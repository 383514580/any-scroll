{"success":true,"data":[{"id":"5cbfd9aca86ae80ce64b3175","author_id":"4f447c2f0a8abae26e01b27d","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>时隔一年，Node.js 12 如约而至，正式发布第一个 <a href=\"https://github.com/nodejs/Release\">Current</a> 版本。</p>\n<p>该版本带来了诸如：</p>\n<ul>\n<li>V8 更新带来好多不错的特性。</li>\n<li>HTTP 解析速度提升。</li>\n<li>启动速度大幅提升。</li>\n<li>更好的诊断报告和堆分析工具。</li>\n<li>ESM 模块更新。</li>\n</ul>\n<p>原文地址：<a href=\"https://medium.com/@nodejs/introducing-node-js-12-76c41a1b3f3f\">https://medium.com/@nodejs/introducing-node-js-12-76c41a1b3f3f</a>\n语雀地址：<a href=\"https://www.yuque.com/egg/nodejs/nodejs-12\">https://www.yuque.com/egg/nodejs/nodejs-12</a></p>\n<h2>LTS vs Current</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/84182/1556074709431-35af45b8-ec7a-4a81-83d8-155eb519f04a.png#align=left&amp;display=inline&amp;height=389&amp;name=image.png&amp;originHeight=500&amp;originWidth=960&amp;size=58313&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>如果你不了解 Node.js 的  Long Term Support 发布策略的话，一定要看看 <a href=\"https://github.com/nodejs/Release\">https://github.com/nodejs/Release</a> 。</p>\n<p>就目前而言，Node.js 6.x 和 8.x 将在 2019 年末结束 LTS 的支持，大家尽快升级到 10.x 吧。</p>\n<h2>快速体验</h2>\n<pre class=\"prettyprint language-bash\"><code>$ nvs add node&#x2F;12\n$ nvs use 12\n$ node -v\nv12.0.0\n</code></pre><p>具体参考这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/63403762\">科普文：使用 nvs 管理本地 Node.js 版本</a></p>\n<h2>V8 更新到 7.4</h2>\n<blockquote>\n<p>大部分情况下，我们不用去考虑性能问题，坐等 V8 版本更新就好了。（大雾）</p>\n</blockquote>\n<p>本次版本更新，也带来了好几个不错的特性：</p>\n<ul>\n<li><a href=\"https://v8.dev/blog/v8-release-72#async-stack-traces\">异步堆栈跟踪</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-74#faster-calls-with-arguments-mismatch\">参数调用不匹配时的调用速度优化</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-73#faster-await\">更快的 await</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-72#javascript-parsing\">更快的 JavaScript 解析速度</a></li>\n</ul>\n<p><strong>同时，跑了下我们 Egg 的一些内部测试，发现序列化有 10~20% 的性能提升，恐怖如斯！</strong></p>\n<p>另，奇丑无比的 <a href=\"https://github.com/tc39/proposal-class-fields\">Private Class Fields</a> 也能用了：</p>\n<pre class=\"prettyprint language-javascript\"><code>class IncreasingCounter {\n  #count = 0;\n  \n  get value() {\n    console.log(&#x27;Getting the current value!&#x27;);\n    return this.#count;\n  }\n  increment() {\n    this.#count++;\n  }\n}\n</code></pre><h2>HTTP 解析速度提升</h2>\n<p>默认的 HTTP 解析器切换为 <a href=\"https://github.com/nodejs/llhttp\">llhttp</a> ，性能提升恐怖如斯：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/84182/1556072499637-686bb0e3-c75c-424c-851f-ad88aff183a2.png#align=left&amp;display=inline&amp;height=231&amp;name=image.png&amp;originHeight=404&amp;originWidth=1302&amp;size=88775&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>启动速度提升</h2>\n<p>通过 <a href=\"https://v8.dev/blog/code-caching\">v8 code cache</a> 的支持，<a href=\"https://github.com/nodejs/node/pull/27161\">在构建时提前为内置库生成代码缓存</a>，从而提升 30% 的启动耗时。\n同时，通过<a href=\"https://github.com/nodejs/node/pull/24950\">重用主进程缓存</a>，Workers Threads 的启动速度提升了 60% 。</p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>Workers Threads</h2>\n<p>在 10.x 已经引入的 <a href=\"https://nodejs.org/api/worker_threads.html\">Workers Threads</a> 特性，在 12.x 里面默认启用，无需使用 <code>--experimental-worker</code> 开启。同时基于上一条的介绍，启动的速度也得到大幅提升。</p>\n<p>相关介绍：<a href=\"https://medium.com/@Trott/using-worker-threads-in-node-js-80494136dbb6\">https://medium.com/@Trott/using-worker-threads-in-node-js-80494136dbb6</a></p>\n<h2>诊断报告</h2>\n<p>提供了新的实验性功能『诊断报告』，一个非常有用的特性。\n可用于帮助分析诸如：崩溃，性能问题，内存泄漏，高 CPU 占用等等问题。详见 <a href=\"https://medium.com/the-node-js-collection/easily-identify-problems-in-node-js-applications-with-diagnostic-report-dc82370d8029\">这篇文章</a>。</p>\n<blockquote>\n<p>点评：这也是 <a href=\"https://www.aliyun.com/product/nodejs\">AliNode</a> 之前的一个卖点之一。</p>\n</blockquote>\n<h2>Heap Dump</h2>\n<p>以前我们分析问题的时候，需要手动安装对应的类库或者使用 AliNode。</p>\n<p>在 12.x 里面内置了该功能，详见：</p>\n<ul>\n<li><a href=\"https://github.com/nodejs/node/pull/27133\">https://github.com/nodejs/node/pull/27133</a></li>\n<li><a href=\"https://github.com/nodejs/node/pull/26501\">https://github.com/nodejs/node/pull/26501</a></li>\n</ul>\n<blockquote>\n<p>点评：又一个 <a href=\"https://www.aliyun.com/product/nodejs\">AliNode</a> 的功能被内置了。但其实影响不大，AliNode 的核心在于分析平台，这块的采集能力，本来他们就打算开源回馈出去的。</p>\n</blockquote>\n<p>同时，由于上述提到的 V8 升级，现在可以按照可用内存动态调整堆大小了。</p>\n<h2>ESM 模块方案更新</h2>\n<p>ES6 模块仍然还在实验阶段，不过有了新的方式，具体参见<a href=\"https://medium.com/@nodejs/announcing-a-new-experimental-modules-1be8d2d6c2ff\">这篇文章</a>。</p>\n<blockquote>\n<p>点评：让子弹再飞一会，该特性真的不是痛点，不急。</p>\n</blockquote>\n<h2>其他更新</h2>\n<ul>\n<li>更好的原生模块支持，<a href=\"https://nodejs.org/api/n-api.html#n_api_n_api\">N-API</a> 升级为版本 4，并 backport 到 Node.js 8.x 和 10.x。详细参见<a href=\"https://medium.com/the-node-js-collection/new-features-bring-native-add-ons-close-to-being-on-par-with-js-modules-cd4f9b8e4b4\">这篇文章</a>。</li>\n<li>TLS 升级为 1.3， <a href=\"https://developer.ibm.com/blogs/openssl-111-has-landed-in-nodejs-master-and-why-its-important-for-nodejs-lts-releases/\">增强安全功能</a>。</li>\n<li>随着 C++ 编译器的更新，现在要求 <code>GCC 6</code> 和 <code>glibc 2.17</code> ，对应的操作系统 Win7 和 macOS 10，详细参见<a href=\"https://github.com/nodejs/node/blob/v12.x/BUILDING.md#platform-list\">这篇文章</a>。</li>\n</ul>\n<p>不过目前 node-gyp 的一些原生模块会编译失败：</p>\n<pre class=\"prettyprint language-bash\"><code>nunjucks@3.2.0 › chokidar@2.1.5 › fsevents@^1.2.7 optional error: Error: Run &quot;sh -c node install&quot; error, exit code 1\n    at ChildProcess.&lt;anonymous&gt; (&#x2F;Users&#x2F;tz&#x2F;.npm-global&#x2F;lib&#x2F;node_modules&#x2F;tnpm&#x2F;node_modules&#x2F;_runscript@1.3.0@runscript&#x2F;index.js:74:21)\n    at ChildProcess.emit (events.js:196:13)\n    at maybeClose (internal&#x2F;child_process.js:1000:16)\n    at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:267:5)\n</code></pre></div>","title":"Node 12 值得关注的新特性","last_reply_at":"2019-06-04T12:12:29.078Z","good":false,"top":true,"reply_count":43,"visit_count":36471,"create_at":"2019-04-24T03:36:12.582Z","author":{"loginname":"atian25","avatar_url":"https://avatars2.githubusercontent.com/u/227713?v=4&s=120"}},{"id":"5bd4772a14e994202cd5bdb7","author_id":"504c28a2e2b845157708cb61","tab":"share","content":"<div class=\"markdown-text\"><p>2018年10月27日晚上，突然收到服务器不能访问的告警通知，拜托了狼叔 <a href=\"/user/i5ting\">@i5ting</a> 帮忙看看，结果登不上也ping不通。\n后来收到短信，发现是被ucloud封了，短信内容如下：</p>\n<blockquote>\n<p>【UCloud】尊敬的UCloud用户，您的IP：123.59.77.142  存在URL ：<a href=\"https://cnodejs.org/topic/57239bce5a26c4a841ecbf01\">https://cnodejs.org/topic/57239bce5a26c4a841ecbf01</a> （详细信息请查看邮箱）包含违禁内容（包括但不限于翻墙等），违反了国家有关法律法规。目前依主管单位要求，对您的IP予以封停，请您尽快处理违规内容。待处理完成后请联系技术支持重新开启业务。[4000188113]</p>\n</blockquote>\n<p>然后联系了ucloud的客服，一下就打通了，对方态度挺好处理问题也快。ucloud说是运营商那边封的，不是他们的检测机制。所以需要联系运营商解决。\n考虑到各位亲爱的网友们的行为我无法控制，那么一直跟越来越严格的审查系统对抗只会让自己疲惫，所以我就站点迁到国外。来到了aws jp。</p>\n<p>我大致测了测，电信和移动的访问速度非常快，100ms以内，联通会慢一点，400ms以内吧。</p>\n<p>建议翻墙访问。</p>\n</div>","title":"服务器迁移至 aws 日本机房","last_reply_at":"2019-06-03T01:29:22.108Z","good":false,"top":true,"reply_count":190,"visit_count":63388,"create_at":"2018-10-27T14:33:14.694Z","author":{"loginname":"alsotang","avatar_url":"https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"}},{"id":"5cf89d971fe902120f31ca23","author_id":"516cc5936d382773065b8e2f","tab":"share","content":"<div class=\"markdown-text\"><p>最近项目需要用到 Base64, 想到npm中找个好用的, 很可惜没一个符合我的预期, 于自己捣鼓一个, 感觉还不错所以分享出来;</p>\n<p><strong>其实我的需求其实很简单:</strong></p>\n<ol>\n<li>浏览器可用; (利用 Buffer 的方法出局);</li>\n<li>支持字符串 (现有的库都支持, 只有 <code>btoa</code> , <code>atob</code> 只支持 <a href=\"https://zh.wikipedia.org/wiki/ISO/IEC_8859-1\">Latin1</a>)</li>\n<li>javascript 字符串无损转换 (因为这一点, 现有库全军覆没), 稍后做说明;</li>\n<li>能用上 <code>Tree-shaking</code> , 因为项目一般只用了Base64的一半功能(<code>encode</code> 或 <code>decode</code>), 我可不想copy代码;</li>\n</ol>\n<h3>为什么不能做到javascript字符串无损转换</h3>\n<p>看一个例子:</p>\n<pre class=\"prettyprint language-js\"><code> var s = &#x27;\\ud800&#x27;; \n var b64 = Buffer.from(s).toString(&#x27;base64&#x27;); \n var _s = Buffer.from(b64, &#x27;base64&#x27;).toString();\n console.log(s == _s); &#x2F;&#x2F;false\n</code></pre><p>为什么最后是 <code>false</code>?<br>\n首先要知道, 字符串编码为base64之前要先转成字节数组, 字节数组再进行 base64 编码, 解码反之, 我们一般都用’utf8’编码字符串;\n再看 <code>U+d800</code> 是一个空码, 从 <code>utf16</code> 来看, 是一个4字节字符的一半, 然而javascript是<a href=\"https://zh.wikipedia.org/wiki/UTF-16#UTF-16%E8%88%87UCS-2%E7%9A%84%E9%97%9C%E4%BF%82\">ucs2</a>编码, 所以它在javascript中是一个正常的字符串;\n<code>Buffer</code> 默认也是以’utf8’编码字符串 , 所以过程是这样 <code>字符串&gt;Unicode&gt;utf8</code>, 字符串 到 Unicode 过和程对于空码, 替换成了一个占位符 ‘�’, 之后的转换过程就跟着错了, 还原回来当然就错了;</p>\n<blockquote>\n<p>反正就认准一点,我一个字符串 出了个门回来就变了 这是不可以的.</p>\n</blockquote>\n<h4>怎么解决:</h4>\n<p>方案1:<br>\n直接用<code>ucs2</code>编码; 省去 字符串 到 Unicode 的过程, 自然不会出问题了;</p>\n<pre class=\"prettyprint language-js\"><code> var s = &#x27;\\ud800&#x27;; \n var b64 = Buffer.from(s,&#x27;ucs2&#x27;).toString(&#x27;base64&#x27;); \n var _s = Buffer.from(b64, &#x27;base64&#x27;).toString(&#x27;ucs2&#x27;);\n console.log(s == _s); &#x2F;&#x2F;true\n</code></pre><blockquote>\n<p>注意: 上面代码里的 ‘ucs2’ 其实是 ‘utf16le’ 的别名.\n但有一个问题, 单字符串中 英文居多时 , 编码后的Base64会比用 “utf8” 的情况长很多;</p>\n</blockquote>\n<p>方案2:<br>\n<code>字符串&gt;Unicode&gt;utf8</code> 的过程不把空码替换, 解码也一样, 这样也可以保证字符串的一至性;\n我写的这个Base64库用的也是这个方案;</p>\n<h3>其它</h3>\n<p>除了上面说的5点, 我还做了一些顺手的功能;</p>\n<ol>\n<li>抽象出 Base64 算法, 支持自定义的 编码表 和 字符串编码方式, 适应更多特殊场景;</li>\n<li>支持字节数组 (既然在都有了 ArrayBuffer/Uint8Array 类型, 为什么不顺便支持一下, 其实比支持字符串更简单吧) , 其实我的项目也没用到;</li>\n</ol>\n<p>GitHub: <a href=\"https://github.com/cnwhy/Base64.js\">cnwhy/Base64.js</a><br>\n详细的使用方法可参看<a href=\"https://blog.whyoop.com/2019/06/03/new-base64/#demo\">这篇</a></p>\n</div>","title":"分享一个自认为不错的基础库 base64","last_reply_at":"2019-06-06T08:50:15.322Z","good":false,"top":false,"reply_count":5,"visit_count":135,"create_at":"2019-06-06T04:59:03.564Z","author":{"loginname":"cnwhy","avatar_url":"https://avatars1.githubusercontent.com/u/4178465?v=4&s=120"}},{"id":"5cf718e995fcc914aa266316","author_id":"5a9783798d6e16e56bb80a34","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FsCv5s_g7ixH7mbfA7xXg1fg41Gw\" alt=\"QQ图片20190605092113.png\"></p>\n<p>RT</p>\n</div>","title":"狼叔的《狼书（卷1）：更了不起的Node.js》有赠书吗？","last_reply_at":"2019-06-06T08:28:34.109Z","good":false,"top":false,"reply_count":6,"visit_count":537,"create_at":"2019-06-05T01:20:41.677Z","author":{"loginname":"OXOYO","avatar_url":"https://avatars3.githubusercontent.com/u/5074207?v=4&s=120"}},{"id":"5cf8ce4d1fe902120f31cbb3","author_id":"5cce5e185a5bae6e07812e27","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FmcYoSEFY2N7dsou77Tb7k0-l2f4\" alt=\"image.png\">\n就是我这段代码，每30条一页，当30名是20分，31名也是20分，到第二页的时候，可能31名就是上一页的30名，，这种情况怎么处理啊。</p>\n</div>","title":"【求助】mongoose 查询排序分页，在同分值的情况下出现重复数据。","last_reply_at":"2019-06-06T08:26:53.526Z","good":false,"top":false,"reply_count":0,"visit_count":24,"create_at":"2019-06-06T08:26:53.526Z","author":{"loginname":"joucksHua","avatar_url":"https://avatars1.githubusercontent.com/u/24910959?v=4&s=120"}},{"id":"5cf8c09795fcc914aa266b24","author_id":"52084df944e76d216ad87698","tab":"ask","content":"<div class=\"markdown-text\"><p>如题</p>\n</div>","title":"ts项目用ts-node跑和编译后用node跑哪个更好?","last_reply_at":"2019-06-06T08:22:54.155Z","good":false,"top":false,"reply_count":1,"visit_count":72,"create_at":"2019-06-06T07:28:23.726Z","author":{"loginname":"duanyunhu","avatar_url":"//gravatar.com/avatar/db53696004ac3d03005abd80f2ddb391?size=48"}},{"id":"5b599f682860af042a2178e9","author_id":"57c8e6f86f7069ce262d0504","tab":"ask","content":"<div class=\"markdown-text\"><p>大概是这样的，我有个需求，需要向某个api 不断的请求，而且数量不小，有点像压力测试吧</p>\n<pre class=\"prettyprint\"><code>const fetch = require(&#x27;node-fetch&#x27;);\nconst funs = async () =&gt; {\n  const now = Date.now();\n  await fetch(&#x27;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#x27;);\n console.log(i, &#96;start:${now}&#96;, &#96;end:${Date.now()}&#96;, &#96;use:${Date.now() - now}&#96;);\n};\n</code></pre><p>在我的机器上跑，发现  同时跑 10、100、1000得到的结果时间相差太多</p>\n<pre class=\"prettyprint\"><code> for (let i = 0; i &lt; 10; i += 1) {\n   funs(i);\n }\n &#x2F;&#x2F; funs log的时间大概是 80-100ms 递增\n \n for (let i = 0; i &lt; 100; i += 1) {\n   funs(i);\n }\n &#x2F;&#x2F; funs log的时间大概是 500-800ms 递增\n \n for (let i = 0; i &lt; 1000; i += 1) {\n   funs(i);\n }\n &#x2F;&#x2F; funs log的时间大概是 1000-5000ms 递增\n</code></pre><h6>部分评论的尝试</h6>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;01，尝试设置maxSockets \nhttps.globalAgent.maxSockets = 1000;\nhttps.globalAgent.maxFreeSockets = 1000;\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F;02，用原生https尝试设置new Agent  \nconst https = require(&#x27;https&#x27;);\nconst $get = (i) =&gt; {\n  const now = Date.now();\n  const agent = new https.Agent();\n  const options = {\n    hostname: &#x27;www.baidu.com&#x27;,\n    port: 443,\n    method: &#x27;GET&#x27;,\n    agent: false, &#x2F;&#x2F; agent\n  };\n  https.get(options, () =&gt; {\n    console.log(i, &#96;start:${now}&#96;, &#96;end:${Date.now()}&#96;, &#96;use:${Date.now() - now}&#96;);\n  }).on(&#x27;error&#x27;, () =&gt; {\n    console.log(i, &#96;start:${now}&#96;, &#96;end:${Date.now()}&#96;, &#96;use:${Date.now() - now}&#96;);\n  });\n};\n\nfor (let i = 0; i &lt; 1000; i += 1) {\n  $get(i);\n}\n&#x2F;&#x2F;结果还是没变化\n</code></pre><h5>不明白造成请求的时间变长的具体原因是啥？</h5>\n<p>瞎猜1 node有类似浏览器一样有请求数限制？</p>\n<p>瞎猜2 TCP链接数限制？</p>\n<h5>希望能解决： 10000并发以内不会出现大幅度延迟</h5>\n<h4>有没有大佬帮忙解惑？</h4>\n</div>","title":"node发出的请求数多了，整体响应变慢，不清处影响的因素是什么，求解惑。","last_reply_at":"2019-06-06T07:19:27.355Z","good":false,"top":false,"reply_count":37,"visit_count":3586,"create_at":"2018-07-26T10:16:08.459Z","author":{"loginname":"THROFHR","avatar_url":"https://avatars1.githubusercontent.com/u/13469743?v=4&s=120"}},{"id":"5cf88bfc95fcc914aa2669c0","author_id":"5cdfdf21518e0954fc40f6b3","tab":"ask","content":"<div class=\"markdown-text\"><p>请问如何打包项目成windows上的可执行文件，并能加入系统服务，最好还能修改注册表。而且不能用到第三方软件。</p>\n</div>","title":"如何打包项目成windows上的可执行文件，并能加入系统服务","last_reply_at":"2019-06-06T06:58:16.015Z","good":false,"top":false,"reply_count":2,"visit_count":149,"create_at":"2019-06-06T03:43:56.559Z","author":{"loginname":"xxzrua","avatar_url":"https://avatars3.githubusercontent.com/u/26266717?v=4&s=120"}},{"id":"5ce8a1134036f24194cf66f8","author_id":"5ce89ae04036f24194cf66ca","tab":"ask","content":"<div class=\"markdown-text\"><p>最近小弟在忙毕业设计的事，在使用nodejs搭建代理服务器的时候遇到了一些问题，希望有能解决的大佬帮帮忙\n代理服务器地址：<a href=\"https://github.com/TheRest0/HttpsToHttp\">https://github.com/TheRest0/HttpsToHttp</a>\n本意呢，就是一个前端劫持的操作，也是看了一个博客学习的，博客链接俺也不知道能不能发就先不发了，大体意思呢就是给https的链接进行降域编程http，\n<img src=\"//static.cnodejs.org/FrdWS0YpbGIeEsuaD7hhjbFUiHSA\" alt=\"之前.png\">\n之前呢是这个版本，设置好浏览器服务器之后运行这个脚本，就可以正常访问http的网页了，但https的不行，传输不了数据，于是我盲目的找了一下，发现可能是证书的问题，就有了现在这个版本\n<img src=\"//static.cnodejs.org/FtBiMF94ysVY9zknjvle2rZ5iZZc\" alt=\"之后.png\">\n现在这个版本呢我更改了一些内容，发现连http的都不能上了，就一直在转圈圈，咱也不知道咋回事，但咱得问问，要是哪位大佬碰巧懂这个东西，恳请您帮帮我这个即将毕业的小老弟，万分感谢！！！</p>\n</div>","title":"使用Node.JS搭建代理服务器遇到的问题，呼叫大佬呼叫大佬","last_reply_at":"2019-06-06T06:49:16.982Z","good":false,"top":false,"reply_count":4,"visit_count":957,"create_at":"2019-05-25T01:57:39.770Z","author":{"loginname":"TheRest0","avatar_url":"https://avatars1.githubusercontent.com/u/34371402?v=4&s=120"}},{"id":"5cf88a0b1fe902120f31c9c8","author_id":"550a97f53135610a365b0307","tab":"ask","content":"<div class=\"markdown-text\"><p>最近一段时间在做 Eggjs 相关的项目，关于单机部署有一些疑问:</p>\n<p>该如何做到服务不中断更新呢？</p>\n<p>最原始的更新方式是： 代码更新、服务重启，这段时间用户服务是中断的体验不好。\n我想到的优化方案是：\nNginx 在前边做一层负载，服务器下做启动两个服务端口分别是 9000 和 9001，\n部署的时候，\nNginx 去掉 9000 的负载，重启 Nginx；9000 端口停止服务，代码更新，重启 Eggjs；\nNginx 加上 9000 的负载，关闭 9001 的负载；9001 端口停止服务，代码更新，重启 Eggjs；\nNginx 加上 9001 的负载，重启 Nginx；\n更新完成。</p>\n<p>这样操作有两个问题：一是操作极其繁琐，二是 Eggjs 服务器里有初始化和定时任务，如果做负载的话，代码上还要做区分，感觉还是不够优雅。\n诸位有什么比较优雅的解决方式吗？</p>\n</div>","title":"关于 Node 部署更新的一些探讨","last_reply_at":"2019-06-06T06:01:18.455Z","good":false,"top":false,"reply_count":5,"visit_count":191,"create_at":"2019-06-06T03:35:39.387Z","author":{"loginname":"Sirormy","avatar_url":"https://avatars0.githubusercontent.com/u/6128447?v=4&s=120"}},{"id":"5cef810f4036f24194cf7e80","author_id":"5976b9b80c87675e74674819","tab":"ask","content":"<div class=\"markdown-text\"><p>写了一个定时任务，如下：\nconst schedule = require(‘node-schedule’);\nlet rule2 = new schedule.RecurrenceRule();\nrule2.hour = [1,2,3,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23];\nrule2.minute = [3,8,13,18,23,28,33,38,43,48,53,58];\nrule2.second = 1;\nschedule.scheduleJob(rule2, function(){ // 每隔5分钟\n<a href=\"http://lightLog.info\">lightLog.info</a>(‘pid:’, process.pid,“定时产生数据”);\nrequire(’…/cron/GenNum.js’)();\n});</p>\n<p>每隔一段时间（时间随机）会，在执行定时任务的时候，会执行两次，请问是为什么？？？下面是打印的结果</p>\n<p><img src=\"//static.cnodejs.org/FljzILf-IFt-DY0sVhV3XvVK4wLE\" alt=\"image.png\"></p>\n</div>","title":"定时任务为什么会执行两次，很奇怪，有没有大神知道是什么原因？？？","last_reply_at":"2019-06-06T03:29:49.870Z","good":false,"top":false,"reply_count":14,"visit_count":1000,"create_at":"2019-05-30T07:06:55.680Z","author":{"loginname":"quanpf2481","avatar_url":"https://avatars3.githubusercontent.com/u/30330930?v=4&s=120"}},{"id":"5cf883051fe902120f31c97c","author_id":"594b5dff984e31dd458c1325","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://marketplace.visualstudio.com/items?itemName=Rwing.minesweeper\">https://marketplace.visualstudio.com/items?itemName=Rwing.minesweeper</a>\n在命令面板 (Ctrl+Shift+P) 里执行 minesweeper\n感谢原本js游戏的作者，我只是包装了一下。\n<img src=\"//static.cnodejs.org/FnDVzf1XM6ELzfhmoEmpuV953lZV\" alt=\"screenshot[1].png\"></p>\n</div>","title":"说起 VSCode 摸鱼，之前我也随便包装了一个扫雷游戏的。。。。","last_reply_at":"2019-06-06T03:05:41.586Z","good":false,"top":false,"reply_count":0,"visit_count":150,"create_at":"2019-06-06T03:05:41.586Z","author":{"loginname":"Rwing","avatar_url":"https://avatars0.githubusercontent.com/u/497333?v=4&s=120"}},{"id":"5cf5296b95fcc914aa265c77","author_id":"5b0eaaf38a4f51e140d9437d","tab":"share","content":"<div class=\"markdown-text\"><h2>需求背景</h2>\n<p>实现全链路日志追踪，便于日志监控、问题排查、接口响应耗时数据统计等，首先 API 接口服务接收到调用方请求，根据调用方传的 traceId，在该次调用链中处理业务时，如需打印日志的，日志信息按照约定的规范进行打印，并记录 traceId，实现日志链路追踪。</p>\n<ul>\n<li><strong>日志路径约定</strong></li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;var&#x2F;logs&#x2F;${projectName}&#x2F;bizLog&#x2F;${projectName}-yyyyMMdd.log\n</code></pre><ul>\n<li><strong>日志格式约定</strong></li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>日志时间[]traceId[]服务端IP[]客户端IP[]日志级别[]日志内容\n</code></pre><p>采用 Egg.js 框架 egg-logger 中间件，在实现过程中发现对于按照以上日志格式打印是无法满足需求的（至少目前我还没找到可实现方式），如果要自己实现，可能要自己造轮子了，好在官方的  egg-logger 中间件提供了自定义日志扩展功能，参考 <a href=\"https://eggjs.org/zh-cn/core/logger.html#%E9%AB%98%E7%BA%A7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97\">高级自定义日志</a>，本身也提供了日志分割、多进程日志处理等功能。</p>\n<p>egg-logger 提供了多种传输通道，我们的需求主要是对请求的业务日志自定义格式存储，主要用到 fileTransport 和 consoleTransport 两个通道，分别打印日志到文件和终端。</p>\n<h2>自定义日志插件开发</h2>\n<p>基于 egg-logger 定制开发一个插件项目，参考 <a href=\"https://eggjs.org/zh-cn/advanced/plugin.html\">插件开发</a>，以下以 egg-logger-custom 为项目，展示核心代码编写</p>\n<ul>\n<li><strong>编写logger.js</strong></li>\n</ul>\n<blockquote>\n<p>egg-logger-custom/lib/logger.js</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>const moment = require(&#x27;moment&#x27;);\nconst FileTransport = require(&#x27;egg-logger&#x27;).FileTransport;\nconst utils = require(&#x27;.&#x2F;utils&#x27;);\nconst util = require(&#x27;util&#x27;);\n\n&#x2F;**\n * 继承 FileTransport\n *&#x2F;\nclass AppTransport extends FileTransport {\n    constructor(options, ctx) {\n        super(options);\n\n        this.ctx = ctx; &#x2F;&#x2F; 得到每次请求的上下文\n    }\n\n    log(level, args, meta) {\n        &#x2F;&#x2F; 获取自定义格式消息\n        const customMsg = this.messageFormat({\n            level,\n        });\n\n        &#x2F;&#x2F; 针对 Error 消息打印出错误的堆栈\n        if (args[0] instanceof Error) {\n            const err = args[0] || {};\n            args[0] = util.format(&#x27;%s: %s\\n%s\\npid: %s\\n&#x27;, err.name, err.message, err.stack, process.pid);\n        } else {\n            args[0] = util.format(customMsg, args[0]);\n        }\n\n        &#x2F;&#x2F; 这个是必须的，否则日志文件不会写入\n        super.log(level, args, meta);\n    }\n\n    &#x2F;**\n     * 自定义消息格式\n     * 可以根据自己的业务需求自行定义\n     * @param { String } level\n     *&#x2F;\n    messageFormat({\n        level\n    }) {\n        const { ctx } = this;\n        const params = JSON.stringify(Object.assign({}, ctx.request.query, ctx.body));\n\n        return [\n            moment().format(&#x27;YYYY&#x2F;MM&#x2F;DD HH:mm:ss&#x27;),\n            ctx.request.get(&#x27;traceId&#x27;),\n            utils.serviceIPAddress,\n            utils.clientIPAddress(ctx.req),\n            level,\n        ].join(utils.loggerDelimiter) + utils.loggerDelimiter;\n    }\n}\n\nmodule.exports = AppTransport;\n</code></pre><ul>\n<li><strong>工具</strong></li>\n</ul>\n<blockquote>\n<p>egg-logger-custom/lib/utils.js</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>const interfaces = require(&#x27;os&#x27;).networkInterfaces();\n\nmodule.exports = {\n\n    &#x2F;**\n     * 日志分隔符\n     *&#x2F;\n    loggerDelimiter: &#x27;[]&#x27;,\n\n    &#x2F;**\n     * 获取当前服务器IP\n     *&#x2F;\n    serviceIPAddress: (() =&gt; {\n        for (const devName in interfaces) {\n            const iface = interfaces[devName];\n\n            for (let i = 0; i &lt; iface.length; i++) {\n                const alias = iface[i];\n\n                if (alias.family === &#x27;IPv4&#x27; &amp;&amp; alias.address !== &#x27;127.0.0.1&#x27; &amp;&amp; !alias.internal) {\n                    return alias.address;\n                }\n            }\n        }\n    })(),\n\n    &#x2F;**\n     * 获取当前请求客户端IP\n     * 不安全的写法\n     *&#x2F;\n    clientIPAddress: req =&gt; {\n        const address = req.headers[&#x27;x-forwarded-for&#x27;] || &#x2F;&#x2F; 判断是否有反向代理 IP\n        req.connection.remoteAddress || &#x2F;&#x2F; 判断 connection 的远程 IP\n        req.socket.remoteAddress || &#x2F;&#x2F; 判断后端的 socket 的 IP\n        req.connection.socket.remoteAddress;\n\n        return address.replace(&#x2F;::ffff:&#x2F;ig, &#x27;&#x27;);\n    },\n\n    clientIPAddress: ctx =&gt; {    \n        return ctx.ip;\n    },\n}\n</code></pre><p><strong>注意</strong>：以上获取当前请求客户端IP的方式，如果你需要对用户的 IP 做限流、防刷限制，请不要使用如上方式，参见 <a href=\"https://www.yuque.com/egg/nodejs/coopsc\">科普文：如何伪造和获取用户真实 IP ？</a>，在 Egg.js 里你也可以通过 ctx.ip 来获取，参考 <a href=\"https://eggjs.org/zh-cn/tutorials/proxy.html\">前置代理模式</a>。</p>\n<ul>\n<li><strong>初始化 Logger</strong></li>\n</ul>\n<pre class=\"prettyprint\"><code>egg-logger-custom&#x2F;app.js\n</code></pre><pre class=\"prettyprint language-js\"><code>const Logger = require(&#x27;egg-logger&#x27;).Logger;\nconst ConsoleTransport = require(&#x27;egg-logger&#x27;).ConsoleTransport;\nconst AppTransport = require(&#x27;.&#x2F;app&#x2F;logger&#x27;);\n\nmodule.exports = (ctx, options) =&gt; {\n    const logger = new Logger();\n\n    logger.set(&#x27;file&#x27;, new AppTransport({\n        level: options.fileLoggerLevel || &#x27;INFO&#x27;,\n        file: &#96;&#x2F;var&#x2F;logs&#x2F;${options.appName}&#x2F;bizLog&#x2F;${options.appName}.log&#96;,\n    }, ctx));\n\n    logger.set(&#x27;console&#x27;, new ConsoleTransport({\n        level: options.consoleLevel || &#x27;INFO&#x27;,\n    }));\n\n    return logger;\n}\n</code></pre><p>以上对于日志定制格式开发已经好了，如果你有实际业务需要可以根据自己团队的需求，封装为团队内部的一个 npm 中间件来使用。</p>\n<h2>项目扩展</h2>\n<p>自定义日志中间件封装好之后，在实际项目应用中我们还需要一步操作，Egg 提供了 <a href=\"https://eggjs.org/zh-cn/basics/extend.html\">框架扩展</a> 功能，包含五项：Application、Context、Request、Response、Helper，可以对这几项进行自定义扩展，对于日志因为每次日志记录我们需要记录当前请求携带的 traceId 做一个链路追踪，需要用到 Context（是 Koa 的请求上下文） 扩展项。</p>\n<p>新建 <code>app/extend/context.js</code> 文件</p>\n<pre class=\"prettyprint language-js\"><code>const AppLogger = require(&#x27;egg-logger-custom&#x27;); &#x2F;&#x2F; 上面定义的中间件\n\nmodule.exports = {\n    get logger() { &#x2F;&#x2F; 名字自定义 也可以是 customLogger\n        return AppLogger(this, {\n            appName: &#x27;test&#x27;, &#x2F;&#x2F; 项目名称\n            consoleLevel: &#x27;DEBUG&#x27;, &#x2F;&#x2F; 终端日志级别\n            fileLoggerLevel: &#x27;DEBUG&#x27;, &#x2F;&#x2F; 文件日志级别\n        });\n    }\n}\n</code></pre><p><strong>建议</strong>：对于日志级别，可以采用配置中心如 Consul 进行配置，上线时日志级别设置为 INFO，当需要生产问题排查时，可以动态开启 DEBUG 模式。关于 Consul 可以关注我之前写的 <a href=\"https://www.nodejs.red/#/microservice/consul\">服务注册发现 Consul 系列</a></p>\n<h2>项目应用</h2>\n<p>错误日志记录，直接会将错误日志完整堆栈信息记录下来，并且输出到 errorLog 中，为了保证异常可追踪，必须保证所有抛出的异常都是 Error 类型，因为只有 Error 类型才会带上堆栈信息，定位到问题。</p>\n<pre class=\"prettyprint language-js\"><code>const Controller = require(&#x27;egg&#x27;).Controller;\n\nclass ExampleController extends Controller {\n    async list() {\n        const { ctx } = this;\n\n        ctx.logger.error(new Error(&#x27;程序异常！&#x27;));\n\n        ctx.logger.debug(&#x27;测试&#x27;);\n\n        ctx.logger.info(&#x27;测试&#x27;);\n    }\n}\n</code></pre><p>最终日志打印格式如下所示：</p>\n<pre class=\"prettyprint\"><code>2019&#x2F;05&#x2F;30 01:50:21[]d373c38a-344b-4b36-b931-1e8981aef14f[]192.168.1.20[]221.69.245.153[]INFO[]测试\n</code></pre><h2>contextFormatter自定义日志格式</h2>\n<p>Egg-Logger 最新版本支持通过 contextFormatter 函数自定义日志格式，参见之前 <a href=\"https://github.com/eggjs/egg-logger/pull/51\">PR：support contextFormatter #51</a></p>\n<p>应用也很简单，通过配置 contextFormatter 函数即可，以下是简单的应用</p>\n<pre class=\"prettyprint language-js\"><code>config.logger = {\n    contextFormatter: function(meta) {\n        console.log(meta);\n        return [\n            meta.date,\n            meta.message\n        ].join(&#x27;[]&#x27;)\n    },\n    ...\n};\n</code></pre><p>同样的在你的业务里对于需要打印日志的地方，和之前一样</p>\n<pre class=\"prettyprint language-js\"><code>ctx.logger.info(&#x27;这是一个测试数据&#x27;);\n</code></pre><p>输出结果如下所示：</p>\n<pre class=\"prettyprint\"><code>2019-06-04 12:20:10,421[]这是一个测试数据\n</code></pre><h2>日志切割</h2>\n<p>框架提供了 <a href=\"https://github.com/eggjs/egg-logrotator\">egg-logrotator</a> 中间件，默认切割为按天切割，其它方式可参考官网自行配置。</p>\n<ul>\n<li><strong>框架默认日志路径</strong></li>\n</ul>\n<blockquote>\n<p>egg-logger 模块 lib/egg/config/config.default.js</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>config.logger = {\n    dir: path.join(appInfo.root, &#x27;logs&#x27;, appInfo.name),\n    ...\n};\n</code></pre><ul>\n<li><strong>自定义日志目录</strong></li>\n</ul>\n<p>很简单按照我们的需求在项目配置文件重新定义 logger 的 dir 路径</p>\n<pre class=\"prettyprint language-js\"><code>config.logger = {\n    dir: &#x2F;var&#x2F;logs&#x2F;test&#x2F;bizLog&#x2F;\n}\n</code></pre><p>这样是否就可以呢？按照我们上面自定义的日志文件名格式（<code>${projectName}-yyyyMMdd.log</code>），貌似是不行的，在日志分割过程中默认的文件名格式为 <code>.log.YYYY-MM-DD</code>，参考源码</p>\n<blockquote>\n<p><a href=\"https://github.com/eggjs/egg-logrotator/blob/master/app/lib/day_rotator.js\">https://github.com/eggjs/egg-logrotator/blob/master/app/lib/day_rotator.js</a></p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code> _setFile(srcPath, files) {\n    &#x2F;&#x2F; don&#x27;t rotate logPath in filesRotateBySize\n    if (this.filesRotateBySize.indexOf(srcPath) &gt; -1) {\n      return;\n    }\n\n    &#x2F;&#x2F; don&#x27;t rotate logPath in filesRotateByHour\n    if (this.filesRotateByHour.indexOf(srcPath) &gt; -1) {\n      return;\n    }\n\n    if (!files.has(srcPath)) {\n      &#x2F;&#x2F; allow 2 minutes deviation\n      const targetPath = srcPath + moment()\n        .subtract(23, &#x27;hours&#x27;)\n        .subtract(58, &#x27;minutes&#x27;)\n        .format(&#x27;.YYYY-MM-DD&#x27;); &#x2F;&#x2F; 日志格式定义\n      debug(&#x27;set file %s =&gt; %s&#x27;, srcPath, targetPath);\n      files.set(srcPath, { srcPath, targetPath });\n    }\n }\n</code></pre><ul>\n<li><strong>日志分割扩展</strong></li>\n</ul>\n<p>中间件 <a href=\"https://github.com/eggjs/egg-logrotator\">egg-logrotator</a> 预留了扩展接口，对于自定义的日志文件名，可以用框架提供的 app.LogRotator 做一个定制。</p>\n<blockquote>\n<p>app/schedule/custom.js</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>const moment = require(&#x27;moment&#x27;);\n\nmodule.exports = app =&gt; {\n    const rotator = getRotator(app);\n\n    return {\n        schedule: {\n            type: &#x27;worker&#x27;, &#x2F;&#x2F; only one worker run this task\n            cron: &#x27;1 0 0 * * *&#x27;, &#x2F;&#x2F; run every day at 00:00\n        },\n        async task() {\n            await rotator.rotate();\n        }\n    };\n};\n\nfunction getRotator(app) {\n    class CustomRotator extends app.LogRotator {\n        async getRotateFiles() {\n            const files = new Map();\n            const srcPath = &#96;&#x2F;var&#x2F;logs&#x2F;test&#x2F;bizLog&#x2F;test.log&#96;;\n            const targetPath = &#96;&#x2F;var&#x2F;logs&#x2F;test&#x2F;bizLog&#x2F;test-${moment().subtract(1, &#x27;days&#x27;).format(&#x27;YYYY-MM-DD&#x27;)}.log&#96;;\n            files.set(srcPath, { srcPath, targetPath });\n            return files;\n        }\n    }\n\n    return new CustomRotator({ app });\n}\n</code></pre><p>经过分割之后文件展示如下：</p>\n<pre class=\"prettyprint language-bash\"><code>$ ls -lh &#x2F;var&#x2F;logs&#x2F;test&#x2F;bizLog&#x2F;\ntotal 188K\n-rw-r--r-- 1 root root 135K Jun  1 11:00 test-2019-06-01.log\n-rw-r--r-- 1 root root  912 Jun  2 09:44 test-2019-06-02.log\n-rw-r--r-- 1 root root  40K Jun  3 11:49 test.log\n</code></pre><p><strong>扩展</strong>：基于以上日志格式，可以采用 ELK 做日志搜集、分析、检索。</p>\n<h2>阅读推荐</h2>\n<ul>\n<li>侧重于Nodejs服务端技术栈：<a href=\"https://www.nodejs.red\">https://www.nodejs.red</a></li>\n<li>公众号：Nodejs技术栈</li>\n</ul>\n</div>","title":"基于Egg框架的日志链路追踪实践分享","last_reply_at":"2019-06-06T02:57:38.081Z","good":false,"top":false,"reply_count":14,"visit_count":655,"create_at":"2019-06-03T14:06:35.182Z","author":{"loginname":"Q-Angelo","avatar_url":"https://avatars0.githubusercontent.com/u/17956058?v=4&s=120"}},{"id":"5ceca8f852ccb64168ba811d","author_id":"5ceca6e14036f24194cf7182","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FmAjYTYlRr6nGs9y2a9NI19jUvLK\" alt=\"1.png\"></p>\n<blockquote>\n<p>一个摸鱼看书神器</p>\n</blockquote>\n<h3>地址</h3>\n<ul>\n<li><a href=\"https://github.com/cteams/Thief-Book\">https://github.com/cteams/Thief-Book</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=C-TEAM.thief-book\">https://marketplace.visualstudio.com/items?itemName=C-TEAM.thief-book</a></li>\n</ul>\n<h3>默认配置</h3>\n<blockquote>\n<p>需要填写 TXT小说 路径才可以使用此插件</p>\n</blockquote>\n<ul>\n<li>当前页数：1</li>\n<li>每页长度：50</li>\n<li>TXT绝对路径：空</li>\n</ul>\n<h3>快捷键</h3>\n<blockquote>\n<p>没有设置TXT小说的本地绝对路径，会报错，会提示设置路径</p>\n</blockquote>\n<p><code>cmd+m</code> 老板键 。 随机显示不同语言的 Hello World ，随时可用</p>\n<p><code>cmd+,</code> 上一页 。 文本聚焦(编辑代码)的时候，才可以使用</p>\n<p><code>cmd+.</code> 下一页 。 文本聚焦(编辑代码)的时候，才可以使用</p>\n</div>","title":"VSCode 上一款真正的摸鱼神器： Thief-Book","last_reply_at":"2019-06-06T00:58:29.077Z","good":false,"top":false,"reply_count":17,"visit_count":2347,"create_at":"2019-05-28T03:20:24.270Z","author":{"loginname":"lauixData","avatar_url":"https://avatars1.githubusercontent.com/u/9290546?v=4&s=120"}},{"id":"5cf076ce52ccb64168ba90f8","author_id":"5c85d4b2acb681372d416dd6","tab":"share","content":"<div class=\"markdown-text\"><h2>资讯：原美图技术副总裁洪小军加入 AfterShip 出任 CTO。</h2>\n<p>欢迎各位加入。可在拉勾或者 boss 搜索 aftership 了解详细的岗位，或者直接发 CV 到我们的邮箱： <a href=\"mailto:xh.wang@aftership.com\">xh.wang@aftership.com</a></p>\n<p>洪小军的职业生涯历经飞信、微博、美图这几个公司的关键发展历程，完整的经历了移动互联网发展的十年，今天我们有机会采访到他，聊他这一次的职业选择，同时也进一步了解他选择的这家公司。</p>\n<h2>洪小军是谁？— AfterShip CTO</h2>\n<h2>曾任：</h2>\n<p>美图 技术副总裁</p>\n<p>微博 平台架构团队负责人</p>\n<p>中国移动飞信 架构师</p>\n<h2>技术影响力：</h2>\n<p>厦门 TGO 鲲鹏会第一任会长</p>\n<p>全球架构师峰会优秀出品人</p>\n<p>顶级技术大会分享议题和出品专题</p>\n<p>[全球软件开发大会 /全球架构师峰会 /全球互联网架构大会]</p>\n<p>“对于我而言，虽然技术一直是舒适区，但是我也期望在产品、市场、客户等很多领域都能有所突破，创造更大的价值。“ — AfterShip CTO 洪小军</p>\n<h2>AfterShip 是做什么的？</h2>\n<p>AfterShip （爱客科技）：是一个为国际性电商企业而设的 B2B 的 SaaS 平台，通过提供全方位和全自动化的工具，帮助电商降低营运成本及实现智能营销。公司全自动化系统涵盖市场推广、订单管理、运单打印、快递跟踪及退换货管理等。</p>\n<h2>这家公司有多厉害呢？</h2>\n<p>支持 30 多种语言 覆盖 200 多个国家 对接 500 多家快递公司 为 Amazon, eBay, Wish, IKEA 等 全球 100,000 多家企业提供服务</p>\n<p>Google 搜索“包裹跟踪” 排名第一就是这家公司</p>\n<p>So，在核心技术备受瞩目的今天 AfterShip 是如何从创业公司起步， 最后跻身成为 国际包裹查询的龙头企业呢？ 每年营收翻番的背后， 又有怎样的用人之道呢？</p>\n<h2>听小军讲 AfterShip 过硬技术背后的独特魅力</h2>\n<h3>Q1：为什么选择的是 AfterShip 呢？</h3>\n<p>小军：创业⼀直是我的梦想，同时我这一次的职业选择是综合行业发展趋势、⼈才发展方向和团队氛围综合考虑的，而 AfterShip 跟我的想法⽐较契合。</p>\n<p>海外有超过 500 万家以上的电商企业，面向这个领域的 SaaS 有很大的市场空间，AfterShip 在物流跟踪等领域已经做到全球领先，并且也取得很好的客户信任度，这很有利于接下来更进一步开拓市场及其为客户提供更全方位的服务。这个阶段的公司给到个人和团队的机会都比较多。 除此之外，公司对技术的要求和团队氛围我也比较看重。很多优秀的技术⼈会有一些好的习惯和做事方式，在好的技术氛围⾥在能带来新的成长和突破。</p>\n<h3>Q2：对于你管理的团队，你是怎么去做团队技术氛围建设的？</h3>\n<p>小军：要让团队成员有更多的成长空间，要让员工工作起来有成就感。</p>\n<p>一方面在组建团队的时候，我会考虑队员之间的优势互补，同时会指出个人的一些不足，挖掘每个人的优点，给他们空间去成长和创造价值，帮助团队成员分析梳理个人规划。</p>\n<p>另一方面通过在公司内部构建体系化分享和交流氛围，带动公司内部形成很好的技术交流和学习氛围。比如牵头组织持续的高质量技术文章输出，推动公司更多人去顶级技术大会分享议题等。</p>\n<h3>Q3：加入这家公司，你接下来对自己的定位是什么？</h3>\n<p>小军：从发展的角度来看，具有多领域知识和经验，并具有国际化视野的复合型人才将会是未来所需要的核⼼人才。在未来也期望⾃己是更加复合型的⼈，在技术之外，期望在产品、市场、客户等很多领域都能有所突破，并且也让⾃己也更加国际化。</p>\n<h3>Q4：可以说几点 AfterShip 跟其他公司不同的地方吗？</h3>\n<p>1、公司 CEO Teddy 本身是一个极具极客精神的⼯程师，因⽽公司的⼯程师⽂化比较好，崇尚开源，并且有浓厚的⼯具化文化。公司具有多元文化，不断在探索如何实现中⻄方文化的优势互补，对于团队建设和个⼈成⻓也都会有优势。</p>\n<p>2、公司 2012 年成⽴⾄今成⽴ 7 年的时间，是没有销售团队，也没有做任何的付费推⼴之类的。但是从 2014 年开始盈利，并且做到了细分领域的第一，现在合作的包含⼀些国际知名平台和品牌，⽐如说:Amazon, Wish, eBay, Yahoo, IKEA, PUMA 等。这⼀点跟国内的大多数公司都不太一样。</p>\n<h3>Q5：团队情况现在是怎么样的？</h3>\n<p>小军：在香港、深圳和印度都有团队，团队成员有来自十几个不同国家的。</p>\n<h3>Q6：那 AfterShip 是怎么吸引更多的牛人呢？</h3>\n<p>小军：除了帮助员工成长，让他有一个好的发展空间之外，我们在企业福利方面给了员工跟多的选择权。比如：办公设备标配 Apple MacBook Pro+LG 真 4K 显示器、不限额学习成长基金、每月的团队聚餐基金、每天下午茶、定期体检和不定期外出旅游、可以使用各种国际正版付费工具等。</p>\n<h3>Q7：除了福利待遇方面，在 AfterShip 工作还会有哪些收获？</h3>\n<p>小军：当前公司业务正处于快速发展的阶段，在这个时间加入我们其实是一个很好的机会，可以有机会和公司共同成长。</p>\n<p>在这里，可以和一群有极客精神的小伙伴共事，体验纯正的开源和工程师文化。并且开发的是全球性项目，有很多机会去学习新的技术，可以拓展个人的技术视野和能力。</p>\n<h3>Q8：那你们对人才的要求是怎么样的呢？</h3>\n<p>小军：我们服务的客户既包括 Amazon, eBay 等⼤客户，也包括⼤量的⻓尾客户，极致的产品细节优化、体验优化和自动化⼀直是我们公司的产品核⼼竞争力，所以我们对代码的质量和产品开发流程⾮常的重视，倡导通过⼯具来量解决更多问题，让整体更加自动化。 所以我们希望加⼊我们的⼩伙伴他有技术热情，有快速的学习能⼒，可以不断去提升他的各⽅面能⼒，来更好帮助公司和让⾃己更快的成长。</p>\n<h3>Q9：你对即将去新的环境工作的人有什么建议？</h3>\n<p>小军：每个人在成长的过程中都会面临很多新的发展机会，会面临岗位和工作内容的变化，在做选择之前，需要对于即将面临选择的新岗位有更清晰全面的认知，同时也需要提前去为新岗位做尽可能多的准备工作，迎接新的岗位后也需要尽快做好角色转变。</p>\n<p>机会总是更倾向于给有准备的人。一些大公司比如 Google, Facebook 招人有个很关键的评估标准是：“你是不是已经在过去的半年或者一年里，按照下一个级别的标准在工作。”</p>\n<p>所以不仅仅是要站在所处的岗位级别去思考问题，至少要站在下一级甚至更下一级去思考问题。</p>\n<h2>没有过硬的技术终究会“昙花一现”。而过硬的技术，始终是 AfterShip 的核心竞争力。</h2>\n<p>人才是企业的第一资源。识别人才，给人才提供舒适的工作氛围，更多的学习机会，从而发挥人才的作用，企业才能更好的发展。 AfterShip 在这两方面都尽心在做。相信 AfterShip 在未来会走的更远。</p>\n</div>","title":"这家前美图技术副总裁入职的公司值得你关注","last_reply_at":"2019-06-06T00:58:07.787Z","good":false,"top":false,"reply_count":13,"visit_count":1629,"create_at":"2019-05-31T00:35:26.404Z","author":{"loginname":"wangxihua916","avatar_url":"https://avatars0.githubusercontent.com/u/37897167?v=4&s=120"}},{"id":"5cecab2a52ccb64168ba813e","author_id":"5acf8345464b1bfa6b4250a4","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Frhz_1GMKGQHgPvcrmbVW4ReDnhD\" alt=\"1.jpg\">\n<img src=\"//static.cnodejs.org/Fv6KarXVa4nvWdvzb-rzItLfr3Ei\" alt=\"2.jpg\">\n<img src=\"//static.cnodejs.org/Ft20fpv7ot8i9TV1S6YBI2-FX0Am\" alt=\"3.jpg\"></p>\n</div>","title":"《更了不起的Nodejs》最新情况,期待正式上市","last_reply_at":"2019-06-05T23:26:34.064Z","good":false,"top":false,"reply_count":16,"visit_count":1453,"create_at":"2019-05-28T03:29:46.387Z","author":{"loginname":"pzzcn","avatar_url":"https://avatars1.githubusercontent.com/u/34960683?v=4&s=120"}},{"id":"5cecb8584036f24194cf7223","author_id":"5ce3b918e57aac76fed2ca3a","tab":"ask","content":"<div class=\"markdown-text\"><p>服务器存了很多图片，现在设计是API返回图片名字的数组，前端取到之后分别放在img标签里。<br>\n现在的问题是api返回的数据可以被别人轻易获取，然后就可以随便请求图片，请教一下怎么避免这个问题？<br>\n有的图片网站是直接服务器渲染，除了这个还有其他办法吗？</p>\n</div>","title":"请教一个后端图片api问题","last_reply_at":"2019-06-05T18:20:33.982Z","good":false,"top":false,"reply_count":7,"visit_count":763,"create_at":"2019-05-28T04:26:00.058Z","author":{"loginname":"zytjs","avatar_url":"https://avatars2.githubusercontent.com/u/12710516?v=4&s=120"}},{"id":"5cf79b3e1fe902120f31c714","author_id":"56fdcb26c5f5b4a959e91751","tab":"share","content":"<div class=\"markdown-text\"><p>最近想在我开发的项目：<a href=\"https://www.geekjc.com\">极客教程</a></p>\n<p>加入活跃度功能，用户发文，点赞，发动态都可以积攒活跃度，每天统计用户活跃度，前10或者20的用户可以获得本项目当天总收入的一定比例，大家觉得如何？</p>\n</div>","title":"项目想法-共享收入","last_reply_at":"2019-06-05T14:14:48.664Z","good":false,"top":false,"reply_count":2,"visit_count":336,"create_at":"2019-06-05T10:36:46.032Z","author":{"loginname":"cllgeek","avatar_url":"https://avatars0.githubusercontent.com/u/15187909?v=4&s=120"}},{"id":"5cf5344d1fe902120f31bcce","author_id":"56daaf5dc0fa23473d005feb","tab":"share","content":"<div class=\"markdown-text\"><p>吐槽一波，亚马逊云的数据库DynamoDB真心难用</p>\n<p>分享一下经过改良的DynamoDB导出CSV文件教程：<a href=\"https://github.com/zhulinwei/dynamodb-to-csv\">dynamodb-to-csv</a></p>\n</div>","title":"AWS DynamoDB数据导入CSV文件","last_reply_at":"2019-06-05T14:12:23.333Z","good":false,"top":false,"reply_count":6,"visit_count":351,"create_at":"2019-06-03T14:53:01.999Z","author":{"loginname":"zhulinwei","avatar_url":"https://avatars2.githubusercontent.com/u/17670262?v=4&s=120"}},{"id":"5ce3b9dd518e0954fc4104bc","author_id":"5ce3b918e57aac76fed2ca3a","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://marketplace.visualstudio.com/items?itemName=zitup.classnametocss\">https://marketplace.visualstudio.com/items?itemName=zitup.classnametocss</a><br>\n功能就一个，就是在css(less/scss/stylus/vue)中智能提示同目录下的html(htm/jsx/tsx/vue)文件中的className。<br>\n<img src=\"//static.cnodejs.org/FnkyRiP2Y46_p0l1ZepIiCL6sB9k\" alt=\"classtocss.gif\">\n没有找到类似插件，就自己写了一个。不想每次去界面文件复制粘贴…</p>\n</div>","title":"写了个vscode插件，ClassName To Css","last_reply_at":"2019-06-05T12:54:00.491Z","good":false,"top":false,"reply_count":19,"visit_count":1142,"create_at":"2019-05-21T08:42:05.741Z","author":{"loginname":"zytjs","avatar_url":"https://avatars2.githubusercontent.com/u/12710516?v=4&s=120"}},{"id":"55a0dff4419f1e8a23a64276","author_id":"55728d26c4e7fbea6e9a2f07","tab":"ask","content":"<div class=\"markdown-text\"><p>问题描述：\n使用node开发了一个游戏服务器，为了尽可能提高服务器的性能，服务器采用多进程的架构，前面处理玩家socket连接的是多个node进程，使用 child_process 模块，服务器启动时fork出来，而处理玩家游戏逻辑的是单独一个node进程（因为玩家之间需要交互，而且玩家都是有状态的，所以无法分成多个进程）这个作为主进程；主进程与子进程之间使用使用child_process模块内建的通讯方式进行通讯；</p>\n<p>现在服务器性能出现瓶颈，服务器同时在线去到1500人左右，CPU占用率在40+左右，目标是3000人同时在线；通过CPU Profile分析，唯一无状态的可分离出来而且比较占用CPU的，就是玩家数据读数据库和保存数据库的时候，数据库使用的是mongodb,所以现在想把读写数据库的逻辑独立到一个新的进程中；但是问题来了，由于玩家的数据是一个大的Json结构，最大的大小能达到600+K，而node的child_process模块的内建进程间通讯是通过JSON.stringify和JSON.parse来转换成字符串来进行通讯的，所</p>\n<p>以独立出来以后，性能的问题，又指向了child_process模块中的进程之间的通讯的函数，通过实验：\nJSON.strinify 一个600K+玩家的数据平均需要35ms,JSON.parse 一个600K+玩家的数据平均需要20ms，而且这两个函数都是同步的，会造成阻塞；这也就是说主进程无法把一些包含大数据处理的任务分派到其他进程去做，这也直接限制了主进程的承载量和在线玩家人数；</p>\n<p>尝试找过一写解决的方案：\n1.异步版的 JSON.stringify 和 JSON.parse ，可惜没有结果，正如这里的讨论：<a href=\"https://github.com/joyent/node/issues/7543\">https://github.com/joyent/node/issues/7543</a>\n2.为node加入多线程？node有几个多线程的库，但是貌似都不支持共享进程内存，无法操作主进程的内存，只能通过字符串进行交换数据，也就是说轮回到以上进程间的通讯问题；</p>\n<p>这个问题一直比较困扰，还没有找到好的解决方法，希望大牛来赐教</p>\n</div>","title":"node开发游戏服务器遇到的性能问题","last_reply_at":"2019-06-05T09:48:59.624Z","good":true,"top":false,"reply_count":96,"visit_count":30494,"create_at":"2015-07-11T09:20:52.975Z","author":{"loginname":"wf744","avatar_url":"https://avatars.githubusercontent.com/u/3078907?v=3&s=120"}},{"id":"5cf22e861fe902120f31b25f","author_id":"58bd6b91d282728c0ec401b4","tab":"ask","content":"<div class=\"markdown-text\"><p>如果使用 return next() 会出现什么问题影响吗？ 假定 next() 下面没有需要继续执行的代码，next()本来就在最后一行。\n(纠结的原因，如果可以用 return next() ，我就不需要在函数前面加 async了, hahaha)</p>\n</div>","title":"求教： Koa2里 使用await next()和return next()有没有区别？","last_reply_at":"2019-06-05T09:17:05.540Z","good":false,"top":false,"reply_count":7,"visit_count":694,"create_at":"2019-06-01T07:51:34.761Z","author":{"loginname":"chengshubei","avatar_url":"https://avatars3.githubusercontent.com/u/24501068?v=4&s=120"}},{"id":"5cf784b91fe902120f31c636","author_id":"5cf783a41fe902120f31c62d","tab":"share","content":"<div class=\"markdown-text\"><p>操作简单，就体验个模板框架，跑个 demo 应该中高级开发者半小时能搞定 跑通了差不多有 300 元。\n公司项目，目前主要开发语言是C#，写js的，大家上手C#也快，操作应该会很顺手。</p>\n<p>说明下：区块链公链项目，发的是等值代币（市值 100 以内项目，可以查得到：aelf ） 不过已经上线五十多个交易所，变现不是问题。</p>\n<p>具体的可以看看活动文章： aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvcERjYlFiN3JaMWMweTZJVWtITDRMZw==</p>\n</div>","title":"我们公司招募一批开发者体验开发环境，跑个 demo，跑通了会给奖励，看有没有兴趣的开发朋友？","last_reply_at":"2019-06-05T09:08:44.965Z","good":false,"top":false,"reply_count":1,"visit_count":326,"create_at":"2019-06-05T09:00:41.033Z","author":{"loginname":"xiexiaodi","avatar_url":"https://avatars2.githubusercontent.com/u/39952518?v=4&s=120"}},{"id":"5cf767641fe902120f31c555","author_id":"5ceb91364036f24194cf6e62","tab":"ask","content":"<div class=\"markdown-text\"><p>在es6中，可以通过 static getInstance() 实现单例模式，\n源代码：\nstatic getInstance(obj) {\nif (!this.instance) {\nthis.instance = new myObject(obj);\n}\nreturn this.instance;\n}</p>\n<p>但是obj是动态改变属性的，我做了如下改动：</p>\n<p>static getInstance(obj) {\nif (this.instance) {\ndelete this.instance;\n}\nthis.instance = new myObject(obj);\nreturn this.instance;\n}</p>\n<p>请问大家这样是否可以？？？有什么问题？？？谢谢</p>\n</div>","title":"node es6 的单例模式问题","last_reply_at":"2019-06-05T08:27:38.596Z","good":false,"top":false,"reply_count":1,"visit_count":222,"create_at":"2019-06-05T06:55:32.782Z","author":{"loginname":"LuoShiXi","avatar_url":"https://avatars2.githubusercontent.com/u/20841502?v=4&s=120"}},{"id":"5ce37234518e0954fc41017e","author_id":"5cd52169ce97fe69027a4165","tab":"share","content":"<div class=\"markdown-text\"><p>学习 node 的小伙伴相信都有一颗全栈的心, 虽然 node 全栈被 javaer 嘲笑, 但并不代表不行, 用狼叔话讲是 java 底子太厚, 给 node 发挥的机会不多</p>\n<p>我是一个 iOSer, 学习 node 的目的是为了扩展能力范围, 让自己没有短板, 假如被裁了, 离开了公司, 自己也可以  SOHO, 也算是给自己留个备胎, 毛衣站的事情告诉我们, 打铁还得自身硬,  备胎总比瘸腿强</p>\n<p>扯了这么多, 下面来说说我的计划吧</p>\n<p>我用半个月的时间学习了一下 node 的基础 api, 对 http, net, event, stream, fs, 这几个模块也挺熟悉了, 我在慕课网上买了一个视频, <a href=\"https://s.imooc.com/SOZks8k\">Node.js 从零开发web server博客项目</a>, 看重这个课程是因为他主要讲后端工程师如何思考, 并且把一个博客项目用裸写, express, koa2 写了三遍, 可以从底层做起, 并且了解框架做了哪些事情以及优点, 知其然, 知其所以然</p>\n<p>前端课程我选了 b 站上的一个视频, <a href=\"https://www.bilibili.com/video/av47296993\">React+Redux+React Router+Node.js全栈开发</a>, 本人之前写过 RN, 所以对 react + redux 还算熟. 另外, react 对 ts 天生友好,回头学习 ts 也可以无痛练习</p>\n<p>视频时长大概有 50 小时, 每天看一小时视频, 写一小时代码, 也每天将近两个小时, 强度感觉挺高了, 加上有时候会摸鱼, 感觉100 天搞完也挺紧张😂</p>\n<p>有跟我一样想提高自己却没有执行力的, 大家组个团, 互相监督打卡交流, 争取明年 30k!!!</p>\n<p>欢迎大家把自己的计划写到回复里, 加入 qq 群 542160608</p>\n</div>","title":"自己定了一个百天\"全栈计划\", 欢迎小伙伴们加入, 互相打卡监督","last_reply_at":"2019-06-05T07:12:28.331Z","good":false,"top":false,"reply_count":19,"visit_count":2086,"create_at":"2019-05-21T03:36:20.357Z","author":{"loginname":"Luyakus","avatar_url":"https://avatars0.githubusercontent.com/u/16056733?v=4&s=120"}},{"id":"5cf7207f1fe902120f31c355","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>译者按：</strong> 有时候一个算法的直观、简洁、高效是需要作出取舍的。</p>\n<ul>\n<li>原文: <a href=\"https://jrsinclair.com/articles/2019/five-ways-to-average-with-js-reduce/\">FUNCTIONAL JAVASCRIPT: FIVE WAYS TO CALCULATE AN AVERAGE WITH ARRAY REDUCE</a></li>\n<li>译者: <a href=\"https://www.fundebug.com/\">Fundebug</a></li>\n</ul>\n<p><strong>本文采用意译，版权归原作者所有</strong></p>\n<p>函数式编程中用于<a href=\"https://jrsinclair.com/articles/2017/javascript-without-loops/\">操作数组的方法</a>就像“毒品”一样，它让很多人爱上函数式编程。因为它们真的十分常用而且又超级简单。 <a href=\"https://jrsinclair.com/articles/2017/javascript-without-loops/#mapping\"><code>.map()</code></a> 和 <a href=\"https://jrsinclair.com/articles/2017/javascript-without-loops/#filtering\"><code>.filter()</code></a>都仅需一个参数，该参数定义操作数组每一个元素的函数即可。<code>reduce()</code>会复杂一些，我之前写过一篇文章介绍为什么人们难以掌握<code>reduce()</code>方法，其中一个原因在于很多入门资料都仅仅用算术作为例子。我写了很多用<code>reduce()</code>来做算术以外的例子。</p>\n<p>用<code>reduce()</code>来计算数组的平均值是一个常用的模式。代码看起来非常简单，不过在计算最终结果之前你需要做两个准备工作：</p>\n<ul>\n<li>数组的长度</li>\n<li>数组所有元素之和</li>\n</ul>\n<p>这两个事情看起来都很简单，那么计算数组的平均值并不是很难了吧。解法如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>function average(nums) {\n    return nums.reduce((a, b) =&gt; a + b) &#x2F; nums.length;\n}\n</code></pre><p>确实不是很难，是吧？但是如果数据结构变得复杂了，就没那么简单了。比如，数组里面的元素是对象，你需要先过滤掉某些对象，然后从对象中取出数字。这样的场景让计算平均值变得复杂了一点。</p>\n<p>接下来我们处理一个类似的问题(从<a href=\"https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/functional-programming/use-the-reduce-method-to-analyze-data/\">this Free Code Camp challenge</a>获得灵感)，我们会提供 5 种不同的解法，每一种方法有各自的优点和缺点。这 5 种方法也展示了 JavaScript 的灵活。我希望可以给你在使用<code>reduce</code>的实战中一些灵感。</p>\n<h2>问题提出</h2>\n<p>假设我们有一个数组，记录了维多利亚时代常用的口语。接下来我们要找出那些依然现存于 Google Books 中的词汇，并计算他们的平均流行度。数据的格式是这样的:</p>\n<pre class=\"prettyprint language-javascript\"><code>const victorianSlang = [\n    {\n        term: &quot;doing the bear&quot;,\n        found: true,\n        popularity: 108\n    },\n    {\n        term: &quot;katterzem&quot;,\n        found: false,\n        popularity: null\n    },\n    {\n        term: &quot;bone shaker&quot;,\n        found: true,\n        popularity: 609\n    },\n    {\n        term: &quot;smothering a parrot&quot;,\n        found: false,\n        popularity: null\n    },\n    {\n        term: &quot;damfino&quot;,\n        found: true,\n        popularity: 232\n    },\n    {\n        term: &quot;rain napper&quot;,\n        found: false,\n        popularity: null\n    },\n    {\n        term: &quot;donkey’s breakfast&quot;,\n        found: true,\n        popularity: 787\n    },\n    {\n        term: &quot;rational costume&quot;,\n        found: true,\n        popularity: 513\n    },\n    {\n        term: &quot;mind the grease&quot;,\n        found: true,\n        popularity: 154\n    }\n];\n</code></pre><p>接下来我们用 5 中不同的方法计算平均流行度值。</p>\n<h2>1. for 循环</h2>\n<p>初次尝试，我们不使用<code>reduce()</code>。如果你对数组的常用函数不熟悉，用 for 循环可以让你更好地理解我们要做什么。</p>\n<pre class=\"prettyprint language-javascript\"><code>let popularitySum = 0;\nlet itemsFound = 0;\nconst len = victorianSlang.length;\nlet item = null;\nfor (let i = 0; i &lt; len; i++) {\n    item = victorianSlang[i];\n    if (item.found) {\n        popularitySum = item.popularity + popularitySum;\n        itemsFound = itemsFound + 1;\n    }\n}\nconst averagePopularity = popularitySum &#x2F; itemsFound;\nconsole.log(&quot;Average popularity:&quot;, averagePopularity);\n</code></pre><p>如果你熟悉 JavaScript，上面的代码理解起来应该很容易：</p>\n<ol>\n<li>初始化<code>polularitySum</code>和<code>itemsFound</code>变量。<code>popularitySum</code>记录总的流行度值，<code>itemsFound</code>记录我们已经找到的所有的条目；</li>\n<li>初始化<code>len</code>和<code>item</code>来帮助我们遍历数组；</li>\n<li>for 循环每一次增加<code>i</code>的值，直到循环<code>n</code>次；</li>\n<li>在循环中，我们每次取出当前索引位置的条目<code>vitorianSlang[i]</code>；</li>\n<li>检查该条目是否在 Google Books 中</li>\n<li>如果在，获取<code>popularity</code>并累加到<code>popularitySum</code>；</li>\n<li>并递增<code>itemsFound</code>；</li>\n<li>最后，用<code>popularitySum</code>除以<code>itemsFound</code>来计算平均值。</li>\n</ol>\n<p>代码虽然不是那么简洁，但是顺利完成了任务。使用数组迭代方法可以更加简洁，接下来开始吧……</p>\n<h2>2. 简单模式: filter, map 和 sum</h2>\n<p>我们首先将这个问题拆分成几个子问题：</p>\n<ol>\n<li>使用<code>fitler()</code>找到那些在 Google Books 中的条目;</li>\n<li>使用<code>map()</code>获取流行度；</li>\n<li>使用<code>reuduce()</code>来计算总的流行度；</li>\n<li>计算平均值。</li>\n</ol>\n<p>下面是实现代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 辅助函数\n&#x2F;&#x2F; ----------------------------------------------------------------------------\nfunction isFound(item) {\n    return item.found;\n}\n\nfunction getPopularity(item) {\n    return item.popularity;\n}\n\nfunction addScores(runningTotal, popularity) {\n    return runningTotal + popularity;\n}\n\n&#x2F;&#x2F; 计算\n&#x2F;&#x2F; ----------------------------------------------------------------------------\n\n&#x2F;&#x2F; 找出所有isFound为true的条目\nconst foundSlangTerms = victorianSlang.filter(isFound);\n\n&#x2F;&#x2F; 从条目中获取流行度值，返回为数组\nconst popularityScores = foundSlangTerms.map(getPopularity);\n\n&#x2F;&#x2F; 求和\nconst scoresTotal = popularityScores.reduce(addScores, 0);\n\n&#x2F;&#x2F; 计算平均值\nconst averagePopularity = scoresTotal &#x2F; popularityScores.length;\nconsole.log(&quot;Average popularity:&quot;, averagePopularity);\n</code></pre><p>注意看<code>addScores</code>函数以及调用<code>reduce()</code>函数的那一行。<code>addScores()</code>接收两个参数，第一个<code>runningTotal</code>，我们把它叫做累加数，它一直记录着累加的总数。每访问数组中的一个条目，我们都会用<code>addScores</code>函数来更新它的值。第二个参数<code>popularity</code>是当前某个元素的值。注意，第一次调用的时候，我们还没有<code>runningTotal</code>的值，所以在调用<code>reduce()</code>的时候，我们给<code>runningTotal</code>初始化。也就是<code>reduce()</code>的第二个参数。</p>\n<p>这个版本的代码简洁很多了，也更加的直观。我们不再告诉 JavaScript 引擎如何循环，如何对当前索引的值做操作。我们定义了很多小的辅助函数，并且把它们组合起来完成任务。<code>filter()</code>，<code>map()</code>和<code>reduce()</code>帮我们做了很多工作。上面的实现更加直观地告诉我们这段代码要做什么，而不是底层如何去实现。</p>\n<h2>3. 简单模式 II: 记录多个累加值</h2>\n<p>在之前的版本中，我们创建了很多中间变量：<code>foundSlangTerms</code>，<code>popularityScores</code>。接下来，我们给自己设一个挑战，使用<a href=\"https://en.wikipedia.org/wiki/Fluent_interface\">链式操作</a>，将所有的函数调用组合起来，不再使用中间变量。注意：<code>popularityScores.length</code>变量需要用其它的方式来获取。我们可以在<code>addScores</code>的累加参数中记录它。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 辅助函数\n&#x2F;&#x2F; ---------------------------------------------------------------------------------\nfunction isFound(item) {\n    return item.found;\n}\n\nfunction getPopularity(item) {\n    return item.popularity;\n}\n\n&#x2F;&#x2F; 我们使用一个对象来记录总的流行度和条目的总数\nfunction addScores({ totalPopularity, itemCount }, popularity) {\n    return {\n        totalPopularity: totalPopularity + popularity,\n        itemCount: itemCount + 1\n    };\n}\n\n&#x2F;&#x2F; 计算\n&#x2F;&#x2F; ---------------------------------------------------------------------------------\n\nconst initialInfo = { totalPopularity: 0, itemCount: 0 };\nconst popularityInfo = victorianSlang\n    .filter(isFound)\n    .map(getPopularity)\n    .reduce(addScores, initialInfo);\n\nconst { totalPopularity, itemCount } = popularityInfo;\nconst averagePopularity = totalPopularity &#x2F; itemCount;\nconsole.log(&quot;Average popularity:&quot;, averagePopularity);\n</code></pre><p>我们在<code>reduce</code>函数中使用对象来记录了<code>totalPopularity</code>和<code>itemCount</code>。在<code>addScores</code>中，每次都更新<code>itemCount</code>的计数。</p>\n<p>通过<code>filter</code>，<code>map</code>和<code>reduce</code>计算的最终的结果存储在<code>popularityInfo</code>中。你甚至可以继续简化上述代码，移除不必要的中间变量，让最终的计算代码只有一行。</p>\n<h2>4. point-free 式函数组合</h2>\n<p><strong>注意</strong>: <em>如果你不熟悉函数式语言或则觉得难以理解，请跳过这部分！</em></p>\n<p>如果你熟悉<code>curry()</code>和<code>compose()</code>，接下来的内容就不难理解。如果你想知道更多，可以看看这篇文章: <a href=\"https://jrsinclair.com/articles/2016/gentle-introduction-to-functional-javascript-intro/\">‘A Gentle Introduction to Functional JavaScript’</a>. 特别是<a href=\"https://jrsinclair.com/articles/2016/gentle-introduction-to-functional-javascript-functions/\">第三部分</a> 。</p>\n<p>我们可以使用<code>compose</code>函数来构建一个完全不带任何变量的代码，这就叫做<code>point-free</code>的方式。不过，我们需要一些帮助函数。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 辅助函数\n&#x2F;&#x2F; ----------------------------------------------------------------------------\nconst filter = p =&gt; a =&gt; a.filter(p);\nconst map = f =&gt; a =&gt; a.map(f);\nconst prop = k =&gt; x =&gt; x[k];\nconst reduce = r =&gt; i =&gt; a =&gt; a.reduce(r, i);\nconst compose = (...fns) =&gt; arg =&gt; fns.reduceRight((arg, fn) =&gt; fn(arg), arg);\n\n&#x2F;&#x2F; The blackbird combinator.\n&#x2F;&#x2F; See: https:&#x2F;&#x2F;jrsinclair.com&#x2F;articles&#x2F;2019&#x2F;compose-js-functions-multiple-parameters&#x2F;\nconst B1 = f =&gt; g =&gt; h =&gt; x =&gt; f(g(x))(h(x));\n\n&#x2F;&#x2F; 计算\n&#x2F;&#x2F; ----------------------------------------------------------------------------\n\n&#x2F;&#x2F; 求和函数\nconst sum = reduce((a, i) =&gt; a + i)(0);\n\n&#x2F;&#x2F; 计算数组长度的函数\nconst length = a =&gt; a.length;\n\n&#x2F;&#x2F; 除法函数\nconst div = a =&gt; b =&gt; a &#x2F; b;\n\n&#x2F;&#x2F; 我们使用compose()来将函数组合起来\n&#x2F;&#x2F; compose()的参数你可以倒着读，来理解程序的含义\nconst calcPopularity = compose(\n    B1(div)(sum)(length),\n    map(prop(&quot;popularity&quot;)),\n    filter(prop(&quot;found&quot;))\n);\n\nconst averagePopularity = calcPopularity(victorianSlang);\nconsole.log(&quot;Average popularity:&quot;, averagePopularity);\n</code></pre><p>我们在<code>compose</code>中做了所有的计算。从后往前看，首先<code>filter(prop('found'))</code>筛选出所有在 Google Books 中的条目，然后通过<code>map(prop('popularity'))</code>获取所有的流行度数值，最后使用 <a href=\"https://jrsinclair.com/articles/2019/compose-js-functions-multiple-parameters/\">magical blackbird (<code>B1</code>) combinator</a> 来对同一个输入进行<code>sum</code>和<code>length</code>的计算，并求得平均值。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; All the lines below are equivalent:\nconst avg1 = B1(div)(sum)(length);\nconst avg2 = arr =&gt; div(sum(arr))(length(arr));\nconst avg3 = arr =&gt; sum(arr) &#x2F; length(arr);\nconst avg4 = arr =&gt; arr.reduce((a, x) =&gt; a + x, 0) &#x2F; arr.length;\n</code></pre><p>不要担心看不明白，上面主要是为大家演示有 4 种方式来实现<code>average</code>功能。这就是 JavaScript 的优美之处。</p>\n<p>相对来说，本文的内容是有点极客的。虽然笔者之前深度使用函数式语言 Haskell 做过不少研究项目，对函数式颇有理解，但是 point-free 风格的代码，我们是不建议在实际工程中使用的，维护成本会很高。我们<a href=\"https://www.fundebug.com\">Fundebug</a>所有的代码都要求直观易懂，不推崇用一些奇淫技巧来实现。除非某些万不得已的地方，但是一定要把注释写得非常清楚，来降低后期的维护成本。</p>\n<h2>5. 终极优化: 一次计算出结果</h2>\n<p>之前所有的解法都可以很好地工作。那些使用<code>reduce()</code>的解法都有一个共同点，它们将大的问题拆解问小的子问题，然后通过不同的方式将它们组合起来。但是也要注意它们对数组遍历了三次，感觉很没有效率。如果一次就可以计算出来，才是最佳的方案。确实可以，不过需要一点数学运算。</p>\n<p>为了计算 n 个元素的平均值，我们使用下面的公式：</p>\n<p><img src=\"https://image.fundebug.com/2019-06-04-sum-n.png\" alt></p>\n<p>那么，计算 n+1 个元素的平均值，使用同样的公式（唯一不同的是 n 变成 n+1）：</p>\n<p><img src=\"https://image.fundebug.com/2019-06-04-sum-n-plus-1.png\" alt></p>\n<p>它等同于:</p>\n<p><img src=\"https://image.fundebug.com/2019-06-04-sum-n-plus-1-2.png\" alt></p>\n<p>同样等同于:</p>\n<p><img src=\"https://image.fundebug.com/2019-06-04-sum-n-plus-1-3.png\" alt></p>\n<p>做点变换:</p>\n<p><img src=\"https://image.fundebug.com/2019-06-04-sum-n-plus-1-4.png\" alt></p>\n<p>结论是，我们可以一直记录当前状态下的所有满足条件的元素的平均值。只要我们知道之前所有元素的平均值和元素的个数。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 求平均值\nfunction averageScores({ avg, n }, slangTermInfo) {\n    if (!slangTermInfo.found) {\n        return { avg, n };\n    }\n    return {\n        avg: (slangTermInfo.popularity + n * avg) &#x2F; (n + 1),\n        n: n + 1\n    };\n}\n\nconst initialVals = { avg: 0, n: 0 };\nconst averagePopularity = victorianSlang.reduce(averageScores, initialVals).avg;\nconsole.log(&quot;Average popularity:&quot;, averagePopularity);\n</code></pre><p>这个方法只需要遍历一次就计算出平均值，缺点是我们做了更多的计算。每一次当元素满足条件，都要做乘法和除法，而不是最后才做一次除法。不过，它使用了更少的内存，因为没有中间的数组变量，我们只是记录了一个仅仅有两个元素的对象。</p>\n<p>这样写还有一个缺点，代码一点都不直观，后续维护麻烦。至少一眼看过去不能理解它是做什么的。</p>\n<p>所以，到底哪一种方案才是最好的呢？视情形而定。也许你有一个很大的数组要处理，也许你的代码需要在内存很小的硬件上跑。在这些场景下，使用第 5 个方案最佳。如果性能不是问题，那么就算使用最低效的方法也没问题。你需要选择最适合的。</p>\n<p>还有一些聪明的朋友会思考：是否可以将问题拆解为子问题，仍然只遍历一次呢？是的，确实有。需要使用 transducer。</p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2019/06/05/5-ways-calculate-an-average-with-reduce/\">https://blog.fundebug.com/2019/06/05/5-ways-calculate-an-average-with-reduce/</a></p>\n</div>","title":"大神是怎样用函数式JavaScript计算数组平均值的","last_reply_at":"2019-06-05T05:09:06.527Z","good":false,"top":false,"reply_count":1,"visit_count":237,"create_at":"2019-06-05T01:53:03.437Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5cf739201fe902120f31c467","author_id":"572c54718783d212174bd765","tab":"share","content":"<div class=\"markdown-text\"><h2>Vue页面堆栈管理器</h2>\n<blockquote>\n<p>A vue page stack manager Vue页面堆栈管理器 <a href=\"https://github.com/hezhongfeng/vue-page-stack\">vue-page-stack</a></p>\n</blockquote>\n<p><img src=\"https://i.loli.net/2019/06/04/5cf64c9ea1f1d71714.gif\" alt=\"image\"></p>\n<blockquote>\n<p>示例展示了一般的前进、后退（有activited）和replace的场景，同时还展示了同一个路由可以存在多层的效果（输入必要信息）</p>\n</blockquote>\n<p><strong>目前版本还没有经过整体业务的测试，欢迎有同样需求的进行试用</strong></p>\n<p><a href=\"https://hezhongfeng.github.io/vue-page-stack-example/\">预览</a></p>\n<p><a href=\"https://github.com/hezhongfeng/vue-page-stack-example\">示例源码</a></p>\n<h2>需求分析</h2>\n<p>由于重度使用了Vue全家桶在<code>web App</code>、公众号和原生Hybrid开发，所以很自然的会遇到页面跳转与回退这方面的问题。</p>\n<p>场景举例：</p>\n<ol>\n<li>列表页进入详情页，然后回退</li>\n<li>某操作页A需要在下一页面B选择，选择后需要退回到A页面（A页面还要知道选择了什么）</li>\n<li>在任意页面进入到登录页面，登录或者注册成功后返回到原页面，并且要保证继续回退是不会到登陆页面的</li>\n<li>支持浏览器的<code>back</code>和<code>forward</code>(微信或者小程序很有用)</li>\n<li>在进入、退出或者某些特殊页面的时候添加一些动画，比如模仿ios的默认动画（进入是页面从右向左平移，退出是页面从左向右平移）</li>\n</ol>\n<h2>尝试过的方法</h2>\n<p>尝试了以下方法，但是都没有达到我的预期</p>\n<h3>keep-alive</h3>\n<p>一般是使用两个<code>router-view</code>通过route信息和keep-alive控制页面是否缓存，这样存在两个问题：</p>\n<ol>\n<li>keep-alive对相同的页面只会存储一次，不会有两个版本的相同页面</li>\n<li>两个router-view之间没有办法使用<code>transition</code>等动画</li>\n</ol>\n<h3>CSS配合嵌套route</h3>\n<p>曾经在查看<code>cube-ui</code>的例子的时候，发现他们的例子好像解决了页面缓存的问题，我借鉴(copy)了他们的处理方式，升级了一下，使用CSS和嵌套route的方式实现了基本的需求。\n但是也有缺点：</p>\n<ol>\n<li>我必须严格按照页面的层级来写我的route</li>\n<li>很多页面在多个地方需要用到，我必须都得把路由配上(例如商品详情页面，会在很多个地方有入口)</li>\n</ol>\n<h2>功能说明</h2>\n<ol>\n<li>在vue-router上扩展，原有导航逻辑不需改变</li>\n<li><code>push</code>或者<code>forward</code>的时候重新渲染页面，Stack中会添加新渲染的页面</li>\n<li><code>back</code>或者<code>go(负数)</code>的时候不会重新渲染，从Stack中读取先前的页面，会保留好先前的内容状态，例如表单内容，滚动条滑动的位置等</li>\n<li><code>back</code>或者<code>go(负数)</code>的时候会把不用的页面从Stack中移除</li>\n<li><code>replace</code>会更新Stack中页面信息</li>\n<li>回退到之前页面的时候有activited钩子函数触发</li>\n<li>支持浏览器的后退，前进事件</li>\n<li>支持响应路由参数的变化，例如从 /user/foo 导航到 /user/bar，组件实例会被复用</li>\n<li>可以在前进和后退的时候添加不同的动画，也可以在特殊页面添加特殊的动画</li>\n</ol>\n<h2>安装和用法</h2>\n<h3>安装</h3>\n<pre class=\"prettyprint\"><code>npm install vue-page-stack\n# OR\nyarn add vue-page-stack\n</code></pre><h3>使用</h3>\n<pre class=\"prettyprint\"><code>import Vue from &#x27;vue&#x27;\nimport VuePageStack from &#x27;vue-page-stack&#x27;;\n\n&#x2F;&#x2F; vue-router是必须的\nVue.use(VuePageStack, { router }); \n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; App.vue\n&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;vue-page-stack&gt;\n      &lt;router-view &gt;&lt;&#x2F;router-view&gt;\n    &lt;&#x2F;vue-page-stack&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default {\n  name: &#x27;App&#x27;,\n  data() {\n    return {\n    };\n  },\n  components: {},\n  created() {},\n  methods: {}\n};\n&lt;&#x2F;script&gt;\n\n</code></pre><h2>API</h2>\n<h3>注册</h3>\n<p>注册的时候可以指定VuePageStack的名字和keyName，一般不需要</p>\n<pre class=\"prettyprint\"><code>Vue.use(VuePageStack, { router, name: &#x27;VuePageStack&#x27;, keyName: &#x27;stack-key&#x27; });\n</code></pre><h3>前进和后退</h3>\n<p>想在前进、后退或者特殊路由添加一些动画，可以在<code>router-view</code>的页面通过watch <code>$route</code>，通过<code>stack-key-dir(自定义keyName这里也随之变化)</code>参数判断此时的方向，可以参考<a href=\"https://github.com/hezhongfeng/vue-page-stack-example\">实例</a></p>\n<h2>相关说明</h2>\n<h3>keyName</h3>\n<p>为什么会给路由添加<code>keyName</code>这个参数，是为了支持浏览器的后退，前进事件，这个特点在微信公众号和小程序很重要</p>\n<h3>原理****</h3>\n<p>获取当前页面Stack部分参考了keep-alive的部分</p>\n<h2>结束语</h2>\n<blockquote>\n<p>念念不忘，必有回响</p>\n</blockquote>\n<p>这个插件存在我心中很久了，断断续续做了好久，终于被我搞定了，真的非常开心。</p>\n<p>目前版本还没有经过整体业务的测试，欢迎有同样需求的进行试用，有任何的意见或者建议，欢迎在 <a href=\"https://github.com/hezhongfeng/vue-page-stack\">Github</a> 提issue和PR，感谢你的支持和贡献。</p>\n<p>这个插件同时借鉴了<a href=\"https://github.com/zack24q/vue-navigation\">vue-navigation</a>和<a href=\"https://github.com/nearspears/vue-nav\">vue-nav</a>，很感谢他们给的灵感。</p>\n</div>","title":"[vue-page-stack]Vue页面堆栈管理器","last_reply_at":"2019-06-05T03:38:08.436Z","good":false,"top":false,"reply_count":0,"visit_count":174,"create_at":"2019-06-05T03:38:08.436Z","author":{"loginname":"hezhongfeng","avatar_url":"https://avatars2.githubusercontent.com/u/12163050?v=4&s=120"}},{"id":"5cef9f6f4036f24194cf805c","author_id":"5c875af8acb681372d41753b","tab":"share","content":"<div class=\"markdown-text\"><p>Dart教程在线试听地址： <a href=\"https://www.bilibili.com/video/av52490605\">https://www.bilibili.com/video/av52490605</a></p>\n<p>Flutter教程在线试听地址： <a href=\"https://www.bilibili.com/video/av52490605/?p=15\">https://www.bilibili.com/video/av52490605/?p=15</a></p>\n<p><strong>2019年5月新出Dart Flutter入门实战视频教程网盘下载地址：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1WCobyt_1Oy4KDUmnSsCpiw\">https://pan.baidu.com/s/1WCobyt_1Oy4KDUmnSsCpiw</a>  提取码：xwpq</p>\n</div>","title":"2019年5月录制的Dart Flutter入门实战系列视频教程-网盘免费分享","last_reply_at":"2019-06-05T02:58:09.707Z","good":false,"top":false,"reply_count":8,"visit_count":662,"create_at":"2019-05-30T09:16:31.065Z","author":{"loginname":"youmenglinzi","avatar_url":"https://avatars0.githubusercontent.com/u/48469369?v=4&s=120"}},{"id":"5cf4b1f295fcc914aa2658d0","author_id":"53b25565399ed9e07d1e8793","tab":"ask","content":"<div class=\"markdown-text\"><p>nodejs-websocket 创建服务</p>\n<pre class=\"prettyprint language-js\"><code>var ws = require(&quot;nodejs-websocket&quot;)\n \n&#x2F;&#x2F; Scream server example: &quot;hi&quot; -&gt; &quot;HI!!!&quot;\nvar server = ws.createServer(function (conn) {\n    console.log(&quot;New connection&quot;)\n    conn.on(&quot;text&quot;, function (str) {\n        console.log(&quot;Received &quot;+str)\n        conn.sendText(str.toUpperCase()+&quot;!!!&quot;)\n    })\n    conn.on(&quot;close&quot;, function (code, reason) {\n        console.log(&quot;Connection closed&quot;)\n    })\n}).listen(8001)\n</code></pre><p>http 创建服务</p>\n<pre class=\"prettyprint language-js\"><code>const http = require(&quot;http&quot;);\nconst fs = require(&quot;fs&quot;);\n\nhttp\n  .createServer(function(req, res) {\n    res.writeHead(200, { &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; });\n    var stream = fs.createReadStream(&quot;.&#x2F;index.html&quot;);\n    stream.on(&quot;open&quot;, function(fd) {\n      &#x2F;&#x2F; console.log(&#x27;开始读取文件&#x27;);\n    });\n    stream.on(&quot;data&quot;, function(data) {\n      &#x2F;&#x2F; console.log(&#x27;读取到数据：&#x27;);\n      &#x2F;&#x2F; console.log(data.toString());\n      res.write(data);\n    });\n    stream.on(&quot;end&quot;, function() {\n      &#x2F;&#x2F; console.log(&#x27;文件已全部读取完毕&#x27;);\n      res.end();\n    });\n    stream.on(&quot;close&quot;, function() {\n      &#x2F;&#x2F; console.log(&#x27;文件被关闭&#x27;);\n    });\n    stream.on(&quot;error&quot;, function(err) {\n      &#x2F;&#x2F; console.log(&#x27;读取文件失败&#x27;);\n      res.writeHead(500, { &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; });\n      res.write(&quot;500 error&quot;);\n    });\n  })\n  .listen(3000);\n</code></pre><p>有办法把这两个端口共用吗？</p>\n</div>","title":"怎么让 nodejs-websocket 启动的ws服务与http启动的http服务共用一个端口呢？","last_reply_at":"2019-06-05T02:56:26.515Z","good":false,"top":false,"reply_count":2,"visit_count":399,"create_at":"2019-06-03T05:36:50.632Z","author":{"loginname":"tomoya92","avatar_url":"https://avatars2.githubusercontent.com/u/6915570?v=4&s=120"}},{"id":"5cee06a652ccb64168ba86e6","author_id":"5cee057c52ccb64168ba86dc","tab":"share","content":"<div class=\"markdown-text\"><p>官网 <a href=\"https://xjzproxy.xjz.pw/zh-cn/\">https://xjzproxy.xjz.pw/zh-cn/</a></p>\n<hr>\n<h2>主要功能</h2>\n<ul>\n<li>本地 API Mock 基于 YAML 文档，支持动态数据生成</li>\n<li>自动生成、导出 API 文档</li>\n<li>自动基于文档对比 API 请求响应数据格式，提前发现有问题的接口</li>\n<li>根据请求历史生成统计数据</li>\n<li>HTTP/HTTPS/HTTP2/GRPC 代理</li>\n</ul>\n<h2>我们遇到的问题</h2>\n<p>通过为了方便合作，在需求确定后，我们会先写一份接口文档给前端，然后前端按文档定义的接口去开发。</p>\n<p>在这期间我们可能会遇见很多问题:</p>\n<ol>\n<li>结构松散或是没有结构的文档格式，很难去管理、协作，写起来也麻烦</li>\n<li>只有文档，自己 mock 各种数据很麻烦，等真实接口好了才方便开发</li>\n<li>请求参数格式没按文档来，在个例下正常工作，到复杂的线上就出问题了</li>\n<li>后端接口没有文档格式来，在特定情况下前端没有处理而出问题</li>\n<li>接口改了，但文档没改，久而久之，文档形同虚设</li>\n</ol>\n<h2>我们的解决方案</h2>\n<ol>\n<li>使用 YAML 书写结构化的文档，数据结构可以复用。一个接口甚至可以简单到只需要几行</li>\n<li>文档完成后，你就相当于有了一个本地的后端服务器，文档中所有接口可以直接调用</li>\n<li>在请求文档接口时，我们会按文档检查请求参数是否与文档定义一致。遇到不匹配的将会有相应提示</li>\n<li>在连接上真实服务器时，我们会帮助你检查数据的返回格式是否与文档定义一致。遇到不匹配的将会有相应提示</li>\n<li>以上方式让文档主动参与到开发中，将督促使用者去更新文档</li>\n</ol>\n<h3>Example</h3>\n<p>一个最简单的项目文档示例</p>\n<pre class=\"prettyprint language-yaml\"><code>project:\n  host: mydomain.com\n\napis:\n  - title: Get a user\n    method: GET\n    path: &#x2F;api&#x2F;v1&#x2F;users&#x2F;\\d+\n    response:\n      success:\n        http_code: 200\n        data:\n          id: 1\n          name: .t&#x2F;name\n</code></pre><p>然后就可以通过文档代理来访问了</p>\n<pre class=\"prettyprint\"><code>$ curl http:&#x2F;&#x2F;mydomain.com&#x2F;api&#x2F;v1&#x2F;users&#x2F;123 --proxy localhost:9898\n{&quot;id&quot;: 1, &quot;name&quot;: &quot;random name&quot;}\n</code></pre><p>当然，你可以在移动设备、浏览器中通过代理地址访问接口。更多文档书写帮助请参考<a href=\"https://xjzproxy.xjz.pw/quick-start\">这里</a></p>\n<p>请求参数和文档对不上时，会有提示\n<img src=\"https://xjzproxy.xjz.pw/imgs/app-1.png\" alt=\"error_params\"></p>\n<h3>GRPC</h3>\n<p>如果你在使用 GRPC 的话，只要配置好 protobufs 的路径，就可以直接调用接口了。当然，如果你想定制 GRPC 接口返回的数据内容，还是需要在文档中定义好一些数据模板。</p>\n<h3>Preview</h3>\n<p>在工具中查看渲染好的漂亮文档也是不能少的。</p>\n<p><img src=\"https://xjzproxy.xjz.pw/imgs/app-2.png\" alt=\"doc_preview\"></p>\n<h3>More</h3>\n<p>更多功能介绍，可参考官网。欢迎大家试用。</p>\n<hr>\n<p>有兴趣的朋友可以在<a href=\"https://xjzproxy.xjz.pw/\">这里</a>下载试用（目前只支持 Mac 与 Ubuntu，其它系统以后看情况再折腾了)。</p>\n<p>如果需要使用 GRPC 或者需要更多的 API 数量（&gt; 128），发邮件到 base64 <code>eGllamlhbmd6aGlAZ21haWwuY29t</code>。我会给发送证书。记得带上标题 “XJZProxy 证书申请”，不然我可能注意不到。</p>\n</div>","title":"[工具] 文档即接口 - XJZProxy 提高你的开发、协作效率","last_reply_at":"2019-06-05T02:49:53.494Z","good":false,"top":false,"reply_count":6,"visit_count":583,"create_at":"2019-05-29T04:12:22.945Z","author":{"loginname":"xiejiangzhi","avatar_url":"https://avatars0.githubusercontent.com/u/1396853?v=4&s=120"}},{"id":"5b3748c457137f22415c5143","author_id":"5b37469f57137f22415c5140","tab":"share","content":"<div class=\"markdown-text\"><p>当你用了Koa以后，你肯定不会再用express，因为Koa太优秀了!</p>\n<p><strong>2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\"></a><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w</a></p>\n<p>Nodejs Koa交流群：319732955   想和大神交流的加下群</p>\n</div>","title":"2018 Nodejs+Koa2入门实战视频教程【共41集】-欢迎拍砖免费分享【网盘直接下载】","last_reply_at":"2019-06-05T02:19:18.536Z","good":false,"top":false,"reply_count":59,"visit_count":13321,"create_at":"2018-06-30T09:09:24.209Z","author":{"loginname":"koa666","avatar_url":"https://avatars3.githubusercontent.com/u/37576865?v=4&s=120"}},{"id":"5cf723b81fe902120f31c387","author_id":"5cf7238e1fe902120f31c382","tab":"share","content":"<div class=\"markdown-text\"><p>点击文章中的小册名称，跳转到掘金网站上就可以享受八折优惠。如图所示：</p>\n<p><img src=\"https://i.loli.net/2019/06/05/5cf71d7eae60e84679.jpg\" alt=\"1.jpg\"></p>\n<h1><strong>前端掘金小册推荐</strong></h1>\n<p><strong>小编精选推荐购买的前端相关掘金小册，均可以八折购买。</strong></p>\n<h2>1. <a href=\"https://juejin.im/book/5bdc715fe51d454e755f75ef?referrer=58cb7ee5ac502e00588d9d40\">优惠八折购买：前端面试之道 – yck</a></h2>\n<p><img src=\"https://i.loli.net/2019/06/05/5cf71d801a0b586323.jpg\" alt=\"2.jpg\"></p>\n<p>疲于业务的你，可能并没有多少时间好好学习，或者说不知道该学习什么才能提高自己的技术。对于前端开发者来说，尽早建立起一个完整的前端知识框架，了解当下大厂常考知识点，掌握面试技巧，是一个值得重视的正经事。</p>\n<h2>2. <a href=\"https://juejin.im/book/5baaf635f265da0ab915cc9f?referrer=58cb7ee5ac502e00588d9d40\">优惠八折购买：WebGL 入门与实践</a></h2>\n<p><img src=\"https://i.loli.net/2019/06/05/5cf71d802e51f62571.jpg\" alt=\"3.jpg\"></p>\n<h2>3. <a href=\"https://juejin.im/book/5b936540f265da0a9624b04b?referrer=58cb7ee5ac502e00588d9d40\">优惠八折购买：前端性能优化原理与实践</a></h2>\n<p><img src=\"https://i.loli.net/2019/06/05/5cf71d802cb6c22287.jpg\" alt=\"4.jpg\"></p>\n<h2>4. <a href=\"https://juejin.im/book/5a36661851882538e2259c0f?referrer=58cb7ee5ac502e00588d9d40\">优惠八折购买：剖析 Vue.js 内部运行机制 – 染陌</a></h2>\n<p><img src=\"https://i.loli.net/2019/06/05/5cf71d7fd52d729367.jpg\" alt=\"5.jpg\"></p>\n<p>本小册希望通过一种对新手更加友好直观的方式讲解 Vue.js 内部运行机制。把 Vue.js 拆分成多个小模块，讲解模块间的依赖以及调用关系。然后将源码核心部分抽离压缩，各个模块以小 Demo 的形式展现出来，用最少的代码讲解内部实现。掌握了这些模块的核心原理之后，再去阅读 Vue.js 源码或者是解决 Vue.js 的疑难杂症时，相信会更加得心应手。</p>\n<h2>5. <a href=\"https://juejin.im/book/5a124b29f265da431d3c472e?referrer=58cb7ee5ac502e00588d9d40\">优惠八折购买：Git 原理详解及实用指南 – 扔物线</a></h2>\n<p><img src=\"https://i.loli.net/2019/06/05/5cf71d7ff148e51550.jpg\" alt=\"6.jpg\"></p>\n<p>简单地总结：Git 难学，是因为它的概念难以整体理解。而这本小册，就是从概念的角度出发，帮你先从本质上了解 Git 的工作模型，在此基础上去了解它的具体用法，以此来达到四两拨千斤的学习效果。而且这样的学习具有更高的持久性，在看完这本小册之后，你以后也很难再忘掉 Git 的用法了。</p>\n<h2>6. <a href=\"https://juejin.im/book/5a1212bc51882531ea64df07?referrer=58cb7ee5ac502e00588d9d40\">优惠八折购买：用 npm script 打造超溜的前端工作流 – 王仕军</a></h2>\n<p><img src=\"https://i.loli.net/2019/06/05/5cf71d7ff202999250.jpg\" alt=\"7.jpg\"></p>\n<p>这本小册的切入点，我在这本小册中会用 step-by-step 的方式讲解如何使用 npm script 打造轻量级但完整的前端工作流。即使你是命令行小白，也能轻松跟上，小册会以实际前端项目为底板逐步介绍更高阶的话题。学完这本小册，你将熟知使用 npm script 打造前端工作流要用的各种小工具和技巧。</p>\n<h2>7. <a href=\"https://juejin.im/book/5ba42844f265da0a8a6aa5e9?referrer=58cb7ee5ac502e00588d9d40\">优惠八折购买：React 实战：设计模式和最佳实践</a></h2>\n<p><img src=\"https://i.loli.net/2019/06/05/5cf71d802e38a28659.jpg\" alt=\"8.jpg\"></p>\n<p>React 是当前最热门的网页开发框架之一，其简洁易用的特点吸引了全世界的网页开发者。React 只是一个工具，并没有强制要求开发者按照什么套路去开发应用，但这也给开发者带来一些迷茫，当遇到一个具体问题的时候，不知道该选取什么样的方法去解决。这个小册的目的，就是要解除 React 使用者的迷惑，帮助大家快速找到解决问题的办法。</p>\n<h2>8. <a href=\"https://juejin.im/book/5b73a131f265da28065fb1cd?referrer=58cb7ee5ac502e00588d9d40\">优惠八折购买：Taro 多端开发实现原理与项目实战</a></h2>\n<p><img src=\"https://i.loli.net/2019/06/05/5cf71d80188c846302.jpg\" alt=\"9.jpg\"></p>\n<p>在「大前端」的背景下，由于成本和效率的问题，业务产品不太可能为每个终端都单独的进行开发工作。但是如果你使用 Taro，就可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端(微信小程序、H5、App端等)运行的代码。同时 Taro 还提供开箱即用的语法检测和自动补全等功能，有效地提升了开发体验和开发效率。</p>\n<h2>9. <a href=\"https://juejin.im/book/5a8f9ddcf265da4e9f6fb959?referrer=58cb7ee5ac502e00588d9d40\">优惠八折购买：Web 前端面试指南与高频考题解析 – Alex007</a></h2>\n<p><img src=\"https://i.loli.net/2019/06/05/5cf71d7ff184b31547.jpg\" alt=\"10.jpg\"></p>\n<p>本小册参考一般面试流程，从「准备」开始，经过「一面（技术面试）」，「二面（侧重非技术能力）」和 「HR 面试」四大部分，打通整个的面试流程。其中「准备」、「非技术面试」和「HR 面试」三部分具有普适性，「一面（技术面试）」部分会先梳理前端知识体系框架，然后找出必考的知识点，再通过经典问题进行讲解分析。</p>\n</div>","title":"优质前端掘金小册推荐及优惠购买链接","last_reply_at":"2019-06-05T02:06:48.232Z","good":false,"top":false,"reply_count":0,"visit_count":194,"create_at":"2019-06-05T02:06:48.232Z","author":{"loginname":"sandy1504","avatar_url":"https://avatars3.githubusercontent.com/u/51390784?v=4&s=120"}},{"id":"5cf08cd44036f24194cf8369","author_id":"575e5645c1518403160a4584","tab":"ask","content":"<div class=\"markdown-text\"><p>有3台设备。</p>\n<ol>\n<li>家用的电脑</li>\n<li>一台可以通过公网访问的机器</li>\n<li>公司的电脑</li>\n</ol>\n<p>如何利用公网的机器通过 node 让家里的电脑访问公司电脑的本地服务器？\n我想到是用 socket，但是 npm 找的包都是客户端和服务端通信的，没有服务端主动发起 socket 请求的 api。</p>\n</div>","title":"如何通过一台公网机器访问公司电脑的本地服务器？","last_reply_at":"2019-06-04T15:50:50.217Z","good":false,"top":false,"reply_count":8,"visit_count":733,"create_at":"2019-05-31T02:09:24.022Z","author":{"loginname":"jamieYou","avatar_url":"https://avatars2.githubusercontent.com/u/19544032?v=4&s=120"}},{"id":"5cf5e2581fe902120f31be6e","author_id":"584d7dce4c17b38d35436595","tab":"ask","content":"<div class=\"markdown-text\"><p>这里使用的是createBrowserHistory({forceRefresh:true}强制刷新的做法，除了这个还有其他方法吗，用的是React-routerV4</p>\n<pre class=\"prettyprint language-bash\"><code>&#x2F;&#x2F; history\nimport { createBrowserHistory } from &quot;history&quot;;\nexport default createBrowserHistory({forceRefresh:true}); \n\nimport axios from &quot;axios&quot;; \nimport {fakeAuth} from &#x27;..&#x2F;util&#x2F;fakeAuth&#x27;;\nimport {message as Message} from &#x27;antd&#x27;;\nimport {timeout,baseURL} from &quot;.&#x2F;config.js&quot;;\nimport history from &#x27;.&#x2F;history&#x27;;\naxios.defaults.timeout = timeout;\naxios.defaults.baseURL = baseURL;\naxios.interceptors.request.use(\n    config =&gt; {\n        if (fakeAuth.authenticate()) {\n            config.headers.Authorization = &#96;Bearer ${sessionStorage.getItem(&#x27;loginToken&#x27;)}&#96;;\n        }\n        return config;\n    },\n    error =&gt; {\n        return Promise.reject(error);\n    }\n);\naxios.interceptors.response.use(\n    response =&gt; {\n        return response;\n    },\n    error =&gt; {\n        if (error.response) {\n            switch (error.response.status) {\n                case 401:\n                    fakeAuth.signout();\n                    history.push(&#x27;&#x2F;login&#x27;);\n                    break;\n                default:\n            }\n            const message = error.response.data.message ?error.response.data.message :&quot;服务器异常&quot;;\n            Message.error(message);\n        }\n        return Promise.reject(error);\n    }\n);\n</code></pre></div>","title":"React-router-dom如何在封装的axios中实现跳转","last_reply_at":"2019-06-04T15:47:16.431Z","good":false,"top":false,"reply_count":2,"visit_count":307,"create_at":"2019-06-04T03:15:36.990Z","author":{"loginname":"1261407209LHH","avatar_url":"https://avatars0.githubusercontent.com/u/15929863?v=4&s=120"}},{"id":"5b18a28557137f22415c49e9","author_id":"55d120f3b25bd72150842d85","tab":"share","content":"<div class=\"markdown-text\"><h1>前端进阶之困</h1>\n<p>最近看了不少文章和帖子， 如文：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5b124fdd5188257d6c0465da?utm_source=gold_browser_extension\">前端的焦虑，你想过30岁以后的前端路怎么走吗？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5af047150a36e5312d6ecdf0\">前端怎么一步步走向全栈呢？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5b164efa29e6e510415b2803\">移动端入门Node.js怎么学习?</a></li>\n<li><a href=\"https://cnodejs.org/topic/5a4cc04cebc575dc49b270d5\">前端的未来走向在哪里？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5ab1ebb5e7b166bb7b9eccaa\">工作2年多的前端，现在迷茫了，如何更进一步的提升自己</a></li>\n</ul>\n<p>身边和朋友圈也不少做前端开发的同事朋友问如何发展和提升\n这里我向大家给一些建议</p>\n<h2>扎实基础</h2>\n<p>首先思考下手上的工作是否做得足够好了，近几年前端技术发展迅猛各种框架层出不穷，刚学会jquery还没用熟， angular 、vue 、react 已经满大街了。\ngulp 还没明白怎么回事、webpack 已开始遍地开花了。眼花缭乱的技术不知道从哪里开始好。\n如果你还被这些困扰的话，那请静下来思考一下，技术的发展总是有规律的，学习也是有规律可循的，我的建议是，把共性和必要的技能先稳固下来，既不浪费时间，又能提高效率，如果这块还么稳固好、框架什么少看几种吧，先有一样可用的就好。\n对于加强基础一个可行的方案是，从自己上手的工作开始、除了专注现学现用工作需要的框架技术外加强基础的学习，如：</p>\n<ul>\n<li>基本的逻辑（与、或、非）</li>\n<li>运算操作（加减乘除 Math 下的各种函数）</li>\n<li>字符串处理 （什么大小写、编码、裁剪什么的）</li>\n<li>时间处理 （日期的加减、对比、格式转换等）</li>\n<li>数组、集合对象处理\n可以了解学习一些基础库 如: <a href=\"https://github.com/lodash/lodash\">lodash</a>、<a href=\"https://github.com/moment/moment\">moment</a> 等、若时间有限可以看看示例有个印象回头可以查找，当然最好的方式是实践练习。</li>\n</ul>\n<h2>发展全栈的正确姿势</h2>\n<p>Javascript 生态链对于全栈有一些优势，但全栈不是贴金的标签，如果技能不够硬，必然落得个 <strong>前端不强，后端不行</strong> 的尴尬局面。</p>\n<h3>那对于前端是不是不该发展后端呢？</h3>\n<p>回答当然是否定的，前端<em>有目的、有计划的发展后端技能</em>，对于系统全局观、工作协作能力提升是非常有帮助的，<strong>另外切实让老板愿意为你加工资是非常可能的</strong>。</p>\n<h3>那要如何才能是有目的、有计划的发展后端技能呢？</h3>\n<p>首先认清后端技能出发点和关键点。</p>\n<ul>\n<li>出发点: 是主动权和话语权（可能某个后端老是鄙视你，你要的东西，说这个没办法，那个不应该，造成了你工作很被动，效率不高，出错了可能还先找你）。</li>\n<li>关键点: 前后端接口 （如果你能清晰、标准、明确你要的接口，那么一些都会明朗起来）。\n所以我认为前端切入后端应该从接口开始。</li>\n</ul>\n<h3>从标准接口开始，什么样的接口才是标准的呢？</h3>\n<p><a href=\"https://swagger.io/resources/open-api/\">OpenAPI  Specification</a>\n这里我为大家推荐 Swagger 标准接口 (目前有两个标准 OAS 2.0 和 OAS 3.0)\nSwagger 致力于接口的标准化，并为此提供了一系列的工具，方便大家对进口进行标准化。</p>\n<h3>有什么好处呢</h3>\n<ul>\n<li>简化工作流程 (Streamline Your Workflow)。</li>\n<li>自由构建 (Restraint-Free Build)</li>\n<li>开放/全球化的支持 (Open &amp; Globally Supported)\n我的理解是增强系统的健壮性、降低沟通成本、提高写作效率，另外接口是系统的一种抽象可以更好的从宏观把握系统。</li>\n</ul>\n<h3>标准化的接口要如何实践</h3>\n<p>这里我安利下我的开源项目 <a href=\"https://github.com/vellengs/typerx\">typerx</a>, typerx 是一个轻量注解式的全栈系统、你可以使用他快速的实践接口标准的全栈开发。</p>\n<ul>\n<li>创建接口前、我们仍旧还是要考虑接口模块的、模块化的设计能降低我们一次思考的复杂度。\n在 typerx 中我们分了 core 模块和 cms 模块。</li>\n<li>接口的创建从原型开始考虑、确定接口所需的模型 model, 这个模型我们称之为 DTO(data transform object) 也就是接口的输入输出数据对象。\n<a href=\"https://github.com/vellengs/typerx/blob/master/packages/server/src/modules/core/dto\">dto 的编写示例</a></li>\n<li>有了模型之后我们就可以确定需要哪些接口方法了，编写接口的时候先不着急考虑接口的实现，我们只要先提供模型（可以建立一个按模型提供的数据mock)确保必要的接口规格描述就好，\n<a href=\"https://github.com/vellengs/typerx/blob/master/packages/server/src/modules/core/account.controller.ts\">account 的接口定义</a>\n这里我们通过直接编写代码的方式来实现文档，这样方便我们高效、可维护的接口文档（当然先完成文档再来生成代码也是可以的，不过代码能表述的永远比文档能描述的多，所以应该是有一套能够自动生成api 文档的代码来维护比较合适，过去也曾从文档开始，但文档的错漏不方便验证、而且文档维护数据模型是很累的一个事情无法动态关联重构）。</li>\n<li>按要求完成了接口定义之后，你只要轻松运行</li>\n</ul>\n<pre class=\"prettyprint\"><code>npm run build \n</code></pre><p>你就拥有标准的接口文档描述文件 swagger.json / swagger.yaml 了, 你可以使用 typerx 直接启动服务端预览接口 <a href=\"http://localhost:4700/docs\">localhost:4700</a> 或者放到在线编辑器上预览 <a href=\"http://editor.swagger.io/\">editor.swagger.io</a>;</p>\n<ul>\n<li>好了标准话的接口有了你可以保持这个接和后端的接口一致，这样就可以和后端愉快的协作了，当然如果你喜欢，直接使用 typerx 实现自己真实的后端。</li>\n</ul>\n<p>最后欢迎大家关注 <a href=\"https://github.com/vellengs/typerx\">typerx</a> 一起讨论努力进阶。</p>\n</div>","title":"前端如何进阶全栈开发","last_reply_at":"2019-06-04T15:25:41.547Z","good":false,"top":false,"reply_count":46,"visit_count":10779,"create_at":"2018-06-07T03:12:05.854Z","author":{"loginname":"vellengs","avatar_url":"https://avatars1.githubusercontent.com/u/5743338?v=4&s=120"}},{"id":"5cf5be941fe902120f31bd4d","author_id":"5bc6779d37a6965f5905229a","tab":"ask","content":"<div class=\"markdown-text\"><p>请问前辈们，有没有egg-authz/node-casbin的完整应用范例呢？可以帮忙提供一下吗！感谢感谢~~</p>\n<p>想参考别人的代码，看看怎麽运用，站在巨人的肩膀上，学习事半功倍呀！</p>\n</div>","title":"请问前辈们，有没有egg-authz/node-casbin  的完整应用范例呢？想参考别人的代码，看看怎麽运用，站在巨人的肩膀上，学习事半功倍呀！","last_reply_at":"2019-06-04T11:36:00.620Z","good":false,"top":false,"reply_count":1,"visit_count":311,"create_at":"2019-06-04T00:43:00.541Z","author":{"loginname":"Solomonqoo","avatar_url":"https://avatars3.githubusercontent.com/u/44214486?v=4&s=120"}},{"id":"5cf6463f1fe902120f31c143","author_id":"5ceca6e14036f24194cf7182","tab":"share","content":"<div class=\"markdown-text\"><h1>前言</h1>\n<p>之前发的帖子：<a href=\"https://cnodejs.org/topic/5ceca8f852ccb64168ba811d#5cf4c20295fcc914aa265988\">https://cnodejs.org/topic/5ceca8f852ccb64168ba811d#5cf4c20295fcc914aa265988</a></p>\n<blockquote>\n<p>发布了 vscode 版本后好评如潮，有许多用户需要其他 编辑器版本 和 浏览器版本 等\n经过各种调研，于是就产出了 PC 版本,支持 MAC+WIN\n为了更好的隐蔽，支持透明窗口，可以完美的嵌入各种软件界面上。</p>\n</blockquote>\n<h1>介绍</h1>\n<p><strong>Thief-Book</strong> 是一款真正的<code>摸鱼神器</code>，可以更加隐秘性大胆的看小说。</p>\n<ul>\n<li><strong>隐蔽性</strong> 自定义透明背景，随意调整大小，完美融入各种软件界面</li>\n<li><strong>快捷性</strong> 三个快捷键，实现完美的摸鱼</li>\n<li><strong>跨平台</strong> 支持 Mac+Win，Linux 暂未测试，请自行打包</li>\n</ul>\n<h1>VScode</h1>\n<p>Thief-Book 为用户提供 Vscode 版本，具体请看 <a href=\"https://github.com/cteams/Thief-Book-VSCode\">https://github.com/cteams/Thief-Book-VSCode</a></p>\n<h1>地址</h1>\n<ul>\n<li>Github :<a href=\"https://github.com/cteams/Thief-Book\"> https://github.com/cteams/Thief-Book</a></li>\n<li>下载地址 : <a href=\"https://github.com/cteams/Thief-Book/releases\">https://github.com/cteams/Thief-Book/releases</a></li>\n</ul>\n<h1>演示</h1>\n<h2>MAC</h2>\n<blockquote>\n<p>MAC 支持 任务栏版 + 桌面版</p>\n</blockquote>\n<p><img src=\"https://liu-yu.oss-cn-beijing.aliyuncs.com/tc/mac.gif\" alt=\"mac\"></p>\n<h2>WIN</h2>\n<blockquote>\n<p>WIN 只有桌面版</p>\n</blockquote>\n<p><img src=\"https://liu-yu.oss-cn-beijing.aliyuncs.com/tc/win.gif\" alt=\"win\"></p>\n<h1>快捷键</h1>\n<h2>MAC</h2>\n<p><strong>Cmd+Option+M</strong> 老板键</p>\n<p><strong>Cmd+Option+,</strong> 上一页</p>\n<p><strong>Cmd+Option+.</strong> 下一页</p>\n<h2>WIN</h2>\n<p><strong>Ctrl+Alt+M</strong>  老板键</p>\n<p><strong>Ctrl+Alt+,</strong> 上一页</p>\n<p><strong>Ctrl+Alt+.</strong> 下一页</p>\n<h1>TODO</h1>\n<ul>\n<li>[x] 任务栏版本</li>\n<li>[x] 桌面版本</li>\n<li>[x] 设置小说路径</li>\n<li>[x] 设置当前页数</li>\n<li>[x] 设置每页字数</li>\n<li>[x] 老板键</li>\n<li>[x] 上一页</li>\n<li>[x] 下一页</li>\n<li>[x] 英文小说支持</li>\n<li>[x] 自定义换行符号</li>\n<li>[x] 自定义桌面版背景</li>\n<li>[x] 自定义桌面版字体颜色</li>\n<li>[x] 跨平台兼容</li>\n<li>[x] 桌面版随意拖动，随意调整大小</li>\n<li>[x] 桌面版窗口永远顶置</li>\n<li>[ ] 多本小说管理</li>\n<li>[ ] 在线小说下载</li>\n<li>[ ] 股票支持</li>\n</ul>\n<h1>意见</h1>\n<p>大家有更好的意见，更好的想法，请 Github 留言</p>\n</div>","title":"Thief-Book 摸鱼神器终于发布了 PC 端","last_reply_at":"2019-06-04T10:21:51.890Z","good":false,"top":false,"reply_count":0,"visit_count":299,"create_at":"2019-06-04T10:21:51.890Z","author":{"loginname":"lauixData","avatar_url":"https://avatars1.githubusercontent.com/u/9290546?v=4&s=120"}},{"id":"5cc12d4537faec0ce1d06706","author_id":"5875bd3d06fa6e2a4e4f730b","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FsJPVoGNLeApbuZx9lRwmcv4LCfm\" alt=\"image.png\">\n前一秒还在劝人学node，后一秒就被打脸了。。。羞愧难当。。。顿时找不到理由反驳。</p>\n</div>","title":"一位同学因别人说node只适合中小型，放弃node学go,大家怎么看。","last_reply_at":"2019-06-04T10:18:20.685Z","good":false,"top":false,"reply_count":41,"visit_count":4576,"create_at":"2019-04-25T03:45:09.872Z","author":{"loginname":"zy445566","avatar_url":"https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"}},{"id":"5ce6646a52ccb64168ba6dc2","author_id":"58f837a3bbaf2f3f569be082","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>作者：鬼柒\n原文：<a href=\"https://www.douban.com/note/719582021/\">https://www.douban.com/note/719582021/</a>\n互联网时光机备份：<a href=\"https://archive.fo/6y5zJ\">https://archive.fo/6y5zJ</a></p>\n</blockquote>\n<p>996 ICU的项目来龙去脉相信很多人都知道了，这里不再复述。想了解清晰一点的话可以看看知乎这个答案  <a href=\"https://www.zhihu.com/question/317722302/answer/635760914\">996 ICU 项目的来龙去脉</a></p>\n<p>我现在正在做信息公开的申请，跟诉讼事宜，相关信息可以查看这篇稿子。 <a href=\"https://github.com/CPdogson/996action/blob/master/Press-releases/chengdususong.md\">996action行政诉讼第一案</a></p>\n<p>我自己已经没有在996了，而且也算是中高级职位，做好工期预估工作，推掉一些不合理需求，整个团队能够按照正常的工作时间进行，工作气氛不错，也可以利用一些业余时间学习，继续增进自己的能力，不过还是会有一些紧急情况，安排少量的加班不可避免。</p>\n<p>我开始关注加班问题，大概也是4-5年前了，当时某公司出现过劳猝死的事件，我发了一些拙见，也有几百个赞， <a href=\"https://www.zhihu.com/question/38567964/answer/77045960\">关于加班的一些个人观点</a></p>\n<p>当然更早一点的时候我就注意到所在的行业气氛，对加班居然已经形成了一种叫”加班文化“的流氓现象，所以一直都有在思考一些个人的出路，我自己也经历过1-2个月无休，每晚加班到凌晨的情况，到了极限的时候，脑袋里一团浆糊的感觉也越来越重。</p>\n<p>我深知其危害，也绝不会放弃思索解决之道。</p>\n<p>4月的时候爆发了这个事件，当时也是恰巧有好几个互联网公司公开半公开的说了996制度，厚颜无耻。</p>\n<p>IT从业人士积压了很多怨气，所以宣泄口一开，居然也形成了一股力量，开始开枝散叶，做了很多事情，其中狗崽开的子项目996action 996law 我个人觉得是一条既合法又严谨的方案，但是这里面要参与者实名去跟行政部门打交道，中国5千年的奴隶思维，就算到了近代，也还是有点怕，我也有点方。但是这件事必须去做，必须有人去做才行，我也想过在后面吆喝，鼓励其他人去做，然后我提提建议就行了，直到我意识到一个情况，大家都是这么想的。</p>\n<p>必须有人迈出第一步，我重新把所有资料认真研究了一遍，也跟狗崽细聊了一段时间。</p>\n<p>所以我为什么要做这些事情，信息公开申请，复议，诉讼等，因为我爱己，就绝不会继续折损自己的生命。然后我爱后代，既然爱护后代，就一定不能让TA们生活在一个坏时代，然后我热爱自己的职业，那么爱屋及乌，我也同情与我有相同遭遇的人们，如果我们真的爱我们的国与家，真正发自内心的爱，就是不能忍心让劳动者继续在泥潭里深陷，不能忍心所以要有所行动，能发一点光的，发点光，能发一点热的，发点热。就算到了最后，可能一无所获，但是这条路我们走过了，不管成功了或是失败了，以后的人们便可以看到种种的经验，有了前车之鉴，去探索更好的路，那么我们的努力也就绝不会枉费。</p>\n<p>而且狗崽还有其他朋友努力整理了很多资料，写了很多方案，稿件等，这件事如果没有人愿意参与，那么这些努力就白费了，我实在无法坐视不管，要多么多么难得，才会有人愿意在这件事上付出努力，我实在是没办法眼看这些非常善意的努力无法推进。</p>\n<p>最近诉讼还在等待立案，资料已经送达法院，后续会发生什么事情，我也不知道，咱也不敢问。</p>\n<p>但是很多开发者给我们发了很多鼓励的话，”加油！“” 注意安全！“” 祝马到成功 “等等</p>\n<p>我也有点紧张，行政部门的大佬打电话来问：”你为什么要跨市申请信息公开？你都不在这边工作“ ，我如实说，寄了好几个城市的申请，做汇总之后想对比一下不同城市的用工情况，对我个人而言，我以后选择其他工作也会作为参考，所以这件事于己于人，都是有利的。毕竟没有多少人愿意相信，我做这个事是为了一些毫不相关的陌生人。但是我在这里可以畅所欲言，我就是为了毫不相干的陌生人。</p>\n<p><strong>陌生人，我爱你</strong></p>\n</div>","title":"为什么“我”要做这些事 ，996 ICU是不是真的无解？","last_reply_at":"2019-06-04T08:28:11.458Z","good":false,"top":false,"reply_count":2,"visit_count":1042,"create_at":"2019-05-23T09:14:18.895Z","author":{"loginname":"shuiRong","avatar_url":"https://avatars1.githubusercontent.com/u/16076993?v=4&s=120"}},{"id":"5c1c425c76c4964062a1c0ef","author_id":"5c1c411f76c4964062a1c0e3","tab":"share","content":"<div class=\"markdown-text\"><p>推荐一个前端导航网站，记录了各种关于前端的网址，可以直接在对应社区查找问题。\n喜欢的话赶快收藏一波吧 ^^\n网站地址： <strong><a href=\"https://www.frontendjs.com/\">https://www.frontendjs.com/</a></strong></p>\n<p><img src=\"//static.cnodejs.org/Fk1zwq8EO9Ugzovv-D1T5-GUnuIy\" alt=\"3898986698-5c05daee066b9_articlex.png\"></p>\n</div>","title":"前端导航网址分享，觉得有帮助的可以收藏下","last_reply_at":"2019-06-04T07:50:50.052Z","good":false,"top":false,"reply_count":20,"visit_count":2738,"create_at":"2018-12-21T01:31:08.779Z","author":{"loginname":"bestvist","avatar_url":"https://avatars2.githubusercontent.com/u/22828569?v=4&s=120"}}]}