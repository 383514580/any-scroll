{"success":true,"data":[{"id":"5cbfd9aca86ae80ce64b3175","author_id":"4f447c2f0a8abae26e01b27d","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>时隔一年，Node.js 12 如约而至，正式发布第一个 <a href=\"https://github.com/nodejs/Release\">Current</a> 版本。</p>\n<p>该版本带来了诸如：</p>\n<ul>\n<li>V8 更新带来好多不错的特性。</li>\n<li>HTTP 解析速度提升。</li>\n<li>启动速度大幅提升。</li>\n<li>更好的诊断报告和堆分析工具。</li>\n<li>ESM 模块更新。</li>\n</ul>\n<p>原文地址：<a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/nodejs\">@nodejs</a>/introducing-node-js-12-76c41a1b3f3f\n语雀地址：<a href=\"https://www.yuque.com/egg/nodejs/nodejs-12\">https://www.yuque.com/egg/nodejs/nodejs-12</a></p>\n<h2>LTS vs Current</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/84182/1556074709431-35af45b8-ec7a-4a81-83d8-155eb519f04a.png#align=left&amp;display=inline&amp;height=389&amp;name=image.png&amp;originHeight=500&amp;originWidth=960&amp;size=58313&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>如果你不了解 Node.js 的  Long Term Support 发布策略的话，一定要看看 <a href=\"https://github.com/nodejs/Release\">https://github.com/nodejs/Release</a> 。</p>\n<p>就目前而言，Node.js 6.x 和 8.x 将在 2019 年末结束 LTS 的支持，大家尽快升级到 10.x 吧。</p>\n<h2>快速体验</h2>\n<pre class=\"prettyprint language-bash\"><code>$ nvs add node&#x2F;12\n$ nvs use 12\n$ node -v\nv12.0.0\n</code></pre><p>具体参考这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/63403762\">科普文：使用 nvs 管理本地 Node.js 版本</a></p>\n<h2>V8 更新到 7.4</h2>\n<blockquote>\n<p>大部分情况下，我们不用去考虑性能问题，坐等 V8 版本更新就好了。（大雾）</p>\n</blockquote>\n<p>本次版本更新，也带来了好几个不错的特性：</p>\n<ul>\n<li><a href=\"https://v8.dev/blog/v8-release-72#async-stack-traces\">异步堆栈跟踪</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-74#faster-calls-with-arguments-mismatch\">参数调用不匹配时的调用速度优化</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-73#faster-await\">更快的 await</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-72#javascript-parsing\">更快的 JavaScript 解析速度</a></li>\n</ul>\n<p><strong>同时，跑了下我们 Egg 的一些内部测试，发现序列化有 10~20% 的性能提升，恐怖如斯！</strong></p>\n<p>另，奇丑无比的 <a href=\"https://github.com/tc39/proposal-class-fields\">Private Class Fields</a> 也能用了：</p>\n<pre class=\"prettyprint language-javascript\"><code>class IncreasingCounter {\n  #count = 0;\n  \n  get value() {\n    console.log(&#x27;Getting the current value!&#x27;);\n    return this.#count;\n  }\n  increment() {\n    this.#count++;\n  }\n}\n</code></pre><h2>HTTP 解析速度提升</h2>\n<p>默认的 HTTP 解析器切换为 <a href=\"https://github.com/nodejs/llhttp\">llhttp</a> ，性能提升恐怖如斯：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/84182/1556072499637-686bb0e3-c75c-424c-851f-ad88aff183a2.png#align=left&amp;display=inline&amp;height=231&amp;name=image.png&amp;originHeight=404&amp;originWidth=1302&amp;size=88775&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>启动速度提升</h2>\n<p>通过 <a href=\"https://v8.dev/blog/code-caching\">v8 code cache</a> 的支持，<a href=\"https://github.com/nodejs/node/pull/27161\">在构建时提前为内置库生成代码缓存</a>，从而提升 30% 的启动耗时。\n同时，通过<a href=\"https://github.com/nodejs/node/pull/24950\">重用主进程缓存</a>，Workers Threads 的启动速度提升了 60% 。</p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>Workers Threads</h2>\n<p>在 10.x 已经引入的 <a href=\"https://nodejs.org/api/worker_threads.html\">Workers Threads</a> 特性，在 12.x 里面默认启用，无需使用 <code>--experimental-worker</code> 开启。同时基于上一条的介绍，启动的速度也得到大幅提升。</p>\n<p>相关介绍：[<a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/Trott\">@Trott</a>/using-worker-threads-in-node-js-80494136dbb6](<a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/Trott\">@Trott</a>/using-worker-threads-in-node-js-80494136dbb6)</p>\n<h2>诊断报告</h2>\n<p>提供了新的实验性功能『诊断报告』，一个非常有用的特性。\n可用于帮助分析诸如：崩溃，性能问题，内存泄漏，高 CPU 占用等等问题。详见 <a href=\"https://medium.com/the-node-js-collection/easily-identify-problems-in-node-js-applications-with-diagnostic-report-dc82370d8029\">这篇文章</a>。</p>\n<blockquote>\n<p>点评：这也是 <a href=\"https://www.aliyun.com/product/nodejs\">AliNode</a> 之前的一个卖点之一。</p>\n</blockquote>\n<h2>Heap Dump</h2>\n<p>以前我们分析问题的时候，需要手动安装对应的类库或者使用 AliNode。</p>\n<p>在 12.x 里面内置了该功能，详见：</p>\n<ul>\n<li><a href=\"https://github.com/nodejs/node/pull/27133\">https://github.com/nodejs/node/pull/27133</a></li>\n<li><a href=\"https://github.com/nodejs/node/pull/26501\">https://github.com/nodejs/node/pull/26501</a></li>\n</ul>\n<blockquote>\n<p>点评：又一个 <a href=\"https://www.aliyun.com/product/nodejs\">AliNode</a> 的功能被内置了。但其实影响不大，AliNode 的核心在于分析平台，这块的采集能力，本来他们就打算开源回馈出去的。</p>\n</blockquote>\n<p>同时，由于上述提到的 V8 升级，现在可以按照可用内存动态调整堆大小了。</p>\n<h2>ESM 模块方案更新</h2>\n<p>ES6 模块仍然还在实验阶段，不过有了新的方式，具体参见<a href=\"https://medium.com/%5B@nodejs%5D(/user/nodejs)/announcing-a-new-experimental-modules-1be8d2d6c2ff\">这篇文章</a>。</p>\n<blockquote>\n<p>点评：让子弹再飞一会，该特性真的不是痛点，不急。</p>\n</blockquote>\n<h2>其他更新</h2>\n<ul>\n<li>更好的原生模块支持，<a href=\"https://nodejs.org/api/n-api.html#n_api_n_api\">N-API</a> 升级为版本 4，并 backport 到 Node.js 8.x 和 10.x。详细参见<a href=\"https://medium.com/the-node-js-collection/new-features-bring-native-add-ons-close-to-being-on-par-with-js-modules-cd4f9b8e4b4\">这篇文章</a>。</li>\n<li>TLS 升级为 1.3， <a href=\"https://developer.ibm.com/blogs/openssl-111-has-landed-in-nodejs-master-and-why-its-important-for-nodejs-lts-releases/\">增强安全功能</a>。</li>\n<li>随着 C++ 编译器的更新，现在要求 <code>GCC 6</code> 和 <code>glibc 2.17</code> ，对应的操作系统 Win7 和 macOS 10，详细参见<a href=\"https://github.com/nodejs/node/blob/v12.x/BUILDING.md#platform-list\">这篇文章</a>。</li>\n</ul>\n<p>不过目前 node-gyp 的一些原生模块会编译失败：</p>\n<pre class=\"prettyprint language-bash\"><code>nunjucks@3.2.0 › chokidar@2.1.5 › fsevents@^1.2.7 optional error: Error: Run &quot;sh -c node install&quot; error, exit code 1\n    at ChildProcess.&lt;anonymous&gt; (&#x2F;Users&#x2F;tz&#x2F;.npm-global&#x2F;lib&#x2F;node_modules&#x2F;tnpm&#x2F;node_modules&#x2F;_runscript@1.3.0@runscript&#x2F;index.js:74:21)\n    at ChildProcess.emit (events.js:196:13)\n    at maybeClose (internal&#x2F;child_process.js:1000:16)\n    at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:267:5)\n</code></pre></div>","title":"Node 12 值得关注的新特性","last_reply_at":"2019-05-06T10:38:11.791Z","good":false,"top":true,"reply_count":30,"visit_count":10722,"create_at":"2019-04-24T03:36:12.582Z","author":{"loginname":"atian25","avatar_url":"https://avatars2.githubusercontent.com/u/227713?v=4&s=120"}},{"id":"5bd4772a14e994202cd5bdb7","author_id":"504c28a2e2b845157708cb61","tab":"share","content":"<div class=\"markdown-text\"><p>2018年10月27日晚上，突然收到服务器不能访问的告警通知，拜托了狼叔 <a href=\"/user/i5ting\">@i5ting</a> 帮忙看看，结果登不上也ping不通。\n后来收到短信，发现是被ucloud封了，短信内容如下：</p>\n<blockquote>\n<p>【UCloud】尊敬的UCloud用户，您的IP：123.59.77.142  存在URL ：<a href=\"https://cnodejs.org/topic/57239bce5a26c4a841ecbf01\">https://cnodejs.org/topic/57239bce5a26c4a841ecbf01</a> （详细信息请查看邮箱）包含违禁内容（包括但不限于翻墙等），违反了国家有关法律法规。目前依主管单位要求，对您的IP予以封停，请您尽快处理违规内容。待处理完成后请联系技术支持重新开启业务。[4000188113]</p>\n</blockquote>\n<p>然后联系了ucloud的客服，一下就打通了，对方态度挺好处理问题也快。ucloud说是运营商那边封的，不是他们的检测机制。所以需要联系运营商解决。\n考虑到各位亲爱的网友们的行为我无法控制，那么一直跟越来越严格的审查系统对抗只会让自己疲惫，所以我就站点迁到国外。来到了aws jp。</p>\n<p>我大致测了测，电信和移动的访问速度非常快，100ms以内，联通会慢一点，400ms以内吧。</p>\n<p>建议翻墙访问。</p>\n</div>","title":"服务器迁移至 aws 日本机房","last_reply_at":"2019-05-05T09:20:06.831Z","good":false,"top":true,"reply_count":190,"visit_count":38355,"create_at":"2018-10-27T14:33:14.694Z","author":{"loginname":"alsotang","avatar_url":"https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"}},{"id":"5cd0e0d2776fb66e0d172bb0","author_id":"5cac197b7edd13064e053b71","tab":"share","content":"<div class=\"markdown-text\"><p>ts是前端必备技能，此教程类 接口 泛型 泛型类、模块、装饰器都讲了，算是市面上最全的ts教程。 废话不多说 直接上地址。</p>\n<p><strong>2019年5月更新TypeScript入门实战教程B站地址:</strong></p>\n<p><a href=\"https://www.bilibili.com/video/av38379328/?p=1\">https://www.bilibili.com/video/av38379328/?p=1</a></p>\n<p><strong>2019年5月更新TypeScript入门实战教程百度网盘地址:</strong></p>\n<p><a href=\"https://pan.baidu.com/s/17jllW0igIOWjM3YCvWS-bg\">https://pan.baidu.com/s/17jllW0igIOWjM3YCvWS-bg</a></p>\n</div>","title":"2019年5月更新TypeScript入门实战教程-类 接口 泛型 泛型类 ts封装类似Mongoose的db库、装饰器-免费分享","last_reply_at":"2019-05-07T01:45:09.739Z","good":false,"top":false,"reply_count":1,"visit_count":26,"create_at":"2019-05-07T01:35:14.483Z","author":{"loginname":"xiaofenlin","avatar_url":"https://avatars3.githubusercontent.com/u/49425206?v=4&s=120"}},{"id":"5cd0de895a5bae6e07813a04","author_id":"58f023c5e54976e847e0a039","tab":"ask","content":"<div class=\"markdown-text\"><p>用过express写过两个很小的项目，但是对于nodejs本身了解的很少。每次想要好好的学习下nodejs，然而点开文档，随便找一个模块都发现api这么多。 在这么多的api当中，如何选择最常用的。</p>\n</div>","title":"nodejs的api这么多，在学习的过程中应该如何有的放矢。","last_reply_at":"2019-05-07T01:44:29.633Z","good":false,"top":false,"reply_count":3,"visit_count":41,"create_at":"2019-05-07T01:25:29.133Z","author":{"loginname":"WUSO01","avatar_url":"https://avatars0.githubusercontent.com/u/21070775?v=4&s=120"}},{"id":"5b7ac9c7c52ad1482eb940bf","author_id":"5b52cbf1fb9e84ec69cc1ca2","tab":"ask","content":"<div class=\"markdown-text\"><p>Egg.js现在用的人多吗？那些公司在用有知道的吗？</p>\n<p>同上，老铁们出来吧。</p>\n</div>","title":"Egg.js现在用的人多吗？那些公司在用有知道的吗？","last_reply_at":"2019-05-07T01:41:58.118Z","good":false,"top":false,"reply_count":107,"visit_count":12274,"create_at":"2018-08-20T14:01:43.981Z","author":{"loginname":"nodeper","avatar_url":"https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"}},{"id":"5cd05b4e5a5bae6e0781394a","author_id":"55d15035b25bd72150842db8","tab":"ask","content":"<div class=\"markdown-text\"><ol>\n<li>假如第一版已经上线运行，第二版要发布，重启服务的话不就断掉啦？是不是至少部署两台机器，然后用nginx去转发一下？有没有大神能提供一些实现细节</li>\n<li>单元测试是必写的吗？</li>\n<li><a href=\"https://github.com/papertiger8848/modelproxy\">https://github.com/papertiger8848/modelproxy</a> 类似这种的轻量级的接口配置建模框架，在eggjs里有没有更好的</li>\n</ol>\n</div>","title":"【部署上线】eggjs服务的疑问","last_reply_at":"2019-05-07T01:40:36.981Z","good":false,"top":false,"reply_count":4,"visit_count":127,"create_at":"2019-05-06T16:05:34.174Z","author":{"loginname":"luckymore","avatar_url":"https://avatars0.githubusercontent.com/u/5390013?v=4&s=120"}},{"id":"5ccd52a25a5bae6e07812b40","author_id":"5ccd522a776fb66e0d171b7c","tab":"ask","content":"<div class=\"markdown-text\"><p>router.post(’/upload’, multiparty({\nuploadDir: ‘./public/source’\n}), async(ctx, next) =&gt; {</p>\n<p>console.log(‘22’)\n**  无法打印出session**\nconsole.log(ctx.session)\nlet files = JSON.stringify(ctx.req.files)</p>\n<p>files = JSON.parse(files)\nconsole.log(files)</p>\n<p>})</p>\n</div>","title":"koa使用koa2-multiparty上传文件   session获取不到   求大佬解答","last_reply_at":"2019-05-07T01:28:22.506Z","good":false,"top":false,"reply_count":3,"visit_count":326,"create_at":"2019-05-04T08:51:46.702Z","author":{"loginname":"CHxtz","avatar_url":"https://avatars2.githubusercontent.com/u/37284580?v=4&s=120"}},{"id":"5cd0da52776fb66e0d172b53","author_id":"5831a35367db500b79c100f7","tab":"share","content":"<div class=\"markdown-text\"><p>通用企业应用接口管理系统（Common Enterprise Application interface Management System）为用户提供基于Node.js的云端微服务应用开发运维，以及API管理解决方案。</p>\n<p>CEAMS为云端微服务应用提供基于浏览器的在线一体化开发、调试、部署、监控管理、访问认证等能力。用户可在CEAMS系统上使用大量方便的云端服务应用的自动化开发和管理功能，例如自动化测试工具、代码和文档生成，零中断时间的一键升级和回滚应用版本，应用代码下载上传、版本比较等方便的功能。</p>\n<p>CEAMS系统由系统管理终端、应用开发管理网站及门户、以及高性能应用服务器三部分组成。系统为用户提供基于网页的统一在线应用门户中心，用户可在其中查看系统中部署的各类在线应用，同时提供对应用的分类和检索能力。CEAMS系统提供在线测试、浏览API文档、自动生成调用方接入代码等方便功能。</p>\n<p>统一的应用展示中心，用户可从中添加自己需要的服务资源：\n<img src=\"//static.cnodejs.org/FmuMOo6CLc4Lotb_XjI_NYDODvNr\" alt=\"统一的应用展示中心，用户可从中添加自己需要的服务资源\"></p>\n<p>自动生成清晰严谨API文档和API接入端代码，支持基于JSON Schema的数据校验：\n<img src=\"//static.cnodejs.org/Ftc5JJGJSqJuHSYmlS4_R1LxaF27\" alt=\"自动生成清晰严谨API文档和API接入端代码，支持基于JSON Schema的数据校验\"></p>\n<p>为方便开发，CEAMS系统为用户的云端应用提供统一的API规范，以及基于该规范的HTTP + JSON的API调用接口，可支持各类客户端，例如移动端app，企业后台应用等类型应用的接入。开发云端应用时，用户首先在平台上编辑并生成应用的API规范。CEAMS系统为云端微服务应用提供的统一API规范借鉴了部分UPnP规范的设计，可被看成是一个JSON版的WSDL规范。基于该API规范，平台为应用提供各项方便的自动化能力，例如API文档、客户端接入代码自动生成、应用框架代码自动生成、基于JSON schema的严格数据校验能力、基于JSON schema form表单自动生成的API测试工具、灵活的API数据缓存和限流保护等能力。</p>\n<p>基于JSON Schema form自动输入表单生成能力的API测试工具：\n<img src=\"//static.cnodejs.org/Fv7xgtTHScmN4-O1dFphhlN_mYKf\" alt=\"基于JSON Schema form自动输入表单生成能力的API测试工具\"></p>\n<p>在CEAMS系统中，每个应用是一个标准的NPM包，可以对其添加任意开源第三方NPM依赖。在API规范编辑完成后，系统将自动为应用生成应用的框架代码，包含一个NPM包所需要的所有基础文件，以及API实现函数的入口等，开发者只需要编写函数的实现部分代码即可完成开发，而无需关心繁琐的HTTP协议实现，传参方法等。</p>\n<p>系统为开发者提供了基于Web IDE的线上开发环境，可支持多用户同时在线开发。用户可以在在浏览器中，线上完成应用的开发、调试、和部署，而无需重复代码在本地开发测试，线上部署的繁琐过程。得益于CDIF应用服务器提供的热更新能力，应用从启动调试到完成部署仅需数十秒即可完成。同时，系统也支持在VSCode等流行的IDE中完成应用的线下开发调试，并通过NPM压缩包格式一键上传到系统中并部署。</p>\n<p>基于浏览器的云端开发环境，支持多人同时在线开发调试，Web Terminal和Node.js REPL：\n<img src=\"//static.cnodejs.org/Fus7E2QmUJNCxmAuJ-5J9M7yTJfq\" alt=\"基于浏览器的云端开发环境，支持多人同时在线开发调试，Web Terminal和Node.js REPL\"></p>\n<p>系统提供完整的Node.js NPM生态支持（<a href=\"https://www.npmjs.com\">https://www.npmjs.com</a>），用户可自由引用NPM生态中70多万个各类开源包中的任意一个，例如各类工具库、数据库驱动，消息中间件接口等，帮助方便地开发其云端应用和对接到各类异构系统资源。为方便使用，CEAMS系统为用户提供了免费的国内高速NPM镜像，内置了常用的数千个NPM包资源，并可实时自动更新版本和添加更多第三方开源NPM包。同时，系统内置了对各类常用协议，例如对REST API、SOAP等的支持，可帮助应用开发者方便地连接并从其他系统获取应用开发需要的数据和能力。</p>\n<p>CEAMS系统已支持Node.js最新版本带来的多线程能力。在多线程模式下，每个应用部署于独立的worker线程中，并具备单独的线程上下文和堆空间，执行高CPU占用率任务时不会阻塞其他应用的执行。同时适用于I/O密集型与CPU密集型任务，如API网关和数据计算处理等。CEAMS系统的应用服务器可无缝地随时在传统的单线程和新的多线程模式下切换，对已部署的应用毫无感知。</p>\n<p>应用服务器同时提供Node.js单线程和多线程运行模式，并可指定扩容实例个数：\n<img src=\"//static.cnodejs.org/FlNUNg68sL-pNaHYNFMmtsssEI7z\" alt=\"应用服务器同时提供Node.js单线程和多线程模式，并可指定应用服务器扩容实例数量\"></p>\n<p>更进一步，基于CDIF应用服务器为应用提供的统一JSON数据接口，在获得相应的应用访问权限后，用户可使用纯粹JSON 数据格式调用系统中部署的其他应用，灵活地组织和处理来自不同应用的JSON 数据，并使用lodash、JSON path等高效的数据转换和查询工具，配合async等异步并发流程控制组件，组织出复杂、高性能的组合微服务应用逻辑和工作流程场景。</p>\n<p>为帮助用户使用，CEAMS系统封装了Node.js多线程API，为不同应用线程之间的数据相互调用提供了高性能的异步消息接口，并且在单线程模式和多线程模式下完全统一。用户无需理解和使用繁杂的Node.js多线程API，或基于Cluster的多进程模型。只需要在应用的任何位置添加几行代码，创建对任意服务应用的客户端对象，并根据该服务应用提供的JSON API规范，即可完成和该服务应用之间的数据对接。</p>\n<p>CEAMS系统已被成功应用于国内省级警务云平台建设，以及其他多个政企项目中，并稳定运行至今。我们在期间从未收到过一次故障崩溃报告。</p>\n<p>目前，我们已为CEAMS系统已提供社区版免费下载，社区版包含了系统的全部功能，可以满足中小规模应用场景。用户可以通过bash安装脚本，在常用的Linux操作系统上一键下载、安装和启动整个系统。以下是CEAMS产品的下载连接，其中包含了系统的下载安装方法、用户手册、开发指南等文档：</p>\n<p><a href=\"https://www.apemesh.com/cn/download\">CEAMS系统下载连接</a></p>\n<p>如果您对CEAMS系统的使用有任何问题，欢迎您邮件至：support@apemesh.com，或者加入灵长科技技术支持QQ群：618450152 向我们询问和了解。</p>\n</div>","title":"CEAMS: 基于Node.js的高效微服务应用开发运维和API管理系统提供免费下载使用","last_reply_at":"2019-05-07T01:07:30.793Z","good":false,"top":false,"reply_count":0,"visit_count":50,"create_at":"2019-05-07T01:07:30.793Z","author":{"loginname":"out4b","avatar_url":"https://avatars2.githubusercontent.com/u/13964618?v=4&s=120"}},{"id":"5cd0162d5a5bae6e07813834","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FgUggHAIOwyOUF2qy6xgsS7nsiks\" alt=\"image.png\"></p>\n<p>每天更新外包资源，尽在微信小程序：小猿众包 。扫一扫</p>\n<p><img src=\"//static.cnodejs.org/FvdVcZiXziCn000KpsP3ha7TJsX_\" alt=\"image.png\"></p>\n<p>可以加官方微信群：\n<img src=\"//static.cnodejs.org/Fmbw-S1GjdL2_pLzeUlfv98--DNv\" alt=\"image.png\"></p>\n</div>","title":"有没有朋友接私活，报酬 5万-10万","last_reply_at":"2019-05-07T00:59:08.733Z","good":false,"top":false,"reply_count":4,"visit_count":330,"create_at":"2019-05-06T11:10:37.253Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5cd0490b776fb66e0d172aa3","author_id":"4f50e82198766f5a610bbaff","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://note.youdao.com/ynoteshare1/index.html?id=5b4084bf0dd4e456cf7c813eec4b7d6a&amp;type=note\">https://note.youdao.com/ynoteshare1/index.html?id=5b4084bf0dd4e456cf7c813eec4b7d6a&amp;type=note</a></p>\n</div>","title":"前端如何做excel表格的导出","last_reply_at":"2019-05-07T00:29:22.312Z","good":false,"top":false,"reply_count":1,"visit_count":121,"create_at":"2019-05-06T14:47:39.701Z","author":{"loginname":"151263","avatar_url":"//gravatar.com/avatar/595ec965d51c7e3c6a7d1e8eb177dd8d?size=48"}},{"id":"5c1c425c76c4964062a1c0ef","author_id":"5c1c411f76c4964062a1c0e3","tab":"share","content":"<div class=\"markdown-text\"><p>推荐一个前端导航网站，记录了各种关于前端的网址，可以直接在对应社区查找问题。\n喜欢的话赶快收藏一波吧 ^^\n网站地址： <strong><a href=\"https://www.frontendjs.com/\">https://www.frontendjs.com/</a></strong></p>\n<p><img src=\"//static.cnodejs.org/Fk1zwq8EO9Ugzovv-D1T5-GUnuIy\" alt=\"3898986698-5c05daee066b9_articlex.png\"></p>\n</div>","title":"前端导航网址分享，觉得有帮助的可以收藏下","last_reply_at":"2019-05-07T00:24:49.338Z","good":false,"top":false,"reply_count":16,"visit_count":2272,"create_at":"2018-12-21T01:31:08.779Z","author":{"loginname":"bestvist","avatar_url":"https://avatars2.githubusercontent.com/u/22828569?v=4&s=120"}},{"id":"5cd0575a5a5bae6e07813941","author_id":"5c91ace496558e26e1b677bd","tab":"ask","content":"<div class=\"markdown-text\"><p>nodejs中对于大文件一般是用stream来操作的，但是对于更大的文件，处理还是很耗时间。所以我就想能不能用子进程结合fs.createReadStrem的方式，使用其中的start,end来进行文件分片，再交由子进程读取后使用process.send发给主进程。但是自己写的代码发现往往比单进程还要耗时，请问我这样的思考方向有问题吗？另外，现在我学nodejs纯粹是想到哪写到哪，请问有没有什么好的nodejs书籍或者在线学习的地方推荐？劳烦各位解疑了，谢谢。</p>\n</div>","title":"Nodejs对于大文件分片的思考","last_reply_at":"2019-05-06T18:45:25.993Z","good":false,"top":false,"reply_count":1,"visit_count":109,"create_at":"2019-05-06T15:48:42.535Z","author":{"loginname":"HyperClockUp","avatar_url":"https://avatars2.githubusercontent.com/u/36909196?v=4&s=120"}},{"id":"5cc7a14705ae566f637fdb44","author_id":"580f6fcab37ee8fb339787ea","tab":"ask","content":"<div class=\"markdown-text\"><p>之前服务端使用PHP写的，只有一个域名，前后端做了分离，现在部分新接口改用Java开发了，每个服务都有一个单独的域名</p>\n</div>","title":"请教一个问题，前端要从多个域名接口拿数据，一般是在前端进行配置还是写一个node服务中间层做所有的请求转发？","last_reply_at":"2019-05-06T15:43:06.552Z","good":false,"top":false,"reply_count":7,"visit_count":993,"create_at":"2019-04-30T01:13:43.154Z","author":{"loginname":"lzq920","avatar_url":"https://avatars0.githubusercontent.com/u/37999725?v=4&s=120"}},{"id":"5b7f8a2c944cb8340c27e335","author_id":"5b72f6727271129a2f32a97f","tab":"share","content":"<div class=\"markdown-text\"><p>2018年Nodejs Koa2 Typescript Eggjs Vue2最新教程资源网盘分享：\n<a href=\"https://pan.baidu.com/s/1O2C6TolDzYpMnKIfQaaqog\">Nodejs视频教程</a>\n<a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">Koa2教程</a>\n<a href=\"https://pan.baidu.com/s/17jllW0igIOWjM3YCvWS-bg\">6月Typescript教程</a>\n<a href=\"https://pan.baidu.com/s/1a8-RY-aBm3YkH2ZqJKmztg\">8月Eggjs视频教程</a>\n需要更多学习资源可留下邮箱，有的就分享</p>\n</div>","title":"2018年Nodejs Koa2 Typescript Eggjs Vue2最新教程资源网盘分享","last_reply_at":"2019-05-06T14:03:09.111Z","good":false,"top":false,"reply_count":42,"visit_count":7340,"create_at":"2018-08-24T04:31:40.973Z","author":{"loginname":"chengl123","avatar_url":"https://avatars3.githubusercontent.com/u/42384077?v=4&s=120"}},{"id":"5cd0393c776fb66e0d172a5c","author_id":"55d15035b25bd72150842db8","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fqsitokl6-Z9q2eBZyhoMOYvAZBi\" alt=\"image.png\"></p>\n</div>","title":"计算机语言的性能指标都是啥意思？","last_reply_at":"2019-05-06T13:40:12.297Z","good":false,"top":false,"reply_count":0,"visit_count":101,"create_at":"2019-05-06T13:40:12.297Z","author":{"loginname":"luckymore","avatar_url":"https://avatars0.githubusercontent.com/u/5390013?v=4&s=120"}},{"id":"5c976feefd41137eb7660fca","author_id":"57f2384783a4d9176a71da75","tab":"share","content":"<div class=\"markdown-text\"><h2>TL；DR</h2>\n<p><a href=\"http://Logoly.Pro\">Logoly.Pro</a> 是一个在线的 PornHub 风格 Logo 生成工具，可以帮助你快速生成类似 PornHub 风格的 Logo</p>\n<p><img src=\"https://i.loli.net/2019/03/24/5c976fdcf01a8.png\" alt></p>\n<p>目前项目已经上线：<a href=\"https://logoly.pro/\">https://logoly.pro/</a>\n代码也已开源：<a href=\"https://github.com/bestony/logoly\">https://github.com/bestony/logoly</a></p>\n<p><strong>欢迎各位前来试用 &amp;&amp; 求 Star !</strong></p>\n<hr>\n<p>昨晚，我花了 5 个小时，在肝一个项目，如今，让他成功上线，我便向大家介绍一下他。</p>\n<h2>突发的灵感</h2>\n<p>我自己平时经常要做一些 Side Project ，在做 Side Project 的时候，就涉及到了要做 Logo ，但是作为一个没有设计感的程序员，在做 Logo 时总是会做出一些很丑的 Logo ，于是痛定思痛，想想有没有什么有用的工具可以帮助我生成好看的 Logo。对于我来说，也不需要太过复杂，能够满足我自己的要求就行。</p>\n<p>那么这就要求这个 Logo 有一些特点</p>\n<ol>\n<li><strong>设计简单</strong>：很多带吉祥物的 Logo 就不适合我了，因为要去准备吉祥物的图片。</li>\n<li><strong>辨识度高</strong>：单纯的简单并没有太多的用处， Logo 需要让用户能够记住</li>\n</ol>\n<p>经过一番筛选，PornHub 的 Logo 进入到我的视线。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/24/169adc89cb1d0857?w=926&amp;h=312&amp;f=png&amp;s=16159\" alt></p>\n<h2>设计产品</h2>\n<p>在开发之前，我先进行了产品方面的考虑，看看我需要做哪些功能，哪些不做，最终得到了这样一个清单：</p>\n<p><strong>要做的项目</strong></p>\n<ol>\n<li><strong>项目使用 Vue 开发</strong>，因为可以快速上线</li>\n<li><strong>项目使用 Netlify 部署</strong>，这样就可以使用自己的域名，并使用 SSL，速度还要比 Github Pages 快一些。</li>\n<li><strong>项目应当支持自定义文字</strong>，这个是最基础的功能需求，必须要做的。</li>\n<li><strong>项目应当支持自定义颜色</strong>，毕竟可能有其他的方面，需要类似风格，但是不同的颜色的 Logo</li>\n<li><strong>项目应当支持自定义文字大小</strong>，毕竟我导出的是 PNG，如果不能自定义大小，大家可能会很困扰。</li>\n<li><strong>项目应当加入 Google Analytics</strong>，加入统计，就知道有多少人用过我的项目了，也是一种成就感。</li>\n<li><strong>项目应当加入我的个人信息，用来给我自己推广</strong>，顺便刷一波脸。</li>\n<li><strong>社会化分享</strong>，应当有个方便的分享方法，这样才能够更好的帮助项目在前期成长。</li>\n</ol>\n<p><strong>不做的项目</strong></p>\n<ol>\n<li><strong>自定义字体</strong>：原汁原味的 PH 风格，怎能瞎改字体呢？</li>\n<li><strong>导出 JPG</strong>： 有了透明背景的 PNG，不透明的 JPG 的需求就没那么大了。</li>\n</ol>\n<p><strong>后续迭代实现的</strong></p>\n<ol>\n<li><strong>其他简单的 Logo</strong>：比如 Youtube.</li>\n</ol>\n<h2>设计布局</h2>\n<p>在完成了产品的功能，我又进行了布局的设计，这次我用的是 Adobe XD，最近很喜欢用这个工具来设计产品的界面，非常的方便。最终设计完成的版本如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/24/169adc89ca709b11?w=1920&amp;h=1700&amp;f=png&amp;s=70050\" alt></p>\n<p>设计完成后，就要开始准备开始编码了。</p>\n<h2>找库</h2>\n<p>一开始，我考虑使用一些 UI Framework ,不过，由于一开始没有引入 UI Framework， 快写完了才发现基本不需要组件库，干脆将错就错，这样用了。</p>\n<p>在完成了基本的界面后，就是涉及到的一些库的使用了，这里要感谢前端生态圈的繁荣，我从 <a href=\"https://picas.now.sh/\">Picas</a> 和 <a href=\"https://carbon.now.sh/\">Carbon</a> 的源码里找到了我想要用的库。</p>\n<ul>\n<li><strong>dom-to-image</strong>: 将 Dom 元素转换成为图片，以备下载。</li>\n<li><strong>file-save</strong>: 在 Vue 组件里调用系统的下载接口，下载图片</li>\n</ul>\n<p>其他我用到的库还有</p>\n<ul>\n<li><strong>v-tooltips</strong>:  用户提醒，之前用的 Vue-Tour,但是跳跃感太强了，所以弃用了。</li>\n<li><strong>vue-analytics</strong>： Vue 下的 Google Analytics 工具，可以很方便的调用 GA 进行统计。</li>\n</ul>\n<h2>上线</h2>\n<p>在完成了开发后，将代码上传到 Github，准备部署。</p>\n<p>在前面提到，我考虑用 Netlify 进行部署，这里非常方便，在 Netlify 上直接创建项目，选择你的项目，然后填入命令即可。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/24/169adc89c9c670f2?w=684&amp;h=379&amp;f=png&amp;s=21910\" alt></p>\n<p>并配置一下域名，将自己的域名设置为主域名</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/24/169adc89f111c20c?w=910&amp;h=594&amp;f=png&amp;s=32967\" alt></p>\n<p>稍等一会，就会自动为你的域名签注 Let’s Encrypt 的证书。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/24/169adc89cb521df8?w=926&amp;h=623&amp;f=png&amp;s=40176\" alt></p>\n<h2>最后</h2>\n<p>关于这个项目的故事，我已经说完了所有我能想到的了，接下来，就是你的提问时间了，欢迎你针对项目对我提问，无论是产品、设计、编码，都可以~</p>\n<p><strong>希望大家能够给这个项目一个 Star: <a href=\"https://github.com/bestony/logoly\">https://github.com/bestony/logoly</a></strong></p>\n</div>","title":"正经的我，做了个不正经的项目 —— Pornhub 风格 Logo 生成器","last_reply_at":"2019-05-06T13:29:03.270Z","good":false,"top":false,"reply_count":18,"visit_count":3733,"create_at":"2019-03-24T11:54:22.582Z","author":{"loginname":"bestony","avatar_url":"https://avatars1.githubusercontent.com/u/13283837?v=4&s=120"}},{"id":"5c1c9ab676c4964062a1c3e1","author_id":"5372465f3c72496d41009adc","tab":"share","content":"<div class=\"markdown-text\"><p>《Node.js开发实战》原书排名并发编程类榜首。有读者坐火车十小时一口气读完，欲罢不能！好不好，试读就知道。</p>\n<p><strong>62页试读下载</strong>：<a href=\"https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg\">https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg</a></p>\n<p><strong>读者热评</strong>：</p>\n<ul>\n<li>看的欲罢不能啊，火车上来回十个小时，把整体内容浏览了一遍，然后现在精读到第二张，发现学到了好多东西，好书。\n——京东读者 小***土</li>\n</ul>\n<ul>\n<li>粗略的看了一遍,准备细读一下,很多地方给详细讲了es6的新特性,包括let、const、还有class和promise,还讲解了async和await,反正不太需要有es6基础也能看得懂,不过都要2019了,其实这些应该是前端必备技能了吧.书写的很好,循序渐进,感觉前端在没搞懂node之前,其实并不需要去学py啊php啊之类的,语言毕竟只是工具,利用工具做事情的理念是想通的.(最后这句说给我自己的)\n——豆瓣读者 陈小土</li>\n</ul>\n<ul>\n<li>很不错的一本关于node的实战书！\n——京东读者 f***8</li>\n</ul>\n<ul>\n<li>内容由浅入深，引人入胜。\n——京东读者 d***t</li>\n</ul>\n<p><strong>京东有售</strong>：<a href=\"https://item.jd.com/12460185.html\">https://item.jd.com/12460185.html</a></p>\n<p><img src=\"//static.cnodejs.org/Finp2H7di-Equ_yMWsjJY6hxYGkh\" alt=\"WechatIMG148 copy.jpg\"></p>\n</div>","title":"新书《Node.js开发实战》抢鲜试读","last_reply_at":"2019-05-06T11:34:55.214Z","good":false,"top":false,"reply_count":21,"visit_count":4244,"create_at":"2018-12-21T07:48:06.079Z","author":{"loginname":"meikidd","avatar_url":"https://avatars0.githubusercontent.com/u/376338?v=4&s=120"}},{"id":"5ccfecad776fb66e0d1727b1","author_id":"5875bd3d06fa6e2a4e4f730b","tab":"share","content":"<div class=\"markdown-text\"><p>很多人质疑node的高并发优势，并且以输出HelloWorld或输出计算结果来和传统的Java对比证明node并没有web的高并发优势，但事实真的是这样么？为什么说只输出HelloWorld性能还是比不过传统Java？异步是否还难道是不如多线程？</p>\n<p>尤其是对于node的高并发优势，很多人却说的很模糊，所以我觉得是时候以更通俗的语言和更接近Web编程的实际场景来解释异步模型的优势。</p>\n<h1>先讲个小故事</h1>\n<p>C是建筑工，Q是搬运工，Y是包工头。</p>\n<p>故事一:第一天C建墙建了一天发现没砖了，C告诉包工头Y没砖了，于是Y通知Q去搬点砖来，结果Q搬砖搬了一天，C就休息了一天。后来C建了一天屋顶又发现没瓦了,C告诉包工头Y没瓦了，于是Y通知Q再去搬点瓦来，结果Q搬瓦搬了一天，C就又休息了一天。后来C建了一天窗户又发现没玻璃了，C告诉包工头Y没玻璃了，于是Y通知Q再去搬点玻璃来，结果Q搬玻璃搬了一天，C就又休息了一天。后来C建了一天电路又发现没电线了，C告诉包工头Y没电线了，于是Y通知Q再去搬点电线来，结果Q搬电线搬了一天，C就又休息了一天。以此类推，最终导致工期没有按时完成，Y被处分了。</p>\n<p>故事二:吸取了故事一的教训，Y扩充了三倍团队人数。C1,C2,C3一起来建房子。结果C1,C2,C3都没有砖了，C1,C2,C3告诉Y，Y于是叫Q1，Q2，Q3去搬砖。同样Q1,Q2,Q3搬砖搬了一天，C1,C2,C3就休息了一天，和上面差不多都出现了搬瓦搬玻璃电线等等事件，但由于人多，建的速度快，还好没延期，但多招了很多人，Y亏本破产了。</p>\n<p>故事三:吸取了故事二的教训，Y决定弄个排期表还是不能让C闲着，当C建了一天墙发现没砖了后，Y让Q把砖搬回来的同时也让C先建设一天屋顶。正好C发现没瓦后，正好S的砖也搬回来了，C又可以去建墙，同时S又可以去拉瓦。当瓦拉回来后，C又可以建屋顶了。以此类推，最终工期按时完成，同时Y也赚到盆满钵满。</p>\n<p>故事一就是传统的单线程阻塞模式，故事二就是多线程的阻塞模式，故事三就是非阻塞的异步模式。而C就是CPU，C休息就是CPU空转。Q就是查询，Q搬东西就是查询需要等待的时间。C1,C2,C3的工资就是开线程的成本。Y就是你，你就是包工头。所以非阻塞的异步模式，主要解决了两个问题：</p>\n<ul>\n<li>解决了CPU空转大量浪费问题</li>\n<li>节约了开线程和线程切换上下文的成本问题</li>\n</ul>\n<h1>再谈什么情况能超越传统Java</h1>\n<p>根据上面的情况，无论是只输出HelloWorld也好，进行少量计算也好，这都是无需等待的操作，相当于上面那个故事里面的砖从来没有缺过的情况，但是一旦涉及到需要阻塞的等待，那么node的异步模式将起了极大的作用，而Web编程这种需要阻塞的等待又是极多的，比如说查询。</p>\n<p>我将用一段Java和node的等待操作进行压测来证明我的所说的情况。</p>\n<p>java代码:</p>\n<pre class=\"prettyprint language-java\"><code>package test;\n\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport java.io.*;\n\n@WebServlet(&quot;&#x2F;&quot;)\npublic class TestServlet extends HttpServlet {\n\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t&#x2F;&#x2F; 暂停三秒\n\t\tint sleepTime = 3000;\n\t\ttry {\n\t\t\tThread.sleep(sleepTime);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tPrintWriter out = response.getWriter();\n    &#x2F;&#x2F; 读取文件并显示,unuseData.txt是一个40M的文件\n\t\tFile f = new File(&quot;&#x2F;xxx&#x2F;unuseData.txt&quot;);\n        FileInputStream fip = new FileInputStream(f);\n        InputStreamReader reader = new InputStreamReader(fip, &quot;UTF-8&quot;);\n        StringBuffer sb = new StringBuffer();\n        while (reader.ready()) {\n            sb.append((char) reader.read());\n        }\n        reader.close();\n        fip.close();\n\t\tout.println(&quot;Java Stop The World &quot; + sleepTime&#x2F;1000 + &quot;s&quot;+&quot;,unuseData:&quot;+ sb.toString());\n\t}\n\n}\n</code></pre><p>node代码:</p>\n<pre class=\"prettyprint language-js\"><code>const http = require(&quot;http&quot;);\nconst fs = require(&quot;fs&quot;);\nconst port = 4000;\nfunction nodeSleep(time) {\n    return new Promise((resolve,reject)=&gt;{\n        setTimeout(() =&gt; {\n            resolve(true)\n        }, time);\n    });\n}\nfunction getUnseData() {\n    return new Promise((resolve,reject)=&gt;{\n        &#x2F;&#x2F; unuseData.txt是一个40M的文件\n        fs.readFile(&#x27;&#x2F;xxx&#x2F;unuseData.txt&#x27;, (err, data) =&gt; {\n            if (err) reject(err);\n            resolve(data)\n        });\n    });\n}\nhttp.createServer( async function (request, response) {\n    let sleepTime = 3000;\n    &#x2F;&#x2F; 暂停三秒\n    await nodeSleep(sleepTime);\n    &#x2F;&#x2F; 读取文件并显示\n    let unuseData = await getUnseData();\n    response.end(&#96;Node Stop The World ${sleepTime}s,unseDate:${unuseData}&#96;);  \n}).listen(port);\nconsole.log(&#96;listen http:&#x2F;&#x2F;localhost:${port}&#x2F;&#96;)\n</code></pre><p>压测结果：</p>\n<pre class=\"prettyprint language-sh\"><code># Java\nab -n 50 -c 5 http:&#x2F;&#x2F;localhost:8080&#x2F;test&#x2F;\nConnection Times (ms)\n              min  mean[+&#x2F;-sd] median   max\nConnect:        0    0   0.1      0       1\nProcessing:  4181 5645 883.3   5579    7495\nWaiting:     4075 5443 838.2   5394    7215\nTotal:       4181 5645 883.3   5579    7496\n\n# Node\nab -n 50 -c 5 http:&#x2F;&#x2F;localhost:4000&#x2F;\nConnection Times (ms)\n              min  mean[+&#x2F;-sd] median   max\nConnect:        0    0   0.3      0       2\nProcessing:  3210 3487 232.7   3487    3908\nWaiting:     3182 3349 167.8   3328    3835\nTotal:       3210 3487 232.7   3488    3908\n</code></pre><p><code>注意：并发为5，总请求数为50是因为我电脑是公司的低配mini扛不住，机器好的可以适当调高</code></p>\n<p>可以看到</p>\n<p>Java最快在5秒左右，最慢在7秒左右。</p>\n<p>Node最快在3秒左右，最慢也在3秒左右。</p>\n<p>传统的Java写法居然比Node慢了2到4秒！</p>\n<h1>为什么呢？</h1>\n<p>先解释一下代码，这两段代码都是先sleep一段时间，再读取文件展示给页面上。但Node在等待的时候让另一个已经等待完成的请求来读文件了，传统的Java却只能将等待彻底完成，才开始读文件，并且由于服务tomcat的worker恒定，worker池用完后，则需要等待worker释放，导致后一个worker的时间极大延长，而Node的队列却足够长到可以应付。</p>\n<p>所以为什么只是少量计算或直接输出HelloWorld，压测时性能还不如Java是因为这个时候CPU直接打满，这会导致node直接就阻塞了，无法发挥其优势，而这时Java的多worker反而使得CPU打满充分利用CPU来计算，所以速度反而快了。</p>\n<p>但是Web编程的大部分情况都不是简单的少量计算或直接输出HelloWorld，而是往往有更多的查询或文件读写操作和更复杂的情况，所以导致Node在通用Web开发中具有更大高并发优势！</p>\n</div>","title":"为什么说node具有高并发优势","last_reply_at":"2019-05-06T11:31:46.788Z","good":false,"top":false,"reply_count":4,"visit_count":323,"create_at":"2019-05-06T08:13:33.059Z","author":{"loginname":"zy445566","avatar_url":"https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"}},{"id":"5cc41656a86ae80ce64b4aef","author_id":"5cc414eea86ae80ce64b4ae1","tab":"share","content":"<div class=\"markdown-text\"><p>更新加入支持编辑手机端网页的功能\n提供在线免费服务，可以编辑宣传页或者广告页~\n<a href=\"https://www.cxzweb.club/#/light-show/mRead/0.6051613123650894ppt\">手机版演示文稿</a>\n<a href=\"https://www.cxzweb.club/#/light-show/mEdit\">编辑器地址</a>  (注意，编辑器还是PC端打开使用)</p>\n<p>pc端在线demo:\nPC端在线演示文稿地址：<a href=\"https://www.cxzweb.club/#/light-show/read\">https://www.cxzweb.club/#/light-show/read</a>\nPC版编辑器地址： <a href=\"https://www.cxzweb.club/#/light-show/edit\">https://www.cxzweb.club/#/light-show/edit</a></p>\n<p>GitHub地址：<a href=\"https://github.com/Cxz-web/light-show\">https://github.com/Cxz-web/light-show</a>\n有小伙伴一起体验交流？ 后续会继续优化交互和完善更多的功能（有觉得功能不错的小伙伴给个Star支持鼓励下,谢谢O(∩_∩)O）。</p>\n</div>","title":"一个在线演示文稿工具， O(∩_∩)O，体验一波？","last_reply_at":"2019-05-06T10:31:42.944Z","good":false,"top":false,"reply_count":14,"visit_count":1503,"create_at":"2019-04-27T08:44:06.151Z","author":{"loginname":"Cxz-web","avatar_url":"https://avatars1.githubusercontent.com/u/39953676?v=4&s=120"}},{"id":"5cc02d00a86ae80ce64b377d","author_id":"5cb4b9b5dad66d658e409645","tab":"ask","content":"<div class=\"markdown-text\"><p>想问一下Node怎么实现用户评论和回复消息的功能，急！有没有会做的大神指导一下，谢谢！</p>\n</div>","title":"评论回复功能的实现","last_reply_at":"2019-05-06T10:29:08.787Z","good":false,"top":false,"reply_count":3,"visit_count":603,"create_at":"2019-04-24T09:31:44.653Z","author":{"loginname":"forever520cy","avatar_url":"https://avatars1.githubusercontent.com/u/49617584?v=4&s=120"}},{"id":"5ccfca065a5bae6e07813538","author_id":"5ccfc99d776fb66e0d172609","tab":"share","content":"<div class=\"markdown-text\"><p>自己写的一个前端 UI 框架。轻量级，模块化，提供多主题支持（ 1.0.0 版本之后）。</p>\n<p>内置基线网格和常用组件，基于 MutationObserver，不需要手动维护组件生命周期。</p>\n<p>主页: <a href=\"https://oatw.github.io/luda\">https://oatw.github.io/luda</a></p>\n<p>Repo: <a href=\"https://github.com/oatw/luda\">https://github.com/oatw/luda</a></p>\n<p>欢迎提 issue 开 PR。</p>\n<p>谢谢！</p>\n</div>","title":"Luda 一个为设计师和开发者创建的 UI 框架","last_reply_at":"2019-05-06T10:26:02.828Z","good":false,"top":false,"reply_count":2,"visit_count":216,"create_at":"2019-05-06T05:45:42.982Z","author":{"loginname":"oatw","avatar_url":"https://avatars0.githubusercontent.com/u/47649745?v=4&s=120"}},{"id":"5ccfed4c5a5bae6e078136a2","author_id":"5902cd88782dbc4b183eceda","tab":"ask","content":"<div class=\"markdown-text\"><p>阿里云函数计算，是个诱人的服务，我们在试水。</p>\n<p>但是现在遇到webpack打包后，本地调试云函数时，找不到handler入口函数的问题</p>\n<p>有成功实践webpack打包后发布到云函数计算的吗？</p>\n</div>","title":"哪位大神实践过在阿里云函数计算中webpack打包发布","last_reply_at":"2019-05-06T10:00:11.784Z","good":false,"top":false,"reply_count":1,"visit_count":155,"create_at":"2019-05-06T08:16:12.955Z","author":{"loginname":"threem0126","avatar_url":"https://avatars0.githubusercontent.com/u/5511360?v=4&s=120"}},{"id":"5ccfbdb7776fb66e0d1725d7","author_id":"5ca1a9666c1de62dce4667d7","tab":"ask","content":"<div class=\"markdown-text\"><p>conn.query(sql, parmes, function (err, result) {}</p>\n<p>这里的err到底是啥结构的呢？按照网上的实例：\nconsole.log(’[ERROR ] - ', err.message);\n显示的是：</p>\n<blockquote>\n<p>WARN_DATA_TRUNCATED: Data truncated for column ‘age’ at row 1\n\t 应该是一个字符串吧，那么message是属性名称吗？</p>\n</blockquote>\n<p>然后我把 err变成字符串</p>\n<blockquote>\n<pre class=\"prettyprint\"><code>console.log(&#x27;[INSERT err2 ] - &#x27;,JSON.stringify(err) );\n</code></pre></blockquote>\n<pre class=\"prettyprint\"><code>显示的是：\n</code></pre><blockquote>\n<p>{\n“code”:“WARN_DATA_TRUNCATED”,\n“errno”:1265,\n“sqlMessage”:“Data truncated for column ‘age’ at row 1”,\n“sqlState”:“01000”,\n“index”:0,\n“sql”:“INSERT INTO node_user(id,name,age) VALUES(0,‘name11’,‘3w3’)”}</p>\n</blockquote>\n<p>但是这里面怎么没有 <strong>message</strong> ？上面那个 err.message 是哪来的？</p>\n<p>然后我又直接输出</p>\n<blockquote>\n<p>console.log(’[INSERT err ] - ',err);\n这次显示的内容就多了\n{ Error: WARN_DATA_TRUNCATED: Data truncated for column ‘age’ at row 1\nat Query.Sequence._packetToError (D:\\nodejs\\node_modules\\mysql\\lib\\protocol\\sequences\\Sequence.js:47:14)\nat Query.ErrorPacket (D:\\nodejs\\node_modules\\mysql\\lib\\protocol\\sequences\\Query.js:77:18)\nat Protocol._parsePacket (D:\\nodejs\\node_modules\\mysql\\lib\\protocol\\Protocol.js:278:23)\nat Parser.write (D:\\nodejs\\node_modules\\mysql\\lib\\protocol\\Parser.js:76:12)\nat Protocol.write (D:\\nodejs\\node_modules\\mysql\\lib\\protocol\\Protocol.js:38:16)\nat Socket.&lt;anonymous&gt; (D:\\nodejs\\node_modules\\mysql\\lib\\Connection.js:91:28)\nat Socket.&lt;anonymous&gt; (D:\\nodejs\\node_modules\\mysql\\lib\\Connection.js:502:10)\nat emitOne (events.js:115:13)\nat Socket.emit (events.js:210:7)\nat addChunk (_stream_readable.js:264:12)\n--------------------\nat Protocol._enqueue (D:\\nodejs\\node_modules\\mysql\\lib\\protocol\\Protocol.js:144:48)\nat Connection.query (D:\\nodejs\\node_modules\\mysql\\lib\\Connection.js:200:25)\nat Object.exports.query (D:\\nodejs\\test\\natureFW\\dbHelp.js:46:10)\nat Object.&lt;anonymous&gt; (D:\\nodejs\\test\\NatureTest\\testAdd.js:55:12)\nat Module._compile (module.js:624:30)\nat Object.Module._extensions…js (module.js:635:10)\nat Module.load (module.js:545:32)\nat tryModuleLoad (module.js:508:12)\nat Function.Module._load (module.js:500:3)\nat Function.Module.runMain (module.js:665:10)\ncode: ‘WARN_DATA_TRUNCATED’,\nerrno: 1265,\nsqlMessage: ‘Data truncated for column ‘age’ at row 1’,\nsqlState: ‘01000’,\nindex: 0,\nsql: ‘INSERT INTO node_user(id,name,age) VALUES(0,‘name11’,‘3w3’)’ }</p>\n</blockquote>\n<p>这回一下子多了好多。都是啥？</p>\n<p>这大概是一个函数把，有属性和方法，JSON.stringify()好像只是把属性的部分给变成字符串了，其他的似乎没关。</p>\n</div>","title":"mysql的回调函数里面的参数 err 是啥结构的？","last_reply_at":"2019-05-06T08:45:58.524Z","good":false,"top":false,"reply_count":1,"visit_count":137,"create_at":"2019-05-06T04:53:11.455Z","author":{"loginname":"jyk0011","avatar_url":"https://avatars0.githubusercontent.com/u/6062713?v=4&s=120"}},{"id":"5433d5e4e737cbe96dcef312","author_id":"504c28a2e2b845157708cb61","tab":"share","content":"<div class=\"markdown-text\"><p>GitHub repo 地址：<a href=\"https://github.com/alsotang/node-lessons\">https://github.com/alsotang/node-lessons</a></p>\n<p>如果大家认为漏了哪些初学者应会的内容，可以在此留言，或者开个 issue 给我（!!推荐）。</p>\n<hr>\n<h1>《Node.js 包教不包会》 – by alsotang</h1>\n<h1>为何写作此课程</h1>\n<p>在 CNode(<a href=\"https://cnodejs.org/\">https://cnodejs.org/</a>) 混了那么久，解答了不少 Node.js 初学者们的问题。回头想想，那些问题所需要的思路都不难，但大部分人由于练手机会少，所以在遇到问题的时候很无措。国内唯一一本排的上号的 Node.js 书是 @朴灵(<a href=\"https://github.com/JacksonTian\">https://github.com/JacksonTian</a>) 的 《深入浅出Node.js》(<a href=\"http://book.douban.com/subject/25768396/\">http://book.douban.com/subject/25768396/</a> )，但这本书离实战还是比较远的。</p>\n<p>这个课程是希望提供更多的 Node.js 实战机会，通过每一节精心安排的课程目标，让 Node.js 的初学者们可以循序渐进地，有目的有挑战地开展 Node.js 的学习。</p>\n<p>更多 Node.js 入门资料请前往：<a href=\"https://cnodejs.org/getstart\">https://cnodejs.org/getstart</a></p>\n<h1>课程列表</h1>\n<ul>\n<li>Lesson 0: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson0\">《搭建 Node.js 开发环境》</a></li>\n<li>Lesson 1: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson1\">《一个最简单的 express 应用》</a></li>\n<li>Lesson 2: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson2\">《学习使用外部模块》</a></li>\n<li>Lesson 3: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson3\">《使用 superagent 与 cheerio 完成简单爬虫》</a></li>\n<li>Lesson 4: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson4\">《使用 eventproxy 控制并发》</a></li>\n<li>Lesson 5: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson5\">《使用 async 控制并发》</a></li>\n<li>Lesson 6: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson6\">《测试用例：mocha，should，istanbul》</a></li>\n<li>Lesson 7: 《测试用例：supertest》</li>\n<li>Lesson 8: 《Mongodb 与 Mongoose 的使用》</li>\n<li>Lesson 9: 《一个简单的 blog》</li>\n</ul>\n<h1>License</h1>\n<p>MIT</p>\n</div>","title":"一个面向 Node.js 初学者的系列课程：node-lessons","last_reply_at":"2019-05-06T08:41:46.480Z","good":true,"top":false,"reply_count":94,"visit_count":46001,"create_at":"2014-10-07T12:00:36.270Z","author":{"loginname":"alsotang","avatar_url":"https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"}},{"id":"5cc6ef49a86ae80ce64b575e","author_id":"50386c12f767cc9a51ed20cb","tab":"ask","content":"<div class=\"markdown-text\"><p>RT. 阔别NodeJs已久，目前大家都在用什么NodeJs的框架，上下游的中间件怎么选择，请给位大侠指点。</p>\n</div>","title":"阔别NodeJs已久，请教各位大侠，框架选择的问题。","last_reply_at":"2019-05-06T07:52:08.931Z","good":false,"top":false,"reply_count":12,"visit_count":1452,"create_at":"2019-04-29T12:34:17.601Z","author":{"loginname":"ringtail","avatar_url":"https://avatars2.githubusercontent.com/u/3116693?v=4&s=120"}},{"id":"5ccfdca9776fb66e0d172715","author_id":"55b9895b35ce2ac164f5191c","tab":"share","content":"<div class=\"markdown-text\"><p>Hello 大家好，</p>\n<p>我们推出了一款基于机器学习的产品推荐引擎 - <a href=\"https://zhaodao.ai\">找到AI</a></p>\n<p>如果你 1 ）不满足于现有的产品，需要寻找更好的可替代品； 2 ）想要拓宽自己的工具箱，发现更多好产品； 3 ）寻找与自己品味类似的人喜欢的产品并关注他们，欢迎使用 <a href=\"https://zhaodao.ai\">找到AI</a>  Ta 可以帮助你找到更多更好的互联网产品，和类似他们的产品，建议登录后查看 AI 推荐或关注其他人的推荐，AI 会基于你的行为偏好以及与你类似的人群进行智能推荐。</p>\n<p><img src=\"https://coding-net-production-pp-ci.codehub.cn/5ded8ef9-b778-484e-936d-ab18d194001a.gif\" alt></p>\n<p>我们正在不断学习改进以帮助您找到下一个好产品/作品，未来我们也会逐步扩宽品类帮助你发现更多好东西，比如互联网相关书籍等。欢迎反馈意见或提交产品/作品给我们～ <a href=\"mailto:hi@zhaodao.ai\">hi@zhaodao.ai</a></p>\n</div>","title":"找到 AI - 基于机器学习的产品推荐引擎","last_reply_at":"2019-05-06T07:05:13.078Z","good":false,"top":false,"reply_count":0,"visit_count":133,"create_at":"2019-05-06T07:05:13.078Z","author":{"loginname":"tvvocold","avatar_url":"https://avatars0.githubusercontent.com/u/4530539?v=4&s=120"}},{"id":"5ccbfdac5a5bae6e07812932","author_id":"5a38aa20d92f2f5b185acff5","tab":"ask","content":"<div class=\"markdown-text\"><p>Android弱鸡一枚,准备转node,求一份学习路线图.希望能够根据学习路线图来完整的学习,掌握node.</p>\n<blockquote>\n<p>没有js的基础</p>\n</blockquote>\n<p>再次谢谢各位了.\n2019-5-3  16:36</p>\n</div>","title":"Android弱鸡一枚,准备转node,求一份学习路线图","last_reply_at":"2019-05-06T06:51:37.108Z","good":false,"top":false,"reply_count":10,"visit_count":761,"create_at":"2019-05-03T08:37:00.378Z","author":{"loginname":"UOYO","avatar_url":"https://avatars1.githubusercontent.com/u/20040601?v=4&s=120"}},{"id":"5cce6dfb776fb66e0d171e89","author_id":"5b0eaaf38a4f51e140d9437d","tab":"share","content":"<div class=\"markdown-text\"><h1>Node.js技术栈</h1>\n<blockquote>\n<p>为Node.js学习贡献一份自己微小的力量，本文档是作者从事<code>Node.js Developer</code>以来的学习历程，旨在为大家提供一个较详细的学习教程，侧重点更倾向于Node.js服务端所涉及的技术栈，如果本文能为您得到帮助，请给予支持！</p>\n</blockquote>\n<p><strong>如何支持：</strong></p>\n<ul>\n<li>搜索公众号 <strong><code>Node.js技术栈</code></strong> 进行关注</li>\n<li>点击右上角Star :star: 给予关注</li>\n<li>分享给您身边更多的小伙伴</li>\n</ul>\n<blockquote>\n<p><strong>Github</strong>：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap\">https://github.com/Q-Angelo/Nodejs-Roadmap</a></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th><a href=\"#JavaScript\"><code>JavaScript</code></a></th>\n<th><a href=\"#ECMAScript6\"><code>ECMAScript6</code></a></th>\n<th><a href=\"#Nodejs\"><code>Node.js</code></a></th>\n<th><a href=\"#DataBase\"><code>DataBase</code></a></th>\n<th><a href=\"#Microservice\"><code>Microservice</code></a></th>\n<th><a href=\"#HTTP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E6%88%98\"><code>HTTP</code></a></th>\n<th><a href=\"#DevOps\"><code>DevOps</code></a></th>\n<th><a href=\"#%E5%B7%A5%E5%85%B7\"><code>工具</code></a></th>\n<th><a href=\"#%E8%B5%84%E6%96%99\"><code>资料</code></a></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<h2>JavaScript</h2>\n<ul>\n<li><strong>基础</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md\">[more]</a>\n<ul>\n<li><code>[基础]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\">常见问题</a></li>\n<li><code>[基础]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md#undefined%E4%B8%8Eundeclared%E7%9A%84%E5%8C%BA%E5%88%AB\">undefined与undeclared的区别？</a></li>\n<li><code>[基础]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B\">typeof、instanceof 类型检测</a></li>\n<li><code>[作用域]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md#%E6%AC%BA%E9%AA%97%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F\">eval()、with 欺骗词法作用域</a></li>\n<li><code>[Error]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md#%E9%94%99%E8%AF%AF\">错误类型ReferenceError、TypeError的区别？</a></li>\n<li><code>[面试]</code> <code>编写一个函数实现多维数组去重？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\">数组去重的三种实现方式</a></li>\n<li><code>[面试]</code> <code>实现对多维数组降维？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md#%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4\">数组降维–扁平化多维数组</a></li>\n</ul>\n</li>\n<li><strong>This</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/this.md\">[more]</a>\n<ul>\n<li><code>[This指向]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/this.md#%E6%8C%87%E5%90%91%E8%87%AA%E8%BA%AB\">指向自身</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/this.md#%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\">指向函数的作用域</a></li>\n<li><code>[绑定规则]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/this.md#%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A\">默认绑定</a>、 <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/this.md#%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A\">隐式绑定</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/this.md#%E6%98%BE%E7%A4%BA%E7%BB%91%E5%AE%9A\">显示绑定</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/this.md#new%E7%BB%91%E5%AE%9A\">new绑定</a></li>\n</ul>\n</li>\n<li><strong>函数</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md\">[more]</a>\n<ul>\n<li><code>[Function]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F\">函数声明与函数表达式</a></li>\n<li><code>[Function]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0\">内置函数</a></li>\n<li><code>[Function]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#arguments%E5%AF%B9%E8%B1%A1\">arguments对象</a></li>\n<li><code>[Function]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#call%E5%92%8Capply%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8C%BA%E5%88%AB\">call和apply的使用与区别?</a></li>\n<li><code>[Function]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\">引用传递</a></li>\n<li><code>[面试]</code> <code>递归调用实现一个阶乘函数？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#arguments%E5%AF%B9%E8%B1%A1\">arguments对象</a></li>\n<li><code>[面试]</code> <code>如何理解JavaScript中的引用传递与值传递？JS中是否拥有引用传递？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\">引用传递</a></li>\n<li><code>[面试]</code> <code>经典面试题：什么是匿名函数和闭包？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85\">深入理解匿名函数与闭包</a></li>\n</ul>\n</li>\n<li><strong>对象</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md\">[more]</a>\n<ul>\n<li><code>[Object]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95\">创建对象的四种方法</a>：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9B%E5%BB%BA\">对象字面量</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E4%BD%BF%E7%94%A8new%E5%85%B3%E9%94%AE%E5%AD%97%E6%9E%84%E9%80%A0%E5%BD%A2%E5%BC%8F%E5%88%9B%E5%BB%BA\">new关键字构造形式</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E5%AF%B9%E8%B1%A1%E7%9A%84create%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA\">create方法</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E5%8E%9F%E5%9E%8Bprototype%E5%88%9B%E5%BB%BA\">原型prototype创建</a></li>\n<li><code>[面试]</code> <code>什么是引用传递？{} == {} 是否等于true</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90\">对象引用类型示例分析</a></li>\n<li><code>[面试]</code> <code>如何编写一个对象的深度拷贝函数？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E5%AF%B9%E8%B1%A1copy%E5%AE%9E%E7%8E%B0\">对象copy实现</a></li>\n<li><code>[面试]</code> <code>new操作符具体做了哪些操作，重要知识点！</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E4%BD%BF%E7%94%A8new%E5%85%B3%E9%94%AE%E5%AD%97%E6%9E%84%E9%80%A0%E5%BD%A2%E5%BC%8F%E5%88%9B%E5%BB%BA\">使用new关键字构造形式创建</a></li>\n</ul>\n</li>\n<li><strong>原型</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md\">[more]</a>\n<ul>\n<li><code>[ProtoType]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E5%8E%9F%E5%9E%8B%E6%A6%82%E5%BF%B5\">原型概念</a></li>\n<li><code>[ProtoType]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\">原型模式的执行流程</a></li>\n<li><code>[ProtoType]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95\">构造函数实例属性方法</a></li>\n<li><code>[ProtoType]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E6%9E%84%E5%BB%BA%E5%8E%9F%E5%9E%8B%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95\">构建原型属性方法</a></li>\n<li><code>[ProtoType]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E5%8E%9F%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\">原型字面量创建对象</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\">字面量创建对象</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\">构造函数创建对象</a></li>\n<li><code>[ProtoType]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8\">原型的实际应用</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#jquery%E4%B8%AD%E5%8E%9F%E5%9E%8B%E5%BA%94%E7%94%A8\">jquery中原型应用</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#zepto%E4%B8%AD%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8\">zepto中原型的应用</a></li>\n<li><code>[面试]</code> 如何实现原型的扩展？，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%89%A9%E5%B1%95\">原型的扩展</a></li>\n</ul>\n</li>\n<li><strong>正则</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/regexp.md\">[more]</a>\n<ul>\n<li><code>[RegExp]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/regexp.md#%E6%A8%A1%E5%BC%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%82%E6%95%B0\">模式修饰符参数</a></li>\n<li><code>[RegExp]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/regexp.md#%E4%B8%A4%E4%B8%AA%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95\">两个测试方法</a></li>\n<li><code>[RegExp]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/regexp.md#4%E4%B8%AA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%96%B9%E6%B3%95\">4个正则表达式方法</a></li>\n<li><code>[RegExp]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/regexp.md#%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F\">匹配模式</a></li>\n<li><code>[RegExp]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/regexp.md#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\">常用正则表达式</a></li>\n</ul>\n</li>\n</ul>\n<h2>ECMAScript6</h2>\n<ul>\n<li><strong>变量声明</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md\">[more]</a>\n<ul>\n<li><code>[Variable]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E6%96%B0%E5%A2%9E%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F\">新增let&amp;const变量声明</a></li>\n</ul>\n</li>\n<li><strong>解构赋值</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\">[more]</a>\n<ul>\n<li><code>[Deconstruction]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\">数组解构赋值</a></li>\n<li><code>[Deconstruction]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\">对象解构赋值</a></li>\n</ul>\n</li>\n<li><strong>扩展系列</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\">[more]</a>\n<ul>\n<li><code>[Extension]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%89%A9%E5%B1%95\">正则表达式扩展</a></li>\n<li><code>[Extension]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95\">字符串扩展</a></li>\n<li><code>[Extension]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E6%95%B0%E5%80%BC%E6%89%A9%E5%B1%95\">数值扩展</a></li>\n<li><code>[Extension]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95\">数组扩展</a></li>\n<li><code>[Extension]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95\">函数扩展</a></li>\n<li><code>[Extension]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95\">对象扩展</a></li>\n</ul>\n</li>\n<li><strong>集合系列</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\">[more]</a>\n<ul>\n<li><code>[Set]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#set\">集合Set</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#weakset\">WeakSet</a></li>\n<li><code>[Map]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#map\">集合Map</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#weakmap\">WeakMap</a></li>\n<li><code>[Map-Array]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#map%E4%B8%8Earray%E5%AF%B9%E6%AF%94\">Map与Array横向对比增、查、改、删</a></li>\n<li><code>[Set-Array]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#set%E4%B8%8Earray\">Set与Array增、查、改、删对比</a></li>\n<li><code>[Map-Set-Array]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#%E9%9B%86%E5%90%88map%E9%9B%86%E5%90%88set%E5%AF%B9%E8%B1%A1%E4%B8%89%E8%80%85%E5%AF%B9%E6%AF%94\">Map、Set、Object三者增、查、改、删对比</a></li>\n</ul>\n</li>\n<li><strong>Promise</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md\">[more]</a>\n<ul>\n<li><code>[Promise]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#promise%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86\">Promise的基本使用和原理</a></li>\n<li><code>[Promise]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#callback%E6%96%B9%E5%BC%8F%E4%B9%A6%E5%86%99\">Callback方式书写</a></li>\n<li><code>[Promise]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#promise%E6%96%B9%E5%BC%8F%E4%B9%A6%E5%86%99\">Promise方式书写</a></li>\n<li><code>[Promise]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#finally\">Promise.finally()</a></li>\n<li><code>[Promise]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#promise%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C\">Promise并行执行 Promise.all()</a></li>\n<li><code>[Promise]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#promise%E7%8E%87%E5%85%88%E6%89%A7%E8%A1%8C\">Promise率先执行 Promise.race()</a></li>\n<li><code>[Promise]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7\">错误捕获</a></li>\n<li><code>[面试]</code> <code>Promise 中 .then 的第二参数与 .catch 有什么区别?</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7\">错误捕获</a></li>\n<li><code>[面试]</code> <code>怎么让一个函数无论promise对象成功和失败都能被调用？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#finally\">finally</a></li>\n</ul>\n</li>\n<li><strong>Decorators</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/decorators.md\">[more]</a></li>\n<li><strong>Symbol</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/symbol.md\">[more]</a></li>\n<li><strong>Generator</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/generator.md\">[more]</a></li>\n</ul>\n<h2>Nodejs</h2>\n<ul>\n<li><strong>模块</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md\">[more]</a>\n<ul>\n<li><code>[Module]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%86%E7%B1%BB\">模块的分类</a>：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97\">系统模块</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97\">第三方模块</a></li>\n<li><code>[Module]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\">模块加载机制</a></li>\n<li><code>[Module]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E6%A8%A1%E5%9D%97%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8\">模块循环引用</a></li>\n<li><code>[面试]</code> <code>require的加载机制？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\">模块加载机制</a></li>\n<li><code>[面试]</code> <code>module.exports与exports的区别</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#module.exports%E4%B8%8Eexports%E7%9A%84%E5%8C%BA%E5%88%AB\">module.exports与exports的区别</a></li>\n<li><code>[面试]</code> <code>假设有a.js、b.js两个模块相互引用，会有什么问题？是否为陷入死循环？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E9%97%AE%E9%A2%981\">#</a></li>\n<li><code>[面试]</code> <code>a模块中的undeclaredVariable变量在b.js中是否会被打印？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E9%97%AE%E9%A2%982\">#</a></li>\n</ul>\n</li>\n<li><strong>事件轮询（Event Loop）</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/event-loop.md\">[more]</a>\n<ul>\n<li><code>[EventLoop]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/event-loop.md#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B\">线程模型、EventLoop介绍</a></li>\n<li><code>[I/O]</code><a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/event-loop.md#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BD%AE%E8%AF%A2%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B\">操作系统I/O模型及轮询技术演变</a></li>\n<li><code>[I/O]</code><a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/event-loop.md#%E7%99%BD%E8%AF%9D%E9%A3%8E%E6%A0%BC\">白话风格（小明与妹子的邂逅）讲解I/O演进</a></li>\n<li><code>[Node.js-EventLoop]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/event-loop.md#Node.js%E4%B8%AD%E7%9A%84EventLoop\">Node.js中的Event Loop</a></li>\n<li><code>[Browser-EventLoop]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/event-loop.md#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84EventLoop\">浏览器中的Event Loop</a></li>\n<li><code>[Interview]</code> <code>I/O多路复用轮询技术select和epoll的区别？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/event-loop.md#select%E5%92%8Cepoll%E7%9A%84%E5%8C%BA%E5%88%AB\">#</a></li>\n</ul>\n</li>\n<li><strong>中间件</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/middleware.md\">[more]</a>\n<ul>\n<li><code>[Mddleware]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/middleware.md\">常用Web框架&amp;中间件汇总</a></li>\n</ul>\n</li>\n<li><strong>缓存</strong>\n<ul>\n<li><code>[Cache]</code> <a href=\"https://github.com/webpack/memory-fs\">memory-fs 将文件写入内存</a></li>\n<li><code>[Cache]</code> <a href=\"https://github.com/ptarjan/node-cache#readme\">Memory Cache</a></li>\n<li><code>[Cache]</code> <a href=\"https://github.com/mpneuried/nodecache\">Node Cache</a></li>\n</ul>\n</li>\n<li><strong>定时任务</strong>\n<ul>\n<li><code>[Schedule]</code> <a href=\"https://github.com/node-schedule/node-schedule\">node-schedule </a></li>\n<li><code>[Schedule]</code> <a href=\"https://github.com/agenda/agenda\">Agenda 将Node中的定时任务存储在数据库中（官方推荐MongoDB）</a></li>\n</ul>\n</li>\n<li><strong>模板引擎</strong>\n<ul>\n<li><code>[Template]</code> <a href=\"https://ejs.co/\">Ejs</a></li>\n<li><code>[Template]</code> <a href=\"https://handlebarsjs.com/\">Handlebarsjs</a></li>\n<li><code>[Template]</code> <a href=\"http://jade-lang.com/\">Jade</a></li>\n</ul>\n</li>\n<li><strong>日志记录收集</strong>\n<ul>\n<li><code>[Logger]</code> <a href=\"https://sentry.io/welcome/\">Sentry–错误日志收集框架</a></li>\n<li><code>[Logger]</code> <a href=\"https://github.com/log4js-node/log4js-node\">log4js 日志记录工具</a></li>\n<li><code>[Logger]</code> <a href=\"https://www.elastic.co/cn/products\">ELK–开源的日志分析系统</a></li>\n<li><code>[Logger]</code> <a href=\"https://github.com/winstonjs/winston\">winston日志模块</a></li>\n</ul>\n</li>\n<li><strong>测试</strong>\n<ul>\n<li><code>Unit Testing</code> <a href=\"https://mochajs.org/\">mocha NodeJS里最常用的测试框架</a></li>\n<li><code>Unit Testing</code> <a href=\"http://www.chaijs.com/api/\">chai 一个断言库</a></li>\n<li><code>Unit Testing</code> <a href=\"https://jestjs.io/\">Jest — Facebook推出的一款测试框架，集成了 Mocha，chai，jsdom，sinon等功能。</a></li>\n<li><code>BDD Testing</code> <a href=\"https://jasmine.github.io/\">Jasmine — 一款基于行为驱动的JavaScript测试框架</a></li>\n<li><code>Testing Tool</code> <a href=\"https://github.com/gotwarlost/istanbul\">istanbul Istanbul - a JS code coverage tool written in JS 测试覆盖率</a></li>\n<li><code>E2E Testing</code> <a href=\"https://github.com/GoogleChrome/puppeteer\">Puppeteer</a></li>\n</ul>\n</li>\n<li><strong>框架</strong>\n<ul>\n<li><code>[Framework]</code> <a href=\"http://www.expressjs.com.cn/\">Express 中文版</a>、<a href=\"http://www.expressjs.com.cn/\">Express of English Version</a></li>\n<li><code>[Framework]</code> <a href=\"https://koajs.com/\">Koa 中文版</a>、<a href=\"https://koajs.com/\">Koa of English Version</a></li>\n<li><code>[Framework]</code> <a href=\"https://eggjs.org/zh-cn/intro/quickstart.html\">Egg 中文版</a>、<a href=\"https://eggjs.org/en/intro/quickstart.html\">Egg of English Version</a></li>\n<li><code>[Framework]</code> <a href=\"https://docs.nestjs.cn/\">Nest.js 中文版</a>、<a href=\"https://docs.nestjs.com/\">Nest.js</a></li>\n</ul>\n</li>\n<li><strong>ORM</strong>\n<ul>\n<li><code>[typeorm]</code> <a href=\"https://typeorm.io/\">typeorm</a> 【右上角切换中文】</li>\n<li><code>[sequelize]</code> <a href=\"http://docs.sequelizejs.com/\">sequelize</a></li>\n<li><code>[prisma]</code> <a href=\"https://www.prisma.io/docs\">prisma</a></li>\n</ul>\n</li>\n</ul>\n<h2>DataBase</h2>\n<ul>\n<li><strong><code>Relational</code></strong>\n<ul>\n<li><a href=\"https://www.mysql.com/\">MySql</a></li>\n<li><a href=\"https://www.microsoft.com/en-us/sql-server/sql-server-2017\">SQL Server</a></li>\n<li><a href=\"https://www.postgresql.org/\">PostgreSQL</a></li>\n<li><a href=\"https://www.oracle.com/index.html\">Oracle</a></li>\n</ul>\n</li>\n<li><strong><code>NoSQL</code></strong>\n<ul>\n<li><a href=\"https://www.mongodb.com/\">MongoDB</a></li>\n<li><a href=\"https://redis.io/\">Redis</a></li>\n<li><a href=\"https://github.com/facebook/rocksdb/\">RocksDB</a>、<a href=\"https://rocksdb.org.cn/\">RocksDB中文网</a></li>\n<li><a href=\"http://couchdb.apache.org/\">CouchDB</a></li>\n</ul>\n</li>\n<li><strong>Search Engines</strong>\n<ul>\n<li><a href=\"https://www.elastic.co/\">ElasticSearch</a></li>\n<li><a href=\"http://lucene.apache.org/solr/\">Solr</a></li>\n<li><a href=\"http://sphinxsearch.com/\">Sphinxsearch</a></li>\n</ul>\n</li>\n</ul>\n<h2>Microservice</h2>\n<ul>\n<li><strong>服务注册发现之Consul</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/consul.md\">[more]</a>\n<ul>\n<li><code>[Consul]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/consul.md#%E4%BD%BF%E7%94%A8consul%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98\">使用Consul解决了哪些问题</a></li>\n<li><code>[Consul]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/consul.md#consul%E6%9E%B6%E6%9E%84\">微服务Consul系列之服务部署、搭建、使用</a></li>\n<li><code>[Consul]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/consul.md#%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA\">微服务Consul系列之集群搭建</a></li>\n<li><code>[Consul]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/consul.md#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0\">微服务Consul系列之服务注册与服务发现</a></li>\n<li><code>[Question]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/consul.md#%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93\">微服务Consul系列之问题汇总篇</a></li>\n</ul>\n</li>\n<li><strong>消息中间件之RabbitMQ</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/rabbitmq-base.md\">[more]</a>\n<ul>\n<li><code>[RabbitMQ]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/rabbitmq-base.md#%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AE%80%E4%BB%8B\">主流消息中间件简介</a></li>\n<li><code>[RabbitMQ]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/rabbitmq-base.md#%E5%AE%89%E8%A3%85\">RabbitMQ安装、部署、启动</a>\n<ul>\n<li>Mac版安装</li>\n<li>Linux系统（Ubuntu、CentOS）安装</li>\n<li>运行与启动</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>轻量级数据通信</strong>\n<ul>\n<li><code>[RPC]</code> <a href=\"http://doc.oschina.net/grpc?t=57966\">gRPC 官方文档中文版</a></li>\n<li><code>[RPC]</code> <a href=\"http://thrift.apache.org/\">Apache Thrift</a></li>\n<li><code>[RPC]</code> <a href=\"http://dubbo.apache.org/zh-cn/index.html\">Apache Dubbo一款高性能Java RPC框架</a></li>\n<li><code>[HTTP]</code> <a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\">RESTful API 设计指南</a> <a href=\"https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#versioning\">Best Practices for Designing a Pragmatic RESTful API\n</a></li>\n</ul>\n</li>\n</ul>\n<h2>HTTP协议</h2>\n<ul>\n<li><strong>http三次握手</strong> <a href=\"https://github.com/Q-Angelo/http-protocol#http%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\">[more]</a>\n<ul>\n<li><code>[HTTP三次握手]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BA%8F%E5%9B%BE\">三次握手时序图</a></li>\n<li><code>[HTTP三次握手]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%95%B0%E6%8D%AE%E5%8C%85%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9%E5%88%86%E6%9E%90\">三次握手数据包详细内容分析</a></li>\n<li><code>[HTTP三次握手]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E6%80%BB%E7%BB%93\">分析总结</a></li>\n<li><code>[面试]</code> <code>说下TCP三次握手的过程?</code>，参考：<a href=\"https://github.com/Q-Angelo/http-protocol#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BA%8F%E5%9B%BE\">三次握手时序图</a></li>\n</ul>\n</li>\n<li><strong>跨域CORS</strong> <a href=\"https://github.com/Q-Angelo/http-protocol#%E8%B7%A8%E5%9F%9Fcors\">[more]</a>\n<ul>\n<li><code>[CORS]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E8%B7%A8%E5%9F%9Fcors\">跨域形成原理简介</a></li>\n<li><code>[CORS]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E7%A4%BA%E4%BE%8B\">实例来验证跨域的产生过程</a></li>\n<li><code>[CORS]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E5%9F%BA%E4%BA%8Ehttp%E5%8D%8F%E8%AE%AE%E5%B1%82%E9%9D%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\">基于http协议层面的几种解决办法</a></li>\n<li><code>[CORS]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#cors%E9%A2%84%E8%AF%B7%E6%B1%82\">CORS预请求</a></li>\n<li><code>[面试]</code> <code>你之前遇见过跨域吗？说一下跨域的形成与实现。</code>，参考：<a href=\"https://github.com/Q-Angelo/http-protocol#%E8%B7%A8%E5%9F%9Fcors\">CORS</a></li>\n</ul>\n</li>\n<li><strong>缓存头Cache-Control的含义和使用</strong>\n<ul>\n<li><code>[Cache-Control]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E5%8F%AF%E7%BC%93%E5%AD%98%E6%80%A7\">可缓存性（public、private、no-cache）</a></li>\n<li><code>[Cache-Control]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E5%88%B0%E6%9C%9F\">到期 （max-age、s-maxage、max-stale）</a></li>\n<li><code>[Cache-Control]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E9%87%8D%E6%96%B0%E9%AA%8C%E8%AF%81\">重新验证 （must-revalidate、proxy-revalidate）</a></li>\n<li><code>[Cache-Control]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E5%85%B6%E5%AE%83\">其它 （no-store、no-transform）</a></li>\n<li><code>[Cache-Control]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E7%BC%93%E5%AD%98cache-control%E7%A4%BA%E4%BE%8B\">缓存cache-control示例</a></li>\n</ul>\n<ol>\n<li><code>[思考]</code> <code>在页面中引入静态资源文件，为什么静态资源文件改变后，再次发起请求还是之前的内容，没有变化呢？</code>，参考：<a href=\"https://github.com/Q-Angelo/http-protocol#%E7%BC%93%E5%AD%98cache-control%E7%A4%BA%E4%BE%8B\">#</a></li>\n<li><code>[思考]</code> <code>在使用webpack等一些打包工具时，为什么要加上一串hash码？</code>，参考：<a href=\"https://github.com/Q-Angelo/http-protocol#%E7%BC%93%E5%AD%98cache-control%E7%A4%BA%E4%BE%8B\">#</a></li>\n</ol>\n</li>\n<li><strong>HTTP长链接</strong>\n<ul>\n<li><code>[KeepAlive]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#http%E9%95%BF%E9%93%BE%E6%8E%A5\">http长链接简介</a></li>\n<li><code>[KeepAlive]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#http%E9%95%BF%E9%93%BE%E6%8E%A5\">http/1.1中长链接的实现示例</a></li>\n<li><code>[KeepAlive]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#http%E9%95%BF%E9%93%BE%E6%8E%A5\">长链接在http2中的应用与http/1.1协议中的对比</a></li>\n<li><code>[面试]</code> <code>Chrome浏览器允许的一次性最大TCP并发链接是几个？</code>，参考：<a href=\"https://github.com/Q-Angelo/http-protocol#http%E9%95%BF%E9%93%BE%E6%8E%A5\">HTTP长链接分析</a></li>\n</ul>\n</li>\n<li><strong>Nginx服务配置</strong>\n<ul>\n<li><code>[Nginx]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#nginx%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8\">Nginx安装启动</a></li>\n<li><code>[Nginx]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%90%8D\">修改hosts文件配置本地域名</a></li>\n<li><code>[Nginx]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#nginx%E9%85%8D%E7%BD%AE%E7%BC%93%E5%AD%98\">Nginx配置缓存</a></li>\n<li><code>[Nginx]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#nginx%E9%83%A8%E7%BD%B2https%E6%9C%8D%E5%8A%A1\">nginx部署https服务</a></li>\n<li><code>[Nginx]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E5%AE%9E%E7%8E%B0http2%E5%8D%8F%E8%AE%AE\">实现http2协议</a></li>\n</ul>\n</li>\n</ul>\n<h2>DevOps</h2>\n<ul>\n<li><strong>Node.js生产环境完整部署指南</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/node-deploy.md\">[more]</a>\n<ul>\n<li><code>[Node.js]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/node-deploy.md#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%8F%8A%E7%99%BB%E9%99%86%E6%9C%8D%E5%8A%A1%E5%99%A8\">用户权限管理及登陆服务器</a></li>\n<li><code>[Node.js]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/node-deploy.md#%E5%A2%9E%E5%BC%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E7%AD%89%E7%BA%A7\">增强服务器安全等级</a></li>\n<li><code>[Node.js]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/node-deploy.md#nodejs%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2\">Node.js生产环境部署</a></li>\n<li><code>[Node.js]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/node-deploy.md#nginx%E6%98%A0%E5%B0%84\">Nginx端口映射</a></li>\n<li><code>[Node.js]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/node-deploy.md#mongodb\">Mongodb生产环境部署</a></li>\n<li><code>[Node.js]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/node-deploy.md#%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E5%90%8C%E6%AD%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BB%93%E5%BA%93%E8%BF%9B%E8%A1%8C%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2\">实现服务器与第三方仓库的关联-PM2代码部署</a></li>\n</ul>\n</li>\n<li><strong>NPM模块管理</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/npm-deploy.md\">[more]</a>\n<ul>\n<li><code>[NPM]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/npm-deploy.md#npm%E6%BA%90%E8%AE%BE%E7%BD%AE\">npm源设置</a></li>\n<li><code>[NPM]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/npm-deploy.md#npm%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95\">nnpm注册登录</a></li>\n<li><code>[NPM]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/npm-deploy.md#npm-module-%E5%8F%91%E5%B8%83\">npm module 发布</a></li>\n<li><code>[NPM]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/npm-deploy.md#%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98\">可能遇到的问题</a></li>\n</ul>\n</li>\n<li><strong>Linux系统问题汇总</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/linux-question.md\">[more]</a></li>\n</ul>\n<h2>工具</h2>\n<ul>\n<li><strong>Git</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/tools/git.md\">[more]</a>\n<ul>\n<li><code>[Git]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/tools/git.md\">Git常用命令及日常问题集锦</a></li>\n</ul>\n</li>\n<li><strong>SEO</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/tools/seo.md\">[more]</a>\n<ul>\n<li><code>[SEO实战]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/tools/seo.md\">SEO网站优化title设置与快速排名</a></li>\n</ul>\n</li>\n</ul>\n<h2>资料</h2>\n<ul>\n<li><strong>书籍推荐</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/materials/book.md\">[more]</a></li>\n<li><strong>Blog推荐</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/materials/blog.md\">[more]</a></li>\n<li><strong>文章推荐</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/materials/article.md\">[more]</a></li>\n</ul>\n<p><strong>未完待续，持续更新中。。。</strong></p>\n</div>","title":"Node.js技术栈—侧重于服务端的学习指南","last_reply_at":"2019-05-06T05:21:02.879Z","good":false,"top":false,"reply_count":10,"visit_count":797,"create_at":"2019-05-05T05:00:43.856Z","author":{"loginname":"Q-Angelo","avatar_url":"https://avatars0.githubusercontent.com/u/17956058?v=4&s=120"}},{"id":"5cc0840fa86ae80ce64b396c","author_id":"51b44498f78196a85c3f28b7","tab":"ask","content":"<div class=\"markdown-text\"><p>在conntroller中的 async upload方法</p>\n<pre class=\"prettyprint\"><code> let stream = await ctx.getFileStream();\nconsole.log(&quot;stream:&quot;,stream );\n</code></pre><p><strong>打印这个stream对象</strong></p>\n<pre class=\"prettyprint\"><code>  encoding: &#x27;7bit&#x27;,\n  transferEncoding: &#x27;7bit&#x27;,\n  mime: &#x27;image&#x2F;png&#x27;,\n  mimeType: &#x27;image&#x2F;png&#x27;,\n * fields: {}* }\n</code></pre><p>** html部分 **</p>\n<pre class=\"prettyprint\"><code>&lt;form action=&quot;&#x2F;api&#x2F;upload&quot; method=&quot;post&quot; enctype=&quot;multipart&#x2F;form-data&quot; &gt;\n  \n  &lt;button type=&quot;submit&quot; &gt;上传图片&lt;&#x2F;button&gt;\n  &lt;input type=&quot;file&quot;  name=&quot;file&quot; &gt;\n  &lt;input type=&quot;hidden&quot;  name=&quot;uploadType&quot; id=&quot;uploadType&quot; value=&quot;1234&quot;&gt;\n  &lt;&#x2F;form&gt;\n</code></pre><p>刚写出来时可以得到stream. fields，现在怎么折腾沒值了。但需要上传的文件是写到服务器了。\n在conntroller中的 async upload方法</p>\n<p>let stream = await ctx.getFileStream();\nconsole.log(“stream:”,stream );\n打印这个stream对象</p>\n<p>encoding: ‘7bit’,\ntransferEncoding: ‘7bit’,\nmime: ‘image/png’,\nmimeType: ‘image/png’,</p>\n<ul>\n<li>fields: {}* }\n** html部分 **</li>\n</ul>\n<p>&lt;form action=&quot;/api/upload&quot; method=“post” enctype=“multipart/form-data” &gt;</p>\n<p>&lt;button type=“submit” &gt;上传图片&lt;/button&gt;\n&lt;input type=“file”  name=“file” &gt;\n&lt;input type=“hidden”  name=“uploadType” id=“uploadType” value=“1234”&gt;\n&lt;/form&gt;\n刚写出来时可以得到stream. fields，现在怎么折腾沒值了。但需要上传的文件是写到服务器了。请大神们指点一二</p>\n</div>","title":"Egg.js 文件上传，怎么得到表单其他的input值?","last_reply_at":"2019-05-06T03:29:55.227Z","good":false,"top":false,"reply_count":2,"visit_count":348,"create_at":"2019-04-24T15:43:11.045Z","author":{"loginname":"nobody","avatar_url":"//gravatar.com/avatar/f6c2087ee6256883d056314565630cb0?size=48"}},{"id":"5cc6c4b6a86ae80ce64b5663","author_id":"58bcce197872ea0864fee3d5","tab":"ask","content":"<div class=\"markdown-text\"><p>video标签目前只支持以下三种格式的视频，但是用户上传的视频格式有很多种，有什么插件可以播放各种各样格式的视频吗？</p>\n<blockquote>\n<p>MP4 = 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件\nWebM = 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件\nOgg = 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件</p>\n</blockquote>\n<p>视频的格式有：‘mp4’, ‘flv’, ‘avi’, ‘wmv’, ‘mov’, ‘webm’, 'mpeg4’等等</p>\n</div>","title":"关于video标签视频播放的问题","last_reply_at":"2019-05-06T03:04:27.161Z","good":false,"top":false,"reply_count":2,"visit_count":497,"create_at":"2019-04-29T09:32:38.080Z","author":{"loginname":"dreamsline","avatar_url":"https://avatars3.githubusercontent.com/u/20219371?v=4&s=120"}},{"id":"5ccebe605a5bae6e078131ab","author_id":"5cce8b1b776fb66e0d171fb7","tab":"ask","content":"<div class=\"markdown-text\"><p>最近也想实现一下这个回复的功能,完全没有思路,还有查看未读消息的功能,\n求小伙伴们教教我</p>\n</div>","title":"这个评论回复的功能是怎么实现的呢","last_reply_at":"2019-05-06T02:31:33.916Z","good":false,"top":false,"reply_count":1,"visit_count":266,"create_at":"2019-05-05T10:43:44.479Z","author":{"loginname":"liuyifengmvc","avatar_url":"https://avatars2.githubusercontent.com/u/46715265?v=4&s=120"}},{"id":"5cc2a91ea86ae80ce64b4557","author_id":"580c1addc3fead57507172a9","tab":"ask","content":"<div class=\"markdown-text\"><p>对于微服务，go有etcd，node使用什么搭建微服务呢？在网上看到的文章都提到了seneca 大家一般使用什么呢？</p>\n</div>","title":"node微服务使用什么框架？","last_reply_at":"2019-05-06T02:17:10.172Z","good":false,"top":false,"reply_count":25,"visit_count":2156,"create_at":"2019-04-26T06:45:50.879Z","author":{"loginname":"jowang2016","avatar_url":"https://avatars1.githubusercontent.com/u/18169317?v=4&s=120"}},{"id":"5c74a05fab86b86ddf6b2ceb","author_id":"5928e4609e32cc84569a7431","tab":"share","content":"<div class=\"markdown-text\"><p>之所以叫ghChat，是想着以后做一些GitHub的集成，希望让这个即时通讯工具成为chat tool for github。目前只支持github授权登录，和展示github用户公开的信息，然后可以方便地在ghChat中为自己的github项目建个项目群，然后贴群链接到readme中，方便项目即时交流。</p>\n<h3>地址</h3>\n<p><a href=\"https://github.com/aermin/react-chat\">github项目地址</a>。<strong><em>富应用型的开发很耗时间精力，觉得还不错的麻烦给个star鼓励下ʘᴗʘ</em></strong></p>\n<p><a href=\"https://im.aermin.top/group_chat/ddbffd80-3663-11e9-a580-d119b23ef62e\">应用线上地址(也是项目的群链接)，支持直接github授权登录</a></p>\n<h3>技术栈</h3>\n<p>前端React全家桶，后端node.js(koa2), 数据库MySQL, <a href=\"http://xn--SocKet-he0jn1y0ra0619b.io\">双向通信SocKet.io</a>, jwt鉴权等等。具体看package.json。有疑问的可以加ghChat群交流哦，我每天都在线，也可以私聊我，<a href=\"https://im.aermin.top/private_chat/1\">点击加我</a></p>\n<h3>项目展示：</h3>\n<p>之前某个时间的大部分功能的截图，其他功能和新功能直接<a href=\"https://im.aermin.top\">线上体验</a>。</p>\n<p><img src=\"https://user-images.githubusercontent.com/24861316/55677334-2f599d00-5918-11e9-8eb9-ab74a56572b1.png\" alt=\"image\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/24861316/57189039-caf02480-6f3b-11e9-85b0-59f107b9b26f.png\" alt=\"image\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/24861316/57188951-5e285a80-6f3a-11e9-8def-ef932c4abc8b.png\" alt=\"image\"></p>\n<h3>建议开启PWA: <a href=\"https://github.com/aermin/blog/issues/63\">如何在chrome浏览器中开启对PWA的支持</a></h3>\n<h3>目前进度</h3>\n<ul>\n<li>\n<p>账户</p>\n<ul>\n<li>[x] 登录</li>\n<li>[x] 注册</li>\n<li>[x] 退出登录</li>\n<li>[x] 多设备同时登录</li>\n</ul>\n</li>\n<li>\n<p>对github的集成</p>\n<ul>\n<li>[x] 支持github授权登录</li>\n<li>[x] 展示github用户公开的信息</li>\n</ul>\n</li>\n<li>\n<p>UI</p>\n<ul>\n<li>[x] 弹窗，提示等基础组件</li>\n<li>[x] 响应式布局, 适配桌面端和移动端。</li>\n</ul>\n</li>\n<li>\n<p>私聊</p>\n<ul>\n<li>[x] 私聊</li>\n<li>[x] 添加联系人</li>\n<li>[x] 好友资料展示</li>\n<li>[x] 删除联系人</li>\n</ul>\n</li>\n<li>\n<p>群聊</p>\n<ul>\n<li>[x] 群聊</li>\n<li>[x] 建群</li>\n<li>[x] 加群</li>\n<li>[x] 群资料展示</li>\n<li>[x] 退群</li>\n<li>[x] 编辑群资料</li>\n<li>[x] 有人加入群时会有提示</li>\n</ul>\n</li>\n<li>\n<p>查询</p>\n<ul>\n<li>[x] 用户搜索&amp;&amp;群搜索： 支持前端模糊搜索和后端模糊搜索</li>\n</ul>\n</li>\n<li>\n<p>丰富聊天方式</p>\n<ul>\n<li>[x] 聊天页表：实时按时间降序展示联系过的人和加入的群</li>\n<li>[x] 发图</li>\n<li>[x] 发表情</li>\n<li>[x] 发文件</li>\n<li>[x] 下载文件</li>\n<li>[x] Enter快捷键发送信息,发送按钮灰亮</li>\n<li>[x] @某人</li>\n<li>[x] 图片放大查看</li>\n<li>[x] 发送copy的图片(如截图后粘贴可直接发图)</li>\n<li>[x] 分享群|联系人给其他的人|群（应用内|外都支持）</li>\n<li>[ ] 提供在线表情库</li>\n<li>[ ] 支持Markdown</li>\n<li>[ ] 支持Quote</li>\n</ul>\n</li>\n<li>\n<p>新消息提示</p>\n<ul>\n<li>[x] 浏览器桌面通知（生产环境下，使用chrome的桌面通知需要你的网站是HTTPS的）</li>\n<li>[x] 列表未读消息数目提示</li>\n<li>[x] 刷新/重开/(不同账号)重登页面，列表未读消息的数目将仍然且准确显示</li>\n</ul>\n</li>\n<li>\n<p>不断的重构和性能优化</p>\n<ul>\n<li>[x] gzip 压缩</li>\n<li>[x] 聊天内容懒加载，每次获取20条数据</li>\n<li>[x] 路由按需加载</li>\n<li>[x] 接口请求频率限制</li>\n<li>[ ] css文件单独打包</li>\n<li>[ ] sql优化</li>\n</ul>\n</li>\n<li>\n<p>其他</p>\n<ul>\n<li>[x] 机器人智能聊天回复</li>\n<li>[x] 部署SSL证书</li>\n<li>[x] 支持PWA</li>\n<li>[ ] 国际化</li>\n<li>[ ] 后端用TS重写，封装成sdk</li>\n<li>[ ] CI/CD</li>\n</ul>\n</li>\n</ul>\n<h3>项目结构图</h3>\n<pre class=\"prettyprint\"><code>├── LICENSE\n├── README-zh_CN.md\n├── README.md\n├── build\n├── package-lock.json\n├── package.json\n├── postcss.config.js\n├── secret.js &#x2F;&#x2F; 放一些非公开的secret\n├── server  &#x2F;&#x2F; 后端代码\n│   ├── config.js\n│   ├── controllers\n│   ├── ecosystem.config.js &#x2F;&#x2F; pm2加生产环境变量的配置文件\n│   ├── gulpfile.js\n│   ├── index.js\n│   ├── init  &#x2F;&#x2F; 初始化mysql\n│   ├── middlewares\n│   ├── models\n│   ├── package-lock.json\n│   ├── package.json\n│   ├── routes  &#x2F;&#x2F; 后端路由，跟登录注册模块有关\n│   ├── socket  &#x2F;&#x2F; 除了登录注册，其他都用socket 来通信\n│   ├── utils\n│   └── yarn.lock\n├── src  &#x2F;&#x2F; 前端代码\n│   ├── App.js\n│   ├── app.scss\n│   ├── assets\n│   ├── components\n│   ├── containers\n│   ├── index.html\n│   ├── index.js\n│   ├── manifest.json &#x2F;&#x2F; PWA需要\n│   ├── modules\n│   ├── redux\n│   ├── router\n│   ├── service-worker.js &#x2F;&#x2F; PWA需要\n│   └── utils\n├── webpack.common.config.js  &#x2F;&#x2F; 通用webpack设置\n├── webpack.config.js  &#x2F;&#x2F;生产相关的webpack配置\n├── webpack.dev.config.js  &#x2F;&#x2F;开发相关的webpack配置\n</code></pre><h3>本地开发</h3>\n<ol>\n<li>项目拉到本地</li>\n</ol>\n<pre class=\"prettyprint\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;aermin&#x2F;react-chat.git\n</code></pre><ol>\n<li>在react-chat文件夹下创建一个secret.js的空白文件。</li>\n</ol>\n<p>如果要使用github授权登录，使用七牛云cdn，生产环境数据库和jwt的secret的单独配置，就要填充相应的配置了。</p>\n<pre class=\"prettyprint\"><code>module.exports = {\n  client_secret: &#x27;&#x27;, &#x2F;&#x2F; github授权登录需要的  github-&gt; settings -&gt;  Developer settings 那边生成获取\n  db: {\n    host: &#x27;&#x27;, &#x2F;&#x2F; 数据库IP\n    port: , &#x2F;&#x2F; 数据库端口\n    database: &#x27;&#x27;, &#x2F;&#x2F; 数据库名称\n    user: &#x27;&#x27;, &#x2F;&#x2F; 数据库用户名\n    password: &#x27;&#x27;, &#x2F;&#x2F; 数据库密码\n  },\n  secretValue: &#x27;&#x27;, &#x2F;&#x2F; json web token 的 secret\n  qiniu: { &#x2F;&#x2F; 七牛云配置\n    accessKey: &#x27;&#x27;,\n    secretKey: &#x27;&#x27;,\n    bucket: &#x27;&#x27;\n  }\n};\n</code></pre><ol>\n<li>下载前端的npm包</li>\n</ol>\n<pre class=\"prettyprint\"><code>cd react-chat\n</code></pre><pre class=\"prettyprint\"><code>npm i\n</code></pre><ol>\n<li>下载后端的npm包</li>\n</ol>\n<pre class=\"prettyprint\"><code>cd cd react-chat&#x2F;server \n</code></pre><pre class=\"prettyprint\"><code>npm i\n</code></pre><ol>\n<li>初始化数据库</li>\n</ol>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;需要先在本地建一个名为ghchat的mysql数据库\n配置如下看react-chat&#x2F;server&#x2F;config.js\n\nnpm run init_sql    &#x2F;&#x2F;然后查看下数据库是否init成功\n</code></pre><ol>\n<li>跑起前端和后端的代码</li>\n</ol>\n<pre class=\"prettyprint\"><code>npm run start\n</code></pre><pre class=\"prettyprint\"><code>cd ..      &#x2F;&#x2F; 返回到react-chat&#x2F;目录\n</code></pre><pre class=\"prettyprint\"><code>npm run start\n</code></pre><p>ps: 本地发图片和发文件和github登录无法使用，需要自己去github和七牛云申请一些东西</p>\n<h3>文档</h3>\n<p>这边开坑了一篇<a href=\"https://github.com/aermin/blog/issues/60\">ghChat开发历程</a> ，将不断地更新总结做这个全栈项目时会遇到的问题，知识点，和坑。</p>\n</div>","title":"写个高完成度的实时聊天应用，Node(Koa2)+React/Vue全家桶+Socket.io+MySQL+PWA","last_reply_at":"2019-05-06T02:02:49.314Z","good":false,"top":false,"reply_count":25,"visit_count":3238,"create_at":"2019-02-26T02:11:43.731Z","author":{"loginname":"aermin","avatar_url":"https://avatars1.githubusercontent.com/u/24861316?v=4&s=120"}},{"id":"5cceae295a5bae6e07813106","author_id":"58bcce197872ea0864fee3d5","tab":"ask","content":"<div class=\"markdown-text\"><p>需求是这样的：用户在上传视频时，上传完成之后，会选择某一帧的图片作为视频的预览图片，也即video标签的poster的值，怎么读取视频里面的帧呢？</p>\n</div>","title":"怎么获取视频里面的某一帧或者某几帧","last_reply_at":"2019-05-06T02:01:58.563Z","good":false,"top":false,"reply_count":9,"visit_count":302,"create_at":"2019-05-05T09:34:33.023Z","author":{"loginname":"dreamsline","avatar_url":"https://avatars3.githubusercontent.com/u/20219371?v=4&s=120"}},{"id":"5cce4cff5a5bae6e07812d2a","author_id":"5a7a5d505321b5396004ec1e","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://nstudio.io/xplat\">https://nstudio.io/xplat</a></p>\n<p><img src=\"//static.cnodejs.org/FrLM6r-vkZ4NsM12ioYjYyCKlWVw\" alt=\"image.png\"></p>\n<p><img src=\"//static.cnodejs.org/FovNBKarrhijn-bAAV-ZK9xG02El\" alt=\"image.png\"></p>\n<p>lib 所有平台通用\nxplat 指定平台通用代码\napp 同一平台不同应用</p>\n<h2>支持：</h2>\n<ul>\n<li>web （angular）,</li>\n<li>nativescript （APP）</li>\n<li>ionic （web/APP）</li>\n<li>electron (桌面应用)</li>\n<li>nest （后端）</li>\n</ul>\n<p>也可以 多个后端或者前端项目共享一套lib库，在一个仓库中启动多个项目 （不同脚本）</p>\n<p>github: <a href=\"https://github.com/nstudio/xplat\">https://github.com/nstudio/xplat</a></p>\n</div>","title":"xplat  一套代码通用 web、APP、桌面应用、后端","last_reply_at":"2019-05-06T01:44:41.473Z","good":false,"top":false,"reply_count":2,"visit_count":322,"create_at":"2019-05-05T02:39:59.164Z","author":{"loginname":"zuohuadong","avatar_url":"https://avatars0.githubusercontent.com/u/11203929?v=4&s=120"}},{"id":"5c0a92e415a4d545e3f4c5d7","author_id":"5bc9f0ca9545eaf107b9ccdd","tab":"ask","content":"<div class=\"markdown-text\"><p>要怎么去学习</p>\n</div>","title":"如何学习angular","last_reply_at":"2019-05-05T20:58:13.385Z","good":false,"top":false,"reply_count":24,"visit_count":2579,"create_at":"2018-12-07T15:33:56.403Z","author":{"loginname":"hhffhh","avatar_url":"https://avatars0.githubusercontent.com/u/3991376?v=4&s=120"}},{"id":"5ccee56c776fb66e0d1722dd","author_id":"55d15035b25bd72150842db8","tab":"ask","content":"<div class=\"markdown-text\"><p>1、中间件代码\nsharp_rotate.js</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;\nmodule.exports = () =&gt; {\n  return async function sharpRotate(ctx, next) {\n    const start = Date.now()\n    await next()\n    console.log(&#x27;rotate 时间消耗: &#x27;, Date.now() - start, &#x27;ms&#x27;)\n  }\n}\n</code></pre><p>2、中间件配置\nconfig.default.js</p>\n<pre class=\"prettyprint\"><code>middleware: [&#x27;sharpRotate&#x27;, &#x27;errorHandler&#x27;],\n</code></pre><p>3、执行 <code>npm start</code>\n本地mac OS环境正常\nlinux-64环境中间件代码一直被执行</p>\n<p><img src=\"//static.cnodejs.org/FhtVJSV9eu3WQdzwIMTu_BE6KM0j\" alt=\"image.png\"></p>\n</div>","title":"【eggjs】npm start 后，中间件中的代码一直被执行。","last_reply_at":"2019-05-05T14:58:33.466Z","good":false,"top":false,"reply_count":2,"visit_count":187,"create_at":"2019-05-05T13:30:20.008Z","author":{"loginname":"luckymore","avatar_url":"https://avatars0.githubusercontent.com/u/5390013?v=4&s=120"}},{"id":"5b164efa29e6e510415b2803","author_id":"5b164c1957137f22415c4958","tab":"ask","content":"<div class=\"markdown-text\"><p>首先，我是做移动端iOS，最近在学Node,目前再看Node in Action这本书，感觉自己有点像无头苍蝇。书中的很多例子都是构建web应用，而我的前端知识呢?还停留在小学水平，所有有点迷茫。</p>\n<p>能不能来个老司机来带带我，帮我看看怎么学习是最高效的.\n老司机们~</p>\n</div>","title":"移动端入门Node.js怎么学习?","last_reply_at":"2019-05-05T13:13:22.726Z","good":false,"top":false,"reply_count":65,"visit_count":6758,"create_at":"2018-06-05T08:51:06.562Z","author":{"loginname":"jincc","avatar_url":"https://avatars1.githubusercontent.com/u/12285323?v=4&s=120"}},{"id":"5ccec70f5a5bae6e07813200","author_id":"58cb34c8246a2aeb194a5489","tab":"share","content":"<div class=\"markdown-text\"><p>之前写过的一篇关于<a href=\"https://github.com/soraping/any-source/issues/14\">《前端<code>IOC</code> 的简单实践》</a>，基于本人是一个前端，设计模式的基础知识都不完备，所以内容不是太严谨，正在学习中！\n文章中提到了一个关键词：依赖注入。</p>\n<p>有小伙伴跟我提说在真实项目中如何使用的，我知道 <code>angular</code> 就是借鉴 <code>spring</code> 的 <code>ioc</code> ，奈何我没有用过，下面呢就来说说我之前在<code>nodejs</code>项目上的一些实践。</p>\n<p>去年，我贴了一个 <code>nodejs</code> 的简易web框架-- <a href=\"https://github.com/soraping/lenneth\">lenneth</a>，基于 <code>koa2</code> 搞的，简单说就是用装饰器模仿 <code>spring</code> 来写 <code>nodejs</code> 的注解（说注解习惯了，就不说装饰器了），看下示例：</p>\n<pre class=\"prettyprint language-js\"><code>import {\n  Controller,\n  Autowired,\n  Post,\n  Get,\n  RequestBody,\n  PathVariable,\n  Response,\n  TResponse,\n  UseBefore,\n  Description\n} from &quot;lenneth&quot;;\nimport { UserService } from &quot;..&#x2F;services&quot;;\nimport { IUserInfo } from &quot;..&#x2F;interface&quot;;\nimport { UserAuth, RuleAuth } from &quot;..&#x2F;middleware&quot;;\n\n@Controller(&quot;&#x2F;user&quot;)\nexport class UserController {\n  @Autowired()\n  userService: UserService;\n\n  @Post(&quot;&#x2F;add&quot;)\n  @Description(&quot;添加会员&quot;)\n  @UseBefore(UserAuth, RuleAuth)\n  async addUser(\n    @RequestBody() user: IUserInfo,\n    @Response() response: TResponse\n  ) {\n    response.body = this.userService.addUser(user);\n  }\n\n  @Get(&quot;&#x2F;detail&#x2F;:userId&quot;)\n  @UseBefore(UserAuth)\n  @Description(&quot;查询会员&quot;)\n  async getUser(\n    @PathVariable(&quot;userId&quot;) userId: string,\n    @Response() response: TResponse\n  ) {\n    response.body = this.userService.getUserInfo(userId);\n  }\n}\n</code></pre><p>看到这些注解，是不是很眼熟，就是从 <code>spring</code> 抄来的，具体介绍可以去项目里看看，下面来重点介绍实现 <code>Autowired</code> 注解的过程，也就是依赖注入的实践。</p>\n<p>看上面的实例，这个项目依赖了一个 <code>UserService</code> 类，在这个 <code>UserController</code> 这个方法中会用到这个依赖类的某个方法。</p>\n<p>依赖注入：</p>\n<pre class=\"prettyprint language-js\"><code>@Autowired()\nuserService: UserService;\n</code></pre><p>使用：</p>\n<pre class=\"prettyprint language-js\"><code>this.userService.addUser(user);\n</code></pre><p>来看下 <code>Autowired</code> 注解的实现：</p>\n<pre class=\"prettyprint language-js\"><code>import { Metadata } from &quot;@common&quot;;\nimport { descriptorOf, getClassName } from &quot;@utils&quot;;\n\n&#x2F;**\n * 注入service，类属性修饰器\n * @param params 实例化参数\n *&#x2F;\nexport const Autowired = (params: any = &quot;&quot;): Function =&gt; {\n  return (target: any, propertyKey: string) =&gt; {\n    &#x2F;&#x2F; 获取该属性的类型\n    let typeClass = Metadata.getType(target, propertyKey);\n    const descriptor = descriptorOf(target, propertyKey) || {\n      writable: true,\n      configurable: true\n    };\n    &#x2F;&#x2F; 实例化修饰类\n    descriptor.value = params ? new typeClass(params) : new typeClass();\n    Reflect.defineProperty(\n      (target &amp;&amp; target.prototype) || target,\n      propertyKey,\n      descriptor\n    );\n  };\n};\n\n</code></pre><p>解读这段实现之前，先引出了另一个概念–<strong>反射</strong>，就是在运行时动态获取一个对象的一切信息，包括方法/属性等等，特点在于动态类型反推导。</p>\n<p><a href=\"http://es6.ruanyifeng.com/#docs/reflect\"><code>Reflect</code></a> 是ES6新增的api，本身提供了不少静态方法，不过要使用还需要引入 <code>reflect-metadata</code> 这个库，为了使编译器在设计时将元数据序列化传给修饰器。</p>\n<p>通过反射能获得系统提供的<code>metadataKey</code>信息：</p>\n<ul>\n<li><code>design:type</code> 修饰目标对象的类型；</li>\n<li><code>design:paramtypes</code> 修饰目标对象方法的参数类型；</li>\n<li><code>design:returntype</code> 修饰目标对象方法返回值的类型；</li>\n</ul>\n<p>来看下案例：</p>\n<pre class=\"prettyprint language-js\"><code>import &quot;reflect-metadata&quot;;\n\nconst validate = () =&gt; {\n  return (target: any, propertyKey: string) =&gt; {\n    &#x2F;&#x2F; 修饰目标对象的类型\n    let type = Reflect.getMetadata(&quot;design:type&quot;, target, propertyKey);\n    &#x2F;&#x2F; 修饰目标的参数类型\n    let paramTypes = Reflect.getMetadata(\n      &quot;design:paramtypes&quot;,\n      target,\n      propertyKey\n    );\n    &#x2F;&#x2F; 修饰目标的返回值类型\n    let returnType = Reflect.getMetadata(\n      &quot;design:returntype&quot;,\n      target,\n      propertyKey\n    );\n    &#x2F;&#x2F; 所有能通过反射获取的元数据类型key\n    let allKeys = Reflect.getMetadataKeys(target, propertyKey);\n    console.log(&quot;type&quot;, type);\n    console.log(&quot;paramTypes&quot;, paramTypes);\n    console.log(&quot;returnType&quot;, returnType);\n    console.log(&quot;allKeys&quot;, allKeys);\n  };\n};\n\nclass Person {\n  private name: string;\n\n  @validate()\n  getInfo(tags: string): string {\n    return &#96;your name is ${this.name}, tags is ${tags}&#96;;\n  }\n}\n\n</code></pre><p>控制台展示：</p>\n<pre class=\"prettyprint language-bash\"><code>type function Function() { [native code] }\nparamTypes [ [Function: String] ]\nreturnType function String() { [native code] }\nallKeys [ &#x27;design:returntype&#x27;, &#x27;design:paramtypes&#x27;, &#x27;design:type&#x27; ]\n</code></pre><p>特别注意：<code>design:returntype</code> 依赖于所修饰方法的是否显式定义类型了，如果没有定义类型，那就会默认返回 <code>undefined</code>。</p>\n<p>我们也可以自定义 <code>metadataKey</code>，即在相应的类上定义自定义的元数据。</p>\n<pre class=\"prettyprint language-js\"><code>const service = () =&gt; {\n  return (target: any) =&gt; {\n    &#x2F;&#x2F; 自定义元数据，key 为 ServiceDecorator\n    Reflect.defineMetadata(&quot;ServiceDecorator&quot;, &quot;your personal value&quot;, target);\n  };\n};\n\n@service()\nclass Person {\n  private name: string;\n}\n\n&#x2F;&#x2F; 在合适的位置获取之前定义的元数据\n&#x2F;&#x2F; your personal value\nconsole.log(Reflect.getMetadata(&quot;ServiceDecorator&quot;, Person));\n</code></pre><p>自此，有了这个知识，在看上面的 <code>Autowired</code> 代码是不是简单的多了。</p>\n<p><code>Autowired</code> 注解的本质是一个属性修饰器，主要是考虑到会有参数传入，所以就写了一个高阶函数。修饰器本身就不做介绍了，可以看下阮一峰老师的es6教程。</p>\n<p>在方法内部，先获取了被修饰对象的类型，转换如下：</p>\n<pre class=\"prettyprint language-js\"><code>let typeClass = Reflect.getMetadata(&quot;design:type&quot;, target, propertyKey);\n</code></pre><p>这个 <code>metadataKey</code> 是系统提供的 <code>design:type</code>，获取被修饰对象的类型。</p>\n<pre class=\"prettyprint language-js\"><code>@Autowired()\nuserService: UserService;\n</code></pre><p>那这个 <code>typeClass</code> 的值就是 <code>UserService</code>。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 获取指定对象属性的描述对象\nconst descriptor = Reflect.getOwnPropertyDescriptor(target, propertyKey) || {\n      writable: true,\n      configurable: true\n    };\n</code></pre><p>这里就是获取 <code>UserController</code> 的 <code>userService</code> 属性的描述对象，那这个值有什么用呢？</p>\n<p><code>Reflect.getOwnPropertyDescriptor</code> 方法其实等同于 <code>Object.getOwnPropertyDescriptor</code> ，它会返回一个object:</p>\n<pre class=\"prettyprint language-js\"><code>{\n    value: &quot;value&quot;,\n    writable: true,\n    enumerable: true,\n    configurable: true\n}\n</code></pre><p>返回的四个字段中<code>value</code>就是这个属性的值，我们只要修改这个<code>value</code>字段，就可以实现注入了。</p>\n<pre class=\"prettyprint language-js\"><code>descriptor.value = params ? new typeClass(params) : new typeClass();\nReflect.defineProperty(\n  (target &amp;&amp; target.prototype) || target,\n  propertyKey,\n  descriptor\n);\n</code></pre><p>所以，最后修改了这个属性的描述对象的值，使它指向了所返回类型的实例对象，再重新定义这个属性的描述对象，这样编译后，<code>userService</code> 这个被修饰的属性就是<code>UserService</code> 的实例对象，能够访问到<code>UserService</code>内的属性方法了。</p>\n<p>如此，就实现了 <code>Autowired</code> 注解的功能了。</p>\n<p>完整示例：</p>\n<pre class=\"prettyprint language-js\"><code>const Autowired = (params: any = &quot;&quot;): Function =&gt; {\n  return (target: any, propertyKey: string) =&gt; {\n    &#x2F;&#x2F; 获取该属性的类型\n    let typeClass = Reflect.getMetadata(&quot;design:type&quot;, target, propertyKey);\n    const descriptor = Reflect.getOwnPropertyDescriptor(\n      target,\n      propertyKey\n    ) || {\n      writable: true,\n      configurable: true\n    };\n    &#x2F;&#x2F; 实例化修饰类\n    descriptor.value = params ? new typeClass(params) : new typeClass();\n    Reflect.defineProperty(\n      (target &amp;&amp; target.prototype) || target,\n      propertyKey,\n      descriptor\n    );\n  };\n};\n\nclass UserService {\n  getUserById(id: string) {\n    return &#96;user id is ${id}&#96;;\n  }\n}\n\nclass Person {\n  @Autowired()\n  private userService: UserService;\n  \n  getUserInfo(id: string) {\n    console.log(this.userService.getUserById(id));\n  }\n}\n\n&#x2F;&#x2F; user id is 12\nconsole.log(new Person().getUserInfo(&quot;12&quot;));\n</code></pre><p><a href=\"https://github.com/soraping/any-source/issues/15\">原文地址</a></p>\n</div>","title":"typescript依赖注入实践","last_reply_at":"2019-05-05T11:20:47.721Z","good":false,"top":false,"reply_count":0,"visit_count":258,"create_at":"2019-05-05T11:20:47.721Z","author":{"loginname":"soraping","avatar_url":"https://avatars2.githubusercontent.com/u/8610213?v=4&s=120"}},{"id":"5ccec2fc776fb66e0d172261","author_id":"54bc7fde0049cbcc5994c51f","tab":"share","content":"<div class=\"markdown-text\"><p>网上nodejs的加密基本上都是做成一个可执行文件，但是很多时候的需求是加密部分代码，而不是全部代码。我的思路是写一个解密的文件打包进node里面，可以参考nodejs教程https://github.com/nodejs/node/blob/master/BUILDING.md，如下\n<img src=\"//static.cnodejs.org/FtTIdMQtEcDCAqEX8mMD-WwVv4wh\" alt=\"image.png\"></p>\n<ol>\n<li>具体做法是我们自己创建一个文件类型jsxx，此文件放加密的代码。</li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>Module._extensions[&quot;.jsxx&quot;] = function(module, filename) {\n\t&#x2F;&#x2F; 解密代码\t\n\t&#x2F;&#x2F; 禁用一些方法，比如说toString等\n};\n</code></pre><ol>\n<li>在启动主文件里面引用当前的模块既可，只有使用相对应的node才行正常启动。</li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>require(&quot;jsxx&quot;);\n</code></pre></div>","title":"nodejs代码加密","last_reply_at":"2019-05-05T11:03:24.071Z","good":false,"top":false,"reply_count":0,"visit_count":259,"create_at":"2019-05-05T11:03:24.071Z","author":{"loginname":"einsqing","avatar_url":"https://avatars3.githubusercontent.com/u/7685948?v=4&s=120"}},{"id":"5b8de66137b3005a0b0e6b3f","author_id":"5b8de41bbf116a8c0e42579f","tab":"share","content":"<div class=\"markdown-text\"><p>Egg.js入门视频教程主要讲了Egg的环境搭建   egg的控制器      egg服务  egg中间件   egg路由 egg扩展   egg模板引擎  egg cookie   egg session</p>\n<p><strong>Eggjs 视频教程百度网盘分享接</strong>： <a href=\"https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w\">https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w</a></p>\n<p><strong>或者此连接Egg.js视频教程10讲入门链接</strong>： <a href=\"https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg\">https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg</a>  <strong>密码</strong>：4b6i</p>\n<p><strong>来源</strong>  <a href=\"https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf\">https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf</a></p>\n<p>希望老铁门能喜欢\n<img src=\"//static.cnodejs.org/FoPZNWCMpHqWFAb2QDns-UhIMX-3\" alt=\"egg01.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fu4_-OevpWiKHFqeEGBOW53MCdnE\" alt=\"egg02.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtOEkaeRTUNyuWE2mhvazrxPc6cd\" alt=\"egg03.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtJsuDe3kbcNYWWcJyfxuE08wVs5\" alt=\"egg05.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fp8erhbPkGZrsYFsd-gxn2z4Gssb\" alt=\"222.png\"></p>\n<p><img src=\"//static.cnodejs.org/FhCAuCKVwbQnTCJWtkGKv6ZR8toN\" alt=\"06.png\"></p>\n</div>","title":"Egg.js视频教程-Eggjs入门视频教程网盘免费分享-10讲入门基础希望老铁门能喜欢","last_reply_at":"2019-05-05T08:34:35.030Z","good":false,"top":false,"reply_count":93,"visit_count":12848,"create_at":"2018-09-04T01:56:49.179Z","author":{"loginname":"zlyuanteng","avatar_url":"https://avatars0.githubusercontent.com/u/42952042?v=4&s=120"}},{"id":"5cb9938d37faec0ce1d03cde","author_id":"5a52d060a89c475d7ea4fac3","tab":"ask","content":"<div class=\"markdown-text\"><p><strong>模型定义</strong></p>\n<pre class=\"prettyprint\"><code>const Sequelize = require(&#x27;sequelize&#x27;);\nconst BaseModel = require(&#x27;.&#x2F;BaseModel&#x27;);\nconst sequelize = require(&#x27;..&#x2F;lib&#x2F;HealthCheck&#x27;).getCheckInstance().getMysqlConnection(); &#x2F;&#x2F;获取最下面定义的sequelize连接\nclass UserModel extends BaseModel {\n    constructor() {\n        super();\n    }\n    async addNewUser(params) {&#x2F;&#x2F;params是传过来的参数，主要是要添加的字段值，类型是Object\n        let addRuesult = await UserModel.findOrCreate({\n            where: {username: params.username},\n            defaults: {password: params.password, nickname: params.nickname, region: params.region, status: 11}\n        });\n\n        return addRuesult;\n    }\n}\n\n&#x2F;&#x2F;用户表模型定义\nUserModel.init({\n    id: {type: Sequelize.UUID, defaultValue: Sequelize.UUIDV1, allowNull: false, primaryKey: true},\n    username: {type: Sequelize.STRING, allowNull: false},\n    password: {type: Sequelize.STRING, allowNull: false},\n    nickname: Sequelize.STRING,\n    region: Sequelize.STRING,\n    status: {type: Sequelize.INTEGER(2), allowNull: false},\n    created_time: {type: Sequelize.DATE, allowNull: false},\n    last_login_time: Sequelize.DATE\n}, {\n    sequelize,\n    modelName: &#x27;user&#x27;,\n    timestamps: true,\n    createdAt: &#x27;created_time&#x27;,\n    updatedAt: &#x27;last_login_time&#x27;,\n    deletedAt: false\n});\n\nmodule.exports = UserModel;\n</code></pre><p><strong>BaseModel定义</strong></p>\n<pre class=\"prettyprint\"><code>const Sequelize = require(&#x27;sequelize&#x27;);\nconst Model = Sequelize.Model;\n\nclass BaseModel extends Model{\n    constructor() {\n        super();\n    }\n}\n\nmodule.exports = BaseModel;\n</code></pre><p><strong>数据库连接定义</strong></p>\n<pre class=\"prettyprint\"><code> let sequelize = new Sequelize({\n \thost: &#x27;127.0.0.1&#x27;,\n        port: 3306,\n        username: &#x27;root&#x27;,\n        password: &#x27;123456&#x27;,\n        database: &#x27;service&#x27;,\n        dialect: &#x27;mysql&#x27;,\n        define: {\n            freezeTableName: true\n        }\n });\n</code></pre><p><strong>问题</strong>\n模型定义由于有做字段值非空验证，结果sequelize会报验证非空错误，传过来的参数都是能正确获取到的，就是调用create或者findOrCreate方法时无法获取到字段值；我有试过在调用sequelize的方法时，直接将字段值写死，还是会报一样的错；大神们帮我看看到底是我定义错了，还是哪个地方出了问题？谢谢！</p>\n</div>","title":"sequelize v5版本使用create或者findOrCreate添加数据时，传过去的值都是undefined","last_reply_at":"2019-05-05T06:49:36.446Z","good":false,"top":false,"reply_count":9,"visit_count":1245,"create_at":"2019-04-19T09:23:25.976Z","author":{"loginname":"yss1993","avatar_url":"https://avatars1.githubusercontent.com/u/24558693?v=4&s=120"}},{"id":"5cc72448a86ae80ce64b5822","author_id":"54f5240d66c739e05459b2f4","tab":"ask","content":"<div class=\"markdown-text\"><p>使用node readdir返回的files文件顺序和在windows系统中看到的顺序不一样，怎么保持一致啊，文件夹命名有纯中文的，有数字加中文的</p>\n</div>","title":"readir读取文件夹顺序问题","last_reply_at":"2019-05-05T06:36:27.844Z","good":false,"top":false,"reply_count":2,"visit_count":546,"create_at":"2019-04-29T16:20:24.305Z","author":{"loginname":"weiketa","avatar_url":"https://avatars3.githubusercontent.com/u/7657987?v=4&s=120"}},{"id":"5cca7561a86ae80ce64b5f07","author_id":"5b31b09b57137f22415c4f4a","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p><strong>该文章阅读需要5分钟,更多文章请点击本人博客<a href=\"https://www.halu886.cn\">halu886</a></strong></p>\n</blockquote>\n<ul>\n<li><a href=\"#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E9%9A%BE%E7%82%B9\">异步编程的难点</a>\n<ul>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97%E8%BF%87%E6%B7%B1\">函数嵌套过深</a></li>\n<li><a href=\"#%E9%98%BB%E5%A1%9E%E4%BB%A3%E7%A0%81\">阻塞代码</a></li>\n<li><a href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B\">多线程编程</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\">异步编程解决方案</a>\n<ul>\n<li><a href=\"#%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F\">事件发布/订阅模式</a></li>\n<li><a href=\"#%E9%9B%86%E6%88%90events%E6%A8%A1%E5%9D%97\">集成events模块</a></li>\n<li><a href=\"#%E5%88%A9%E7%94%A8%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98\">利用事件队列解决雪崩问题</a></li>\n</ul>\n</li>\n</ul>\n<h1>异步编程的难点</h1>\n<h2>函数嵌套过深</h2>\n<p>这应该是Node中最受人诟病的地方。在前端开发中，较少存在异步多级依赖的业务场景。</p>\n<pre class=\"prettyprint language-js\"><code>$(selector).click(function(event){\n    &#x2F;&#x2F; TODO\n});\n$(selector).change(function(event){\n    &#x2F;&#x2F; TODO\n})\n</code></pre><p>但是在Node中，事物中多级异步调用的场景比比皆是。</p>\n<pre class=\"prettyprint language-js\"><code>fs.readdir(path.join(_dirname,&#x27;..&#x27;),function(err,files){\n    files.forEach(function(filename,index){\n        fs.readFile(filename,&#x27;utf8&#x27;,funtion(err,file){\n            &#x2F;&#x2F; TODO\n        })\n    })\n})\n</code></pre><p>在上述场景中，因为两次操作存在依赖关系，嵌套情有可原。但是在网页渲染中，通常需要数据，模板，静态文件，但是三者并不相互依赖，但是最终渲染结果三者缺一不可，如果采用默认的异步方法调用。</p>\n<pre class=\"prettyprint language-js\"><code>fs.readFile(template_path,&#x27;utf8&#x27;,function(err,template){\n    db.query(sql,function(err,data){\n        l10n.get(function(err,resources){\n            &#x2F;&#x2F; TODO\n        })\n    })\n})\n</code></pre><p>虽然从结果上来说这是没有问题的，但是这并没有使用Node的并行优势。</p>\n<h2>阻塞代码</h2>\n<p>对于Javascript的开发者可能会困惑，如何实现沉睡线程的功能，<code>setTimeout()</code>和<code>setInterval()</code>能延后操作，但是不能阻塞后面的代码执行。\n所以，我们可能会这样实现<code>sleep(1000)</code>的效果。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; TODO\nvar start = new Date();\nwhile(new Date() - start &lt;1000){\n    &#x2F;&#x2F; TODO\n}\n&#x2F;&#x2F; 需要阻塞的代码\n</code></pre><p>但是事实却是，CPU会持续计算，根本就没有起到线程沉睡的功能，并且Node是单线程的，CPU所有的资源都在为这段代码服务，导致任何请求都得不到响应。</p>\n<p>存在这种需求，统一规划业务逻辑，调用setTimeout()实现效果会更好。</p>\n<h2>多线程编程</h2>\n<p>我们在讨论Javascript编程时，通常都是单线程编程，前端中UI渲染和Javascript执行线程共用一个线程。在Node中，只是没有UI渲染，模型基本相同。但是在多核服务器中，单个Node进程实际上没有充分利用多核CPU。随着业务复杂化，对于多核CPU的要求也会越来越高。浏览器提出Web Workers。它通常将Javascript执行与UI渲染分离，可以通过多核CPU进行大量运算。并且Web Worker也是一个通过消息机制合理使用多核CPU的合理模型。</p>\n<p><img src=\"http://resource.halu886.cn/images/async-code-2/1.png?x-oss-process=style/halu-blog-watermark\" alt=\"1\"></p>\n<p>遗憾的是浏览器对于标准存在明显的滞后，导致Web Worker并没有广泛的应用。并且虽然Web Worker解决了多核CPU和渲染UI的问题，但是并没有解决UI渲染的效率问题。但是Node借鉴了Web Worker的模式，child_process是基础API，cluster则是它的深层次应用。</p>\n<h1>异步编程解决方案</h1>\n<p>以上我们列举了一下异步编程的缺点，和异步编程的高性能相比，编程过程看起来并没有那么完美。但是事实也并没有那么糟糕，与问题相比，解决方案总是更多。</p>\n<ul>\n<li>事件发布/订阅模式</li>\n<li>Promise/Deferred模式</li>\n<li>流程控制库</li>\n</ul>\n<h2>事件发布/订阅模式</h2>\n<p>事件监听器模式是广泛用于异步编程的模式，将回调函数异步化。又称发布/订阅模式</p>\n<p>Node自身的<a href=\"https://nodejs.org/docs/latest/api/events.html\">events模块</a>是发布订阅的一个简单实现，Node大多数模块都继承自它，这比前端的事件机制简单的多，不存在事件冒泡，也不存在<code>preventDefault()</code>,<code>stopPropagetion()</code>,<code>stopImmediatePropagation()</code>等控制事件传递的方法。具有<code>addListener/on()</code>，<code>once()</code>，<code>removeListener()</code>，<code>removeAllListeners()</code>和<code>emit()</code>等基本的事件监听模式的方法实现。</p>\n<pre class=\"prettyprint language-js\"><code>emitter.on(&quot;event1&quot;,function(message){\n    console.log(message);\n})\n\nemitter.emit(&#x27;event1&#x27;,&quot;I am message!&quot;);\n</code></pre><p>订阅事件是高阶函数的应用，一个事件能够与多个回调函数相关联，一个回调函数又称为事件监听器。当使用<code>emit()</code>发布事件后，消息会传递给注册的事件监听器都会被执行，并且监听器能够方便的添加或者删除，这样能够实现事件和具体逻辑的解耦。</p>\n<p>事件发布/订阅自身没有同步和异步的概念，<code>emit()</code>基于事件循环的概念而异步触发的。那么可以理解为发布/订阅模式应用于异步编程。</p>\n<p>事件发布/订阅模式模式主要用于业务的解耦，事件的发布者不用关心订阅的监听者的业务逻辑是什么，有多少个监听者，数据可以通过消息的方法灵活的流转。可以将一个流程中不变的封装成一个个组件，容易变化的暴露出去给外部处理，可以理解为事件的设计是组件的接口设计。</p>\n<p>从另外一个角度上来看，事件监听也是一种钩子（hook）模式，Node中大多数对象都是黑盒，可以通过事件将对象在运行状态的状态通过事件传递出来。</p>\n<pre class=\"prettyprint language-js\"><code>var options = {\n    host: &#x27;www.google.com&#x27;,\n    port: 80,\n    path: &#x27;&#x2F;upload&#x27;,\n    method: &#x27;POST&#x27;\n}\n\nvar req = http.request(options,function(res){\n    console.log(&#x27;STATUS&#x27; + res.statusCode);\n    console.log(&#x27;HEADERS:&#x27; + JSON.stringify(res.headers));\n\n    res.setEncoding(&#x27;utf8&#x27;);\n    res.on(&#x27;data&#x27;,function(chunk){\n        console.log(&#x27;BODY:&#x27;+chunk);\n    });\n\n    res.on(&#x27;end&#x27;,function(){\n        &#x2F;&#x2F; TODO\n    })\n    req.on(&#x27;error&#x27;,function(e){\n        console.log(&#x27;problem with request:&#x27; + e.message);\n    })\n    req.write(&#x27;data\\n&#x27;);\n    req.write(&#x27;data\\n&#x27;);\n    req.end();\n})\n</code></pre><p>在这段http请求中，我们只需要将重点放在error,data,end事件上，业务流程则不需要过于关注。</p>\n<p>下面有两个基于健壮性考虑的细节</p>\n<ul>\n<li>如果事件的监听器超过10个，将会获得一条警告，初衷是担心导致内存泄露。可以通过emitter.setMaxListeners(0)关闭这个限制。</li>\n<li>为了处理异常，当事件处理中发生了一个异常，实例会将这个异常传递给已经存在error监听者，如果不存在异常监听者进行捕获，这个异常将会向外抛出，最后如果没有被捕获，则会导致线程推出，一个健壮的EventEmitter应该有异常监听者。</li>\n</ul>\n<h2>集成events模块</h2>\n<p>实现继承一个EventEmitter类也很简单</p>\n<pre class=\"prettyprint language-js\"><code>var events = require(&#x27;events&#x27;);\n\nfunction Stream(){\n    events.EventEmitter.call(this);\n}\nutil.inherits(Stream,events.EventEmitter);\n</code></pre><p>使用util轻松的继承的EventEmitter事件，通过事件来解决业务问题，Node中核心模块有一半的对象继承了EventEmitter对象。</p>\n<h2>利用事件队列解决雪崩问题</h2>\n<p>在事件订阅/发布模式中，存在<code>once()</code>方法，事件和监听器关联，只会被执行一次，之后就会解除关联。这个可以帮助我们过滤掉一些重复性的事件响应。</p>\n<p>在计算机中，将缓存存储在内存中加快数据的读取。雪崩问题指的是当高访问量时，大并发量的情况下，缓存失效。此时大量请求涌入数据库，导致网站整体的性能。</p>\n<pre class=\"prettyprint language-js\"><code>var select = function(callback){\n    db.select(&quot;SQL&quot;,function(results){\n        callback(results);\n    })\n}\n</code></pre><p>如果站点刚好启动，此时缓存不存在数据，但是如果访问量巨大时，同一条sql会在数据库中反复查询，会影响服务的整体性能。</p>\n<p>可以添加一个状态锁。</p>\n<pre class=\"prettyprint language-js\"><code>var status = &quot;ready&quot;;\nvar select = function(callback){\n    if(status === &quot;ready&quot;){\n        status = &quot;pending&quot;;\n        db.select(&quot;SQL&quot;,function(results){\n            status = &quot;ready&quot;;\n            callback(results);\n        })\n    }\n}\n</code></pre><p>此时连续调用多次，只有第一条SQL执行成功，后续的SQL则是失效的。</p>\n<p>这个时候可以引入队列服务。</p>\n<pre class=\"prettyprint language-js\"><code>var proxy = new events.EventEmitter();\nvar status = &quot;ready&quot;;\nvar select = function(callback){\n    proxy.once(&quot;selected&quot;,callback);\n    if(status === &quot;ready&quot;){\n        status = &quot;pending&quot;;\n        db.select(&quot;SQL&quot;,function(results){\n            proxy.emit(&quot;selected&quot;,results);\n            status = &quot;ready&quot;;\n        })\n    }\n}\n</code></pre><p>这里我们利用了<code>once()</code>的特性，将所有的回调都压入事件队列中。在相同的SQL完成时，将得到的结果被所有的回调共同调用，所有回调都只会运行一次，执行完后就会被销毁。并且由于Node单线程的原因，也不用担心数据同步的问题。这个也能应用到其他远程调用的场景，即使外部没有缓存策略，也能节省重复开销。</p>\n<p>不过此处可能会因为监听器过多而产生警告，需要调用<code>setMaxListeners(0)</code>移除掉警告，或者设置更大的警告阙值。</p>\n<blockquote>\n<p>以上知识点均来自&lt;&lt;深入浅出Node.js&gt;&gt;，更多细节建议阅读书籍:-)</p>\n</blockquote>\n</div>","title":"异步编程总结-2","last_reply_at":"2019-05-05T06:12:46.019Z","good":false,"top":false,"reply_count":3,"visit_count":518,"create_at":"2019-05-02T04:43:13.103Z","author":{"loginname":"halu886","avatar_url":"https://avatars1.githubusercontent.com/u/22374024?v=4&s=120"}},{"id":"5cc7ebcd05ae566f637fddd2","author_id":"5ac77987e34737560fccaa7b","tab":"ask","content":"<div class=\"markdown-text\"><p>提问一个关于社保的问题，大佬们帮帮忙</p>\n<p>目前在北京工作，公司缴纳的是全额的社保，公积金的比例也比较高</p>\n<p>但是鉴于现实的情况，落户北京买房是不可能的事情了</p>\n<p>我交那么高的比例的社保，公积金，我以后回老家，我能拿到相应的好处吗？如果只能拿当地水平，我岂不是亏了？</p>\n</div>","title":"【非技术】提问一个关于社保的问题，大佬们帮帮忙","last_reply_at":"2019-05-05T06:06:35.767Z","good":false,"top":false,"reply_count":8,"visit_count":1031,"create_at":"2019-04-30T06:31:41.960Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{"id":"5c98303afd41137eb76611c5","author_id":"5c8b07957ce0df37324281f2","tab":"ask","content":"<div class=\"markdown-text\"><p><a href=\"https://www.bilibili.com/video/av47250164?from=search&amp;seid=5656787623889941077\">https://www.bilibili.com/video/av47250164?from=search&amp;seid=5656787623889941077</a></p>\n<p>Nodejs直播系统开发有人会吗?不知道 Nodejs搭建的直播系统性能怎么样?</p>\n</div>","title":"Nodejs直播系统开发有人会吗?B站已经有Nodejs实现（摄像机）监控直播管理系统","last_reply_at":"2019-05-05T03:44:24.799Z","good":false,"top":false,"reply_count":16,"visit_count":2825,"create_at":"2019-03-25T01:34:50.259Z","author":{"loginname":"xuemeifenglin","avatar_url":"https://avatars3.githubusercontent.com/u/48575523?v=4&s=120"}},{"id":"5cce5b535a5bae6e07812df6","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FmgWkquxIMAANCnQHWkYgIm7wFul\" alt=\"image.png\"></p>\n<p>找外包，就搜小程序 “小猿众包”，扫如下码就行了，每天更新外包项目资源：\n<img src=\"//static.cnodejs.org/Fvwzo2PzuWpd8lBzi1s4vf9yz2tn\" alt=\"image.png\"></p>\n</div>","title":"有没有做外包的朋友，兼职做点外包~~","last_reply_at":"2019-05-05T03:41:07.912Z","good":false,"top":false,"reply_count":0,"visit_count":436,"create_at":"2019-05-05T03:41:07.912Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5ca2dc5631010b2dfbb4222f","author_id":"57b99bc2dcaeb5d932db220a","tab":"share","content":"<div class=\"markdown-text\"><h1>Web性能</h1>\n<p>从底层计算机网络协议到应用层各个方面去理解Web性能，此项目可能会涉及到网络、操作系统、编译原理、工程开发等知识，欢迎贡献。\nGithub: <a href=\"https://github.com/laoqiren/web-performance\">https://github.com/laoqiren/web-performance</a></p>\n<h2>目录</h2>\n<ul>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/README.md\">网页渲染原理</a>\n<ul>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">渲染过程</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.md\">资源加载顺序</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5.md\">浏览器优化策略</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/repaint%E4%B8%8Ereflow.md\">repaint与reflow</a></li>\n</ul>\n</li>\n<li><a href=\"/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/README.md\">带宽与延迟</a>\n<ul>\n<li><a href=\"/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%BC%80%E5%A7%8B.md\">从输入URL开始</a></li>\n<li><a href=\"/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F.md\">带宽与延迟</a></li>\n<li><a href=\"/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/TCP%E5%8D%8F%E8%AE%AE%E7%BB%86%E8%8A%82.md\">TCP协议细节</a></li>\n<li>HTTP 1.x性能</li>\n<li>针对性优化</li>\n</ul>\n</li>\n<li><a href=\"/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/README.md\">缓存机制</a>\n<ul>\n<li><a href=\"/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.md\">首部字段</a></li>\n<li><a href=\"/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA.md\">浏览器行为</a></li>\n<li><a href=\"/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E4%BC%98%E5%8C%96.md\">优化</a></li>\n</ul>\n</li>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/README.md\">静态资源</a>\n<ul>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9.md\">资源压缩</a></li>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96.md\">图片资源优化</a></li>\n<li>离线应用资源</li>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/Webpack.md\">Webpack</a></li>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/CDN.md\">CDN</a></li>\n</ul>\n</li>\n<li>响应式编程\n<ul>\n<li><a href=\"/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/PubSub%E6%96%B9%E5%BC%8F.md\">Pub/Sub方式</a></li>\n<li><a href=\"/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/Vue%E6%96%B9%E5%BC%8F.md\">Vue的方式</a></li>\n<li><a href=\"/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/%E8%84%8F%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6.md\">脏检查机制</a></li>\n<li>Rx</li>\n</ul>\n</li>\n<li>Virtual DOM\n<ul>\n<li><a href=\"/%E8%99%9A%E6%8B%9FDOM/React%E5%9F%BA%E7%A1%80.md\">React基础</a></li>\n<li>实现</li>\n<li>diff算法</li>\n<li>性能考虑</li>\n</ul>\n</li>\n<li>SPA与SSR\n<ul>\n<li>SPA问题</li>\n<li>服务端渲染</li>\n<li>同构应用</li>\n<li>性能问题</li>\n</ul>\n</li>\n<li>HTTP2\n<ul>\n<li>新特性概览</li>\n<li>性能提升</li>\n<li>工程实践</li>\n</ul>\n</li>\n<li>HTTPS性能影响\n<ul>\n<li><a href=\"/HTTPS%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D/TLS%E5%8E%9F%E7%90%86.md\">TLS原理</a></li>\n<li><a href=\"/HTTPS%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D/%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D.md\">性能影响</a></li>\n</ul>\n</li>\n<li><a href=\"/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/README.md\">高性能JavaScript</a>\n<ul>\n<li><a href=\"/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/V8%E4%B8%8EJIT.md\">V8与JIT</a></li>\n<li><a href=\"/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md\">内存管理</a></li>\n<li><a href=\"/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/GC%E6%9C%BA%E5%88%B6.md\">GC机制</a></li>\n<li>内存泄露</li>\n<li>算法与流程</li>\n<li>Web worker</li>\n</ul>\n</li>\n<li>WebAssembly\n<ul>\n<li>编译原理</li>\n<li>性能提升点</li>\n<li>应用场景</li>\n</ul>\n</li>\n<li>PWA与离线应用</li>\n<li>即时应用与P2P\n<ul>\n<li>UDP协议</li>\n<li>WebRTC</li>\n<li>WebSocket</li>\n<li>其他解决方案</li>\n</ul>\n</li>\n<li>Node.js性能优化\n<ul>\n<li><a href=\"/Node%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84.md\">多进程架构</a></li>\n<li><a href=\"/Node%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Node%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B.md\">Node中的多进程</a></li>\n<li><a href=\"/Node%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%BC%82%E6%AD%A5IO.md\">异步I/O</a></li>\n<li>Buffer与Stream</li>\n<li>C++扩展</li>\n</ul>\n</li>\n<li>云计算相关\n<ul>\n<li>三大算法</li>\n<li>虚拟技术</li>\n<li>分布式集群</li>\n<li>大数据计算</li>\n</ul>\n</li>\n<li>集群与负载均衡</li>\n<li>数据库相关</li>\n<li>性能测试\n<ul>\n<li>Chrome开发者工具</li>\n<li>benchmark</li>\n<li>压力测试</li>\n</ul>\n</li>\n</ul>\n<h2>引用说明</h2>\n<p>此项目会引用许多其他文章书籍的图片或部分内容，我会尽量都加以注明，如果有部分遗漏以致于侵犯到您的版权，烦请联系我修改！此项目旨在整理零碎的知识和实践方案，方便交流学习，请勿用于商业用途。</p>\n<h2>参与贡献</h2>\n<ul>\n<li>提想法和建议</li>\n<li>纠错完善</li>\n<li>增加新章节或内容</li>\n</ul>\n</div>","title":"性能优化知识与实践整理","last_reply_at":"2019-05-05T03:41:01.686Z","good":false,"top":false,"reply_count":1,"visit_count":1861,"create_at":"2019-04-02T03:51:50.977Z","author":{"loginname":"laoqiren","avatar_url":"https://avatars2.githubusercontent.com/u/16136702?v=4&s=120"}},{"id":"59e783f5c08dd9db362e0f97","author_id":"59227363d371b6372a8afc26","tab":"share","content":"<div class=\"markdown-text\"><p>找java的connector时无意间发现的，一看文档发布日期竟然一个月前就有了\n下载地址https://dev.mysql.com/downloads/connector/nodejs/\n文档https://dev.mysql.com/doc/dev/connector-nodejs/</p>\n<p>版本要求\nNode.js 4.2.x\nMySQL 5.7.19 (挺新的版本了，大多数人应该都要重新下一个，顺便附上下载地址https://dev.mysql.com/downloads/mysql/)\n先安装了再说 <code>npm install @mysql/xdevapi</code></p>\n<p>官方给的示例代码</p>\n<pre class=\"prettyprint language-javascript\"><code>const mysql = require(&#x27;@mysql&#x2F;xdevapi&#x27;);\n\nmysql\n    .getSession({\n        host: &#x27;localhost&#x27;,\n        port: 33060,\n        dbUser: &#x27;user&#x27;,\n        dbPassword: &#x27;passwd&#x27;\n    })\n    .then(session =&gt; {\n        console.log(&#x27;Session created&#x27;);\n\n        return session.createSchema(&#x27;test_schema&#x27;);\n    })\n    .then(schema =&gt; {\n        console.log(&#x27;Schema created&#x27;);\n\n        return schema.createCollection(&#x27;myCollection&#x27;);\n    })\n    .then(collection =&gt; {\n        console.log(&#x27;Collection created&#x27;)\n\n        return Promise.all([\n            collection\n                .add({ baz: { foo: &#x27;bar&#x27; } }, { foo: { bar: &#x27;baz&#x27; } })\n                .execute(),\n            collection\n                .find(&quot;$.baz.foo == &#x27;bar&#x27;&quot;)\n                .execute(row =&gt; {\n                    console.log(&#x27;Found row: %j&#x27;, row);\n                })\n                .then(res =&gt; {\n                    console.log(&#x27;Collection find finished&#x27;);\n                }),\n            collection\n                .remove(&quot;($.foo.bar) == &#x27;baz&#x27;&quot;)\n                .execute()\n                .then(() =&gt; {\n                    console.log(&#x27;Document deleted&#x27;);\n                }),\n            collection\n                .drop()\n                .then(() =&gt; {\n                    console.log(&#x27;Collection deleted&#x27;);\n                })\n        ]);\n    })\n    .then(() =&gt; {\n        return session.dropSchema(&#x27;test_schema&#x27;);\n    })\n    .then(() =&gt; {\n        console.log(&#x27;Schema deleted&#x27;);\n\n        return session.close();\n    })\n    .then(() =&gt; {\n        console.log(&#x27;Session destroyed&#x27;);\n    })\n    .catch(err =&gt; {\n        console.log(err.stack);\n    });\n</code></pre><p>看起来相当不错，可以去尝试一下了</p>\n</div>","title":"刚发现MySQL发布了Node的Connector","last_reply_at":"2019-05-05T03:08:42.171Z","good":false,"top":false,"reply_count":2,"visit_count":1748,"create_at":"2017-10-18T16:40:21.087Z","author":{"loginname":"dislido","avatar_url":"https://avatars2.githubusercontent.com/u/25094788?v=4&s=120"}},{"id":"5ccdb469776fb66e0d171c1d","author_id":"545b74143e1f39344c5b3bee","tab":"ask","content":"<div class=\"markdown-text\"><p>有这种工具吗？</p>\n<p>n=3</p>\n<pre class=\"prettyprint\"><code>\t\t\t&#x27;&#x27;:{\n\t\t\t\t&#x27;&#x27;:{\n\t\t\t\t\t&#x27;&#x27;:{\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n</code></pre><p>n=2</p>\n<pre class=\"prettyprint\"><code>\t\t\t&#x27;&#x27;:{\n\t\t\t\t&#x27;&#x27;:{\n\t\t\t\t}\n\t\t\t}\n</code></pre></div>","title":"vscode生成n层嵌套json，有什么好插件？","last_reply_at":"2019-05-05T03:03:53.959Z","good":false,"top":false,"reply_count":2,"visit_count":334,"create_at":"2019-05-04T15:48:57.756Z","author":{"loginname":"chapgaga","avatar_url":"https://avatars0.githubusercontent.com/u/9590859?v=4&s=120"}},{"id":"5b852286632c7f422e5b81e5","author_id":"5b85221808d0b0fb2d8e6c84","tab":"ask","content":"<div class=\"markdown-text\"><p>最近想用node.js重构公司后端。egg.js和nest.js改选择哪一个作为系统框架呢，大神们给点意见？</p>\n</div>","title":"egg.js和nest.js改选择哪一个作为系统框架呢，大神们给点意见？","last_reply_at":"2019-05-05T01:33:57.930Z","good":false,"top":false,"reply_count":60,"visit_count":7996,"create_at":"2018-08-28T10:23:02.365Z","author":{"loginname":"danielmlc","avatar_url":"https://avatars2.githubusercontent.com/u/16604995?v=4&s=120"}},{"id":"5ccdb79d776fb66e0d171c2a","author_id":"5b376dfcac8bc1e124114500","tab":"share","content":"<div class=\"markdown-text\"><p>用过两个编程之后就会觉得他们非常相近, 两个代表作分别是 JS 的 eventEmitter 和 Rxjs</p>\n<p>了解之后 reactive  programming (响应式) 其实是基于 event data programing (事件驱动) 的方式来处理 <strong>数据流</strong>,</p>\n<p>Event data programming: <strong>当某个件事情发生我再做某些事情</strong></p>\n<p>Reactive programming: <strong>当某个件事情发生事件告诉我, 在这之前你可以吧数据处理好先</strong></p>\n<p>Event data programming 和 Reactive programming 区别在于:</p>\n<ol>\n<li>Event data programming 事件是全局性的当发出一个信号大家都会听看看是不是自己的, reactive programing 每个事件是唯一的, 如果你想监听这个事件你需要订阅它, 在这方面感觉 reactive 极大优化了性能.</li>\n<li>Event data programing 只处理事件, Reactive programming 除了可以订阅事件还可以订阅某个数据变化.</li>\n</ol>\n</div>","title":"响应式 和 事件驱动编程 区别","last_reply_at":"2019-05-04T16:02:37.820Z","good":false,"top":false,"reply_count":0,"visit_count":305,"create_at":"2019-05-04T16:02:37.820Z","author":{"loginname":"tmirun","avatar_url":"https://avatars1.githubusercontent.com/u/8052536?v=4&s=120"}},{"id":"5bb0bf6f37a6965f59051df3","author_id":"5ba61ea38f5b0c1c59ea10b6","tab":"share","content":"<div class=\"markdown-text\"><h2>在线体验地址:<a href=\"http://vip.52tech.tech/\">http://vip.52tech.tech/</a></h2>\n<h2>GIthub源码：<a href=\"https://github.com/xiugangzhang/vip.github.io\">https://github.com/xiugangzhang/vip.github.io</a></h2>\n<h2>项目预览</h2>\n<p><img src=\"//static.cnodejs.org/FmjZMm4b3MUqJIuSB5aYS2PEW0pf\" alt=\"preview.jpg\"></p>\n<ul>\n<li>主页面\n<img src=\"//static.cnodejs.org/FhTjrj9HgY37ojGYNdLWupmBfSyv\" alt=\"preview.jpg\"></li>\n<li>登录页面\n<img src=\"//static.cnodejs.org/FrZr5Mck4VQD9ndVXhJGqA9XwHsU\" alt=\"login.jpg\"></li>\n<li>注册页面\n<img src=\"//static.cnodejs.org/FnXwM1CtMBcA7cFv66vlYb-t559E\" alt=\"register.jpg\"></li>\n<li>会员中心\n<img src=\"//static.cnodejs.org/FtCfCUeeIA8Y0WnYkhvzqlweqPbs\" alt=\"user.jpg\"></li>\n<li>电影播放页面\n<img src=\"//static.cnodejs.org/FryrTyzEeEFuOgD1uXrkwF4MzXn-\" alt=\"play.jpg\"></li>\n<li>电影弹幕功能\n<img src=\"//static.cnodejs.org/FhcOXAvbMZuafMrJzU00fMvRXot9\" alt=\"danmu.jpg\"></li>\n</ul>\n<h2>视频网站项目已经完功能如下：</h2>\n<h3>v1.0.3（当前最新版本）</h3>\n<ul>\n<li>\n<ol>\n<li>增加自动抓取功能，网站数据定期实时更新</li>\n</ol>\n<ul>\n<li>电影和电视剧数据抓取</li>\n<li>电影数据信息前端展现</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影页面图片的自动抓取、下载和展示</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>代码结构调整</li>\n</ol>\n</li>\n</ul>\n<h3>v1.0.2</h3>\n<ul>\n<li>\n<ol>\n<li>简化程序安装流程，新增可视化安装界面</li>\n</ol>\n<ul>\n<li>用户可直接输入数据库名、数据库地址、数据库用户名、数据库密码信息一键完成程序的安装</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>页面部分结构的调整</li>\n</ol>\n</li>\n</ul>\n<h3>v1.0.1</h3>\n<ul>\n<li>\n<ol>\n<li>用户中心的管理</li>\n</ol>\n<ul>\n<li>对于已经注册的用户，实现用户基本信息的修改</li>\n<li>用户密码的修改</li>\n<li>用户评论记录的查看</li>\n<li>用户收藏电影的查看和播放</li>\n<li>用户登录日志的查看</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影搜索功能（特色功能）</li>\n</ol>\n<ul>\n<li>实现了根据视频播放地址和视频名称全网视频的搜索和播放功能</li>\n<li>实现了正在热映，即将上映和TOP250的电影列表的展示</li>\n<li>电影收藏和取消功能</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>弹幕功能（特色功能）</li>\n</ol>\n<ul>\n<li>类似于B站等其他视频网站的弹幕功能，用户在登录之后可以实现在线发言</li>\n</ul>\n</li>\n</ul>\n<h3>v1.0.0</h3>\n<ul>\n<li>\n<ol>\n<li>用户主页的搭建：</li>\n</ol>\n<ul>\n<li>实现了主页轮播图的显示和切换，用户可以从数据库中自由配置和切换轮播图的显示</li>\n<li>实现了主页电影列表的显示：从数据库文件读取电影和电视剧列表信息并在前台显示</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>用户登录和注册页面的搭建：</li>\n</ol>\n<ul>\n<li>实现了用户的登录和注册功能</li>\n<li>用户注册和登录验证码提示功能</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影播放页面的搭建</li>\n</ol>\n<ul>\n<li>对于其他页面的任意可以展现电影列表的页面，用户可以直接点击列表，直接进入播放页面</li>\n<li>播放页面电影详细信息的展现</li>\n<li>对于加载速度较慢的视频，用户可以自由切换播放接口进行加速</li>\n<li>用户可以在相应的播放页面查看其他用户已经发表的评论，同时也可以在登录之后自由发表评论</li>\n</ul>\n</li>\n</ul>\n<h3>其他</h3>\n<ul>\n<li>\n<ol>\n<li>页面整体的风格模仿了Discuz等论坛网站的布局</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>网站首页的轮播图效果模仿了优酷、爱奇艺、腾讯视频等主流视频网站的轮播图效果，并且对该部分的效果实现进行了代码封装</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>电影底部的的友情链接，使用了大部分网站的分栏布局，用户可以添加自己的QQ群以及微信公众号方便增加自己网站的人气</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>主要列表的分页功能，对于一些内容显示较多的不能再一页显示完整的页面，使用了ajax无刷新分页对数据进行多条展示，提高了用户的体验</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>目前主流浏览器中也做了相应测试，建议大家使用谷歌或者火狐浏览器，效果可能会更好</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>未使用其他第三方框架，首页和播放页均为纯原生的HTML，CSS， js实现（至于这个xframe-min-1.0.js文件可以参见我的GitHub xframe.js这个开源项目）</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>电影播放页面：此处也是类似于当前主流网站的的播放页面，左侧为播放窗口，右侧部分为电影的详细信息</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>底部导航：使用分栏的方式实现了底部的导航，前面的为友情链接，后面的一个为网站的微信，Q微博等联系方式</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>用户中心：这部分实现了修改密码，评论，登录，日志管理，收藏电影的功能，用户可以自由切换</li>\n</ol>\n</li>\n</ul>\n<h2>程序目录结构说明</h2>\n<pre class=\"prettyprint\"><code>vip.github.io:\n├─controllers               &#x2F;&#x2F; 控制层\n├─data                      &#x2F;&#x2F; 数据抓取层\n├─logs                      &#x2F;&#x2F; 后台日志\n│  ├─errlog                 &#x2F;&#x2F; 错误日志\n│  ├─othlog                 &#x2F;&#x2F; 其他日志\n│  └─reqlog                 &#x2F;&#x2F; 请求日志\n├─models                    &#x2F;&#x2F; 模型层\n├─static                    &#x2F;&#x2F; 静态页\n│  ├─css                    &#x2F;&#x2F; 样式表\n│  ├─images                 &#x2F;&#x2F; 静态图片资源\n│  └─js                     &#x2F;&#x2F; js脚本\n├─utils                     &#x2F;&#x2F; 工具相关\n├─views                     &#x2F;&#x2F; 视图层\n└─www                       &#x2F;&#x2F; 静态资源\n    ├─css                   &#x2F;&#x2F; 样式表\n    ├─html                  &#x2F;&#x2F; html文件\n    ├─images                &#x2F;&#x2F; 静态图片资源\n    ├─js                    &#x2F;&#x2F; js脚本\n    │  └─movielist          &#x2F;&#x2F; 搜索页电影列表\n    │      ├─components     &#x2F;&#x2F; top250&#x2F;即将上映\n    │      └─in_theaters    &#x2F;&#x2F; 正在热映\n    └─uploads               &#x2F;&#x2F; 文件上传目录\n        ├─avatar            &#x2F;&#x2F; 用户图像\n        └─movie             &#x2F;&#x2F; 电影图标\n\n</code></pre><h2>程序安装方法</h2>\n<ul>\n<li>\n<ol>\n<li>确保电脑已经安装了NodeJS环境，运行版本尽量保持最新（V8以上吧），选择本地的一个路径，然后运行命令：</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>   git clone https:&#x2F;&#x2F;github.com&#x2F;xiugangzhang&#x2F;vip.github.io.git\n</code></pre><ul>\n<li>\n<ol>\n<li>进入程序的主目录（包含app.js的那个文件夹）运行命令：npm install，系统就会自动安装该程序的依赖包；</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>在以上的步骤都执行完成且正确的情况下，就可以在程序主目录下面（有app.js的那个目录）,运行命令</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>   node app.js\n</code></pre><p>之后就会自动在浏览器中打开本程序安装的主界面；</p>\n<ul>\n<li>\n<ol>\n<li>如果是windows环境下，本程序提供了可视化的安装。用户可在程序的安装界面输入数据库名、数据库主机地址、数据库用户名、数据库密码，之后点击按钮立即安装即可，在输入的参数全部正确的情况下，就会后台自动安装程序，安装成功之后会自动跳转到网站首页；\n<img src=\"//static.cnodejs.org/FqNdjsfo5whahU-WvEC8WOpBBXA5\" alt=\"installing.jpg\"></li>\n</ol>\n</li>\n<li>\n<ol>\n<li>如果是Linux环境下，请提前准备好数据库名（database=video）、数据库主机地址（host=localhost）、数据库用户名（user=root）、数据库密码（password=123456 ），按照如下格式保存为config.properties文件，请确保这里的配置信息和你的数据库配置信息完全一致；</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>    database=video               \n    host=localhost          \n    user=root               \n    password=123456         \n</code></pre><ul>\n<li>\n<ol>\n<li>在线演示站点：<a href=\"http://vip.52tech.tech\">http://vip.52tech.tech</a></li>\n</ol>\n</li>\n<li>\n<ol>\n<li>对于安装和使用的过程中如果有什么问题和建议，也欢迎交流和提出建议，可以在issue去发起话题讨论，或直接联系邮箱：tech52admin@126.com</li>\n</ol>\n</li>\n</ul>\n</div>","title":"【VIP视频网站项目】基于Nodejs开发的VIP视频网站项目及源码分享【v1.0.3版】","last_reply_at":"2019-05-04T08:45:39.768Z","good":false,"top":false,"reply_count":24,"visit_count":16139,"create_at":"2018-09-30T12:19:59.585Z","author":{"loginname":"xiugangzhang","avatar_url":"https://avatars3.githubusercontent.com/u/29092258?v=4&s=120"}},{"id":"5c09f4bc15a4d545e3f4c18e","author_id":"5c09d26ed3b8ab334e8dba63","tab":"ask","content":"<div class=\"markdown-text\"><p>是学php还是nodejs,主要想学习一下服务端语言,其实是想学习node的，但是感觉nodejs的相关书籍还有资料比较少,遇到问题网上不一定查的到，这样的话学习起来不很困难吗? 而且数据库好多都是用mongodb，但是想用mysql啊，大家都是怎么学的?</p>\n</div>","title":"nodejs怎么学习啊?感觉资料很少啊","last_reply_at":"2019-05-04T02:57:36.970Z","good":false,"top":false,"reply_count":26,"visit_count":3441,"create_at":"2018-12-07T04:19:08.132Z","author":{"loginname":"yt7649757","avatar_url":"https://avatars3.githubusercontent.com/u/25155154?v=4&s=120"}},{"id":"5ccc27f8776fb66e0d1719c2","author_id":"5c2f299a5bf06c5e7e3f15d5","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/NuoHui/fe-note/issues\">Vue全家桶源码分析</a></p>\n<p>慢慢学习中。</p>\n</div>","title":"有没有对Vue全家桶源码感兴趣对, 一起来issues交流。","last_reply_at":"2019-05-03T11:37:28.214Z","good":false,"top":false,"reply_count":0,"visit_count":412,"create_at":"2019-05-03T11:37:28.214Z","author":{"loginname":"NuoHui","avatar_url":"https://avatars2.githubusercontent.com/u/42414989?v=4&s=120"}},{"id":"5cc5c9ab37faec0ce1d07c49","author_id":"5cc5270637faec0ce1d0785c","tab":"share","content":"<div class=\"markdown-text\"><h1><a href=\"https://xorpay.com\">XorPay 支付平台介绍</a></h1>\n<blockquote>\n<p><a href=\"https://xorpay.com\">XorPay</a>  定位为个人 / 独立开发者 / 个体户 / 小微企业提供安全、简单、稳定、正规的收款服务。目前支持 支付宝当面付 和 微信 NATIVE / JSAPI / 收银台 / 小程序 等支付方式，资金由支付宝或微信官方T+1结算自动下发个人银行卡。(支付宝为即时到账)</p>\n</blockquote>\n<h3>为什么开发 XorPay 支付平台</h3>\n<blockquote>\n<p>我们知道作为独立开发者产品需要收款是多么麻烦，注册公司维护成本太高，市面上各种收款工具要么手续费太高，要么到账很慢，体验很不好。于是我们开发了<a href=\"https://xorpay.com\">「XorPay 支付平台」</a> 用来解决这个问题，希望可以帮助到每个默默前行的独立开发者。</p>\n</blockquote>\n<h3>支持接口</h3>\n<ul>\n<li><a href=\"https://xorpay.com/doc/sign.html\">签名算法</a></li>\n<li><a href=\"https://xorpay.com/doc/alipay.html\">支付宝当面付</a></li>\n<li><a href=\"https://xorpay.com/doc/native.html\">NATIVE 扫码支付</a></li>\n<li><a href=\"https://xorpay.com/doc/cashier.html\">收银台支付</a></li>\n<li><a href=\"https://xorpay.com/doc/mini.html\">小程序支付</a></li>\n<li><a href=\"https://xorpay.com/doc/jsapi.html\">JSAPI 网页支付</a></li>\n<li><a href=\"https://xorpay.com/doc/query.html\">订单状态查询</a></li>\n<li><a href=\"https://xorpay.com/doc/notify.html\">回调通知</a></li>\n<li><a href=\"https://xorpay.com/doc/openid.html\">获取 OPENID</a></li>\n</ul>\n<h3>链接</h3>\n<ul>\n<li><a href=\"https://xorpay.com\">XorPay 官网</a></li>\n<li><a href=\"https://xorpay.com/doc\">API 文档</a></li>\n<li><a href=\"https://github.com/xorpay\">Github 仓库</a></li>\n</ul>\n<p>欢迎提问交流</p>\n</div>","title":"XorPay 个人支付平台【支持个人微信支付和支付宝支付接口】","last_reply_at":"2019-05-03T05:57:07.673Z","good":false,"top":false,"reply_count":4,"visit_count":868,"create_at":"2019-04-28T15:41:31.251Z","author":{"loginname":"xorpay","avatar_url":"https://avatars1.githubusercontent.com/u/48086955?v=4&s=120"}},{"id":"5cc3b7b737faec0ce1d072ff","author_id":"4efc278625fa69ac690004c5","tab":"share","content":"<div class=\"markdown-text\"><p>1290年了，使用TypeScript来代替Javascript来构建我们的前后端应用，已经在社区达成共识，去年在新浪移动大前端团队，也积极的投入到了TypeScript的学习和开发之中来。</p>\n<p>经过大概半年多的业务迭代，我们内部从一开始就计划开发一款拥有完整TypeScript开发体验的Nodejs Web框架。</p>\n<p>经过几个版本的迭代后，我们终于开源了团队的内部web框架，Daruk。</p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/daruk-framework/daruk\">Daruk</a></p>\n<blockquote>\n<p>Daruk是一款基于 Koa2，使用 typescript 开发的轻量级 web 框架。使用过 koa2 框架的朋友应该知道，koa2 属于比较原始和基础的 http server 实现，在日常的开发工作中，我们可能需要通过安装很多开源的中间件，自己完成复杂的项目配置，路由管理，以及和业务无关的工作：如日志，监控，性能等基础组件的定制。</p>\n</blockquote>\n<p>目前内部已经有大概10几个web项目在使用Daruk来构建了，比如下面这个c端的产品：</p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//photo.sina.cn/album_1_2841_368564.htm%3Fch%3D1%26from%3Dhot%26vt%3D4%26hd%3D1\">金正恩首会普京 双方握手 _新浪图片</a></p>\n<p>手机新浪网的高清图整站（目前落地页100% Daruk，使用TypeScript开发），频道首等其他页面还在灰度中（原来是PHP项目），流量一天1500-2000万，QPS峰值700多。</p>\n<p>Daruk自身的定位是Koa2的上层封装，所以团队中熟悉Koa开发和TS的都可以直接无门槛上手，基于约定的目录配置和周边的一些内部扩展（内部一些基础扩展还未全部开源），目前我们大前端团队已经开始承接手机新浪网的BFF层开发。</p>\n<p>回到框架本身，在一开始去年设计的时候我们还不知道有nestJs还有midwayjs这些优秀框架，今年了解到之后，我们后期也会借鉴和吸收他们的一些特性和优点进行改进。</p>\n<p>但是Daruk的Goal，从一开始的定位和之后的定位都不会变：轻巧的，易扩展的，面向对象式的MVC web框架，并拥有TS的完整开发体验。</p>\n<p>Daruk这个名字是我起的，当时沉迷塞尔达传说不能自拔，你看就是这个家伙：</p>\n<p><img src=\"//static.cnodejs.org/FjDivclyeB4Um_PiWNJwPYR-62I8\" alt=\"image.png\"></p>\n<p>当然，Daruk上手也非常简单，我们也提供了对应的脚手架工具，帮助不熟悉ts的同学可以快速玩起来：</p>\n<p>下面是一个常见的 Koa 服务代码:</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; index.js \nconst Koa = require(&quot;koa&quot;);\nconst app = new Koa();  \napp.use(async ctx =&gt; {   \n  ctx.body = &quot;Hello World&quot;;\n});  \napp.listen(3000);\n</code></pre><p>转换成 Daruk 编写的例子如下：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; src&#x2F;index.ts\nimport { Daruk } from &quot;daruk&quot;;\n\nlet app = new Daruk(&quot;myapp&quot;, {\n  rootPath: __dirname, &#x2F;&#x2F; 指定 autoloader根目录\n  debug: true &#x2F;&#x2F; 开启调试模式\n});\n\napp.run(3000);\n</code></pre><p>controllers的定义：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; src&#x2F;controllers&#x2F;index.ts\nimport { BaseController, Context, get } from &quot;daruk&quot;;\nexport default class Index extends BaseController {\n  @get(&quot;&#x2F;&quot;)\n  public async index(ctx: Context, next: Function) {\n    ctx.body = &quot;Hello world&quot;;\n  }\n}\n</code></pre><p>更多详细使用方法，可以参考文档：</p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//daruk-framework.github.io/daruk.org/tutorial/install.html%23%25E8%2584%259A%25E6%2589%258B%25E6%259E%25B6%25E5%25AE%2589%25E8%25A3%2585\">Daruk 安装文档</a></p>\n<p>最后，由于目前项目刚刚开源，网站的文档核心部分已经编写完成，但是后边的框架设计和最佳实践还没有全部完善，近期几周会以单独文章的形式投稿在我们自己的前端专栏，同时也希望喜欢TS的Nodejs开发者们多多支持，一起参与。</p>\n<p>：）</p>\n</div>","title":"使用Daruk和TypeScript构建你的Nodejs应用","last_reply_at":"2019-05-03T04:05:29.691Z","good":false,"top":false,"reply_count":47,"visit_count":2127,"create_at":"2019-04-27T02:00:23.894Z","author":{"loginname":"xiaojue","avatar_url":"https://avatars3.githubusercontent.com/u/289225?v=4&s=120"}},{"id":"5cc8019f05ae566f637fde51","author_id":"581ae153e90cfbec054d762a","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/276025/1556515821434-91b89639-b1b1-446e-a3a2-e625b8a04880.png#align=left&amp;display=inline&amp;height=360&amp;name=image.png&amp;originHeight=360&amp;originWidth=720&amp;size=553714&amp;status=done&amp;width=720\" alt=\"image.png\"></p>\n<p>【阿里云 TXD 前端月刊】- 热门前端技术快报，聚焦业界新视界；前端领域急速发展的节奏从未停歇，即将流逝的四月里，<a href=\"https://www.yuque.com/egg/nodejs/nodejs-12\">Nodejs</a> 发布了 v12 版本，<a href=\"https://addyosmani.com/blog/lazy-loading/\">Chrome75</a> 也将原生支持懒加载……也许是大潮将至，亦或是好事将近，总之，在下还能学！！！</p>\n<blockquote>\n<p>欢迎 <a href=\"https://zhuanlan.zhihu.com/txd-team\">订阅</a> &amp; <a href=\"https://github.com/txd-team/monthly/issues\">投稿</a>\n本期小编：<a href=\"https://github.com/Mavericker-1996\">佐七</a></p>\n</blockquote>\n<h2>学习专栏</h2>\n<h4><a href=\"https://frontendmasters.com/books/front-end-handbook/2019/\">2019 前端工程师手册（front-end-handbook-2019）</a></h4>\n<p>这个受欢迎的前端详细指南于本年度再次回归。更新了大量有用的资源、学习资料和开发工具。内容非常全面，值得一看。</p>\n<h4><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Layout_cookbook\">Css Layout Cookbook</a></h4>\n<p>MDN 官网为前端开发者总结的一些常用布局模块的实现方案。包括面包屑，分页，导航栏等，值得参考。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/276025/1556455431352-828407a9-780d-4743-aa43-68042bfcdbb0.png#align=left&amp;display=inline&amp;height=600&amp;name=image.png&amp;originHeight=600&amp;originWidth=696&amp;size=125343&amp;status=done&amp;width=696\" alt=\"image.png\"></p>\n<h4><a href=\"https://medium.com/%5B@bretcameron%5D(/user/bretcameron)/12-javascript-tricks-you-wont-find-in-most-tutorials-a9c9331f169d\">11 个教程中不常被提及的 JavaScript 小技巧</a></h4>\n<p>本文作者选取了 11 个在我们工作中经常出现却容易被忽略的 JavaScript 小技巧，可以帮助我们更高效的进行编码。</p>\n<h4><a href=\"https://juejin.im/post/5cbd1f0ae51d456e5e035f45#heading-14\">45 个值得收藏的 CSS 形状</a></h4>\n<p>本文列举了一些我们日常会用到的一些 CSS 形状，值得参考。此外，在Houdini 已经到来的当下，也许一句 --shape: ‘triangle’ ，即可使用，无需重复编写这些 CSS 形状。&lt;br /&gt;</p>\n<h2>新闻快报</h2>\n<h4><a href=\"https://www.yuque.com/cssconf/5th\">第五届 CSS 大会顺利举行</a></h4>\n<p>第五届 CSS 大会于 2019 年 3 月 30 日在深圳举办，本次会议共邀请了 7 位演讲嘉宾出席演讲，其中有我们熟悉的大漠，张鑫旭，勾三股四等，为我们分享了一些新时代下的 CSS 技术。</p>\n<h4><a href=\"https://addyosmani.com/blog/lazy-loading/\">Chrome75 将原生支持懒加载</a></h4>\n<p>过去我们一直通过 js 来实现图片的延迟加载，而 Chrome75 的到来将原生支持该功能。我们可以通过设置 loading 属性来控制浏览器是否延迟加载屏幕外的图像和 iframe。示例代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&lt;img src=&quot;celebration.jpg&quot; loading=&quot;lazy&quot; alt=&quot;...&quot; &#x2F;&gt;\n&lt;iframe src=&quot;video-player.html&quot; loading=&quot;lazy&quot;&gt;&lt;&#x2F;iframe&gt;\n</code></pre><p>让我们看一下效果：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/276025/1556457435267-b0ee9630-61f0-46f8-9a0b-14b4cae6592f.gif#align=left&amp;display=inline&amp;height=772&amp;name=lazyload.gif&amp;originHeight=772&amp;originWidth=1342&amp;size=3336715&amp;status=done&amp;width=1342\" alt=\"lazyload.gif\"></p>\n<h4><a href=\"https://mp.weixin.qq.com/s/jrwb7rYy_p9g_L_P8oLASQ\">微软发布基于 Chromium 的预览版 Edge</a></h4>\n<p>2018 年 12 月，微软宣布 Edge 将采用 Chromium，这是由谷歌 Chrome 支持的开源项目，其中包含了不少值得我们期待的新特性像自定义元素和 shaodw dom，javascript 字体加载API等。目前预览版现在已经可以在 Windows 上使用，很快就可以在 Mac 上使用。</p>\n<h4><a href=\"http://blog.jquery.com/2019/04/10/jquery-3-4-0-released/\">jQuery 3.4.0 版本发布</a></h4>\n<p>4月10 日，jQuery 官博发文宣告 jQuery 3.4.0 正式发布。距离 2018 年 1 月发布 v 3.3.0 版已有一年多了。jQuery 官方表示，这是 3.x 系列的最后一个版本，他们将全力准备 jQuery 4.0。本次更新重点放在一些bug的修理和性能的提升。</p>\n<h4><a href=\"https://www.yuque.com/egg/nodejs/nodejs-12\">Nodejs 12发布</a></h4>\n<p>时隔一年，Node.js 12 如约而至，正式发布第一个 <a href=\"https://github.com/nodejs/Release\">Current</a> 版本。（按照当前的节奏一年两更，2063 年我们就能迎来 Node v100 了……）</p>\n<p>该版本带来了诸如：</p>\n<ul>\n<li>V8 版本更新带来好多不错的特性；</li>\n<li>HTTP 解析速度提升；</li>\n<li>启动速度大幅提升；</li>\n<li>更好的诊断报告和堆分析工具；</li>\n<li>ESM 模块更新；</li>\n</ul>\n<p>同时 <a href=\"https://nodejs.org/en/about/releases/\">Node v6</a> 也即将停止维护。</p>\n<h4><a href=\"https://vue.w3ctech.com/\">第三届 VueConf 将在上海举办</a></h4>\n<p>一年一度的 VueConf 又来啦！VueConf 2018 是在杭州举办的，Vue.js 作者尤雨溪采用了远程参与的方式，给大家带来了精彩了演讲。这一次，VueConf 2019 上海来啦，会议将在 6 月 8 号上海徐家汇华山路举办，尤大将亲临现场，给大家带来主题演讲，赶快点击链接抢票吧！</p>\n<h2>工具推荐</h2>\n<h4><a href=\"https://shipshapecode.github.io/shepherd/docs/welcome/\">Shepherd: Guide Your Users Through a Tour of Your App </a></h4>\n<p>Shepherd是一款便于我们为一款产品做新手指引的工具库，通过一些简单的api就可以实现该功能，目前对于Vue，React，Angular，Ember框架都有支持。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/276025/1556459532372-fce6df6c-b6b6-4813-9c48-6241afa2a824.gif#align=left&amp;display=inline&amp;height=772&amp;name=shepherd.gif&amp;originHeight=772&amp;originWidth=1342&amp;size=1438302&amp;status=done&amp;width=1342\" alt=\"shepherd.gif\"></p>\n<h4><a href=\"https://cloudconvert.com/\">CloudConvert: 文件格式在线转换平台</a></h4>\n<p>CloudConvert 是一款强大全能格式在线转换云在线应用，支持跨平台。 … 支持输入文件 URL、Dropbox、Google Drive 文件源或者直接从电脑上传文件进行转换，你只需要一个浏览器就可以使用它，非常方便。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/276025/1556507397357-85217ee1-c574-461f-b3df-71e088cf92fa.png#align=left&amp;display=inline&amp;height=1646&amp;name=image.png&amp;originHeight=1646&amp;originWidth=2878&amp;size=765280&amp;status=done&amp;width=2878\" alt=\"image.png\"></p>\n<h4><a href=\"https://github.com/vadimdemedes/ink\">Ink: 使用 React 编写命令行界面</a></h4>\n<p>Ink 是一款使用 React 风格开发命令行界面应用 (CLI App) 的 Nodejs 工具，也就是说，我们可以使用像 React 那样的方式来组织代码，开发出运行在命令行的工具应用。Ink 2.0 可以无缝支持 React 的某些特性，比如 Hooks 或Context，还可以与 React 生态系统中的其他重要组件（比如 Redux ）发生交互。&lt;br /&gt;官方文档提供了如下的示例：</p>\n<pre class=\"prettyprint language-jsx\"><code>import React, {Component} from &#x27;react&#x27;;\nimport {render, Color} from &#x27;ink&#x27;;\n \nclass Counter extends Component {\n  constructor() {\n    super();\n    this.state = {\n      i: 0\n    };\n  }\n \n  render() {\n    return (\n      &lt;Color green&gt;\n        {this.state.i} tests passed\n      &lt;&#x2F;Color&gt;\n    );\n  }\n \n  componentDidMount() {\n    this.timer = setInterval(() =&gt; {\n      this.setState({\n      i: this.state.i + 1\n      });\n    }, 100);\n  }\n \n  componentWillUnmount() {\n    clearInterval(this.timer);\n  }\n}\n \nrender(&lt;Counter&#x2F;&gt;);\n\n</code></pre><p>终端上的输出：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/svg/276025/1556507982379-0795e747-d6a0-4631-bda8-435fd2ab8e28.svg#align=left&amp;display=inline&amp;height=250&amp;originHeight=234&amp;originWidth=540&amp;status=done&amp;width=578\" alt></p>\n<h2>热门文章</h2>\n<h4><a href=\"https://zhuanlan.zhihu.com/p/61127760\">我在阿里云做前端</a></h4>\n<p>“抓住我们核心的竞争力，并同时发现业务中的问题，跨端推进解决，这是最好的出路。” 让我们看看阿里巴巴高级前端技术专家城池大大讲述他过去几年在阿里云的前端经验。</p>\n<h4><a href=\"https://www.infoq.cn/article/ENA6ooPYgt6*bZieWfCK\">Winter 眼中的前端十年：觉醒、全栈、包袱，未来无不可为</a></h4>\n<p>为什么他能在前端圈如鱼得水？为什么他总能拿到大公司的高薪 Offer？在他眼中：前端 Leader 都该焦虑什么？为什么过去十年是前端觉醒的十年？在杭州家里，本篇文章采访了本期嘉宾 Winter，听他讲述前端行业十年的得与失。</p>\n<h4><a href=\"https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247491022&amp;idx=1&amp;sn=0f080050f4bb7c3365d5cfbc1b70bea1&amp;chksm=f951a88dce26219bef53994b7608b21b298324f387863401dc2d7e09d13f56782659a1cfc552&amp;xtrack=1&amp;scene=0&amp;subscene=10000&amp;clicktime=1556444647&amp;ascene=7&amp;devicetype=android-28&amp;version=27000439&amp;nettype=WIFI&amp;abtest_cookie=BAABAAoACwASABMABQAjlx4AVpkeAMGZHgDZmR4A3JkeAAAA&amp;lang=zh_CN&amp;pass_ticket=6FpnjH0Xly5DJAnrxT8RH3mjz5WprMiG89TiVaWcA6eIM1QWBOVLN8KBvrCx5v52&amp;wx_header=1\">使用 Typescript 两年之后，它值得推荐吗</a></h4>\n<p>Typescript 近两年热度不减，很多大公司都选择去拥抱 TS，但它真的值得被推荐吗？本篇文章站在比较客观的角度从多方面讲述 TS 的优点和缺点。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/137059/1554173440911-9bd825a2-0664-4e96-b300-12a855a34e4a.png#align=left&amp;display=inline&amp;height=378&amp;name=image.png&amp;originHeight=1044&amp;originWidth=1080&amp;size=1149092&amp;status=done&amp;width=391\" alt=\"image.png\"></p>\n</div>","title":"您的四月份前端补给包已到，请查收～","last_reply_at":"2019-05-03T02:27:51.058Z","good":false,"top":false,"reply_count":3,"visit_count":1121,"create_at":"2019-04-30T08:04:47.449Z","author":{"loginname":"x-cold","avatar_url":"https://avatars1.githubusercontent.com/u/6903313?v=4&s=120"}},{"id":"5ccab35d05ae566f637fe26a","author_id":"58de5214b3e60b982d089dc3","tab":"ask","content":"<div class=\"markdown-text\"><p>因为egg-logger无法方便定制, 需要完全禁用.\n现在我要用的logger在egg中无法正常工作, 单独跑是ok的, 还没找到原因. 求助<a href=\"/user/atian25\">@atian25</a></p>\n<p>用以下代码段可以复现, 以下内容单独放个ts文件输出正常:</p>\n<pre class=\"prettyprint language-ts\"><code>import log4js from &#x27;log4js&#x27;\n\nconst logger = log4js.getLogger()\nlogger.level = &#x27;debug&#x27;\nlogger.debug(&#x27;=====================================&#x27;)\n\nconsole.log(&#x27;=====================================&#x27;)\t&#x2F;&#x2F; egg中仅此行输出\n</code></pre></div>","title":"如何完全禁用eggjs的egg-logger","last_reply_at":"2019-05-02T15:10:31.631Z","good":false,"top":false,"reply_count":3,"visit_count":403,"create_at":"2019-05-02T09:07:41.851Z","author":{"loginname":"xiaozhongliu","avatar_url":"https://avatars3.githubusercontent.com/u/17674404?v=4&s=120"}},{"id":"5c6d3191e1a81129a7ad8d2e","author_id":"5c4735a23b948a2b4ab70945","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FlPrSPQFN6_4OPWH9VXoom3pKToP\" alt=\"11111.jpg\">\n精英版8天nodejs培训视频教程，附带案例源码\n讲的很详细，分享出去，希望大家少走弯路，花更少的时间学习更多东西\n教程下载：<a href=\"https://www.sucaihuo.com/video/255.html\">https://www.sucaihuo.com/video/255.html</a></p>\n</div>","title":"精英版8天nodejs培训视频教程","last_reply_at":"2019-05-02T14:15:08.164Z","good":false,"top":false,"reply_count":3,"visit_count":1588,"create_at":"2019-02-20T10:53:05.469Z","author":{"loginname":"jtghaha","avatar_url":"https://avatars0.githubusercontent.com/u/46346950?v=4&s=120"}},{"id":"5cc8716d05ae566f637fe003","author_id":"5cc86a5c05ae566f637fdff4","tab":"share","content":"<div class=\"markdown-text\"><h2>项目主页</h2>\n<p><a href=\"https://github.com/xVanTuring/cquant\">CQuant：Async Node.js Color quantization Library</a></p>\n<h2>起因</h2>\n<p>5 年前 XadillaX 发布<a href=\"https://github.com/XadillaX/thmclrx\">thmclrx</a>,可用于提取图片的主色调。笔者原本准备使用其实现一些功能，却在安装上遇到了一些Node的版本问题。</p>\n<h2>造轮子</h2>\n<p>为了后续开发者的使用,安装方便，决定自己再造个轮子，于是就有了<a href=\"https://github.com/xVanTuring/cquant\">CQuant</a>库</p>\n<h3>预览</h3>\n<p><img src=\"https://s2.ax1x.com/2019/04/30/EGRnCF.png\" alt=\"Preview\"></p>\n<h3>优点</h3>\n<ul>\n<li>原生速度 ，(1920x1080的图片提取5色大约需要12ms)</li>\n<li>安装方便，提供Prebuild，无需C++开发工具</li>\n</ul>\n<h3>支持平台</h3>\n<p>Node.js： 6 | 8 | 10 | 11\nElectron: v3 and v4\nPlatform: Linux, Windows and macOs</p>\n<h3>所用算法</h3>\n<p>量化算法为MMCQ,算法参考自 <a href=\"http://www.leptonica.com/\">leptonica</a></p>\n<h2>Extra</h2>\n<p><a href=\"https://xvanturing.ml/\">个人主页</a>，偶尔会分享一些前端框架分析和一些乱七八糟的东西.</p>\n</div>","title":"CQuant:基于N-api的图片主色调提取库","last_reply_at":"2019-05-02T13:52:31.351Z","good":false,"top":false,"reply_count":2,"visit_count":419,"create_at":"2019-04-30T16:01:49.798Z","author":{"loginname":"xVanTuring","avatar_url":"https://avatars0.githubusercontent.com/u/11146248?v=4&s=120"}},{"id":"5cc8133fa86ae80ce64b5c58","author_id":"5cc812bba86ae80ce64b5c52","tab":"ask","content":"<div class=\"markdown-text\"><p>我从tcp消息实时抓取一些二进制byte消息流  按行存在一个文件里\n然后我想用nodejs按行读取  有什么办法么\n或者用什么方式存 能让nodejs按消息流来获取呀</p>\n</div>","title":"tcp数据流实时存放到文件中 有办法按包读取么 各位大佬 我该怎么存","last_reply_at":"2019-05-01T12:44:56.085Z","good":false,"top":false,"reply_count":3,"visit_count":496,"create_at":"2019-04-30T09:19:59.433Z","author":{"loginname":"cuijianxiong","avatar_url":"https://avatars1.githubusercontent.com/u/19885418?v=4&s=120"}},{"id":"5cc96110a86ae80ce64b5de3","author_id":"55c56e8a39273b9219336288","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://oo.t9t.io/jobs\">https://oo.t9t.io/jobs</a></p>\n<p><img src=\"https://l.ruby-china.com/photo/2019/c4b4f081-df4d-4448-be19-0c1dc357a404.png!large\" alt></p>\n<p><img src=\"https://l.ruby-china.com/photo/2019/16cabc06-688d-4abb-ad24-4ec839bb07ad.png!large\" alt></p>\n</div>","title":"有没有想过找一份为开源项目做贡献的工作, 我做了一个网站收集这类工作机会. 欢迎大家注册试用","last_reply_at":"2019-05-01T09:04:16.770Z","good":false,"top":false,"reply_count":0,"visit_count":446,"create_at":"2019-05-01T09:04:16.770Z","author":{"loginname":"timqian","avatar_url":"https://avatars3.githubusercontent.com/u/5512552?v=4&s=120"}},{"id":"5cc12d4537faec0ce1d06706","author_id":"5875bd3d06fa6e2a4e4f730b","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FsJPVoGNLeApbuZx9lRwmcv4LCfm\" alt=\"image.png\">\n前一秒还在劝人学node，后一秒就被打脸了。。。羞愧难当。。。顿时找不到理由反驳。</p>\n</div>","title":"一位同学因别人说node只适合中小型，放弃node学go,大家怎么看。","last_reply_at":"2019-05-01T04:57:29.886Z","good":false,"top":false,"reply_count":33,"visit_count":2734,"create_at":"2019-04-25T03:45:09.872Z","author":{"loginname":"zy445566","avatar_url":"https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"}},{"id":"5bb3199aede204052db80345","author_id":"5b9e04448f5b0c1c59ea0e80","tab":"ask","content":"<div class=\"markdown-text\"><p>如题，刚刚在论坛里面专门找了一下，最近的一次询问是三个月前的（<a href=\"https://cnodejs.org/topic/5b2f02a757137f22415c4e90\">传送门</a>此前帖子），真的好期待啊……</p>\n</div>","title":"又3个月了，狼叔的《更了不起的Node.js》应该快出来了吧？","last_reply_at":"2019-05-01T03:58:53.109Z","good":false,"top":false,"reply_count":42,"visit_count":6719,"create_at":"2018-10-02T07:09:14.001Z","author":{"loginname":"tufifth","avatar_url":"https://avatars0.githubusercontent.com/u/34742669?v=4&s=120"}},{"id":"5cc7e85ba86ae80ce64b5abf","author_id":"59b0fced1b37e54f6793c3d6","tab":"ask","content":"<div class=\"markdown-text\"><blockquote>\n<p>NODE应用CPU使用率过高，可能是PM2引起的吗？</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/Fvc8CSyBAJL_0Rq1ell2PG_Rduoz\" alt=\"image.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtbXd7XgTpM7u6uC2cYtEqBc1lHC\" alt=\"image.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fi7yuFoGBlqw5X5Ip27J63MbDIoz\" alt=\"image.png\"></p>\n<pre class=\"prettyprint\"><code>1、app使用pm2启动，默认两个负载是上图中的&#96;node &#x2F;mnt&#x2F;pgyer&#96;\n2、app运行一段时间，比如压力测试、并发测试过程中&#96;node &#x2F;mnt&#x2F;pgyer&#96;的进程会升高，停止压测、并发测试之后对应的CPU也会降下来。反复持续一段时间之后，&#96;node&#96;进程出现，并且CPU持续变高，一直达到&#96;110%+&#96;。整个机器的CPU使用率达到了&#96;60%&#96;左右，除非杀掉&#96;node&#96;进程才会恢复正常；图2是站点不做任何访问CPU使用率的截图，还是依然如此之高。\n3、使用传统的方式&#96;node .&#x2F;app.js&#96;的方式启动一个进程，压测、并发测试等等，CPU使用率会上升但是随着压测、并发测试的结束，CPU使用率也会相应的降下来。反复几次也都是正常的。\n4、我怀疑是不是PM2使用不当呢。\n\n</code></pre></div>","title":"PM2 node进程 CPU达到116%+（帮我解决问题给红包感谢！！！）","last_reply_at":"2019-04-30T08:53:32.687Z","good":false,"top":false,"reply_count":4,"visit_count":722,"create_at":"2019-04-30T06:16:59.383Z","author":{"loginname":"xulayen","avatar_url":"https://avatars1.githubusercontent.com/u/15044564?v=4&s=120"}},{"id":"5cc6ccada86ae80ce64b5695","author_id":"55125bccd792542a29789aee","tab":"ask","content":"<div class=\"markdown-text\"><p>目前我们有一个邮件服务器搭建的需求，需要能够通过接口在项目中给用户自动生成邮箱，且希望能够有搭建邮件服务器的源码和教程。有偿求搭建。\n可以搭建这个项目的，可以在后面留言，谢谢！</p>\n</div>","title":"关于如何搭建邮件服务器，有偿","last_reply_at":"2019-04-30T07:38:07.296Z","good":false,"top":false,"reply_count":1,"visit_count":560,"create_at":"2019-04-29T10:06:37.230Z","author":{"loginname":"myadmin","avatar_url":"https://avatars2.githubusercontent.com/u/6794499?v=4&s=120"}},{"id":"5cc7c342a86ae80ce64b5a18","author_id":"54582a566537f4d52c414e41","tab":"ask","content":"<div class=\"markdown-text\"><p>koa+sequelize 间歇性的报超时，我该从何处着手开始排查 SequelizeConnectionError: connect ETIMEDOUT</p>\n<p>啥叫间歇性：就是每天总报三四个这样的错误，请求就500了，但是程序也没重启，其他请求都好好的。</p>\n<p>连接配置\n&quot;teacher&quot;: {\n\t\t“db”: {\n\t\t\t“logging”: false,\n\t\t\t“username”: “prod”,\n\t\t\t“password”: “xxxxxxxxxxxx”,\n\t\t\t“dialect”: “mysql”,\n\t\t\t“database”: “teacher”,\n\t\t\t“host”: “xxxxxxxxxxxx”,\n\t\t\t“port”: “3306”,\n\t\t\t“operatorsAliases”: true,\n\t\t\t“define”: {\n\t\t\t\t“freezeTableName”: true,\n\t\t\t\t“paranoid”: true\n\t\t\t},\n\t\t\t“pool”: {\n\t\t\t\t“max”: 30,\n\t\t\t\t“min”: 0,\n\t\t\t\t“acquire”: 10000,\n\t\t\t\t“idle”: 10000\n\t\t\t}\n\t\t}\n\t}</p>\n</div>","title":"koa+sequelize 间歇性的报超时，我该从何处着手开始排查 SequelizeConnectionError: connect ETIMEDOUT","last_reply_at":"2019-04-30T06:15:32.986Z","good":false,"top":false,"reply_count":2,"visit_count":366,"create_at":"2019-04-30T03:38:42.483Z","author":{"loginname":"wxsong","avatar_url":"https://avatars1.githubusercontent.com/u/8464014?v=4&s=120"}},{"id":"5cc7b20305ae566f637fdc00","author_id":"577f0e4369d72f545483ca04","tab":"ask","content":"<div class=\"markdown-text\"><h2><img src=\"//static.cnodejs.org/FsbCoWFofHWrxmOPh3cbTAikwu34\" alt=\"image.png\">\nnode版本：\n升级前：v11.2.~\n升级后：v12.0.0\n也将npm升级到最新版本。\n目前运行项目就报这个问题。\n试过重新 <em>create-react-app</em> ，运行时也同样报错，如图**\n<img src=\"//static.cnodejs.org/FpzXYklX2yVnEWsfvKb8I3SEZHx-\" alt=\"image.png\">\n遇到这种问题，怎么处理？</h2>\n<p>补充内容：\n<em>Error: fsevents is not a constructor</em>这个我百度了，解决方案是卸载再升级truffle，试了，结果跟第二个图一样。**</p>\n</div>","title":"react项目，升级node版本后，运行yarn start报错","last_reply_at":"2019-04-30T03:16:11.448Z","good":false,"top":false,"reply_count":4,"visit_count":386,"create_at":"2019-04-30T02:25:07.751Z","author":{"loginname":"imizao","avatar_url":"https://avatars1.githubusercontent.com/u/20340304?v=4&s=120"}},{"id":"5cc6ced2a86ae80ce64b56a7","author_id":"58cb34c8246a2aeb194a5489","tab":"share","content":"<div class=\"markdown-text\"><p>你有没有过这样一个经历，一个项目立项之时，什么模块化啊，什么抽象啊，什么解耦啊，什么可复用组件啊什么的，哪个高端用哪个，可是项目发展到中期，随着模块的增加，什么可复用，能用就行，什么模块化，载入就行，久而久之，项目越来越大，随之也越来越臃肿，越来越难以维护，改一处看似简单的模块，却发现八杆子打不着的地方居然也被影响了，真真是写时一时爽，维护时更加爽！</p>\n<p>那项目大了，维护成了难题，如何优化呢，怎么解决呢！</p>\n<h3>IOC (InversionofControl 控制反转)</h3>\n<p>看英文缩写，是不是有点高大上，其实这个理念在后端是非常常见的，而前端很少涉及到。不过现代前端也可以在项目中实践了，而且很契合。</p>\n<h4>三个准则</h4>\n<ul>\n<li>高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象</li>\n<li>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</li>\n<li>面向接口编程而不是面向实现编程</li>\n</ul>\n<h4>一个案例</h4>\n<p>放着这些个准则不说，先用一个案例来说明下：</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; screen.ts\nexport default class Screen {\n  name = &quot;Retina&quot;;\n}\n\n&#x2F;&#x2F; cpu.ts\nexport default class Cpu {\n  name = &quot;i5&quot;;\n}\n\n&#x2F;&#x2F; battery\n&#x2F;&#x2F; 电池模式，普通模式，低电量，高电量\ntype TMode = &quot;normal&quot; | &quot;low&quot; | &quot;high&quot;;\nexport default class Battery {\n  mode: string;\n  constructor(option: { mode: TMode } = { mode: &quot;normal&quot; }) {\n    this.mode = option.mode;\n  }\n}\n\n\n&#x2F;&#x2F; mac.ts\n\nimport Screen from &quot;.&#x2F;screen&quot;;\nimport Cpu from &quot;.&#x2F;cpu&quot;;\nimport Battery from &quot;.&#x2F;battery&quot;;\n\nexport default class MacBook {\n  cpu: Cpu;\n  screen: Screen;\n  battery: Battery;\n  constructor() {\n    this.cpu = new Cpu();\n    this.screen = new Screen();\n    this.battery = new Battery();\n  }\n  start() {\n    console.log(\n      &#96;your mac screen is battery mode is ${this.battery.mode}, screen is ${\n        this.screen.name\n      } and cpu is ${this.cpu.name}&#96;\n    );\n  }\n}\n\n\n&#x2F;&#x2F; index.ts\n\nimport MacBook from &quot;.&#x2F;mac&quot;;\n\nlet mac = new MacBook();\n\nmac.start();\n</code></pre><p>首先建立一个<code>index.ts</code>启动文件，mac壳子 <code>mac.ts</code>，它内部有三个模块，<code>cpu</code> ，<code>screen</code> 和 <code>battery</code> ，这个三个属性分别引用的是文件外的模块。</p>\n<p>代码这样写，其实没有什么问题的，执行 <code>index</code> 就能看到结果，查看到这个mac类的配置，那么，如果说我要设置mac电池配置 <code>mode</code> 为低电量，那么我就不得不去 <code>mac.ts</code> 主模块里修改电池的配置。</p>\n<pre class=\"prettyprint language-js\"><code>this.battery = new Battery({mode: &quot;low&quot;});\n</code></pre><p>这样改，其实是没有什么问题的，但是，mac其中的一个模块修改了，为什么壳子 <code>mac.ts</code> 这个文件也要跟着懂呢，而且这个壳子里有mac所有的模块依赖，之前测试通过了，这次修改了，能不能保证一定没有出错呢，所以这次的模块改动就是我上面说到的问题，那如何改动呢？</p>\n<h4>第一次优化</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; mac.ts\n\nimport Screen from &quot;.&#x2F;screen&quot;;\nimport Cpu from &quot;.&#x2F;cpu&quot;;\nimport Battery from &quot;.&#x2F;battery&quot;;\n\ninterface IMac {\n  cpu: Cpu;\n  screen: Screen;\n  battery: Battery;\n}\n\nexport default class MacBook {\n  cpu: Cpu;\n  screen: Screen;\n  battery: Battery;\n  constructor(option: IMac) {\n    this.cpu = option.cpu;\n    this.screen = option.screen;\n    this.battery = option.battery;\n  }\n  start() {\n    console.log(\n      &#96;your mac screen is battery mode is ${this.battery.mode}, screen is ${\n        this.screen.name\n      } and cpu is ${this.cpu.name}&#96;\n    );\n  }\n}\n\n\n&#x2F;&#x2F; index.ts\n\nimport MacBook from &quot;.&#x2F;mac&quot;;\nimport Battery from &quot;.&#x2F;battery&quot;;\nimport Cpu from &quot;.&#x2F;cpu&quot;;\nimport Screen from &quot;.&#x2F;screen&quot;;\n\nlet mac = new MacBook({\n  cpu: new Cpu(),\n  screen: new Screen(),\n  battery: new Battery()\n});\n\nmac.start();\n\n</code></pre><p>将模块的依赖全都放在了启动文件 <code>index.ts</code> 处，无论模块如何改动，壳子模块 <code>mac.ts</code> 是不是都不用改了，模块之间的耦合度也降低了。</p>\n<p>简单来说，<code>mac.ts</code> 是高层模块，<code>battery.ts</code> 是底层模块，优化之前 <code>mac.ts</code> 依赖了 <code>battery.ts</code> ，是不是违背了 <code>IOC</code> 的第一条准则呢，优化后的代码是将高层次的模块所需要的依赖通过参数传递到模块内部，这个方法有一个专业术语 - 依赖注入（Dependency Injection）。</p>\n<p><strong>所需要传入的参数类型 <code>IMac</code> 就是所定义的抽象，壳子模块 <code>mac.ts</code> 就是依赖了这个抽象，而这个抽象也没有依赖于某个具体的实现。</strong></p>\n<p>那么问题又来了，如果我想给这个mac实例再增加一个触摸板模块 <code>touchpad.ts</code> 呢，是不是又要修改壳子模块 <code>mac.ts</code> 了，难道新增一个就要修改一次，就没有一个通用方案么？</p>\n<h4>案例再次优化</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; mac.ts\n\ntype IModule&lt;T&gt; = T | T[];\n\nexport default class MacBook {\n  private modules: any[];\n\n  use&lt;T&gt;(module: IModule&lt;T&gt;) {\n    Array.isArray(module)\n      ? module.map(item =&gt; this.use(item))\n      : this.modules.push(module);\n    return this;\n  }\n\n  start() {\n    console.log(this.modules);\n  }\n}\n\n\n&#x2F;&#x2F; index.ts\n\nimport MacBook from &quot;.&#x2F;mac&quot;;\nimport Battery from &quot;.&#x2F;battery&quot;;\nimport Cpu from &quot;.&#x2F;cpu&quot;;\nimport Screen from &quot;.&#x2F;screen&quot;;\nimport Touchpad from &quot;.&#x2F;touchpad&quot;;\n\nlet mac = new MacBook();\n\nmac\n  .use(new Cpu())\n  .use(new Screen())\n  .use([new Battery({mode: &quot;high&quot;}), new Touchpad()])\n  .start();\n\n</code></pre><p>模仿 <code>koa</code> 载入模块的 <code>use</code> 方法，可以链式，这样壳子模块 <code>mac.ts</code> 就完全与低层次模块解藕了，无论mac新增多少个模块它都不会发生修改。<code>mac.ts</code> 内部已经看不到什么业务代码了，所有的配置都放在了最外层，即便修改添加也及其方便。</p>\n<p>那么问题又来了，<code>mac.ts</code> 对模块可是有要求的，不是任何一个牌子的模块就能安装到我的mac上，得按照一定的标准是执行，也就是依照一定的 <strong>约定</strong>，这也就是第三个准册，面向接口编程而不是面向实现编程，下面就用代码来展示这个准则：</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; mac.ts\ntype IModule&lt;T&gt; = T | T[];\n\nexport default class MacBook {\n  private modules: any[] = [];\n\n  use&lt;T&gt;(module: IModule&lt;T&gt;) {\n    Array.isArray(module)\n      ? module.map(item =&gt; this.use(item))\n      : this.modules.push(module);\n    return this;\n  }\n\n  start() {\n    this.modules.map(\n      module =&gt;\n        module.init &amp;&amp; typeof module.init === &quot;function&quot; &amp;&amp; module.init()\n    );\n  }\n}\n\n</code></pre><p>在 <code>mac.ts</code> 的启动方法中，我们看到了，对接的模块内部，一定要有一个 <code>init</code> 属性，且这个属性一定是一个可执行方法，那么所对接的模块要如何处理呢：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; cpu.ts\nexport default class Cpu {\n  name = &quot;i5&quot;;\n  init() {\n    console.log(&#96;${this.name} start&#96;);\n  }\n}\n</code></pre><p>类似于这样的，要对接这个壳子，就必须在模块内部实现一个<code>init</code>方法，这样这个模块才能在壳子内部起作用。</p>\n<p><code>init</code> 方法对于 <code>mac.ts</code> 来说，只是一个抽象方法，一个约定的接口，将实现交给了所来对接的各个模块，这不就是 <strong>面向接口编程 而不要面向实现编程</strong> 最好的诠释么！</p>\n<h3>总结</h3>\n<p>其实在 <code>IOC</code> 的术语中，<code>mac.ts</code> 更应该称作为 <strong>容器(Container)</strong> ，上面称它为壳子比较贴近现实好理解，它跟业务实现其实没有太大的关联，仅仅是做一些初始化的操作，所以壳子不应该随着它所依赖的模块的改变也跟着改变。\n所以就需要一种 <code>IOC</code> 的编程思想去优化它，依赖注入只是这种思想的一种实现。</p>\n<p><strong>最后说一句，思想才是提高编程的最佳手段，而不是学习怎么用框架！</strong>\n<a href=\"https://github.com/soraping/any-source/issues/14\">原文地址</a></p>\n</div>","title":"前端 ioc 思想的简单实践","last_reply_at":"2019-04-30T03:14:59.194Z","good":false,"top":false,"reply_count":6,"visit_count":559,"create_at":"2019-04-29T10:15:46.638Z","author":{"loginname":"soraping","avatar_url":"https://avatars2.githubusercontent.com/u/8610213?v=4&s=120"}},{"id":"5cc7a5b105ae566f637fdb7c","author_id":"4f447c2f0a8abae26e01b27d","tab":"share","content":"<div class=\"markdown-text\"><p>也同时为你自己点一盏吧。</p>\n<p><img src=\"//static.cnodejs.org/FpuVWnMEZCdsXegOzWSc2gspjZfR\" alt=\"image.png\"></p>\n<p><img src=\"//static.cnodejs.org/FoL-cKZf0PuoPBSFIzpIbCIEr_Rt\" alt=\"image.png\"></p>\n</div>","title":"如果你还有 Node 6.x 的项目，请珍惜它，因为今天是 LastDay 了，请点灯 🕯🕯","last_reply_at":"2019-04-30T02:08:36.954Z","good":false,"top":false,"reply_count":2,"visit_count":633,"create_at":"2019-04-30T01:32:33.257Z","author":{"loginname":"atian25","avatar_url":"https://avatars2.githubusercontent.com/u/227713?v=4&s=120"}},{"id":"5cc6b931a86ae80ce64b560a","author_id":"5a1067384f0d21491dd96078","tab":"ask","content":"<div class=\"markdown-text\"><p>经常看到社区的文章里都配有动图，很直观，请问大家都是如何制作的，有没有好用的工具推荐(●’◡’●)</p>\n</div>","title":"gif图片制作问题","last_reply_at":"2019-04-30T02:02:20.292Z","good":false,"top":false,"reply_count":3,"visit_count":461,"create_at":"2019-04-29T08:43:29.439Z","author":{"loginname":"lucky-leaf","avatar_url":"https://avatars1.githubusercontent.com/u/31915733?v=4&s=120"}},{"id":"5cc79f6805ae566f637fdb27","author_id":"5922ddb7d371b6372a8afc55","tab":"share","content":"<div class=\"markdown-text\"><p>该文为node.js官网关于对http请求处理流程的文档翻译，本身并无复杂和难以理解的地方\n<a href=\"https://nodejs.org/en/docs/guides/anatomy-of-an-http-transaction/\">原文地址</a></p>\n<p>未完待续</p>\n</div>","title":"node.js对http请求处理过程剖析","last_reply_at":"2019-04-30T01:05:44.256Z","good":false,"top":false,"reply_count":0,"visit_count":501,"create_at":"2019-04-30T01:05:44.256Z","author":{"loginname":"hackboy","avatar_url":"https://avatars1.githubusercontent.com/u/7553085?v=4&s=120"}},{"id":"5cc7029e05ae566f637fda75","author_id":"5b2a0c5029e6e510415b2c0f","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FpgWVIewzo7AWbwOL_TfmEYMYo6g\" alt></p>\n<p><strong>其中一些课程:</strong>\n[dojo中国]ExtJs视频教程\n[极客]Node.js视频教程\n[捷训]Node.js视频教程 12集\n[麦子]Node.js + Web Socket 打造即时聊天程序\n[麦子]玩转NodeJS全栈开发之博客系统\n[实战]Vue.js+Node.js实战音乐播放器\nJade即学即用\nmongodb基础入门实例教程\nMongoDB视频教程\nnode.js+Mongo+ExtJS4.1（20集）\nnode.js从入门到实战教育项目\nNode.JS基础教程\nNode.js开发公众号实战视频\nNode.JS全栈工程师系列课程\nNodejs&amp;Express 讲座\n教程下载：<a href=\"https://www.sucaihuo.com/video/152.html\">https://www.sucaihuo.com/video/152.html</a></p>\n</div>","title":"nodejs众多培训机构视频教程集合","last_reply_at":"2019-04-29T13:56:46.685Z","good":false,"top":false,"reply_count":0,"visit_count":420,"create_at":"2019-04-29T13:56:46.685Z","author":{"loginname":"whoknowme","avatar_url":"https://avatars0.githubusercontent.com/u/40422811?v=4&s=120"}},{"id":"5ab3166be7b166bb7b9eccf7","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><h1>说明</h1>\n<p>2017-12-14 我发了一篇文章《没用过Node.js，就别瞎逼逼》是因为有人在知乎上黑Node.js。那篇文章的反响还是相当不错的，甚至连著名的hax贺老都很认同，下班时读那篇文章，竟然坐车的还坐过站了。大家可以很明显的感到Node.js的普及度还不够，还存很多误解。甚至说很多小白用户也得不到很好的学习。大神都功成身退，书也跟不上，大部分都是2013年左右的，Node.js版本都是基于v0.10左右的，现在已经v9了。想想也是有点可惜，使用如此广泛的Node.js被大家默认，却没人来科普。</p>\n<p>反思之后，我就想准备一个科普的Live，于是就有了《狼叔：如何正确学习 Node.js？》，相信能够对很多喜欢Node.js的朋友有所帮助。Live已完成目前1200多人，230人评价，平均4.8+，还算是一个比较成功的Live。现整理出来，希望对更多朋友有用。</p>\n<ul>\n<li>感谢 <a href=\"/user/justjavac\">@justjavac</a> 大神的<a href=\"https://github.com/justjavac/free-programming-books-zh_CN/#%E7%BD%AE%E9%A1%B6\"> 免费的计算机编程类中文书籍</a> 收录并推荐</li>\n<li><a href=\"https://github.com/i5ting/How-to-learn-node-correctly\">github地址，以后在仓库里更新</a></li>\n<li><a href=\"https://www.zhihu.com/lives/928687583372926976\">Live地址，声音版</a></li>\n</ul>\n<h1>【全文】狼叔：如何正确的学习Node.js</h1>\n<p>Live 简介</p>\n<p>现在，越来越多的科技公司和开发者开始使用 Node.js 开发各种应用。Node.js除了能够辅助大前端开发外，还可以编写Web应用，封装Api，组装RPC服务等，甚至是开发VSCode编辑器一样的PC客户端。和其它技术相比， Node.js 简单易学，性能好、部署容易，能够轻松处理高并发场景下的大量服务器请求。Node.js 周边的生态也非常强大，NPM（Node包管理）上有超过60万个模块，日下超过载量3亿次。但编写 Node.js 代码对新人和其它语言背景的开发者来说，不是一件容易的事，在入门之前需要弄懂不少复杂的概念。</p>\n<p>我身边也有很多人问我：如何学习 Node.js ？作为一名 Node.js 布道者，我做过很多 Node.js 普及和推广的工作，对它的基本概念和核心模块都很熟悉； 此外，我还在撰写一本名为《更了不起的 Node.js 》的书，已经写了 2 年，积累了很丰富的资料，本次 Live 也将为你提供对 Node.js 更全面的解读。</p>\n<p>本次 Live 主要包括以下内容，目录</p>\n<p>Part 0 ：Node.js简介</p>\n<p>a）Node.js简介\nb）什么是Node.js？\nc）基本原理</p>\n<p>Part 1前言：学习 Node.js 的三个境界</p>\n<p>Part 2准备：如何学习Node.js</p>\n<ul>\n<li>2.1 Node 用途那么多，我该从哪里学起？</li>\n<li>2.2 Node Web 框架那么多，我该怎么选？</li>\n<li>2.3 关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n<p>Part 3延伸：大前端变化那么快，如何才能做到每日精进？</p>\n<p>Part 4实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</p>\n<p>Part 5答疑：回答大家的问题</p>\n<p>本次Live主要是科普，适用新用户和比较迷茫的Node朋友，希望大家多多理解和支持。</p>\n<h2>Part 0 ：Node.js简介</h2>\n<p>a）Node.js简介\nb）什么是Node.js？\nc）基本原理</p>\n<h3>a）Node.js简介</h3>\n<p>Node.js 诞生于 2009 年，由 Joyent 的员工 <a href=\"https://github.com/ry\">Ryan Dahl</a> 开发而成，之后 Joyent 公司一直扮演着 Node.js 孵化者的角色。由于诸多原因，Ryan 在2012年离开社区，随后在2015年由于 Node 贡献者对 es6 新特性集成问题的分歧，导致分裂出iojs，并由 iojs 发布1.0、2.0和3.0版本。由于 iojs 的分裂最终促成了2015年Node基金会的成立，并顺利发布了4.0版本。Node.js基金会的创始成员包括 Google、Joyent、IBM、Paypal、微软、Fidelity 和 Linux基金会，创始成员将共同掌管过去由 Joyent 一家企业掌控的 Node.js 开源项目。此后，Node.js基金会发展非常好，稳定的发布5、6、7、8等版本，截止发稿最新版本已经是8.6，长期支持版本是6.11。</p>\n<p>Node.js 不是一门语言也不是框架，它只是基于 Google V8 引擎的 JavaScript 运行时环境，同时结合 Libuv 扩展了 JavaScript 功能，使之支持 io、fs 等只有语言才有的特性，使得 JavaScript 能够同时具有 DOM 操作(浏览器)和 I/O、文件读写、操作数据库(服务器端)等能力，是目前最简单的全栈式语言。</p>\n<p>早在2007年，Jeff Atwood 就提出了著名的 <code>Atwood定律</code></p>\n<blockquote>\n<p>任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现</p>\n</blockquote>\n<p>目前 Node.js 在大部分领域都占有一席之地，尤其是 I/O 密集型的，比如 Web 开发，微服务，前端构建等。不少大型网站都是使用 Node.js 作为后台开发语言的，用的最多的就是使用Node.js做前端渲染和架构优化，比如 <a href=\"https://www.taobao.com/\">淘宝</a> 双十一、<a href=\"https://www.qunar.com/\">去哪儿网</a> 的 PC 端核心业务等。另外，有不少知名的前端库也是使用 Node.js 开发的，比如，<a href=\"https://github.com/webpack/webpack\">Webpack</a> 是一个强大的打包器，<a href=\"https://github.com/facebook/react\">React</a>/<a href=\"https://github.com/vuejs/vue\">Vue</a> 是成熟的前端组件化框架。</p>\n<p>Node.js通常被用来开发低延迟的网络应用，也就是那些需要在服务器端环境和前端实时收集和交换数据的应用（API、即时聊天、微服务）。阿里巴巴、腾讯、Qunar、百度、PayPal、道琼斯、沃尔玛和 LinkedIn 都采用了 Node.js 框架搭建应用。</p>\n<p>另外， Node.js 编写的包管理器 npm 已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。</p>\n<p>当然了，Node.js 也有一些缺点。Node.js 经常被人们吐槽的一点就是：回调太多难于控制（俗称回调地狱）和 CPU 密集任务处理的不是很好。但是，目前异步流程技术已经取得了非常不错的进步，从Callback、Promise 到 Async函数，可以轻松的满足所有开发需求。至于 CPU 密集任务处理并非不可解，方案有很多，比如通过系统底层语言 Rust 来扩展 Node.js，但这样会比较麻烦。笔者坚信在合适的场景使用合适的东西，尤其是在微服务架构下，一切都是服务，可以做到语言无关。如果大家想使 JavaScript 做 CPU 密集任务，推荐 Node.js 的兄弟项目 <a href=\"http://fibjs.org/\">fibjs</a>，基于纤程(fiber，可以简单理解为更轻量级的线程)，效率非常高，兼容npm，同时没有异步回调烦恼。</p>\n<h3>b）什么是Node.js？</h3>\n<p>按照 <a href=\"https://nodejs.org/en/\">Node.js官方网站主页</a> 的说法:</p>\n<pre class=\"prettyprint\"><code>Node.js® is a JavaScript runtime built on Chrome&#x27;s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I&#x2F;O model that makes it lightweight and efficient. Node.js&#x27; package ecosystem, npm, is the largest ecosystem of open source libraries in the world.\n</code></pre><p>从这段介绍来看，解读要点如下</p>\n<ul>\n<li>Node.js 不是 JavaScript 应用，不是语言（JavaScript 是语言），不是像 Rails(Ruby)、 Laravel(PHP) 或 Django(Python) 一样的框架，也不是像 Nginx 一样的 Web 服务器。Node.js 是 JavaScript 运行时环境</li>\n<li>构建在 Chrome’s V8 这个著名的 JavaScript 引擎之上，Chrome V8 引擎以 C/C++ 为主，相当于使用JavaScript 写法，转成 C/C++ 调用，大大的降低了学习成本</li>\n<li>事件驱动（event-driven），非阻塞 I/O 模型（non-blocking I/O model），简单点讲就是每个函数都是异步的，最后由 Libuv 这个 C/C++ 编写的事件循环处理库来处理这些 I/O 操作，隐藏了非阻塞 I/O 的具体细节，简化并发编程模型，让你可以轻松的编写高性能的Web应用，所以它是轻量（lightweight）且高效（efficient）的</li>\n<li>使用 <code>npm</code> 作为包管理器，目前 <code>npm</code> 是开源库里包管理最大的生态，功能强大，截止到2017年12月，模块数量超过 60 万+</li>\n</ul>\n<p>大多数人都认为 Node.js 只能写网站后台或者前端工具，这其实是不全面的，Node.js的目标是让并发编程更简单，主要应用在以网络编程为主的 I/O 密集型应用。它是开源的，跨平台，并且高效（尤其是I/O处理），包括IBM、Microsoft、Yahoo、SAP、PayPal、沃尔玛及GoDaddy都是 Node.js 的用户。</p>\n<h3>c）基本原理</h3>\n<p>下面是一张 Node.js 早期的架构图，来自 Node.js 之父 Ryan Dahl 的演讲稿，在今天依然不过时，它简要的介绍了 Node.js 是基于 Chrome V8引擎构建的，由事件循环（Event Loop）分发 I/O 任务，最终工作线程（Work Thread）将任务丢到线程池（Thread Pool）里去执行，而事件循环只要等待执行结果就可以了。</p>\n<p><img src=\"//static.cnodejs.org/Fh2MIT1r4YStGl9ZEEzt7N4lEbqX\" alt=\"14912763353044.png\"></p>\n<p>核心概念</p>\n<ul>\n<li>Chrome V8 是 Google 发布的开源 JavaScript 引擎，采用 C/C++ 编写，在 Google 的 <code>Chrome</code> 浏览器中被使用。Chrome V8 引擎可以独立运行，也可以用来嵌入到 C/C++ 应用程序中执行。</li>\n<li>Event Loop 事件循环（由 <code>libuv</code> 提供）</li>\n<li>Thread Pool 线程池（由 <code>libuv</code> 提供）</li>\n</ul>\n<p>梳理一下</p>\n<ul>\n<li>Chrome V8 是 JavaScript 引擎</li>\n<li>Node.js 内置 Chrome V8 引擎，所以它使用的 JavaScript 语法</li>\n<li>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事</li>\n<li>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</li>\n<li>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 I/O 很慢，不得不等着结果出来，再往下执行</li>\n<li>CPU 完全可以不管 I/O 设备，挂起处于等待中的任务，先运行排在后面的任务</li>\n<li>将等待中的 I/O 任务放到 Event Loop 里</li>\n<li>由 Event Loop 将 I/O 任务放到线程池里</li>\n<li>只要有资源，就尽力执行</li>\n</ul>\n<p>我们再换一个维度看一下</p>\n<p><img src=\"//static.cnodejs.org/FkTMjCoX4xyL0rJtmm7oBc6V0i8W\" alt=\"14992384974942.png\"></p>\n<p>核心</p>\n<ul>\n<li>Chrome V8 解释并执行 JavaScript 代码（这就是为什么浏览器能执行 JavaScript 原因）</li>\n<li><code>libuv</code> 由事件循环和线程池组成，负责所有 I/O 任务的分发与执行</li>\n</ul>\n<p>在解决并发问题上，异步是最好的解决方案，可以拿排队和叫号机来理解</p>\n<ul>\n<li>排队：在排队的时候，你除了等之外什么都干不了</li>\n<li>叫号机：你要做的是先取号码，等轮到你的时候，系统会通知你，这中间，你可以做任何你想做的事儿</li>\n</ul>\n<p>Node.js 其实就是帮我们构建类似的机制。我们在写代码的时候，实际上就是取号的过程，由 Event Loop 来接受处理，而真正执行操作的是具体的线程池里的 I/O 任务。之所以说 Node.js 是单线程，就是因为在接受任务的时候是单线程的，它无需进程/线程切换上下文的成本，非常高效，但它在执行具体任务的时候是多线程的。</p>\n<p>Node.js 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”，毫无疑问，它确实做到了。这种做法将并发编程模型简化了，Event Loop和具体线程池等细节被 Node.js 封装了，继而将异步调用 Api 写法暴露给开发者。真是福祸相依，一方面简化了并发编程，另一方面在写法上埋下了祸根，这种做法的好处是能让更多人轻而易举的写出高性能的程序！</p>\n<p>在Node.js Bindings层做的事儿就是将 Chrome V8 等暴露的 <code>C/C++</code> 接口转成JavaScript Api，并且结合这些 Api 编写了 Node.js 标准库，所有这些 Api 统称为 Node.js SDK，后面模块章节会有更详细的讨论。</p>\n<p>微软在2016年宣布在MIT许可协议下开放 Chakra 引擎，并以 <code>ChakraCore</code> 为名在 Github 上开放了源代码，<code>ChakraCore</code> 是一个完整的 JavaScript 虚拟机，它拥有着和 <code>Chakra</code> 几乎相同的功能与特性。微软向 Node.js 主分支提交代码合并请求，让 Node.js 用上 <code>ChakraCore</code>引擎，即 <a href=\"https://github.com/nodejs/node-chakracore\">nodejs/node-chakracore</a> 项目。实际上微软是通过创建名为 <code>V8 shim</code> 的库的赋予了 <code>ChakraCore</code> 处理谷歌 Chrome V8 引擎指令的能力，其原理示意图如下</p>\n<p><img src=\"//static.cnodejs.org/FmJWcazPP4smFeEzBnfnEJuW36ts\" alt=\"15018598977763.jpg\"></p>\n<p>目前，Node.js 同时支持这2种 JavaScript 引擎，二者性能和特性上各有千秋，<code>ChakraCore</code> 在特性上感觉更潮一些，曾经是第一个支持 <code>Async函数</code> 的引擎，但目前 Node.js 还是以 Chrome V8 引擎为主， <code>ChakraCore</code> 版本需要单独安装，大家了解一下就好。</p>\n<h2>Part 1前言：学习 Node.js 的三个境界</h2>\n<p>我总结的编程3种境界</p>\n<ul>\n<li>打日志：console.log</li>\n<li>断点调试：断点调试：node debugger 或node inspector 或vscode</li>\n<li>测试驱动开发（tdd | bdd）</li>\n</ul>\n<p>大家可以自测一下，自己在哪个水平？如果是第三个阶段，那么本场Live可能不太适合你。哈哈哈</p>\n<h2>Part 2准备：如何学习Node.js</h2>\n<p>Node不是语言，不是框架，只是基于V8运行时环境。结合libuv能够通过js语法获得更好的等价于c/c++的性能。</p>\n<p>它很简单，异步是解决并发的最佳实践。本节主要讲如何学习Node.js，是本次Live非常核心的内容，大家要注意听。</p>\n<h3>基础学习</h3>\n<p>1）js语法必须会</p>\n<ol>\n<li>js基本语法，都是c语系的，有其他语言背景学习起来相对更简单</li>\n<li>常见用法，比如正则，比如数据结构，尤其是数组的几种用法。比如bind/call/apply等等</li>\n<li>面向对象写法。js是基于对象的，所以它的oo写起来非常诡异。参见红皮书JavaScript高级编程，很多框架都是自己实现oo基础框架，比如ext-core等。</li>\n</ol>\n<p>犀牛书，《JavaScript权威指南》，没事就多翻翻，看少多少遍都不为过。</p>\n<p>2）个人学习和技术选型都要循序渐进</p>\n<ol>\n<li>先能写，采用面向过程写法，简单理解就是定义一堆function，然后调用，非常简单</li>\n<li>然后再追求更好的写法，可以面向对象。对于规模化的编程来说，oo是有它的优势的，一般java、c#，ruby这些语言里都有面向对象，所以后端更习惯，但对于语言经验不那么强的前端来说算高级技巧。</li>\n<li>等oo玩腻了，可以有更好的追求：函数式编程，无论编程思维，还是用法上都对已有的编程思维是个挑战。我很喜欢函数式，但不太会在团队里使用，毕竟oo阶段还没完全掌握，风险会比较大。但如果团队水平都非常高了，团队稳定是可以用的。</li>\n</ol>\n<p>可以看出我的思路，先能写，然后再追求更好的写法，比如面向对象。等团队水平到一定程度了，并且稳定的时候，可以考虑更加极致的函数式写法。</p>\n<p>团队是这样选型的，个人学习也这样，最好是循序渐进，步子迈大了不好。</p>\n<p>3）各种高级的JavaScript友好语言</p>\n<p>JavaScript友好语言指的是能够使用其他语法实现，但最终编译成js的语言。自从Node.js出现后，这种黑科技层出不穷。比如比较有名的coffee、typescript、babel（es）等。</p>\n<p>CoffeeScript虽然也是JavaScript友好语言，但其语法借鉴ruby，崇尚极简，对于类型和OO机制上还是偏弱，而且这么多年也没发展起来，仍然是比较小众的活着。未来比例会越来越少的。</p>\n<p>显然TypeScript会越来越好，TypeScript 的强大之处是要用过才知道的。</p>\n<ul>\n<li>1）规模化编程，像Java那种，静态类型，面向对象，前端只有TypeScript能做到</li>\n<li>2）亲爹是微软安德斯·海尔斯伯格，不知道此人的请看borland传奇去</li>\n<li>3）开源，未来很好</li>\n<li>4）组合拳：TypeScript + VSCode = 神器</li>\n</ul>\n<p>当下前端发展速度极快，以指数级的曲线增长。以前可能1年都不一定有一项新技术，现在可能每个月都有。大前端，Node全栈，架构演进等等都在快速变化。可以说，前端越复杂，有越多的不确定性，TypeScript的机会就越大。</p>\n<p>4）再论面向对象</p>\n<p>面向对象想用好也不容易的，而且js里有各种实现，真是让人眼花缭乱。</p>\n<ul>\n<li>基于原型的写法，纵观JavaScript高级编程，就是翻来覆去的讲这个，这个很基础，但不好是很好用。可以不用，但不可以不会。</li>\n<li>自己写面向对象机制是最好的，但不是每个人都有这个能力的。好在es6规范出了更好一点的面向对象，通过class、extends、super关键字来定义类，已经明显好很多了，虽然还很弱，但起码勉强能用起来了。从面向过程走过来的同学，推荐这种写法，简单易用。但要注意面向对象要有面向对象的写法，要理解抽象，继承，封装，多态4个基本特征。如果想用好，你甚至还需要看一些设计模式相关的书。好在有《JavaScript设计模式》一书。Koa2里已经在用这种写法了。</li>\n<li>js是脚本语言，解释即可执行。所以它的最大缺点是没有类型系统，这在规模化编程里是非常危险的，一个函数，传参就能玩死人。于是现在流行使用flow和typescript来做类型校验。flow只是工具，比较轻量级。而typescript是es6超级，给es6补充了类型系统和更完善的面向对象机制，所以大部分人都会对ts有好感，很有可能是未来的趋势。</li>\n</ul>\n<p>对于es6高级特性，我是比较保守的，一般node长期支持版本lts支持的我都让用，一些更新的特性我一般不让使用。根本lts版本保持一致就好。</p>\n<p>我的团队现在是采用es6的面向对象写法开发，后面会一点一点转到typescript上的。熟练oo转到ts是非常容易的。</p>\n<h3>安装Node.js环境</h3>\n<p>3m安装法</p>\n<ul>\n<li>nvm（node version manager）【需要使用npm安装，替代品是yrm（支持yarn），nvs对window支持很好】</li>\n<li>nrm（node registry manager）【需要使用npm安装，替代品是yrm（支持yarn）】</li>\n<li>npm（node packages manager）【内置，替代品是n或nvs（对win也支持）】</li>\n</ul>\n<h4>nvm</h4>\n<p>node版本发布非常快，而且多版本共存可能性较大，推荐使用nvm来安装node</p>\n<pre class=\"prettyprint language-shell\"><code>$ curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.6&#x2F;install.sh | bash\n\n$ echo &#x27;export NVM_DIR=&quot;$HOME&#x2F;.nvm&quot;&#x27; &gt;&gt; ~&#x2F;.zshrc\n$ echo &#x27;[ -s &quot;$NVM_DIR&#x2F;nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR&#x2F;nvm.sh&quot; # This loads nvm&#x27; &gt;&gt; ~&#x2F;.zshrc\n$ source ~&#x2F;.zshrc\n\n$ nvm install 0.10\n$ nvm install 4\n$ nvm install 6\n$ nvm install 8\n</code></pre><h4>nrm</h4>\n<p><a href=\"https://registry.npmjs.com\">https://registry.npmjs.com</a> 是node官方的源（registry），服务器在国外，下载速度较慢，推荐安装nrm来切换源，国内的cnpm和taobao的源都非常快，当然，如果你想自建源也是支持的。</p>\n<pre class=\"prettyprint language-shell\"><code>$ npm install --global nrm --registry=https:&#x2F;&#x2F;registry.npm.taobao.org\n$ nrm use cnpm\n</code></pre><h4>npm</h4>\n<p>nrm切换完源之后，你安装npm模块的速度会更快。</p>\n<pre class=\"prettyprint language-shell\"><code>$ npm install --global yarn\n</code></pre><p>npm基本命令</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n<th>简写</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>npm install xxx</td>\n<td>安装xxx模块，但不记录到package.json里</td>\n<td>npm i xxx</td>\n</tr>\n<tr>\n<td>npm install --save xxx</td>\n<td>安装xxx模块，并且记录到package.json里，字段对应的dependency，是产品环境必须依赖的模块</td>\n<td>npm i -s xxx</td>\n</tr>\n<tr>\n<td>npm install --save-de xxx</td>\n<td>安装xxx模块，并且记录到package.json里，字段对应的dev-dependency，是开发环境必须依赖的模块，比如测试类的（mocha、chai、sinon、zombie、supertest等）都在</td>\n<td>npm i -D xxx</td>\n</tr>\n<tr>\n<td>npm install --global xxx</td>\n<td>全局安装xxx模块，但不记录到package.json里，如果模块里package.json有bin配置，会自动链接，作为cli命令</td>\n<td>npm i -g xxx</td>\n</tr>\n</tbody>\n</table>\n<h3>常用软件</h3>\n<ul>\n<li>1）oh my zsh是我最习惯的shell，终端下非常好用</li>\n</ul>\n<p>配合iterm2分屏 + spectacle全屏，几乎无敌</p>\n<ul>\n<li>2）brew是mac装软件非常好的方式，和apt-get、rpm等都非常类似</li>\n</ul>\n<p>安装4个必备软件</p>\n<ul>\n<li>\n<p>brew install git 最流行的SCM源码版本控制软件</p>\n</li>\n<li>\n<p>brew install wget 下载、扒站神器</p>\n</li>\n<li>\n<p>brew install ack  搜索代码神器</p>\n</li>\n<li>\n<p>brew install autojump 终端下多目录跳转神器</p>\n</li>\n<li>\n<p>3）vim</p>\n</li>\n</ul>\n<p>我虽然不算vim党，但也深爱着。janus是一个非常好用的vim集成开发环境。比如ctrl-p、nerdtree等插件都集成了，对我这种懒人足够了。</p>\n<h3>IDE和编辑器</h3>\n<p>关于Node.js的IDE和编辑器有很多选择，对比如下</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>是否收费</th>\n<th>断点调试</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Webstorm</td>\n<td>收费</td>\n<td>支持</td>\n<td>是IDE，在代码提示、重构等方面功能非常强大，支持的各种语言、框架、模板也非常多，支持断点调试，好处是特别智能，缺点也是特别智能</td>\n</tr>\n<tr>\n<td>Sublime/TextMate</td>\n<td>收费</td>\n<td>不支持</td>\n<td>编辑器里非常好用的，textmate主要针对mac用户，sublime是跨平台的，相信很多前端开发都熟悉</td>\n</tr>\n<tr>\n<td>Vim/Emace</td>\n<td>免费</td>\n<td>不支持</td>\n<td>命令行下的编辑器，非常强大，难度也稍大，但更为酷炫，而且对于服务器部署开发来说是值得一学的</td>\n</tr>\n<tr>\n<td>VSCode/Atom</td>\n<td>免费</td>\n<td>支持</td>\n<td>Atom比较早，功能强大，缺点稍卡顿，VSCode是微软出的，速度快，对于Node.js 调试，重构，代码提示等方面支持都非常好</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a>是一个运行于 Mac、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。它功能强大，便于调试，加上它本身也是基于 Node.js 模块 <code>electron</code> 构建的，尤其要推荐大家使用。</p>\n<p>Visual Studio Code（以下简称vsc）</p>\n<ul>\n<li>vsc是一个比较潮比较新的编辑器（跨平台Mac OS X、Windows和 Linux ）</li>\n<li>vsc功能和textmate、sublime、notepad++，ultraedit等比较，毫不逊色</li>\n<li>vsc尤其是在nodejs（调试）和typescript、go上支持尤其好</li>\n<li>vsc提供了自定义 Debugger Adapter 和 VSCode Debug Protocol 从而实现自己的调试器</li>\n</ul>\n<p>值得一学，我推荐VSCode编辑器！</p>\n<p>更多调试方法，参见https://github.com/i5ting/node-debug-tutorial</p>\n<h3>Node.js应用场景</h3>\n<p>《Node.js in action》一书里说，Node.js 所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为 Node.js 自身在 I/O 上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。</p>\n<p>这话不假，但在今天来看，DIRT 还是范围小了。其实 DIRT 本质上说的 I/O 处理的都算，但随着大前端的发展，Node.js 已经不再只是 I/O 处理相关，而是更加的“Node”！</p>\n<p>Node.js 使用场景主要分为4大类</p>\n<p><img src=\"//static.cnodejs.org/FlXC-FcqbkX4B9ToqUVEy1m-H9Vl\" alt=\"屏幕快照 2017-05-17 07.25.05.png\"></p>\n<ul>\n<li>1）跨平台：覆盖你能想到的面向用户的所有平台，传统的PC Web端，以及PC客户端 <code>nw.js/electron</code> 、移动端 <code>cordova</code>、HTML5、<code>react-native</code>、<code>weex</code>，硬件 <code>ruff.io</code> 等</li>\n<li>2）Web应用开发：网站、Api、RPC服务等</li>\n<li>3）前端：三大框架 React \\ <code>Vue</code> \\ <code>Angular</code> 辅助开发，以及工程化演进过程（使用<code>Gulp</code> /Webpack 构建 Web 开发工具）</li>\n<li>4）工具：<code>npm</code>上各种工具模块，包括各种前端预编译、构建工具 <code>Grunt</code> / <code>Gulp</code>、脚手架，命令行工具，各种奇技淫巧等</li>\n</ul>\n<p>下面列出具体的 Node.js 的使用场景，以模块维度划分</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>描述</th>\n<th>相关模块</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>网站</td>\n<td>类似于 <code>cnodejs.org</code> 这样传统的网站</td>\n<td><code>Express</code> / <code>Koa</code></td>\n</tr>\n<tr>\n<td>Api</td>\n<td>同时提供给移动端，PC，<code>H5</code> 等前端使用的 <code>HTTP Api</code> 接口</td>\n<td><code>Restify</code> / <code>HApi</code></td>\n</tr>\n<tr>\n<td>Api代理</td>\n<td>为前端提供的，主要对后端Api接口进行再处理，以便更多的适应前端开发</td>\n<td><code>Express</code> / <code>Koa</code></td>\n</tr>\n<tr>\n<td>IM即时聊天</td>\n<td>实时应用，很多是基于 <code>WebSocket</code>协议的</td>\n<td><code>Socket.io</code> / <code>sockjs</code></td>\n</tr>\n<tr>\n<td>反向代理</td>\n<td>提供类似于 <code>nginx</code> 反向代理功能，但对前端更友好</td>\n<td><code>anyproxy</code> / <code>node-http-proxy</code> / <code>hiproxy</code></td>\n</tr>\n<tr>\n<td>前端构建工具</td>\n<td>辅助前端开发，尤其是各种预编译，构建相关的工具，能够极大的提高前端开发效率</td>\n<td><code>Grunt</code> / <code>Gulp</code> / <code>Bower</code> / Webpack / <code>Fis3</code> / <code>YKit</code></td>\n</tr>\n<tr>\n<td>命令行工具</td>\n<td>使用命令行是非常酷的方式，前端开发自定义了很多相关工具，无论是shell命令，node脚本，还是各种脚手架等，几乎每个公司\\小组都会自己的命令行工具集</td>\n<td><code>Cordova</code> / <code>Shell.js</code></td>\n</tr>\n<tr>\n<td>操作系统</td>\n<td>有实现，但估计不太会有人用</td>\n<td><code>NodeOS</code></td>\n</tr>\n<tr>\n<td>跨平台打包工具</td>\n<td>使用 Web 开发技术开发PC客户端是目前最流行的方式，会有更多前端开发工具是采用这种方式的</td>\n<td>PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的Cordova，即老的Phonegap，还有更加有名的一站式开发框架Ionicframework</td>\n</tr>\n<tr>\n<td>P2P</td>\n<td>区块链开发、BT客户端</td>\n<td><code>webtorrent</code> / <code>ipfs</code></td>\n</tr>\n<tr>\n<td>编辑器</td>\n<td><code>Atom</code> 和 <code>VSCode</code> 都是基于 <code>electron</code> 模块的</td>\n<td><code>electron</code></td>\n</tr>\n<tr>\n<td>物联网与硬件</td>\n<td>ruff.io和很多硬件都支持node sdk</td>\n<td><code>ruff</code></td>\n</tr>\n</tbody>\n</table>\n<p>Node.js 应用场景非常丰富，比如 Node.js 可以开发操作系统，但一般我都不讲的，就算说了也没多大意义，难道大家真的会用吗？一般，我习惯将 Node.js 应用场景氛围7个部分。</p>\n<p>1）初衷，server端，不想成了前端开发的基础设施\n2）命令行辅助工具，甚至可以是运维\n3）移动端：cordova，pc端：nw.js和electron\n4）组件化，构建，代理\n5）架构，前后端分离、api proxy\n6）性能优化、反爬虫与爬虫</p>\n<ol>\n<li>全栈最便捷之路</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>场景</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>反向代理</td>\n<td>Node.js可以作为nginx这样的反向代理，虽然线上我们很少这样做，但它确确实实可以这样做。比如node-http-proxy和anyproxy等，其实使用Node.js做这种请求转发是非常简单的，在后面的http章节里，有单独的讲解。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>爬虫</td>\n<td>有大量的爬虫模块，比如node-crawler等，写起来比python要简单一些，尤其搭配jsdom（node版本的jQuery）类库的，对前端来说尤其友好</td>\n</tr>\n<tr>\n<td>3</td>\n<td>命令行工具</td>\n<td>所有辅助开发，运维，提高效率等等可以用cli做的，使用node来开发都非常合适，是编写命令行工具最简单的方式，java8以后也参考了node的命令行实现</td>\n</tr>\n<tr>\n<td>4</td>\n<td>微服务与RPC</td>\n<td>node里有各种rpc支持，比如node编写的dnode，seneca，也有跨语言支持的grpc，足够应用了</td>\n</tr>\n<tr>\n<td>5</td>\n<td>微信公众号开发</td>\n<td>相关sdk，框架非常多，是快速开发的利器</td>\n</tr>\n<tr>\n<td>6</td>\n<td>前端流行SSR &amp;&amp; PWA</td>\n<td>SSR是服务器端渲染，PWA是渐进式Web应用，都是今年最火的技术。如果大家用过，一定对Node.js不陌生。比如React、Vuejs都是Node.js实现的ssr。至于pwa的service-worker也是Node.js实现的。那么为啥不用其他语言实现呢？不是其他语言不能实现，而是使用Node.js简单、方便、学习成本低，轻松获得高性能，如果用其他语言，我至少还得装环境</td>\n</tr>\n</tbody>\n</table>\n<p>可以说目前大家能够看到的、用到的软件都有 Node.js 身影，当下最流行的软件写法也大都是基于 Node.js 的，比如 PC 客户端 <a href=\"https://github.com/luin/medis\">luin/medis</a> 采用 <code>electron</code> 打包，写法采用 React + Redux。我自己一直的实践的【Node全栈】，也正是基于这种趋势而形成的。在未来，Node.js 的应用场景会更加的广泛，更多参见 <a href=\"https://github.com/sindresorhus/awesome-nodejs\">sindresorhus/awesome-nodejs</a>。</p>\n<h3>Node核心：异步流程控制</h3>\n<p>Node.js是为异步而生的，它自己把复杂的事儿做了（高并发，低延时），交给用户的只是有点难用的Callback写法。也正是坦诚的将异步回调暴露出来，才有更好的流程控制方面的演进。也正是这些演进，让Node.js从DIRT（数据敏感实时应用）扩展到更多的应用场景，今天的Node.js已经不只是能写后端的JavaScript，已经涵盖了所有涉及到开发的各个方面，而Node全栈更是热门种的热门。</p>\n<p>直面问题才能有更好的解决方式，Node.js的异步是整个学习Node.js过程中重中之重。</p>\n<ul>\n<li>\n<ol>\n<li>异步流程控制学习重点</li>\n</ol>\n</li>\n<li>2）Api写法：Error-first Callback 和 EventEmitter</li>\n<li>3）中流砥柱：Promise</li>\n<li>4）终极解决方案：Async/Await</li>\n</ul>\n<h4>1) 异步流程控制学习重点</h4>\n<p>我整理了一张图，更直观一些。从09年到现在，8年多的时间里，整个Node.js社区做了大量尝试，其中曲折足足够写一本书的了。大家先简单了解一下。</p>\n<p><img src=\"//static.cnodejs.org/FowNmdNw00ghB3PxKtMz9ajo2i5c\" alt=\"Screen Shot 2017-04-05 at 08.43.08.png\"></p>\n<ul>\n<li>红色代表Promise，是使用最多的，无论async还是generator都可用</li>\n<li>蓝色是Generator，过度货</li>\n<li>绿色是Async函数，趋势</li>\n</ul>\n<p><strong>结论</strong>：Promise是必须会的，那你为什么不顺势而为呢？</p>\n<p><strong>推荐</strong>：使用Async函数 + Promise组合，如下图所示。</p>\n<p>其实，一般使用是不需要掌握上图中的所有技术的。对于初学者来说，先够用，再去深究细节。所以，精简一下，只了解3个就足够足够用了。</p>\n<p><img src=\"//static.cnodejs.org/Flepwa2gOwCimQX5JbOdL5bK74s1\" alt=\"Screen Shot 2017-04-05 at 08.43.34.png\"></p>\n<p>结论</p>\n<ol>\n<li>Node.js SDK里callback写法必须会的。</li>\n<li>Node.js学习重点: Async函数与Promise\n<ol>\n<li>中流砥柱：Promise</li>\n<li>终极解决方案：Async/Await</li>\n</ol>\n</li>\n</ol>\n<p>所以下面我们会分个小部分进行讲解。</p>\n<h4>2）Api写法：Error-first Callback 和 EventEmitter</h4>\n<p>a）Error-first Callback\n定义错误优先的回调写法只需要注意2条规则即可：</p>\n<ul>\n<li>回调函数的第一个参数返回的error对象，如果error发生了，它会作为第一个err参数返回，如果没有，一般做法是返回null。</li>\n<li>回调函数的第二个参数返回的是任何成功响应的结果数据。如果结果正常，没有error发生，err会被设置为null，并在第二个参数就出返回成功结果数据。</li>\n</ul>\n<p>下面让我们看一下调用函数示例，Node.js 文档里最常采用下面这样的回调方式：</p>\n<pre class=\"prettyprint language-js\"><code>function(err, res) {\n  &#x2F;&#x2F; process the error and result\n}\n</code></pre><p>这里的 <code>callback</code> 指的是带有2个参数的函数：&quot;err&quot;和 “res”。语义上讲，非空的“err”相当于程序异常；而空的“err”相当于可以正常返回结果“res”，无任何异常。</p>\n<p>b）EventEmitter</p>\n<p>事件模块是 Node.js 内置的对观察者模式“发布/订阅”（publish/subscribe）的实现，通过<code>EventEmitter</code>属性，提供了一个构造函数。该构造函数的实例具有 <code>on</code> 方法，可以用来监听指定事件，并触发回调函数。任意对象都可以发布指定事件，被 <code>EventEmitter</code> 实例的 <code>on</code> 方法监听到。</p>\n<p>在node 6之后，可以直接使用<code>require('events')</code>类</p>\n<pre class=\"prettyprint language-js\"><code>var EventEmitter = require(&#x27;events&#x27;)\nvar util = require(&#x27;util&#x27;)\n\nvar MyEmitter = function () {\n \n}\n\nutil.inherits(MyEmitter, EventEmitter)\n\nconst myEmitter = new MyEmitter();\n\nmyEmitter.on(&#x27;event&#x27;, (a, b) =&gt; {\n  console.log(a, b, this);\n    &#x2F;&#x2F; Prints: a b {}\n});\n\nmyEmitter.emit(&#x27;event&#x27;, &#x27;a&#x27;, &#x27;b&#x27;);\n</code></pre><p>和jquery、vue里的Event是非常类似的。而且前端自己也有EventEmitter。</p>\n<p>c）如何更好的查Node.js文档</p>\n<p>API是应用程序接口Application Programming Interface的简称。从Node.js异步原理，我们可以知道，核心在于 Node.js SDK 中API调用，然后交由EventLoop（Libuv）去执行，所以我们一定要熟悉Node.js的API操作。</p>\n<p>Node.js的API都是异步的，同步的函数是奢求，要查API文档，在高并发场景下慎用。</p>\n<p>笔者推荐使用 <a href=\"https://kapeli.com/dash\">Dash</a> 或 <a href=\"https://zealdocs.org/\">Zeal</a> 查看离线文档，经常查看离线文档，对Api理解会深入很多，比IDE辅助要好，可以有效避免离开IDE就不会写代码的窘境。</p>\n<p><img src=\"//static.cnodejs.org/FrIj8UUZLjtGeZDA8RQeBTxff55l\" alt=\"api.png\"></p>\n<h4>3）中流砥柱：Promise</h4>\n<p>回调地狱</p>\n<p>Node.js 因为采用了错误优先的回调风格写法，导致sdk里导出都是回调函数。如果组合调用的话，就会特别痛苦，经常会出现回调里嵌套回调的问题，大家都非常厌烦这种写法，称之为Callback Hell，即回调地狱。一个经典的例子来自著名的Promise模块<a href=\"https://github.com/kriskowal/q\">q</a>文档里。</p>\n<pre class=\"prettyprint language-js\"><code>step1(function (value1) {\n    step2(value1, function(value2) {\n        step3(value2, function(value3) {\n            step4(value3, function(value4) {\n                &#x2F;&#x2F; Do something with value4\n            });\n        });\n    });\n});\n</code></pre><p>这里只是做4步，嵌套了4层回调，如果更多步骤呢？很多新手浅尝辄止，到这儿就望而却步，粉转黑。这明显不够成熟，最起码你要看看它的应对解决方案吧！</p>\n<p>Node.js 约定所有Api都采用错误优先的回调方式，这部分场景都是大家直接调用接口，无太多变化。而Promise是对回调地狱的思考，或者说是改良方案。目前使用非常普遍，可以说是在async函数普及之前唯一一个通用性规范，甚至 Node.js 社区都在考虑 Promise 化，可见其影响之大。</p>\n<p>Promise最早也是在commonjs社区提出来的，当时提出了很多规范。比较接受的是promise/A规范。后来人们在这个基础上，提出了promise/A+规范，也就是实际上现在的业内推行的规范。ES6 也是采用的这种规范。</p>\n<p>Promise意味着[许愿|承诺]一个还没有完成的操作，但在未来会完成的。与Promise最主要的交互方法是通过将函数传入它的then方法从而获取得Promise最终的值或Promise最终最拒绝（reject）的原因。要点有三个：</p>\n<ul>\n<li>递归，每个异步操作返回的都是promise对象</li>\n<li>状态机：三种状态转换，只在promise对象内部可以控制，外部不能改变状态</li>\n<li>全局异常处理</li>\n</ul>\n<p>1)定义</p>\n<pre class=\"prettyprint language-js\"><code>var promise = new Promise(function(resolve, reject) {\n  &#x2F;&#x2F; do a thing, possibly async, then…\n\n  if (&#x2F;* everything turned out fine *&#x2F;) {\n    resolve(&quot;Stuff worked!&quot;);\n  }\n  else {\n    reject(Error(&quot;It broke&quot;));\n  }\n});\n</code></pre><p>每个Promise定义都是一样的，在构造函数里传入一个匿名函数，参数是resolve和reject，分别代表成功和失败时候的处理。</p>\n<p>2)调用</p>\n<pre class=\"prettyprint language-js\"><code>promise.then(function(text){\n    console.log(text)&#x2F;&#x2F; Stuff worked!\n    return Promise.reject(new Error(&#x27;我是故意的&#x27;))\n}).catch(function(err){\n    console.log(err)\n})\n</code></pre><p>它的主要交互方式是通过then函数，如果Promise成功执行resolve了，那么它就会将resolve的值传给最近的then函数，作为它的then函数的参数。如果出错reject，那就交给catch来捕获异常就好了。</p>\n<p>Promise 的最大优势是标准化，各类异步工具库都按照统一规范实现，即使是async函数也可以无缝集成。所以用 Promise 封装 API 通用性强，用起来简单，学习成本低。在async函数普及之前，绝大部分应用都是采用Promise来做异步流程控制的，所以掌握Promise是Node.js学习过程中必须要掌握的重中之重。</p>\n<p>Bluebird是 Node.js 世界里性能最好的Promise/a+规范的实现模块，Api非常齐全，功能强大，是原生Promise外的不二选择。</p>\n<p>好处如下：</p>\n<ul>\n<li>避免Node.js内置Promise实现 问题，使用与所有版本兼容</li>\n<li>避免Node.js 4曾经出现的内存泄露问题</li>\n<li>内置更多扩展，timeout、 promisifyAll等，对Promise/A+规范提供了强有力的补充</li>\n</ul>\n<p>限于时间关系，这里就不一一列举了，还是那句话，在学习Node.js过程中，对于Promise了解多深入都不过分。</p>\n<p>推荐学习资料</p>\n<ul>\n<li>Node.js最新技术栈之Promise篇  <a href=\"https://cnodejs.org/topic/560dbc826a1ed28204a1e7de\">https://cnodejs.org/topic/560dbc826a1ed28204a1e7de</a></li>\n<li>理解 Promise 的工作原理 <a href=\"https://cnodejs.org/topic/569c8226adf526da2aeb23fd\">https://cnodejs.org/topic/569c8226adf526da2aeb23fd</a></li>\n<li>Promise 迷你书 <a href=\"http://liubin.github.io/promises-book/\">http://liubin.github.io/promises-book/</a></li>\n</ul>\n<h4>4）终极解决方案：Async/Await</h4>\n<p>Async/Await是异步操作的终极解决方案，Koa 2在node 7.6发布之后，立马发布了正式版本，并且推荐使用async函数来编写Koa中间件。</p>\n<p>这里给出一段Koa 2应用里的一段代码</p>\n<pre class=\"prettyprint\"><code>exports.list = async (ctx, next) =&gt; {\n  try {\n    let students = await Student.getAllAsync();\n  \n    await ctx.render(&#x27;students&#x2F;index&#x27;, {\n      students : students\n    })\n  } catch (err) {\n    return ctx.api_error(err);\n  }\n};\n</code></pre><p>它做了3件事儿</p>\n<ul>\n<li>通过await Student.getAllAsync();来获取所有的students信息。</li>\n<li>通过await ctx.render渲染页面</li>\n<li>由于是同步代码，使用try/catch做的异常处理</li>\n</ul>\n<p>是不是非常简单，现在Eggjs里也都是这样同步的代码。</p>\n<p>4.1 正常写法</p>\n<pre class=\"prettyprint\"><code>const pkgConf = require(&#x27;pkg-conf&#x27;);\n\nasync function main(){\n\tconst config = await pkgConf(&#x27;unicorn&#x27;);\n\n\tconsole.log(config.rainbow);\n\t&#x2F;&#x2F;=&gt; true\n}\n\nmain();\n</code></pre><p>变态写法</p>\n<pre class=\"prettyprint\"><code>const pkgConf = require(&#x27;pkg-conf&#x27;);\n\n(async () =&gt; {\n\tconst config = await pkgConf(&#x27;unicorn&#x27;);\n\n\tconsole.log(config.rainbow);\n\t&#x2F;&#x2F;=&gt; true\n})();\n</code></pre><p>4.2 await + Promise</p>\n<pre class=\"prettyprint\"><code>const Promise = require(&#x27;bluebird&#x27;);\nconst fs = Promise.promisifyAll(require(&quot;fs&quot;));\n\nasync function main(){\n    const contents = await fs.readFileAsync(&quot;myfile.js&quot;, &quot;utf8&quot;)\n    console.log(contents);\n}\n\nmain();\n</code></pre><p>4.3 await + co + generator</p>\n<pre class=\"prettyprint\"><code>const co = require(&#x27;co&#x27;);\nconst Promise = require(&#x27;bluebird&#x27;);\nconst fs = Promise.promisifyAll(require(&quot;fs&quot;));\n\nasync function main(){\n   const contents = co(function* () {\n      var result = yield fs.readFileAsync(&quot;myfile.js&quot;, &quot;utf8&quot;)\n      return result;\n   })\n\n\tconsole.log(contents);\n}\n\nmain();\n</code></pre><p>要点</p>\n<ul>\n<li>co的返回值是promise，所以await可以直接接co。</li>\n<li>co的参数是genrator</li>\n<li>在generator里可以使用yield，而yield后面接的有5种可能，故而把这些可以yield接的方式成为yieldable，即可以yield接的。\n<ul>\n<li>Promises</li>\n<li>Thunks (functions)</li>\n<li>array (parallel execution)</li>\n<li>objects (parallel execution)</li>\n<li>Generators 和 GeneratorFunctions</li>\n</ul>\n</li>\n</ul>\n<p>由上面3中基本用法可以推出Async函数要点如下：</p>\n<ul>\n<li>Async函数语义上非常好</li>\n<li>Async不需要执行器，它本身具备执行能力，不像Generator需要co模块</li>\n<li>Async函数的异常处理采用try/catch和Promise的错误处理，非常强大</li>\n<li>Await接Promise，Promise自身就足够应对所有流程了，包括async函数没有纯并行处理机制，也可以采用Promise里的all和race来补齐</li>\n<li>Await释放Promise的组合能力，外加co和Promise的then，几乎没有不支持的场景</li>\n</ul>\n<p>综上所述</p>\n<ul>\n<li>Async函数是趋势，如果Chrome 52. v8 5.1已经支持Async函数(<a href=\"https://github.com/nodejs/CTC/issues/7\">https://github.com/nodejs/CTC/issues/7</a>)了，Node.js支持还会远么？</li>\n<li>Async和Generator函数里都支持promise，所以promise是必须会的。</li>\n<li>Generator和yield异常强大，不过不会成为主流，所以学会基本用法和promise就好了，没必要所有的都必须会。</li>\n<li>co作为Generator执行器是不错的，它更好的是当做Promise 包装器，通过Generator支持yieldable，最后返回Promise，是不是有点无耻？</li>\n</ul>\n<p>小结</p>\n<p>这部分共讲了4个小点，都是极其直接的必须掌握的知识点。</p>\n<ul>\n<li>\n<ol>\n<li>异步流程控制学习重点</li>\n</ol>\n</li>\n<li>2）Api写法：Error-first Callback 和 EventEmitter</li>\n<li>3）中流砥柱：Promise</li>\n<li>4）终极解决方案：Async/Await</li>\n</ul>\n<p>这里再提一下关于Node.js源码阅读问题，很多人api都还没完熟练就去阅读源码，这是非常不赞成的，不带着问题去读源码是比较容易迷失在大量代码中的。效果并不好。</p>\n<p>先用明白，然后再去阅读Node.js源码，然后探寻libuv并发机制。很多人买了朴大的《深入浅出Node.js》一书，看了之后还是不太会用，不是书写的不好，而是步骤不对。</p>\n<ul>\n<li>Node in action和了不起的Node.js是入门的绝好书籍，非常简单，各个部分都讲了，但不深入，看了之后，基本就能用起来了</li>\n<li>当你用了一段之后，你会对Node.js的运行机制好奇，为啥呢？这时候去读朴大的《深入浅出Node.js》一书就能够解惑。原因很简单，九浅一深一书是偏向底层实现原理的书，从操作系统，并发原理，node源码层层解读。如果是新手读，难免会比较郁闷。</li>\n<li>实践类的可以看看雷宗民（老雷）和赵坤（nswbmw）写的书</li>\n</ul>\n<p>我一般给大家的推荐是把Node in action读上5遍10遍，入门干活足够了。剩下的就是反复实践，多写代码和npm模块就好。</p>\n<p>目前所有的书籍几乎都有点过时了，大部分都是Node.js v0.10左右的版本的，我得新书是基于Node.js 8版本的，预计2018年3月或4月出版。别催我，真没法更快了。</p>\n<p>目录</p>\n<ul>\n<li><a href>01 Node.js初识</a></li>\n<li><a href>02 安装与入门</a></li>\n<li><a href>03 更了不起的Node.js</a></li>\n<li><a href>04 更好的Node.js</a></li>\n<li><a href>05 Node.js是如何执行的</a></li>\n<li><a href>06 模块与核心</a></li>\n<li><a href>07 异步写法与流程控制</a></li>\n<li><a href>08 下一代Web框架Koa入门</a></li>\n<li><a href>09 Koa的核心扩展机制：中间件</a></li>\n<li><a href>10 HTTP协议必知必会</a></li>\n<li><a href>11 Koa练习</a></li>\n<li><a href>12 数据库入门</a></li>\n<li><a href>13 数据库进阶</a></li>\n<li><a href>14 视图模板</a></li>\n<li><a href>15 Koa项目实战</a></li>\n<li><a href>16 自己动手写NPM模块</a></li>\n<li><a href>17 Node.js企业级Web开发</a></li>\n<li><a href>18 构建具有Node.js特色的微服务</a></li>\n<li><a href>19 让Node.js跑的更稳</a></li>\n<li><a href>20 让Node.js跑的更快</a></li>\n</ul>\n<p>博文视点的美女编辑在苦逼的整理中，预计出版在3月之后（不要催我，我也没法说），20章，800页+，定价预计在130+。</p>\n<h3>Web编程要点</h3>\n<p>一般，后端开发指的是 Web 应用开发中和视图渲染无关的部分，主要是和数据库交互为主的重业务型逻辑处理。但现在架构升级后，Node.js 承担了前后端分离重任之后，有了更多玩法。从带视图的<strong>传统Web应用</strong>和<strong>面向Api接口应用</strong>，到通过 RPC 调用封装对数据库的操作，到提供前端 Api 代理和网关，服务组装等，统称为<strong>后端开发</strong>，不再是以往只有和数据库打交道的部分才算后端。这样，就可以让前端工程师对开发过程可控，更好的进行调优和性能优化。</p>\n<p>对 Node.js 来说，一直没有在后端取得其合理的占有率，原因是多方面的，暂列几条。</p>\n<ul>\n<li>1）利益分配，已有实现大多是Java或者其他语言，基本是没法撼动的，重写的成本是巨大的，另外，如果用Node写了，那么那些写Java的人怎么办？抢人饭碗，这是要拼命的。</li>\n<li>2）Node相对年轻，大家对Node的理解不够，回调和异步流程控制略麻烦，很多架构师都不愿意花时间去学习。尽管在Web应用部分处理起来非常简单高效，但在遇到问题时并不容易排查定位，对开发者水平要求略高。</li>\n<li>3）开发者技能单一，很多是从前端转过来的，对数据库，架构方面知识欠缺，对系统设计也知之不多，这是很危险的，有种麻杆打狼两头害怕的感觉。</li>\n<li>4）Node在科普、培训、布道等方面做的并不好，国外使用的非常多，国内却很少人知道，不如某些语言做得好。</li>\n</ul>\n<p>尽管如此，Node.js 还是尽人皆知，卷入各种是非风口，也算是在大前端浪潮中大红大紫。原因它的定位非常明确，补足以 JavaScript 为核心的全栈体系中服务器部分。开发也是人，能够同时掌握并精通多门语言的人毕竟不多，而且程序员的美德是“懒”，能使用 JavaScript 一门语言完成所有事儿，为什么要学更多呢？</p>\n<p>对于 Web 应用大致分2种，带视图的<strong>传统Web应用</strong>和<strong>面向Api接口应用</strong>，我们先看一下 Node.js Web 应用开发框架的演进时间线大致如下：</p>\n<ul>\n<li>2010年 TJ Holowaychuk 写的 Express</li>\n<li>2011年 Derby.js 开始开发，8月5日，WalmartLabs 的一位成员 Eran Hammer 提交了 Hapi 的第一次git记录。Hapi 原本是 Postmile 的一部分，并且最开始是基于 Express 构建的。后来它发展成自己自己的框架，</li>\n<li>2012年1月21日，专注于 Rest api 的 Restify 发布1.0版本，同构的 Meteor 开始投入开发，最像Rails 的 Sails 也开始了开发</li>\n<li>2013年 TJ Holowaychuk 开始玩 es6 generator，编写 <code>co</code> 这个 Generator 执行器，并开始了Koa 项目。2013 年下半年李成银开始 ThinkJS，参考 ThinkPHP</li>\n<li>2014年4月9日，Express 发布4.0，进入4.x时代持续到今天，MEAN.js 开始随着 MEAN 架构的提出开始开发，意图大一统，另外 Total.js 开始起步，最像PHP里 Laravel 或 Python 里的 Django 或 <a href=\"http://ASP.NET\">ASP.NET</a> MVC的框架，代表着 Node.js 的成熟，开始从其他语言里的成熟框架借鉴</li>\n<li>2015年8月22日，下一代 Web 框架 Koa 发布1.0，可以在Node.js v0.12下面，通过<code>co</code> 和 generator实现同步逻辑，那时候 <code>co</code> 还是基于 <code>thunkfy</code> 的，在2015年10月30日，ThinkJS发布了首个基于 Es2015+ 特性开发的 v2.0 版本</li>\n<li>2016 年 09 月，蚂蚁金服的 Eggjs，在 JSConf China 2016 上亮相并宣布开源</li>\n<li>2017年2月，下一代Web框架 Koa 发布v2.0正式版</li>\n</ul>\n<p>我们可以根据框架的特性进行分类</p>\n<table>\n<thead>\n<tr>\n<th>框架名称</th>\n<th>特性</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Express</td>\n<td>简单、实用，路由中间件等五脏俱全</td>\n<td>最著名的Web框架</td>\n</tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor</td>\n<td>同构</td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高</td>\n</tr>\n<tr>\n<td>Sails、Total</td>\n<td>面向其他语言，Ruby、PHP等</td>\n<td>借鉴业界优秀实现，也是 Node.js 成熟的一个标志</td>\n</tr>\n<tr>\n<td>MEAN.js</td>\n<td>面向架构</td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点</td>\n</tr>\n<tr>\n<td>Hapi和Restfy</td>\n<td>面向Api &amp;&amp; 微服务</td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器</td>\n</tr>\n<tr>\n<td>ThinkJS</td>\n<td>面向新特性</td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右，新版v3.0是基于Koa v2.0的作为内核的</td>\n</tr>\n<tr>\n<td>Koa</td>\n<td>专注于异步流程改进</td>\n<td>下一代Web框架</td>\n</tr>\n<tr>\n<td>Egg</td>\n<td>基于Koa，在开发上有极大便利</td>\n<td>企业级Web开发框架</td>\n</tr>\n</tbody>\n</table>\n<p>对于框架选型</p>\n<ul>\n<li>业务场景、特点，不必为了什么而什么，避免本末倒置</li>\n<li>自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定</li>\n<li>出现问题的时候，有人能够做到源码级定制。Node.js 已经有8年历史，但模块完善程度良莠不齐，如果不慎踩到一个坑里，需要团队在无外力的情况能够搞定，否则会影响进度</li>\n</ul>\n<blockquote>\n<p>Tips：个人学习求新，企业架构求稳，无非喜好与场景而已</p>\n</blockquote>\n<p>Node.js 本来就为了做后端而设计的，这里我们再看看利益问题。Node.js 向后端延伸，必然会触动后端开发的利益。那么 Proxy 层的事儿，前后端矛盾的交界处，后端不想变，前端又求变，那么长此以往，Api接口会变得越来越恶心。后端是愿意把Api的事儿叫前端的，对后端来说，只要你不动我的数据库和服务就可以。</p>\n<p>但是 Node.js 能不能做这部分呢？答案是能的，这个是和 Java、PHP 类似的，一般是和数据库连接到一起，处理带有业务逻辑的。目前国内大部分都是以 Java、PHP 等为主，所以要想吃到这部分并不容易。</p>\n<ul>\n<li>小公司，创业公司，新孵化的项目更倾向于 Node.js ，简单，快速，高效</li>\n<li>微服务架构下的某些服务，使用 Node.js 开发，是比较合理的</li>\n</ul>\n<p>国内这部分一直没有做的很好，所以 Node.js 在大公司还没有很好的被应用，安全问题、生态问题、历史遗留问题等，还有很多人对 Node.js 的误解。</p>\n<ul>\n<li>单线程很脆弱，这是事实，但单线程不等于不能多核并发，而且你还有集群呢</li>\n<li>运维，其实很简单，比其他语言之简单，日志采集、监控也非常简单</li>\n<li>模块稳定性，对于 <code>MongoDB</code>、<code>MySQL</code>、<code>Redis</code> 等还是相当不错，但其他的数据库支持可能没那么好。</li>\n<li>安全问题是个伪命题，所有框架面临的都是一样的。</li>\n</ul>\n<p>这些对于提供Api服务来说已经足够了，本书后面有大量篇幅讲如何使用 Koa 框架来构建Api服务。</p>\n<p>Web编程核心</p>\n<ul>\n<li>异步流程控制（前面讲过了）</li>\n<li>基本框架 Koa或Express，新手推荐Express，毕竟资料多，上手更容易。如果有一定经验，推荐Koa，其实这些都是为了了解Web编程原理，尤其是中间件机制理解。</li>\n<li>数据库 mongodb或mysql都行，mongoose和Sequelize、bookshelf，TypeOrm等都非常不错。对于事物，不是Node.js的锅，是你选的数据库的问题。另外一些偏门，想node连sqlserver等估计还不成熟，我是不会这样用的。</li>\n<li>模板引擎， ejs，jade，nunjucks。理解原理最好。尤其是extend，include等高级用法，理解布局，复用的好处。其实前后端思路都是一样的。</li>\n</ul>\n<h3>迷茫时学习Node.js最好的方法</h3>\n<p>Node.js 编写的包管理器 npm 已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。现在早已经超过60万个模块了。</p>\n<p>这里就不一一举例了，给出一个<strong>迷茫时学习Node.js最好的方法</strong>吧！</p>\n<p>某天，我在3w咖啡整理书稿，然后小弟梁过来了，聊聊他的现状，一副很不好的样子，在天津我曾带过他大半年，总不能不管，我给他的建议是：“每天看10个npm模块”</p>\n<p>对于学习Node.js迷茫的人来说，这是最好的方式，当你不知道如何做的时候，就要向前（钱）看，你要知道积累哪些技能对以后有好处。对于学习Node.js必经之路，一定是要掌握很多模块用法，并从中汲取技巧、思路、设计思想的。与其不知道学什么，为什么不每天积累几个技巧呢？</p>\n<p>推荐一个repo即 <a href=\"https://github.com/parro-it/awesome-micro-npm-packages\">https://github.com/parro-it/awesome-micro-npm-packages</a> 小型库集合，一天看十个不是梦！</p>\n<p>更多讨论 <a href=\"https://zhuanlan.zhihu.com/p/29625882\">https://zhuanlan.zhihu.com/p/29625882</a></p>\n<h3>非科班出身如何Node.js</h3>\n<p>有朋友提问</p>\n<pre class=\"prettyprint\"><code>狼叔，关注你和cnode很久了，最近有点迷茫，想请你指点下。\n我的情况是这样的，非科班出身，从事前端工作4年，公司使用的技术栈是vue2、vue-router、vuex、webpack，目前的能力处理工作还是比较轻松，但是也很明确自己有很多不足，只是对于如何提升比较迷茫。\n不足：\n1、非科班出身，计算机基础薄弱\n2、对当前使用的技术了解不够深入，很多东西只停留在会用的层面\n3、对服务端了解较少，想学node，却不知道如何系统的学习\n</code></pre><p>解答困惑：</p>\n<p>1、计算机基础薄弱该如何完善自己的知识体系？</p>\n<p>答:追逐长尾，所见所闻不懂的都去学就好啦。我是这样过来的，头几年每天14个小时+，很累，不过效果还可以。os，算法，数据结构，设计模式，编译原理，基本也就这些重点。做到每天都有进步就好，别贪多求快。数学和英文当然也是越狠越好的！</p>\n<p>2、如何在技术上做更深入的探索？</p>\n<p>答:技术人只关注技术，想法创意通常比较少。最简单的办法就是抓自己的痒，比我大学时和朋友们翻译过grails文档，所以对翻译有情节。为了翻译，我用node写了无数工具尝试，反复对比各种翻译工具，理解它们背后的设计。包括markdown里嵌html标签标识中英文，然后gulp编译成独立文档。甚至一度想上线卖服务。这种折腾真的很爽，甚至耽误了不少翻译。有时要警惕长尾，不要忘了自己的初衷</p>\n<p>3、如何系统的学习node？</p>\n<p>答:阶段</p>\n<p>1/要会用，能完成工作任务\n2/写点提高效率的工具\n3/参与开源项目，甚至是node源码</p>\n<p>应对方法</p>\n<p>1/《node in action》看五遍，然后就去写吧，别管代码质量如何，能写敢写\n2/多用些模块，理解它们，如果有机会就自己写一下，万一有很多人用你，我小弟写过一个地区选择加载的json数据，star数不少呢\n3/给别人贡献代码，要去学别人的习惯，网上有git标准工作流和提pr方法，你要做的是精研该模块代码，关注issue，其他就是等机会。另外朴灵的深入浅出多读几遍，试着读node源码，你的理解会更好。推荐看看我写的《通过开源项目去学习》<a href=\"https://github.com/i5ting/Study-For-StuQ\">https://github.com/i5ting/Study-For-StuQ</a>\n4/跳出node范围，重新审视node的应用场景，对未来你的技术选项和决策大有裨益</p>\n<ul>\n<li>2.1 Node 用途那么多，我该从哪里学起？</li>\n</ul>\n<p>答：如果有机会就直接上Web应用，如果没有机会就从前端构建，工具等方面开始做，慢慢引入更潮更酷的前端技术，自然就把Node引入进来了。不要急。</p>\n<ul>\n<li>2.2 Node Web 框架那么多，我该怎么选？</li>\n</ul>\n<p>答：初学者推荐Express，如果有一定经验，推荐Koa。当然真正项目里还是推荐Eggjs和Thinkjs这样的框架。</p>\n<ul>\n<li>2.3 关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n<p>答：\n1）Node in action和了不起的Node.js是入门的绝好书籍，非常简单，各个部分都讲了，但不深入，看了之后，基本就能用起来了\n2）当你用了一段之后，你会对Node.js的运行机制好奇，为啥呢？这时候去读朴大的《深入浅出Node.js》一书就能够解惑。原因很简单，九浅一深一书是偏向底层实现原理的书，从操作系统，并发原理，node源码层层解读。如果是新手读，难免会比较郁闷。\n3)实践类的可以看看雷宗民（老雷）和赵坤（nswbmw）写的书</p>\n<p>如果你不着急，也可以等我的那本《更了不起的Node.js》，时间待定。</p>\n<h2>Part 3延伸：大前端变化那么快，如何才能做到每日精进？</h2>\n<p>有朋友问现在Android开发和web前端开发哪个前景更好？我的回答是明显是前端更好，看一下移动端发展过程</p>\n<blockquote>\n<p>native &lt; hybrid &lt; rn/weex &lt; h5</p>\n</blockquote>\n<p>目前rn和weex的开发逐渐变得主流，组件化写法已经由前端主导了。以前ios和android程序员占比很高，但现在就留1到2个写插件，真是差别很大。</p>\n<p>Web开发对移动端的冲击非常大。当然现在Web技术也开发PC client了，比如vscode是通过electron打包的，效果还是相当不错的。</p>\n<p>前端可以说是最近几年开发里最火的部分，原因很多，最主要是开发方式的变更，以今时今日的眼光来看，称之为现代Web开发是不为过的。</p>\n<p>先给出现代Web开发的概览图</p>\n<p><img src=\"//static.cnodejs.org/Fq7XArZKEXlzHEwBiR35IxHs4nOg\" alt=\"15117552681353.jpg\"></p>\n<p>每次演讲我会都问大家是不是前端，回答“是”的人非常多，我会开玩笑的恭喜大家：“现在的前端就是钱端”，确实，现在前端发展异常的快，而且没有趋向于类比java里ssh框架的那种稳定，所以未来很长一段时间，还会增长，持续混乱，这对前端来说是把双刃剑，一方面有很强的压迫感，不学习就跟不上时代，另一方它也是机遇，能够带给更多机会，包括money。</p>\n<p>大家都疑惑的一个问题是如何在这样巨变的时代能够通过学习来应变，我可以很负责的告诉大家，没有捷径，但通过掌握 Node.js 能够让你降低这个学习曲线而已，毕竟Node.js是大前端的基础设施。大家可以看一下，前端的开发过程，模块化，构建，辅助工具，调优，架构调整，可以说Node.js是无处不在的。</p>\n<p>其实，辅助大前端开发只是Node.js的一个非常无心插柳的衍生功能，通过掌握Node.js能够让你能做的更多、获得的更多，甚至可以说有更多自我实现的快乐，这也是我那本书书名字里“更了不起的”要去阐述的内容。</p>\n<p>综上种种，就是我一直提倡以 JavaScript 语言为中心的 <code>Node全栈</code> 概念的缘由，JavaScript 覆盖所有前端，Node.js 擅长做 I/O 密集型的后端，外加辅助开发的各种基础设施，无疑是工作、学习和成为快速掌握全栈技术最好的途径。你会的越多，你能做的就更多，你的人生也将会有不一样的精彩篇章。</p>\n<p>全栈核心</p>\n<ul>\n<li>后端不会的 UI（界面相关）</li>\n<li>前端不会的 DB（业务相关）</li>\n</ul>\n<p>只要打通这2个要点，其他就比较容易了。最怕的是哪样都接触点，然后就号称自己是全栈，建议大家不要这样做，这就好比在简历里写精通一样，基本上都会被问到尴尬。全栈是一种信仰，不是拿来吹牛逼的，而可以解决更多问题，让自己的知识体系不留空白，享受自我实现的极致快乐。</p>\n<h3>我的全栈之路</h3>\n<p>想问一下狼叔最近的业务一直都是简单的用express搭一个后端服务，没有其他更加深入node的业务了，这种时候应该如何自己给自己创应用场景呢</p>\n<blockquote>\n<p>没有目标就向钱看，有目标就向前看</p>\n</blockquote>\n<ul>\n<li>从 java 开始，蹭课，背着机箱到深圳，3个月胖20斤</li>\n<li>坚持翻译英文文档，看 《Thinking in Java》</li>\n<li>毕业后开始 bi，整理 bi 文档</li>\n<li>学长明林清，传授 jQuery，愿意学，别人就更愿意分析</li>\n<li>接手《内蒙广电数据分析与科学决策系统》，打通前、后端</li>\n<li>广东联通，自己造轮子，写 jQuery 插件，DRY</li>\n<li>做云计算，学习 AIX，写有《凌云志》</li>\n<li>分手、离职，去做 iOS，从 cordova 开始搞 H5，研究各种移动端框架，自己写框架，转原生</li>\n<li>面试也是学习的利器，轻松进新浪</li>\n<li>总结了大量 iOS 经验，想写书，结果写了一堆写书的工具</li>\n</ul>\n<blockquote>\n<p>既然无法逃避，就热爱它，最后变成兴趣</p>\n</blockquote>\n<ul>\n<li>去网秦做技术总监，做首席，管架构，带人，写开源项目</li>\n<li>创业，当 CTO，结婚，做公众号运营，写书，最苦的时候没钱吃饭，又不能找媳妇要，只能在 StuQ 上讲点课</li>\n<li>加入去哪儿网，任职前端架构师</li>\n<li>加入阿里巴巴，前端技术专家</li>\n</ul>\n<blockquote>\n<p>人生不只有代码，但它能让我快乐，终生受益</p>\n</blockquote>\n<p>也曾懵懂，也曾迷茫，但我这人比较傻，一直信奉：“一次只做1件事儿，尽力做到极致”，短时间看这是比较傻的，但一旦你坚持下去，你就会发现技术其实是门手艺，厚积薄发。</p>\n<p>我没办法说自己最擅长什么，但在什么场景下用什么技术是我擅长的。或者说，应变是我最大的本事。很多框架，新技术我都没见过，用过，但花一点点过一下，就能拿已有的知识快速的理解它，这其实是长期学习的好处。</p>\n<p>现在越来越忙，写代码的时间越来越少，技术又越发展越快，我能做好的就是每日精进，仗着这点已有的知识储备跟年轻人比赛。我不觉得累，相反我很享受这种感觉，没有被时代淘汰，是一件多么幸福的事儿。</p>\n<h3>从后端转</h3>\n<p>做后端的人</p>\n<ul>\n<li>对数据库是比较熟悉，无论 mongodb，还是 mysql、postgres</li>\n<li>对前端理解比较弱，会基本的 html，css，模板引擎等比较熟悉</li>\n</ul>\n<blockquote>\n<p>4阶段循序渐进，build 与工具齐飞</p>\n</blockquote>\n<p>前端开发4阶段，我的感觉是按照顺序，循序渐进就好。</p>\n<h3>从前端转</h3>\n<p>从前端往后端转，api 接口非常容易学会，像 express、koa 这类框架大部分人一周就能学会，最难的是对 db、er 模型的理解，说直白点，还是业务需求落地的理解</p>\n<p>我们来想想一般的前端有什么技能？</p>\n<ul>\n<li>html</li>\n<li>css（兼容浏览器）</li>\n<li>js 会点（可能更多的是会点 jquery）</li>\n<li>ps 切图</li>\n<li>firebug 和 chrome debuger 会的人都不太多</li>\n<li>用过几个框架，大部分人是仅仅会用</li>\n<li>英语一般</li>\n<li>svn/git 会一点</li>\n</ul>\n<p>那么他们如果想在前端领域做的更深有哪些难点呢？</p>\n<ul>\n<li>基础：oo，dp，命令，shell，构建等</li>\n<li>编程思想上的理解（mvc、ioc，规约等）</li>\n<li>区分概念</li>\n<li>外围验收，如 H5 和 hybird 等</li>\n<li>追赶趋势，如何学习新东西</li>\n</ul>\n<p>以上皆是痛点，所以比较好的办法应该是这样的。</p>\n<ul>\n<li>玩转 npm、gulp 这样的前端工具类（此时还是前端）</li>\n<li>使用 node 做前后端分离（此时还是前端）</li>\n<li>express、koa 这类框架</li>\n<li>jade、ejs 等模板引擎</li>\n<li>nginx</li>\n<li>玩转【后端】异步流程处理（promise/es6的(generator|yield)/es7(async|await)）</li>\n<li>玩转【后端】mongodb、mysql 对应的 Node 模块</li>\n</ul>\n<p>从我们的经验看，这样是比较靠谱的。先做最简单前后端分离，里面没有任何和db相关，前端可以非常容易的学会，基本2周就已经非常熟练了。一般半年后，让他们接触【异步流程处理】和【数据库】相关内容，学习后端代码，就可以全栈了。</p>\n<h3>从移动端转</h3>\n<p>看一下移动端发展过程</p>\n<blockquote>\n<p>native &lt; hybrid &lt; rn/weex &lt; h5</p>\n</blockquote>\n<p>目前rn和weex的开发逐渐变得主流，组件化写法已经由前端主导了。以前ios和android程序员占比很高，但现在就留1到2个写插件，真是差别很大。狼叔一直固执的以为未来是h5的。</p>\n<p>现在的 Native 开发是姥姥不疼舅舅不爱，非常尴尬，很明显连培训出的人就业不要工资混经验就很明显了。另外领导们也都在惦记，能不能用 H5 写？这还算是保守的，如果直接激进的就直接上 RN 了，那么 Native开发的程序员就变了</p>\n<blockquote>\n<p>一个写插件的程序员…招谁惹谁了。。。。</p>\n</blockquote>\n<p>要么忍，要么转，没办法，认命吧，温水里舒服了几年，也该学点东西了</p>\n<ul>\n<li>hybrid 或组件化开发，你总要会一样</li>\n<li>无论哪种，你都离前端很近，因为 H5 或组件化都是从前端走出来的</li>\n<li>组件化在前端领域先行，无论借鉴还是学习都不可避免</li>\n<li>如果没时间就直接上组件化，如果有时间就好好学学前端完整体系，最终也还是要学组件化</li>\n</ul>\n<p>原生开发就是 iOS 用 OC/Swift,Android 用 java 或 scala 等，就算偶尔嵌入 webview，能玩js的机会也非常好少</p>\n<p>所以移动端转全栈的方法，最好是从 cordova（以前叫 phonegap）开始做 hybrid 开发。</p>\n<ul>\n<li>只要关注 www 目录里的 H5 即可，比较简单</li>\n<li>如果 H5 不足以完成的情况下，可以编写 cordova 插件，即通过插件让 js 调用原生 sdk 里功能</li>\n<li>cordova 的 cli 可以通过 npm 安装，学习 npm 的好方法</li>\n<li>学习 gulp 构建工具</li>\n</ul>\n<p>只要入了 H5 的坑，其实就非常好办了。</p>\n<ul>\n<li>然后 h5、zeptojs、iscroll、fastclick 等</li>\n<li>然后微信常用的，如 weui、vux（vue+weui）、jmui（react+weui）</li>\n<li>然后可以玩点框架，比如 jquery mobile，sencha touch</li>\n<li>然后可以玩点高级货，ionicframework（基于 angularjs、cordova）</li>\n<li>然后前端4阶段，依次打怪升级</li>\n<li>然后 node</li>\n</ul>\n<p>这个基本上是我走的路，从2010年写iOS、做phonegap（当时是0.9.3）、一路走到现在的总结吧！</p>\n<p>以前技术发展还不是那么明显，写 Java 的时候 <code>Apache</code> 的开源用的比较多，那时开源的代码托管<code>sourceforge</code>，<code>google code</code> 也都凑合用，自从 <code>Git</code> 和 <code>GitHub</code> 出现时候，代码社交兴起，极大的促进了开源的活跃，使得大量明星项目脱引而出。这是好事，如果没有开源，中国的软件水平真是要落后好多年。那么问题也来了，如何能够在技术快速发展的今天，个人成长也能更好呢？</p>\n<p>学习的3种层次，跟人学最快，其次是跟书（或者博客）学，最差的是自悟。但是牛人不能遇到，遇到了也未必有精力教你，书本或者博客，别人有，但不一定写出来，就算是写了，可能只是点到为止。至于自悟，如果没有深厚的积累的，还是有相当大难度的。</p>\n<p>对于开发来说代码是一切基础，在掌握了一定计算机基础后，其差别就在于代码质量和眼界。编程没有捷径，能够做到每日精进就是极好的。现在开源代码非常多，要能够从中获取自己所需的知识，也是一种本领！如果能够坚持着每日精进，根本不需要向其他人学习的。</p>\n<p><img src=\"//static.cnodejs.org/FvXJwylBhEv33TowEJYMfX-CULZC\" alt=\"15011322589471.jpg\"></p>\n<p>大家可以在 Github 随便打开一个前端项目，里面有一半以上都是 Node.js 相关信息，各种包管理、测试、ci、辅助模块，如果大家对这些基础信息掌握的非常好，那么学习一个新的框架，你要比别人快好多，最重要的是学了一次，到处使用。</p>\n<p>很多人问我怎么才能成为一个 Node.js 大神？我的回答是“在cnode论坛上坚持写文章和开源项目2年，足矣，轻松进阿里腾讯，不用你找他们，他们自会找你的”。</p>\n<blockquote>\n<p>从今天起，开始重视开源项目，重视 node，做到每日精进</p>\n</blockquote>\n<h2>Part 4实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</h2>\n<h3>招人标准</h3>\n<p>先说下我的招人标准，做技术总监时上指下派只要看好技术能力和态度即可，做CTO时要考虑团队文化，人品和能否在公司长留，所以不同的人面试要看的点是不一样的，我曾面过很多Node.js程序员，也见过很多面试题，汇总一下，大致有以下9个点：</p>\n<ol>\n<li>基本的Node.js几个特性，比如事件驱动、非阻塞I/O、Stream等</li>\n<li>异步流程控制相关，Promise是必问的</li>\n<li>掌握1种以上Web框架，比如Express、Koa、Thinkjs、Restfy、Hapi等，会问遇到过哪些问题、以及前端优化等常识</li>\n<li>数据库相关，尤其是SQL、缓存、Mongodb等</li>\n<li>对于常见Node.js模块、工具的使用，观察一个人是否爱学习、折腾</li>\n<li>是否熟悉linux，是否独立部署过服务器，有+分</li>\n<li>js语法和es6、es7，延伸CoffeeScript、TypeScript等，看看你是否关注新技术，有+分</li>\n<li>对前端是否了解，有+分</li>\n<li>是否参与过或写过开源项目，技术博客、有+分</li>\n</ol>\n<p>补充一句:只看技能没人品的人，千万别招，白脸狼</p>\n<p>主动执行，辅助团队\n掌握一门后端语言；熟悉用户体验相关知识；了解软件工程。\n精通浏览器工作原理，熟悉HTTP协议，熟悉设计模式。\n掌握改善无障碍访问的方法；掌握数据采集分析能力；熟悉可维护性问题。\n通过开发、使用、推广效率工具让自己与团队的效率得到提高；\n提炼可复用组件，为类库贡献高质量代码.\n积极完善知识库；\n跨团队分享技术和专业相关知识。\n辅导新人技能成长；\n协助主管做招聘和团队管理工作。</p>\n<h3>大家是选大公司还是小公司？</h3>\n<p>我再知乎上回复的《在跳槽后的第三个月，收到世界500强的offer，我该怎么办？》</p>\n<p>1）互联网公司优先，流量大，人才多，机会也多，流程规范一些</p>\n<p>2）今天的世界500强不比从前了，普华永道应该是四大之一，不知道信息化怎么样，你只要和你现在的公司对比就好了。</p>\n<p>3）问问自己想要什么，钱，经历，还是时间</p>\n<p>如果你很年轻，现在很安逸，我建议你换。如果不是很想动，那就学会所有能接触到的知识再换。</p>\n<p>我是降薪来的阿里，原因有三，一是有事可为，老板重用你给你机会，二是集团内部是open的，偏偏我知识面足够可以看出它们的好处，算是另一种补偿吧，三是对个人品牌是一个升级，狼叔的职业生涯到此已经足够了，进可攻退可守，也算另一种自由吧！</p>\n<p>钱多是个优势而已，还有氛围，文化，信仰</p>\n<ul>\n<li>牛人多</li>\n<li>业务需要</li>\n<li>成熟后有更多精力</li>\n<li>内部竞争，优胜劣汰</li>\n<li>财务相对自由，可以追求信仰了</li>\n</ul>\n<p>前几天还和 @苏千 聊，我和 @死月絲卡蕾特 相继入职阿里，还有cnode社区著名程序员也即将入职阿里，当时大家开玩笑说:</p>\n<blockquote>\n<p>“前端的终极归宿是阿里，不是在阿里，就是在去阿里的路上”</p>\n</blockquote>\n<p>另外要说的一点是pc和h5站在使用Node.js做api中间层，其最佳实践已成型，量也是极大的。以前前端玩得还是比较弱，如果能够缓存+控制页面数据，获得一个性能极大的提升也是极好的。2018年，争取拿这个做主题演讲上qcon或archsummit大会。</p>\n<p>每天忙得很开心，这就是我现在状态。其实，我的折腾还是在于想做些事情。如果你也想跟我一起做事，请将简历邮件给我 <a href=\"mailto:langshu.ssl@alibaba-inc.com\">langshu.ssl@alibaba-inc.com</a>，团队大量招人，也可以帮忙推荐给集团其他部门。</p>\n<p>大公司的做事方式</p>\n<ul>\n<li>按照规矩做事，不要碰红线</li>\n<li>工时一般压的都不会太紧，都是可以商量的，但态度一定要好</li>\n<li>闲的时候自己学点东西，上班要学习相关，下班学不相干的。别犯傻。</li>\n<li>多创造点额外价值，让你的领导更喜欢你</li>\n<li>理解能力要强，不要让你的领导说二遍。</li>\n</ul>\n<p>小公司</p>\n<ul>\n<li>简单粗暴，快速出东西，领导最关心的是进度</li>\n<li>执行力要强，遇佛杀佛，有鬼杀鬼</li>\n<li>代码质量其实没太多人管，但自己要注意养成好习惯</li>\n<li>没有机会自己创造机会。创造机会之前是赢得信任。</li>\n</ul>\n<p>狼叔经常说的一句：“少抱怨，多思考，未来更美好”，大部分人都喜欢积极的人，遇到问题不怕不躲不避，要相信自己能够解决，最多是时间问题。</p>\n<p>还有一句是：“没目标向钱看，有目标向前看”。历史上很多这样的例子，在2010年左右iOS开发刚起步，会拖拽弄个界面的就五位数工资，比做JAVA的几年的都要多。这世界就是这样不公平。但是你也不能不思进取，这样也是极其危险。在2016年左右，其实iOS开发就遇到了市场饱和的问题，很多培训出来的人都找不到工作，各家公司都在考虑换react-native或weex或者h5。</p>\n<p>所以，当你有机会进入一个很有前途的方向，你要努力学好，并准备好下一个阶段的应变。相反，如果当成找一个养老的地方，早晚会遇到尴尬的。比如现在很多iOS程序员被迫去学react/vue等，境遇也不太好的，更有甚者直接被开除。</p>\n<h3>优酷-高级前端开发</h3>\n<p>职位描述</p>\n<ol>\n<li>支撑企业级应用后台开发，使用 React 等前端框架搭建后台页面，实现交互需求及后端服务对接;</li>\n<li>以模块化的思想设计开发通用前端组件，并能够针对OTT,移动端进行针对性优化；</li>\n<li>在理解前端开发流程的基础上，结合前端实际建立或优化提升工作效率的工具；</li>\n<li>在理解产品业务的基础上，提升产品的用户体验，技术驱动业务的发展；</li>\n<li>关注前端前沿技术研究，通过新技术服务团队和业务；</li>\n<li>使用 Weex 技术开发产品需求。&quot;</li>\n</ol>\n<p>职位要求</p>\n<ol>\n<li>精通前端技术，包括HTML/CSS/JavaScript/Node.JS等；</li>\n<li>掌握Bootstrap，jQuery，AngularJS，React等框架，并有项目实践；</li>\n<li>熟悉前端模块化、编译和构建工具，如grunt，gulp,webpack等；</li>\n<li>至少熟悉一门非前端的语言（如Java/PHP/C/C++/Python/Ruby）,有项目实践更佳；</li>\n<li>具备跨终端的前端开发能力，在Web（PC+Mobile）/Node.js/Native App三个方向上至少精通一个方向，具备多个的更佳，鼓励在Native和Web技术融合上的探索；</li>\n<li>具有较强的学习能力，对前端技术有持续的热情，个性乐观开朗,逻辑性强，善于和产品，UED，后端等方向同学合作。</li>\n</ol>\n<h3>PixelLab</h3>\n<p>PixelLab是与淘宝GM Lab联合成立的专注于视频算法方向的研发部门，主要涉及视频的空间感知、轨迹跟踪、图像分割、遮挡检测以及照片级渲染等相关技术。用于实现视频内的内容植入与后期特效的研发，属于视频MR的场景，主要应用于广告植入平台的研发，方向靠谱老板人好，欢迎推荐。主要需要的岗位包括了图像算法、3D视觉算法，渲染算法，WebGL以及并行计算等几大方向，因为算法类招聘实在难，所以将JD的链接帖出来希望同事们有适合的人可以内推一下。</p>\n<p>岗位要求：</p>\n<ol>\n<li>本科及以上学历，5年以上工作开发经验；</li>\n<li>扎实的计算几何基础，熟悉常见数学工具；</li>\n<li>熟练WebGL, Canvas渲染开发，熟练Shader编写， 熟悉Three.js, OSG.js者优先;</li>\n<li>熟练运用JavaScript语言与HTML5、CSS3等技术;</li>\n<li>熟悉主流移动浏览器的技术特点，有移动端H5, WebGL项目经验者优先;</li>\n<li>有移动端WebGL开发经验者优先;</li>\n<li>学习能力强、应变能力强，优秀的沟通能力和协调能力，执行能力强，具备较强的团队合作精神。</li>\n</ol>\n<h3>蚂蚁金服</h3>\n<p>岗位要求：</p>\n<ul>\n<li>大学本科学历，2年以上开发经验，能熟练使用常见类库或框架，编写高质量的前端代码；</li>\n<li>熟悉NodeJS，有NodeJS开发经验，熟悉Express\\koa等框架；</li>\n<li>熟练掌握React、Redux及相关框架和技术，有单页面应用开发经验；</li>\n<li>精通ES6，gulp，webpack等规范和技术；</li>\n<li>善于 Web 性能优化与前端效果的实现；</li>\n<li>良好的团队合作精神和积极主动的沟通意识，具有很强的学习能力和对新技术的追求精神，乐于分享；</li>\n<li>有大型网站开发经验者优先。</li>\n</ul>\n<p>我们的前端专业建设方向</p>\n<ul>\n<li>基于ReactJS的主题可配置组件化平台</li>\n<li>基于Nodejs的UED中台业务（浏览器端web页面监控等）</li>\n<li>基于Docker的nodejs云容器平台</li>\n<li>基于Webpack的前端工程化体系建设</li>\n<li>基于eggjs的react同构框架</li>\n<li>基于G2的业务数据可视化组件库</li>\n<li>大规模图形识别/图像处理/AR/VR//语音交互等研究性领域探索</li>\n</ul>\n<h3>联系方式</h3>\n<p>目前北京，杭州，广州，上海，深圳，成都都在招聘，如果你也想跟我一起共事，请将简历邮件给我 <a href=\"mailto:langshu.ssl@alibaba-inc.com\">langshu.ssl@alibaba-inc.com</a>，团队大量招人，也可以帮忙推荐给集团其他部门。</p>\n<p>有机会和winter，勾股，玉伯，苏千，朴灵、死马、偏右，徐飞，阮一峰，天猪，裕波等大神一起工作哦。</p>\n<p>悄悄地说，其实其他公司我也可以帮推荐。</p>\n<h2>结束语</h2>\n<p>年轻时死磕，年长点让小弟死磕，现在抓个专家一起吃饭，没有什么是一顿饭解决不了的，不行就二顿</p>\n<p>工程师的能力不是编码和死磕，而是解决问题</p>\n<ul>\n<li>年轻死磕是为了长本事，30岁以前都可以这样做</li>\n<li>带团队后，要懂得任务下放，让更多人帮你，别带人越多越累</li>\n<li>30岁之后是打牌阶段，技能积累足够用，这时要注重社交，打组合拳才能玩的更好</li>\n</ul>\n<p>强调30岁不是我创造的，大部分人都会认为30岁后事情，压力会明显大得多，比如家庭，孩子，房子，车子，票子，甚至是管理，权利，欲望等等吧。我感受最深的是身体不如从前和记忆力明显下降。</p>\n<p>狼叔说: “少抱怨，多思考，未来更美好”</p>\n<p>大部分人体会不到坚持的乐趣，不会玩，所以抱怨多。其实玩出乐趣也是一种能力，尤其是像写代码这种看似无聊的事儿。最开始可能只想赚点钱，后面变成热爱，这样才美好。只要坚持每日精进开心就好了。</p>\n<p>另外，时间也要好处处理，狼叔总会提菜根谭上的一句话:【闲时要有吃紧的心思，忙里要有偷闲的乐趣】。</p>\n<p>每个人的一生中都有很多坎，类似于瓶颈，唯有苦难和坚持才能冲破，坚持会产生自信，苦难会创造机会。一个经过苦难还有自信的人，一定会有更美好的未来。</p>\n<p>如果大家还有问题，可以去cnode社区发帖at我，也可以在Node全栈公众号提问。</p>\n<h2>Part 5答疑：回答大家的问题</h2>\n<p>答疑有点多，这里就不一一贴出来，如果是新用户和比较迷茫的Node朋友去Live里听吧。</p>\n<ul>\n<li>感谢justjavac大神的<a href=\"https://github.com/justjavac/free-programming-books-zh_CN/#%E7%BD%AE%E9%A1%B6\"> 免费的计算机编程类中文书籍</a> 收录并推荐</li>\n<li><a href=\"https://github.com/i5ting/How-to-learn-node-correctly\">github地址，以后在仓库里更新</a></li>\n<li><a href=\"https://www.zhihu.com/lives/928687583372926976\">Live地址</a></li>\n</ul>\n</div>","title":"【全文】狼叔：如何正确的学习Node.js","last_reply_at":"2019-04-29T12:52:45.476Z","good":true,"top":false,"reply_count":104,"visit_count":59313,"create_at":"2018-03-22T02:35:23.073Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"5b101b058a4f51e140d9440c","author_id":"5b094f5257137f22415c4685","tab":"ask","content":"<div class=\"markdown-text\"><h1>付费VPN推荐</h1>\n<p>更新：<a href=\"https://www.wallmama.com/best-vpn-china-2019/\">2019年便宜好用的翻墙VPN推荐</a></p>\n<h2>免费VPN服务最好不要用</h2>\n<p>用免费VPN服务，网络流量流经一个不可信的第三方，是件危险的事。你的流量里可能有没有充分加密保护的敏感信息：密码，银行账号，私密资料，访问历史等，流量劫持的潜在风险还不止这些。</p>\n<h2>破解的VPN软件更危险</h2>\n<p>这更危险，此类破解软件挂马带病毒是很常见的事，贪便宜从不明来源下载，很快让你的电脑裸奔；况且，破解软件不能更新，即使能用，也只能用极有限的时间。</p>\n<h2>国内的付费VPN服务想用也用不了</h2>\n<p>去年，GreenVPN被关。</p>\n<p>国内还剩多少可用的付费VPN服务，没统计过，越来越少吧，即使还有也离被关不远了。国内某些小众搜索引擎的结果页里偶尔还出现一些不入流（骗钱）的产品。</p>\n<p>也许存在传说中的“已注册“的服务，但国内政策风险太大，不建议购买。</p>\n<h2>国外的付费VPN服务能用的已经不多</h2>\n<p>绝大多数在这几年也陆续沦陷了，国内无法直接购买，买VPN要先上VPN，本身就很无奈。</p>\n<p>不是所有的付费VPN厂商都重视中国市场，只有一线大厂才可以，小厂商的财力、人力、技术能力都没大到能长期保证国内用户能持续使用服务的程度。</p>\n<h2>国外付费VPN推荐</h2>\n<p>下面推荐的服务商都</p>\n<ul>\n<li>\n<p>重视中国用户，国内还能直接支付宝购买</p>\n</li>\n<li>\n<p>全球服务器，好用的客户端</p>\n</li>\n<li>\n<p>提供额外加强服务，持续改进算法和服务质量</p>\n</li>\n<li>\n<p>支持无条件退款</p>\n</li>\n</ul>\n<p><strong>国内还能用支付宝买到</strong>的国外付费vpn推荐：</p>\n<h2>VPN推荐一：<a href=\"https://indx.cc/exp\">ExpressVPN</a></h2>\n<p>全球148+服务器所在地 / 无限流量 / 多协议，包括openVPN / 一键连接 / 同时3台设备 / 256-bit AES加密 / 支付宝支付 / 支持路由器连接 / 完全IP隐藏 / 零日志 / 全终端覆盖 / 30天无条件退款 / Split tunneling技术 + 浏览器插件，同时访问内外网 / <strong>推荐原因：速度相对最快</strong></p>\n<h2>VPN推荐二：<a href=\"https://indx.cc/vyr\">VyprVPN</a></h2>\n<p>70+自有服务器所在地，200,000+IP地址 / 无限流量 / 多协议，独家混淆协议 / 一键连接 / 同时5台设备 / 支持P2P / 变色龙加密，<strong>推荐原因：连接相对最稳定</strong> / 支付宝支付 / 支持路由器连接 / NAT安全机制 / DNS加密 / 全终端覆盖 / 2年款最大优惠 / 30天无条件退款 / 按程序控制网络技术，同时访问内外网</p>\n<h2>VPN推荐三：<a href=\"https://indx.cc/nrd\">Nord</a></h2>\n<p>3400+服务器 / 无限流量 / 支持Onion over vpn / 一键连接 / 同时6台设备 / 支持P2P / 双重加密 / 支付宝支付 / 支持路由器连接 / CyberSec安全技术 / 零日志 / 专业客户端 / 2年款最大优惠 / 随时退款 / 浏览器代理插件，同时访问内外网 / <strong>推荐原因：随时退款</strong></p>\n<h2>自建VPN方案</h2>\n<p>自建VPN是否成功，得靠运气，像<a href=\"https://www.vultr.com/?ref=6996621\">Vultr</a>这样的IP池比较大，但国内用户也特别多，准备好换IP吧，长远没有付费VPN靠谱。</p>\n<h2>付费VPN稳定性与速度</h2>\n<p>没有100%稳定的VPN服务，每年特殊时间段的连接质量都不好，容易断线。</p>\n<p>一年中大部分时间，日常使用Google，收发Gmail，使用Youtube还是稳定的。</p>\n<p>1080P的油管通常是不可能的，只在极少时间还算流畅，720P多数时候比较流畅。</p>\n<p>日常使用，偶尔断线，基本换服务器位置重连即可。</p>\n<p>即使是同一个服务，在一天不同时段，或在不同地域访问，服务质量也可能天差地别，没人知道具体原因，所以如果你在旅行途中，如果要保证最大限度的可连接性，可以考虑常备两个以上的服务，如果一个服务暂时出问题，另一个替上。</p>\n<h2>用好试用期</h2>\n<p>一线服务商都提供免费试用或至少7天的无条件退款，利用好试用期，充分检测服务质量，不满意及时退款，因为各服务在不同地域服务质量不同，所以一定要自己试一试。</p>\n</div>","title":"2019国外付费vpn推荐","last_reply_at":"2019-04-29T10:34:15.136Z","good":false,"top":false,"reply_count":23,"visit_count":23318,"create_at":"2018-05-31T15:55:49.256Z","author":{"loginname":"wallmama","avatar_url":"https://avatars3.githubusercontent.com/u/39631585?v=4&s=120"}},{"id":"5cc2a72f37faec0ce1d06fc4","author_id":"5062b5ea01d0b801483ae4ff","tab":"share","content":"<div class=\"markdown-text\"><p>Scott 近两年无论是面试还是线下线上的技术分享，遇到许许多多前端同学，由于团队原因，个人原因，职业成长，技术方向，甚至家庭等等原因，在理想国与现实之间，在放弃与坚守之间，摇摆不停，心酸硬扛，大家可以找我聊聊南聊聊北，对工程师的宿命有更多的了解，有更多的看见与听见，Scott 微信： codingdream。\n<a href=\"https://juejin.im/user/5790c76dc4c9710054f0f58b/posts\">本系列共 18+ 篇</a>（最开始 15+ 篇，未来会扩充到 30 篇），此为第二篇预热，大家感兴趣后面文章可以点下关注，再转发下朋友圈我就心满意足了。</p>\n<h2>正文开始</h2>\n<blockquote>\n<p>任何可以用 JavaScript 来写的应用，最终都将用 JavaScript 来写。  – <a href=\"https://baike.baidu.com/item/%E9%98%BF%E7%89%B9%E4%BC%8D%E5%BE%B7%E5%AE%9A%E5%BE%8B/631745?fr=aladdin\">阿特伍德定律</a></p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1554174966442-f4c825d1-cbf0-40f0-b2fa-72633d0356f8.png#align=left&amp;display=inline&amp;height=602&amp;name=image.png&amp;originHeight=1204&amp;originWidth=2154&amp;size=417530&amp;status=done&amp;width=1077\" alt=\"image.png\">&lt;br /&gt;</p>\n<p>这篇文章向大家介绍下小菜前端的基建在一步步走过来的过程中，NodeJS 是如何使用的及扮演了哪些角色，它对于工程师个人，团队能力，公司研发效率，业务支撑，技术的探索与突破等等到底有什么实际的意义，以及为什么是它而不是 Python/C++/PHP/Java 成为了前端团队的核心技术栈。</p>\n<h2>被 NodeJS 加速的框架演进速度</h2>\n<p>2019 年的前端与 2009 年的前端早已是君住长江头我住长江尾，短短十年，人是物非，React/Vue 一统天下，Webpack 标配江湖，单纯看近 2 年的 【Npm Trends】:</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1550981329667-dc6c72b5-189b-4af4-ba7d-71da018f88ce.png#align=left&amp;display=inline&amp;height=456&amp;name=image.png&amp;originHeight=570&amp;originWidth=1086&amp;size=115661&amp;status=done&amp;width=869#align=left&amp;display=inline&amp;height=392&amp;originHeight=570&amp;originWidth=1086&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>或者参考近 10 年的【<a href=\"https://trends.google.com/trends/explore?date=2012-02-24%202019-02-24&amp;q=%2Fg%2F11clg_kyfc,Backbone.js,AngularJS,ReactJS,VueJS\">Google Trends</a>】：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1550980367882-4065a804-bbfd-4e59-b028-af6d2353de4f.png#align=left&amp;display=inline&amp;height=370&amp;name=image.png&amp;originHeight=462&amp;originWidth=1152&amp;size=58234&amp;status=done&amp;width=922#align=left&amp;display=inline&amp;height=299&amp;originHeight=462&amp;originWidth=1152&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>热度一定程度反映了社区活跃，和占用市场的体量，可以发现 AngularJS 也是经历了过山车，市场被 React/Vue 不断侵蚀，那再把 jQuery 加进来看下：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1550978165549-170815d8-87f6-4b65-9bbb-95d6964e2d8a.png#align=left&amp;display=inline&amp;height=375&amp;name=image.png&amp;originHeight=468&amp;originWidth=1152&amp;size=55446&amp;status=done&amp;width=922#align=left&amp;display=inline&amp;height=303&amp;originHeight=468&amp;originWidth=1152&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>令人瞠目结舌，即便 React/Vue（绿色和紫色） 如日中天的今天，在整个网络的搜索热度上，也远远低于 jQuery 和 NodeJS，尤其是 jQuery，虽然它的热度在持续降低，但依然是整个互联网中不能忽视的重要组成部分，</p>\n<p>虽然早期与 jQuery 同时代还有很多其他框架类库，比如 ExtJS/Mooltools/Dojo/Yui/Kissy 等等等等，但它们的体量比起 jQuery 都差之甚远不再比较，如果大家把近十年听到的看到的框架罗列起来，几十上百都不成问题，生命周期能超过 5 年却寥寥无几，尤其是在 2012 年 NodeJS 在全球推广到一定规模后，框架的诞生迭代替换更为快速，所以从框架的生命力来看，jQuery 目前为止依然是赢家，那它跟 NodeJS 有什么关系呢？</p>\n<p>NodeJS 的持续变热，jQuery 也在持续走冷，一部分原因就是 NodeJS 生态基建能力，在之上不断的生长出来新的框架与解决方案（不限于 AngularJS/React/Vue），也在不断的蚕食 jQuery 的市场，倘若没有 NodeJS，自然也不可能有新框架的繁荣之态，今天大有可能依然是 jQuery 在一统江湖。</p>\n<p>在今天，无论是 Angular/React/Vue/Webpack，从开发体验、单元测试到打包编译，脱离了 NodeJS 生态，都无法正常运转，NodeJS 就是整个上层建筑的物理基础和配套设施。</p>\n<p>现在我们已经从宏观上了解了 NodeJS 对于前端框架进化和保障的重要性，接下来，就结合小菜前端在 NodeJS 上的建设与大家聊聊它的重要性，2 年来，我们重度使用 NodeJS 陆续参与了十几个重要的工具/产品/系统的建设，下面挑选四个有代表性的分享给大家：</p>\n<h2>小菜前端第一次尝鲜 NodeJS - APP 热更新服务</h2>\n<p>写一些 NodeJS 自动化脚本，代码校验甚至利用 Express/Koa 搭建一些简单的服务，这些都不能算做真正意义使用 NodeJS，我们也抛开 ReactNative/Webpack 等前端开发打包编译需要依赖 NodeJS 这样的场景，我们第一次真正意义使用 NodeJS， 就是对 ReactNative APP 开发的热更新系统，代号神奇博士，服务端框架用的 ThinkJS 框架，那时候是 2016 年中，Scott 还没有入职小菜。</p>\n<p>这样一个热更新发布系统可以让客户端 APP 动态更新到增量的代码包，最原始的更新流程如下图：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1550986692321-51ff661f-6031-4c4b-8e7a-93b0df3a3fe5.png#align=left&amp;display=inline&amp;height=778&amp;name=image.png&amp;originHeight=972&amp;originWidth=1832&amp;size=178950&amp;status=done&amp;width=1466#align=left&amp;display=inline&amp;height=396&amp;originHeight=972&amp;originWidth=1832&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>在热更新系统中，需要针对 iOS/Android 的 IPA/APK 包进行特定操作系统的资源拆包，增量包/原生包存储，包版本管理，权限管理等功能，这些事情是不太可能让服务端童鞋比如 Java 童鞋替你做的，只能前端自己做，也只能用 NodeJS 才能快速的开发出来。</p>\n<p>系统上线后，整个公司的 App 发版频率从一个月一两次（审核还会被打回）提升到一周三四次，效率至少提升 10 倍，而且用户的更新体验得到质的提升，对于业务/运营/产品/用户都有极大的价值。</p>\n<p>这时候我们概念里面的 NodeJS 可能更像是一个特定场景的功能玩具，并没有深挖它的重要性和可能性，虽然尝到了甜头，但往后的一年多没有再持续挖掘。</p>\n<h2>小菜前端第二次尝鲜 NodeJS - APP 打包平台</h2>\n<p>Scott 是从 2011 年开始接触和使用 NodeJS，从 2013 年后技术栈以 NodeJS 为主，开始尝试搭建比较复杂的系统，非常清楚它的优势和短板，在 2017 年下半年开始带前端团队的时候，收到了很多的反馈和投诉，主要分为两类： APP 更新失败的问题（在非常高的迭代节奏下） 和前后端协作的接口/联调问题，针对 APP 更新下失败的问题，我们先来还原下当时的开发状态，大家如果也有多人协作 RN APP 的开发，可以参考接下来我们的做法，相信对你有用。</p>\n<p>我们的 APP 当时一共有 5 个 - 宋小菜（对外）、宋小菜司机（对外）、宋小菜供应商（对外），宋小福（对内）、采秘（对内），所有的 APP 都是 RN 开发，都有 iOS/Android 两个版本，其中对外的是商业开发版本，要发布到苹果商店和推送到特定渠道，对内的都是企业包，不对外公开，我们通过公司自己的网站托管应用供员工安装。</p>\n<p>这些 APP 之间的业务也有一定的联系，通常开发宋小菜，也会联动要修改宋小福或者采秘，在本地开发的时候，需要在每个包里面，区分连接的是日常测试环境，还是线上生产环境，还要区分是可以打印出日志的 debug 包，还是非 debug 包，并且最终上线前，再由每个同学在本地 Mac 上打出一个包上传到热更新平台，这个流程里面会出现大量问题，我曾经画了这样一张图给服务端的同学解释为什么前端打包 APP 到上线会经常出问题：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1550999857898-de8b5645-d5c0-494b-ac53-50fd3c3232dc.png#align=left&amp;display=inline&amp;height=462&amp;name=image.png&amp;originHeight=577&amp;originWidth=805&amp;size=167561&amp;status=done&amp;width=644#align=left&amp;display=inline&amp;height=535&amp;originHeight=577&amp;originWidth=805&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>这样就会有很多组合，有的包是要频繁打的，有的偶尔来几发，打包的时候要区分：</p>\n<ul>\n<li>是哪一个 APP</li>\n<li>是打 iOS 还是 Android 的包</li>\n<li>是正式环境，还是日常测试环境</li>\n<li>打的包要不要开启热更新功能，不开启就不会走线上热更新流程</li>\n<li>这个包要不要实时连到本地打一些 log 出来，也就是是否需要 Debug</li>\n<li>是在哪个同学电脑上打的包</li>\n</ul>\n<p>这样硬组合就可以打出 64 个不同的包，意味着可能需要把配置文件修改 64 次，另外，每个同学电脑上的 Mac 操作系统版本会有不同，XCode/Gradle 也可能版本不同，更不用说 Node 以及 NPM 所安装的三方包，甚至本地预装的开发者证书也时有不一致的情况，于是整个团队陷在了打包/包正确性/一致性/是否能打出来一堆问题形成的泥坑里，艰难的对外解释，艰难的互相配合，针对这个问题，我们思路是让这一切可以傻瓜一点自动化一点，让团队共用一个打包环境，以它打的包为准，于是我们启动了大伯伯打包平台，采购了一台高配 Mac Mini 部署在内网，把所有的配置项都通过界面来管理，简要流程如下：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551006257020-d1107ba9-0642-49cc-ab2b-5331ce817779.png#align=left&amp;display=inline&amp;height=579&amp;name=image.png&amp;originHeight=724&amp;originWidth=1088&amp;size=227220&amp;status=done&amp;width=870#align=left&amp;display=inline&amp;height=496&amp;originHeight=724&amp;originWidth=1088&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>界面一开始很朴素，长这个样子：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551007043243-1c800232-5a2e-42f4-9ecc-07dacc14c7f8.png#align=left&amp;display=inline&amp;height=864&amp;name=image.png&amp;originHeight=1080&amp;originWidth=1234&amp;size=268898&amp;status=done&amp;width=987#align=left&amp;display=inline&amp;height=653&amp;originHeight=1080&amp;originWidth=1234&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>这个系统上线 1 年来，我们已经打了 1000 多个包，因为打包而出现环境错误问题 0 次，极大的解放了团队效率和提升了打包的正确性，更重要的是对于团队也沉淀了一些基于 Node 使用的技能，坚定了大家使用它的信心：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551006379204-19cd28b9-5ec2-4a5d-ba23-ee5a34330b8e.png#align=left&amp;display=inline&amp;height=579&amp;name=image.png&amp;originHeight=723&amp;originWidth=1086&amp;size=239018&amp;status=done&amp;width=869#align=left&amp;display=inline&amp;height=497&amp;originHeight=723&amp;originWidth=1086&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<h2>小菜前端第三次尝鲜 NodeJS - 报表快速制作平台</h2>\n<p>无论是 toB 还是 toC 公司，把数据库里的数据拎出来，无论直接导出为 Excel，还是通过接口输出到前端页面中展示，都是硬刚需，小菜也不例外，而且小菜的业务早些年变化特别高频，每次变化都要提一堆报表需求来监控调整前后的业务变化是否符合预期，如果没有了报表就跟算命一样全靠猜，然后这样一个普通不能再普通的需求，却让小菜整个产品技术团队头疼了好几年。</p>\n<p>在紧张的业务开发项目中，让前后端各自抽出资源来对接一个个的报表字段，再通过接口 - 页面的联调和发布，是一件非常浪费资源的事情，后端感觉自己像是一个写 SQL 的和接口胶水代码的，前端感觉自己就是个纯粹 Table 报表页面仔，而且经常资源交叉冲突导致报表优先级降低甚至拖很久不能给到业务方，所以公司做了整整 3 年，总共才产出了 50 多个报表零散的扔在 ERP 系统里面，针对这个问题，前端启动了一个项目 - 大表哥报表平台，用来解决报表产出效率的问题，实现 SQL 到页面的自动生成，后端工程师，甚至会 SQL 的产品经理和运营都可以到平台上，按照约定的规则粘贴一些 SQL，或者基于编辑页面组装一些 SQL 的子语句，咔咔！报表生成，这个系统上线 1 年来，生产力一下子得到释放，总共产出了 400 多张报表：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551008061890-718ddcbe-9e88-4901-9c49-68b2c64df4cb.png#align=left&amp;display=inline&amp;height=342&amp;name=image.png&amp;originHeight=427&amp;originWidth=1287&amp;size=76549&amp;status=done&amp;width=1030#align=left&amp;display=inline&amp;height=248&amp;originHeight=427&amp;originWidth=1287&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>公司的员工浏览报表每天都有一两千次，直接导出 Excel 就导出了 1 万 6 千多次，已经是公司内部最成功的一个工具产品，服务于全公司所有部门，报表展示大概长这样：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551008972313-977d0787-738d-436a-b7f8-aeb604a271b4.png#align=left&amp;display=inline&amp;height=48&amp;name=image.png&amp;originHeight=60&amp;originWidth=1799&amp;size=11981&amp;status=done&amp;width=1439#align=left&amp;display=inline&amp;height=25&amp;originHeight=60&amp;originWidth=1799&amp;status=done&amp;width=746\" alt=\"image.png\">&lt;br /&gt;<img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551009457628-a3392dd4-d83b-4b2d-9375-500b29d028c1.png#align=left&amp;display=inline&amp;height=277&amp;name=image.png&amp;originHeight=346&amp;originWidth=1792&amp;size=90248&amp;status=done&amp;width=1434#align=left&amp;display=inline&amp;height=144&amp;originHeight=346&amp;originWidth=1792&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>一个报表的制作界面大概长这样：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551008550743-059db323-1dbf-458e-9156-bf2a0acd0ad2.png#align=left&amp;display=inline&amp;height=404&amp;name=image.png&amp;originHeight=505&amp;originWidth=1222&amp;size=87311&amp;status=done&amp;width=978#align=left&amp;display=inline&amp;height=308&amp;originHeight=505&amp;originWidth=1222&amp;status=done&amp;width=746\" alt=\"image.png\">&lt;br /&gt;<img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551008636940-7c9e14e5-5f67-43cf-bcc5-887fc4800f91.png#align=left&amp;display=inline&amp;height=613&amp;name=image.png&amp;originHeight=766&amp;originWidth=1221&amp;size=73231&amp;status=done&amp;width=977#align=left&amp;display=inline&amp;height=468&amp;originHeight=766&amp;originWidth=1221&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>通过对 SQL 的各种查询词的组件封装，可以从界面快速生成一个可在数据库执行的复杂 SQL 语句，或者反向贴入符合规则的 SQL，自动拆解成报表的表头（字段的中文名称），自动映射到组件（日期、排序、筛选、二级跳转的子报表等等），包括整个报表的需求提出、描述、认领、上下线、制作和发布这样的工作流等等也全部用 NodeJS 实现，这次尝鲜不仅奠定了 NodeJS 在前端团队绝对的位置，也实质性的在支撑业务这里拿到了很好的结果，更让我们感到欣喜的是，在报表系统里面使用 GraphQL 是多么的便捷，同时前端部门独立支撑数据相关的业务产品这条路变得可行，NodeJS 的角色从工具也延展到了业务。</p>\n<h2>小菜前端第四次尝鲜 NodeJS - 前后端数据聚合服务</h2>\n<p>如果说前面几个，都是与服务端团队解耦的，是前端可以独立完成的，那么这一次，则是跟服务端在职能上和系统上都有强耦合的地方，是跨团队研发层面的尝试，这次发生在 2018 年 2 月份，也就是在前两次尝鲜后，我们又一次比较大胆的突破。</p>\n<p>背景依然是前端的页面与后端的接口这里，关于这个后面会专门有一篇详细与大家聊聊前后端合作研发上我们的思考，这里我简述一下，前后端的合作方式通常是数据接口，也就是数据格式和字段约定，一个吐数据一个消费数据，吐什么样的数据取决于消费什么样的数据，消费的数据则来源于产品流程上的 UI 展示形式，一份概念里统一的数据，是有可能被分拆成两个 UI 块展示和复用，可能会让接口颗粒度更小拆成 2 个，或者共用一个大的，频次高一些的 UI 改版也会导致接口的通用性变得很弱，最终产生一堆大而全的重体积接口，进而对前端维护页面和用户的加载产生较大的影响。</p>\n<p>而且接口里面永远是黑盒，在前端是看不全接口的能力了，一旦文档没有跟上，接口的输出与 UI 的使用便会脱节，为产品运行的带来了更强的不稳定性，所以我们会希望接口都是纯粹的，用到多少字段就输出多少字段，用到什么格式就输出什么格式，同一个页面的数据，尽量一个接口返回而不是三四个接口返回，但这显然对服务端提出了更高的要求，也是很多公司从前端产品层面试图推动后端团队时候无功而返的最大阻力。一个人群中，大部分人都倾向于不作出改变，在没有看到太多对自己带来的好处之前，而短期成本与长期红利之间大部分会选择短期，因为它容易预见。</p>\n<p>我们的解决办法是，用 NodeJS(EggJS) + GraphQL 搭建一个系统，它负责三件事：</p>\n<ul>\n<li>负责对前端输出所需数据（单接口，要什么给什么，无冗余可组合）</li>\n<li>负责去拿所有的服务端微服务接口数据（HTTP 协议或者 RPC 协议）</li>\n<li>提供一个可以在线连接接口、约束字段以及实时 Mock 的编辑系统</li>\n</ul>\n<p>对它的要求是可在线编辑，可联调测试，可数据热发布与热回滚，这个系统上线后，我们接管了 2 款 App 的接口需求，前端拼装页面和组合数据时候变得更灵活自如，同时正向逆向的数据监控，让我们对数据更有把控力，对于服务端来说，也可以更加不关注 UI 如何，更关注业务领域的搭建与标准数据接口的封装，它的界面长这个样子：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551011468885-fe470426-e822-438e-9938-10df31779e95.png#align=left&amp;display=inline&amp;height=573&amp;name=image.png&amp;originHeight=716&amp;originWidth=1971&amp;size=111706&amp;status=done&amp;width=1577#align=left&amp;display=inline&amp;height=271&amp;originHeight=716&amp;originWidth=1971&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551011516619-07f39971-29fd-4148-b00d-0c72e652e82d.png#align=left&amp;display=inline&amp;height=354&amp;name=image.png&amp;originHeight=442&amp;originWidth=1953&amp;size=81644&amp;status=done&amp;width=1562#align=left&amp;display=inline&amp;height=169&amp;originHeight=442&amp;originWidth=1953&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551011398749-0bfa9fba-b34a-4932-b42e-1cce7a892f92.png#align=left&amp;display=inline&amp;height=519&amp;name=image.png&amp;originHeight=649&amp;originWidth=1892&amp;size=139818&amp;status=done&amp;width=1514#align=left&amp;display=inline&amp;height=256&amp;originHeight=649&amp;originWidth=1892&amp;status=done&amp;width=746\" alt=\"image.png\">&lt;br /&gt;<img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551011560236-bd5765c7-d1bb-4c34-9fde-a3f48c825ab0.png#align=left&amp;display=inline&amp;height=446&amp;name=image.png&amp;originHeight=557&amp;originWidth=2084&amp;size=168554&amp;status=done&amp;width=1667#align=left&amp;display=inline&amp;height=199&amp;originHeight=557&amp;originWidth=2084&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>还有接口地图、数据关系网络、接口字段监控、Mock 系统等等不再一一截图，这个 NodeJS 搭建的系统的复杂度还是蛮高的，上线后我们专门组织了一场技术分享 - <a href=\"https://juejin.im/post/5b29cd2be51d4558d217c644\">杭州第一届 GraphQLParty</a>，让它开源的群众呼声很高，我们觉得还需要更多 NodeJS 的专家进来把系统进一步完善后，才真正能达到开源的标准，目前依然是在公司内部使用。</p>\n<p>综上，小菜前端基于 NodeJS 既有 Eat My Own Shit 的内部场景的问题解决，也有直接服务于前端产品的工具，也有直接把数据当做业务来支撑公司决策的业务产品，还有专注在前后端研发效率的数据聚合层的全方位尝试，从内到外从前到后，而这些系统的尝试，又为前端团队沉淀了非常多的服务端能力，系统设计能力，甚至带来跨语言栈的变化，童鞋们的技术能力也都大幅提升，所以 NodeJS 越来越成为前端团队的核心技术栈，一切基于它的深度尝试，只要能贴合你团队的痛点，公司业务的痛点，那么都是值得尝试的。</p>\n<p>最最后，本文作为预热篇，旨在针对如下话题为大家输出：</p>\n<ul>\n<li>把团队蛮荒到自动化运维的从 0 到 1</li>\n<li>成长历程总结输出给社区，帮助更多的小团队少走弯路</li>\n<li>以一种可被量化的方式汇聚小菜前端的困惑、沉淀与方法路径，给团队带来更多创作成就感</li>\n<li>从更多视角侧切进入团队管理/技术演进/个人成长的过程中，探讨工程师团队的价值最大化</li>\n</ul>\n<p>如果大家感兴趣，我们小菜前端团队，会集体智慧共同凝聚，一起撰写并推出一本偏前端职业生涯、技术成长和团队成长的小册，回馈给大家，大家在文后记得留言评论和提需求哦，还有别忘了加 Scott 微信哈： codingdream。</p>\n<p>作者：Scott\n链接：<a href=\"https://juejin.im/post/5cc04ecef265da03973ab107\">https://juejin.im/post/5cc04ecef265da03973ab107</a>\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</div>","title":"技术栈：为什么 Node 是前端团队的核心技术栈","last_reply_at":"2019-04-29T07:55:21.256Z","good":false,"top":false,"reply_count":8,"visit_count":2173,"create_at":"2019-04-26T06:37:35.385Z","author":{"loginname":"huanglong","avatar_url":"https://avatars1.githubusercontent.com/u/670360?v=4&s=120"}},{"id":"5cc3ae1fa86ae80ce64b4904","author_id":"528a32b1d2b3893f2a6aceeb","tab":"ask","content":"<div class=\"markdown-text\"><p>RT</p>\n</div>","title":"Node 10.0 之后 express 也可以 async/await 了，那么koa2还有存在的意义吗","last_reply_at":"2019-04-29T06:00:54.164Z","good":false,"top":false,"reply_count":7,"visit_count":1173,"create_at":"2019-04-27T01:19:27.789Z","author":{"loginname":"Hanggi","avatar_url":"https://avatars2.githubusercontent.com/u/5997900?v=4&s=120"}},{"id":"5cc5c70a37faec0ce1d07c39","author_id":"5bf3cec8e6481c5709f5d871","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fupbpm2nJQFXTMVU9FK8dYVMPOFe\" alt=\"1.png\"><img src=\"//static.cnodejs.org/FmS8pA3EKJkqQjNZUnEb1iuxUL-G\" alt=\"2.png\"><img src=\"//static.cnodejs.org/Ft-SQYR6m5C61cq3ZkI5fLhBjBYr\" alt=\"WechatIMG116.png\"><img src=\"//static.cnodejs.org/FvYCjEfX667emIyE-hbclYFUVZlq\" alt=\"WechatIMG117.png\"></p>\n<h3>平时都好好的。未知下午出现这个情况。很头疼！严重影响开发。哪位大佬是否遇到过</h3>\n</div>","title":"vue.cli3.0代理后接口没有返回，浏览器内存攀升，页面卡死。请问这是什么情况，哪位大佬知道。","last_reply_at":"2019-04-29T04:33:33.808Z","good":false,"top":false,"reply_count":3,"visit_count":569,"create_at":"2019-04-28T15:30:18.914Z","author":{"loginname":"tzbcf","avatar_url":"https://avatars1.githubusercontent.com/u/25059314?v=4&s=120"}},{"id":"5cc3ceb3a86ae80ce64b49bd","author_id":"5520a425ce156cc206687c5c","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/zhangkaiyulw/seedgoose\">Seedgoose</a> 支持自动id。</p>\n<p>不管用什么seed工具，seed数据的时候，关联是最让人头疼的。</p>\n<p>Seedgoose让关联没有烦恼。</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;_id&quot;: &quot;jack&quot;,\n  &quot;age&quot;: 20,\n  &quot;school&quot;: &quot;no1 middle school&quot;\n}\n</code></pre><pre class=\"prettyprint language-json\"><code>{\n  &quot;_id&quot;: &quot;no1 middle school&quot;,\n  &quot;name&quot;: &quot;No. 1 Middle School&quot;\n}\n</code></pre><pre class=\"prettyprint language-bash\"><code>seedgoose seed\n</code></pre><p>功能如你所想。</p>\n</div>","title":"mongoose最好用的seeder","last_reply_at":"2019-04-29T04:29:25.472Z","good":false,"top":false,"reply_count":4,"visit_count":580,"create_at":"2019-04-27T03:38:27.808Z","author":{"loginname":"cheunghy","avatar_url":"https://avatars0.githubusercontent.com/u/3055936?v=4&s=120"}},{"id":"5cc182f937faec0ce1d06a78","author_id":"5a9ded34be0ec087668bcd0d","tab":"ask","content":"<div class=\"markdown-text\"><p>有的语言可以 <code>from 'package' import sth</code></p>\n<p>js则是 <code>import { sth} from 'package'</code> ,要有提示只能先把 package 码了,再移光标回前面.</p>\n<p>我用的 vscode,大家伙有啥办法解决这个蛋疼的问题吗?</p>\n</div>","title":"import from语法顺序很蛋疼,有什么办法解决吗?","last_reply_at":"2019-04-29T03:53:34.303Z","good":false,"top":false,"reply_count":19,"visit_count":1325,"create_at":"2019-04-25T09:50:49.176Z","author":{"loginname":"abiuDoIT","avatar_url":"https://avatars2.githubusercontent.com/u/30167501?v=4&s=120"}},{"id":"5a328967d92f2f5b185ace96","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><p>本来不想回复的，匿名的那哥们写的挺好的，虽然不懂他为什么要匿名。但看到某些回复，不得不说几句。乱解读，误人子弟的事，还是有必要澄清的，以免Node有无端被黑，相信这也是所有布道者都应该承担这种除魔卫道的责任。</p>\n<blockquote>\n<p>没有领袖，Node 之父用 Go，TJ 也用 Go，都跑了。</p>\n</blockquote>\n<ol>\n<li>语言不是因素，是他想做的事儿变了，但他的心依然还是爱着Koa</li>\n</ol>\n<p>TJ转做Go有很多原因</p>\n<ul>\n<li>人家做的基于aws Lambda的基础设施 <a href=\"https://github.com/apex/apex%EF%BC%8C%E9%80%89%E6%8B%A9Go%E6%97%A0%E5%8F%AF%E5%8E%9A%E9%9D%9E%EF%BC%8C%E4%BB%8E%E6%9E%B6%E6%9E%84%E8%A7%92%E5%BA%A6%EF%BC%8C%E6%88%91%E8%BF%98%E8%A6%81%E7%BB%99%E4%BB%96%E7%82%B9%E8%B5%9E%EF%BC%81\">https://github.com/apex/apex，选择Go无可厚非，从架构角度，我还要给他点赞！</a></li>\n<li>TJ对Node.js一直很关注，尤其对Koa框架，看他的Pinned repositories 就知道，另外给Koa提issue被他怼过，也可见他很在意Koa</li>\n</ul>\n<p>别乱解读，误人子弟</p>\n<ol>\n<li>Node.js之父在2012年就离开社区的，然而这5年发展的依然很好</li>\n</ol>\n<p>狼叔写过一篇文章 <a href=\"https://cnodejs.org/topic/59daf46f2543cb3368b1627e\">请别拿“死”人做文章</a>，\nNode.js之父Ryan Dahl在2012年就离开社区的，我们必须要承认他作为创始人的伟大创举，但不能标签化，ryan不代表node，从他离开社区后，对于社区而言，他就“死”在曾经的丰功伟绩上，未来与他无关！</p>\n<p>Node.js之父在2012年就离开社区的，然而这5年发展的依然很好，并无影响。这篇文章本来没什么问题，但有些人借位营销就恶心了。</p>\n<p>狼叔说：Node.js不是最好，也不是最差，是性价比比较高的，可惜node做后端一直不温不火，java，php利益相关，只有新项目用，微服务架构下，会更好一些。很多人node是用错的，不是用node就什么都用，分清场景。不误解，不传谣，合适自己的才是最好的\n但是总有些人想拿这事儿做文章过度解读，</p>\n<blockquote>\n<p>抽象程度不够高，对于做业务的人来说这很痛苦。使用者中小白太多，人员素质参差不齐，包的数量多，质量却呵呵。</p>\n</blockquote>\n<p>这完全是没逻辑的屁话，看起来没问题，却经不起推敲。</p>\n<p>抽象程度，所有语言都有这个问题，Go就没有么？Java、PHP这么多年小白少么？说人员素质参差不齐，哪个语言不一样？所以说，这完全是狗屁逻辑。我比较喜欢Ruby社区，是高手和低手两级分化最明显。Node.js从2009年到现在才8年，再成熟能成熟到哪里呢？不拿一个起点比较都是扯淡。</p>\n<p>最后说npm，黑的完全不到点上，目前超过60万个模块，绝对是社区第一。在众多包管理器上，我没见过质量都一样好的，按照8020原则，60万里至少有12万个模块是不错的吧，你工作中能用到的会超过三位数么？</p>\n<p>所以说质量好不好要看人怎么选，而不应该赖到npm上。长点心吧。</p>\n<blockquote>\n<p>用来做脚本倒是没啥问题，做商业开发就处处踩坑了。我没怎么用 Node做 Web，因为怕 hold 不住。</p>\n</blockquote>\n<p>没用过，就别瞎逼逼。</p>\n<p>国内国外的成功案例，眼瞎看不到么？我亲历的去哪儿和阿里都在大量使用，我亲耳听到的腾讯大量使用Node，对于李成银所在的360团队也是大量使用。</p>\n<p>如果说 Node hold 不住，其他语言就能 hold 住？呵呵</p>\n<p>如果说 人 hold 不住，那我相信，那是水平问题。</p>\n<blockquote>\n<p>目前 Node Web 框架依然是 koa 和 express 类似的架构，中间件没什么问题，但是如何组织它们，如何在 high level 层面把控他们却没有看到很好的最佳实践。</p>\n</blockquote>\n<p>没用Node还哔哔框架，不是打脸么？</p>\n<p>我们可以根据框架的特性进行分类</p>\n<table>\n<thead>\n<tr>\n<th>框架名称</th>\n<th>特性</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Express</td>\n<td>简单、实用，路由中间件等五脏俱全</td>\n<td>最著名的Web框架</td>\n</tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor</td>\n<td>同构</td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高</td>\n</tr>\n<tr>\n<td>Sails、Total</td>\n<td>面向其他语言，Ruby、PHP等</td>\n<td>借鉴业界优秀实现，也是 Node.js 成熟的一个标志</td>\n</tr>\n<tr>\n<td>MEAN.js</td>\n<td>面向架构</td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点</td>\n</tr>\n<tr>\n<td>Hapi和Restfy</td>\n<td>面向Api &amp;&amp; 微服务</td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器</td>\n</tr>\n<tr>\n<td>ThinkJS</td>\n<td>面向新特性</td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右，新版v3.0是基于Koa v2.0的作为内核的</td>\n</tr>\n<tr>\n<td>Koa</td>\n<td>专注于异步流程改进</td>\n<td>下一代Web框架</td>\n</tr>\n<tr>\n<td>Egg</td>\n<td>基于Koa，在开发上有极大便利</td>\n<td>企业级Web开发框架</td>\n</tr>\n</tbody>\n</table>\n<p>各种框架都经过大厂小厂实践，别的语言实现的我敢说Node都有了。还有什么所谓的更好实践，从2005年rails横空出世之后，大部分框架都是借鉴ROR，Node就算没有走到最前面，至少没有落后于最佳实践，否则，请给出，否则，请闭嘴，别瞎逼逼。</p>\n<blockquote>\n<p>大公司也是相继开发自己基于 koa 的框架。</p>\n</blockquote>\n<p>悖论，去哪儿的基于Express用的杠杠的，无任何问题。Node不缺Web框架，Koa虽好，但迁移各种还需要时间，未来是变化的，Koa能否一统天下还犹未可知。可以肯定的是Koa在异步流程控制做的改进，命名为Node下一个Web框架是不过分的。</p>\n<p>比如micro，比如fastify，非常多好东西。</p>\n<blockquote>\n<p>不过在我一个 Rails 使用者的眼里，这些框架还是不够 high level如果性能要求高，我的选择肯定是 Go 而不是 Node。</p>\n</blockquote>\n<p>用rails的人还考虑性能么？我不是黑ror的朋友们。rails这样的神器足够好，即使ruby以前性能那么不好，但不影响人家开发很多世界级应用啊。尽管后面有的被替换了，但又怎样呢？做ror的高手技能都非常全面，ruby和前端和运维都是极其的熟练。当然Node和go也有这样的人，但普遍偏弱，这不是人的问题，而是产生的时间较短，没背景的人就不能出现全栈牛逼的能力。</p>\n<p>如果真追求性能，我建议用rust写，如果还想牛逼，用c写，最好顺便把操作系统也写了。</p>\n<p>人还是要有自知之明，做应用软件和系统软件是不一样的思维。傻逼才只看性能呢。</p>\n<blockquote>\n<p>Node 除了亲 JS 好像对我没啥吸引力。但是如果公司非要用我也不反对，大不了自己摸爬滚打找出最佳实践即可。</p>\n</blockquote>\n<p>没用过，请绕过。我特别尊重苏千和朴灵，推动Node在阿里落地，比如苏千做的cnpm真是功德无量，比如Egg，能够统一全公司的资源去推动框架落地，可预见大公司阻力。朴灵的alinode解决了性能调优的问题，内部使用的经验沉淀，对外提供付费服务。</p>\n<p>这是人物。做的比说的多，低调如此，也不去惹是非。用德艺双馨形容不为过。</p>\n<blockquote>\n<p>Node 还有一个好处是 UI 做的好，比如 pm2，比如调试器，毕竟是前端，但这些都不是杀手级的卖点呀。我不是挑语言的开发者。</p>\n</blockquote>\n<p>Node 和 UI有关系么？呵呵呵</p>\n<blockquote>\n<p>Node 对我属于一个可用可不用位置。不过相信牛逼的你肯定可以玩转 Node。加油吧少年。我对Node新人的建议是玩一玩可以，</p>\n</blockquote>\n<p>没用过，就别瞎逼逼。</p>\n<p>js已经横跨3端，pc/h5，移动端（hybrid和组件化），pc client（nw.js和electron，atom和vscode体验还不错）</p>\n<p>Node补足了js服务端的补足，比如io，比如过于依赖浏览器。</p>\n<ul>\n<li>1）初衷，server端，不想成了前端开发的基础设施</li>\n<li>2）命令行辅助工具，甚至可以是运维</li>\n<li>3）移动端：cordova，pc端：nw.js和electron</li>\n<li>4）组件化，构建，代理</li>\n<li>5）架构，前后端分离、api proxy</li>\n<li>6）性能优化、反爬虫与爬虫</li>\n<li>\n<ol>\n<li>全栈最便捷之路</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>不过要早点转 Go，因为 Node 并没有什么突出的优势。</p>\n</blockquote>\n<p>Go在服务器端，并发模型上确实很好。做后端是极好的选型。但在前后端分离或者单体应用里，真的合适么？</p>\n<p>前面说了，性能并不是继续选型的唯一因素，不然ror那些牛人早转了。我一直的看法是前端离不开node，api层node有优势，io密集和脚本动态，做api组装聚合类的非常合适。对于后端服务，Node也是可以的，不过这时的node和go是一样的，尤其是上了微服务架构，服务是独立的，和语言无关，按照其特性选就好了，何必扯一些没用的。</p>\n<p>最后说一下Node全栈</p>\n<p>每次演讲我会都问大家是不是前端，回答“是”的人非常多，我会开玩笑的恭喜大家：“现在的前端就是钱端”，确实，现在前端发展异常的快，而且没有趋向于类比java里ssh框架的那种稳定，所以未来很长一段时间，还会增长，持续混乱，这对前端来说是把双刃剑，一方面有很强的压迫感，不学习就跟不上时代，另一方它也是机遇，能够带给更多机会，包括money。</p>\n<p>大家都疑惑的一个问题是如何在这样巨变的时代能够通过学习来应变，我可以很负责的告诉大家，没有捷径，但通过掌握 Node.js 能够让你降低这个学习曲线而已，毕竟Node.js是大前端的基础设施。大家可以看一下，前端的开发过程，模块化，构建，辅助工具，调优，架构调整，可以说Node.js是无处不在的。</p>\n<p>其实，辅助大前端开发只是Node.js的一个非常无心插柳的衍生功能，通过掌握Node.js能够让你能做的更多、获得的更多，甚至可以说有更多自我实现的快乐，在后面的章节会详细讲解Node.js的具体应用场景好处，这也是本书名字里“更了不起的”要去阐述的内容。</p>\n<p>综上种种，就是我一直提倡以 JavaScript 语言为中心的 <code>Node全栈</code> 概念的缘由，JavaScript 覆盖所有前端，Node.js 擅长做 I/O 密集型的后端，外加辅助开发的各种基础设施，无疑是工作、学习和成为快速掌握全栈技术最好的途径。你会的越多，你能做的就更多，你的人生也将会有不一样的精彩篇章。</p>\n<h1>补充</h1>\n<h2>没有领袖？</h2>\n<p>笑死了，根本就是外行，Node的接力棒是 TJ 和 sindresorhus ？ryan走了， Isaac Schlueter接✋的好么，然后是TJ Fontaine。之后闹出了iojs分裂问题，后来促使joyent不得不妥协，成立Node基金会。\n现在是纯社区玩法，背后是Node基金会。</p>\n<p>可以说，任何人离开都不会有特别大影响。铁打的营盘流水的兵，而已。</p>\n<p>TJ是想对Node改进的，但Node的负担太重了，现有体系和机制改变不是易事，而且也没有动力促使它改变。很多特性都是意淫的，根本不是Node设计的场景，所以说这些没意义。响马大哥的fibjs就是一个不错的实践，但为什么二者不融合呢？。。。。因为没法真的没法这样做。。。</p>\n<h2>拿 express 和 Rails 对比，是一样东西么？</h2>\n<blockquote>\n<p>我知道不能把 Node 跟 Rails 一起比，因为一个是平台，一个是框架。那我就详细拿 express 和Rails 比吧。express 可以说是提供了一个 RESTful API + MVC 的框架，本身既没有 orm 也没有提供各方面的脚手架（对比 Rails 的 scaffold）也没有提供任何主观性的集成（比如你需要自己搭建测试框架）</p>\n</blockquote>\n<p>进一步暴漏无知。express本身只是内核加了几个实用中间价的微型框架。Rails呢？是一个一站式的顶级Web框架。rails在2005年横空出世，node是2009年产生，exprss是2010年才有，这个比较客观么？</p>\n<p>谬误1:express 可以说是提供了一个 RESTful API + MVC 的框架</p>\n<p>a）谁说express是RESTful API了？</p>\n<p>明显要自己规约才能实现的，这也意淫到express上。。。sinatra呢，beego，Revel，Martini呢？</p>\n<p>express上实现rest可以，但不能这叫。</p>\n<pre class=\"prettyprint\"><code>var express = require(&#x27;express&#x27;);\nvar router = express.Router();\n\nvar $ = require(&#x27;..&#x2F;controllers&#x2F;users_controller&#x27;);\n\n&#x2F;&#x2F; -- custom\n\n&#x2F;**\n * Auto generate RESTful url routes.\n *\n * URL routes:\n *\n *  GET    &#x2F;users[&#x2F;]        =&gt; user.list()\n *  GET    &#x2F;users&#x2F;new       =&gt; user.new()\n *  GET    &#x2F;users&#x2F;:id       =&gt; user.show()\n *  GET    &#x2F;users&#x2F;:id&#x2F;edit  =&gt; user.edit()\n *  POST   &#x2F;users[&#x2F;]        =&gt; user.create()\n *  PATCH  &#x2F;users&#x2F;:id       =&gt; user.update()\n *  DELETE &#x2F;users&#x2F;:id       =&gt; user.destroy()\n *\n *&#x2F;\n\nrouter.get(&#x27;&#x2F;new&#x27;, $.new);  \nrouter.get(&#x27;&#x2F;:id&#x2F;edit&#x27;, $.edit);\n\nrouter.route(&#x27;&#x2F;&#x27;)\n  .get($.list)\n  .post($.create);\n\nrouter.route(&#x27;&#x2F;:id&#x27;)\n  .patch($.update)\n  .get($.show)\n  .delete($.destroy);\n\n\nmodule.exports = router;\n</code></pre><p>b）谁说express是MVC了？</p>\n<p>express目录有router和view就算mvc了？呵呵，看看rails，thinkjs，eggjs行么？</p>\n<pre class=\"prettyprint\"><code>├── app.js\n├── bin\n│   └── www\n├── package.json\n├── public\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n│       └── style.css\n├── routes\n│   ├── index.js\n│   └── users.js\n└── views\n    ├── error.jade\n    ├── index.jade\n    └── layout.jade\n\n7 directories, 9 files\n</code></pre><p>c）谁说express是和rails一样的框架了？</p>\n<p>你可以这也理解express只是内核（插件机制） + 几个常用插件。是一个麻雀虽小，五脏俱全的微型框架。一个连基本约定，orm，脚手架，migrate都没有的框架也算框架？</p>\n<p>express不会直接使用的。大部分情况都是要自己封装的，如果说直接拿express-generator做事儿，做分析的，那真是用浅尝辄止形容不为过。</p>\n<p>d）说express不如rails</p>\n<p>确实不如，本来就不是一样的东西。ruby诞生自93年，rails诞生2005年，node和express呢？</p>\n<p>起点不一样，比较有意义么？</p>\n<h2>Node哲学 与 Left-pad事件始末，真了解？</h2>\n<blockquote>\n<p>Node 社区的哲学是可以把 left pad 作为一个包，这看起来真的很傻。</p>\n</blockquote>\n<p>明明不知道事件始末就乱发表意见，是否得当？是够傻的。</p>\n<p>2016年3月份，kik是Azer写的模块，但Kik同时是手机通信录的社交软件，所以这个社交软件上就无耻的直接说让Azer把kik名字给他们，Azer不同意，他们就拿律师函恐吓，并让npm妥协，所以npm就妥协了</p>\n<p>Azer一怒之下将自己在 npm 上的 273 个封包全部撤下，其中就包括 left-pad 封包。一石激起千层浪，依赖 left-pad 的上千个项目包括 babel 和 react-native 瞬间崩溃。大量开发者看着自己项目构建失败，顿时被吓尿。</p>\n<p>观点</p>\n<ul>\n<li>\n<p>1）就没见过这么傻逼的公司，一个红包就能解决的事儿，非要用强权，如果对方在改模块上耗费心血少的话，转给你也是可以商量的。</p>\n</li>\n<li>\n<p>2）11行代码要不要封装成一个包？</p>\n</li>\n</ul>\n<blockquote>\n<p>sindresorhus: Containing complexity is not about putting everything in one-line functions/modules.</p>\n</blockquote>\n<p>社区一致认可的结论：你的模块必须含有一定的复杂性，不然就没啥意义了。</p>\n<ul>\n<li>3）npm上那么多个模块，大多数都是无意义的吧？</li>\n</ul>\n<p>从我开始讲<a href=\"https://github.com/i5ting/nodejs-fullstack\">Node.js全栈</a>大约是3月份，那是npm上是25.6万个吧，截止到2017年3月是45万个，我想说的是那个包仓库都是有好有坏，按照80/20原则，数量是也是相当可观的。总比那些某些语言连包管理机制都不完善的要强太多了吧！</p>\n<ul>\n<li>4）<a href=\"http://blog.npmjs.org/post/141905368000/changes-to-npms-unpublish-policy\">迫使npm调整了撤销策略</a>，模块一旦发布，24小时之后就不让撤销了</li>\n</ul>\n<blockquote>\n<p>If the version is less than 24 hours old, you can unpublish it. The package will be completely removed from the registry.</p>\n</blockquote>\n<h2>这世界是完美的？</h2>\n<pre class=\"prettyprint\"><code>没用过别逼逼我不同意，我在做新的项目之前仔细对比了 Node Web 框架与其他框架，发现 Node 的上述问题，才使用了别的。\n我不认为我一定要用过之后再来逼逼。\n你也是做过项目的，知道如果一个项目做毁了会有多大损失，我不会为了来逼逼而去做毁一个项目。\n如果你技术一般，我建议你先别用 Node，因为会让你的技术更一般。\n如果你技术很牛，我不需要建议你什么，你牛你先说。\n</code></pre><p>没用过就是没用过，很多精髓的东西如果停留在表面，是不是太肤浅了？哪个框架是完美的？了解敏捷么？敏捷的基础认知是什么？</p>\n<p>从上面那express和rails比，从对express是rest+mvc的描述，暴漏对node了解太浅。如果说想黑node，我再帮你补二刀，早年robbin范凯，一直在黑node的回调地狱，可是又如何呢？该有多人用还是有多少人用</p>\n<p>有种你别装，装了就别瞎比比，既想当婊子，又想立牌坊吗？</p>\n<p>至于项目能否做成功，我并不认为是技术的问题。更多的是你对技术的熟练程度，哪个熟悉就用哪个，你哪个自己不熟悉的，做毁了，然后来骂框架，骂语言？这也是神逻辑啊。</p>\n<p>狼叔经常说：“少抱怨，多思考，未来更美好”，适用于所有人。</p>\n<h2>人员参差不齐要说人员参差不齐， Node 社区说第二，有哪个敢说第一？</h2>\n<pre class=\"prettyprint\"><code>PHP 好歹也是专注 Web 后台。Node 可笑的地方在于一群前端以为自己会后端就来写 Web 后台。我没有数据支持，但是我就是这么认为的。\nJava 后台的新人也是第一天就会专注于后台方面的学习。\n当然这并不能作为你不使用 Node 的原因，如果你是大神，你不会在乎这个社区有多少小白的。但是我前面也说了，我关注的大神都从 Node 社区走了啊。我为什么还要进 Node 社区……\n阿里的苏千我在阿里的时候也有向他请教 Node 方面的知识，我从未否认他们的贡献，不过我并不会因此捧 Node。\n</code></pre><p>PHP专注于Web 后台，我估计看了这话，鸟哥会哭的很伤心的。Node的人不是可笑，是有追求，慢慢写着写着就在成长。</p>\n<p>Java 后台的新人也是第一天就会专注于后台方面的学习？呵呵，没学Java么？去看看core java吧，上来学后台，没见过。</p>\n<p>关注的大神都从 Node 社区走了，这话更扯淡。哪个社区不是这样的？不同年龄，职位，人生阶段，关注点会不一样的。比如严清zensh就从node转了go，人家职位也不一样了。再有说话不要用“都”，我举个例子朴灵，<a href=\"https://cnodejs.org/user/JacksonTian%EF%BC%8C%E5%A4%A7%E5%AE%B6%E5%8E%BB%E7%9C%8B%E7%9C%8B%E4%BB%96%E7%9A%84%E6%9C%80%E8%BF%91%E5%8F%82%E4%B8%8E%E7%9A%84%E8%AF%9D%E9%A2%98%EF%BC%8C10%E5%A4%A9%E5%89%8D%E7%9A%84%E3%80%82https://cnodejs.org/topic/5a20be0a110a338547d6e371#5a24c72b9178b0a14ac01e1b\">https://cnodejs.org/user/JacksonTian，大家去看看他的最近参与的话题，10天前的。https://cnodejs.org/topic/5a20be0a110a338547d6e371#5a24c72b9178b0a14ac01e1b</a></p>\n<p>最后，再说一件事儿，别老贴金，进了阿里不代表什么，马云说了，三年以上才算阿里人，才有阿里味。向玉伯，寒冬，苏千，朴灵，天猪等大大们致敬。</p>\n<h2>Hold 不住？</h2>\n<blockquote>\n<p>Node 呢，请问我该用什么数据库？用什么 ORM？用什么模板语言？用什么做后台任务？如何监控内存？如何分析日志？如何做分布式？如何做安全？有些人看说用 Node 做业务速度快，Node 的框架就做那么点低层次的封装，能不快吗？你把各种中间件加完试试？每个领域都要自己去找最佳实践，然后自己集成起来。</p>\n</blockquote>\n<p>先不论对node和express等理解错误的问题。</p>\n<p>先看狼叔之前的回复 <a href=\"https://www.zhihu.com/question/263855387/answer/273769595\">https://www.zhihu.com/question/263855387/answer/273769595</a></p>\n<p>一般，后端开发指的是 <code>Web</code> 应用开发中和视图渲染无关的部分，但现在架构升级，<code>Node</code> 承担了前后端分离重任之后，有了更多玩法。从带视图的传统 <code>Web应用</code> 和 <code>面向Api接口应用</code>，到通过 <code>RPC</code> 调用封装对数据库的操作，到提供前端 <code>Api</code> 代理和网关，服务组装等，统称为后端开发，不再是以往只有和数据库打交道的部分才算后端，这样，就可以让前端工程师对开发过程可控，更好的进行调优和性能优化。</p>\n<p>对Node.js来说，一直没有在后端取得其合理的占有率。原因很简单</p>\n<ul>\n<li>\n<p>1）利益分配，已有实现大多是Java或者其他语言，基本是没法撼动的，重写的成本是巨大的，另外，如果用Node写了，那么那些写Java的人怎么办？抢人饭碗，这是要拼命的。</p>\n</li>\n<li>\n<p>2）Node相对年轻，大家对Node的理解不够，回调和异步流程控制略麻烦，很多架构师都不愿意花时间去学习。尽管在Web应用部分处理起来非常简单高效，但在遇到问题时并不容易排查定位，对开发者水平要求略高。</p>\n</li>\n<li>\n<p>3）开发者技能单一，很多是从前端转过来的，对数据库，架构方面知识欠缺，对系统设计也知之不多，这是很危险的，有种麻杆打狼两头害怕的感觉。</p>\n</li>\n<li>\n<p>4）Node在科普、培训、布道等方面做的并不好，国外使用的非常多，国内却很少人知道，不如某些语言做得好。</p>\n</li>\n</ul>\n<p>了不起是个不能随便说的词儿，对于 Node.js 来说，简化并发编程，用了不起来形容并不过分，在2009年横空出世时，确实是独一无二的。但在今天，已经8岁的 Node.js 有了更多、更为广泛的应用场景，它已经远远大于当初设计时的初衷了，我觉得用更了不起来形容已经不过分了！</p>\n<p>你这个问题，很明显暴漏了自己的问题就是上面的原因之3。</p>\n<blockquote>\n<p>开发者技能单一，很多是从前端转过来的，对数据库，架构方面知识欠缺，对系统设计也知之不多，这是很危险的，有种麻杆打狼两头害怕的感觉。</p>\n</blockquote>\n<p>不懂架构，不懂数据库，还没有明白人带，那你用啥框架，语言能好呢？</p>\n<ul>\n<li>1）复用已有基础设施，很明显比自己造轮子好。别动不动就java已死，xx已死的，冰冻三尺非一日之寒</li>\n<li>2）微服务架构下，你需要多复杂？</li>\n</ul>\n<p>不懂不可怕，别装懂。</p>\n<h2>UI 是 User Inferface，意思是 Node 社区做的工具的外观（UI）都很漂亮。</h2>\n<blockquote>\n<p>pm2 的 UI（命令行界面）我就很喜欢，Node 内容 Chrome 调试（界面）我也很喜欢，这是 UI，我不是说 GUI。程序员之间说 UI 难道不是既包括 GUI 又包括 CLI 吗？这只是对于术语的误解而已，不重要。</p>\n</blockquote>\n<p>各位看官自己判断这句话吧。</p>\n<h2>所以 NodeJS 社区很明智，多多模仿其他成熟框架是对的。但我直接去看你模仿的框架就好。？</h2>\n<p>举例，我想学日语，结果发现日语里有汉语的影子，于是我去学了汉语？是这逻辑么？</p>\n<p>水是原子组成的，干嘛喝水呢？去喝原子啊，反正有很多途径。。。</p>\n<h2>JS 全栈</h2>\n<blockquote>\n<p>我不知道这有什么意义？为了全栈而全栈？Java 二十年前也有一样的口号，然后呢？而且 JS 现在已经很奇怪了。</p>\n</blockquote>\n<p>目前看js是最容易实现全栈的途径，没有之一。我很喜欢ror，但同时学2种还是略难。其他就更不要说了。Java是跨平台，能和JS一样么？你真的了解从applet到awt到swing到他们衰亡的历史么？不见得吧，说话还是要有理有据的。</p>\n<p>全栈是信仰，是一种积极的人生态度。何谓为了全栈而全栈?我看到的更多的是大家积极的学习，努力的向提高成长。在技术变化如此快的今天，我们不是更该如此么？我尊重每一个有全栈信仰的人，我也祝福你们，未来是你们的。</p>\n<p>关于语言他回复的2个点</p>\n<ul>\n<li>我对Node新人的建议是玩一玩可以，不过要早点转 Go，因为 Node 并没有什么突出的优势。</li>\n<li>我宁愿用 Java 都不会用 Node.js，除非工资特别高</li>\n</ul>\n<p>一会扯go，一会扯java，难道对这门语言很熟悉的？还是纯粹为了挑起语言战争？还是为了培训机构站台？</p>\n<p>大家姑妄言之，姑妄笑之就好，别认真，认真你就输了</p>\n<p>朴大说过：“为什么非要尝试去说服傻逼”，可怜之人必有可恨之处，但不容许有人黑我大Node。</p>\n</div>","title":"狼叔回复的《Node相比传统服务端技术栈好在哪里？》","last_reply_at":"2019-04-29T01:45:12.311Z","good":true,"top":false,"reply_count":29,"visit_count":10449,"create_at":"2017-12-14T14:23:35.819Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"5cc3ab1ca86ae80ce64b48eb","author_id":"580339330bab808265185e45","tab":"share","content":"<div class=\"markdown-text\"><p>源码：<a href=\"https://github.com/wtfjun/js-coi\">git仓库</a> 欢迎star &amp; fork ～～</p>\n<p>做过校验需求的小伙伴们都知道，校验其实是个麻烦事。</p>\n<p>规则多，需要校验的字段多，都给我们前端带来巨大的工作量。</p>\n<p>一个不小心，代码里就出现了不少<code>if else</code>等不可维护的代码。</p>\n<p>因此，我觉得一个团队或者是一个项目，需要一个校验工具，简化我们的工作。</p>\n<p>首先，参考一下 Joi。只看这一小段代码：</p>\n<p><code>Joi.string().alphanum().min(3).max(30).required()</code></p>\n<p>我希望我的校验工具Coi也是链式调用，链式调用可以极大的简化代码。</p>\n<p>校验呢，其实主要就3个入参：需要校验的数据，提示的错误信息，校验规则。</p>\n<p>哎 直接把代码贴出来吧，反正就一百行，一目了然：</p>\n<pre class=\"prettyprint\"><code>export default class Coi {\n    constructor(prop) {\n        this.input = prop\n        this.errorMessage = &#x27;通过校验&#x27; &#x2F;&#x2F; 错误信息\n        this.pass = true &#x2F;&#x2F; 校验是否通过\n    }\n\n    &#x2F;&#x2F; 数据输入\n    data(input) {\n        if (!this.pass) return this\n\n        this.input = input\n        return this\n    }\n\n    &#x2F;&#x2F; 必填，不能为空\n    isRequired(message) {\n        if (!this.pass) return this\n\n        if (\n            &#x2F;^\\s*$&#x2F;g.test(this.input) ||\n            this.input === null ||\n            this.input === undefined\n        ) {\n            this.errorMessage = message\n            this.pass = false\n        }\n        return this\n    }\n\n    &#x2F;&#x2F; 最小长度\n    minLength(length, message) {\n        if (!this.pass) return this\n\n        if (this.input.length &lt; length) {\n            this.errorMessage = message\n            this.pass = false\n        }\n        return this\n    }\n\n    &#x2F;&#x2F; 最大长度\n    maxLength(length, message) {\n        if (!this.pass) return this\n\n        if (this.input.length &gt; length) {\n            this.errorMessage = message\n            this.pass = false\n        }\n        return this\n    }\n\n    &#x2F;&#x2F; 需要的格式 number: 数字, letter: 字母, chinese: 中文\n    requireFormat(formatArray, message) {\n        if (!this.pass) return this\n        let formatMap = {\n            number: 0,\n            letter: 0,\n            chinese: 0\n        }\n\n        Object.keys(formatMap).forEach(key =&gt; {\n            if (formatArray.includes(key)) formatMap[key] = 1\n        })\n\n        let formatReg = new RegExp(\n            &#96;^[${formatMap.number ? &#x27;0-9&#x27; : &#x27;&#x27;}${\n                formatMap.letter ? &#x27;a-zA-Z&#x27; : &#x27;&#x27;\n            }${formatMap.chinese ? &#x27;\\u4e00-\\u9fa5&#x27; : &#x27;&#x27;}]*$&#96;\n        )\n\n        if (!formatReg.test(this.input)) {\n            this.errorMessage = message\n            this.pass = false\n        }\n        return this\n    }\n\n    &#x2F;&#x2F; 邮箱校验\n    isEmail(message) {\n        if (!this.pass) return this\n\n        const emailReg = &#x2F;^[a-z0-9]+([._\\\\-]*[a-z0-9])*@([a-z0-9]+[-a-z0-9]*[a-z0-9]+.){1,63}[a-z0-9]+$&#x2F;\n        if (!emailReg.test(this.input)) {\n            this.errorMessage = message\n            this.pass = false\n        }\n        return this\n    }\n\n    &#x2F;&#x2F; ulr校验\n    isURL(message) {\n        if (!this.pass) return this\n\n        const urlReg = new RegExp(\n            &#x27;^(?!mailto:)(?:(?:http|https|ftp):&#x2F;&#x2F;|&#x2F;&#x2F;)(?:\\\\S+(?::\\\\S*)?@)?(?:(?:(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[0-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]+-?)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]+-?)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,})))|localhost)(?::\\\\d{2,5})?(?:(&#x2F;|\\\\?|#)[^\\\\s]*)?$&#x27;,\n            &#x27;i&#x27;\n        )\n        if (!urlReg.test(this.input)) {\n            this.errorMessage = message\n            this.pass = false\n        }\n        return this\n    }\n\n    &#x2F;&#x2F; 自定义正则校验\n    requireRegexp(reg, message) {\n        if (!this.pass) return this\n\n        if (!reg.test(this.input)) {\n            this.errorMessage = message\n            this.pass = false\n        }\n        return this\n    }\n}\n</code></pre><p>使用姿势如下：</p>\n<pre class=\"prettyprint\"><code>import Coi from &#x27;js-coi&#x27;\n\nconst validCoi = new Coi()\nvalidCoi\n    .data(&#x27;1234&#x27;)\n    .isRequired(&#x27;id不能为空&#x27;)\n    .minLength(3, &#x27;id不能少于3位&#x27;)\n    .maxLength(5, &#x27;id不能多于5位&#x27;)\n\n    .data(&#x27;1234@qq.&#x27;)\n    .isRequired(&#x27;邮箱不能为空&#x27;)\n    .isEmail(&#x27;邮箱格式不正确&#x27;)\n\n    .data(&#x27;http:dwd&#x27;)\n    .isRequired(&#x27;url不能为空&#x27;)\n    .isUrl(&#x27;url格式不正确&#x27;)\n\nif (!validCoi.pass) {\n    this.$message.error(validCoi.errorMessage)\n    return\n}\n</code></pre><p>当然你只校验一个字段的话也可以这么使用：</p>\n<pre class=\"prettyprint\"><code>import Coi from &#x27;js-coi&#x27;\n\nconst idCoi = new Coi(&#x27;1234&#x27;)\nidCoi\n    .isRequired(&#x27;id不能为空&#x27;)\n    .minLength(3, &#x27;id不能少于3位&#x27;)\n    .maxLength(5, &#x27;id不能多于5位&#x27;)\n    .isEmail(&#x27;id邮箱格式不正确&#x27;)\n    .isUrl(&#x27;id格式不正确&#x27;)\n    .requireFormat([&#x27;number&#x27;, &#x27;letter&#x27;, &#x27;chinese&#x27;], &#x27;id格式不正确&#x27;)\n    .requireRegexp(&#x2F;012345&#x2F;, &#x27;id格式不正确&#x27;)\n\nif (!idCoi.pass) {\n    this.$message.error(idCoi.errorMessage)\n    return\n}\n</code></pre></div>","title":"一百行js代码实现一个校验工具","last_reply_at":"2019-04-28T15:01:31.717Z","good":false,"top":false,"reply_count":2,"visit_count":545,"create_at":"2019-04-27T01:06:36.289Z","author":{"loginname":"wtfjun","avatar_url":"https://avatars1.githubusercontent.com/u/17716658?v=4&s=120"}},{"id":"5cc584dba86ae80ce64b51ac","author_id":"59f007c928137001719a81e9","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FokXQcwJAN6D5nQj0qyPVmlwo-dC\" alt=\"QQ图片20190428184631.png\"></p>\n<p>谷歌里面 查看 vue .webpack   ?为什么 看不到 html 内容 .只能看到  js部分  ??</p>\n<p>如图所示 .这是以前写的一个项目 源码丢了.现在要重写 ,突然发现 看不了html 的内容 .</p>\n<p>#@</p>\n</div>","title":"谷歌里面 查看 vue .webpack   ?为什么 看不到 html 内容 .只能看到  js部分?","last_reply_at":"2019-04-28T10:47:55.637Z","good":false,"top":false,"reply_count":0,"visit_count":540,"create_at":"2019-04-28T10:47:55.637Z","author":{"loginname":"1016716110","avatar_url":"https://avatars2.githubusercontent.com/u/30174358?v=4&s=120"}},{"id":"55d1bd159bdae50c477e6ea1","author_id":"54914b4161491ead0cc7bee1","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint language-javascript\"><code>var mongoose = require(&#x27;mongoose&#x27;);\nvar db = mongoose.createConnection(&#x27;mongodb:&#x2F;&#x2F;xxxxxxxxxxxxxxxxx&#x2F;test&#x27;);\n\ndb.on(&#x27;error&#x27;, function(error) {\n    console.log(error);\n});\n\nvar downloadSchema = new mongoose.Schema({\n    assets :  {type: String},\n    body :  {type: String},\n    tag_name :  {type: String},\n    date :  {type: String},\n});\n\nvar mongooseModel = db.model(&#x27;download&#x27;, downloadSchema);\n\nmongooseModel.find(function(error,result){\n    if(error) {\n        console.log(err);\n    } else {\n        console.log(result); &#x2F;&#x2F; result 为空\n    }\n    db.close();\n});\n</code></pre><p>第一次用mogoose,搞了很久都没搞定,不知道原因出在哪里</p>\n</div>","title":"mongoose查询不出来数据?","last_reply_at":"2019-04-28T08:36:31.246Z","good":false,"top":false,"reply_count":8,"visit_count":4447,"create_at":"2015-08-17T10:53:09.960Z","author":{"loginname":"w88975","avatar_url":"https://avatars.githubusercontent.com/u/5819351?v=3&s=120"}},{"id":"5cc2745c37faec0ce1d06e67","author_id":"5b03c9a7000332b81cf821a5","tab":"ask","content":"<div class=\"markdown-text\"><p>在V8的性能分析日志中有这个术语，但是这个术语是什么意思呢？</p>\n</div>","title":"V8，什么是lazy compile？","last_reply_at":"2019-04-28T08:04:12.256Z","good":false,"top":false,"reply_count":1,"visit_count":678,"create_at":"2019-04-26T03:00:44.346Z","author":{"loginname":"linxiaoziruo","avatar_url":"https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"}},{"id":"5addecaaa7d228c16b9871e1","author_id":"5933d569bce3132e4bb4f8d5","tab":"share","content":"<div class=\"markdown-text\"><p>有兴趣可以看看 <a href=\"https://github.com/yviscool/egg-pig\">egg-pig</a></p>\n</div>","title":"把 nest 的 pipe/guard/interceptor 移植到了 egg","last_reply_at":"2019-04-28T07:44:29.852Z","good":false,"top":false,"reply_count":4,"visit_count":1275,"create_at":"2018-04-23T14:24:42.809Z","author":{"loginname":"yviscool","avatar_url":"https://avatars2.githubusercontent.com/u/20163909?v=4&s=120"}},{"id":"5cc5498b37faec0ce1d07928","author_id":"5cc546de37faec0ce1d0790a","tab":"share","content":"<div class=\"markdown-text\"><h3>功能列表：</h3>\n<ul>\n<li>转换，编辑和生成Markdown表格、CSV、JSON、XML、YAML、SQL、HTML表格、Excel和LaTeX表格</li>\n<li>可视化表格创建器</li>\n<li>类似于Excel的表格编辑器，同时支持键盘和鼠标操作</li>\n<li>提取网址中的表格</li>\n<li>LaTex table生成器</li>\n<li>自定义输出模板（IDEA）</li>\n<li>压缩XML、JSON、HTML等</li>\n</ul>\n<h3>截止v1.0.9，支持下面这些格式的转换</h3>\n<h5>1. Excel 转换器</h5>\n<ul>\n<li>将Excel转换为Markdown表格</li>\n<li>将Excel转换为CSV/TSV</li>\n<li>将Excel转换为JSON</li>\n<li>将Excel转换为XML</li>\n<li>将Excel转换为YAML</li>\n<li>将Excel转换为create表格 SQL and insert SQL</li>\n<li>将Excel转换为HTML表格</li>\n<li>将Excel转换为LaTex表格</li>\n<li>将Excel转换为Plain Text表格</li>\n</ul>\n<h5>2.URL 转换器</h5>\n<ul>\n<li>将URL转换为Markdown表格</li>\n<li>将URL转换为CSV/TSV</li>\n<li>将URL转换为JSON</li>\n<li>将URL转换为XML</li>\n<li>将URL转换为YAML</li>\n<li>将URL转换为create表格 SQL and insert SQL</li>\n<li>将URL转换为HTML表格</li>\n<li>将URL转换为Excel</li>\n<li>将URL转换为LaTex表格</li>\n<li>将URL转换为Plain Text表格</li>\n</ul>\n<h5>3. HTML表格 转换器</h5>\n<ul>\n<li>将HTML表格转换为Markdown表格</li>\n<li>将HTML表格转换为CSV/TSV</li>\n<li>将HTML表格转换为JSON</li>\n<li>将HTML表格转换为XML</li>\n<li>将HTML表格转换为YAML</li>\n<li>将HTML表格转换为create表格 SQL and insert SQL</li>\n<li>将HTML表格转换为Excel</li>\n<li>将HTML表格转换为LaTex表格</li>\n<li>将HTML表格转换为Plain Text表格</li>\n</ul>\n<h5>4.Markdown表格 转换器</h5>\n<ul>\n<li>将Markdown表格转换为CSV/TSV</li>\n<li>将Markdown表格转换为JSON</li>\n<li>将Markdown表格转换为XML</li>\n<li>将Markdown表格转换为YAML</li>\n<li>将Markdown表格转换为create表格 SQL and insert SQL</li>\n<li>将Markdown表格转换为HTML表格</li>\n<li>将Markdown表格转换为Excel</li>\n<li>将Markdown表格转换为LaTex表格</li>\n<li>将Markdown表格转换为Plain Text表格</li>\n</ul>\n<h5>5. CSV/TSV 转换器</h5>\n<ul>\n<li>将CSV转换为Markdown表格</li>\n<li>将CSV转换为JSON</li>\n<li>将CSV转换为XML</li>\n<li>将CSV转换为YAML</li>\n<li>将CSV转换为create表格 SQL and insert SQL</li>\n<li>将CSV转换为HTML表格</li>\n<li>将CSV转换为Excel</li>\n<li>将CSV转换为LaTex表格</li>\n<li>将CSV转换为Plain Text表格</li>\n</ul>\n<h5>6. JSON 转换器</h5>\n<ul>\n<li>将JSON转换为Markdown表格</li>\n<li>将JSON转换为JSON</li>\n<li>将JSON转换为XML</li>\n<li>将JSON转换为YAML</li>\n<li>将JSON转换为create表格 SQL and insert SQL</li>\n<li>将JSON转换为HTML表格</li>\n<li>将JSON转换为Excel</li>\n<li>将JSON转换为LaTex表格</li>\n<li>将JSON转换为Plain Text表格</li>\n</ul>\n<p>工具地址：<a href=\"https://tableconvert.com\">https://tableconvert.com</a></p>\n</div>","title":"一个在线表格工具","last_reply_at":"2019-04-28T06:34:51.565Z","good":false,"top":false,"reply_count":0,"visit_count":635,"create_at":"2019-04-28T06:34:51.565Z","author":{"loginname":"Fechin","avatar_url":"https://avatars2.githubusercontent.com/u/2541482?v=4&s=120"}},{"id":"5b1e20e929e6e510415b29d0","author_id":"5aed77ea1b02288048bd0cb6","tab":"share","content":"<div class=\"markdown-text\"><h1>来自<a href=\"https://github.com/shenzekun/useful-tools\">github</a> （注意github 会不定期更新，这里不再更新了）</h1>\n<h1>useful-tools</h1>\n<blockquote>\n<p>🔨 一些有用的工具网站（<strong>注意</strong>：有些网站可能需要翻墙才能看到）</p>\n</blockquote>\n<h2>浏览器兼容类🌎</h2>\n<ul>\n<li><a href=\"https://caniuse.com/\">caniuse</a> (网站开发浏览器兼容性查询)</li>\n<li><a href=\"http://browserhacks.com/\">browserhacks</a> (一些浏览器兼容写法)</li>\n</ul>\n<h2>图片类😎</h2>\n<ul>\n<li><a href=\"https://tinypng.com/\">Tinypng</a> | <a href=\"http://zhitu.isux.us/\">智图</a> (压缩图片)</li>\n<li><a href=\"http://www.biaonimeia.com/login\">标你妹啊</a> (psd 标注)</li>\n<li><a href=\"https://coolbackgrounds.io/\">Cool Backgrounds</a> (生成好看的渐变背景图)</li>\n<li><a href=\"https://carbon.now.sh/?bg=rgba(171,%20184,%20195,%201)&amp;t=seti&amp;wt=none&amp;l=auto&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=48px&amp;ph=32px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;si=false&amp;es=2x&amp;wm=false\">carbon</a> (生成类似 mac 风格的代码图片，用于分享)</li>\n<li><a href=\"https://source.unsplash.com/\">Unsplash Source</a> (生成随机图片)</li>\n<li><a href=\"https://spritegen.website-performance.org/\">CSS Sprite Generator</a> (生成雪碧图)</li>\n<li><a href=\"http://www.iconfont.cn/plus\">iconfont</a> (阿里巴巴矢量图标库)</li>\n<li><a href=\"https://icons8.com/preloaders/\">Preloaders</a> | <a href=\"https://loading.io/\">LOADING.IO</a> (加载图，<strong>有些是收费的</strong>)</li>\n<li><a href=\"https://www.desktoppr.co/wallpapers\">desktoppr</a> (好看的壁纸)</li>\n<li><a href=\"https://material.io/tools/icons/?style=baseline\">Material icons</a> (Material icons图标)</li>\n<li><a href=\"https://www.iloveimg.com/zh-cn\">Iloveimg</a> (批量编辑图片的所有工具。包括压缩图片，剪裁图片，图片加水印，转化至jpg图片等等)</li>\n<li><a href=\"https://www.pkgif.net/\">pkgif</a> (任意GIF添加字幕)</li>\n<li><a href=\"https://imagecyborg.com/\">ImageCyborg</a> (一键下载当前网页的所有图片)</li>\n<li><a href=\"http://emblemmatic.org/markmaker/#/\">MarkMaker</a> (在线 logo 随机生成工具)</li>\n<li><a href=\"https://www.remove.bg/\">Removebg</a> (在线移除背景工具，想改图片的背景可以用这个，证件照必备😀)</li>\n</ul>\n<h2>代码类⌨️</h2>\n<ul>\n<li><a href=\"https://paste.ubuntu.com/\">Ubuntu pastebin</a> (代码分享)</li>\n<li><a href=\"https://codepen.io/pens/\">Codepen</a> (在线代码编辑)</li>\n<li><a href=\"http://jsbin.com/\">Jsbin</a> (在线代码编辑)</li>\n<li><a href=\"https://codesandbox.io/\">CodeSandbox</a> (在线写React,自动编译,有代码提示)</li>\n<li><a href=\"http://www.colorzilla.com/gradient-editor/\">Ultimate CSS Gradient Generator</a> (生成 css 渐变)</li>\n<li><a href=\"https://www.grabient.com/\">Grabient</a> (生成漂亮的 css 渐变)</li>\n<li><a href=\"https://dev.w3.org/html5/html-author/charref\">Character Entity Reference Chart</a> (各种符号的转义字符)</li>\n<li><a href=\"http://apps.eky.hk/css-triangle-generator/zh-hant\">css三角形产生器</a></li>\n<li><a href=\"https://easings.net/zh-cn?tuyiyi.com\">缓动函数速查表</a></li>\n<li><a href=\"https://regexper.com/\">Regexper</a> (正则可视化)</li>\n<li><a href=\"https://regex101.com/\">Regex101</a> (正则表达式测试)</li>\n<li><a href=\"https://visualgo.net/en\">Visualgo</a> (数据结构，算法可视化)</li>\n<li><a href=\"http://animista.net/\">Animista</a> (在线生成 css 动画)</li>\n<li><a href=\"https://developers.google.com/speed/pagespeed/insights/\">PageSpeed Insights</a> (测试网站速度，优化性能)</li>\n<li><a href=\"https://learngitbranching.js.org/\">Learn Git Branching</a> (以动画的形式让你学习 git)</li>\n<li><a href=\"http://asciiflow.com/\">Asciiflow</a> (生成类似代码注释里那种佛祖的代码。。自己画😄)</li>\n<li><a href=\"http://pxtoem.com/\">PXtoEM</a> (PX EM 单位换算)</li>\n<li><a href=\"http://epic-spinners.epicmax.co/#/\">epic-spinners</a> (一个好看的css loading 代码库)</li>\n</ul>\n<h2>效率类⚡️</h2>\n<ul>\n<li><a href=\"https://modao.cc/\">墨刀</a> (画原型图)</li>\n<li><a href=\"https://shimo.im/\">石墨文档</a> (多人实时协作的云端文档与表格)</li>\n<li><a href=\"https://www.hloom.com/resume-examples/\">resume-examples</a> (简历模板)</li>\n<li><a href=\"https://enhancv.com/\">Enhancv</a> (生成简历)</li>\n<li><a href=\"http://www.koppt.cn/index\">KOPPT</a> (ppt 模板)</li>\n<li><a href=\"https://about.beautiful.ai/\">Beautiful.Ai</a> (人工智能 ppt 模板创建)</li>\n<li><a href=\"https://www.canva.com/templates/\">Canva</a> (设计模板)</li>\n<li><a href=\"https://www.processon.com/;jsessionid=EC0CB59BD105F6FD0294417AB0B0CC22.jvm1\">ProcessOn</a> (在线画流程图，思维导图、UI原型图等等)</li>\n<li><a href=\"https://wakatime.com/\">WakaTime</a> (跟踪项目花费的时间，得装插件)</li>\n<li><a href=\"http://screensiz.es/\">Screen Sizes</a> (移动屏幕尺寸)</li>\n<li><a href=\"https://habitica.com/\">Habitica</a> (游戏化Todo)</li>\n<li><a href=\"https://smallpdf.com/\">Smallpdf</a> (非常厉害的一个网站，PDF压缩，PDF转PPT，Word，Excel等等都可以直接通过这个页面实现)</li>\n<li><a href=\"https://cli.im/\">草料二维码</a> (在线生成二维码)</li>\n<li><a href=\"https://ppt.baomitu.com\">声享</a> (在线制作 PPT)</li>\n<li><a href=\"https://mubu.com/\">幕布</a> (极简大纲笔记，一键生成思维导图)</li>\n<li><a href=\"https://infogram.com/\">Infogram</a> (在线图表制作工具)</li>\n<li><a href=\"https://uzer.me/\">UZER.ME</a> (能够在线使用ps，ai，office，xmind，火狐浏览器等多个应用的网站)</li>\n<li><a href=\"http://www.nicetool.net/\">NiceTool</a> (在线工具集合网站)</li>\n</ul>\n<h2>查询类🔎</h2>\n<ul>\n<li><a href=\"https://devhints.io/\">devhints</a> (常用速查表，快速查询各类框架和库的常用方法，很实用)</li>\n<li><a href=\"https://docschina.org/\">印记中文</a> (快速查询各类框架和周边库的中文文档)</li>\n<li><a href=\"https://csstriggers.com/\">Css Triggers</a> (列出了哪些CSS属性在不同的渲染引擎中是否会触发重排或重绘)</li>\n<li><a href=\"https://securityheaders.com/\">Security Headers</a> (搜索网站是否有不安全的头部 header 设置，并会评分)</li>\n</ul>\n</div>","title":"分享一些有用的工具网站","last_reply_at":"2019-04-28T06:27:43.404Z","good":false,"top":false,"reply_count":73,"visit_count":9962,"create_at":"2018-06-11T07:12:41.157Z","author":{"loginname":"shenzekun","avatar_url":"https://avatars1.githubusercontent.com/u/21151080?v=4&s=120"}},{"id":"5cc53af6a86ae80ce64b4ed6","author_id":"58018308fdf3bd3d6511866b","tab":"share","content":"<div class=\"markdown-text\"><h2>为什么需要 API 文档</h2>\n<p>目前大的环境下面，基本服务都以单体服务转换成前后端分离的服务，客户端作为调用方，服务端作为提供方需要给予到调用方通俗易懂的文档。</p>\n<h2>常见 API 文档有哪些</h2>\n<ol>\n<li><a href=\"https://github.com/GitbookIO/gitbook\">gitbook</a></li>\n</ol>\n<blockquote>\n<p>Modern documentation format and toolchain using Git and Markdown</p>\n</blockquote>\n<p><img src=\"https://uploader.shimo.im/f/45J30B4D0d4L7CWC.png!thumbnail\" alt=\"图片\"></p>\n<ul>\n<li><a href=\"https://github.com/GitbookIO/gitbook/blob/master/docs/setup.md\">Usage</a></li>\n<li>优点：\n<ul>\n<li>类似书籍的管理方式（适合写书）</li>\n<li>支持多人协作，支持保存在 Github 中</li>\n<li>支持 Build 成静态网页，部署方便</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>需要熟悉 <em>Markdown</em> 语法，不是实时生成，需要使用 <a href=\"https://github.com/GitbookIO/gitbook-cli\">Git-cli</a> 打包文件</li>\n<li>以一本书籍作为起点，只能放到单个项目中</li>\n</ul>\n</li>\n<li>总结：适合写书籍，不太适合 API 开发文档</li>\n</ul>\n<ol>\n<li><a href=\"https://github.com/jsdoc3/jsdoc\">jsdoc</a></li>\n</ol>\n<blockquote>\n<p>An API documentation generator for JavaScript.</p>\n</blockquote>\n<p><img src=\"https://uploader.shimo.im/f/UyoiKuM54H08ylGa.png!thumbnail\" alt=\"图片\"></p>\n<ul>\n<li><a href=\"http://usejsdoc.org/\">Usage</a></li>\n<li>优点：\n<ul>\n<li>功能丰富，支持引入块状注释（<a href=\"https://www.html.cn/doc/jsdoc/tags-example.html\">Block Tags</a>）</li>\n<li>功能丰富，支持内联注释（<a href=\"https://www.html.cn/doc/jsdoc/tags-inline-link.html\">Inline Tags</a>）</li>\n<li>强大的社区支持，各个平台支持 jsdocs 插件</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>有一定的学习成本，需要学习它的块状注释使用方式</li>\n<li>UI 只能单项目使用，每个项目的 DOC UI 独立</li>\n</ul>\n</li>\n<li>在线样例（<a href=\"https://github.com/SoftwareBrothers/better-docs\">b</a><a href=\"https://softwarebrothers.github.io/admin-bro-dev/index.html\">etter-</a><a href=\"https://github.com/SoftwareBrothers/better-docs\">d</a><a href=\"https://github.com/SoftwareBrothers/better-docs\">ocs</a> <a href=\"https://nhnent.github.io/tui.jsdoc-template/latest/\">tui-jsdoc-template</a>)</li>\n<li>总结：适合深度定制项目，比如说我们对外开放 API 给开发者使用。</li>\n</ul>\n<ol>\n<li><a href=\"https://github.com/Surnet/swagger-jsdoc\">swagger-jsdoc</a></li>\n</ol>\n<blockquote>\n<p>Generates swagger doc based on JSDoc.</p>\n</blockquote>\n<p><img src=\"https://uploader.shimo.im/f/fHtWq6Xh6gcnZNZm.png!thumbnail\" alt=\"图片\"></p>\n<ul>\n<li><a href=\"https://github.com/Surnet/swagger-jsdoc/tree/master/example/v2\">Usage</a></li>\n<li>优点：\n<ul>\n<li>集合 Swagger，支持按照类似 JSDoc 方式生成文档</li>\n<li>支持错误定位，如果注释书写错误，能够抛出具体的错误栈</li>\n<li>支持 <a href=\"https://github.com/Surnet/swagger-jsdoc/blob/master/docs/CLI.md\">CLI</a>，自由选择文件输出位置</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>书写格式不友好，强格式要求，对于新手来说不容易上手，官方样例较少，很多语法需要对于 Swagger YAML 格式，自己理解进行映射</li>\n<li>没有能够完成安装 JSDoc 格式来书写注释，更倾向于 YAML 文件</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><a href=\"https://github.com/SensitiveMix/doc-generators\">doc-generators</a></li>\n</ol>\n<blockquote>\n<p>simple generator handler for swagger</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>&#x2F;**\n * @typedef Product\n * @property {integer} id\n * @property {string} name.required - Some description for product\n * @property {Array.&lt;Point&gt;} Point\n *&#x2F;\n\n&#x2F;**\n * This function comment is parsed by doctrine\n * sdfkjsldfkj\n * @route POST &#x2F;users\n * @param {Point.model} point.body.required - the new point\n * @group foo - Operations about user\n * @param {string} email.query.required - username or email\n * @param {string} password.query.required - user&#x27;s password.\n * @param {enum} status.query.required - Status values that need to be considered for filter - eg: available,pending\n * @operationId retrieveFooInfo\n * @produces application&#x2F;json application&#x2F;xml\n * @consumes application&#x2F;json application&#x2F;xml\n * @returns {Response.model} 200 - An array of user info\n * @returns {Product.model}  default - Unexpected error\n * @returns {Array.&lt;Point&gt;} Point - Some description for point\n * @headers {integer} 200.X-Rate-Limit - calls per hour allowed by the user\n * @headers {string} 200.X-Expires-After - \tdate in UTC when token expires\n * @security JWT\n *&#x2F;\n</code></pre><ul>\n<li><a href=\"https://github.com/SensitiveMix/doc-generators/blob/master/example/router.js\">Usage</a></li>\n<li>优点：\n<ul>\n<li>支持集成 Swagger，支持按照类似 JSDoc 方式生成文档</li>\n<li>友好的文档的注释，贴合 IDE 函数注释</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>实现可用的基础上，需要支持到 IDE，方便一键生成，支持自动化</li>\n</ul>\n</li>\n</ul>\n<h2>Example</h2>\n<pre class=\"prettyprint\"><code>&#x2F;**\n * verify quarantine site\n * @route POST &#x2F;ui&#x2F;quarantine&#x2F;v1&#x2F;verify_od_dedicated_quarantine_site\n * @group quarantine\n * @param {QuarantineJSON.model} body.body.required - post body\n * @returns {object} 200 - An array of handler info\n * @returns {Error} 400 - invalid site\n * @returns {Error} 500 - internal error\n *&#x2F;\n&#x2F;**\n * JSON parameters require a model. This one just has &quot;name&quot;\n * @typedef QuarantineJSON\n * @property {string} site.required - quarantine site info\n *&#x2F;\n    server.post(&#x27;&#x2F;ui&#x2F;quarantine&#x2F;v1&#x2F;verify_od_dedicated_quarantine_site&#x27;, middleware.other.verifyLoginInfo,\n        rbac.quarantine.write, quarantine.verifyOdDedicatedQuarantineSite);\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;**\n * HTTP API statistics\n * @route GET &#x2F;monit&#x2F;v1&#x2F;metric\n * @group monit\n * @param {string} sort.query - asc | desc\n * @param {string} direction.query - count | avarageMillisecondCost | routeName\n * @returns {object} 200 - An array of user info\n * @returns {metrics.model} default - Unexpected error\n *&#x2F;\n&#x2F;**\n * @typedef metrics\n * @property {string} routeName.required - &#x27;getuiadminv1company_plans&#x27;\n * @property {number} count.required - route invoke times\n * @property {number} avarageMillisecondCost.required - route avg second cost\n *&#x2F;\n\nserver.get(&quot;&#x2F;monit&#x2F;v1&#x2F;metric&quot;, validator.query({\n    type: &#x27;object&#x27;,\n    properties: {\n        sort: { type: &#x27;string&#x27;, enum: [&#x27;count&#x27;] },\n        direction: { type: &#x27;string&#x27;, enum: [&#x27;asc&#x27;, &#x27;desc&#x27;] }\n    }\n}), monitService.apiMetricHandlers);\n</code></pre><p>项目地址：<a href=\"https://github.com/SensitiveMix/doc-generators\">https://github.com/SensitiveMix/doc-generators</a>\n喜欢的同学请点个 Star</p>\n</div>","title":"Node 项目使用注入 API 文档实践","last_reply_at":"2019-04-28T05:32:38.435Z","good":false,"top":false,"reply_count":0,"visit_count":413,"create_at":"2019-04-28T05:32:38.435Z","author":{"loginname":"sunNode","avatar_url":"https://avatars2.githubusercontent.com/u/16094680?v=4&s=120"}},{"id":"5cc4faa937faec0ce1d07681","author_id":"58de5214b3e60b982d089dc3","tab":"share","content":"<div class=\"markdown-text\"><p>说是骗星的, 目的不纯啊. 都忘放github地址了, 谢评论区提醒:\n<a href=\"https://github.com/xiaozhongliu/grpc-client-egg\">https://github.com/xiaozhongliu/grpc-client-egg</a></p>\n<p>这里给一下TS中的使用方法.</p>\n<h1>grpc-client-egg</h1>\n<p><a href=\"https://www.npmjs.org/package/grpc-client-egg\"><img src=\"https://img.shields.io/npm/v/grpc-client-egg.svg?style=flat-square\" alt=\"npm version\"></a></p>\n<blockquote>\n<p>An egg grpc client written in Typescript.</p>\n</blockquote>\n<h2>How to use</h2>\n<p>1 install</p>\n<pre class=\"prettyprint language-sh\"><code>npm i -S grpc-client-egg\n</code></pre><p>2 include</p>\n<pre class=\"prettyprint language-ts\"><code>import { EggPlugin } from &#x27;egg&#x27;\n\nconst plugin: EggPlugin = {\n\n    routerPlus: {\n        enable: true,\n        package: &#x27;egg-router-plus&#x27;,\n    },\n    grpcClient: {\n        enable: true,\n        package: &#x27;grpc-client-egg&#x27;,\n    },\n}\n\nexport default plugin\n\n</code></pre><p>3 config</p>\n<pre class=\"prettyprint language-ts\"><code>import { EggAppConfig, PowerPartial } from &#x27;egg&#x27;\n\nexport default () =&gt; {\n    const config: PowerPartial&lt;EggAppConfig&gt; = {\n\n        grpcClient: {\n            clients: [\n                {\n                    name: &#x27;main&#x27;,\n                    protoPath: &#x27;app&#x2F;proto&#x2F;main&#x27;,\n                    host: &#x27;0.0.0.0&#x27;,\n                    port: 50051,\n                },\n            ],\n        },\n    }\n    return config\n}\n</code></pre><p>4 invoke promisified grpc service methods</p>\n<pre class=\"prettyprint language-ts\"><code>import { Service } from &#x27;egg&#x27;\n\nexport default class Greeter extends Service {\n\n    readonly greeter: GreeterService = this.app.grpcClient.main.greeter.Greeter\n\n    public async sayHello(name: string) {\n        return this.greeter.sayHello({ name })\n    }\n\n    public async sayGoodbye(name: string) {\n        return this.greeter.sayGoodbye({ name })\n    }\n}\n</code></pre><h2>Default config from the plugin</h2>\n<pre class=\"prettyprint language-ts\"><code>    loaderOption: {\n        keepCase: true,\n        longs: String,\n        enums: String,\n        defaults: true,\n        oneofs: true,\n    },\n\n    clients: [\n        {\n            name: &#x27;main&#x27;,\n            protoPath: &#x27;app&#x2F;proto&#x2F;main&#x27;,\n            host: &#x27;0.0.0.0&#x27;,\n            port: 50051,\n        },\n    ],\n</code></pre></div>","title":"我又来骗星了, grpc-client-egg插件, TS与非TS都适用","last_reply_at":"2019-04-28T02:28:40.683Z","good":false,"top":false,"reply_count":3,"visit_count":431,"create_at":"2019-04-28T00:58:17.513Z","author":{"loginname":"xiaozhongliu","avatar_url":"https://avatars3.githubusercontent.com/u/17674404?v=4&s=120"}},{"id":"5c2edce13898674067a7b103","author_id":"5372465f3c72496d41009adc","tab":"share","content":"<div class=\"markdown-text\"><p>截止1 月 12日晚 22:00，有效参与人数共 252 人，抽取 5 名中奖者。\n恭喜以下中奖者🎉🎉🎉🎉🎉 gofromzero,MoeXian,yxcs,caoxiaoshuai1,langjy🎉🎉🎉🎉🎉\n请评论区留下联系方式。\n<img src=\"//static.cnodejs.org/Fvx9s9EjQk7IwNrAMO5_y7zJfrej\" alt=\"image.png\"></p>\n<p>---------------- 以下是原文 ----------------</p>\n<p>新书《Node.js开发实战》热卖，大获好评，感谢大家的支持，送几本书回馈给大家。</p>\n<p>赠书办法：</p>\n<ul>\n<li>只须在本贴留言即可。</li>\n<li>从回贴评论者中随机抽取中奖者，共计 5 本，每位中奖者 1 本。</li>\n<li>获赠名单公布在本帖，并在本贴下评论 @ 每位获赠的同学。</li>\n<li>截止时间 2019 年 1 月 12 日 22:00:00 （ UTC+8 ），以评论时间为准。</li>\n<li>由于本站不支持私信，请获奖同学在本帖回复联系方式，邮箱或者任何其它能联系到你的形式。</li>\n<li>开奖后 72 小时未能回复联系方式者视为放弃。</li>\n</ul>\n<p>试读样章：<a href=\"https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg\">https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg</a>\n京东有售：<a href=\"https://item.jd.com/12460185.html\">https://item.jd.com/12460185.html</a>\n<img src=\"//static.cnodejs.org/Finp2H7di-Equ_yMWsjJY6hxYGkh\" alt=\"WechatIMG148 copy.jpg\"></p>\n</div>","title":"送几本《Node.js开发实战》","last_reply_at":"2019-04-28T02:23:23.318Z","good":false,"top":false,"reply_count":364,"visit_count":14592,"create_at":"2019-01-04T04:11:13.570Z","author":{"loginname":"meikidd","avatar_url":"https://avatars0.githubusercontent.com/u/376338?v=4&s=120"}},{"id":"5cc2ef9da86ae80ce64b47f5","author_id":"5cc18fd637faec0ce1d06af1","tab":"share","content":"<div class=\"markdown-text\"><p>之前看过几篇关于<strong>exports</strong>、<strong>module.exports</strong>感觉都说的不清不楚，作为菜鸟，今天看了node.js实战后，才彻底搞清楚他们之间的区别，故在此分享下书中关于这两个对象/变量的区别，大佬就略过吧，哈哈）。\n为了保持原汁原味，我就先把原文关于exports和module.exports区别搬过来，后面有更深的理解再做解析、分析，希望能帮助到和我一样的初学者。\n\t原文：Node 模块允许从被引入文件中选择要暴露给程序的函数和变量。如果模块返回的函数或变量不止一个，那它可以通过设定 exports 对象的属性来指明它们。但如果模块只返回一个函数或变量，则可以设定 module.exports 属性。\n\t代码实例exports:\n\t\tconst canadianDollar = 0.91;\n\t\tfunction roundTwo(amount) {\n\t\t return Math.round(amount * 100) / 100;\n\t\t}\n\t\t<em>exports.canadianToUS = canadian =&gt; roundTwo(canadian * canadianDollar);</em>\n\t\t*exports.USToCanadian = us =&gt; roundTwo(us / canadianDollar); *</p>\n<pre class=\"prettyprint\"><code>exports 对象上只设定了两个属性。也就是说引入这个模块的代码只能访问到 canadianToUS 和 USToCanadian 这两个函数。而变量 canadianDollar 作为私有变量仅作用在canadianToUS 和 USToCanadian 的逻辑内部，程序不能直接访问它。\n尽管用函数和变量组装 exports 对象能满足大多数的模块创建需要，但有时你可能需要用不同的模型创建该模块。比如说，前面创建的那个货币转换器模块可以改成只返回一个 Currency 构造函数，而不是包含两个函数的对象。\n要创建只返回一个变量或函数的模块，你可能会以为只要把 exports 设定成你想返回的东西就行。但这样是不行的，因为 Node 觉得不能用任何其他对象、函数或变量给 exports 赋值。下面这个代码中的模块代码试图将一个函数赋值给 exports。\n**错误**代码示例：\nclass Currency {\n constructor(canadianDollar) {\n this.canadianDollar = canadianDollar;\n }\n roundTwoDecimals(amount) {\n return Math.round(amount * 100) &#x2F; 100;\n }\n canadianToUS(canadian) {\n return this.roundTwoDecimals(canadian * this.canadianDollar);\n }\n USToCanadian(us) {\n return this.roundTwoDecimals(us &#x2F; this.canadianDollar);\n }\n}\nexports = Currency; &#x2F;&#x2F;错误的方式，将会报错\n\n为了让前面那个模块的代码能用，需要把 exports 换成 module.exports。用 module.exports 可以对外提供单个变量、函数或者对象。如果你创建了一个既有 exports 又有module.exports 的模块，那它会返回 module.exports，而 exports 会被忽略。\n注意：最终在程序里导出的是 module.exports。exports 只是对 module.exports 的一个全局引用，最初被定义为一个可以添加属性的空对象。exports.myFunc 只是 module.exports.myFunc 的简写。所以，如果把 exports 设定为别的，就打破了 module.exports 和 exports 之间的引用关系。可是因为真正导出的是 module.exports，那样 \t\t\texports 就不能用了，因为它不再指向module.exports 了。如果你想保留那个链接，可以像下面这样让 module.exports 再次引用\nexports：module.exports = exports = Currency;\n根据需要使用 exports 或 module.exports 可以将功能组织成模块，规避掉程序脚本一直增长所产生的弊端。</code></pre></div>","title":"关于js模块中的exports和module.exports区别","last_reply_at":"2019-04-28T01:10:21.472Z","good":false,"top":false,"reply_count":2,"visit_count":463,"create_at":"2019-04-26T11:46:37.252Z","author":{"loginname":"Hew007","avatar_url":"https://avatars1.githubusercontent.com/u/26536518?v=4&s=120"}},{"id":"5b44291035342ab0690613d6","author_id":"5b37500b5c8f1ea723a56b2b","tab":"share","content":"<div class=\"markdown-text\"><p>Electron是一个跨平台的桌面应用开发框架，可以让我们用html css js的技术开发跨平台桌面上可以安装的软件。</p>\n<p><strong>前4讲免费试听地址：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1Dol4tP6Jop6MXro0ULVapQ\">https://pan.baidu.com/s/1Dol4tP6Jop6MXro0ULVapQ</a></p>\n<p>electron Github的 star已经达到61957，那么他的<strong>用户量可能已经有100万了</strong>。还有大家知道的github的atom编辑器、微软的vscode编辑器，包括阿里内部的一些软件也是用 electron 开发的。既然这么热，<strong>那就一个字：学</strong>，大家都在学，你不学（有没有压力啊！！！）</p>\n<p><strong>28元购买地址</strong>:<a href=\"https://www.itying.com/goods-929.html\">https://www.itying.com/goods-929.html</a></p>\n<p><img src=\"//static.cnodejs.org/FqbpQ7iHRMdMdSrEGLD_xpe4CabH\" alt=\"1.png\"></p>\n</div>","title":"Electron视频教程_Electron+Vue跨平台桌面软件开发视频教程（收费啊--不贵一包烟钱-有试听）","last_reply_at":"2019-04-28T00:39:34.173Z","good":false,"top":false,"reply_count":34,"visit_count":8388,"create_at":"2018-07-10T03:33:36.227Z","author":{"loginname":"it-ionic","avatar_url":"https://avatars1.githubusercontent.com/u/17946554?v=4&s=120"}},{"id":"5cbb3440a86ae80ce64b1760","author_id":"5a051be2ee9b35da75a869f7","tab":"share","content":"<div class=\"markdown-text\"><h2>现在存在的问题</h2>\n<blockquote>\n<p>每次打包完, 都要打开 FileZilla 一顿拖拽然后才能上传代码, 那就立马撸一个自动化脚本就完事了</p>\n</blockquote>\n<h2>publish-sftp</h2>\n<blockquote>\n<p><a href=\"https://github.com/xiaoxiaojx/publish-sftp\">Github 传送门</a>(<s><s>顺便来骗个Star</s></s>)  以后一行命令上传本地文件到服务器啦</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/20/16a3b04aee0c822c?w=300&amp;h=200&amp;f=jpeg&amp;s=8252\" alt></p>\n<pre class=\"prettyprint\"><code>publish-sftp -c &#x2F;&#x2F; 完事\n</code></pre><h2>安全性</h2>\n<blockquote>\n<p>项目组已经跑了大半年, 没出过幺蛾子, 可放心使用</p>\n</blockquote>\n<h2>实现</h2>\n<blockquote>\n<p>基于 ssh2-sftp-client</p>\n</blockquote>\n<h2>快速上手</h2>\n<h3>install</h3>\n<pre class=\"prettyprint\"><code>    sudo npm i publish-sftp -g\n    sudo npm link publish-sftp\n</code></pre><h3>tips</h3>\n<blockquote>\n<p>当前目录下需要提供一份 sftp.json</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>{\n    &quot;localPath&quot;: &quot;.&#x2F;dist&quot;,\n    &quot;remotePath&quot;: &quot;&#x2F;export&#x2F;App&#x2F;xxx&quot;,\n    &quot;protectedRemotePath&quot;: &quot;&#x2F;export&#x2F;App&#x2F;xxx&quot;,\n    &quot;connect&quot;: {\n        &quot;host&quot;: &quot;xxx.xxx.xxx.xx&quot;,\n        &quot;port&quot;: 22,\n        &quot;username&quot;: &quot;root&quot;,\n        &quot;password&quot;: &quot;123456&quot;\n    }\n}\n</code></pre><h3>example</h3>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/10/18/16687b0ddcd3a2a4?w=828&amp;h=234&amp;f=jpeg&amp;s=48490\" alt=\"image\"></p>\n<blockquote>\n<p>复制 localPath 下所有文件到 remotePath/xjx/test, -c 参数为空则是复制到 remotePath, 远程目录不存在会先创建</p>\n</blockquote>\n<h3>copy</h3>\n<blockquote>\n<p>复制 localPath 下所有文件到 remotePath 目录下, 如果 xxx 有值则是复制到 <code>${remotePath}/${xxx}</code> 目录</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>publish-sftp -c xxx\n</code></pre><h3>remove</h3>\n<blockquote>\n<p>删除 remotePath 目录, 如果 xxx 有值则是删除 <code>${remotePath}/${xxx}</code> 目录, protectedRemotePath 目录是不允许操作的, 所以为了安全是必需要设置的, 一般和 remotePath 值一样即可!</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>publish-sftp -r xxx\n</code></pre><h2>谢谢阅读</h2>\n</div>","title":"Node.js 一行命令上传本地文件到服务器","last_reply_at":"2019-04-27T19:44:34.105Z","good":false,"top":false,"reply_count":19,"visit_count":1756,"create_at":"2019-04-20T15:01:20.665Z","author":{"loginname":"xiaoxiaojx","avatar_url":"https://avatars2.githubusercontent.com/u/23253540?v=4&s=120"}},{"id":"5cc3f4a337faec0ce1d07407","author_id":"5c88bffdacb681372d417bb4","tab":"share","content":"<div class=\"markdown-text\"><p>Saas平台软件提供商多多客重磅支持微信公众号，商家只需搭建一次后台，即可同时发布到微信、百度、支付宝小程序、微信公众号四端。</p>\n<p><strong>线上多渠道推广，流量曝光</strong>\n微信小程序、百度小程序、支付宝小程序、微信公众号，一次搭建，四大渠道同时推广，把握社交网络每一份流量。</p>\n<p><strong>页面可视化DIY，随心设计</strong>\n丰富组件库，样式、大小、颜色自由更改；可视化自由拖拽，满足任何个性化需求。</p>\n<p><img src=\"//static.cnodejs.org/FoUEZf5sGaMD8AMsBfXjKlsLsiWL\" alt=\"552fe0c0ab374c2d91970c4ab6fcf7b9.png\"></p>\n<p><strong>几十种营销工具，提升留存率</strong>\n分销、拼团、会员卡、裂变红包、集赞、积分商城、消息推送等几十种营销玩法，获客、促活新利器，轻松助力企业推广、提升留存。</p>\n<p><img src=\"//static.cnodejs.org/FvVpgc35WRQoeix0JnDNmvlwCeoo\" alt=\"293e19accd634bde8ea648a7f02c57c5.png\"></p>\n<p><strong>私有化部署，保障数据安全</strong>\n多多客支持私有化部署，助力企业搭建安全高效的saas平台，满足网络安全控制体系的要求。支持二次开发，满足企业个性开发需求。</p>\n<p><strong>多种运营模式，保障盈利</strong>\n代理商预存款、商家小程序年费、运营支持、二次开发、应用商店，五大运营模式助力商家拓展市场。</p>\n<p>多多客微信公众号saas平台今日正式开放公测。</p>\n<p>公测时间：4月24日 - 4月30日</p>\n<p>公测期间购微信/百度/支付宝saas平台版小程序赠送多多客微信公众号。</p>\n<p>多多客公测网址：<a href=\"http://doodooke.com\">doodooke.com</a>，如果您对多多客有好的意见或建议，欢迎随时联系青妹（微信：qfxcx66）反馈哦 ~</p>\n</div>","title":"多多客支持微信公众号，正式开放公测！","last_reply_at":"2019-04-27T06:20:19.069Z","good":false,"top":false,"reply_count":0,"visit_count":442,"create_at":"2019-04-27T06:20:19.069Z","author":{"loginname":"doodooke1688","avatar_url":"https://avatars0.githubusercontent.com/u/48510722?v=4&s=120"}},{"id":"5caae8a57edd13064e0533fd","author_id":"5c88bffdacb681372d417bb4","tab":"share","content":"<div class=\"markdown-text\"><p>多多客（doodooke）是一款基于Koa+Vue+Taro开发，支持微信，百度，支付宝小程序的第三方SaaS平台。</p>\n<p><strong>本次重要更新</strong>\n1、优化打赏不显示打赏人\n2、新增登录的账号未绑定微信的情况下提示绑定微信\n3、优化safari下页面组件样式问题\n4、优化编译重启\n5、优化消息推送小程序模板消息下架问题\n6、优化客户管理在多小程序下显示问题\n7、新增小程序客服引导\n8、优化营销应用图标\n9、新增订单导出功能</p>\n<p><strong>3.0新特性</strong>\n1、支持migrations，可以快速的创建和修改表\n2、支持rewrite，可以将请求转发到修改过的接口\n3、支持view逻辑钩子，可以扩展vue逻辑\n4、支持view视图钩子，可以扩展vue视图\n5、支持cluster，可以启动多个项目\n6、支持本地调试，可以将生产环境的请求转发或复制到本地\n7、支持bin命令，可以快速的处理migration等</p>\n<p>多多客官网：<a href=\"http://doodooke.com\">doodooke.com</a>\n3.0开源版立即下载：<a href=\"https://gitee.com/doodooke/doodoo\">https://gitee.com/doodooke/doodoo</a></p>\n</div>","title":"【开源】多多客小程序发布 3.0.0-alpha.6，Koa+Vue+Taro最佳实践","last_reply_at":"2019-04-27T06:17:22.936Z","good":false,"top":false,"reply_count":3,"visit_count":947,"create_at":"2019-04-08T06:22:29.186Z","author":{"loginname":"doodooke1688","avatar_url":"https://avatars0.githubusercontent.com/u/48510722?v=4&s=120"}},{"id":"5c28c1913898674067a79bfb","author_id":"5b2a0c5029e6e510415b2c0f","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fkn6kPQ9QOWno-1bxP_hkIZmRYZx\" alt=\"11111.jpg\"></p>\n<p>适合新手入门学习的Node.js简单视频教程，带你走进Node.js的世界，有留言板项目实战等8节课</p>\n<p><strong>教程目录：</strong>\n01 Node.js是什么\n02 安装体验Node.js\n03 尝试写个小程序\n04 查看你的CPU和内存\n05 写文件\n06 采集网页\n07 运行网站\n08 留言板\n教程下载：<a href=\"https://www.sucaihuo.com/video/178.html\">https://www.sucaihuo.com/video/178.html</a></p>\n</div>","title":"Node.js简单视频教程 适合新手入门","last_reply_at":"2019-04-27T01:44:46.782Z","good":false,"top":false,"reply_count":6,"visit_count":1933,"create_at":"2018-12-30T13:01:05.700Z","author":{"loginname":"whoknowme","avatar_url":"https://avatars0.githubusercontent.com/u/40422811?v=4&s=120"}},{"id":"5cbf0519a86ae80ce64b2b73","author_id":"5c91ace496558e26e1b677bd","tab":"ask","content":"<div class=\"markdown-text\"><p>chilld process可以生成一个子进程，但是怎么处理父进程的任务呢？我查了官方文档，说是send方法可以传递一个TCP服务器或者Server，那么我父进程的任务怎么传递给子进程来帮我分担作业呢？</p>\n</div>","title":"child_process分担任务问题","last_reply_at":"2019-04-26T08:21:43.563Z","good":false,"top":false,"reply_count":16,"visit_count":1254,"create_at":"2019-04-23T12:29:13.806Z","author":{"loginname":"HyperClockUp","avatar_url":"https://avatars2.githubusercontent.com/u/36909196?v=4&s=120"}},{"id":"5cc29863a86ae80ce64b44cb","author_id":"5976b9b80c87675e74674819","tab":"ask","content":"<div class=\"markdown-text\"><p>做了一个手机网页，加上了title，但是显示还是显示网址，不是应该显示title的内容嘛？？请问各位大神是什么原因？？怎么样来实现呢？？？</p>\n</div>","title":"手机浏览器如何显示title","last_reply_at":"2019-04-26T05:34:27.318Z","good":false,"top":false,"reply_count":0,"visit_count":530,"create_at":"2019-04-26T05:34:27.318Z","author":{"loginname":"quanpf2481","avatar_url":"https://avatars3.githubusercontent.com/u/30330930?v=4&s=120"}},{"id":"5cc285ec37faec0ce1d06f10","author_id":"5cc27819a86ae80ce64b440b","tab":"share","content":"<div class=\"markdown-text\"><h1>ggit 是一个运行在浏览器环境的git gui 工具</h1>\n<p>项目存在许多 巨大BUG和缺失大量功能\n资金不足，思路暂无，敬请期待！(最近开发另一个项目一直没时间)\n注意：本人从未推广过自己的项目 所以最近集中式的推广 海涵😘\n可通过npm 下载尝试 详情见github\n如果喜欢 星星 on gayhub</p>\n<p>项目截图\n<a href=\"https://zhuanlan.zhihu.com/p/63746038\">ggit 运行在浏览器环境的git gui 工具（多图警告）</a></p>\n</div>","title":"ggit 运行在浏览器环境的git gui 工具（多图警告）","last_reply_at":"2019-04-26T04:15:40.883Z","good":false,"top":false,"reply_count":0,"visit_count":677,"create_at":"2019-04-26T04:15:40.883Z","author":{"loginname":"sewerganger","avatar_url":"https://avatars2.githubusercontent.com/u/45007226?v=4&s=120"}},{"id":"5cc284c237faec0ce1d06f0c","author_id":"5cc27819a86ae80ce64b440b","tab":"share","content":"<div class=\"markdown-text\"><p>SimplerDateFormat(pattern: string,[week: Array&lt;string&gt;])\nsewerganger/simpler-date-format\n<a href=\"https://github.com/sewerganger/simpler-date-format\">github地址 simpler-date-format</a>\n图标\nSimplerDateFormat 是一个特别简单的时间格式化js包类似于java的SimplerDateFormat，但是它更加简单😜!</p>\n<ol>\n<li>Api\n构造函数\nSimplerDateFormat(string, week)\n方法\nformat(date: Date);  // format time you want\nzone(number);           // setZoneTime and format\n日期用大写字母，时间用小写字母，字母是随机的，使用空格分隔，输入的顺序是输出的顺序。使用特殊符号（除~）表示一周中输出的日期。在句子前加<code>~</code>可反转输出；</li>\n</ol>\n<p>2.举个🌰子</p>\n<pre class=\"prettyprint\"><code>const SimplerDateFormat = require(&#x27;simpler-date-format&#x27;);\n\n&#x2F;&#x2F;定义一周\nconst weekday = [&#x27;Monday&#x27;,&#x27;Tuesday&#x27;,&#x27;Wednesday&#x27;,&#x27;Thursday&#x27;,&#x27;Friday&#x27;,&#x27;Saturday&#x27; ,&#x27;Sunday&#x27;];\n\nvar sd = new SimplerDateFormat(&#x27;Y&#x2F;M&#x2F;D h:m:d&#x27;);\nsd.format(new Date());              &#x2F;&#x2F;2019&#x2F;04&#x2F;23 22:36:44\n\nvar sd = new SimplerDateFormat(&#x27;Y$M$D h:m:d @&#x27;);\nsd.format(new Date());              &#x2F;&#x2F;2019$04$23 22:36:44 2\n\nvar sd = new SimplerDateFormat(&#x27;h:m:d Y&#x2F;M&#x2F;D&#x27;);\nsd.format(new Date());              &#x2F;&#x2F;22:36:44 2019&#x2F;04&#x2F;23\n\n&#x2F;&#x2F;反转输出\nvar sd = new SimplerDateFormat(&#x27;@ h:m:d ~Y&#x2F;M&#x2F;D&#x27;, week); \nsd.format(new Date());              &#x2F;&#x2F; Tuesday 22:36:44 04&#x2F;23&#x2F;2019\n\n&#x2F;&#x2F;北京时间并输出星期几 自行定义\nvar sd = new SimplerDateFormat(&#x27;h:m:d ~Y&#x2F;M&#x2F;D&#x27;, week);\nsd.zone(8);              &#x2F;&#x2F;22:36:44 04&#x2F;23&#x2F;2019 Tuesday \n\n</code></pre><p>还有更多的功能未开发，欢迎加入Muguet-ui开发交流，群聊号码：279499604\n如果你喜欢可以 在gayhub❤</p>\n</div>","title":"SimplerDateFormat 一个更简单的SimpleDateFormat","last_reply_at":"2019-04-26T04:10:42.166Z","good":false,"top":false,"reply_count":0,"visit_count":463,"create_at":"2019-04-26T04:10:42.166Z","author":{"loginname":"sewerganger","avatar_url":"https://avatars2.githubusercontent.com/u/45007226?v=4&s=120"}},{"id":"5cc27f8d37faec0ce1d06ee8","author_id":"5cc2720637faec0ce1d06e38","tab":"ask","content":"<div class=\"markdown-text\"><p>想用nodejs实现数据接收并推送到网页，但 url.parse( ).path却无法使用。请各位大佬帮帮萌新。\n代码如下（数据接收部分省略）</p>\n<pre class=\"prettyprint language-js\\n\"><code>var http = require(&#x27;http&#x27;);\nvar fs   = require(&#x27;fs&#x27;);\nvar url_parser = require(&#x27;url&#x27;);\nvar querystring = require(&#x27;querystring&#x27;);\nvar man = 0;\nvar car = 0;\n\nvar server=http.createServer(function(req,res)\n{\n    var post = &#x27;&#x27;;\n    var raw_url = req.url;\n    var url = url_parser.parse(raw_url,true);\n    var pathname = url.pathname;\n    var path = url.path;          &#x2F;&#x2F;**url.path无法使用**\n\t\n    &#x2F;&#x2F;响应OneNet发来的请求，接收数据\n    if(pathname == &#x27;&#x2F;dataPort&#x27;)\n    {\n\t           &#x2F;&#x2F;已省略\n    }\n&#x2F;&#x2F;\n    if(path == &#x27;&#x2F;index&#x27;)\n    {\n        res.writeHead(200,{&#x27;Content-Type&#x27;:&#x27;text&#x2F;html&#x27;});\n        fs.readFile(&#x27;.&#x2F;index.html&#x27;,&#x27;utf-8&#x27;,function(err,data)\n        {\n            res.write(data);\n            res.end();\n        });\n    }\n    &#x2F;&#x2F;响应&#x27;&#x2F;?test=ajax&#x27;\n    else if(path == &#x27;&#x2F;?test=ajax&#x27;)\n    {\n        console.log(&#x27;start ajax&#x27;);\n        res.writeHead(200,{&#x27;Content-Type&#x27;:&#x27;text&#x2F;plain&#x27;,&#x27;Access-Control-Allow-Origin&#x27;:&#x27;*&#x27;});\n        var jlatitude_json = {&quot;man&quot;:man,&quot;car&quot;:car};\n        var str = JSON.stringify(jlatitude_json);\n        res.write(str);\n        res.end();\n    }\n});\n\nserver.listen(80);\nconsole.log(&#x27;server running at port 80&#x27;);   \n\n code \\n&#96;&#96;&#96; \nhtml  ajax部分代码\n&#96;&#96;&#96;js\\n    \n&lt;script type=&quot;javascript&quot;&gt;\n    &#x2F;&#x2F;更新数据\n    var car=0;\n    var man=0;\n    &#x2F;&#x2F;发送ajax请求\n    function start(){\n        $.ajax({\n            url:&#x27;http:&#x2F;&#x2F;47.102.122.37:80&#x2F;&#x27;,\n            dataType:&#x27;json&#x27;,\n            type:&#x27;get&#x27;,\n            data:{test:&#x27;ajax&#x27;},\n            success:function(data)\n            {\n                function UpdateMAC(data)\n                {\n                    car = data.car;\n                    man = data.man;\n                    document.getElementById(&#x27;man&#x27;).value = man;\n                    document.getElementById(&#x27;car&#x27;).value = car;\n                }\t&#x2F;&#x2F;更新\n\n            }\n        })\n    }\n\n    &#x2F;*\n     每隔1秒发送一次经纬度数据请求\n     *&#x2F;\n    setInterval(function()\n    {\n        start();\n    },3000);\n&lt;&#x2F;script&gt;\n  code \\n&#96;&#96;&#96;</code></pre></div>","title":"新人求助  url.parse( ).path  无法使用","last_reply_at":"2019-04-26T03:48:29.092Z","good":false,"top":false,"reply_count":0,"visit_count":685,"create_at":"2019-04-26T03:48:29.092Z","author":{"loginname":"ranzhuang880","avatar_url":"https://avatars0.githubusercontent.com/u/49989905?v=4&s=120"}},{"id":"5cc132aca86ae80ce64b3cf0","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h2>一、发现问题</h2>\n<p>这是一个基于 vue-cli 的管理后台项目，由于依赖较多，打包结果如下</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/25/16a52728b78679c4?w=721&amp;h=134&amp;f=png&amp;s=132416\" alt=\"图片描述\"></p>\n<h2>二、查找原因</h2>\n<blockquote>\n<p>为什么 vendor 体积这么大？</p>\n</blockquote>\n<p>引用的库太多时，vendor的体积会很大，借助 Webpack 的分析工具，看了下各个依赖的体积分布</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/25/16a52728ab236ac0?w=800&amp;h=446&amp;f=png&amp;s=151789\" alt=\"图片描述\"></p>\n<p>找到原因，是 Highcharts 和 Element-UI占了较大体积，导致性能减弱。</p>\n<blockquote>\n<p>这两个库都提供了按需加载的功能，能有效减小体积，只是刚好这个管理后台项目依赖较多</p>\n</blockquote>\n<p>那么有办法控制打包的体积超过一定值时，分成多个文件打包吗？<br>\n或者通过配置将部分库抽离出来，打包成另外的文件？</p>\n<h2>三、解决方法</h2>\n<h3>（一）CDN 外链</h3>\n<p>先把 Highcharts 和 Lodash 通过外链引入</p>\n<pre class=\"prettyprint language-html\"><code>&lt;script src=&quot;&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;lodash.js&#x2F;4.17.5&#x2F;lodash.min.js&quot; &#x2F;&gt;\n&lt;script src=&quot;&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;highcharts&#x2F;6.0.7&#x2F;highstock.js&quot; &#x2F;&gt;\n&lt;script src=&quot;&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;highcharts&#x2F;6.0.7&#x2F;js&#x2F;highcharts-more.js&quot; &#x2F;&gt;\n&lt;script src=&quot;&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;highcharts&#x2F;6.0.7&#x2F;js&#x2F;modules&#x2F;treemap.js&quot; &#x2F;&gt;\n</code></pre><p>外链引入的资源就不能直接通过 import 来使用，但可以通过 Webpack 的 externals 特性来兼容</p>\n<pre class=\"prettyprint language-javascript\"><code>import _ from &#x27;lodash&#x27;\nimport Highcharts from &#x27;highcharts&#x27;\n\nconsole.log([_, Highcharts])\n</code></pre><p>这样配置 Webpack 就知道这两个依赖是外链全局的，不需要打包</p>\n<pre class=\"prettyprint language-javascript\"><code>externals: {\n  lodash: &#x27;_&#x27;,\n  highcharts: &#x27;Highcharts&#x27;\n}\n</code></pre><p>先看看去掉 Highcharts 和 Lodash 的效果</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/25/16a52728ab54f70e?w=704&amp;h=131&amp;f=png&amp;s=32604\" alt=\"图片描述\"></p>\n<p>vendor 也避免打包了这两个库</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/25/16a52728ac3119b4?w=800&amp;h=447&amp;f=png&amp;s=189224\" alt=\"图片描述\"></p>\n<p>这种方式适用于不常更新的第三方依赖，采用外链，Element-UI 由于常有新特性更新，需要保持最新版本，所以还是通过 npm 来管理</p>\n<h4>内网部署的问题</h4>\n<p>如若这个管理后台项目要部署到一个内网机器，访问不了外网，那要怎么解决呢？</p>\n<h3>（二）拆开 vendor</h3>\n<blockquote>\n<p>Webpack 默认是将依赖打包成一个文件，这样优点是减少资源请求数，但当依赖增多，体积增大，一个资源的加载速度就会减慢</p>\n</blockquote>\n<p>所以尝试去拆包</p>\n<pre class=\"prettyprint language-javascript\"><code>new webpack.optimize.CommonsChunkPlugin({\n  name: &#x27;charts&#x27;,\n  chunks: [&#x27;vendor&#x27;],\n  minChunks: module =&gt; module.resource.indexOf(&#x27;highcharts&#x27;) &gt; -1\n}),\n\nnew webpack.optimize.CommonsChunkPlugin({\n  name: &#x27;utils&#x27;,\n  chunks: [&#x27;vendor&#x27;],\n  minChunks: module =&gt; module.resource.indexOf(&#x27;lodash&#x27;) &gt; -1\n}),\n\nnew webpack.optimize.CommonsChunkPlugin({\n  name: &#x27;ui&#x27;,\n  chunks: [&#x27;vendor&#x27;],\n  minChunks: module =&gt; module.resource.indexOf(&#x27;element-ui&#x27;) &gt; -1\n})\n</code></pre><p>拆包后的打包结果</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/25/16a52728ac2e499f?w=711&amp;h=178&amp;f=png&amp;s=201907\" alt=\"图片描述\"></p>\n<p>看看分析工具</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/25/16a52728ac95dd0a?w=800&amp;h=447&amp;f=png&amp;s=160849\" alt=\"图片描述\"></p>\n<h2>总结</h2>\n<p>程序小哥实战经验得出：外链简单粗暴，而拆包可以配合浏览器缓存，在每次发布最小化更新资源，比较实用。</p>\n<h2>程序小哥介绍</h2>\n<p>考拉前端开发小哥Bingo，潜心钻研小程序开发。</p>\n</div>","title":"Webpack打包优化：使用外链与拆包模式","last_reply_at":"2019-04-26T03:42:04.887Z","good":false,"top":false,"reply_count":4,"visit_count":697,"create_at":"2019-04-25T04:08:12.940Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5cc16f8937faec0ce1d0697f","author_id":"59b0fced1b37e54f6793c3d6","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>压测NODEJS（PM2管理的负载）接口之后，随便点击任意一个接口出现CPU暴涨到100%+，不点击之后恢复10%（压测之前CPU只有0.3%左右），再次点击又暴涨到100%+\n只有杀掉NODE进程，重启站点才正常。这是通过<code>node --prof-process</code>分析出来的日志</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>Statistical profiling result from isolate-0x3f09b30-v8.log, (1097 ticks, 7 unaccounted, 0 excluded).\n\n [Shared libraries]:\n   ticks  total  nonlib   name\n    776   70.7%          &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n     90    8.2%          &#x2F;usr&#x2F;lib64&#x2F;libc-2.17.so\n     15    1.4%          &#x2F;usr&#x2F;lib64&#x2F;libpthread-2.17.so\n     12    1.1%          &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6.0.19\n      1    0.1%          [vdso]\n\n [JavaScript]:\n   ticks  total  nonlib   name\n     13    1.2%    6.4%  Builtin: InterpreterEntryTrampoline\n     11    1.0%    5.4%  LazyCompile: *montReduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:609:20\n      7    0.6%    3.4%  Builtin: KeyedStoreIC_Megamorphic\n      7    0.6%    3.4%  Builtin: CallFunction_ReceiverIsAny\n      6    0.5%    3.0%  LazyCompile: *bnpSquareTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:448:21\n      5    0.5%    2.5%  LazyCompile: ~resolve path.js:1068:28\n      5    0.5%    2.5%  LazyCompile: ~Module._resolveLookupPaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:401:38\n      5    0.5%    2.5%  LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      5    0.5%    2.5%  LazyCompile: *normalizeString path.js:52:25\n      4    0.4%    2.0%  LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;psl&#x2F;index.js:14:61\n      4    0.4%    2.0%  LazyCompile: *resolve path.js:1068:28\n      4    0.4%    2.0%  Builtin: KeyedLoadIC\n      3    0.3%    1.5%  Builtin: StringSubstring\n      3    0.3%    1.5%  Builtin: StringPrototypeSlice\n      3    0.3%    1.5%  Builtin: StringAdd_CheckNone_NotTenured\n      3    0.3%    1.5%  Builtin: KeyedStoreICTrampoline\n      3    0.3%    1.5%  Builtin: Call_ReceiverIsAny\n      2    0.2%    1.0%  LazyCompile: ~realpathSync fs.js:1375:22\n      2    0.2%    1.0%  LazyCompile: ~readFileSync fs.js:340:22\n      2    0.2%    1.0%  LazyCompile: ~basename path.js:1286:30\n      2    0.2%    1.0%  LazyCompile: ~args internal&#x2F;util&#x2F;types.js:11:10\n      2    0.2%    1.0%  LazyCompile: ~Module._nodeModulePaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:360:37\n      2    0.2%    1.0%  LazyCompile: ~DoJoin native array.js:87:16\n      2    0.2%    1.0%  LazyCompile: *bnpMultiplyTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:436:23\n      2    0.2%    1.0%  LazyCompile: *am3 &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:102:13\n      2    0.2%    1.0%  Builtin: StoreIC\n      2    0.2%    1.0%  Builtin: ObjectPrototypeHasOwnProperty\n      2    0.2%    1.0%  Builtin: LoadIC_Noninlined\n      1    0.1%    0.5%  Stub: StoreFastElementStub\n      1    0.1%    0.5%  Stub: CallApiCallbackStub\n      1    0.1%    0.5%  Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:9:19\n      1    0.1%    0.5%  Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;ajv&#x2F;lib&#x2F;dotjs&#x2F;validate.js:1:11\n      1    0.1%    0.5%  RegExp: (?:^\n      1    0.1%    0.5%  RegExp: \n      1    0.1%    0.5%  LazyCompile: ~wrapCallSite &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:323:22\n      1    0.1%    0.5%  LazyCompile: ~validateUint32 internal&#x2F;validators.js:100:24\n      1    0.1%    0.5%  LazyCompile: ~validateOffsetLengthRead internal&#x2F;fs&#x2F;utils.js:408:34\n      1    0.1%    0.5%  LazyCompile: ~validateMode internal&#x2F;validators.js:32:22\n      1    0.1%    0.5%  LazyCompile: ~tryCreateBuffer fs.js:313:25\n      1    0.1%    0.5%  LazyCompile: ~toPathIfFileURL internal&#x2F;url.js:1364:25\n      1    0.1%    0.5%  LazyCompile: ~stat internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:84:14\n      1    0.1%    0.5%  LazyCompile: ~runInThisContext vm.js:322:26\n      1    0.1%    0.5%  LazyCompile: ~require internal&#x2F;modules&#x2F;cjs&#x2F;helpers.js:19:19\n      1    0.1%    0.5%  LazyCompile: ~relative path.js:1161:30\n      1    0.1%    0.5%  LazyCompile: ~readPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:153:21\n      1    0.1%    0.5%  LazyCompile: ~pathtoRegexp &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;path-to-regexp&#x2F;index.js:28:22\n      1    0.1%    0.5%  LazyCompile: ~openSync fs.js:428:18\n      1    0.1%    0.5%  LazyCompile: ~ok assert.js:356:12\n      1    0.1%    0.5%  LazyCompile: ~normalizeString path.js:52:25\n      1    0.1%    0.5%  LazyCompile: ~module.exports.require.getIteratorMethod &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;core.get-iterator-method.js:4:66\n      1    0.1%    0.5%  LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;_is-array-iter.js:6:27\n      1    0.1%    0.5%  LazyCompile: ~merge &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-traverse&#x2F;lib&#x2F;visitors.js:236:15\n      1    0.1%    0.5%  LazyCompile: ~makeRequireFunction internal&#x2F;modules&#x2F;cjs&#x2F;helpers.js:16:29\n      1    0.1%    0.5%  LazyCompile: ~loadSync &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:12152:18\n      1    0.1%    0.5%  LazyCompile: ~join path.js:1141:22\n      1    0.1%    0.5%  LazyCompile: ~isUint32 internal&#x2F;validators.js:13:18\n      1    0.1%    0.5%  LazyCompile: ~isEncoding buffer.js:449:40\n      1    0.1%    0.5%  LazyCompile: ~isAbsolute path.js:1135:34\n      1    0.1%    0.5%  LazyCompile: ~forEachCode &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;raw-body&#x2F;node_modules&#x2F;http-errors&#x2F;index.js:226:38\n      1    0.1%    0.5%  LazyCompile: ~forEach &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;stealthy-require&#x2F;lib&#x2F;index.js:5:17\n      1    0.1%    0.5%  LazyCompile: ~findConfigs &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;build-config-chain.js:82:66\n      1    0.1%    0.5%  LazyCompile: ~extname path.js:1364:28\n      1    0.1%    0.5%  LazyCompile: ~explode &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-traverse&#x2F;lib&#x2F;visitors.js:41:17\n      1    0.1%    0.5%  LazyCompile: ~debug &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;debug&#x2F;src&#x2F;debug.js:65:17\n      1    0.1%    0.5%  LazyCompile: ~dataFromCodePoints &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regenerate&#x2F;regenerate.js:84:35\n      1    0.1%    0.5%  LazyCompile: ~compile &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:100:17\n      1    0.1%    0.5%  LazyCompile: ~bnpRShiftTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:381:21\n      1    0.1%    0.5%  LazyCompile: ~bnpModInt &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1341:19\n      1    0.1%    0.5%  LazyCompile: ~bnpFromString &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:183:23\n      1    0.1%    0.5%  LazyCompile: ~bnBitLength &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:342:21\n      1    0.1%    0.5%  LazyCompile: ~arrayPush &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_arrayPush.js:9:19\n      1    0.1%    0.5%  LazyCompile: ~am3 &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:102:13\n      1    0.1%    0.5%  LazyCompile: ~allocate buffer.js:318:18\n      1    0.1%    0.5%  LazyCompile: ~_extend util.js:290:17\n      1    0.1%    0.5%  LazyCompile: ~Script vm.js:44:14\n      1    0.1%    0.5%  LazyCompile: ~NativeModule.nonInternalExists internal&#x2F;bootstrap&#x2F;loaders.js:216:46\n      1    0.1%    0.5%  LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    0.1%    0.5%  LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1    0.1%    0.5%  LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1    0.1%    0.5%  LazyCompile: ~IPv4 &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;ipaddr.js&#x2F;lib&#x2F;ipaddr.js:57:18\n      1    0.1%    0.5%  LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:316:76\n      1    0.1%    0.5%  LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_overRest.js:17:18\n      1    0.1%    0.5%  LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:158:33\n      1    0.1%    0.5%  LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;helpers&#x2F;merge.js:12:55\n      1    0.1%    0.5%  LazyCompile: *relative path.js:1161:30\n      1    0.1%    0.5%  LazyCompile: *montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      1    0.1%    0.5%  LazyCompile: *dirname path.js:1259:28\n      1    0.1%    0.5%  LazyCompile: *dataToArray &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regenerate&#x2F;regenerate.js:476:28\n      1    0.1%    0.5%  LazyCompile: *bnpSubTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:402:18\n      1    0.1%    0.5%  LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1    0.1%    0.5%  LazyCompile: *basename path.js:1286:30\n      1    0.1%    0.5%  LazyCompile: *Module._nodeModulePaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:360:37\n      1    0.1%    0.5%  LazyCompile: *DoJoin native array.js:87:16\n      1    0.1%    0.5%  Builtin: ToString\n      1    0.1%    0.5%  Builtin: ToObject\n      1    0.1%    0.5%  Builtin: RegExpPrototypeExec\n      1    0.1%    0.5%  Builtin: RecordWrite\n      1    0.1%    0.5%  Builtin: ObjectAssign\n      1    0.1%    0.5%  Builtin: LoadIC_Uninitialized\n      1    0.1%    0.5%  Builtin: KeyedStoreIC\n      1    0.1%    0.5%  Builtin: KeyedLoadIC_Megamorphic\n      1    0.1%    0.5%  Builtin: JSConstructStubGeneric\n      1    0.1%    0.5%  Builtin: JSBuiltinsConstructStub\n      1    0.1%    0.5%  Builtin: IterableToList\n      1    0.1%    0.5%  Builtin: HasProperty\n      1    0.1%    0.5%  Builtin: GrowFastSmiOrObjectElements\n      1    0.1%    0.5%  Builtin: FindOrderedHashMapEntry\n      1    0.1%    0.5%  Builtin: CallFunction_ReceiverIsNullOrUndefined\n      1    0.1%    0.5%  Builtin: CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit\n      1    0.1%    0.5%  Builtin: ArrayPrototypePush\n      1    0.1%    0.5%  Builtin: ArgumentsAdaptorTrampoline\n\n [C++]:\n   ticks  total  nonlib   name\n\n [Summary]:\n   ticks  total  nonlib   name\n    196   17.9%   96.6%  JavaScript\n      0    0.0%    0.0%  C++\n     54    4.9%   26.6%  GC\n    894   81.5%          Shared libraries\n      7    0.6%          Unaccounted\n\n [C++ entry points]:\n   ticks    cpp   total   name\n\n [Bottom up (heavy) profile]:\n  Note: percentage shows a share of a particular caller in the total\n  amount of its parent calls.\n  Callers occupying less than 1.0% are not shown.\n\n   ticks parent  name\n    776   70.7%  &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n    725   93.4%    &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n    265   36.6%      LazyCompile: ~Script vm.js:44:14\n    265  100.0%        LazyCompile: ~createScript vm.js:273:22\n    265  100.0%          LazyCompile: ~runInThisContext vm.js:322:26\n    265  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n     46    6.3%      LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n     46  100.0%        LazyCompile: ~NativeModule.require internal&#x2F;bootstrap&#x2F;loaders.js:150:34\n      5   10.9%          LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      5  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      4    8.7%          Script: ~&lt;anonymous&gt; util.js:1:11\n      4  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      3    6.5%          Script: ~&lt;anonymous&gt; stream.js:1:11\n      3  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      3    6.5%          Script: ~&lt;anonymous&gt; internal&#x2F;fs&#x2F;streams.js:1:11\n      3  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      2    4.3%          Script: ~&lt;anonymous&gt; internal&#x2F;process&#x2F;main_thread_only.js:1:11\n      2  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      2    4.3%          Script: ~&lt;anonymous&gt; internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:1:11\n      2  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      2    4.3%          Script: ~&lt;anonymous&gt; internal&#x2F;child_process.js:1:11\n      2  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      2    4.3%          Script: ~&lt;anonymous&gt; crypto.js:1:11\n      2  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      2    4.3%          Script: ~&lt;anonymous&gt; assert.js:1:11\n      2  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; tty.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; tls.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; internal&#x2F;util&#x2F;inspect.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; internal&#x2F;crypto&#x2F;cipher.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; internal&#x2F;cluster&#x2F;master.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; internal&#x2F;async_hooks.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; http.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; fs.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; child_process.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; buffer.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; _stream_wrap.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; _stream_readable.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; _http_common.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; _http_client.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      1  100.0%            Script: ~bootstrapNodeJSCore internal&#x2F;bootstrap&#x2F;node.js:15:30\n      1    2.2%          LazyCompile: ~setupProcessObject internal&#x2F;bootstrap&#x2F;node.js:331:30\n      1  100.0%            LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      1    2.2%          LazyCompile: ~setupInspector internal&#x2F;bootstrap&#x2F;node.js:442:26\n      1  100.0%            LazyCompile: ~setupGlobalConsole internal&#x2F;bootstrap&#x2F;node.js:404:30\n      1    2.2%          LazyCompile: ~setupGlobalTimeouts internal&#x2F;bootstrap&#x2F;node.js:394:31\n      1  100.0%            LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      1    2.2%          LazyCompile: ~setupGlobalConsole internal&#x2F;bootstrap&#x2F;node.js:404:30\n      1  100.0%            LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      1    2.2%          LazyCompile: ~lookupAndConnect net.js:934:26\n      1  100.0%            LazyCompile: ~Socket.connect net.js:878:36\n      1    2.2%          LazyCompile: ~createWritableStdioStream internal&#x2F;process&#x2F;stdio.js:158:35\n      1  100.0%            LazyCompile: ~getStdout internal&#x2F;process&#x2F;stdio.js:18:21\n     43    5.9%      LazyCompile: ~load &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:51:14\n     43  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:1:11\n     43  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n     43  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n     24    3.3%      LazyCompile: ~toString buffer.js:643:46\n     24  100.0%        Builtin: CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit\n     24  100.0%          LazyCompile: ~load &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:51:14\n     24  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:1:11\n     24    3.3%      LazyCompile: ~readPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:153:21\n     24  100.0%        LazyCompile: ~tryPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:174:20\n     24  100.0%          LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n     21   87.5%            LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      3   12.5%            LazyCompile: *Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n     20    2.8%      LazyCompile: ~stringify &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;fn&#x2F;json&#x2F;stringify.js:3:36\n     18   90.0%        LazyCompile: ~save &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:32:14\n     18  100.0%          LazyCompile: ~_tickCallback internal&#x2F;process&#x2F;next_tick.js:41:25\n     18  100.0%            LazyCompile: ~Module.runMain internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:741:26\n      2   10.0%        LazyCompile: ~compile &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:100:17\n      2  100.0%          LazyCompile: ~loader &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:143:16\n      2  100.0%            LazyCompile: ~require.extensions.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:150:38\n     17    2.3%      LazyCompile: ~stat internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:84:14\n     11   64.7%        LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      9   81.8%          LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      9  100.0%            LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      2   18.2%          LazyCompile: ~tryPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:174:20\n      2  100.0%            LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      6   35.3%        LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      6  100.0%          LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      6  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n     17    2.3%      LazyCompile: ~fromString buffer.js:334:20\n     17  100.0%        LazyCompile: ~from buffer.js:199:28\n     17  100.0%          LazyCompile: ~writeFileSync fs.js:1184:23\n     17  100.0%            LazyCompile: ~save &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:32:14\n     11    1.5%      LazyCompile: ~stringSlice buffer.js:589:21\n     11  100.0%        LazyCompile: ~toString buffer.js:643:46\n     11  100.0%          LazyCompile: ~readFileSync fs.js:340:22\n      7   63.6%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      2   18.2%            LazyCompile: ~Module._extensions..json internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:717:39\n      2   18.2%            LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:64:35\n     10    1.4%      LazyCompile: ~byteLength buffer.js:509:20\n     10  100.0%        LazyCompile: ~fromString buffer.js:334:20\n     10  100.0%          LazyCompile: ~from buffer.js:199:28\n     10  100.0%            LazyCompile: ~writeFileSync fs.js:1184:23\n      8    1.1%      LazyCompile: ~Module._extensions..json internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:717:39\n      8  100.0%        LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      8  100.0%          LazyCompile: ~tryModuleLoad internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:536:23\n      8  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n\n     90    8.2%  &#x2F;usr&#x2F;lib64&#x2F;libc-2.17.so\n     57   63.3%    &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n      4    7.0%      Builtin: RegExpPrototypeExec\n      1   25.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:567:38\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:226:25\n      1  100.0%            LazyCompile: ~each &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:134:16\n      1   25.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:533:38\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:226:25\n      1  100.0%            LazyCompile: ~each &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:134:16\n      1   25.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:515:38\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:226:25\n      1  100.0%            LazyCompile: ~forOwn &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:168:18\n      1   25.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:500:38\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:226:25\n      1  100.0%            LazyCompile: ~each &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:134:16\n      2    3.5%      LazyCompile: ~load &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:51:14\n      2  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:1:11\n      2  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      2  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      2    3.5%      LazyCompile: ~am3 &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:102:13\n      2  100.0%        LazyCompile: ~bnpMultiplyTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:436:23\n      2  100.0%          LazyCompile: ~montMulTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:637:19\n      2  100.0%            LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      2    3.5%      LazyCompile: ~Module._extensions..json internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:717:39\n      2  100.0%        LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      2  100.0%          LazyCompile: ~tryModuleLoad internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:536:23\n      2  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      2    3.5%      LazyCompile: ~E internal&#x2F;errors.js:195:11\n      2  100.0%        Script: ~&lt;anonymous&gt; internal&#x2F;errors.js:1:11\n      2  100.0%          LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      2  100.0%            LazyCompile: ~NativeModule.require internal&#x2F;bootstrap&#x2F;loaders.js:150:34\n      2    3.5%      Builtin: ArrayForEach\n      1   50.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;wechat-api&#x2F;lib&#x2F;api_material.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1   50.0%        LazyCompile: ~_setExports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;assert-plus&#x2F;assert.js:98:21\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;assert-plus&#x2F;assert.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1    1.8%      Script: ~&lt;anonymous&gt; internal&#x2F;fixed_queue.js:1:11\n      1  100.0%        LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1  100.0%          LazyCompile: ~NativeModule.require internal&#x2F;bootstrap&#x2F;loaders.js:150:34\n      1  100.0%            LazyCompile: ~setupNextTick internal&#x2F;process&#x2F;next_tick.js:5:23\n      1    1.8%      Script: ~&lt;anonymous&gt; buffer.js:1:11\n      1  100.0%        LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1  100.0%          LazyCompile: ~NativeModule.require internal&#x2F;bootstrap&#x2F;loaders.js:150:34\n      1  100.0%            Script: ~&lt;anonymous&gt; util.js:1:11\n      1    1.8%      Script: ~&lt;anonymous&gt; :1:1\n      1    1.8%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;request&#x2F;index.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~require.extensions.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:150:38\n      1    1.8%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;mkdirp&#x2F;index.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    1.8%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_createSet.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    1.8%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;_uid.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    1.8%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-types&#x2F;lib&#x2F;index.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    1.8%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-types&#x2F;lib&#x2F;converters.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    1.8%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-runtime&#x2F;helpers&#x2F;extends.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    1.8%      LazyCompile: ~useColors &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;node_modules&#x2F;debug&#x2F;src&#x2F;node.js:73:19\n      1  100.0%        LazyCompile: ~createDebug &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;node_modules&#x2F;debug&#x2F;src&#x2F;debug.js:62:21\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;log4js.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1    1.8%      LazyCompile: ~thenCallback &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;join.js:13:32\n      1  100.0%        LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;join.js:3:9\n      1  100.0%          LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:2:26\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;bluebird.js:1:11\n      1    1.8%      LazyCompile: ~sync &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;mkdirp&#x2F;index.js:55:29\n      1  100.0%        LazyCompile: ~BaseRollingFileStream.openTheStream &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;streamroller&#x2F;lib&#x2F;BaseRollingFileStream.js:76:57\n      1  100.0%          LazyCompile: ~BaseRollingFileStream &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;streamroller&#x2F;lib&#x2F;BaseRollingFileStream.js:12:31\n      1  100.0%            LazyCompile: ~DateRollingFileStream &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;streamroller&#x2F;lib&#x2F;DateRollingFileStream.js:15:31\n      1    1.8%      LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      1  100.0%        Script: ~bootstrapNodeJSCore internal&#x2F;bootstrap&#x2F;node.js:15:30\n      1    1.8%      LazyCompile: ~runInThisContext vm.js:114:19\n      1  100.0%        LazyCompile: ~runInThisContext vm.js:322:26\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1    1.8%      LazyCompile: ~resolve path.js:1068:28\n      1  100.0%        LazyCompile: ~Module._resolveLookupPaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:401:38\n      1  100.0%          LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1    1.8%      LazyCompile: ~parseBuffer &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:11927:21\n      1  100.0%        LazyCompile: ~loadSync &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:12152:18\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;svg-captcha&#x2F;lib&#x2F;option-manager.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1    1.8%      LazyCompile: ~nextTick internal&#x2F;process&#x2F;next_tick.js:96:20\n      1  100.0%        LazyCompile: ~load &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:51:14\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1    1.8%      LazyCompile: ~json &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;body-parser&#x2F;lib&#x2F;types&#x2F;json.js:50:15\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;server&#x2F;api&#x2F;apiServer.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~loader &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:143:16\n      1    1.8%      LazyCompile: ~getRawTag &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_getRawTag.js:26:19\n      1  100.0%        LazyCompile: ~baseGetTag &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_baseGetTag.js:19:20\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_getTag.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1    1.8%      LazyCompile: ~emit events.js:147:44\n      1  100.0%        LazyCompile: ~RedisClient.on_connect &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;redis&#x2F;index.js:413:45\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;redis&#x2F;index.js:265:46\n      1  100.0%            LazyCompile: ~onceWrapper events.js:273:21\n      1    1.8%      LazyCompile: ~dataIntersection &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regenerate&#x2F;regenerate.js:452:33\n      1  100.0%        LazyCompile: ~intersection &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regenerate&#x2F;regenerate.js:1137:27\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regexpu-core&#x2F;rewrite-pattern.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1    1.8%      LazyCompile: ~configForCategory &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;categories.js:89:27\n      1  100.0%        LazyCompile: ~getLevelForCategory &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;categories.js:104:29\n      1  100.0%          LazyCompile: ~get level &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;logger.js:34:12\n      1  100.0%            LazyCompile: ~Logger &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;logger.js:25:14\n      1    1.8%      LazyCompile: ~compile &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:100:17\n      1  100.0%        LazyCompile: ~loader &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:143:16\n      1  100.0%          LazyCompile: ~require.extensions.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:150:38\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    1.8%      LazyCompile: ~bnpSubTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:402:18\n      1  100.0%        LazyCompile: ~bnModInverse &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1351:22\n      1  100.0%          LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      1  100.0%            LazyCompile: ~module.exports.NodeRSA.generateKeyPair &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:156:50\n      1    1.8%      LazyCompile: ~asString &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;date-format&#x2F;lib&#x2F;index.js:34:18\n      1  100.0%        LazyCompile: ~DateRollingFileStream &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;streamroller&#x2F;lib&#x2F;DateRollingFileStream.js:15:31\n      1  100.0%          LazyCompile: ~appender &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;appenders&#x2F;dateFile.js:16:18\n      1  100.0%            LazyCompile: ~configure &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;appenders&#x2F;dateFile.js:42:19\n      1    1.8%      LazyCompile: ~arrayFilter &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:574:23\n      1  100.0%        LazyCompile: ~baseFunctions &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:3020:27\n      1  100.0%          LazyCompile: ~mixin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:15688:19\n      1  100.0%            Script: ~runInContext &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:1406:44\n      1    1.8%      LazyCompile: ~_interopRequireDefault &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;util.js:59:32\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;util.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1    1.8%      LazyCompile: ~TimeFormat &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;server&#x2F;common&#x2F;index.js:4:36\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;server&#x2F;api&#x2F;apiServer.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~loader &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:143:16\n      1    1.8%      LazyCompile: ~OptionManager &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:84:25\n      1  100.0%        LazyCompile: ~compile &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:100:17\n      1  100.0%          LazyCompile: ~loader &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:143:16\n      1  100.0%            LazyCompile: ~require.extensions.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:150:38\n      1    1.8%      LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:377:36\n      1  100.0%        Builtin: ArrayMap\n      1  100.0%          LazyCompile: ~prepareStackTrace &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:371:27\n      1  100.0%            &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n      1    1.8%      LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:226:25\n      1  100.0%        LazyCompile: ~each &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:134:16\n      1  100.0%          LazyCompile: ~reduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:224:18\n      1  100.0%            LazyCompile: ~getProduct &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:566:24\n      1    1.8%      LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:4903:22\n      1  100.0%        LazyCompile: ~baseForOwn &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:2995:24\n      1  100.0%          Script: ~runInContext &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:1406:44\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:9:11\n      1    1.8%      LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;_collection.js:22:95\n      1  100.0%        LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;_fails.js:1:89\n      1  100.0%          LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;_collection.js:16:27\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;es6.map.js:1:11\n      1    1.8%      LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;store.js:23:22\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;store.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1    1.8%      LazyCompile: *normalizeString path.js:52:25\n      1  100.0%        LazyCompile: ~resolve path.js:1068:28\n      1  100.0%          LazyCompile: ~readPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:153:21\n      1  100.0%            LazyCompile: ~tryPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:174:20\n      1    1.8%      LazyCompile: *montReduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:609:20\n      1  100.0%        LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      1  100.0%          LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%            LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1    1.8%      LazyCompile: *bnpSquareTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:448:21\n      1  100.0%        LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      1  100.0%          LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%            LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1    1.8%      LazyCompile: *Module._nodeModulePaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:360:37\n      1  100.0%        LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1  100.0%          LazyCompile: ~tryModuleLoad internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:536:23\n      1  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1    1.8%      Eval: ~&lt;anonymous&gt; :1:1\n      1  100.0%        Builtin: CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit\n      1  100.0%          LazyCompile: ~thenCallback &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;join.js:13:32\n      1  100.0%            LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;join.js:3:9\n      1    1.8%      Builtin: StringPrototypeReplace\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_baseIsNative.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1    1.8%      Builtin: RegExpPrototypeTest\n      1  100.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;connect-redis&#x2F;node_modules&#x2F;debug&#x2F;src&#x2F;node.js:49:64\n      1  100.0%          Builtin: ArrayFilter\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;connect-redis&#x2F;node_modules&#x2F;debug&#x2F;src&#x2F;node.js:1:11\n      1    1.8%      Builtin: MapPrototypeSet\n      1  100.0%        LazyCompile: *stat internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:84:14\n      1  100.0%          LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      1  100.0%            LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      3    3.3%    LazyCompile: *stat internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:84:14\n      2   66.7%      LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      2  100.0%        LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      2  100.0%          LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      2  100.0%            LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1   33.3%      LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%        LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%          LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      2    2.2%    LazyCompile: *realpathSync fs.js:1375:22\n      2  100.0%      LazyCompile: ~toRealPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:202:20\n      1   50.0%        LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      1  100.0%          LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      1  100.0%            LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1   50.0%        LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%          LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1    1.1%    LazyCompile: ~realpathSync fs.js:1375:22\n      1  100.0%      LazyCompile: *tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      1  100.0%        LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      1  100.0%          LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%            LazyCompile: *Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1    1.1%    LazyCompile: ~nullCheck internal&#x2F;fs&#x2F;utils.js:188:19\n      1  100.0%      LazyCompile: ~validatePath internal&#x2F;fs&#x2F;utils.js:442:22\n      1  100.0%        LazyCompile: ~realpathSync fs.js:1375:22\n      1  100.0%          LazyCompile: ~toRealPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:202:20\n      1  100.0%            LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      1    1.1%    LazyCompile: *tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      1  100.0%      LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      1  100.0%        LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%          LazyCompile: *Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n\n     15    1.4%  &#x2F;usr&#x2F;lib64&#x2F;libpthread-2.17.so\n      3   20.0%    &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n      1   33.3%      LazyCompile: ~memoisePluginContainer &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:92:73\n      1  100.0%        LazyCompile: ~normalisePlugin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:141:59\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:158:33\n      1  100.0%            Builtin: ArrayMap\n      1   33.3%      LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1  100.0%        LazyCompile: ~tryModuleLoad internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:536:23\n      1  100.0%          LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1   33.3%      LazyCompile: *runInThisContext vm.js:114:19\n      1  100.0%        LazyCompile: ~runInThisContext vm.js:322:26\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n\n     13    1.2%  Builtin: InterpreterEntryTrampoline\n      2   15.4%    LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      2  100.0%      LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1   50.0%        LazyCompile: ~exports.default &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;helpers&#x2F;resolve.js:9:28\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;helpers&#x2F;resolve-from-possible-names.js:13:40\n      1  100.0%            Builtin: ArrayReduce\n      1   50.0%        LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%          LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1  100.0%            LazyCompile: ~require internal&#x2F;modules&#x2F;cjs&#x2F;helpers.js:19:19\n      2   15.4%    Builtin: ArrayMap\n      1   50.0%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;psl&#x2F;index.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~require.extensions.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:150:38\n      1   50.0%      LazyCompile: ~normalisePlugins &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:157:61\n      1  100.0%        LazyCompile: ~mergeOptions &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:190:63\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:264:52\n      1  100.0%            LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:275:33\n      1    7.7%    LazyCompile: ~join native array.js:280:46\n      1  100.0%      LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%        LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%          LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1    7.7%    LazyCompile: ~cloneCallSite &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:314:23\n      1  100.0%      LazyCompile: ~wrapCallSite &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:323:22\n      1  100.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:377:36\n      1  100.0%          Builtin: ArrayMap\n      1  100.0%            LazyCompile: ~prepareStackTrace &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:371:27\n      1    7.7%    LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%      LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1  100.0%        LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      1  100.0%          LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n      1  100.0%            LazyCompile: ~BigInteger &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:50:20\n      1    7.7%    LazyCompile: ~Route.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;express&#x2F;lib&#x2F;router&#x2F;route.js:193:37\n      1  100.0%      LazyCompile: ~proto.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;express&#x2F;lib&#x2F;router&#x2F;index.js:508:27\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;server&#x2F;api&#x2F;frontEnd&#x2F;verify&#x2F;index.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~loader &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:143:16\n      1    7.7%    LazyCompile: ~NativeModule.nonInternalExists internal&#x2F;bootstrap&#x2F;loaders.js:216:46\n      1  100.0%      LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%        LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%          LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1  100.0%            LazyCompile: ~require internal&#x2F;modules&#x2F;cjs&#x2F;helpers.js:19:19\n      1    7.7%    LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1  100.0%      LazyCompile: ~tryModuleLoad internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:536:23\n      1  100.0%        LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%          LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1  100.0%            LazyCompile: ~require internal&#x2F;modules&#x2F;cjs&#x2F;helpers.js:19:19\n      1    7.7%    LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%      LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1  100.0%        LazyCompile: ~require internal&#x2F;modules&#x2F;cjs&#x2F;helpers.js:19:19\n      1  100.0%          LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promisify.js:2:26\n      1  100.0%            LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:2:26\n      1    7.7%    LazyCompile: ~Join native array.js:112:14\n      1  100.0%      LazyCompile: ~InnerArrayJoin native array.js:267:24\n      1  100.0%        LazyCompile: ~join native array.js:280:46\n      1  100.0%          LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%            LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1    7.7%    LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_createBaseFor.js:9:18\n      1  100.0%      LazyCompile: ~baseMerge &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_baseMerge.js:20:19\n      1  100.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;mergeWith.js:35:40\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_createAssigner.js:12:27\n      1  100.0%            LazyCompile: ~apply &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_apply.js:11:15\n\n     12    1.1%  &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6.0.19\n      9   75.0%    &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n      1   11.1%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-types&#x2F;lib&#x2F;definitions&#x2F;experimental.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1   11.1%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-helper-optimise-call-expression&#x2F;lib&#x2F;index.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~require.extensions.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:150:38\n      1   11.1%      LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;_iter-define.js:18:27\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;es6.array.iterator.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1   11.1%      LazyCompile: ~levels.forEach &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;levels.js:52:22\n      1  100.0%        Builtin: ArrayForEach\n      1  100.0%          LazyCompile: ~addLevels &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;levels.js:49:19\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;levels.js:1:11\n      1   11.1%      LazyCompile: ~getFixed &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:2077:18\n      1  100.0%        LazyCompile: ~Parser.parseFixed &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:2186:39\n      1  100.0%          LazyCompile: ~parseHeadTable &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:5114:24\n      1  100.0%            LazyCompile: ~parseBuffer &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:11927:21\n      1   11.1%      LazyCompile: ~exports.createClient &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;redis&#x2F;index.js:1088:33\n      1  100.0%        LazyCompile: ~RedisStore &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;connect-redis&#x2F;lib&#x2F;connect-redis.js:52:23\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;server&#x2F;api&#x2F;apiServer.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1   11.1%      LazyCompile: ~Module._resolveLookupPaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:401:38\n      1  100.0%        LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%          LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1   11.1%      Builtin: RegExpPrototypeExec\n      1  100.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:567:38\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:226:25\n      1  100.0%            LazyCompile: ~each &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:134:16\n      1   11.1%      Builtin: ArrayPrototypePush\n      1  100.0%        LazyCompile: ~dataIntersection &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regenerate&#x2F;regenerate.js:452:33\n      1  100.0%          LazyCompile: ~intersection &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regenerate&#x2F;regenerate.js:1137:27\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regexpu-core&#x2F;rewrite-pattern.js:1:11\n      1    8.3%    LazyCompile: ~overRest &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:6552:22\n      1  100.0%      LazyCompile: ~baseRest &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:3933:22\n      1  100.0%        Script: ~runInContext &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:1406:44\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:9:11\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:1:11\n\n     11    1.0%  LazyCompile: *montReduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:609:20\n      6   54.5%    LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      6  100.0%      LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      6  100.0%        LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      6  100.0%          LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      4   66.7%            LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      2   33.3%            LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n      3   27.3%    LazyCompile: ~montMulTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:637:19\n      3  100.0%      LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      3  100.0%        LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      3  100.0%          LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      2   66.7%            LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n      1   33.3%            LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      2   18.2%    LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      2  100.0%      LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      2  100.0%        LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      2  100.0%          LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      2  100.0%            LazyCompile: ~module.exports.NodeRSA.generateKeyPair &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:156:50\n</code></pre></div>","title":"帮忙分析下NODEJS 线上性能日志!","last_reply_at":"2019-04-26T03:14:19.841Z","good":false,"top":false,"reply_count":4,"visit_count":792,"create_at":"2019-04-25T08:27:53.670Z","author":{"loginname":"xulayen","avatar_url":"https://avatars1.githubusercontent.com/u/15044564?v=4&s=120"}},{"id":"5cc2772e37faec0ce1d06e88","author_id":"59b0fced1b37e54f6793c3d6","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>一下是性能测试图，帮我分析下NODEJS存在什么问题。</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/Fra2s0BblhhY89Op0ckwUIBh23XM\" alt=\"image.png\"></p>\n<blockquote>\n<p>解析出来的日志</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>Statistical profiling result from isolate-0x3a8cb30-v8.log, (188 ticks, 0 unaccounted, 0 excluded).\n\n [Shared libraries]:\n   ticks  total  nonlib   name\n    116   61.7%          &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n     18    9.6%          &#x2F;usr&#x2F;lib64&#x2F;libc-2.17.so\n     12    6.4%          &#x2F;usr&#x2F;lib64&#x2F;libpthread-2.17.so\n      1    0.5%          &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6.0.19\n\n [JavaScript]:\n   ticks  total  nonlib   name\n      6    3.2%   14.6%  LazyCompile: *bnpSquareTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:448:21\n      4    2.1%    9.8%  LazyCompile: *montReduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:609:20\n      3    1.6%    7.3%  LazyCompile: *bnpMultiplyTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:436:23\n      3    1.6%    7.3%  Builtin: CallFunction_ReceiverIsAny\n      2    1.1%    4.9%  RegExp: ^screen|^xterm|^vt100|color|ansi|cygwin|linux\n      2    1.1%    4.9%  Builtin: KeyedStoreIC_Megamorphic\n      2    1.1%    4.9%  Builtin: InterpreterEntryTrampoline\n      1    0.5%    2.4%  Script: ~&lt;anonymous&gt; internal&#x2F;querystring.js:1:11\n      1    0.5%    2.4%  LazyCompile: ~validateInteger vm.js:150:25\n      1    0.5%    2.4%  LazyCompile: ~resolve path.js:1068:28\n      1    0.5%    2.4%  LazyCompile: ~require internal&#x2F;modules&#x2F;cjs&#x2F;helpers.js:19:19\n      1    0.5%    2.4%  LazyCompile: ~relative path.js:1161:30\n      1    0.5%    2.4%  LazyCompile: ~forEachCode &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;csurf&#x2F;node_modules&#x2F;http-errors&#x2F;index.js:190:38\n      1    0.5%    2.4%  LazyCompile: ~defineDependentProperty &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:3725:33\n      1    0.5%    2.4%  LazyCompile: ~Script vm.js:44:14\n      1    0.5%    2.4%  LazyCompile: ~Module.wrap internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:125:23\n      1    0.5%    2.4%  LazyCompile: ~Module._resolveLookupPaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:401:38\n      1    0.5%    2.4%  LazyCompile: *resolve path.js:1068:28\n      1    0.5%    2.4%  LazyCompile: *relative path.js:1161:30\n      1    0.5%    2.4%  LazyCompile: *montMulTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:637:19\n      1    0.5%    2.4%  LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1    0.5%    2.4%  LazyCompile: *Module._nodeModulePaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:360:37\n      1    0.5%    2.4%  Builtin: StringAdd_CheckNone_NotTenured\n      1    0.5%    2.4%  Builtin: StoreIC_Uninitialized\n      1    0.5%    2.4%  Builtin: LoadIC\n      1    0.5%    2.4%  Builtin: IterableToList\n\n [C++]:\n   ticks  total  nonlib   name\n\n [Summary]:\n   ticks  total  nonlib   name\n     41   21.8%  100.0%  JavaScript\n      0    0.0%    0.0%  C++\n     20   10.6%   48.8%  GC\n    147   78.2%          Shared libraries\n\n [C++ entry points]:\n   ticks    cpp   total   name\n\n [Bottom up (heavy) profile]:\n  Note: percentage shows a share of a particular caller in the total\n  amount of its parent calls.\n  Callers occupying less than 1.0% are not shown.\n\n   ticks parent  name\n    116   61.7%  &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n    109   94.0%    &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n     42   38.5%      LazyCompile: ~Script vm.js:44:14\n     42  100.0%        LazyCompile: ~createScript vm.js:273:22\n     42  100.0%          LazyCompile: ~runInThisContext vm.js:322:26\n     42  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      5    4.6%      LazyCompile: ~toString buffer.js:643:46\n      5  100.0%        Builtin: CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit\n      5  100.0%          LazyCompile: ~load &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:51:14\n      5  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:1:11\n      5    4.6%      LazyCompile: ~load &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:51:14\n      5  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:1:11\n      5  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      5  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      4    3.7%      LazyCompile: ~stringSlice buffer.js:589:21\n      4  100.0%        LazyCompile: ~toString buffer.js:643:46\n      4  100.0%          LazyCompile: ~readFileSync fs.js:340:22\n      2   50.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1   25.0%            LazyCompile: ~addConfig &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;build-config-chain.js:137:62\n      1   25.0%            LazyCompile: ~Module._extensions..json internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:717:39\n      4    3.7%      LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      4  100.0%        LazyCompile: ~NativeModule.require internal&#x2F;bootstrap&#x2F;loaders.js:150:34\n      1   25.0%          Script: ~&lt;anonymous&gt; internal&#x2F;child_process.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1   25.0%          Script: ~&lt;anonymous&gt; http.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1   25.0%          Script: ~&lt;anonymous&gt; buffer.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1   25.0%          LazyCompile: ~setupProcessFatal internal&#x2F;bootstrap&#x2F;node.js:479:29\n      1  100.0%            LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      3    2.8%      LazyCompile: ~stat internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:84:14\n      2   66.7%        LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      2  100.0%          LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      2  100.0%            LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1   33.3%        LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%          LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      3    2.8%      LazyCompile: ~realpathSync fs.js:1375:22\n      3  100.0%        LazyCompile: ~toRealPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:202:20\n      3  100.0%          LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      2   66.7%            LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      1   33.3%            LazyCompile: ~tryPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:174:20\n      3    2.8%      LazyCompile: ~fromString buffer.js:334:20\n      3  100.0%        LazyCompile: ~from buffer.js:199:28\n      3  100.0%          LazyCompile: ~writeFileSync fs.js:1184:23\n      3  100.0%            LazyCompile: ~save &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:32:14\n      3    2.8%      LazyCompile: ~Module._extensions..json internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:717:39\n      3  100.0%        LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      3  100.0%          LazyCompile: ~tryModuleLoad internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:536:23\n      3  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      2    1.8%      LazyCompile: ~stringify &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;fn&#x2F;json&#x2F;stringify.js:3:36\n      2  100.0%        LazyCompile: ~save &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:32:14\n      2  100.0%          LazyCompile: ~_tickCallback internal&#x2F;process&#x2F;next_tick.js:41:25\n      2  100.0%            LazyCompile: ~Module.runMain internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:741:26\n      2    1.8%      LazyCompile: ~readPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:153:21\n      2  100.0%        LazyCompile: ~tryPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:174:20\n      2  100.0%          LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      2  100.0%            LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      2    1.8%      LazyCompile: ~am3 &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:102:13\n      2  100.0%        LazyCompile: ~bnpSquareTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:448:21\n      2  100.0%          LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      2  100.0%            LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n\n     18    9.6%  &#x2F;usr&#x2F;lib64&#x2F;libc-2.17.so\n     10   55.6%    &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n      3   30.0%      LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      3  100.0%        LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      3  100.0%          LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      3  100.0%            LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      2   20.0%      LazyCompile: ~load &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:51:14\n      2  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:1:11\n      2  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      2  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1   10.0%      RegExp: ^screen|^xterm|^vt100|color|ansi|cygwin|linux\n      1  100.0%        LazyCompile: ~montReduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:609:20\n      1  100.0%          LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      1  100.0%            LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1   10.0%      LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      1  100.0%        Script: ~bootstrapNodeJSCore internal&#x2F;bootstrap&#x2F;node.js:15:30\n      1   10.0%      LazyCompile: ~getRawTag &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_getRawTag.js:26:19\n      1  100.0%        LazyCompile: ~baseGetTag &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_baseGetTag.js:19:20\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_getTag.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1   10.0%      LazyCompile: ~am3 &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:102:13\n      1  100.0%        LazyCompile: ~bnpSquareTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:448:21\n      1  100.0%          LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      1  100.0%            LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1   10.0%      LazyCompile: ~BigInteger &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:50:20\n      1  100.0%        LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%          LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1  100.0%            LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      1    5.6%    LazyCompile: *stat internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:84:14\n      1  100.0%      LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      1  100.0%        LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      1  100.0%          LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%            LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n\n     12    6.4%  &#x2F;usr&#x2F;lib64&#x2F;libpthread-2.17.so\n      3   25.0%    &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n      1   33.3%      LazyCompile: ~setupInspector internal&#x2F;bootstrap&#x2F;node.js:442:26\n      1  100.0%        LazyCompile: ~setupGlobalConsole internal&#x2F;bootstrap&#x2F;node.js:404:30\n      1  100.0%          LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      1  100.0%            Script: ~bootstrapNodeJSCore internal&#x2F;bootstrap&#x2F;node.js:15:30\n      1   33.3%      LazyCompile: ~Module._resolveLookupPaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:401:38\n      1  100.0%        LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%          LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1   33.3%      LazyCompile: ~BigInteger &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:50:20\n      1  100.0%        LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%          LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1  100.0%            LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n\n      6    3.2%  LazyCompile: *bnpSquareTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:448:21\n      3   50.0%    LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      3  100.0%      LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      3  100.0%        LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      3  100.0%          LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      3  100.0%            LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n      3   50.0%    LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      3  100.0%      LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      3  100.0%        LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      2   66.7%          LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n      2  100.0%            LazyCompile: ~BigInteger &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:50:20\n      1   33.3%          LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      1  100.0%            LazyCompile: ~module.exports.NodeRSA.generateKeyPair &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:156:50\n\n      4    2.1%  LazyCompile: *montReduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:609:20\n      2   50.0%    LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      2  100.0%      LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      2  100.0%        LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      2  100.0%          LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      2  100.0%            LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      2   50.0%    LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      2  100.0%      LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      2  100.0%        LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      2  100.0%          LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n      2  100.0%            LazyCompile: ~BigInteger &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:50:20\n\n      3    1.6%  LazyCompile: *bnpMultiplyTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:436:23\n      2   66.7%    LazyCompile: *montMulTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:637:19\n      2  100.0%      LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      2  100.0%        LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      2  100.0%          LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      1   50.0%            LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      1   50.0%            LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n      1   33.3%    LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%      LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1  100.0%        LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      1  100.0%          LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      1  100.0%            LazyCompile: ~module.exports.NodeRSA.generateKeyPair &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:156:50\n\n      3    1.6%  Builtin: CallFunction_ReceiverIsAny\n      1   33.3%    LazyCompile: ~callSiteLocation &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;depd&#x2F;index.js:251:27\n      1  100.0%      LazyCompile: ~wrapfunction &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;depd&#x2F;index.js:397:23\n      1  100.0%        LazyCompile: ~populateConstructorExports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;http-errors&#x2F;index.js:225:37\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;http-errors&#x2F;index.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1   33.3%    LazyCompile: ~assertEncoding internal&#x2F;fs&#x2F;utils.js:58:24\n      1  100.0%      LazyCompile: ~getOptions internal&#x2F;fs&#x2F;utils.js:167:20\n      1  100.0%        LazyCompile: ~readFileSync fs.js:340:22\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1   33.3%    LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;psl&#x2F;index.js:14:61\n      1  100.0%      Builtin: ArrayMap\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;psl&#x2F;index.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n\n      2    1.1%  RegExp: ^screen|^xterm|^vt100|color|ansi|cygwin|linux\n      2  100.0%    LazyCompile: ~montReduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:609:20\n      1   50.0%      LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      1  100.0%        LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%          LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1  100.0%            LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      1   50.0%      LazyCompile: ~montMulTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:637:19\n      1  100.0%        LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%          LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1  100.0%            LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n\n      2    1.1%  Builtin: KeyedStoreIC_Megamorphic\n      1   50.0%    LazyCompile: ~bnpSubTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:402:18\n      1  100.0%      LazyCompile: ~bnModInverse &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1351:22\n      1  100.0%        LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      1  100.0%          LazyCompile: ~module.exports.NodeRSA.generateKeyPair &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:156:50\n      1  100.0%            LazyCompile: ~NodeRSA &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:45:21\n      1   50.0%    LazyCompile: *bnpSquareTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:448:21\n      1  100.0%      LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%        LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1  100.0%          LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      1  100.0%            LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n\n      2    1.1%  Builtin: InterpreterEntryTrampoline\n      1   50.0%    LazyCompile: ~bnModInverse &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1351:22\n      1  100.0%      LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      1  100.0%        LazyCompile: ~module.exports.NodeRSA.generateKeyPair &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:156:50\n      1  100.0%          LazyCompile: ~NodeRSA &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:45:21\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;server&#x2F;common&#x2F;ResultFactory&#x2F;index.js:1:11\n      1   50.0%    LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%      LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1  100.0%        LazyCompile: ~tryModuleLoad internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:536:23\n      1  100.0%          LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n\n\n</code></pre></div>","title":"V8性能测试图","last_reply_at":"2019-04-26T03:12:46.682Z","good":false,"top":false,"reply_count":0,"visit_count":582,"create_at":"2019-04-26T03:12:46.682Z","author":{"loginname":"xulayen","avatar_url":"https://avatars1.githubusercontent.com/u/15044564?v=4&s=120"}},{"id":"5b3748c457137f22415c5143","author_id":"5b37469f57137f22415c5140","tab":"share","content":"<div class=\"markdown-text\"><p>当你用了Koa以后，你肯定不会再用express，因为Koa太优秀了!</p>\n<p><strong>2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\"></a><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w</a></p>\n<p>Nodejs Koa交流群：319732955   想和大神交流的加下群</p>\n</div>","title":"2018 Nodejs+Koa2入门实战视频教程【共41集】-欢迎拍砖免费分享【网盘直接下载】","last_reply_at":"2019-04-26T00:14:33.134Z","good":false,"top":false,"reply_count":57,"visit_count":12629,"create_at":"2018-06-30T09:09:24.209Z","author":{"loginname":"koa666","avatar_url":"https://avatars3.githubusercontent.com/u/37576865?v=4&s=120"}},{"id":"5cc1603f37faec0ce1d06906","author_id":"5cc15db237faec0ce1d068eb","tab":"ask","content":"<div class=\"markdown-text\"><p>问题：session在node中是如何存储的 ？\n最近了解 session cookie的相关概念，然后使用了egg-passport实践了一下\n发现对session的存储有一些疑惑\n通过阅读passport的源码，看到最后是执行到ctx.req.session = xxxx； 这样就保存了session到服务器中吗？\n在脑海里没有很清晰的思路，究竟session是存在哪里，怎么存的\n通过编辑器的提醒 Context.req: IncomingMessage，又找到了node http模块中IncomingMessage相关内容 并没有发现与session 有什么关联\n感觉ctx.req.session = xxxx;是个黑盒子，里面完成了什么内容完全不清楚？\n请问有大佬说说node中 session的理解吗？或者有什么思路\ngoogle了很多 都是如何使用框架进行可持续化的session存储，但是对原理好像没有什么讲述到\n尝试了 ctx.req.abc = 123 进行赋值\n反序列化的时候取ctx.req.abc 是undefined的，并没有存下来，那么就是对session这个字段有特别处理？</p>\n</div>","title":"session在node中是如何存储的 ？","last_reply_at":"2019-04-25T17:18:13.791Z","good":false,"top":false,"reply_count":3,"visit_count":680,"create_at":"2019-04-25T07:22:39.877Z","author":{"loginname":"CrewS","avatar_url":"https://avatars1.githubusercontent.com/u/5671380?v=4&s=120"}},{"id":"5cc09d3637faec0ce1d06381","author_id":"5cc09b18a86ae80ce64b3990","tab":"ask","content":"<div class=\"markdown-text\"><p>node 版本號 10.15.3\n執行程式碼<img src=\"//static.cnodejs.org/FiaL1ov1BRH7ubA6xL_tZwclgU16\" alt=\"保存方法.jpg\">\n第一次執行路徑與結果\n代碼\n<img src=\"//static.cnodejs.org/Fo8OwkgCmK9HIs63EcJCtPpGx_fI\" alt=\"9487碼.jpg\">\n執行結果:有\n<img src=\"//static.cnodejs.org/Fop1v8TGiKlcHLeK_h9_eWfLbHih\" alt=\"執行結果.jpg\">\n路徑以及輸出的資料:有輸出資料\n<img src=\"//static.cnodejs.org/FgVlecHNZMxw7ekz-75nNEXwUvx8\" alt=\"路徑.jpg\">\n第一次成功寫入，但第二次卻沒有寫入但有執行\n第二次執行路徑與結果\n代碼\n<img src=\"//static.cnodejs.org/FvrSJN_6u0nHaIV4Lgc5mlcpo_yw\" alt=\"9488碼.jpg\">\n輸出結果:有\n<img src=\"//static.cnodejs.org/FjxrbAnhomH2H_VM-f5AXuDeILWt\" alt=\"9488結果.jpg\">\n路徑及輸出的資料:沒有輸出的資料\n<img src=\"//static.cnodejs.org/FmqtnT2ZxUpjEWIz2LASz1xd1tgv\" alt=\"9488路徑.jpg\"></p>\n<p>請問各位大大有誰知道這中間發生了甚麼事情嗎 ??</p>\n</div>","title":"有關 fs.writeFile() 有執行但沒有寫入文件的情況","last_reply_at":"2019-04-25T16:21:14.671Z","good":false,"top":false,"reply_count":5,"visit_count":622,"create_at":"2019-04-24T17:30:30.052Z","author":{"loginname":"Jack0427","avatar_url":"https://avatars1.githubusercontent.com/u/41355986?v=4&s=120"}},{"id":"5b8cdb3a71b88cc417ed0846","author_id":"5b74f778a210553a0cde2979","tab":"ask","content":"<div class=\"markdown-text\"><p>求告知react的入门相关书籍！！！</p>\n</div>","title":"如何才能学好react？","last_reply_at":"2019-04-25T14:27:44.974Z","good":false,"top":false,"reply_count":48,"visit_count":4506,"create_at":"2018-09-03T06:56:58.686Z","author":{"loginname":"zhuhaifeng1251pm","avatar_url":"https://avatars1.githubusercontent.com/u/41354007?v=4&s=120"}},{"id":"5cc1846e37faec0ce1d06a8c","author_id":"5bd1dc3dad50495f5e2fbb45","tab":"ask","content":"<div class=\"markdown-text\"><p>大家帮忙看一下除了一下一些在真实项目中使用的时候，还有其他的一些点吗？</p>\n<ol>\n<li>链路跟踪\n如何在真实业务场景中做链路的跟踪，如使用opentracing机制进行链路跟踪，如利用开源项目：Zipkin</li>\n<li>错误监控\n如何当node报错的时候，将错误收集起来，这块例如使用sentry进行收集</li>\n<li>业务监控和性能监控和服务器信息监控\n这块的话当前是用Grafana进行监控，数据库用elasticsearch或者一些时序数据库。</li>\n<li>日志监控\n为了在生产环境中使用，如何做日志数据集合，在统一平台查看。这块当前采用flume + flume-collector + kafka + flink + elasticsearch等做日志平台</li>\n<li>性能提升这块\n当前做swagger的接口与Grafana的每个接口性能的监控。\n6.压测情况\n每个接口开发完毕，使用autocannon进行压测，确保本地的压测结果不太差。\n7.内存泄漏\n通过Grafana做内存、cpu等的曲线图展示，利用alinode分析。</li>\n<li>配置中心\n对接阿波罗配置中心，将一些配置抽离到配置中心。\n9.服务注册发现\n利用consul + nginx做的服务注册发现，不在应用级别侵入做的服务注册发现。</li>\n<li>流控\n用一个middleware简单处理</li>\n<li>cache机制\n封装的装饰器，内部是redis做cache机制</li>\n</ol>\n<p><img src=\"//static.cnodejs.org/FofIz1k_2xqSehoL4wV7I-0TyE49\" alt=\"image.png\"></p>\n</div>","title":"关于如何在真实项目中提升企业级Node这块的地位","last_reply_at":"2019-04-25T13:36:01.317Z","good":false,"top":false,"reply_count":1,"visit_count":593,"create_at":"2019-04-25T09:57:02.678Z","author":{"loginname":"stone-jin","avatar_url":"https://avatars3.githubusercontent.com/u/6525544?v=4&s=120"}},{"id":"5cbeae4e37faec0ce1d0510d","author_id":"541bf946ad60405c1f14b770","tab":"share","content":"<div class=\"markdown-text\"><p>这是一篇广告文，需要的请自取，现在京东打折满100减50~\n<img src=\"https://p3.ssl.qhimg.com/t015e54d793a5ace2c2.jpg\" alt=\"five\"></p>\n<p>购书京东二维码：<img src=\"https://p5.ssl.qhimg.com/t0152e01126216557ce.png\" alt=\"qrcode\"> 购书链接： <a href=\"https://item.jd.com/12573168.html\">https://item.jd.com/12573168.html</a></p>\n<p><img src=\"https://p0.ssl.qhimg.com/t0185cc475190c62f44.jpg\" alt=\"one\">\n<img src=\"https://p5.ssl.qhimg.com/t0147a2c928579d3b70.jpg\" alt=\"two\">\n<img src=\"https://p5.ssl.qhimg.com/t01668fe15fa7b624e8.jpg\" alt=\"three\">\n<img src=\"https://p1.ssl.qhimg.com/t018cdf67a440af41eb.jpg\" alt=\"four\">\n<img src=\"https://p5.ssl.qhimg.com/t018875f5db73fb51d8.jpg\" alt=\"five\"></p>\n<p>购书京东二维码：<img src=\"https://p5.ssl.qhimg.com/t0152e01126216557ce.png\" alt=\"qrcode\"></p>\n<p>购书链接： <a href=\"https://item.jd.com/12573168.html\">https://item.jd.com/12573168.html</a></p>\n</div>","title":"分享一本我写的书《深入浅出Vue.js》，新书上市，现在京东满100减50噢~","last_reply_at":"2019-04-25T03:55:25.663Z","good":false,"top":false,"reply_count":9,"visit_count":1265,"create_at":"2019-04-23T06:18:54.791Z","author":{"loginname":"berwin","avatar_url":"https://avatars0.githubusercontent.com/u/3739368?v=4&s=120"}},{"id":"5ca17f4399e62a362ff41c6d","author_id":"56cb313d66c88b5e490260a9","tab":"share","content":"<div class=\"markdown-text\"><p>我们是一个教练社区网站（<a href=\"http://bbs.zuqiuxunlian.com\">bbs.zuqiuxunlian.com</a>）,用的是cnodejs的开源代码搭建。\n由于现在手机浏览居多，小程序比较适合手机阅读。故而希望做一个客户端。\n可以参考已经有的很多开源的客户端。\n必须的功能：</p>\n<ol>\n<li>微信登录</li>\n<li>方便的留言框</li>\n<li>社区发帖</li>\n<li>自定义头像</li>\n</ol>\n<p>其他需求，可以讨论：</p>\n<ol>\n<li>简洁漂亮的界面</li>\n<li>设计优雅的分享</li>\n</ol>\n<p>有兴趣的报个价给我。\nvx：awong1900</p>\n</div>","title":"【外包】做一个社区的微信小程序客户端","last_reply_at":"2019-04-25T02:28:44.040Z","good":false,"top":false,"reply_count":18,"visit_count":1837,"create_at":"2019-04-01T03:02:27.153Z","author":{"loginname":"awong1900","avatar_url":"https://avatars1.githubusercontent.com/u/4022612?v=4&s=120"}},{"id":"5cb92784a86ae80ce64b0eda","author_id":"5cac197b7edd13064e053b71","tab":"share","content":"<div class=\"markdown-text\"><p>如何在Nodejs Koa代码中实现数据库备份还原呢？</p>\n<p>用koa2+mongodb做了个系统，现在想用nodejs实现一键 备份数据库以及还原功能数据库功能\n首先安装一下conv-lite这个模块哦\n下面只是大概实现思路</p>\n<pre class=\"prettyprint\"><code>const cp = require(&#x27;child_process&#x27;);\nconst iconv = require(&#x27;iconv-lite&#x27;);\n\ncp.exec(&#96;mongodump -h 127.0.0.1 -d koa -o C:\\\\Users\\\\Administrator\\\\Desktop\\\\koa&#96;, {encoding: &#x27;buffer&#x27;}, (error , stdout, stderr) =&gt; {\n  if (error) throw error;\n  stdout = iconv.decode(stdout, &#x27;gbk&#x27;);\n  stderr = iconv.decode(stderr, &#x27;gbk&#x27;);\n  console.log(stdout);\n  console.log(stderr);  \n});\n\n</code></pre></div>","title":"Nodejs Koa+mongodb实现一键 备份数据库 还原功能数据库功能","last_reply_at":"2019-04-25T02:07:16.013Z","good":false,"top":false,"reply_count":5,"visit_count":1096,"create_at":"2019-04-19T01:42:28.624Z","author":{"loginname":"xiaofenlin","avatar_url":"https://avatars3.githubusercontent.com/u/49425206?v=4&s=120"}},{"id":"5cb9634137faec0ce1d03aeb","author_id":"57cfc5d462b635972cd88434","tab":"ask","content":"<div class=\"markdown-text\"><p>服务：mysql、redis、等等…\n为什么不搭建本地环境：\n\t1.数据量大\n\t2.服务太多\n\t3.好几个项目\n综合以上这些问题，搭建一套本地环境真的工作量太大太低效。所以想问问大家有没有什么好的方式可以直连内网？</p>\n</div>","title":"如何配置本地开发环境直连测试环境服务，不想用ssh转发，多个项目多个配置，太繁琐，求好的建议！","last_reply_at":"2019-04-25T01:19:08.858Z","good":false,"top":false,"reply_count":7,"visit_count":956,"create_at":"2019-04-19T05:57:21.469Z","author":{"loginname":"wuyipeng","avatar_url":"https://avatars3.githubusercontent.com/u/16496721?v=4&s=120"}},{"id":"5cbe7a71a86ae80ce64b2343","author_id":"5689d685c301558265041ce6","tab":"share","content":"<div class=\"markdown-text\"><p>本安装教程系统版本为Linux Centos 7，使用Yum源安装MongoDB</p>\n<h2>Yum源</h2>\n<p><strong>使用</strong>\n概括几个常用的：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 1 安装 \nyum install package  &#x2F;&#x2F; 安装指定的安装包package \n\n&#x2F;&#x2F; 2 更新和升级 \nyum update  &#x2F;&#x2F; 全部更新 \nyum update package  &#x2F;&#x2F; 更新指定程序包package\nyum check-update  &#x2F;&#x2F; 检查可更新的程序 \nyum upgrade package  &#x2F;&#x2F; 升级指定程序包package \n\n&#x2F;&#x2F; 3 查找和显示 \nyum info &#x2F;&#x2F; 列出所有可以安装或更新的包的信息\nyum info package &#x2F;&#x2F;显示安装包信息package \nyum list &#x2F;&#x2F; 显示所有已经安装和可以安装的程序包 \nyum list package  &#x2F;&#x2F; 显示指定程序包安装情况package\nyum search package &#x2F;&#x2F; 搜索匹配特定字符的package的详细信息\n\n&#x2F;&#x2F; 4 删除程序 \nyum remove | erase package  &#x2F;&#x2F; 删除程序包package\nyum deplist package  &#x2F;&#x2F; 查看程序package依赖情况\n\n&#x2F;&#x2F; 5 清除缓存 \nyum clean packages  &#x2F;&#x2F; 清除缓存目录下的软件包 \nyum clean headers &#x2F;&#x2F; 清除缓存目录下的 headers \nyum clean oldheaders &#x2F;&#x2F; 清除缓存目录下旧的 headers \nyum clean, yum clean all  &#x2F;&#x2F; (= yum clean packages; yum clean oldheaders) 清除缓存目录下的软件包及旧的headers\n</code></pre><h2>安装Mongodb</h2>\n<h3>配置系统yum源</h3>\n<h4>1. 创建.repo文件，生成mongodb的源</h4>\n<pre class=\"prettyprint\"><code>vi &#x2F;etc&#x2F;yum.repos.d&#x2F;mongodb-org-4.0.repo\n</code></pre><h4>2. 添加以下配置信息：</h4>\n<pre class=\"prettyprint\"><code>[mongodb-org-4.0]\nname=MongoDB Repository\nbaseurl=https:&#x2F;&#x2F;repo.mongodb.org&#x2F;yum&#x2F;redhat&#x2F;#releasever&#x2F;mongodb-org&#x2F;4.0&#x2F;x86_64&#x2F;\ngpgcheck=1\nenabled=1\ngpgkey=https:&#x2F;&#x2F;www.mongodb.org&#x2F;static&#x2F;pgp&#x2F;server-4.0.asc\n</code></pre><p><strong>详解：</strong></p>\n<pre class=\"prettyprint\"><code>name         # 名称\nbaseurl      # 获得下载的路径\ngpkcheck=1   # 表示对从这个源下载的rpm包进行校验；\nenable=1     # 表示启用这个源。\ngpgkey       # gpg验证\n</code></pre><h4>3. 保存退出</h4>\n<pre class=\"prettyprint\"><code>wq # 退出保存\n</code></pre><h3>使用yum安装MongoDB</h3>\n<h4>1. 安装MongoDB</h4>\n<pre class=\"prettyprint\"><code>sudo yum install -y mongodb-org\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/23/16a47f5b28ccc7fe?w=1192&amp;h=894&amp;f=jpeg&amp;s=213276\" alt=\"安装MongoDB\"></p>\n<h4>2. 验证安装结果</h4>\n<pre class=\"prettyprint\"><code>rpm -qa |grep mongodb\n</code></pre><pre class=\"prettyprint\"><code>rpm -ql mongodb-org-server\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/23/16a47f602d81d242?w=1436&amp;h=768&amp;f=jpeg&amp;s=202441\" alt=\"验证安装结果\"></p>\n<h4>3. 启动MongoDB</h4>\n<p>启动MongoDB服务</p>\n<pre class=\"prettyprint\"><code>systemctl start mongod.service\n</code></pre><p>MongoDB默认端口是27017，查看是否开启</p>\n<pre class=\"prettyprint\"><code>netstat -natp | grep 27017\n</code></pre><p>检查数据库是否安装成功</p>\n<pre class=\"prettyprint\"><code>ps -aux | grep mongod    # 查看数据库的进程是否存在\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/23/16a47f668d37fb57?w=1538&amp;h=836&amp;f=jpeg&amp;s=147429\" alt=\"启动MongoDB\"></p>\n<h4>4. 验证服务开启</h4>\n<pre class=\"prettyprint\"><code>mongo\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/23/16a47f6cfc44f347?w=1576&amp;h=1278&amp;f=jpeg&amp;s=453921\" alt=\"验证服务开启\"></p>\n<h3>常用命令清单</h3>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 1、开启MongoDB\nsudo service mongod start  或者 systemctl start mongod.service  # 开启MongoDB\nsudo chkconfig mongod on  # 加入开机启动\nsudo service mongod restart # 重启MongoDB\n\n&#x2F;&#x2F; 2、关闭MongoDB\nsudo service mongod stop  # 关闭防火墙\n\n&#x2F;&#x2F; 3、卸载MongoDB\nsudo yum erase $(rpm -qa | grep mongodb-org)    # 卸载MongoDB\nsudo rm -r &#x2F;var&#x2F;log&#x2F;mongodb  # 删除日志文件\nsudo rm -r &#x2F;var&#x2F;lib&#x2F;mongo    # 删除数据文件\n</code></pre><h2>远程连接Mongodb</h2>\n<h3>1. 修改配置文件mongodb.conf</h3>\n<pre class=\"prettyprint\"><code>vi &#x2F;etc&#x2F;mongod.conf\n\n# network interfaces\nnet:\n  port: 27017\n  bindIp: 0.0.0.0  # Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.\n</code></pre><p><strong>修改绑定ip默认127.0.0.1只允许本地连接， 所以修改为bindIp:0.0.0.0, 退出保存</strong></p>\n<h3>2. 重启mongodb服务</h3>\n<pre class=\"prettyprint\"><code>sudo service mongod restart \n</code></pre><h3>3. 开放对外端口</h3>\n<p><strong>方法一</strong></p>\n<pre class=\"prettyprint\"><code>systemctl status firewalld  # 查看防火墙状态\nfirewall-cmd --zone=public --add-port=27017&#x2F;tcp --permanent # mongodb默认端口号\nfirewall-cmd --reload  # 重新加载防火墙\n\nfirewall-cmd --zone=public --query-port=27017&#x2F;tcp # 查看端口号是否开放成功，输出yes开放成功，no则失败\n</code></pre><p><strong>方法二</strong></p>\n<pre class=\"prettyprint\"><code>iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 27017 -j ACCEPT\n</code></pre><h3>4. 远程连接</h3>\n<p><strong>默认连接</strong></p>\n<pre class=\"prettyprint\"><code>mongo 10.128.218.14:27017\n</code></pre><p><strong>连接到自定义的用户</strong></p>\n<ol>\n<li>创建用户，设置账号，密码，权限</li>\n</ol>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; admin数据库\n&gt; use admin\nswitched to db admin\n&gt; db.createUser({ user:&quot;root&quot;, pwd:&quot;123456&quot;, roles:[&quot;root&quot;] })\nSuccessfully added user: { &quot;user&quot; : &quot;root&quot;, &quot;roles&quot; : [ &quot;root&quot; ] }\n\n&#x2F;&#x2F; 其他数据库\n&gt; use test\nswitched to db test\n&gt; db.createUser({ user:&quot;admin&quot;, pwd:&quot;123456&quot;, roles:[&quot;readWrite&quot;, &quot;dbAdmin&quot;] })\nSuccessfully added user: { &quot;user&quot; : &quot;root&quot;, &quot;roles&quot; : [ &quot;root&quot; ] }\n</code></pre><ol>\n<li>修改mongodb.conf文件，启用身份验证</li>\n</ol>\n<pre class=\"prettyprint\"><code>vi &#x2F;etc&#x2F;mongod.conf\n\nsecurity:\n  authorization: &quot;enabled&quot;   # disable or enabled\n</code></pre><ol>\n<li>重启MongoDB</li>\n</ol>\n<pre class=\"prettyprint\"><code>sudo service mongod restart \n</code></pre><ol>\n<li>用户认证</li>\n</ol>\n<pre class=\"prettyprint\"><code>&gt; use admin\nswitched to db admin\n&gt; db.auth(&quot;root&quot;, &quot;123456&quot;)\n1 &#x2F;&#x2F; 授权成功\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 其他常用命令\ndb.updateUser(user, writeConcern) # 更新用户\ndb.dropUser(&#x27;test&#x27;) # 删除用户\n</code></pre><ol>\n<li>远程连接</li>\n</ol>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 终端连接\nmongo 10.128.218.14:27017:27017&#x2F;database -u username -p password\n\n&#x2F;&#x2F; mongoose方式连接\nmongoose.connect(&#x27;mongodb:&#x2F;&#x2F;username:password@host:port&#x2F;database?options...&#x27;, {useNewUrlParser: true});\n\n&#x2F;&#x2F; 通过客户端连接\n</code></pre><h3>用户权限角色说明</h3>\n<table>\n<thead>\n<tr>\n<th>规则</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>root</td>\n<td>只在admin数据库中可用。超级账号，超级权限</td>\n</tr>\n<tr>\n<td>Read</td>\n<td>允许用户读取指定数据库</td>\n</tr>\n<tr>\n<td>readWrite</td>\n<td>允许用户读写指定数据库</td>\n</tr>\n<tr>\n<td>dbAdmin</td>\n<td>允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</td>\n</tr>\n<tr>\n<td>userAdmin</td>\n<td>允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户</td>\n</tr>\n<tr>\n<td>clusterAdmin</td>\n<td>只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限</td>\n</tr>\n<tr>\n<td>readAnyDatabase</td>\n<td>只在admin数据库中可用，赋予用户所有数据库的读权限</td>\n</tr>\n<tr>\n<td>readWriteAnyDatabase</td>\n<td>只在admin数据库中可用，赋予用户所有数据库的读写权限</td>\n</tr>\n<tr>\n<td>userAdminAnyDatabase</td>\n<td>只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</td>\n</tr>\n<tr>\n<td>dbAdminAnyDatabase</td>\n<td>只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限</td>\n</tr>\n</tbody>\n</table>\n<h1>参考文献</h1>\n<ul>\n<li><a href=\"https://blog.csdn.net/u011305680/article/details/52767230\">yum使用详解</a></li>\n<li><a href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\">Install MongoDB Community Edition on Red Hat Enterprise or CentOS Linux</a></li>\n<li><a href=\"https://www.linuxidc.com/Linux/2017-11/148495.htm\">CentOS 7上MongoDB数据库安装和卸载</a></li>\n<li><a href=\"https://www.jianshu.com/p/03aff57dfe46\">ubuntu mongodb远程连接配置</a></li>\n<li><a href=\"https://medium.com/mongoaudit/how-to-enable-authentication-on-mongodb-b9e8a924efac\">How to Enable Authentication on MongoDB</a></li>\n<li><a href=\"https://docs.mongodb.com/manual/reference/method/db.createUser/\">db.createUser()</a></li>\n</ul>\n</div>","title":"Linux Centos 7安装MongoDB（简单！详细！）","last_reply_at":"2019-04-25T01:11:27.006Z","good":false,"top":false,"reply_count":3,"visit_count":427,"create_at":"2019-04-23T02:37:37.274Z","author":{"loginname":"vincentSea","avatar_url":"https://avatars0.githubusercontent.com/u/16203604?v=4&s=120"}},{"id":"5cc07e5137faec0ce1d0632b","author_id":"5c82a91cacb681372d416622","tab":"ask","content":"<div class=\"markdown-text\"><p>cnode发帖回复的API不能用吗？？</p>\n</div>","title":"cnode发帖回复的API不能用吗？？","last_reply_at":"2019-04-25T00:48:57.237Z","good":false,"top":false,"reply_count":1,"visit_count":294,"create_at":"2019-04-24T15:18:41.644Z","author":{"loginname":"Mr-Jas","avatar_url":"https://avatars0.githubusercontent.com/u/38638603?v=4&s=120"}},{"id":"5c3c64413898674067a7f08e","author_id":"5c2ec7f75bf06c5e7e3f10e8","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FpV4S_2ag6p2eXKV4-hJa6dJMQWd\" alt=\"33333.jpg\">\nNodejs入门+进阶+即时通讯聊天系统实战视频教程，HTML5+AJAX+Node.js+Express+MySQL的组合开发Web聊天应用</p>\n<p><strong>Nodejs入门+进阶</strong>\n<img src=\"//static.cnodejs.org/FnWFg39SGKc4dMNZECu8ZtTu69kP\" alt=\"11111.jpg\"></p>\n<p><strong>Nodejs即时通讯聊天系统实战14讲</strong>\n<img src=\"//static.cnodejs.org/FsvCVzUJo9SPCyujbQ8EFB2nZt_5\" alt=\"22222.jpg\"></p>\n<p>教程下载：<a href=\"https://www.sucaihuo.com/video/231.html\">https://www.sucaihuo.com/video/231.html</a></p>\n</div>","title":"Nodejs入门+进阶+即时通讯聊天系统实战视频教程","last_reply_at":"2019-04-24T14:45:02.656Z","good":false,"top":false,"reply_count":4,"visit_count":1721,"create_at":"2019-01-14T10:28:17.912Z","author":{"loginname":"missheying","avatar_url":"https://avatars3.githubusercontent.com/u/46346806?v=4&s=120"}},{"id":"5cc074bc37faec0ce1d062ee","author_id":"57cfc5d462b635972cd88434","tab":"ask","content":"<div class=\"markdown-text\"><p>背景：\n因为服务实在太多，在本地搭建一套费时费力还影响电脑性能，所以想直连测试环境，测试环境在内网，终端访问需要通过跳板机操作。</p>\n<p>尝试过的解决方案：\n1.开白名单：运维说出现了安全问题，所以关闭了访问，再加上人手不够，运维当下没时间想其它办法解决此问题。\n2.ssh 端口转发：mysql、redis、其它第三方服务都能连了，结果redis cluster却使用不了了，用的是ioredis包，泪崩中。。。\n3.ssr：经了解，ssr只能代理http或者socket数据，mysql redis 这种tcp连接的不知道能不能代理\n4.修改代码：感觉这种方法也不太好。</p>\n<p>实在是想不出其它的方法能够解决这个问题，还望各位走过路过，留下一点小小的建议，感激不尽，如果有好建议的，麻烦写个简短的步骤，或者多加一两句描述，我好有方向去学习探索。</p>\n<p>谢谢，弯腰，鞠躬！</p>\n</div>","title":"开发环境中有什么方式可以连内网服务（mysql、redis...），有这种代理吗？","last_reply_at":"2019-04-24T14:37:48.635Z","good":false,"top":false,"reply_count":0,"visit_count":417,"create_at":"2019-04-24T14:37:48.635Z","author":{"loginname":"wuyipeng","avatar_url":"https://avatars3.githubusercontent.com/u/16496721?v=4&s=120"}},{"id":"5cc06c1f37faec0ce1d0629f","author_id":"5aab840e19b2e3db18959e5b","tab":"share","content":"<div class=\"markdown-text\"><ul>\n<li><a href=\"https://github.com/wszgrcy/ng-window\">github地址</a></li>\n<li>主体部分基于angular开发的一个可视化窗口页面,当然,估计也有很多类似的成品了,所以估计也没那么吸引人,但是因为搜索了下.好像没人拿angular开发,所以写了这个项目</li>\n<li>同时还支持web-component封装的组件引入作为一个独立应用,也搞定了angular模块的懒加载</li>\n<li>想写这个的项目时候,想的挺好的,可以越接近完成,越感觉自己做的东西没意义.但是东西既然做了,还是有始有终把…</li>\n<li>文档写了一大部分(有什么需要了解的可以提出来),<a href=\"https://wszgrcy.github.io/ng-window/\">demo网站</a>也架好了</li>\n<li>e2e写了一部分,单元由于没想好怎么测(基于ngrx的状态管理),还没付出行动.</li>\n<li>反正是大家多多批评把,估计也没啥优点,这个人别的没有,也就是抗击打能力强</li>\n</ul>\n</div>","title":"基于angular框架开源了一个窗口化的页面","last_reply_at":"2019-04-24T14:01:03.003Z","good":false,"top":false,"reply_count":0,"visit_count":419,"create_at":"2019-04-24T14:01:03.003Z","author":{"loginname":"wszgrcy","avatar_url":"https://avatars3.githubusercontent.com/u/9607121?v=4&s=120"}},{"id":"5cc04ceaa86ae80ce64b3819","author_id":"56b8352e71204e03637a385f","tab":"share","content":"<div class=\"markdown-text\"><p>最近需要跟踪竞争对手网站上的信息，公开的接口带了 sign 加密验证，无奈只有使用 puppeteer 来获取网页上所有加密的 接口列表，找了下网上的滚动加载更多，都不是很理想，自己翻了一遍官网 API 写了个出来，或许可以帮助到别人。\n···\nconst puppeteer = require(‘puppeteer’)\nconst EventProxy = require(‘eventproxy’)\nconst ep = new EventProxy()\nlet browser</p>\n<p>main()\nasync function main () {\nbrowser = await openBrowser()</p>\n<p>const ps = []\nfor (let index = 10; index &gt;= 1; index–) {\nlet request_url = <code>demoUrl=${index}</code>\nps.push(spiderPage(request_url))\n}\nawait Promise.all(ps)\nep.after(‘pageFinished’, ps.length, async rs =&gt; {\nawait browser.close()\n})\n}</p>\n<p>async function openBrowser () {\nlet args = [\n’–no-sandbox’,\n’–disable-infobars ‘, // don’t show information bar\n’–window-size=1920,1080’, // resize window view port size\n’–lang=zh-CN’,\n’–disable-dev-shm-usage’\n]</p>\n<p>const browser = await puppeteer.launch({\ndefaultViewport: { width: 375, height: 812 },\nignoreHTTPSErrors: true,\nheadless: false,\ndevtools: true,\ntimeout: 0,\nargs\n})\nreturn browser\n}</p>\n<p>async function spiderPage (request_url) {\nconst page = await openPageToUrl(request_url)\nep.on(<code>${request_url}_response</code>, async rs =&gt; {\nawait sleep(200)\nawait pageScroll(page)\nif (rs.data.productList.list.length != 20) {\nconsole.log(request_url, ‘finished’)\nawait page.screenshot({ path: <code>${request_url.split('?')[1]}.png</code>, fullPage: true })\nawait page.close()\nep.emit(‘pageFinished’)\n}\n})\n}</p>\n<p>async function openPageToUrl (request_url) {\nconst page = await browser.newPage()</p>\n<p>await page.goto(request_url, { waitUntil: ‘domcontentloaded’ }).catch(err =&gt; console.log(err))</p>\n<p>page.on(‘request’, request =&gt; {\n// console.log(‘request’, request._url)\nconst url = request._url\nif (url.indexOf(‘yourTargetUrl’) != -1) {\n// console.log(‘request’, url, ‘page stop scroll’)\n}\n})</p>\n<p>page.on(‘response’, async response =&gt; {\n// console.log(‘request’, request._url)\nconst url = response._url\nif (url.indexOf(‘yourTargetUrl’) != -1) {\nconst rs = await response.json()\nconsole.log(‘response’, url, ‘page start scroll’, rs.data.productList.list.length)\n// console.log(rs.data.productList.list.length)\nep.emit(<code>${request_url}_response</code>, rs)\n}\n})\nreturn page\n}</p>\n<p>async function pageScroll (page) {\nawait page.evaluate(mValues =&gt; {\n// const scrollY = window.innerHeight\nconst scrollY = document.body.clientHeight\nwindow.scrollTo(0, scrollY)\n})\nawait sleep(300)\n}</p>\n<p>// 延时函数\nfunction sleep (delay) {\nreturn new Promise((resolve, reject) =&gt; {\nsetTimeout(() =&gt; {\ntry {\nresolve(1)\n} catch (e) {\nreject(0)\n}\n}, delay)\n})\n}\n···</p>\n</div>","title":"puppeteer 滚动控制研究","last_reply_at":"2019-04-24T11:47:54.480Z","good":false,"top":false,"reply_count":0,"visit_count":298,"create_at":"2019-04-24T11:47:54.480Z","author":{"loginname":"yhc-yhc","avatar_url":"https://avatars1.githubusercontent.com/u/16659510?v=4&s=120"}},{"id":"5cbfffc337faec0ce1d05e65","author_id":"5cb09961207b2365936ec7e3","tab":"ask","content":"<div class=\"markdown-text\"><p>现在只能把路由请求单独打印，console.log又分别分行打印</p>\n</div>","title":"morgan日志库可以把路由信息打印和这次路由里面的console.log打印在一行嘛","last_reply_at":"2019-04-24T06:18:43.417Z","good":false,"top":false,"reply_count":0,"visit_count":301,"create_at":"2019-04-24T06:18:43.417Z","author":{"loginname":"silemelon","avatar_url":"https://avatars2.githubusercontent.com/u/6167490?v=4&s=120"}},{"id":"5cbffa5aa86ae80ce64b333b","author_id":"59b0fced1b37e54f6793c3d6","tab":"ask","content":"<div class=\"markdown-text\"><p>谁能帮我分析下为什么会提示“There may be long-running asynchronous activities”？\n<a href=\"https://upload.clinicjs.org/public/659e885064403fc05deeec5dc435f90aed50d7f04d0b9eb11c2cdfa8e6636752/15124.clinic-bubbleprof.html\"></a><a href=\"https://upload.clinicjs.org/public/659e885064403fc05deeec5dc435f90aed50d7f04d0b9eb11c2cdfa8e6636752/15124.clinic-bubbleprof.html\">https://upload.clinicjs.org/public/659e885064403fc05deeec5dc435f90aed50d7f04d0b9eb11c2cdfa8e6636752/15124.clinic-bubbleprof.html</a></p>\n<p><a href=\"https://upload.clinicjs.org/public/1d53f2c6bfbb6c3aa2bb8aa656fbd8281813ba54b9b213d171666934bd985be5/19848.clinic-doctor.html\"></a><a href=\"https://upload.clinicjs.org/public/1d53f2c6bfbb6c3aa2bb8aa656fbd8281813ba54b9b213d171666934bd985be5/19848.clinic-doctor.html\">https://upload.clinicjs.org/public/1d53f2c6bfbb6c3aa2bb8aa656fbd8281813ba54b9b213d171666934bd985be5/19848.clinic-doctor.html</a></p>\n</div>","title":"NODEJS 性能测试图，寻找项目中的性能问题。","last_reply_at":"2019-04-24T05:55:38.746Z","good":false,"top":false,"reply_count":0,"visit_count":471,"create_at":"2019-04-24T05:55:38.746Z","author":{"loginname":"xulayen","avatar_url":"https://avatars1.githubusercontent.com/u/15044564?v=4&s=120"}},{"id":"567f79d13382febf21134115","author_id":"567f6ba675ab905822046691","tab":"ask","content":"<div class=\"markdown-text\"><h3>使用版本</h3>\n<h2>node 5.0.0\nmulter 1.1.0</h2>\n<p>在跟着这个教程<a href=\"https://github.com/nswbmw/N-blog/\">https://github.com/nswbmw/N-blog/</a>走的时候，到图片上传这一部分卡住了，因为mongodb跟node都是最新版，所以在走教程的时候提到的第三方模块也都是用的最新版，但是一直报<strong>Unexpected field</strong>的错，实在是没能力调了，有没有大神愿意帮个忙，感激涕零。</p>\n<pre class=\"prettyprint\"><code>var multer = require(&#x27;multer&#x27;),\n    upload = multer({ dest: &#x27;.&#x2F;public&#x2F;images&#x2F;&#x27; });\n...\n app.post(&#x27;&#x2F;upload&#x27;, upload.array(&#x27;photos&#x27;, 5), function (req, res) {\n        console.log(&#x27;funny this&#x27;);\n        console.log(req.files);\n        req.flash(&#x27;success&#x27;, &#x27;文件上传成功!&#x27;);\n        res.redirect(&#x27;&#x2F;upload&#x27;);\n    });\n</code></pre><p>代码地址<a href=\"https://github.com/jhonny-me/nodejs-blog1\">https://github.com/jhonny-me/nodejs-blog1</a>.</p>\n</div>","title":"multer 报错Unexpected field，新人求助","last_reply_at":"2019-04-24T04:26:24.446Z","good":false,"top":false,"reply_count":10,"visit_count":8788,"create_at":"2015-12-27T05:40:33.759Z","author":{"loginname":"jhonny-me","avatar_url":"https://avatars.githubusercontent.com/u/9820374?v=3&s=120"}},{"id":"5cbfdf88a86ae80ce64b3215","author_id":"5caaad037edd13064e053135","tab":"ask","content":"<div class=\"markdown-text\"><p>水水水水水</p>\n</div>","title":"jngjdnsndsadsda","last_reply_at":"2019-04-24T04:01:12.956Z","good":false,"top":false,"reply_count":0,"visit_count":233,"create_at":"2019-04-24T04:01:12.956Z","author":{"loginname":"lixingzhe","avatar_url":"https://avatars2.githubusercontent.com/u/49380617?v=4&s=120"}},{"id":"5cbfdeae37faec0ce1d05c5c","author_id":"5a0d348fe2f4b8ea22496498","tab":"share","content":"<div class=\"markdown-text\"><h3>MOCK API 的定义</h3>\n<p>根据百度百科的定义，mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。这个虚拟的对象就是mock对象，mock对象就是真实对象在调试期间的代替品。</p>\n<p>在瀑布流开发模式中，如果前端开发人员需要进行页面对接，需要后端先完成API的开发工作，如果没有mock，那么前后端开发的进度会互相影响。</p>\n<p>通过 Mock API事先编写好 API 的数据生成规则，由工具动态生成 API 的返回数据。开发人员通过访问 Mock API 来获得页面所需要的数据，就可以轻松地完成对接工作。</p>\n<h3>MOCK API 能用来解决什么？</h3>\n<h4>1.依赖的接口尚未开发完成</h4>\n<p>在系统交互双方定义好接口之后，我们可以提前进行开发和测试，并不依赖上游系统的开发实现。</p>\n<h4>2.自定义返回测试结果（比如 HttpservletRequet、JDBC 对象等）</h4>\n<p>在测试时使用Mock，可以自由方便的构建配置接口对象的信息参数；</p>\n<p>在测试过程中，需要第三方接口返回特定的数据以符合特定的测试场景，这种情况往往需要跨条线的沟通协调测试数据，成本高，效率低；利用Mock可以自定义返回测试结果，支持手动构造依赖接口的返回值。（这个功能将在后面重点提及）</p>\n<h4>3.自动化测试</h4>\n<p>在自动化测试概念和发展要求下，自动化测试的规模也逐渐增大到一定程度；</p>\n<p>大型业务系统下测试接口多，测试用例也日益增多，依赖环境的稳定就成为了自动化测试执行的关键所在；</p>\n<p>自动化测试过程中，经常会因为依赖的第三方环境不稳定，导致测试执行失败，长期以往的出现问题，导致测试人员对自动化的稳定运行失去维护的信心；</p>\n<p>利用Mock技术，在测试过程中，只关注被测业务逻辑，mock掉依赖不相关的系统，这种情况下自动化测试运行失败，就一定是被测系统本身的业务逻辑问题，而不是第三方系统、数据的问题；</p>\n<h4>4.更多场景，欢迎看客老爷补充。</h4>\n<h3>应用场景示例（自定义返回结果）</h3>\n<p><strong>接下来我们从测试的层面举个场景：</strong></p>\n<p>我所在的项目是企业管理咨询，项目最经常需要的是根据企业详情判断返回不同的状态。涉及到的数据其实很多，但是为了方便举例，我计划写三个接口进行演示，第一个是登录，第二个是获取企业详情，简化了复杂的判断，直接用判断corpld(企业ID)来作为识别的凭证，第三个是设置企业状态，有注销和恢复两种状态。会根据企业的corpstatus进行判断。接下来带你一一设置：</p>\n<p><img src=\"//static.cnodejs.org/FsvsQT0Ji46FoWAxIPoP3SP1rc8p\" alt=\"1.png\"></p>\n<p>登陆接口不必多讲，我们直接到第二个接口，新建一个期望，请求触发条件不写，在返回数据这里添加corpstatus可能值为1或者2。</p>\n<p><img src=\"//static.cnodejs.org/FiqckbnQv7J373XAvJKrJyYC9TeN\" alt=\"2.png\"></p>\n<p>第三个接口是设置企业状态（注销/恢复），这里需要两个请求参数，第一个是corpld企业ID，对应上个接口的corpld;第二个是corpstatus企业状态，这里引用了全局变量，用两对花括号表示。</p>\n<p><img src=\"//static.cnodejs.org/Fl4SwKbp6bW14B1lDj3BpwLU_4RJ\" alt=\"3.png\"></p>\n<p>还是进入mockapi新建期望，因为这里有两个状态（注销/恢复），所以需要写两个期望。当请求参数corpstatus=4条件触发时，返回参数content=注销成功；当请求参数corpstatus=2条件触发时，返回参数content=企业已恢复。</p>\n<p><img src=\"//static.cnodejs.org/FibfQynEwD02xPyyJ7vZ_HU2GBsY\" alt=\"4.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fj8xfvVMU2ymnhm9yU6Y102R_T2H\" alt=\"5.png\"></p>\n<p>由于这三个接口都是应用在一个场景里面的，我们不妨用一个流程进行测试的，总共三个测试用例：</p>\n<ol>\n<li>登陆</li>\n<li>获取企业详情</li>\n<li>设置企业状态（注销/恢复）</li>\n</ol>\n<p>在测试前需要在第二个用例中要写好一个响应预处理，通过Javascript代码动态改变返回的结果，实现corpstatus=2或者4，从而对应上之前的全局变量。</p>\n<p><img src=\"//static.cnodejs.org/Fjgc942kOqRWBUgFO3PcdcgZ2gMG\" alt=\"6.png\"></p>\n<p>然后就可以点击进行测试。从测试记录可以看到会根据corpstatus的不同返回了不同的信息。</p>\n<p><img src=\"//static.cnodejs.org/FsLbDR8G-GTbsSW2eBv3wcxLLKTC\" alt=\"7.png\"></p>\n<p><img src=\"//static.cnodejs.org/FmQHlqPKINJm5PHaykoi70znlGfG\" alt=\"8.png\"></p>\n<p>这就是一个简略完整的一个场景用例设计。那如果没有mockapi的话，等着后端开发，corpstatus可能就拿不到，进度势必会被影响，为了模拟数据测试，这时候mockapi的优势就凸显了。</p>\n<p><strong>下面再讲一个使用mock自定义功能的项目场景：</strong></p>\n<p>之前所在公司子系统较多，我们为了减低集成和维护成本，采用了ESB的架构。ESB架构可以解决多个应用系统互联所面临的的复杂性。也是因为子系统较多导致整个业务系统的运转比较复杂，其中便涉及到和多个外部系统的对接及数据交互，比如仓储和物流，势必会跟EMS、顺丰等有数据交互。</p>\n<p>当然，跟外部系统对接时系统间的联调测试必不可少，有些外部系统提供测试环境，有些甚至不提供。即便是提供测试环境的外部系统，一般也仅在开发联调阶段配合提供联调测试对接服务，一旦联调测试结束，也不再继续提供测试服务。</p>\n<p>那么，当这些外部系统的联调测试环境不可用时，我们就需模拟这些外部系统来和自己的系统进行数据交互，以便支持完整业务测试流程的正常进行。</p>\n<p>再具体到API开发层面的话，就是开发的API经常遇到在URL一样的情况下，需要根据请求头或者请求体的不同，返回不同测试结果。以前没用mockapi自定义的功能的话，解决的方式只有新建多个接口分别进行，十分麻烦。</p>\n<p>举个例子，在API文档建立后，在进行测试时，我的要求是在URL一样的情况下，根据不同的请求头部返回不同结果。</p>\n<p>1.当标签头部\nContest-type=application/json\nClientld=purchase.consemer\nOperationCode= medicine.purchase.consemer.List</p>\n<p>那么返回参数\nFloor=2\nRoom=2\nCabinet=2</p>\n<p>2.当标签头部\nContest-type=application/json1\nClientld=purchase.consemer1\nOperationCode= medicine.purchase.consemer.List1</p>\n<p>那么返回参数\nFloor=3\nRoom=3\nCabinet=3</p>\n<p><strong>使用 eolinker 进行自定义 MOCK API？</strong>\neolinker 是一款接口管理工具，提供API管理、测试功能，本次我们使用它来进行 Mock API，官网地址：<a href=\"http://www.eolinker.com/#/?ref=cnodejs\">https://www.eolinker.com</a></p>\n<p><strong>1.先建立好文档</strong></p>\n<p><img src=\"//static.cnodejs.org/FhHSRXrXOXn14nvGSMF9UuUtImpV\" alt=\"9.png\"></p>\n<p><strong>2.建立期望进行测试</strong></p>\n<p><img src=\"//static.cnodejs.org/FstN4sd9yAo4-m61muPwShW0_jHb\" alt=\"10.png\"></p>\n<p><strong>3.写完后测试后返回的数据与我们的想要的一致</strong></p>\n<p><img src=\"//static.cnodejs.org/FrisE87rKiClZ1N7vo7RnwmGKD5T\" alt=\"11.png\"></p>\n<p><strong>4.第二种情况类似，就不赘述了</strong></p>\n<p><img src=\"//static.cnodejs.org/FlQYHEXQSJcSwv9RKipZaqU9pvPM\" alt=\"12.png\"></p>\n<p>本篇文章主要从测试层面和角度去介绍 MOCK API，下篇我会从开发的层面去介绍 MOCK API 的实际应用。希望对大家有所帮助。eolinker官网：<a href=\"https://s.growingio.com/gke2DD\">https://www.eolinker.com</a></p>\n</div>","title":"MOCK API 的定义及实践（使用eolinker实现）","last_reply_at":"2019-04-24T03:57:34.443Z","good":false,"top":false,"reply_count":0,"visit_count":323,"create_at":"2019-04-24T03:57:34.443Z","author":{"loginname":"wardennn","avatar_url":"https://avatars0.githubusercontent.com/u/33686934?v=4&s=120"}},{"id":"5cbf2d0037faec0ce1d05663","author_id":"58898ca65d4612c33919ea01","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>MySQL中的大小写敏感问题，可以从服务器(Server)、数据库(Database)、表(Table)、字段(Column)这4个级别来配置，MySQL的很多配置、操作等都是基于这4个级别的。<strong>这4个级别的优先级为：字段&gt;表&gt;数据库&gt;服务器</strong>。而我们最关注的大小写敏感问题通常是对于数据而言的，举个简单的例子：字符串<code>book</code>和字符串<code>Book</code>存入到数据库后，我们通过SQL语句查询的时候，如果这两个字符串是相等的，那么说明MySQL比较这两个字符串的时候采用了<strong>大小写不敏感</strong>的方式，反之，则是使用了<strong>大小写敏感</strong>的方式。在讨论MySQL大小写敏感问题之前，我们需要先了解MySQL的两个概念：字符集(CHARACTER SET)和校对规则(Collation)。</p>\n<h2>字符集(CHARACTER SET)和校对规则(Collation)</h2>\n<p>字符集的通常解释是：符号和编码的集合。举个例子：假设我们有4个字母：A,B,a,b。我们给每个字母编个号码：A=0,B=1,a=3,b=4。我们就可以说字母A是符号，编号0是它的编码。所有的字母和它们的编码组合起来就是我们通常说的字符集。如果我们想要比较两个字符串A和B的值的大小，那么我们很容就想到他们的编码，A的编码是0，B的编码是1，因为<strong>0小于1</strong>，所以<strong>字符串A小于字符串B</strong>。我们做的这个比较就是给这个<strong>字符集(CHARACTER SET)<strong>应用了一套</strong>校对规则(Collation)</strong>。</p>\n<p>MySQL拥有一套完整的字符集和校对规则。每一种字符集至少包含一种校对规则，且每种字符集都有默认的校对规则。</p>\n<ul>\n<li>可以使用<code>SHOW CHARACTER SET</code>语句查看MySQL支持的字符集列表：</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/Fs5W4175f-BxtEa5CClHQzRUYk_9\" alt=\"show_character_set.png\"></p>\n<ul>\n<li>可以使用<code>SHOW COLLATION</code>语句查看MySQL支持的校对规则：</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/FlZ58tmuNj7_ZFUiOxxL2XaJEMul\" alt=\"show_collation.png\"></p>\n<h2>大小写敏感问题</h2>\n<p>接着上面的例子，如果我们想要大写字母A和小写字母a是相等的呢？那么我们需要做的就是将大写字母A和小写字母a的编码设置为一致的，然后比较它们的编码即可。这就是我们通常说的<strong>大小写不敏感校对规则</strong>。反之，如果将大写字母A和小写字母a视为不相等的，就是我们通常说的<strong>大小写敏感校对规则</strong>。</p>\n<p>在不指定字符集和校对规则的情况下，MySQL会使用默认的字符集(utf8)和校对规则(utf8_general_ci)。校对规则的名称遵循规则：<strong>以其相关的字符集开头，后加上一个或者多个后缀用于区分不同的校对规则</strong>。相关后缀说明：</p>\n<table>\n<thead>\n<tr>\n<th>后缀</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>_ai</td>\n<td>口音不敏感(Accent insensitive)</td>\n</tr>\n<tr>\n<td>_as</td>\n<td>口音敏感(Accent sensitive)</td>\n</tr>\n<tr>\n<td>_ci</td>\n<td>大小写不敏感(Case insensitive)</td>\n</tr>\n<tr>\n<td>_cs</td>\n<td>大小写敏感(case-sensitive)</td>\n</tr>\n<tr>\n<td>_ks</td>\n<td>假名敏感(Kana sensitive)</td>\n</tr>\n<tr>\n<td>_bin</td>\n<td>二进制(Binary，大小写敏感)</td>\n</tr>\n</tbody>\n</table>\n<p>由此可以知道：<strong>默认情况下，MySQL所使用的校对规则是大小写不敏感的</strong>。</p>\n<h2>设置大小写敏感</h2>\n<p>在日常的开发场景中，可能很少遇到需要设置大小写敏感的场景，而我恰巧遇到了。下面举例说明：</p>\n<ul>\n<li>先创建一张用户表：</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>CREATE TABLE &#96;users&#96; (\n  &#96;username&#96; varchar(32) NOT NULL,\n  &#96;nickname&#96; varchar(32) DEFAULT NULL,\n  PRIMARY KEY (&#96;username&#96;)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n</code></pre><blockquote>\n<p>这里我们先使用默认的字符集和校对规则。</p>\n</blockquote>\n<ul>\n<li>插入两条数据：</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>INSERT INTO &#96;cs_test&#96;.&#96;users&#96; (&#96;username&#96;, &#96;nickname&#96;) VALUES (&#x27;user1&#x27;, &#x27;black&#x27;);\nINSERT INTO &#96;cs_test&#96;.&#96;users&#96; (&#96;username&#96;, &#96;nickname&#96;) VALUES (&#x27;user2&#x27;, &#x27;match&#x27;);\n</code></pre><ul>\n<li>查询数据：</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>SELECT * FROM users WHERE username=&#x27;user1&#x27;;\nSELECT * FROM users WHERE username=&#x27;usER1&#x27;;\n</code></pre><p>这两条SQL语句的查询结果是一致的：</p>\n<p><img src=\"//static.cnodejs.org/FoCZ0sgzzk6Qw9-MXofSscaYny_3\" alt=\"query_user.png\"></p>\n<ul>\n<li>现在我需要向<code>users</code>表中插入一条<code>username</code>为<strong>useR1</strong>的<strong>另外一个用户</strong>，发现报错了：</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>INSERT INTO &#96;cs_test&#96;.&#96;users&#96; (&#96;username&#96;, &#96;nickname&#96;) VALUES (&#x27;useR1&#x27;, &#x27;whatever&#x27;);\n</code></pre><p><img src=\"//static.cnodejs.org/FpwpmAiY63fyaDplDyCRrKuzuLQh\" alt=\"insert_error.png\"></p>\n<p>理由很简单：因为MySQL此时使用的是大小写不敏感的校对规则，所以<code>user1</code>和<code>useR1</code>是相等的，而<code>username</code>是<code>users</code>表的<strong>主键</strong>，所以在插入数据时会报主键冲突的错误。</p>\n<ul>\n<li>设置<code>users</code>表的<code>username</code>字段使用<strong>大小写敏感</strong>的校对规则：</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>ALTER TABLE &#96;cs_test&#96;.&#96;users&#96; \nCHANGE COLUMN &#96;username&#96; &#96;username&#96; VARCHAR(32) CHARACTER SET &#x27;utf8&#x27; COLLATE &#x27;utf8_bin&#x27; NOT NULL ;\n</code></pre><p>然后再次尝试插入数据，这次插入成功了。此时<code>users</code>表中的数据如下：</p>\n<p><img src=\"//static.cnodejs.org/FpY2ct_WQuLz4HozUPsCEDMpwiJl\" alt=\"users.png\"></p>\n<ul>\n<li>再次查询用户表：</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/FnrU3mxvVrXefOJ8oglW9D6MksuP\" alt=\"query_user_again_1.png\"></p>\n<p><img src=\"//static.cnodejs.org/FkJfDzcEy_hzTwmawJs8WN9VF6fc\" alt=\"query_user_again_2.png\"></p>\n<p><img src=\"//static.cnodejs.org/FsPFf21hGtB1uZNkajdCrVzf1bmH\" alt=\"query_user_again_3.png\"></p>\n<p>发现这次<code>users</code>表的<code>username</code>字段已经彻底变成了<strong>大小写敏感</strong>了。</p>\n<h2>总结</h2>\n<ul>\n<li>本文讨论的是MySQL数据校对规则的大小写敏感问题，而不是讨论表名的大小写敏感问题（网上很多文章都是讨论表名的大小写敏感问题）。</li>\n<li>对MySQL的字符集和校对规则有一定的了解后有助于理解大小写敏感问题。</li>\n<li>MySQL的<code>utf8</code>字符集并没有<code>utf8_general_cs</code>校对规则，网上有些文章存在误导。</li>\n<li>MySQL的<code>utf8_bin</code>校对规则是大小写敏感的。</li>\n<li>MySQL的4个级别优先级为：字段(Column)&gt;表(Table)&gt;数据库(Database)&gt;服务器(Server)，进行相关配置时尤其要注意。</li>\n<li>最好不要对主键等其他含有索引的字段设置大小写敏感，容易导致索引失效，从业务角度考虑也不太合理。</li>\n</ul>\n</div>","title":"浅谈MySQL中的大小写敏感问题","last_reply_at":"2019-04-24T02:56:10.126Z","good":false,"top":false,"reply_count":2,"visit_count":432,"create_at":"2019-04-23T15:19:28.654Z","author":{"loginname":"blackmatch","avatar_url":"https://avatars3.githubusercontent.com/u/12443954?v=4&s=120"}},{"id":"5cbf14f9a86ae80ce64b2bf3","author_id":"56b8352e71204e03637a385f","tab":"share","content":"<div class=\"markdown-text\"><p>凡是能导到线上的都已经尝试过了，现在转化用户成本非常高，到了强者恒强的时代\n互联网裁员，是综合因素导致，大环境下的必然产物。一般情况下各行业周期为20年左右，这个周期相对准确。我们来详细解读下，互联网行业从1998年起步，直至新浪、网易、搜狐、腾讯的鼎立，标志着互联网进入高速发展时期，随后阿里、百度、腾讯崛起，成为互联网行业的标杆企业，中国的人口红利，形成了巨大的流量池，流量主导着一切，雷军曾说过：在风口上，猪都能飞起来！</p>\n<p>直到2018年，我们能明显感知流量红利时代已经结束，因为流量越来越贵、引新越来越少，从一线到二线，从二线到三四线，凡是能导到线上的都已经尝试过了，互联网企业开始进入细分用户及细分服务阶段。举个例子，我所知晓的某电商为例，2007年的消费转化用户成本为15元，那几年的销售额与公司规模几乎年年呈10倍增长，而2018年的消费转化用户成本却高达700元，其中仅有1-2次消费、消费总额不超过300元的用户占比达到了60%，试想下，如此高昂的引新成本，加之近年来各项经营成本的增长，企业财报如何才能做到正向营利，以支撑后续发展？要活下去该怎么办？无非从这三个方面着手：缩减营销预算（广告投入）、减少产品研发成本（创新投入）、减少人力成本（人员投入）。\n最近几天，各媒体争相报导着“互联网寒冬”，对此，我却认为，2019年是最有挑战、最有希望的一年，因为很多凑热闹的行业搅局者、不具备实力的人会出局，这是行业与人才的又一次洗牌。在风口上，猪都能飞起来，当风吹过，一切虚妄的价值就会被打回原形，唯有坚持、真正交付价值的企业才能存活，而真正具备实力的人才也会获得更多机会与可能，并且在未来活得很好。\n大破必有大立！危与机永远并存！不信？一年后再来回顾本篇。觉得不错还可以前往我的主页查看更多BAT架构技术进阶+面试真经等干货~</p>\n<p><a href=\"https://www.cnblogs.com/findumars/p/10165587.html\">https://www.cnblogs.com/findumars/p/10165587.html</a></p>\n</div>","title":"凡是能导到线上的都已经尝试过了，现在转化用户成本非常高，到了强者恒强的时代","last_reply_at":"2019-04-24T02:20:47.633Z","good":false,"top":false,"reply_count":3,"visit_count":781,"create_at":"2019-04-23T13:36:57.543Z","author":{"loginname":"yhc-yhc","avatar_url":"https://avatars1.githubusercontent.com/u/16659510?v=4&s=120"}},{"id":"5cb552aa1d8a69797aa66c4e","author_id":"5b66a03fb71aedfe4c12675f","tab":"ask","content":"<div class=\"markdown-text\"><p>如题</p>\n</div>","title":"node+mongodb编程，如何实现一致性，大神有没有推荐的工具或相似的工具参考参考","last_reply_at":"2019-04-24T01:30:50.940Z","good":false,"top":false,"reply_count":3,"visit_count":1052,"create_at":"2019-04-16T03:57:30.137Z","author":{"loginname":"msforest","avatar_url":"https://avatars0.githubusercontent.com/u/16268045?v=4&s=120"}},{"id":"5cbe812737faec0ce1d04de3","author_id":"5cbe7dfd37faec0ce1d04d91","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>router.getTagsArr = async function (tag = []) {\n    var tags = [];\n    for (var val of tag) {\n        var db = await router.getTags(val);&#x2F;&#x2F;这个方法返回的是new Promise\n        tags.push(db);\n    }\n\n    console.log(tags, 1);\n\t&#x2F;&#x2F;return tags;\n    return 12;\n}\n\n\nconsole.log(router.getTagsArr());\n</code></pre><p>如果这样调用，得到的结果是：\n第一行：Promise { &lt;pending&gt; }\n第二行[。。。。。略] 1\n（注，第二行是console.log(tags, 1);）</p>\n<p>如果我console.log(await router.getTagsArr());\n第一行[。。。。。略] 1\n第二行12</p>\n<p>显然，第二个结果是我要的。但是getTagsArr方法我并没有返Promise对象，他怎么就自动变成这样呢？\n我知道这个是async定义影响的，但是这个关键字不是指定这个方法内，可以开启同步么？await。</p>\n</div>","title":"async定义的function直接就返Promise对象","last_reply_at":"2019-04-23T16:23:01.435Z","good":false,"top":false,"reply_count":3,"visit_count":674,"create_at":"2019-04-23T03:06:15.957Z","author":{"loginname":"jsnnid","avatar_url":"https://avatars2.githubusercontent.com/u/33336408?v=4&s=120"}},{"id":"5cbebd1837faec0ce1d05283","author_id":"5520a425ce156cc206687c5c","tab":"share","content":"<div class=\"markdown-text\"><p>很多小伙伴有一个烦恼，如何在js文件中引用ts。很多项目的依赖项中，尤其是历史遗留项目，不能将整个项目ts化，比如说sequelize的migration文件如何做成ts呢？那这个文件如果依赖其他文件，其他文件是不是就必须转成js格式呢？</p>\n<p>有了Load Any File!，再不用麻烦了，直接在js文件中const myUtil = loafFile(’./helper/myUtil.ts’)，即可引入一个ts文件的module。</p>\n<p>我的初衷是允许开发者使用任意他/她喜欢的语言写配置。比如说，.babelrc.json，.babelrc.yaml，webpack.config.ts，这是不是能让一些有强迫症的开发者觉得代码风格更统一呢？虽然不推荐js，ts混用，也不推荐这种方式来使用Load Any File!，但是觉得能够为一些朋友江湖救急，所以写下了这个帖子。</p>\n<p>这里是Load Any File!的Github地址，测试覆盖率100%，无依赖项，功能稳定。支持node.js 6 - 11。\n<a href=\"https://github.com/zhangkaiyulw/load-any-file\">https://github.com/zhangkaiyulw/load-any-file</a></p>\n</div>","title":"在js文件中引用ts文件成为可能，任意文件都可以引用","last_reply_at":"2019-04-23T14:07:10.797Z","good":false,"top":false,"reply_count":1,"visit_count":484,"create_at":"2019-04-23T07:22:00.932Z","author":{"loginname":"cheunghy","avatar_url":"https://avatars0.githubusercontent.com/u/3055936?v=4&s=120"}},{"id":"5cbf11aea86ae80ce64b2bdc","author_id":"584d7dce4c17b38d35436595","tab":"ask","content":"<div class=\"markdown-text\"><blockquote>\n<p>在入口文件中对login、register过滤不需要进行验证，通过isRevoked对其他的接口的token验证。为什么访问getuserinfo的时候不加 <code>Bear token</code>请求头authoration也能访问到接口的信息。网上搜寻了很多博客文章，还是直接可以不加token的header访问到别的接口，表示很疑问</p>\n</blockquote>\n<ul>\n<li>app.js入口文件</li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>\tconst Koa = require(&quot;koa&quot;);\n\tconst app = new Koa();\n\tconst json = require(&quot;koa-json&quot;);\n\tconst onerror = require(&quot;koa-onerror&quot;);\n\tconst bodyparser = require(&quot;koa-bodyparser&quot;);\n\tconst logger = require(&quot;koa-logger&quot;);\n\tconst koaJwt = require(&quot;koa-jwt&quot;);\n\tconst router = require(&quot;.&#x2F;routes&#x2F;index&quot;);\n\tconst config = require(&quot;.&#x2F;config&#x2F;index&quot;);\n\tconst util = require(&quot;.&#x2F;util&#x2F;index&quot;);\n\tconst errorHandle = require(&quot;.&#x2F;util&#x2F;error.js&quot;);\n\tconst { connect } = require(&quot;.&#x2F;model&#x2F;init&quot;);\n\tonerror(app);\n\t\n\tapp.use(\n\t  bodyparser({\n\t\tenableTypes: [&quot;json&quot;, &quot;form&quot;, &quot;text&quot;]\n\t  })\n\t);\n\tapp.use(json());\n\tapp.use(logger());\n\tapp.use(require(&quot;koa-static&quot;)(__dirname + &quot;&#x2F;public&quot;));\n\tapp.use(async (ctx, next) =&gt; {\n\t  const start = new Date();\n\t  await next();\n\t  const ms = new Date() - start;\n\t  console.log(&#96;${ctx.method} ${ctx.url} - ${ms}ms&#96;);\n\t});\n\tapp.use(errorHandle);\n\tapp.use(router.routes(), router.allowedMethods());\n\tapp.use(\n\t  koaJwt({\n\t\tsecret: config.secret,\n\t\tisRevoked: util.verify\n\t  }).unless({\n\t\tpath: [&#x2F;\\&#x2F;login&#x2F;, &#x2F;\\&#x2F;register&#x2F;]\n\t  })\n\t);\n\t(async () =&gt; {\n\t  await connect();\n\t})();\n\tapp.on(&quot;error&quot;, (err, ctx) =&gt; {\n\t  console.error(&quot;server error&quot;, err, ctx);\n\t});\n\tmodule.exports = app;\n</code></pre><ul>\n<li>jwt的401，errorhandle文件</li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>\tmodule.exports = (ctx, next) =&gt; {\n\t&#x2F;&#x2F; console.log(ctx.request.body);\n\treturn next().catch(err =&gt; {\n\t  if (err.status === 401) {\n\t\tctx.status = 401;\n\t\tctx.body = &quot;UnAthoration to get the data&quot;;\n\t  } else {\n\t\tthrow err;\n\t  }\n\t});\n  };\n</code></pre><ul>\n<li>路由控制文件</li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>\tconst userModel = require(&quot;..&#x2F;model&#x2F;userModel.js&quot;);\n\tconst config = require(&quot;..&#x2F;config&#x2F;index.js&quot;);\n\tconst util = require(&quot;..&#x2F;util&#x2F;index&quot;);\n\tmodule.exports = {\n\t  register: async (ctx, next) =&gt; {\n\t\tconsole.log(&quot;****&quot;,ctx);\n\t\tlet { name, password } = ctx.request.body;\n\t\tif (name &amp;&amp; password) {\n\t\t  password = util.createHash(password);\n\t\t  const result = await new userModel({\n\t\t\tname: name,\n\t\t\tpassword: password\n\t\t  }).save();\n\t\t  console.log(&quot;register result is&quot;, result);\n\t\t  if (!result)\n\t\t\treturn (ctx.body = {\n\t\t\t  code: &quot;400&quot;,\n\t\t\t  message: &quot;register fail&quot;\n\t\t\t});\n\t\t  else\n\t\t\treturn (ctx.body = {\n\t\t\t  code: &quot;200&quot;,\n\t\t\t  message: &quot;register success!&quot;\n\t\t\t});\n\t\t}\n\t  },\n\t  login: async (ctx, next) =&gt; {\n\t\tconst data = ctx.request.body;\n\t\tif (!data.name || !data.password) {\n\t\t  return (ctx.body = {\n\t\t\tcode: &quot;&quot;,\n\t\t\tdata: null,\n\t\t\tmessage: &quot;the usernumber or password can&#x27;t be null&quot;\n\t\t  });\n\t\t}\n\t\tdata.password = util.createHash(data.password);\n\t\tconst result = await userModel.find({\n\t\t  name: data.name,\n\t\t  password: data.password\n\t\t});\n\t\tif (result &amp;&amp; result.length) {\n\t\t  const token = util.sign(result);\n\t\t  return (ctx.body = {\n\t\t\tcode: &quot;200&quot;,\n\t\t\ttoken: token,\n\t\t\tmessage: &quot;login success&quot;\n\t\t  });\n\t\t} else {\n\t\t  return (ctx.body = {\n\t\t\tcode: &quot;400&quot;,\n\t\t\tdata: null,\n\t\t\tmessage: &quot;usernumber or password is error&quot;\n\t\t  });\n\t\t}\n\t  },\n\t  getuserinfo: async (ctx, next) =&gt; {\n\t\treturn (ctx.body = {\n\t\t  msg: &quot;nothing&quot;\n\t\t});\n\t  }\n\t};\n\n</code></pre><ul>\n<li>jwt验证文件</li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>\tconst crypto = require(&quot;crypto&quot;);\n\tconst config = require(&quot;..&#x2F;config&#x2F;index&quot;);\n\tconst jwt = require(&quot;jsonwebtoken&quot;);\n\tmodule.exports = {\n\t  createHash: value =&gt; {\n\t\tconst hmac = crypto.createHash(&quot;sha256&quot;, config.secret);\n\t\thmac.update(value);\n\t\treturn hmac.digest(&quot;hex&quot;);\n\t  },\n\t  sign(result) {\n\t\treturn jwt.sign(\n\t\t  {\n\t\t\t_id: result._id,\n\t\t\tname: result.name\n\t\t  },\n\t\t  config.secret,\n\t\t  config.expiresIn\n\t\t);\n\t  },\n\t  verify(ctx, decodedToken, token) {\n\t\tlet ret = true;\n\t\ttry {\n\t\t  const payload = jwt.verify(token, config.secret);\n\t\t  console.log(payload);\n\t\t  if(payload)\n\t\t\tret = false;\n\t\t} catch (err) {\n\t\t  console.log(err.name);\n\t\t}\n\t\treturn ret;\n\t  }\n\t};\n</code></pre></div>","title":"关于koa-jwt使用的疑问","last_reply_at":"2019-04-23T13:47:42.828Z","good":false,"top":false,"reply_count":2,"visit_count":349,"create_at":"2019-04-23T13:22:54.565Z","author":{"loginname":"1261407209LHH","avatar_url":"https://avatars0.githubusercontent.com/u/15929863?v=4&s=120"}},{"id":"5cbf04e237faec0ce1d05531","author_id":"59227363d371b6372a8afc26","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint language-javascript\"><code>class Test {\n    constructor() {\n        this.test = new Proxy({ foo() {} }, {\n            get(target, name) {\n                console.log(&#x27;name: &#x27;, name);\n            },\n        });\n    }\n}\n\nconst test = new Test();\n\nconsole.log(test);\n&#x2F;*\nname:  Symbol(nodejs.util.inspect.custom)\nname:  Symbol(Symbol.toStringTag)\nname:  Symbol(Symbol.iterator)\nTest { test: { foo: [Function: foo] } }\n*&#x2F;\n</code></pre><p>在浏览器中运行以上代码不会出现这些额外的get访问<br>\n为什么会出现这种情况？有没有办法避免？\n环境：<code>Nodejs v11.14.0</code> <code>win10 x64 1809</code></p>\n</div>","title":"在nodejs中console.log一个class实例对象时，对象中的Proxy出现了额外的get访问","last_reply_at":"2019-04-23T13:05:19.584Z","good":false,"top":false,"reply_count":1,"visit_count":257,"create_at":"2019-04-23T12:28:18.350Z","author":{"loginname":"dislido","avatar_url":"https://avatars2.githubusercontent.com/u/25094788?v=4&s=120"}},{"id":"5b60495e58db3ccf66a450c6","author_id":"54054f7c0256839f714716ea","tab":"ask","content":"<div class=\"markdown-text\"><p>egg的多进程模型\n<a href=\"https://eggjs.org/zh-cn/core/cluster-and-ipc.html\">https://eggjs.org/zh-cn/core/cluster-and-ipc.html</a></p>\n</div>","title":"nest如何实现多进程间通信和egg类似的agent机制","last_reply_at":"2019-04-23T12:49:53.923Z","good":false,"top":false,"reply_count":17,"visit_count":2431,"create_at":"2018-07-31T11:34:54.211Z","author":{"loginname":"yuu2lee4","avatar_url":"https://avatars1.githubusercontent.com/u/8046366?v=4&s=120"}},{"id":"5cb6a8ada86ae80ce64b01aa","author_id":"53e1802fbd3cc3e50ba9e311","tab":"share","content":"<div class=\"markdown-text\"><p>给大家讲一个&quot;十动然拒&quot;的故事：</p>\n<p>2018年6月，Nodejs 之父刚刚开发 deno 不久，Protobuf 的作者建议 deno 不要使用 Protobuf，并向 ry 推荐了自己开发的 Cap’n Proto，性能非常卓越 <a href=\"https://github.com/denoland/deno/issues/269\">https://github.com/denoland/deno/issues/269</a>。ry 和 kentonv 围绕性能问题展开了近一个月的深入探讨，ry 十分感动，然后……拒绝了 kentonv 的推荐，而选择了 flatbuffers。昨天 ry 新开了一个 issue，打算替换掉 flatbuffers 库 <a href=\"https://github.com/denoland/deno/issues/2121\">https://github.com/denoland/deno/issues/2121</a> 因为根据 deno 的基准测试数据看，目前的性能瓶颈就是 flatbuffers, 随后 kentonv 又被重新召唤出来。</p>\n</div>","title":"给大家讲一个\"十动然拒\"的故事，Nodejs 之父有些尴尬","last_reply_at":"2019-04-23T07:39:40.985Z","good":false,"top":false,"reply_count":12,"visit_count":2977,"create_at":"2019-04-17T04:16:45.855Z","author":{"loginname":"justjavac","avatar_url":"https://avatars1.githubusercontent.com/u/359395?v=4&s=120"}},{"id":"5cbea752a86ae80ce64b26ec","author_id":"5cbd569fa86ae80ce64b1ce6","tab":"ask","content":"<div class=\"markdown-text\"><p>cnode哪些接口可以调用？</p>\n</div>","title":"cnode哪些接口可以调用？","last_reply_at":"2019-04-23T06:13:19.749Z","good":false,"top":false,"reply_count":2,"visit_count":451,"create_at":"2019-04-23T05:49:06.831Z","author":{"loginname":"xjinky","avatar_url":"https://avatars1.githubusercontent.com/u/30654234?v=4&s=120"}},{"id":"5cbea10d37faec0ce1d04f98","author_id":"5cbe957fa86ae80ce64b261a","tab":"ask","content":"<div class=\"markdown-text\"><p>node.js安装</p>\n</div>","title":"node.js安装","last_reply_at":"2019-04-23T05:43:50.564Z","good":false,"top":false,"reply_count":3,"visit_count":324,"create_at":"2019-04-23T05:22:21.193Z","author":{"loginname":"kwh123","avatar_url":"https://avatars1.githubusercontent.com/u/46155383?v=4&s=120"}},{"id":"5cbe81a237faec0ce1d04deb","author_id":"5ac08cdf679ac2ad2c492a21","tab":"ask","content":"<div class=\"markdown-text\"><ul>\n<li>\n<p>使用场景\n输入框输入值后<code>500</code>ms内没变化, 将值作为查询条件请求数据</p>\n</li>\n<li>\n<p>问题描述</p>\n</li>\n</ul>\n<ol>\n<li>\n<p>输入值为1, 请求到500条数据, 耗时3s, 待数据返回重新渲染</p>\n</li>\n<li>\n<p>距上次输入1后,经过1s后, 输入2,(当前查询条件为12) 请求到5条数据, 耗时300ms, 待数据返回重新渲染</p>\n</li>\n</ol>\n<p>这个过程中, 第二次数据返回是时间比第一次快, 所以最终的情况是输入框的值为12, 但是渲染的数据为1的请求数据</p>\n<ul>\n<li>解决方案\n我目前使用的一个解决方案是使用<code>XMLHttpRequest.abort()</code>, 来终端第一个请求</li>\n</ul>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort\">XMLHttpRequest.abort()</a></p>\n<p>感觉这个方法比较局限,所以想问一问各位大佬, 有没有更适合的觉得方案?</p>\n</div>","title":"请教一下防抖动问题","last_reply_at":"2019-04-23T04:45:48.653Z","good":false,"top":false,"reply_count":3,"visit_count":602,"create_at":"2019-04-23T03:08:18.192Z","author":{"loginname":"MeetTheBest","avatar_url":"https://avatars1.githubusercontent.com/u/21294768?v=4&s=120"}},{"id":"5cbe82b5a86ae80ce64b2416","author_id":"5cbe8163a86ae80ce64b23fb","tab":"ask","content":"<div class=\"markdown-text\"><p>在vue项目中装了webpack-dev-server。webpack.dev.conf.js中 before里对一些请求返回json数据，数据来自mock文件，例如：\nbefore(mockRoute) {\nmockRoute.get(’/foo/bar’, (req,resp) =&gt; {\nvar content = require(’…/mock/foo/bar.json’)\n\tresp.json(content)\n});\n}\n工作正常，但修改了bar.json中的内容后，每次都要重启node才能获取新数据，有没有什么配置项/途径可以让我不重启node修改bar.json后能拿到新数据？</p>\n</div>","title":"使用express，模拟数据文件能热加载吗","last_reply_at":"2019-04-23T03:33:03.260Z","good":false,"top":false,"reply_count":2,"visit_count":310,"create_at":"2019-04-23T03:12:53.979Z","author":{"loginname":"LanserShi","avatar_url":"https://avatars3.githubusercontent.com/u/20268034?v=4&s=120"}},{"id":"5cbd3d2237faec0ce1d04652","author_id":"5bc6779d37a6965f5905229a","tab":"ask","content":"<div class=\"markdown-text\"><p>egg + mongoose，无法正常连接mongoose，浏览器一直停在 等候 状态，求助大神</p>\n<p>我使用egg  + mongoose，按标准的方式，就是无法访问mongodb，不管mongodb是关闭或启动，都无法访问，在浏览器就停在那里！</p>\n<p>01、app\\model\\admin.js\n<img src=\"//static.cnodejs.org/FuAXTicFNUMQSOcHFNHpCkIXa-P3\" alt=\"image.png\"></p>\n<p>02、app\\controller\\admin\\dbtest.js</p>\n<p><img src=\"//static.cnodejs.org/FgCcw1OGBu933iS8UPwuUgoFYXEI\" alt=\"image.png\">\n03、app\\router.js</p>\n<p><img src=\"//static.cnodejs.org/FrFhEKB98bwcNO9RWSBNvC5Hb0fW\" alt=\"image.png\">\n04、config\\config.default.js\n<img src=\"//static.cnodejs.org/FnMlGdgl6FNB-5YHKSQWX9xTXnAN\" alt=\"image.png\">\n05、config\\plugin.js\n<img src=\"//static.cnodejs.org/Fv7HU_xc6BQTpTO0HDYpZnZDIvvN\" alt=\"image.png\">\n06、打开浏览器，输入http://127.0.0.1:7001/db/dbtest\n<img src=\"//static.cnodejs.org/FpyLePq1JQV-l0g-MIwcK4PwuSqA\" alt=\"image.png\">\n画面就一直停在那里wait</p>\n<p>07、执行的结果(console)\n<img src=\"//static.cnodejs.org/FjuNNR40vNgdB0WlS2B94vhrmUEw\" alt=\"image.png\">\n没有其他的代码了，就只用了egg-init  --type=simple  mongolab</p>\n<p>mongodb可正常连线\n<img src=\"//static.cnodejs.org/Fpfh5WsBF9JMildHGXXWHC_IGfGk\" alt=\"image.png\">\n浏览器打开後，输入http://127.0.0.1:7001/db/dbtest</p>\n<p>visual studio code的console显示如下</p>\n<p><img src=\"//static.cnodejs.org/Fjj9WtdbeGHCPbAUM_H9MXAzj8jK\" alt=\"image.png\"></p>\n<p>有进入执行，\n但是到了var result = await this.ctx.model.find({})) ;<br>\n就停住了，浏览器也一直停在那里，没有结束，一直呈现「等候」的状态。</p>\n<p>麻烦大神了</p>\n</div>","title":"egg + mongoose，无法正常连接mongoose，浏览器一直停在 等候 状态，求助大神","last_reply_at":"2019-04-23T02:38:44.442Z","good":false,"top":false,"reply_count":13,"visit_count":978,"create_at":"2019-04-22T04:03:46.237Z","author":{"loginname":"Solomonqoo","avatar_url":"https://avatars3.githubusercontent.com/u/44214486?v=4&s=120"}},{"id":"5cb8081b37faec0ce1d033a7","author_id":"565553143325bb2c4ebd803a","tab":"share","content":"<div class=\"markdown-text\"><p>前段时间在开发中碰到一个小问题，揭露了我工作多年依然是个菜鸟并且基础知识不够扎实的毛病，现记录下来跟大家分享。为方便重现问题的核心，文中用了最为简洁的代码来模拟当时的场景。</p>\n<h2>一个异常的行为</h2>\n<p>某天开发了一个REST接口让前端调用，它大概是这个样子：</p>\n<pre class=\"prettyprint language-JS\"><code>&#x2F;&#x2F;server.js的代码\n&quot;use strict&quot;;\nconst server = require(&quot;http&quot;).createServer();\nserver.listen(4000);\nserver.on(&quot;request&quot;, (req, res)=&gt; {\n    res.end(&quot;别搞node了，转AI吧&quot;);\n});\n</code></pre><p>写完后用Postman测试了一下<br>\n<img src=\"//static.cnodejs.org/Fj1YMBlqA7GYYe2JMLPcK9IHt029\" alt=\"ip_address_issue.jpg\">\n输出一切正常，马上提交推送代码让前端对接。前端拉取代码在本地运行之后发现请求接口会报错，具体表现是：<strong>按照上面截图的方式用Postman调用接口的话一切正常，用手写的程序调用报错</strong>。例如用以下前端代码调用接口就报错</p>\n<pre class=\"prettyprint language-JS\"><code>&#x2F;&#x2F;前端代码\nvar request= new XMLHttpRequest();\nrequest.onreadystatechange = function () {\n    if (request.readyState === 4) {\n        if (request.status === 200) {\n            console.log(request.responseText)\n        } else {\n            console.error(request.status)\n        }\n    }\n}\nrequest.open(&quot;GET&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:4000&quot;);\nrequest.send();\n</code></pre><p>这让我非常困惑。</p>\n<h2>调试过程</h2>\n<p>这个问题其实不难，仔细的同学可能已经发现代码中的一些问题了，然而由于本人不够细心，在错误的debug方向上越走越远浪费了好些时间。当时我不假思索写了下面的代码来重现问题</p>\n<pre class=\"prettyprint language-JS\"><code>&#x2F;&#x2F;client.js代码\n&quot;use strict&quot;;\nconst client = require(&quot;http&quot;).get(&quot;http:&#x2F;&#x2F;localhost:4000&quot;, res =&gt; {\n    res.setEncoding(&quot;utf8&quot;);\n    res.on(&quot;data&quot;, console.log);\n});\nclient.on(&quot;error&quot;,e=&gt;{\n    console.error(error);\n});\n</code></pre><p>错误输出为</p>\n<pre class=\"prettyprint language-bash\"><code>Error: Parse Error\n    at Socket.socketOnData (VM75 _http_client.js:447)\n    at Socket.emit (VM15 events.js:197)\n    at addChunk (VM65 _stream_readable.js:288)\n    at readableAddChunk (VM65 _stream_readable.js:269)\n    at Socket.Readable.push (VM65 _stream_readable.js:224)\n    at TCP.onStreamRead (VM74 stream_base_commons.js:150)\n</code></pre><p>马上debug进去看看是怎么回事<br>\n<img src=\"//static.cnodejs.org/Fl3mNRXEe50rATT9yZEp_XSDNZmM\" alt=\"ip_address_issue2.jpg\"></p>\n<p>447行的<code>var ret = parser.execute(d);</code>报错，那很明显是服务端发送的数据有问题了，从截图上看<code>d</code>为字符串<code>HEART</code>。这明显不是我的服务端的输出，难不成有另外一个服务跑在4000端口？但如果这样的话会端口冲突，服务端启动会失败更不要说对外服务了，但是Postman请求服务却又是正常的。当时的情况总结就是：</p>\n<ul>\n<li>server.js启动了服务端</li>\n<li>Postman可以正常访问服务端</li>\n<li>client.js不可以正常访问服务端</li>\n</ul>\n<p>上面的情况似乎是矛盾的，我尝试着将server.js停掉，<strong>然后惊奇地发现Postman不能正常访问服务了，但是client.js依然能够接收数据（<code>HEART</code>字符串）然后报错。这表明确实有另外一个服务跑在4000端口</strong>。于是用下面的命令查看是谁</p>\n<pre class=\"prettyprint language-bash\"><code>PS C:\\Users\\hehe&gt; netstat -aon|findstr &quot;4000&quot;\nTCP    127.0.0.1:4000         0.0.0.0:0              LISTENING       4836\n\nPS C:\\Users\\hehe&gt; tasklist|findstr &quot;4836&quot;\nFoxitProtect.exe              4836 Services                   0      6,472 K\n</code></pre><p>原来是FoxiReader的服务占用4000端口造成冲突，改掉server.js监听的端口之后一切正常。<br>\n问题依然解决了，但是我在这个过程中究竟犯了什么错误，为什么会犯这样的错误？为何会出现Postman可以访问但是client.js不能访问的现象？</p>\n<h2>问题所在</h2>\n<p>我犯的错误有以下几个</p>\n<ul>\n<li>在server.js中调用<code>server.listen(4000)</code></li>\n<li>在Postman中基于localhost这个域名去访问服务</li>\n<li>在client.js中基于127.0.0.1去访问服务</li>\n</ul>\n<p>来看看<code>server.listen([port[, host[, backlog]]][, callback])</code>的文档</p>\n<blockquote>\n<p>If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.</p>\n</blockquote>\n<p><strong>也就是说如果不制定参数<code>host</code>的话，就会使用IPv6的地址(::)或者IPv4的地址(0.0.0.0)</strong>，于是我重新将server.js启动，然后执行命令</p>\n<pre class=\"prettyprint language-bash\"><code> C:\\Users\\hehe&gt; netstat -aon|findstr &quot;4000&quot;\n  TCP    0.0.0.0:4000           0.0.0.0:0              LISTENING       13176\n  TCP    127.0.0.1:4000         0.0.0.0:0              LISTENING       4836\n</code></pre><p>server.js在0.0.0.0上监听4000端口，它和127.0.0.1上监听相同端口的服务是不会冲突的。至此我终于发现了自己知识的盲点，就是我对以下四者的关系混淆不清（工作多年还不清楚这个问题真是令人惭愧，脸红中…）</p>\n<ul>\n<li>localhost（注意这是一个域名）</li>\n<li>127.0.0.1</li>\n<li>0.0.0.0</li>\n<li>本机的真实ip，例如192.168.1.64</li>\n</ul>\n<p>关于它们的详细区别请看这里</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/20778771/what-is-the-difference-between-0-0-0-0-127-0-0-1-and-localhost\">What is the difference between 0.0.0.0, 127.0.0.1 and localhost?</a></li>\n<li><a href=\"https://www.zhihu.com/question/23940717\">localhost、127.0.0.1 和 本机IP 三者的区别</a></li>\n</ul>\n<p>此外必须注意到文档中还提及</p>\n<blockquote>\n<p>All net.Socket are set to SO_REUSEADDR</p>\n</blockquote>\n<p>关于<code>SO_REUSEADDR</code>的讨论请看</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t\">Socket options SO_REUSEADDR and SO_REUSEPORT, how do they differ? Do they mean the same across all major operating systems?</a></li>\n<li><a href=\"https://www.cnblogs.com/xybaby/p/7341579.html\">SO_REUSEADDR与SO_REUSEPORT平台差异性与测试</a></li>\n</ul>\n<p>总之这又是一个隐蔽的坑，在不同的操作系统上<code>SO_REUSEADDR</code>具有不同的意义。而在windows上正是因为开启了<code>SO_REUSEADDR</code>才使得0.0.0.0:4000和127.0.0.1:4000不会冲突</p>\n</div>","title":"一个ip地址引起的小问题","last_reply_at":"2019-04-23T02:35:26.659Z","good":false,"top":false,"reply_count":4,"visit_count":1078,"create_at":"2019-04-18T05:16:11.830Z","author":{"loginname":"youth7","avatar_url":"https://avatars2.githubusercontent.com/u/8315732?v=4&s=120"}},{"id":"5b630389b71aedfe4c1266a2","author_id":"5b62fab258db3ccf66a4516b","tab":"ask","content":"<div class=\"markdown-text\"><p>近期在学习node.js，由于自己是初学者，看了《Node.js开发指南》和 《Node.js开发实战》上的一些基础的东西，《深入浅出 Node.js》看起来是很吃力，最近试着用Express开发自己的一个 个人博客系统，刚刚开始，就感觉很吃力，最近就在想该怎么来学习，希望曾经和我有相同问题的朋友解答下我的疑惑，学习路线很迷茫啊。。。</p>\n</div>","title":"node.js的入门（萌新）","last_reply_at":"2019-04-23T02:10:14.994Z","good":false,"top":false,"reply_count":41,"visit_count":5981,"create_at":"2018-08-02T13:13:45.110Z","author":{"loginname":"remembergf","avatar_url":"https://avatars1.githubusercontent.com/u/34055216?v=4&s=120"}},{"id":"5cb7df80a86ae80ce64b07a1","author_id":"5629da22e6a3804c58159198","tab":"share","content":"<div class=\"markdown-text\"><h1>2019-k8s-centos</h1>\n<p>2019最新k8s集群搭建教程 (centos k8s 搭建)\n网上全是要么过时的,要么残缺的,大多数都是2016年,2017年的文档,照着尝试了N次,各种卸了重装,最后centos系统都搞得乱七八糟,各种配置互相冲突,影响,一直在kubeadm init 报错, 后来实在无果,重新安装了centos系统,从头再来</p>\n<p>非常感谢网友@丿陌路灬再见ミ  技术支持和耐心指导</p>\n<ul>\n<li>首先fork我的github到本地</li>\n</ul>\n<pre class=\"prettyprint language-sh\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;qxl1231&#x2F;2019-k8s-centos.git\ncd 2019-k8s-centos\n</code></pre><ul>\n<li>安装完master后,还要安装下dashboard,请看另一个dashboard的md文档</li>\n</ul>\n<h2>centos7 部署 k8s 集群</h2>\n<h4>安装docker-ce</h4>\n<p><a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\">官方文档</a></p>\n<p><strong>Master、Node节点都需要安装、配置Docker</strong></p>\n<pre class=\"prettyprint language-sh\"><code># 卸载原来的docker\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n\n# 安装依赖\nsudo yum update -y &amp;&amp; sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n  \n# 添加官方yum库\nsudo yum-config-manager \\\n    --add-repo \\\n    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo\n    \n# 安装docker\nsudo yum install docker-ce docker-ce-cli containerd.io\n\n# 查看docker版本\ndocker --version\n\n# 开机启动\nsystemctl enable --now docker\n</code></pre><p>或者使用脚本一键安装</p>\n<pre class=\"prettyprint language-shell\"><code>curl -fsSL &quot;https:&#x2F;&#x2F;get.docker.com&#x2F;&quot; | sh\nsystemctl enable --now docker\n</code></pre><p><strong>修改docker cgroup驱动，与k8s一致，使用systemd</strong></p>\n<pre class=\"prettyprint language-shell\"><code># 修改docker cgroup驱动：native.cgroupdriver=systemd\ncat &gt; &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;EOF\n{\n  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],\n  &quot;log-driver&quot;: &quot;json-file&quot;,\n  &quot;log-opts&quot;: {\n    &quot;max-size&quot;: &quot;100m&quot;\n  },\n  &quot;storage-driver&quot;: &quot;overlay2&quot;,\n  &quot;storage-opts&quot;: [\n    &quot;overlay2.override_kernel_check=true&quot;\n  ]\n}\nEOF\n\nsystemctl restart docker  # 重启使配置生效\n</code></pre><h3>安装 kubelet kubeadm kubectl</h3>\n<p><a href=\"https://kubernetes.io/docs/setup/independent/install-kubeadm/\">官方文档</a></p>\n<p><strong>master、node节点都需要安装kubelet kubeadm kubectl。</strong></p>\n<p><strong>安装kubernetes的时候，需要安装kubelet, kubeadm等包，<a href=\"http://xn--k8syumpackages-u60w655l4vzbes5afu5a328a8bc.cloud.google.com\">但k8s官网给的yum源是packages.cloud.google.com</a>，国内访问不了，此时我们可以使用阿里云的yum仓库镜像。</strong></p>\n<pre class=\"prettyprint language-shell\"><code>cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64\nenabled=1\ngpgcheck=0\nrepo_gpgcheck=0\ngpgkey=http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg\n       http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg\nEOF\n\n# 关闭SElinux\nsetenforce 0\nsed -i &#x27;s&#x2F;^SELINUX=enforcing$&#x2F;SELINUX=permissive&#x2F;&#x27; &#x2F;etc&#x2F;selinux&#x2F;config\n\n# 安装kubelet kubeadm kubectl\nyum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes\n\nsystemctl enable --now kubelet  # 开机启动kubelet\n\n# centos7用户还需要设置路由：\nyum install -y bridge-utils.x86_64\nmodprobe  br_netfilter  # 加载br_netfilter模块，使用lsmod查看开启的模块\ncat &lt;&lt;EOF &gt;  &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nEOF\nsysctl --system  # 重新加载所有配置文件\n\nsystemctl disable --now firewalld  # 关闭防火墙\n\n# k8s要求关闭swap  (qxl)\nswapoff -a &amp;&amp; sysctl -w vm.swappiness=0  # 关闭swap\nsed -ri &#x27;&#x2F;^[^#]*swap&#x2F;s@^@#@&#x27; &#x2F;etc&#x2F;fstab  # 取消开机挂载swap\n</code></pre><p><strong>使用虚拟机的可以做完以上步骤后，进行克隆。实验环境为1 Master，2 Node</strong></p>\n<h4>创建集群准备工作</h4>\n<pre class=\"prettyprint language-shell\"><code># Master端：\nkubeadm config images pull # 拉取集群所需镜像，这个需要翻墙\n\n# --- 不能翻墙可以尝试以下办法 ---\nkubeadm config images list # 列出所需镜像\n#(不是一定是下面的,根据实际情况来)\n# 根据所需镜像名字先拉取国内资源\ndocker pull mirrorgooglecontainers&#x2F;kube-apiserver:v1.14.1\ndocker pull mirrorgooglecontainers&#x2F;kube-controller-manager:v1.14.1\ndocker pull mirrorgooglecontainers&#x2F;kube-scheduler:v1.14.1\ndocker pull mirrorgooglecontainers&#x2F;kube-proxy:v1.14.1\ndocker pull mirrorgooglecontainers&#x2F;pause:3.1\ndocker pull mirrorgooglecontainers&#x2F;etcd:3.3.10\ndocker pull coredns&#x2F;coredns:1.3.1  # 这个在mirrorgooglecontainers中没有\n\n# 修改镜像tag\ndocker tag mirrorgooglecontainers&#x2F;kube-apiserver:v1.14.1 k8s.gcr.io&#x2F;kube-apiserver:v1.14.1\ndocker tag mirrorgooglecontainers&#x2F;kube-controller-manager:v1.14.1 k8s.gcr.io&#x2F;kube-controller-manager:v1.14.1\ndocker tag mirrorgooglecontainers&#x2F;kube-scheduler:v1.14.1 k8s.gcr.io&#x2F;kube-scheduler:v1.14.1\ndocker tag mirrorgooglecontainers&#x2F;kube-proxy:v1.14.1 k8s.gcr.io&#x2F;kube-proxy:v1.14.1\ndocker tag mirrorgooglecontainers&#x2F;pause:3.1 k8s.gcr.io&#x2F;pause:3.1\ndocker tag mirrorgooglecontainers&#x2F;etcd:3.3.10 k8s.gcr.io&#x2F;etcd:3.3.10\ndocker tag coredns&#x2F;coredns:1.3.1 k8s.gcr.io&#x2F;coredns:1.3.1\n\n\n# 把所需的镜像下载好，init的时候就不会再拉镜像，由于无法连接google镜像库导致出错\n\n# 删除原来的镜像\ndocker rmi mirrorgooglecontainers&#x2F;kube-apiserver:v1.14.1\ndocker rmi mirrorgooglecontainers&#x2F;kube-controller-manager:v1.14.1\ndocker rmi mirrorgooglecontainers&#x2F;kube-scheduler:v1.14.1\ndocker rmi mirrorgooglecontainers&#x2F;kube-proxy:v1.14.1\ndocker rmi mirrorgooglecontainers&#x2F;pause:3.1\ndocker rmi mirrorgooglecontainers&#x2F;etcd:3.3.10\ndocker rmi coredns&#x2F;coredns:1.3.1\n\n# --- 不能翻墙可以尝试使用 ---\n\n# Node端：\n# 根据所需镜像名字先拉取国内资源\ndocker pull mirrorgooglecontainers&#x2F;kube-proxy:v1.14.1\ndocker pull mirrorgooglecontainers&#x2F;pause:3.1\n\n\n# 修改镜像tag\ndocker tag mirrorgooglecontainers&#x2F;kube-proxy:v1.14.1 k8s.gcr.io&#x2F;kube-proxy:v1.14.1\ndocker tag mirrorgooglecontainers&#x2F;pause:3.1 k8s.gcr.io&#x2F;pause:3.1\n\n# 删除原来的镜像\ndocker rmi mirrorgooglecontainers&#x2F;kube-proxy:v1.14.1\ndocker rmi mirrorgooglecontainers&#x2F;pause:3.1\n# 不加载镜像node节点不能\n</code></pre><h3>使用kubeadm创建集群</h3>\n<pre class=\"prettyprint language-shell\"><code># 第一次初始化过程中&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf该文件存在，是空文件（我自己手动创建的），会报错：panic: runtime error: invalid memory address or nil pointer dereference\nls &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf &amp;&amp; mv &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf.bak # 移走备份\n\n# 初始化Master（Master需要至少2核）此处会各种报错,异常...成功与否就在此\nkubeadm init --apiserver-advertise-address 192.168.200.25 --pod-network-cidr 10.244.0.0&#x2F;16 # --kubernetes-version 1.14.1\n# --apiserver-advertise-address 指定与其它节点通信的接口\n# --pod-network-cidr 指定pod网络子网，使用fannel网络必须使用这个CIDR\n</code></pre><ul>\n<li>运行初始化，程序会检验环境一致性，可以根据实际错误提示进一步修复问题。</li>\n<li>程序会访问https://dl.k8s.io/release/stable-1.txt获取最新的k8s版本，访问这个连接需要FQ，如果无法访问，则会使用kubeadm client的版本作为安装的版本号，使用kubeadm version查看client版本。也可以使用–kubernetes-version明确指定版本。</li>\n</ul>\n<pre class=\"prettyprint\"><code># 初始化结果：\n[init] Using Kubernetes version: v1.14.1\n[preflight] Running pre-flight checks\n[preflight] Pulling images required for setting up a Kubernetes cluster\n[preflight] This might take a minute or two, depending on the speed of your internet connection\n[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;\n[kubelet-start] Writing kubelet environment file with flags to file &quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;kubeadm-flags.env&quot;\n[kubelet-start] Writing kubelet configuration to file &quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;config.yaml&quot;\n[kubelet-start] Activating the kubelet service\n[certs] Using certificateDir folder &quot;&#x2F;etc&#x2F;kubernetes&#x2F;pki&quot;\n[certs] Using existing etcd&#x2F;ca certificate authority\n[certs] Using existing etcd&#x2F;server certificate and key on disk\n[certs] Using existing etcd&#x2F;peer certificate and key on disk\n[certs] Using existing etcd&#x2F;healthcheck-client certificate and key on disk\n[certs] Using existing apiserver-etcd-client certificate and key on disk\n[certs] Using existing ca certificate authority\n[certs] Using existing apiserver certificate and key on disk\n[certs] Using existing apiserver-kubelet-client certificate and key on disk\n[certs] Using existing front-proxy-ca certificate authority\n[certs] Using existing front-proxy-client certificate and key on disk\n[certs] Using the existing &quot;sa&quot; key\n[kubeconfig] Using kubeconfig folder &quot;&#x2F;etc&#x2F;kubernetes&quot;\n[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file\n[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file\n[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file\n[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file\n[control-plane] Using manifest folder &quot;&#x2F;etc&#x2F;kubernetes&#x2F;manifests&quot;\n[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;\n[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;\n[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;\n[etcd] Creating static Pod manifest for local etcd in &quot;&#x2F;etc&#x2F;kubernetes&#x2F;manifests&quot;\n[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;&#x2F;etc&#x2F;kubernetes&#x2F;manifests&quot;. This can take up to 4m0s\n[apiclient] All control plane components are healthy after 21.503375 seconds\n[upload-config] storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace\n[kubelet] Creating a ConfigMap &quot;kubelet-config-1.14&quot; in namespace kube-system with the configuration for the kubelets in the cluster\n[upload-certs] Skipping phase. Please see --experimental-upload-certs\n[mark-control-plane] Marking the node master as control-plane by adding the label &quot;node-role.kubernetes.io&#x2F;master=&#x27;&#x27;&quot;\n[mark-control-plane] Marking the node master as control-plane by adding the taints [node-role.kubernetes.io&#x2F;master:NoSchedule]\n[bootstrap-token] Using token: w2i0mh.5fxxz8vk5k8db0wq\n[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles\n[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials\n[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token\n[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster\n[bootstrap-token] creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace\n[addons] Applied essential addon: CoreDNS\n[addons] Applied essential addon: kube-proxy\n\nYour Kubernetes control-plane has initialized successfully!\n\nTo start using your cluster, you need to run the following as a regular user:\n\n  mkdir -p $HOME&#x2F;.kube\n  sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config\n  sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config\n\nYou should now deploy a pod network to the cluster.\nRun &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:\n  https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;concepts&#x2F;cluster-administration&#x2F;addons&#x2F;\n\nThen you can join any number of worker nodes by running the following on each as root:\n\n#每个机器创建的master以下部分都不同,需要自己保存好-qxl\nkubeadm join 192.168.200.25:6443 --token our9a0.zl490imi6t81tn5u \\\n    --discovery-token-ca-cert-hash sha256:b93f710eb9b389a69f0cd0d6dcf7c82e389a68f009eb6b2028f69d54b099de16 \n</code></pre><h4>普通用户设置权限</h4>\n<pre class=\"prettyprint language-shell\"><code>  mkdir -p $HOME&#x2F;.kube\n  sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config\n  sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config\n</code></pre><h4>应用flannel网络</h4>\n<pre class=\"prettyprint language-shell\"><code>kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml\n</code></pre><h3>node加入机器</h3>\n<pre class=\"prettyprint language-shell\"><code># node1:\nkubeadm join 192.168.20.5:6443 --token w2i0mh.5fxxz8vk5k8db0wq \\\n    --discovery-token-ca-cert-hash sha256:65e82e987f50908f3640df7e05c7a91f390a02726c9142808faa739d4dc24252 \n# node2:\nkubeadm join 192.168.20.5:6443 --token w2i0mh.5fxxz8vk5k8db0wq \\\n    --discovery-token-ca-cert-hash sha256:65e82e987f50908f3640df7e05c7a91f390a02726c9142808faa739d4dc24252 \n</code></pre><p>输出日志：</p>\n<pre class=\"prettyprint\"><code>[preflight] Running pre-flight checks\n[preflight] Reading configuration from the cluster...\n[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -oyaml&#x27;\n[kubelet-start] Downloading configuration for the kubelet from the &quot;kubelet-config-1.14&quot; ConfigMap in the kube-system namespace\n[kubelet-start] Writing kubelet configuration to file &quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;config.yaml&quot;\n[kubelet-start] Writing kubelet environment file with flags to file &quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;kubeadm-flags.env&quot;\n[kubelet-start] Activating the kubelet service\n[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...\n\nThis node has joined the cluster:\n* Certificate signing request was sent to apiserver and a response was received.\n* The Kubelet was informed of the new secure connection details.\n\nRun &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster.\n</code></pre><pre class=\"prettyprint language-shell\"><code># master：\nkubectl get pods --all-namespaces\n# ---输出信息---\nNAMESPACE     NAME                             READY   STATUS    RESTARTS   AGE\nkube-system   coredns-fb8b8dccf-rn8kd          1&#x2F;1     Running   0          170m\nkube-system   coredns-fb8b8dccf-slwr4          1&#x2F;1     Running   0          170m\nkube-system   etcd-master                      1&#x2F;1     Running   0          169m\nkube-system   kube-apiserver-master            1&#x2F;1     Running   0          169m\nkube-system   kube-controller-manager-master   1&#x2F;1     Running   0          169m\nkube-system   kube-flannel-ds-amd64-l8c7c      1&#x2F;1     Running   0          130m\nkube-system   kube-flannel-ds-amd64-lcmxw      1&#x2F;1     Running   1          117m\nkube-system   kube-flannel-ds-amd64-pqnln      1&#x2F;1     Running   1          72m\nkube-system   kube-proxy-4kcqb                 1&#x2F;1     Running   0          170m\nkube-system   kube-proxy-jcqjd                 1&#x2F;1     Running   0          72m\nkube-system   kube-proxy-vm9sj                 1&#x2F;1     Running   0          117m\nkube-system   kube-scheduler-master            1&#x2F;1     Running   0          169m\n# ---输出信息---\n\n\nkubectl get nodes\n# ---输出信息---\nNAME     STATUS   ROLES    AGE    VERSION\nmaster   Ready    master   171m   v1.14.1\nnode1    Ready    &lt;none&gt;   118m   v1.14.1\nnode2    Ready    &lt;none&gt;   74m    v1.14.1\n# ---输出信息---\n</code></pre><p>排错</p>\n<pre class=\"prettyprint language-shell\"><code>journalctl -f  # 当前输出日志\njournalctl -f -u kubelet  # 只看当前的kubelet进程日志\n</code></pre></div>","title":"2019最新k8s集群搭建教程 (centos k8s 搭建)","last_reply_at":"2019-04-23T01:52:59.496Z","good":false,"top":false,"reply_count":10,"visit_count":1266,"create_at":"2019-04-18T02:22:56.623Z","author":{"loginname":"qxl1231","avatar_url":"https://avatars1.githubusercontent.com/u/8305742?v=4&s=120"}},{"id":"5add9ef3a7d228c16b9871c9","author_id":"58d83c586f8b9bf02d1d0b1d","tab":"ask","content":"<div class=\"markdown-text\"><p>前端怎么转node后端\n这是目前个人开发的项目 很菜 只有十几个路由\n目前只也会express+mysql+一堆npm包 写登录token 发验证文件增删查改和爬虫\n想要深入的话要怎么深入才能成为个合格的noder\n前端真的写腻了,怎么转node好 求各位大大指路\n<a href=\"https://github.com/pulessrity/ikan_comic\">https://github.com/pulessrity/ikan_comic</a></p>\n</div>","title":"感觉后端有意思,前端好无聊","last_reply_at":"2019-04-23T01:48:01.628Z","good":false,"top":false,"reply_count":22,"visit_count":4196,"create_at":"2018-04-23T08:53:07.283Z","author":{"loginname":"ResJay","avatar_url":"https://avatars0.githubusercontent.com/u/26635410?v=4&s=120"}},{"id":"5cbd9817a86ae80ce64b1fa2","author_id":"5aa08ffb19b2e3db18959ba1","tab":"ask","content":"<div class=\"markdown-text\"><p>数据是类似这样的数据；\n每一项的数据都是一样的。\n就相当于  iPhone 华为 小米  都属于手机分类一样；\n就是把这个数据 重组一下 逻辑很简单。\n但是遇到一个很诡异的问题。\n<img src=\"//static.cnodejs.org/Fp5DQM5GalpGfJA4ZziP8t9Vomvk\" alt=\"数据.png\"></p>\n<h5>我先上代码</h5>\n<p><img src=\"//static.cnodejs.org/FsRoPuJHBjNAjTA4gPbotenTtMse\" alt=\"代码.png\"></p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 暂无任何一个机构项\nnew_project_list.push({\n  ins_title: item.ins_title,\n  &#x2F;&#x2F; 问题就在这  添不添加 这个item\n  child: [item]\n});\n</code></pre><h4>添加后的结果</h4>\n<p><img src=\"//static.cnodejs.org/Fu_oaniiqRJ0DymUcPSRs6FkDcf0\" alt=\"添加后的结果.png\"></p>\n<h4>未添加的结果</h4>\n<p><img src=\"//static.cnodejs.org/Ftk9SLRpxqhUsRToK_XAyb981E6B\" alt=\"未添加的结果.png\"></p>\n<h3>求助哟，真心想不通</h3>\n</div>","title":"我得发个问题 求教一下 关于数组操作的","last_reply_at":"2019-04-22T15:36:04.865Z","good":false,"top":false,"reply_count":2,"visit_count":500,"create_at":"2019-04-22T10:31:51.510Z","author":{"loginname":"gek6","avatar_url":"https://avatars2.githubusercontent.com/u/33946481?v=4&s=120"}},{"id":"5cbdc8eda86ae80ce64b20ee","author_id":"5c98426500bcfd7eb2be5add","tab":"share","content":"<div class=\"markdown-text\"><h1>彻底理解Node.js中的Buffer</h1>\n<p>每当在Node.js中遇到<strong>Buffer</strong>,<strong>Stream</strong>和<strong>binary data</strong>之类的单词时，是否总是像我一样感到困惑? 认为它们并不是常用的，而只适合Node.js专家和包开发人员去使用。</p>\n<p>实际上，这些单词是非常重要的，尤其对于用Node.js进行web开发而没有任何CS学位的人员。</p>\n<p>当然，如果你选择继续做一个普通的Node.js开发人员，你可能永远不会直接使用它们。但是如果你想对Node.js的理解提升到下一个级别，那么你确实需要更深入地了解Node的许多核心特性。比如Buffer。这正是我写这篇文章的目的——帮助我们揭开其中一些特性的神秘面纱，并将Node.js的学习带到下一个层次。</p>\n<p>在开始前，先看一下<a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html#buffer_buffer\">Node.js官方文档</a>对Buffer的说明</p>\n<blockquote>\n<p>… mechanism for reading or manipulating streams of binary data. The Buffer class was introduced as part of the Node.js API to make it possible to interact with octet streams in the context of things like TCP streams and file system operations.</p>\n</blockquote>\n<p>让我们用简单易懂的语言来重新描述它:</p>\n<pre class=\"prettyprint language-text\"><code>Buffer类作为Node.js API的一部分引入，使操作二进制数据流或与之交互成为可能。\n</code></pre><p>接下来我们更深入的去了解Buffer,streams,binary data。</p>\n<h2>什么是二进制数据</h2>\n<p>你可能已经知道计算机以二进制文件存储和表示数据。二进制就是1和0的集合。例如，下面是5个不同的二进制文件，5组不同的1和0:</p>\n<pre class=\"prettyprint language-text\"><code>10, 01, 001, 1110, 00101011\n</code></pre><p>二进制中每个1和0都称为<strong>Bit</strong>，这是二进制数字的一种简短形式。</p>\n<p>为了存储或表示一段数据，计算机需要将该数据转换为二进制表示。例如，要存储数字12，计算机需要将12转换成二进制表示，即1100。</p>\n<p>但是在工作中，number并不是唯一的数据类型。通常上还会有string,images,videos。计算机知道如何用二进制表示所有的数据类型。比如计算机如何用二进制表示string类型的“L”呢？要将任何字符存储在二进制文件中，计算机首先将该字符转换为数字，然后将该数字转换为二进制表示形式。对于字符串“L”，计算机首先将L转换成表示L的数字。</p>\n<p>打开浏览器控制台，输入“L”. charcodeat(0)。这时控制台会显示出数字76，这是字符“L”的数字表示。但是计算机又是如何知道每个字符表示的确切数字呢?它怎么知道用76来表示L?</p>\n<h2>字符集</h2>\n<p>字符集已经定义好的表示每个字符的确切数字的规则。我们对这些规则有不同的定义，最流行的包括Unicode和ASCII。JavaScript可以很好地处理Unicode字符集。所以，浏览器中的Unicode规定<strong>76</strong>应该表示<strong>L</strong>。</p>\n<p>我们已经看到计算机是如何用数字表示字符的。转换成数字之后计算机再把76转换它的二进制表示。</p>\n<h2>字符编码</h2>\n<p>正如有一些字符集规则定义数字应该怎么样表示字符一样，也有一些规则定义了数字应该如何在二进制文件中表示。具体来说，就是用多少位来表示数字。这叫做字符编码。</p>\n<p>字符编码的一个规则是<strong>UTF-8</strong>。UTF-8声明字符应该以<strong>bytes</strong>编码。一个<strong>byte</strong>是8位（bit）的集合 —— 8个1和0。因此，UTF-8规定应该使用8个1和0来表示二进制中任何字符。</p>\n<p>之前的例子提到，数字12用二进制表示为 <strong>1100</strong>，但是用UTF-8表示应该是8位才对。所以UTF-8规定，计算机需要在不满8位的二进制数字左边添加更多的位，以使其成为一个字节。所以12应该存储为<strong>00001100</strong>。</p>\n<p>因此 76 在UTF-8规则下存储表示为：<strong>01001100</strong></p>\n<p>这就是计算机在二进制文件中存储字符串或字符的方式。同样，计算机也规定了图片和视频应该如何转换、编码和存储在二进制文件中的规则。计算机将所有数据类型存储在二进制文件中。</p>\n<p>现在我们了解了什么是二进制数据，接下来我们介绍一下什么是二进制数据流。</p>\n<h2>流</h2>\n<p>js中的Stream只是表示随着时间的推移从一个点移动到另一个点的数据序列。整个概念是，你有大量的数据要处理，但是你不需要等到所有的数据都可用后才开始处理它。基本上，这个大数据被分解并以块的形式发送。因此，从Buffer的原始定义来看，这仅仅意味着二进制数据正在文件系统中移动。例如，将存储在file1.txt中的文本移动到file2.txt。</p>\n<p>但是Buffer究竟如何帮助我们在流与二进制数据进行交互或操作呢?Buffer到底是什么?</p>\n<h2>Buffer</h2>\n<p>我们已经提到，数据流是数据从一个点移动到另一个点，但是它们究竟是如何移动的呢?</p>\n<p>通常数据的移动是为了处理或读取数据，并根据数据做出决策。在这个过程中，可能需要数据到达一个最小量或者最大量才能进行处理。因此，如果数据到达的速度快于进程消耗数据的速度，那么多余的数据需要在某个地方的等待来处理。另一方面，如果进程消耗数据的速度快于数据到达的速度，那么早到达的少数数据需要等待一定数量的数据到达，然后再发送出去进行处理。</p>\n<p>那个“等候区”就是<strong>Buffer</strong>!它是计算机中的一个小物理位置，通常位于RAM中，数据在RAM中被临时收集、等待，并最终发在流过程中送出去进行处理。</p>\n<p>我们可以把整个stream和buffer过程看做一个汽车站。在某个汽车站，汽车直到有一定数量的乘客或者是一个特殊的时间才可以发车。此外，乘客可能在不同的时间以不同的速度到达。无论是旅客还是汽车站都不能控制旅客到达车站的时间。提前到达的乘客需要等汽车发车。当有些乘客到达时，乘客已经满员或者汽车已经离开，需要等待下一辆汽车。</p>\n<p>无论什么情况，总有一个等待的地方。这就是Node.js的Buffer! js不能控制数据到达的速度或时间，也不能控制流的速度。它只能决定何时发送数据。如果还没有到时间，Node.js将把它们放在buffer中，即RAM中的一个小位置，直到将它们发送出去进行处理为止。</p>\n<p>一个典型的例子是，当你在观看流媒体视频时，可以看到buffer在工作。如果你的互联网连接足够快，流的速度将足够快，可以立即填满Buffer并发送出去进行处理，然后再填入另一个Buffer，然后发送出去，再发送一个，再发送一个，直到流完成为止。</p>\n<p>但是如果你的连接很慢，在处理了第一组到达的数据后，视频会被卡主，这意味着程序正在收集更多的数据，或者等待更多的数据到达。当buffer被填满并处理后，播放器会继续播放视频。在播放的同时，更多的数据将继续到达并在buffer中等待。</p>\n<h2>与Buffer交互</h2>\n<p>Node.js在处理流期间会自动创建buffer，我们也可以通过Nodejs提供的API自己创建buffer。根据你的需求，这里有几种不同的方法可以创建buffer。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; Create an empty buffer of size 10.\n&#x2F;&#x2F; A buffer that only can accommodate 10 bytes\nconst buf1 = Buffer.alloc(10)\n\n&#x2F;&#x2F; Create a buffer with content\nconst buf2 = Buffer.from(&quot;hello buffer&quot;)\n</code></pre><p>当创建成功buffer后，你就可以开始和它进行交互了。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 查看buffer的结构\nbuf1.toJSON()\n&#x2F;&#x2F; { type: &#x27;Buffer&#x27;, data: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] }\n\nbuf2.toJSON()\n&#x2F;&#x2F;{ type: &#x27;Buffer&#x27;,data: [ 104, 101, 108, 108, 111, 32, 98, 117, 102, 102, 101, 114 ]}\n\nbuf1.length &#x2F;&#x2F; 10\nbuf2.length &#x2F;&#x2F; 12\n\n&#x2F;&#x2F; 写操作\nbuf1.write(&quot;Buffer really rocks!&quot;)\n\n&#x2F;&#x2F; decode\nbuf1.toString() &#x2F;&#x2F; &#x27;Buffer rea&#x27;\n&#x2F;&#x2F; 因为buf1创建时只分配了10byte的空间。超过的将不会被存储。\n</code></pre><p>更多的交互API，可以查看<a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html#buffer_buffer\">官方文档</a>，</p>\n<p>希望这篇介绍能帮助您更好地理解Node.js Buffer。</p>\n</div>","title":"彻底理解Node.js中的Buffer","last_reply_at":"2019-04-22T14:00:13.077Z","good":false,"top":false,"reply_count":0,"visit_count":684,"create_at":"2019-04-22T14:00:13.077Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5c0a929c15a4d545e3f4c5d6","author_id":"5bc9f0ca9545eaf107b9ccdd","tab":"ask","content":"<div class=\"markdown-text\"><p>如何学习</p>\n</div>","title":"如何学习vue框架","last_reply_at":"2019-04-22T13:41:44.949Z","good":false,"top":false,"reply_count":24,"visit_count":2426,"create_at":"2018-12-07T15:32:44.120Z","author":{"loginname":"hhffhh","avatar_url":"https://avatars0.githubusercontent.com/u/3991376?v=4&s=120"}},{"id":"5cbab70737faec0ce1d03f6c","author_id":"5b4d997faef62f1b0f9e03be","tab":"share","content":"<div class=\"markdown-text\"><h2>背景</h2>\n<p>这几天抽时间深入阅读了一下 Express-session 中间件的源码，做个总结。</p>\n<h2>Cookie</h2>\n<p>Cookie 是网站为了辨别用户身份、进行 Session 跟踪而储存在用户本地终端上的数据。Cookie有如下属性：</p>\n<ul>\n<li>Cookie-name &amp; Cookie-value ：想要存储的键值对，比如 <code>SessionId:xxx</code>。</li>\n<li>Expires ：Cookie 存储在浏览器的最大时间，需要注意的是，这里的时间是相对于客户端时间而不是服务端时间。</li>\n<li>Max-age ：等待 Cookie 过期的秒数。与 Expires 同时存在的时候，优先级高于 Expires。</li>\n<li>Domain ：属性定义可访问该 Cookie 的域名，对一些大的网站，如果希望 Cookie 可以在子网站中共享，可以使用该属性。例如设置 Domain 为 <code>.bigsite.com</code>,则<code>sub1.bigsite.com</code>和<code>sub2.bigsite.com</code>都可以访问已保存在客户端的<code>cookie</code>，这时还需要将 Path 设置为<code>/</code>。</li>\n<li>Path ：可以访问 Cookie的页面的路径，缺省状态下 Path 为产生 Cookie 时的路径，此时 Cookie。 可以被该路径以及其子路径下的页面访问；可以将 Path 设置为 <code>/</code> ，使 Cookie 可以被网站下所有页面访问。</li>\n<li>Secure ：Secure 只是一个标记而没有值。只有当一个请求通过 SSL 或 HTTPS 创建时，包含 Secure 选项的 Cookie 才能被发送至服务器。</li>\n<li>HttpOnly ：只允许 Cookie 通过 Http 方式来访问，防止脚本攻击。</li>\n</ul>\n<p>Cookie 也有一些不足：</p>\n<ul>\n<li>Http 请求的 Cookie 是明文传递的,所以安全性会有问题。</li>\n<li>Cookie 会附加在 Http 请求中，加大了请求的流量。</li>\n<li>Cookie 有大小限制,无法满足复杂的存储。</li>\n</ul>\n<h2>cookie 与 session 交互</h2>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/20/16a393e758224bf9?w=1632&amp;h=688&amp;f=png&amp;s=92700\" alt></p>\n<p>一次请求的流程大概如下：</p>\n<ul>\n<li>客户端初次向服务端发出请求，此时 Cookie 内还没有 SessionId。</li>\n<li>服务端接收到 Request ，解析出 Request Header 没有对应的 SessionId ,于是服务端初始化一个 Session,并将 Session 存放到对应的容器里，如文件、Redis、内存中。</li>\n<li>请求返回时，Response.header 中写入 <code>set-cookie</code> 传入 SessioinId。</li>\n<li>客户端接收到 <code>set-cookie</code> 指令，将 Cookie 的内容存放在客户端。</li>\n<li>再次请求时,请求的 Cookie 中就会带有该用户会话的 SessionId。</li>\n</ul>\n<h2>源码笔记</h2>\n<p>express-session 包主要由index.js、cookie.js、memory.js、session.js、store.js组成。</p>\n<h3>cookie.js</h3>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; cookie构造函数，默认 path、maxAge、httpOnly 的值，如果有传入的 Options ，则覆盖默认配置\n\nconst Cookie = module.exports = function Cookie(options) {\n  this.path = &#x27;&#x2F;&#x27;;\n  this.maxAge = null;\n  this.httpOnly = true;\n  if (options) merge(this, options);\n  this.originalMaxAge = undefined == this.originalMaxAge\n    ? this.maxAgemaxAge\n    : this.originalMaxAge;\n};\n\n&#x2F;&#x2F;封装了 cookie 的方法：set expires、get expires 、set maxAge、get maxAge、get data、serialize、toJSON\n\nCookie.prototype = {\n    ······\n};\n</code></pre><h3>store.js</h3>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; store 对象用于顾名思义与 session 存储有关\n&#x2F;&#x2F; store 对象是一个抽象类，封装了一些抽象函数，需要子类去具体实现。\n\n&#x2F;&#x2F; 重新获取 store ，先销毁再获取，子类需要实现 destroy 销毁函数。\nStore.prototype.regenerate = function (req, fn) {\n  const self = this;\n  this.destroy(req.sessionID, (err) =&gt; {\n    self.generate(req);\n    fn(err);\n  });\n};\n\n&#x2F;&#x2F; 根据 sid 加载 session\nStore.prototype.load = function (sid, fn) {\n  const self = this;\n  this.get(sid, (err, sess) =&gt; {\n    if (err) return fn(err);\n    if (!sess) return fn();\n    const req = { sessionID: sid, sessionStore: self };\n    fn(null, self.createSession(req, sess));\n  });\n};\n\n&#x2F;&#x2F;该函数用于创建session\n&#x2F;&#x2F;调用 Session() 在 request 对象上构造 session \n&#x2F;&#x2F;为什么创建 session 的函数要放在 store 里？\nStore.prototype.createSession = function (req, sess) {\n  let expires = sess.cookie.expires\n    , orig = sess.cookie.originalMaxAge;\n  sess.cookie = new Cookie(sess.cookie);\n  if (typeof expires === &#x27;string&#x27;) sess.cookie.expires = new Date(expires);\n  sess.cookie.originalMaxAge = orig;\n  req.session = new Session(req, sess);\n  return req.session;\n};\n</code></pre><h3>session.js</h3>\n<pre class=\"prettyprint\"><code>module.exports = Session;\n\n&#x2F;&#x2F; Session构造函数，根据 request 与 data 参数构造 session 对象\nfunction Session(req, data) {\n  Object.defineProperty(this, &#x27;req&#x27;, { value: req });\n  Object.defineProperty(this, &#x27;id&#x27;, { value: req.sessionID });\n\n  if (typeof data ===== &#x27;object&#x27; &amp;&amp; data !== null) {\n    &#x2F;&#x2F; merge data into this, ignoring prototype properties\n    for (const prop in data) {\n      if (!(prop in this)) {\n        this[prop] = data[prop];\n      }\n    }\n  }\n}\n</code></pre><h3>memory.js</h3>\n<pre class=\"prettyprint\"><code>module.exports = MemoryStore;\n\n&#x2F;&#x2F; 继承了 store 的内存仓库\nfunction MemoryStore() {\n  Store.call(this);\n  this.sessions = Object.create(null);\n}\n\n\nutil.inherits(MemoryStore, Store);\n\n&#x2F;&#x2F; 获取内存中的所有 session 记录\nMemoryStore.prototype.all = function all(callback) {\n  const sessionIds = Object.keys(this.sessions);\n  const sessions = Object.create(null);\n\n  for (let i = 0; i &lt; sessionIds.length; i++) {\n    const sessionId = sessionIds[i];\n    const session = getSession.call(this, sessionId);\n\n    if (session) {\n      sessions[sessionId] = session;\n    }\n  }\n\n  callback &amp;&amp; defer(callback, null, sessions);\n};\n\n&#x2F;&#x2F; 清空内存记录\nMemoryStore.prototype.clear = function clear(callback) {\n  this.sessions = Object.create(null);\n  callback &amp;&amp; defer(callback);\n};\n\n&#x2F;&#x2F; 根据 sessionId 销毁对应的 session 信息\nMemoryStore.prototype.destroy = function destroy(sessionId, callback) {\n  delete this.sessions[sessionId];\n  callback &amp;&amp; defer(callback);\n};\n\n\n&#x2F;&#x2F; 根据 sessionId 返回 session\nMemoryStore.prototype.get = function get(sessionId, callback) {\n  defer(callback, null, getSession.call(this, sessionId));\n};\n\n&#x2F;&#x2F; 写入 session\nMemoryStore.prototype.set = function set(sessionId, session, callback) {\n  this.sessions[sessionId] = JSON.stringify(session);\n  callback &amp;&amp; defer(callback);\n};\n\n\n&#x2F;&#x2F; 获取有效的 session\nMemoryStore.prototype.length = function length(callback) {\n  this.all((err, sessions) =&gt; {\n    if (err) return callback(err);\n    callback(null, Object.keys(sessions).length);\n  });\n};\n\n&#x2F;&#x2F; 更新 session 的 cookie 信息\nMemoryStore.prototype.touch = function touch(sessionId, session, callback) {\n  const currentSession = getSession.call(this, sessionId);\n\n  if (currentSession) {\n    &#x2F;&#x2F; update expiration\n    currentSession.cookie = session.cookie;\n    this.sessions[sessionId] = JSON.stringify(currentSession);\n  }\n\n  callback &amp;&amp; defer(callback);\n};\n</code></pre><h3>index.js</h3>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; index 文件为了读起来清晰通顺，我只提取了 session 中间件的主要逻辑大部分的函数定义我都去除了，具体某个函数不了解可以自己看详细函数实现。\n\nexports = module.exports = session;\n\nexports.Store = Store;\nexports.Cookie = Cookie;\nexports.Session = Session;\nexports.MemoryStore = MemoryStore;\n\n\nfunction session(options) {\n\n  &#x2F;&#x2F;根据 option 赋值\n  const opts = options || {};\n  const cookieOptions = opts.cookie || {};\n  const generateId = opts.genid || generateSessionId;\n  const name = opts.name || opts.key || &#x27;connect.sid&#x27;;\n  const store = opts.store || new MemoryStore();\n  const trustProxy = opts.proxy;\n  let resaveSession = opts.resave;\n  const rollingSessions = Boolean(opts.rolling);\n  let saveUninitializedSession = opts.saveUninitialized;\n  let secret = opts.secret;\n\n  &#x2F;&#x2F; 定义 store的 generate 函数（原来 store.regenerate 的 generate()在这里定义。。为啥不在 store 文件里定义呢？）\n  &#x2F;&#x2F; request 对象下挂载 sessionId 与 cookie 对象\n  store.generate = function (req) {\n    req.sessionID = generateId(req);\n    req.session = new Session(req);\n    req.session.cookie = new Cookie(cookieOptions);\n\n    if (cookieOptions.secure === &#x27;auto&#x27;) {\n      req.session.cookie.secure = issecure(req, trustProxy);\n    }\n  };\n\n  const storeImplementsTouch = typeof store.touch === &#x27;function&#x27;;\n\n  &#x2F;&#x2F;注册 session store 的监听  \n  let storeReady = true;\n  store.on(&#x27;disconnect&#x27;, () =&gt; {\n    storeReady = false;\n  });\n  store.on(&#x27;connect&#x27;, () =&gt; {\n    storeReady = true;\n  });\n\n\n  return function session(req, res, next) {\n    &#x2F;&#x2F; self-awareness\n    if (req.session) {\n      next();\n      return;\n    }\n\n    &#x2F;&#x2F; Handle connection as if there is no session if\n    &#x2F;&#x2F; the store has temporarily disconnected etc\n    if (!storeReady) {\n      debug(&#x27;store is disconnected&#x27;);\n      next();\n      return;\n    }\n\n    &#x2F;&#x2F; pathname mismatch\n    const originalPath = parseUrl.original(req).pathname;\n    if (originalPath.indexOf(cookieOptions.path || &#x27;&#x2F;&#x27;) !== 0) return next();\n\n    &#x2F;&#x2F; ensure a secret is available or bail\n    if (!secret &amp;&amp; !req.secret) {\n      next(new Error(&#x27;secret option required for sessions&#x27;));\n      return;\n    }\n\n    &#x2F;&#x2F; backwards compatibility for signed cookies\n    &#x2F;&#x2F; req.secret is passed from the cookie parser middleware\n    const secrets = secret || [req.secret];\n\n    let originalHash;\n    let originalId;\n    let savedHash;\n    let touched = false;\n\n    &#x2F;&#x2F; expose store\n    req.sessionStore = store;\n\n    &#x2F;&#x2F; get the session ID from the cookie\n    const cookieId = req.sessionID = getcookie(req, name, secrets);\n\n    &#x2F;&#x2F; 绑定监听事件，程序改写 res.header 时写入 set-cookie\n    onHeaders(res, () =&gt; {\n      if (!req.session) {\n        debug(&#x27;no session&#x27;);\n        return;\n      }\n\n      if (!shouldSetCookie(req)) {\n        return;\n      }\n\n      &#x2F;&#x2F; only send secure cookies via https\n      if (req.session.cookie.secure &amp;&amp; !issecure(req, trustProxy)) {\n        debug(&#x27;not secured&#x27;);\n        return;\n      }\n  \n      if (!touched) {\n        &#x2F;&#x2F; 重新设置 cookie 的 maxAge\n        req.session.touch();\n        touched = true;\n      }\n\n      &#x2F;&#x2F;将 set-cookie 写入 header\n      setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data);\n    });\n\n    &#x2F;&#x2F; 代理 res.end 来提交 session 到 session store \n    &#x2F;&#x2F; 覆写了 res.end 也解决了我最开始提出的为什么在请求的最后更新 session 的疑问。\n    const _end = res.end;\n    const _write = res.write;\n    let ended = false;\n    res.end = function end(chunk, encoding) {\n      if (ended) {\n        return false;\n      }\n\n      ended = true;\n\n      let ret;\n      let sync = true;\n\n      &#x2F;&#x2F;判断是否需要销毁库存中的对应 session 信息\n      if (shouldDestroy(req)) {\n        &#x2F;&#x2F; destroy session\n        debug(&#x27;destroying&#x27;);\n        store.destroy(req.sessionID, (err) =&gt; {\n          if (err) {\n            defer(next, err);\n          }\n\n          debug(&#x27;destroyed&#x27;);\n          writeend();\n        });\n\n        return writetop();\n      }\n\n      &#x2F;&#x2F; no session to save\n      if (!req.session) {\n        debug(&#x27;no session&#x27;);\n        return _end.call(res, chunk, encoding);\n      }\n\n      if (!touched) {\n        &#x2F;&#x2F; touch session\n        req.session.touch();\n        touched = true;\n      } \n\n      &#x2F;&#x2F;判断应该将 req.session 存入 store 中\n      if (shouldSave(req)) {\n        req.session.save((err) =&gt; {\n          if (err) {\n            defer(next, err);\n          }\n\n          writeend();\n        });\n\n        return writetop();\n      } else if (storeImplementsTouch &amp;&amp; shouldTouch(req)) {\n       \n        &#x2F;&#x2F;刷新 store 内的 session 信息\n        debug(&#x27;touching&#x27;);\n        store.touch(req.sessionID, req.session, (err) =&gt; {\n          if (err) {\n            defer(next, err);\n          }\n\n          debug(&#x27;touched&#x27;);\n          writeend();\n        });\n\n        return writetop();\n      }\n\n      return _end.call(res, chunk, encoding);\n    };\n\n    &#x2F;&#x2F; session 不存在重新获取 session\n    if (!req.sessionID) {\n      debug(&#x27;no SID sent, generating session&#x27;);\n      generate();\n      next();\n      return;\n    }\n\n    &#x2F;&#x2F; 获取 store 中的 session 对象\n    debug(&#x27;fetching %s&#x27;, req.sessionID);\n    store.get(req.sessionID, (err, sess) =&gt; {\n      &#x2F;&#x2F; error handling\n      if (err) {\n        debug(&#x27;error %j&#x27;, err);\n\n        if (err.code !== &#x27;ENOENT&#x27;) {\n          next(err);\n          return;\n        }\n        generate();\n      } else if (!sess) {\n        debug(&#x27;no session found&#x27;);\n        generate();\n      } else {\n        debug(&#x27;session found&#x27;);\n        store.createSession(req, sess);\n        originalId = req.sessionID;\n        originalHash = hash(sess);\n\n        if (!resaveSession) {\n          savedHash = originalHash;\n        }\n\n        &#x2F;&#x2F;重写res.session的 load() 与 save()\n        wrapmethods(req.session);\n      }\n\n      next();\n    });\n  };\n}\n</code></pre></div>","title":"Express Session 源码阅读笔记","last_reply_at":"2019-04-22T10:32:33.235Z","good":false,"top":false,"reply_count":2,"visit_count":738,"create_at":"2019-04-20T06:07:03.604Z","author":{"loginname":"guojingkang","avatar_url":"https://avatars0.githubusercontent.com/u/39728127?v=4&s=120"}},{"id":"5cb99e46a86ae80ce64b135e","author_id":"5adecaa3a86ec1f308ec2480","tab":"ask","content":"<div class=\"markdown-text\"><p>传统的 markdown 编辑器都是两个页面，左边编辑，右边预览效果。</p>\n<p>偶然发现 typora 和 语雀 这两个编辑器也可以写 markdown，但是是在一个页面上书写的，可见即所得。</p>\n<p>想了解下实现原理是什么？</p>\n</div>","title":"来场头脑风暴","last_reply_at":"2019-04-22T07:42:42.931Z","good":false,"top":false,"reply_count":2,"visit_count":1121,"create_at":"2019-04-19T10:09:10.014Z","author":{"loginname":"dkvirus","avatar_url":"https://avatars1.githubusercontent.com/u/29170168?v=4&s=120"}},{"id":"5cbd6fbf37faec0ce1d04831","author_id":"52d491ffe20b7c82147b2214","tab":"ask","content":"<div class=\"markdown-text\"><h4>正常的 Mongoose 里 不使用 Discriminators 的写法：</h4>\n<pre class=\"prettyprint language-js\"><code>&gt; models&#x2F;book.js\n\n&#x2F;&#x2F; Define our Book schema\nconst BookSchema = new mongoose.Schema(\n  {\n    title: { type: String, required: true },\n    author: { type: String, required: true },\n    release_date: { type: Date, required: true },\n  }\n);\n\n&#x2F;&#x2F; Create a model from our schema\nmodule.exports = mongoose.model(&#x27;Book&#x27;, BookSchema);\n</code></pre><pre class=\"prettyprint language-js\"><code>&gt; models&#x2F;movie.js\n\nconst MovieSchema = new mongoose.Schema(\n  {\n    title: { type: String, required: true },\n    director: { type: String, required: true },\n    release_date: { type: Date, required: true },\n  }\n);\n\nmodule.exports = mongoose.model(&#x27;Movie&#x27;, MovieSchema);\n</code></pre><h4>使用 Discriminators 的写法：</h4>\n<pre class=\"prettyprint language-js\"><code>&gt; models&#x2F;book.js\n\nconst baseOptions = {\n  discriminatorKey: &#x27;itemtype&#x27;, &#x2F;&#x2F; our discriminator key, could be anything\n  collection: &#x27;items&#x27;, &#x2F;&#x2F; the name of our collection\n};\n\nconst Base = mongoose.model(&#x27;Base&#x27;, new mongoose.Schema({\n      title: { type: String, required: true },\n      date_added: { type: Date, required: true },\n      redo: { type: Boolean, required: false },\n    }, baseOptions,\n  ),\n);\n\nmodule.exports = mongoose.model(&#x27;Base&#x27;);\n</code></pre><pre class=\"prettyprint language-js\"><code>&gt; models&#x2F;book.js\n\nconst Base = require(&#x27;.&#x2F;base&#x27;); &#x2F;&#x2F; we have to make sure our Book schema is aware of the Base schema\n\nconst Book = Base.discriminator(&#x27;Book&#x27;, new mongoose.Schema({\n    author: { type: String, required: true },\n  }),\n);\n\nmodule.exports = mongoose.model(&#x27;Book&#x27;);\n</code></pre><pre class=\"prettyprint language-js\"><code>&gt; models&#x2F;movie.js\n\nconst Base = require(&#x27;.&#x2F;base&#x27;);\n\nconst Movie = Base.discriminator(&#x27;Movie&#x27;, new mongoose.Schema({\n    director: { type: String, required: true },\n  }),\n);\n\nmodule.exports = mongoose.model(&#x27;Movie&#x27;);\n</code></pre><h4>上面的例子在 egg-mongoose 里这样写：</h4>\n<pre class=\"prettyprint language-js\"><code>&gt; {app_root}&#x2F;app&#x2F;model&#x2F;base.js\n\nmodule.exports = app =&gt; {\n  const mongoose = app.mongoose;\n  const Schema = mongoose.Schema;\n\n  const baseOptions = {\n  discriminatorKey: &#x27;itemtype&#x27;, &#x2F;&#x2F; our discriminator key, could be anything\n  collection: &#x27;items&#x27;, &#x2F;&#x2F; the name of our collection\n  };\n\nconst BaseScheme = new Schema({\n      title: { type: String, required: true },\n      date_added: { type: Date, required: true },\n      redo: { type: Boolean, required: false },\n    }, baseOptions);\n\n  return mongoose.model(&#x27;Base&#x27;, BaseScheme);\n};\n</code></pre><pre class=\"prettyprint language-js\"><code>&gt; {app_root}&#x2F;app&#x2F;model&#x2F;book.js\n\nconst Base = require(&#x27;.&#x2F;base&#x27;);\n\nmodule.exports = app =&gt; {\n  const mongoose = app.mongoose;\n  const Schema = mongoose.Schema;\n  \n  const BookSchema = new Schema({\n    author: { type: String, required: true },\n  });\n  \n  return Base.discriminator(&#x27;Book&#x27;, BookSchema);\n};\n</code></pre><h4>这样做会报错，提示：</h4>\n<pre class=\"prettyprint language-js\"><code>ERROR 30161 nodejs.TypeError: Base.discriminator is not a function\n</code></pre><h4>请问在 egg-mongoose 中在保持 model 分离的前提下如何实现上述功能？</h4>\n<h4>其他</h4>\n<p>上面例子的代码源自 <a href=\"https://dev.to/helenasometimes/getting-started-with-mongoose-discriminators-in-expressjs--22m9\">Getting started with Mongoose discriminators in Express.js</a></p>\n</div>","title":"egg-mongoose 的写法怎么实现 Discriminators？","last_reply_at":"2019-04-22T07:39:43.630Z","good":false,"top":false,"reply_count":0,"visit_count":519,"create_at":"2019-04-22T07:39:43.630Z","author":{"loginname":"VincentSit","avatar_url":"https://avatars0.githubusercontent.com/u/4084679?v=4&s=120"}},{"id":"5cbbec7237faec0ce1d04245","author_id":"57d216e13d3520a5387c2b53","tab":"ask","content":"<div class=\"markdown-text\"><p>RT!</p>\n</div>","title":"大家好，我问一下。node有什么比较好的开源影视视频项目吗","last_reply_at":"2019-04-22T04:56:52.490Z","good":false,"top":false,"reply_count":2,"visit_count":1168,"create_at":"2019-04-21T04:07:14.502Z","author":{"loginname":"a69694510","avatar_url":"https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"}},{"id":"5cbd405ea86ae80ce64b1c82","author_id":"5520a425ce156cc206687c5c","tab":"share","content":"<div class=\"markdown-text\"><p>在很多时候，我们需要定位一个文件的位置，通过不断向上寻找父目录，来找到。比如说，找到node项目根目录，我们就要从当前目录，不停地向上寻找到一个有着package.json的目录。</p>\n<p><a href=\"https://github.com/zhangkaiyulw/find-dominant-file\">find-dominant-file</a> 专门解决这个问题，它没有任何依赖项，它不仅支持js，也支持ts。我在多个项目中使用了这个小工具。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; TypeScript\nimport findDominantFile from &#x27;find-dominant-file&#x27;;\n&#x2F;&#x2F; JavaScript\nconst findDominantFile = require(&#x27;find-dominant-file&#x27;);\n</code></pre></div>","title":"推荐大家一个function小工具","last_reply_at":"2019-04-22T04:17:34.799Z","good":false,"top":false,"reply_count":0,"visit_count":623,"create_at":"2019-04-22T04:17:34.799Z","author":{"loginname":"cheunghy","avatar_url":"https://avatars0.githubusercontent.com/u/3055936?v=4&s=120"}},{"id":"5ba8ad0a15e4fd1923f489ff","author_id":"5520a425ce156cc206687c5c","tab":"share","content":"<div class=\"markdown-text\"><p>首先，确保node 8以上已经安装，建议用10。\n确保已经安装mongodb并后台启动。</p>\n<p>安装amur</p>\n<pre class=\"prettyprint language- bash\"><code>npm install amur -g\n</code></pre><p>创建项目和生成API</p>\n<pre class=\"prettyprint language-bash\"><code># 创建一个新项目\nmkdir ~&#x2F;Desktop&#x2F;demo\ncd ~&#x2F;Desktop&#x2F;demo\namur app . # 这里有一个点\n\n# 不需要上传型字段的话，这一段不要执行。你需要申请个AliOSS云存储。\n# 再没有Uploader的情况下，接下来的命令，请删掉上传型字段。\n# 这里创建一个Uploader\namur uploader FileUploader extends AliOSSUploader bucket=your-bucket \\\n  region=oss-cn-shanghai accessKeySecret=yourSecret \\\n  accessKeyId=yourId\n  \n# Note about the contact schema, it&#x27;s should be copied than referenced.\namur resource User &#x27;email:String!$&#x27; &#x27;name:String!$&#x27; &#x27;gender:Enum{male,female}!&#x27; \\\n  &#x27;age:Int&gt;=0&lt;=100!&#x27; avatar:FileUploader orders:[Order]:user contacts:[contactSchema] \\\n  notificationSettings:{ pushNotification:Boolean email:Boolean sms:Boolean }\n\namur schema Contact name:String phoneNo:String address:String\n# Note here:\n# we save category on product side, it&#x27;s because product has several categories,\n# but a category has a lot of products. We take the benefit of mongoDB.\namur resource Product &#x27;name:String!&#x27; &#x27;description:String!&#x27; &#x27;price:Float&gt;=0!&#x27; \\\n  &#x27;quantityAvailable:Int&gt;=0!&#x27; categories:[Category] images:[FileUploader] \\\n  comments:[Comment]:Order.comment.product coverImage:FileUploader\n# We can add a &#x27;countable&#x27; here.\namur resource Category &#x27;name:String!$&#x27; &#x27;description:String!&#x27; \\\n  products:[Product]:categories parentCategory:Category \\\n  childCategories:[Category]:parentCategory\n\n# Note we need to write custom code to verify if the quality is valid\n# We also need to add a custom getter which calculates the price\namur resource Order &#x27;product:Product!&#x27; &#x27;user:User!&#x27; comment:Comment \\\n  &#x27;quality:Int&gt;=0&#x27; contact:contactSchema\n\namur resource Comment &#x27;content:String!&#x27; order:Order:comment images:[FileUploader] \\\n  user:User:Order.user.comment product:Product:Order.product.comment\n</code></pre><p>最后，npm start即可打开浏览器，到http://localhost:4000体验GraphQL API啦</p>\n</div>","title":"Tutorial：五分钟做一套GraphQL API，不写代码","last_reply_at":"2019-04-22T04:13:36.615Z","good":false,"top":false,"reply_count":8,"visit_count":1924,"create_at":"2018-09-24T09:23:22.355Z","author":{"loginname":"cheunghy","avatar_url":"https://avatars0.githubusercontent.com/u/3055936?v=4&s=120"}},{"id":"5cbaee5aa86ae80ce64b1621","author_id":"5cbae245a86ae80ce64b1609","tab":"ask","content":"<div class=\"markdown-text\"><p>最近遇到一个需求，大文件上传，一开始使用FormData的格式上传，后台(<strong>go</strong>大佬)嫌弃解释时间太长，要求换成 <strong>octet-stream</strong>的格式？！\n我懵了许久，以前一直没听说过啊，在网上也没有查到能帮助的资料，然后前端各种修改，最终以前端获取到的 <em>File</em> 对象，直接丢到</p>\n<pre class=\"prettyprint\"><code>$.ajax({\n\tdata:File,\n\tcontentType:flase,\n\tprocessData:false\n\t}) \n</code></pre><p>然后后台接受到了，速度还挺快。然后我就想使用node来实现一波后台，然后发现用原生的node使用post接受chunk的形式不好使，mutler也不好使，所以请教一下各位有没有这方面的经验或者建议指导学习一下！！！</p>\n</div>","title":"前端上传非FormData格式的文件，node怎么接收处理","last_reply_at":"2019-04-22T03:45:07.405Z","good":false,"top":false,"reply_count":5,"visit_count":1024,"create_at":"2019-04-20T10:03:06.954Z","author":{"loginname":"edisonchan97","avatar_url":"https://avatars0.githubusercontent.com/u/26501047?v=4&s=120"}},{"id":"5cb688a6a86ae80ce64affc7","author_id":"57452aae754d17df1e44d9d7","tab":"share","content":"<div class=\"markdown-text\"><h2>根据Joi 参数判断，去实现文档的request部分，但是总感觉文档用起来还是不是太顺手，求star与提建议。</h2>\n<p>地址：<a href=\"https://github.com/ufo-parts/joi2md\">https://github.com/ufo-parts/joi2md</a>\n<strong>Example</strong></p>\n<pre class=\"prettyprint language-js\"><code>const Joi = require(&#x27;joi&#x27;);\nconst Joi2md = require(&#x27;joi2md&#x27;);\n\nconst Jm = new Joi2md();\n&#x2F;&#x2F; 设置schema\nJm.setSchema({\n    name: Joi.number().default(1).required().notes(&#x27;用户名&#x27;),\n})\n&#x2F;&#x2F; schema 转换为行数据\nJm.transferRows()\n&#x2F;&#x2F; 得到markdown字符串\nJm.setPrintHeaders([\n    [&#x27;path&#x27;, &#x27;参数名&#x27;],\n    [&#x27;type&#x27;, &#x27;类型&#x27;],\n    [&#x27;presence&#x27;, &#x27;必填&#x27;],\n    [&#x27;default&#x27;, &#x27;默认值&#x27;],\n    [&#x27;notes&#x27;, &#x27;说明&#x27;],\n  ]);\nconst result = Jm.printMd()\nconsole.log(result)\n</code></pre><p><strong>Result</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>类型</th>\n<th>必填</th>\n<th>默认值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>number</td>\n<td>true</td>\n<td><code>1</code></td>\n<td><code>用户名</code></td>\n</tr>\n</tbody>\n</table>\n</div>","title":"joi2md","last_reply_at":"2019-04-22T03:08:34.893Z","good":false,"top":false,"reply_count":9,"visit_count":1320,"create_at":"2019-04-17T02:00:06.140Z","author":{"loginname":"yujintang","avatar_url":"https://avatars3.githubusercontent.com/u/18202085?v=4&s=120"}},{"id":"5cbca71fa86ae80ce64b1a0a","author_id":"5b31b09b57137f22415c4f4a","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p><strong>该文章阅读需要5分钟,更多文章请点击本人博客<a href=\"https://www.halu886.cn\">halu886</a></strong></p>\n</blockquote>\n<ul>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\">函数式编程</a>\n<ul>\n<li><a href=\"#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\">高阶函数</a></li>\n<li><a href=\"#%E5%81%8F%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95\">偏函数用法</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E9%9A%BE%E7%82%B9\">异步编程的优势和难点</a>\n<ul>\n<li><a href=\"#%E4%BC%98%E5%8A%BF\">优势</a></li>\n<li><a href=\"#%E9%9A%BE%E7%82%B9\">难点</a>\n<ul>\n<li><a href=\"#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\">异常处理</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>之前总结了NodeJs中通过事件循环实现异步，包括各种基于线程池的异步I/O的API和与I/O无关的异步API。NodeJs的设计从里到外都散发着异步的气息。虽然异步为NodeJs带来了卓越的性能，但是异步编程带了部分的诋毁。</p>\n<p>同时之前我们也总结过异步开发在应用层流行不起来的原因。逻辑上，异步编程在流程控制上，业务表达并不适合自然语言的线形思维习惯。较少人能适应异步编程，除了GUI开发者,前端开发者习以为常处理各种DOM事件和浏览器中的事件。</p>\n<p>Javascript在浏览器中也属于事件驱动的执行过程，这使得前后端的Javascript在执行原理和风格上趋近一致，虽然执行在不同的环境，但是除了宿主环境不一样，并不能让人觉得这是一门新语言。</p>\n<p>V8和异步带来的性能提升，前后端Javascript编程分隔一致，是Node能迅速成功并流行起来的原因。</p>\n<h1>函数式编程</h1>\n<p>在开始异步编程之前，我们先来了解一下Javascript的回调函数和深层嵌套的来龙去脉，函数（function）作为Javascript的一等公民，自由度非常高，无论是作为调用还是参数，甚至返回值均可。这是因为Javascript在诞生时借鉴了Schema语言（lisp的派生）。</p>\n<h2>高阶函数</h2>\n<p>一般来说，函数只接受一般的基本的数据类型或者对象引用，返回值也是基本数据类型和对象引用。</p>\n<pre class=\"prettyprint language-js\"><code>function foo(x){\n    return x;\n}\n</code></pre><p>高阶函数则是可以将函数作为返回值，或者将函数作为参数的函数。</p>\n<pre class=\"prettyprint language-js\"><code>function foo(){\n    return function(){\n        return x;\n    }\n}\n</code></pre><p>高阶函数看起来变化虽小。像C/C++也能通过指针实现，但是形成了一种后续传递风格（Continue Passing Style）的结果接收方式，将函数的业务重心从返回值转移到了回调函数中。</p>\n<pre class=\"prettyprint language-js\"><code>function foo(x,bar){\n    return bar(x);\n}\n</code></pre><p>以上面的高阶函数作为例子，当bar参数不同时，则返回不同结果。例如数组的<code>sorting()</code>则是典型的高阶函数。</p>\n<pre class=\"prettyprint language-js\"><code>var points=[40,100,1,5,25,10];\npoints.sort(function(a,b){\n    return a - b;\n})\n&#x2F;&#x2F; [1,5,10,25,40,100]\n</code></pre><p>通过改动回调函数来决定业务这就是高阶函数的灵活性，同时结合Node的事件模块，事件处理方式正是基于高阶函数的特性来完成的，相同的事件注册不同的回调函数灵活的处理业务逻辑。</p>\n<pre class=\"prettyprint language-js\"><code>var emitter = new events.EventEmitter();\nemitter.on(&#x27;event_foo&#x27;,function(){\n    &#x2F;&#x2F; TODO\n})\n</code></pre><p>事件可以很容易的将复杂业务解耦，这都归功于高阶函数，高阶函数在Javascript中比比皆是。</p>\n<h2>偏函数用法</h2>\n<p>偏函数指的是创建一个调用一个-部分参数或变量已经预设的函数-的函数。</p>\n<p>例如：</p>\n<pre class=\"prettyprint language-js\"><code>var toString = Object.prototype.toString;\n\nvar isString = function(obj){\n    return toString.call(obj) == &#x27;[object String]&#x27;;\n}\nvar isFunction = function(obj){\n    return toString.call(obj)==&#x27;[object Function]&#x27;;\n}\n</code></pre><p>在Javascript中进行类型判断时，我们通常会用上述方法定义。虽然不是很复杂，只有两个函数的定义，但是存在一些重复的代码。一旦类型多起来，那么会出现更多的冗余代码。为了解决重复定义的问题，我们引入一个新函数如工厂一样批量创建类似的函数。</p>\n<pre class=\"prettyprint language-js\"><code>var isType = function(type){\n    return function(obj){\n        return toString.call(obj)==&#x27;[object &#x27; + type + &#x27;]&#x27;;\n    };\n}\n\nvar isString = isType(&#x27;String&#x27;);\nvar isFunction = isType(&#x27;Function&#x27;);\n</code></pre><p>可以看出，通过创建<code>isType()</code>函数后，后面创建类型校验的方法就简单多了。这种通过指定部分参数产生新的定制化的函数的形式就是偏函数。</p>\n<p>偏函数在异步编程中应用也十分广泛，著名类库Underscore提供的after()方法就是偏函数应用。</p>\n<pre class=\"prettyprint language-js\"><code>_.after = function(times,func){\n    if(times&lt;=0) return func();\n    return function(){\n        if (--times &lt; 1) {return func.apply(this,arguments);}\n    }\n}\n</code></pre><p>根据传入的times和具体方法，生成一个需要执行多次才会执行的偏函数。</p>\n<h1>异步编程的优势和难点</h1>\n<p>在单线程中，由于同步I/O耗时太久，导致I/O和CPU使用不能重叠。可是随着应用的复杂度和性能门槛提高，开发者过去通过使用多线程来提升性能，但是随之而来的上下文切换开销以及锁和同步等各种问题让开发者头痛不已。或者C/C++直接调用操作系统底层，手工实现异步I/O，但是开发和调试的门槛也随之提升。Node利用Javascript及内部异步库将异步提升应用层,这是种创新。</p>\n<h2>优势</h2>\n<p>Node的核心是基于事件驱动的非阻塞I/O模型，使得I/O和CPU并不相互依赖，让资源更好的利用。对于网络应用，并发带来的想象空间更大，延展开来的是分布式和云， 并行使得各个单点之间可以有效的连接组织起来。</p>\n<p><img src=\"http://resource.halu886.cn/images/async-code-1/1.png?x-oss-process=style/halu-blog-watermark\" alt=\"1\"></p>\n<p>传统同步模型中，分布式计算性能则会大打折扣。</p>\n<p><img src=\"http://resource.halu886.cn/images/async-code-1/2.png?x-oss-process=style/halu-blog-watermark\" alt=\"2\"></p>\n<p>Node的JavaScript线程则像是一个大管家，将任务分配给I/O线程和处理结果，I/O线程池中的I/O线程则是作为小二的角色。管家和小二则是互不相关的，这保证了整体的高效。</p>\n<p>这个模型的缺陷则是管家无法承担过多的细节性的工作。如果承担过多，则会影响任务的调度。管家将忙个不停，而小二则得不到活干。结果是整体效率的低下。</p>\n<p>Node是处理I/O密集型的模型，采用单线程，则使Node更像一个处理I/O密集型的能手，对于CPU密集型则看这个大管家的能耐了。</p>\n<h2>难点</h2>\n<p>Node让异步编程风靡服务器端，一方面借助异步I/O和V8引擎的高性能突破单线程性能瓶颈，另一方面统一了前后端Javascript编程模型。但是也存在很多难点。</p>\n<h3>异常处理</h3>\n<p>之前我们捕获异常通过类Java的try/catch/final语句块。</p>\n<pre class=\"prettyprint language-js\"><code>try{\n    JSON.parse(json);\n}catch(e){\n    &#x2F;&#x2F;TODO\n}\n</code></pre><p>但是异步I/O通常分为两步，提交请求和处理结果，两个阶段存在事件循环调度。异步方法通常在发起调用立即返回，异常不一定发生在调用的过程中，那么此时try/catch的功效在这里是不会发生任何作用。</p>\n<pre class=\"prettyprint language-js\"><code>var async = function(callback){\n    process.nextTick(callback);\n}\n</code></pre><p>调用async方法后，callback将会被存放起来，将会在下个事件循环Tick中被取出执行。尝试对异步方法进行try/catch只能捕获当此Tick循环中异常，回调中抛出的异常则无法捕获了。</p>\n<pre class=\"prettyprint language-js\"><code>try{\n    async(callback);\n}catch(e){\n    &#x2F;&#x2F;TODO\n}\n</code></pre><p>Node在处理异常时有一种约定俗成的习俗，将异常作为作为回调的第一个实参。如果为空，则表示没有异常。</p>\n<pre class=\"prettyprint language-js\"><code>async(function(err,results){\n    &#x2F;&#x2F;TODO;\n})\n</code></pre><p>如果是我们自行创建的异步方法，也需要遵循以下两点</p>\n<ol>\n<li>必须执行调用方传入的回调函数;</li>\n<li>正确传递异常供调用者判断;</li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>var async = function(callback){\n    process.nextTick(function(){\n        var results = something;\n        if(error){\n            return callback(error);\n        }\n        callback(null,result);\n    })\n}\n</code></pre><p>另一个容易犯的错误则是对用户传递的回调进行异常捕获。</p>\n<pre class=\"prettyprint language-js\"><code>try{\n    req.body = JSON.parse(buf,options.reviver);\n    callback();\n}catch(err){\n   err.body = buf;\n   err.status = 400;\n   callback(err);\n}\n</code></pre><p>上述代码的意图本是捕获<code>JSON.parse()</code>抛出的异常，但是也将<code>callback()</code>包含进去了，一旦回调函数出现异常，那么将会被catch，则又被执行一次，将会造成业务混乱。</p>\n<pre class=\"prettyprint language-js\"><code>try{\n    req.body = JSON.parse(buf,options.reviver);\n}catch(err){\n    err.body = buf;\n    err.status = 400;\n    return callback(err);\n}\ncallback();\n</code></pre><p>在编写异步方法，只需要将异常正常的传递给用户的回调即可，无需做过多的操作。</p>\n<blockquote>\n<p>以上知识点均来自&lt;&lt;深入浅出Node.js&gt;&gt;，更多细节建议阅读书籍:-)</p>\n</blockquote>\n</div>","title":"异步编程总结-1","last_reply_at":"2019-04-21T17:23:43.948Z","good":false,"top":false,"reply_count":0,"visit_count":505,"create_at":"2019-04-21T17:23:43.948Z","author":{"loginname":"halu886","avatar_url":"https://avatars1.githubusercontent.com/u/22374024?v=4&s=120"}},{"id":"5cbb6898a86ae80ce64b1796","author_id":"5cbb652337faec0ce1d04175","tab":"share","content":"<div class=\"markdown-text\"><p>Javascript是一种很棒的语言。 我们可以用很多不同的方式做事。</p>\n<p><strong>parseInt()</strong></p>\n<pre class=\"prettyprint\"><code>console.log(parseInt(&#x27;123&#x27;)); &#x2F;&#x2F; 产量: 123\nconsole.log(parseInt(&#x27;123.45&#x27;)); &#x2F;&#x2F; 产量: 123\n</code></pre><p><strong>parseFloat()</strong></p>\n<pre class=\"prettyprint\"><code>console.log(parseFloat(&#x27;123&#x27;)); &#x2F;&#x2F; 产量: 123\nconsole.log(parseFloat(&#x27;123.45&#x27;)); &#x2F;&#x2F; 产量: 123.45\n</code></pre><p><strong>Number()</strong></p>\n<pre class=\"prettyprint\"><code>console.log(Number(&#x27;123&#x27;)); &#x2F;&#x2F; 产量: 123\nconsole.log(Number(&#x27;123.45&#x27;)); &#x2F;&#x2F; 产量: 123.45\n</code></pre><p><strong>用数字乘以字符串</strong></p>\n<pre class=\"prettyprint\"><code>console.log(&#x27;123&#x27; * 1); &#x2F;&#x2F; 产量: 123\nconsole.log(&#x27;123.45&#x27; * 1); &#x2F;&#x2F; 产量: 123.45\n</code></pre><p>一元加法</p>\n<pre class=\"prettyprint\"><code>console.log(+&#x27;123&#x27;); &#x2F;&#x2F; 产量: 123\nconsole.log(+&#x27;123.45&#x27;); &#x2F;&#x2F; 产量: 123.45\n</code></pre><p>原版的：<a href=\"https://embarkcode.com/javascript-convert-string-to-number/\">JavaScript Convert String to Number</a></p>\n</div>","title":"JavaScript将字符串转换为数字","last_reply_at":"2019-04-21T02:27:19.265Z","good":false,"top":false,"reply_count":2,"visit_count":988,"create_at":"2019-04-20T18:44:40.462Z","author":{"loginname":"AbuzerAsif","avatar_url":"https://avatars3.githubusercontent.com/u/11502830?v=4&s=120"}},{"id":"5cb97a10a86ae80ce64b1224","author_id":"58de5214b3e60b982d089dc3","tab":"ask","content":"<div class=\"markdown-text\"><p>问题简述: 今天凌晨0点3台应用机器cpu爆炸, 持续了几个小时(之后也不是应用自己恢复正常的). 猜想是不是跟日志有关? 前一天清空了应用日志目录.\n<img src=\"//static.cnodejs.org/FtR6gTu3y8vBmEoSHIpdMIcGw1lF\" alt=\"image.png\">\n机器配置: 4cpu x 3台k8s节点机器.\n应用规模: 3台机器跑了大约50个egg k8s pod, 每个应用跑2个pod.\n日志写入: 如果一个应用的2个pod落在同一个机器上, 会写相同的日志文件. (单个pod实例里4个egg worker是不是也存在这样的情况?)\n启动方式: pod里面用egg-scripts start --daemon运行起来的.</p>\n<p>初步排查结果, cpu暴涨的node进程都是egg worker:\n<img src=\"//static.cnodejs.org/FpNRu51LHuQW8ZqmUyYo4dJMzJ4k\" alt=\"image.png\"></p>\n<pre class=\"prettyprint\"><code>1111 ?        Rl     0:13 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:35401}\n1566 ?        Rl     0:06 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:39980}\n1610 ?        Rl     0:10 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:42591}\n1667 ?        Sl     0:07 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:46809}\n2222 ?        Rl     0:06 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;agent_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:35401}\n2349 ?        Rl     0:04 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:46809}\n2529 ?        Rl     0:04 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;agent_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:42591}\n9716 ?        Rl     3:28 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:39980}\n18599 ?        Rl     5:36 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;agent_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:43367}\n18768 ?        Rl     5:31 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:43367}\n18781 ?        Rl     5:37 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:43367}\n18783 ?        Rl     7:42 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;agent_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:37730}\n18871 ?        Rl     7:04 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:37730}\n18873 ?        Rl     7:11 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:37730}\n18878 ?        Rl     7:08 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:37730}\n18888 ?        Rl     6:58 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:37730}\n19292 ?        Rl     6:04 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;agent_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:42728}\n19324 ?        Rl     5:05 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:42728}\n19325 ?        Rl     5:06 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:42728}\n19331 ?        Rl     5:04 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:42728}\n19344 ?        Rl     5:01 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:42728}\n20639 ?        Rl     4:58 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:39980}\n21635 ?        Rl     2:50 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:39980}\n26413 ?        Rl     5:29 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;agent_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:39980}\n31557 ?        Rl     6:56 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;agent_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:45792}\n31580 ?        Rl     6:27 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:45792}\n31582 ?        Rl     6:24 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:45792}\n31584 ?        Rl     6:22 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:45792}\n31596 ?        Rl     6:29 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:45792}\n32705 ?        Rl     0:18 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:35401}\n</code></pre></div>","title":"egg 应用机器凌晨0点 cpu 飙升到100%","last_reply_at":"2019-04-20T22:11:51.913Z","good":false,"top":false,"reply_count":9,"visit_count":1376,"create_at":"2019-04-19T07:34:40.024Z","author":{"loginname":"xiaozhongliu","avatar_url":"https://avatars3.githubusercontent.com/u/17674404?v=4&s=120"}},{"id":"5cb336e0dad66d658e408cb1","author_id":"58183a621a9a7d9909531351","tab":"share","content":"<div class=\"markdown-text\"><h3>项目概览</h3>\n<ul>\n<li>JS 插件文档库地址：<a href=\"https://www.yuque.com/pengloo53/web\">JS 插件文档库 · 语雀</a></li>\n<li>在线演示代码仓库：<a href=\"https://github.com/pengloo53/js-plugin-example\">JS 插件文档库示例代码 · GitHub</a></li>\n<li>在线预览：<a href=\"http://js.90byte.com/page\">JS 插件在线演示</a></li>\n</ul>\n<h3>项目介绍</h3>\n<p>如今，随着大前端的发展，曾经的霸主：jQuery 也渐渐的陨落，随之一起没落的，也包含基于 jQuery 的一些优秀的插件。这些优秀的插件，让我们在前端的开发中，节省了大量的时间。自己的项目中也使用了大部分基于 jQuery 的前端插件，帮助我实现了很多的功能，节省了大量的开发时间。</p>\n<p>所以，我计划发起一个开源项目，整理并收集这些优秀的前端插件的使用方法，并提供示例代码，可供调试和学习。一来为了留个存档，二来也是为了分享出去，帮助到需要的人。</p>\n<blockquote>\n<p>该文档起于 jQuery 框架，但不止于 jQuery，希望能整理所有的 Web 前端框架。</p>\n</blockquote>\n<p>期待你的加入，一起维护文档，语雀文档协作<a href=\"https://www.yuque.com/g/pengloo53/web/collaborator/join?token=rMudjrT0PjYZv8BR\">邀请链接</a>，如果链接过期，请加个人微信号：<strong>P_lu0503</strong>，并备注：<strong>文档协作</strong>。</p>\n<p>为了文档的可用性，我希望每一个插件都有一篇独立文档，以及独立在线演示。</p>\n<h3>文档介绍</h3>\n<p>文档在语雀平台上，期待你的加入进行协作编写，不要求所有的配置项都介绍到，列举一些最常见的即可。文档主要包括以下几个方面的描述：</p>\n<ul>\n<li>简单介绍：插件的用途，使用场景，以及官方文档链接；</li>\n<li>开始使用：如何正确的引入库文件到页面中，这一点对于初学者很重要；</li>\n<li>使用示例（需要代码演示）：\n<ul>\n<li>前台 HTML 如何编写</li>\n<li>前台 JS 如何调用</li>\n<li>后台数据返回的格式（不限后台技术，重点关注返回数据的格式）</li>\n</ul>\n</li>\n</ul>\n<h3>在线演示</h3>\n<p>每一个插件都有一个独立的页面可供访问，在线演示原代码在 <a href=\"https://github.com/pengloo53/js-plugin-example\">GitHub</a> 上，采用 Node 语言编写，可以自行部署在本地，便于调试，尝试插件不同参数的用法。</p>\n<p>熟悉 Node + Express 框架的可以直接 fork 项目，并提交 pull requests，如果不熟悉 Node 开发，也没关系，我会定期将文档中新增的插件，做成演示示例，push 到 GitHub 仓库。</p>\n<p>另外，也提供了<a href=\"http://js.90byte.com/page\">在线预览</a>。</p>\n<h3>本地部署步骤</h3>\n<ol>\n<li>安装 Node 环境</li>\n<li>安装 supervisor，安装方法：<code>npm i -g supervisor</code></li>\n<li>安装 bower 包管理器，安装方法：<code>npm i -g bower</code></li>\n<li>克隆代码到本地，顺便点个 Star</li>\n<li>进入项目目录，安装依赖，<code>npm install</code> 以及 <code>bower install</code></li>\n<li>运行项目，<code>npm start</code></li>\n<li>浏览器打开项目：<code>http://localhost:3030/page</code></li>\n</ol>\n</div>","title":"JS 插件文档库邀你一起协同创作","last_reply_at":"2019-04-20T14:43:07.091Z","good":false,"top":false,"reply_count":2,"visit_count":1099,"create_at":"2019-04-14T13:34:24.759Z","author":{"loginname":"pengloo53","avatar_url":"https://avatars3.githubusercontent.com/u/5508125?v=4&s=120"}},{"id":"5b972808ce9d14c2254df8b0","author_id":"56ea011fa70420bd420d0001","tab":"share","content":"<div class=\"markdown-text\"><p>楼主自己也是才踩 react 的路。。之前偷懒用了 vuejs 就不思上进了…无赖美帝都是 react 占据了90个点的江山.*\n**一直觉得学习，选择好的学习资料和学习的顺序很重要… 对了，路子顺…挫折感小. ** 希望自己的学习顺序，能给别人带来帮助.\n群主弄了个 QQ 技术交流群: 371932256 ，方便讨论我的 cnodejs 的 react 版本的项目…一起进步…也欢迎高手加入…哈哈…</p>\n<ol>\n<li>\n<p>掌握 react 的基本概念\n1.1 看视频课程：<a href=\"https://time.geekbang.org/course/intro/100\">https://time.geekbang.org/course/intro/100</a> （非推广…只是个人是个很热心的妹砸） 01 ~10\n1.2 边看然后边刷官方的 Main Concepts 部分的文档https://reactjs.org/docs/hello-world.html 做好第一步和第二步后，对 react 有基本的概念了…</p>\n</li>\n<li>\n<p>学习 redux/react-redux\n2.1 看ruanyifeng 的 redux/react-redux 教程… 看教程第一二篇的时候，会有个基本的概念呢…\n2.2  然后返回去看 11~ 15， 视频讲解的 redux、react 课程\n当然你在刷课课程中，也会不时的去看看官方文档看看些细节. flux 等概念\n2.3  在上述步骤（3.1 ~3.2 ） 中，你会做 Counter 的例子，了解 redux 的基本玩法… 也会把 Counter的例子改成结合 react-redux 类型的;\n如果这两个例子完成了…可以试试这个视频教程…\n2.4 完成一个小demo: <a href=\"https://www.youtube.com/watch?v=93p3LxR9xfM&amp;t=1168s\">https://www.youtube.com/watch?v=93p3LxR9xfM&amp;t=1168s</a> 这部分想必，对新手会绕一段时间…特别是 redux 这部分如果你没进去看过源码…有时候会被 API 绕晕…觉得 API 多\n这边是楼主写的 redux 阅读笔记: <a href=\"https://github.com/pandoracat/learn-react/blob/master/Notes/Redux/includes/markdown/ReduxSourceCode.md\">https://github.com/pandoracat/learn-react/blob/master/Notes/Redux/includes/markdown/ReduxSourceCode.md</a></p>\n</li>\n<li>\n<p>完成学习 react基本概念… redux/react-redux 基本用法后…（一定要试着敲每个课程的代码哟，扎扎实实走过来的，你内心才踏实)\n可以直接去 react-router 官网看看 demo, 边用用demo, 了解文档，了解用法. 如果有朋友觉得英文文档看起来吃力，可以看看这个 <a href=\"https://www.jianshu.com/p/1781bc1dd938#24-history\">https://www.jianshu.com/p/1781bc1dd938#24-history</a></p>\n</li>\n<li>\n<p>学习完这些后，咱看看 react 项目，代码咋拆分…咋组织\n课程22~25 ： <a href=\"https://time.geekbang.org/course/detail/100-11278\">https://time.geekbang.org/course/detail/100-11278</a></p>\n</li>\n<li>\n<p>这些都过了,下面看 react 怎么测试。关于 react 测试： 强行硬广一波自己的笔记：<a href=\"https://github.com/pandoracat/frontend-testing\">https://github.com/pandoracat/frontend-testing</a> ，我记录了自己的 javascript 测试的学习路程…</p>\n</li>\n<li>\n<p>上面这些你都做了…咱们再把视频教程撸撸… 再次提升下自己的理解…</p>\n</li>\n<li>\n<p>最后，react cnode , 新手练手都用它 😎…看看 它的 api, 咱们 ready go 写个项目试试.\n这边是我正在写的 <a href=\"https://github.com/pandoracat/react-cnode\">https://github.com/pandoracat/react-cnode</a> 欢迎瞧瞧…我会写自己的 readme, 方便你照着模仿一个…\n弱弱的觉得自己设计的风格还不错（偷笑,我是一个审美超级弱的前端妹纸）\n怎么开始这个用 <a href=\"http://cnodejs.org\">cnodejs.org</a> 做 api 服务器的练手项目呢?请点击：<a href=\"https://github.com/pandoracat/react-cnode\">https://github.com/pandoracat/react-cnode</a></p>\n</li>\n</ol>\n<p>群主弄了个 QQ 技术交流群: 371932256 ，方便讨论我的 cnodejs 的 react 版本的项目…一起进步…也欢迎高手加入…哈哈…</p>\n</div>","title":"分享自己的 react 学习路径","last_reply_at":"2019-04-20T13:52:47.113Z","good":false,"top":false,"reply_count":34,"visit_count":4728,"create_at":"2018-09-11T02:27:20.076Z","author":{"loginname":"alicePan","avatar_url":"https://avatars2.githubusercontent.com/u/9105986?v=4&s=120"}},{"id":"5c38830c3898674067a7e3a4","author_id":"56309c1c10b7dd644461fc35","tab":"share","content":"<div class=\"markdown-text\"><p>能用的API都用上了，可以发帖、回复、收藏和点赞。Android平台建议使用Chrome浏览，iOS平台建议使用Safari浏览，点击“添加到主屏幕”可以安装独立的应用。</p>\n<p>技术栈为vue + vuetify + vue-router + vuex，由于使用了UI框架，开发起来难度不高，代码写的不好的地方欢迎批评或提交PR。</p>\n<p>地址：<a href=\"https://cnode.ikholin.com\">https://cnode.ikholin.com</a></p>\n<p>源码：<a href=\"https://github.com/oodzchen/CNode-V\">https://github.com/oodzchen/CNode-V</a></p>\n<p>来自 <a href=\"https://github.com/oodzchen/CNode-V\">CNode-V</a></p>\n</div>","title":"我也给CNode社区做了个PWA","last_reply_at":"2019-04-20T02:23:02.301Z","good":true,"top":false,"reply_count":38,"visit_count":4573,"create_at":"2019-01-11T11:50:36.917Z","author":{"loginname":"oodzchen","avatar_url":"https://avatars1.githubusercontent.com/u/9650699?v=4&s=120"}},{"id":"5c18d6837ec239239ff582b8","author_id":"5c179fa17ec239239ff57b8f","tab":"ask","content":"<div class=\"markdown-text\"><p>请大神们推荐几本教材啊</p>\n</div>","title":"想学node.js, 有什么教材推荐吗","last_reply_at":"2019-04-19T14:49:08.730Z","good":false,"top":false,"reply_count":22,"visit_count":2532,"create_at":"2018-12-18T11:14:11.553Z","author":{"loginname":"sxuni","avatar_url":"https://avatars2.githubusercontent.com/u/16433603?v=4&s=120"}},{"id":"54178b5c6151dc272f66e044","author_id":"52131c790a746c580b4d04d9","tab":"share","content":"<div class=\"markdown-text\"><p>项目地址：<a href=\"https://github.com/Khan/KaTeX\">KaTeX</a></p>\n<p>支持主流的浏览器：Chrome, Firefox, Safari, Opera和 IE8-IE11。</p>\n<ul>\n<li>**快速：**并发渲染，无需重排页面。根据<a href=\"http://jsperf.com/katex-vs-mathjax\">这个测试</a>，性能绝对秒杀<a href=\"http://www.mathjax.org/\">MathJax</a>；\n+**渲染效果好：**采用TeX语法，渲染效果达到印刷出版级别；\n+**无依赖：**不依赖其它库；\n+**支持服务器端渲染：**例如，服务器端的Node.js程序调用KaTeX，把渲染好的HTML片段直接发送给客户端。</li>\n</ul>\n<p>看起来不错，值得试用。</p>\n</div>","title":"KaTeX： 可汗学院出品，号称“最快”的数学公式渲染库","last_reply_at":"2019-04-19T09:34:33.940Z","good":false,"top":false,"reply_count":16,"visit_count":12555,"create_at":"2014-09-16T00:59:08.936Z","author":{"loginname":"bnuhero","avatar_url":"//gravatar.com/avatar/cefc4edf683bb205aa6291358e747ebb?size=48"}},{"id":"5cb992d7a86ae80ce64b12fa","author_id":"5c1af36a3898674067a7632a","tab":"share","content":"<div class=\"markdown-text\"><p>事件触发机制实现<img src=\"//static.cnodejs.org/FtMRn7Ru0NM8Zr4SlHA0HL7PbMCj\" alt=\"cb.png\">\npromise方式实现<img src=\"//static.cnodejs.org/Fi63cTqkPnHMhwvTNRlc_-TnObD9\" alt=\"promise.png\"></p>\n</div>","title":"键盘数据录入+不换行控制台输出","last_reply_at":"2019-04-19T09:20:23.508Z","good":false,"top":false,"reply_count":0,"visit_count":552,"create_at":"2019-04-19T09:20:23.508Z","author":{"loginname":"jiangyan33","avatar_url":"https://avatars3.githubusercontent.com/u/35300813?v=4&s=120"}},{"id":"5cb857b3a86ae80ce64b0cc2","author_id":"595d976b10d696af07768a24","tab":"share","content":"<div class=\"markdown-text\"><h1>sequelize 查找空字符串报错</h1>\n<blockquote>\n<p>需求：找出为&quot;&quot;或者为null的行数</p>\n</blockquote>\n<h2>错误版本</h2>\n<pre class=\"prettyprint language-js\"><code>const count = await Model.count({\n      where: {\n        $or: [\n          { value: null },\n          { value: &#x27;&#x27; },\n        ],\n      },\n    });\n</code></pre><pre class=\"prettyprint\"><code>sql: SELECT count(*) AS &#96;count&#96; FROM &#96;setting&#96; AS &#96;setting&#96; WHERE ((&#96;setting&#96;.&#96;deleted_at&#96; &gt; &#x27;2019-04-16 10:02:39&#x27; OR &#96;setting&#96;.&#96;deleted_at&#96; IS NULL) AND (&#96;setting&#96;.&#96;required&#96; = true AND (&#96;setting&#96;.&#96;value&#96; IS NULL OR &#96;setting&#96;.&#96;value&#96; = &#x27;\\&quot;\\&quot;&#x27;)));\n</code></pre><ul>\n<li>原因：<a href=\"http://www.voidcn.com/article/p-hoohudwl-re.html\">nodejs sequelize库防注入测试</a>，Model.count把’‘转义了’&quot;&quot;’</li>\n</ul>\n<h2>正确版本</h2>\n<pre class=\"prettyprint language-js\"><code>const count = await this.app.model.Setting.count({\n      where: {\n        $or: [\n          { value: null },\n          literal(&#x27;value = &quot;&quot;&#x27;),\n        ],\n      },\n    });\n</code></pre></div>","title":"sequelize 查找空字符串报错","last_reply_at":"2019-04-19T06:44:01.226Z","good":false,"top":false,"reply_count":1,"visit_count":555,"create_at":"2019-04-18T10:55:47.583Z","author":{"loginname":"18820227745","avatar_url":"https://avatars0.githubusercontent.com/u/25097125?v=4&s=120"}},{"id":"5ca3157831010b2dfbb424bf","author_id":"5c47dd816955112b99437e7f","tab":"ask","content":"<div class=\"markdown-text\"><p>node集群起了服务，每个服务上重复订阅了redis的过期通知，然后当redis的发布过期通知时，会向每个服务发送过期通知吗？如何解决服务重复消费redis的过期通知？</p>\n</div>","title":"node集群下重复消费redis的过期通知","last_reply_at":"2019-04-19T06:26:50.458Z","good":false,"top":false,"reply_count":2,"visit_count":775,"create_at":"2019-04-02T07:55:36.744Z","author":{"loginname":"jiazhuoyi","avatar_url":"https://avatars1.githubusercontent.com/u/17874998?v=4&s=120"}},{"id":"5b1939ad29e6e510415b2916","author_id":"5ad9731bba60fcc66b7b86aa","tab":"share","content":"<div class=\"markdown-text\"><p>最近利用空闲时间写了一个从入门到上线的的node实战教程《Node.js从入门到上线》A blog build with Koa2. 目前还在更新中，入门篇已基本成型。</p>\n<p>本项目使用es6语法，采用Koa2 + mongoose 搭建了一个博客系统，实现了文章管理、用户登录注册、权限控制、分类管理等功能。</p>\n<p>GitHub: <a href=\"https://github.com/liuxing/node-blog\">https://github.com/liuxing/node-blog</a></p>\n<h2>目录</h2>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.1Node.js%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.md\">1.1  Node.js 的安装与配置</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.1Node.js%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.md#%E5%AE%89%E8%A3%85nodejs\">安装Node.js</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.1Node.js%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.md#%E4%BD%BF%E7%94%A8-nvm\">使用nvm</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.1Node.js%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.md#%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7\">一些有用的工具</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.1Node.js%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.md#hello-node\">hello-node</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.2Node.js%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88.md\">1.2 Node.js 基础概览</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.2Node.js%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88.md#node%E6%A8%A1%E5%9D%97\">node模块</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.2Node.js%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88.md#npm%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E5%99%A8\">npm包管理器</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/2.1Koa2%E5%88%9D%E4%BD%93%E9%AA%8C.md\">2.1 Koa2初体验</a></p>\n<ul>\n<li>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/2.1Koa2%E5%88%9D%E4%BD%93%E9%AA%8C.md#hello-koa2\">Hello Koa2</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/2.1Koa2%E5%88%9D%E4%BD%93%E9%AA%8C.md#%E4%BD%BF%E7%94%A8supervisor-%E6%88%96%E8%80%85-nodemon\">使用supervisor 或者 nodemon</a></p>\n</li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/2.2MongoDB%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8.md\">2.2 MongoDB的安装及使用</a></p>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.1%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE.md\">3.1 开发前的项目配置</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.1%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE.md#%E8%A7%84%E5%88%92%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\">规划项目目录结构</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.1%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE.md#%E4%BD%BF%E7%94%A8editorconfig\">使用editorconfig</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.1%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE.md#%E4%BD%BF%E7%94%A8commitizen\">使用commitizen</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.1%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE.md#%E4%BD%BF%E7%94%A8eslint\">使用eslint</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.1%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE.md#%E4%BD%BF%E7%94%A8git-hooks%E8%87%AA%E5%8A%A8%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81\">使用Git hooks自动检查代码</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.2%E6%8A%8A%E9%A1%B9%E7%9B%AE%E8%B7%91%E8%B5%B7%E6%9D%A5.md\">3.2 把项目跑起来</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.2%E6%8A%8A%E9%A1%B9%E7%9B%AE%E8%B7%91%E8%B5%B7%E6%9D%A5.md#router\">router</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.2%E6%8A%8A%E9%A1%B9%E7%9B%AE%E8%B7%91%E8%B5%B7%E6%9D%A5.md#%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E\">配置模板引擎</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.2%E6%8A%8A%E9%A1%B9%E7%9B%AE%E8%B7%91%E8%B5%B7%E6%9D%A5.md#%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90\">配置静态资源</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.3%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93.md\">3.3 使用mongoose操作数据库</a></p>\n<ul>\n<li>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.3%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93.md#%E8%AE%BE%E8%AE%A1schema\">设计Schema</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.3%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93.md#%E4%BD%BF%E7%94%A8model\">使用model</a></p>\n</li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.4%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%99%BB%E5%BD%95.md\">3.4用户注册与登录</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.4%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%99%BB%E5%BD%95.md#cookie%E4%B8%8Esession\">cookie与session</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.4%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%99%BB%E5%BD%95.md#%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C\">用户注册</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.4%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%99%BB%E5%BD%95.md#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95\">用户登录</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.4%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%99%BB%E5%BD%95.md#%E7%94%A8%E6%88%B7%E7%99%BB%E5%87%BA\">用户登出</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.5koa2%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BC%80%E5%8F%91.md\">3.5 koa2中间件开发</a></p>\n<ul>\n<li>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.5koa2%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BC%80%E5%8F%91.md#koa2-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6\">koa2 中间件机制</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.5koa2%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BC%80%E5%8F%91.md#%E6%B6%88%E6%81%AF%E9%97%AA%E7%8E%B0%E4%B8%AD%E9%97%B4%E4%BB%B6\">消息闪现中间件</a></p>\n</li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.6%E6%96%87%E7%AB%A0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5.md\">3.6 文章增删改查</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.6%E6%96%87%E7%AB%A0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5.md#%E6%96%87%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1\">文章模型设计</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.6%E6%96%87%E7%AB%A0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5.md#%E6%96%87%E7%AB%A0%E5%8F%91%E8%A1%A8\">文章发表</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.6%E6%96%87%E7%AB%A0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5.md#%E6%96%87%E7%AB%A0%E5%88%97%E8%A1%A8%E4%B8%8E%E8%AF%A6%E6%83%85\">文章列表与详情</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.6%E6%96%87%E7%AB%A0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5.md#%E6%96%87%E7%AB%A0%E7%BC%96%E8%BE%91%E4%B8%8E%E5%88%A0%E9%99%A4\">文章编辑与删除</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.7%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.md\">3.7 用户权限控制</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.7%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.md#%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5\">登录状态检查</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.7%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.md#%E7%AE%A1%E7%90%86%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6\">管理权限控制</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.8%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD.md\">3.8 评论功能</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.8%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD.md#%E8%AE%BE%E8%AE%A1%E8%AF%84%E8%AE%BA%E7%9A%84%E6%A8%A1%E5%9E%8B\">设计评论的模型</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.8%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD.md#%E5%8F%91%E5%B8%83%E7%95%99%E8%A8%80\">发布留言</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.8%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD.md#%E5%8F%91%E5%B8%83%E7%95%99%E8%A8%80\">显示留言</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.8%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD.md#%E5%88%A0%E9%99%A4%E7%95%99%E8%A8%80\">删除留言</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.9%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.md\">3.9 一些安全问题</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.9%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.md#xss%E7%9A%84%E9%98%B2%E8%8C%83\">XSS的防范</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.9%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.md#csrf-%E7%9A%84%E9%98%B2%E8%8C%83\">CSRF的防范</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.10%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB.md\">3.10 分类管理</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.10%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB.md#%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1\">分类模型</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.10%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB.md#%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86%E4%B8%BB%E9%A1%B5\">分类管理主页</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.10%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB.md#%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB\">新增与删除</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.11%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD.md\">3.11 分页功能</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.11%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD.md#mongodb-%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E5%8E%9F%E7%90%86\">MongoDB分页原理</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.11%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD.md#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%88%86%E9%A1%B5%E5%99%A8\">实现一个基本的分页器</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.11%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD.md#%E9%AB%98%E7%BA%A7%E4%B8%80%E7%82%B9%E5%84%BF%E7%9A%84%E5%88%86%E9%A1%B5%E5%99%A8\">高级一点儿的分页器</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.12koa2%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%8F%8A404.md\">3.12 koa2错误处理及404</a></p>\n<p>[3.13 单元测试 更新中]</p>\n<p>关于测试：大家喜欢什么框架 mocha or jest？\n…</p>\n<p>持续更新中，未来将逐步发布【上线篇】：域名服务器选购、服务器配置、Nginx等等。实现线上部署</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/12/1621826e0dd7f41a?w=642&amp;h=382&amp;f=webp&amp;s=12738\" alt></p>\n<p>左手代码右手砖抛砖引玉</p>\n</div>","title":"《Node.js从入门到上线》入门篇 （持续更新中）","last_reply_at":"2019-04-19T04:08:07.705Z","good":false,"top":false,"reply_count":52,"visit_count":14037,"create_at":"2018-06-07T13:57:01.654Z","author":{"loginname":"liuxing","avatar_url":"https://avatars0.githubusercontent.com/u/17724186?v=4&s=120"}},{"id":"5cb7f44d37faec0ce1d0334e","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h2>故事是这样开始的</h2>\n<p>前端开发小哥Bingo接到了产品小姐姐的需求，要上线多个小程序.</p>\n<h2>码畜小哥开始架构</h2>\n<ul>\n<li>小程序杂，放一个项目方便管理</li>\n<li>小程序多，代码要能够复用</li>\n<li>团队开发，代码风格要统一</li>\n</ul>\n<h2>码畜小哥开始建项目</h2>\n<p>这是单个小程序的基本目录结构，没问题</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c87df50428?w=231&amp;h=222&amp;f=jpeg&amp;s=16850\" alt=\"图片描述\"></p>\n<p>当一个项目有多个小程序的时候，好像也没问题</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c87e3ecf17?w=206&amp;h=442&amp;f=jpeg&amp;s=26578\" alt=\"图片描述\"></p>\n<p>当多个小程序都用到同一个组件 com3 时，小哥发现代码没法复用，需要复制黏贴</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c87dea03e6?w=191&amp;h=353&amp;f=jpeg&amp;s=23022\" alt=\"图片描述\"></p>\n<p>思考了一下，那么把组件目录移到外面，这样不就可以复用了吗？</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c87e9df3be?w=195&amp;h=311&amp;f=jpeg&amp;s=21113\" alt=\"图片描述\"></p>\n<p>感觉很好，小哥这时在微信开发者工具打开 demo1，发现报错了</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c88766f2fd?w=665&amp;h=403&amp;f=jpeg&amp;s=64446\" alt=\"图片描述\"></p>\n<p>原来小程序是以当前项目作为根目录，components 目录已经不在 demo1 目录范围内，所以是引用不到的</p>\n<h2>小哥想到了 Webpack</h2>\n<h3>1. 整理目录</h3>\n<ul>\n<li>apps/：存放全部小程序</li>\n<li>build/：存放构建脚本</li>\n<li>common/：存放公共方法</li>\n<li>components/：存放公共组件</li>\n<li>styles/：存放公共样式</li>\n<li>templates/：存放公共模板</li>\n</ul>\n<p>大概长这样</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c887193e91?w=215&amp;h=316&amp;f=jpeg&amp;s=22665\" alt=\"图片描述\"></p>\n<h3>2. 编写构建脚本</h3>\n<p>package.json</p>\n<pre class=\"prettyprint language-javascript\"><code>script: {\n  &quot;dev&quot;: &quot;webpack --config build&#x2F;webpack.config.js&quot;\n}\n</code></pre><p>build/webpack.config.js</p>\n<blockquote>\n<p>思路就是利用 CopyWebpackPlugin 同步指定的文件到小程序目录下</p>\n</blockquote>\n<pre class=\"prettyprint language-javascript\"><code>const CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;)\nconst utils = require(&#x27;.&#x2F;utils&#x27;)\n\n&#x2F;&#x2F; 获取 apps 目录下的小程序并指定公共文件目录命名\nfunction copyToApps(dir) {\n  let r = []\n\n  utils\n    .exec(&#96;cd ${utils.resolve(&#x27;apps&#x27;)} &amp;&amp; ls&#96;)\n    .split(&#x27;\\n&#x27;)\n    .map(app =&gt; {\n      r.push({\n        from: utils.resolve(dir),\n        to: utils.resolve(&#96;apps&#x2F;${app}&#x2F;_${dir}&#96;)\n      })\n    })\n\n  return r\n}\n\nmodule.exports = {\n  watch: true,\n\n  &#x2F;&#x2F; 监听入口文件，保存便会刷新\n  entry: utils.resolve(&#x27;index.js&#x27;),\n\n  output: {\n    path: utils.resolve(&#x27;.tmp&#x27;),\n    filename: &#x27;bundle.js&#x27;\n  },\n\n  plugins: [\n    &#x2F;&#x2F; 同步指定的公共文件到所有小程序目录下\n    new CopyWebpackPlugin([\n      ...copyToApps(&#x27;styles&#x27;),\n      ...copyToApps(&#x27;common&#x27;),\n      ...copyToApps(&#x27;templates&#x27;),\n      ...copyToApps(&#x27;components&#x27;)\n    ])\n  ]\n}\n</code></pre><h3>3. 启动本地开发</h3>\n<pre class=\"prettyprint language-javascript\"><code>npm run dev\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c8b5931c1e?w=602&amp;h=456&amp;f=jpeg&amp;s=96585\" alt=\"图片描述\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c8ea94bcae?w=244&amp;h=467&amp;f=jpeg&amp;s=29761\" alt=\"图片描述\"></p>\n<p>现在公用的代码已经自动同步到小程序目录下，以下划线开头，当改动公共代码也会自动同步给小程序调用</p>\n<p>调用方式长这样</p>\n<pre class=\"prettyprint language-javascript\"><code>import utils from &#x27;.&#x2F;_common&#x2F;utils&#x27;\nimport com3 from &#x27;.&#x2F;_components&#x2F;com3&#x27;\n</code></pre><pre class=\"prettyprint language-css\"><code>@import &#x27;.&#x2F;_styles&#x2F;index.wxss&#x27;;\n</code></pre><pre class=\"prettyprint language-html\"><code>&lt;import src=&quot;.&#x2F;_templates&#x2F;index.wxml&quot; &#x2F;&gt;\n</code></pre><h2>代码风格校验</h2>\n<p>package.json</p>\n<pre class=\"prettyprint language-javascript\"><code>script: {\n  &quot;lint&quot;: &quot;eslint apps&#x2F;&quot;\n}\n</code></pre><p>.eslintrc.js</p>\n<pre class=\"prettyprint language-javascript\"><code>module.exports = {\n  extends: &#x27;standard&#x27;,\n\n  &#x2F;&#x2F; 将小程序特有的全局变量排除下\n  globals: {\n    Page: true,\n    Component: true,\n    App: true,\n    getApp: true,\n    wx: true\n  },\n\n  rules: {\n    &#x27;space-before-function-paren&#x27;: [&#x27;error&#x27;, &#x27;never&#x27;],\n    &#x27;no-unused-vars&#x27;: [\n      &#x27;error&#x27;,\n      {\n        &#x2F;&#x2F; 小程序还没支持 ES7，这个是用来兼容 async&#x2F;await\n        varsIgnorePattern: &#x27;regeneratorRuntime&#x27;\n      }\n    ]\n  }\n}\n</code></pre><p>然后借助 <a href=\"https://github.com/typicode/husky\">husky</a> 在每次 git commit 前执行校验</p>\n<pre class=\"prettyprint language-javascript\"><code>script: {\n  &quot;precommit&quot;: &quot;npm run lint&quot;\n},\n\ndevDependencies: {\n  &quot;husky&quot;: &quot;^0.14.3&quot;\n}\n\n</code></pre><h2>清理</h2>\n<p>最后小哥还加了个清理命令，便于重新生成公共代码</p>\n<p>package.json</p>\n<pre class=\"prettyprint language-javascript\"><code>script: {\n  &quot;clean&quot;: &quot;node build&#x2F;clean.js&quot;\n}\n\n</code></pre><p>build/clean.js</p>\n<pre class=\"prettyprint language-javascript\"><code>const rimraf = require(&#x27;rimraf&#x27;)\nconst utils = require(&#x27;.&#x2F;utils&#x27;)\n\nfunction log(dir) {\n  console.log(&#96;cleaning ${dir}&#96;)\n}\n\nrimraf(utils.resolve(&#x27;.tmp&#x27;), () =&gt; log(&#x27;.tmp&#x27;))\n\nutils\n  .exec(&#96;cd ${utils.resolve(&#x27;apps&#x27;)} &amp;&amp; ls&#96;)\n  .split(&#x27;\\n&#x27;)\n  .map(app =&gt; {\n    ;[\n      &#96;${app}&#x2F;_styles&#96;,\n      &#96;${app}&#x2F;_common&#96;,\n      &#96;${app}&#x2F;_templates&#96;,\n      &#96;${app}&#x2F;_components&#96;\n    ].map(m =&gt; {\n      rimraf(utils.resolve(&#96;apps&#x2F;${m}&#96;), () =&gt; log(m))\n    })\n  })\n\n</code></pre><h2>码畜小哥心满意足</h2>\n<blockquote>\n<p>“可以下班追剧了”</p>\n</blockquote>\n<h2>码畜小哥简介</h2>\n<p>考拉前端开发小哥Bingo，钻研小程序开发。</p>\n</div>","title":"利用 Webpack 实现小程序多项目管理","last_reply_at":"2019-04-19T03:01:49.536Z","good":false,"top":false,"reply_count":2,"visit_count":782,"create_at":"2019-04-18T03:51:41.757Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5c7f48af5b8cb21491ca65d0","author_id":"55e3e9f422d29223058b65d3","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>koa-router 是目前用的比较多的 Koa 的路由中间件之一，前段时间由于作者没有精力继续维护而将其<a href=\"https://www.zhihu.com/question/310604967\">公开售卖</a>。我们有些项目也用到了这个库，但是目前很多我们想要的特性都没有，比如生成接口文档。本身这个库代码实现还比较简单，因此综合考虑打算重写一个。</p>\n<p>项目地址：<a href=\"https://github.com/d-band/koa-mapper\">https://github.com/d-band/koa-mapper</a></p>\n<h2>特性：</h2>\n<ul>\n<li>支持几乎所有的 koa-router 特性</li>\n<li>支持 params 校验</li>\n<li>params 支持从 path, header, query, cookie 中获取</li>\n<li>支持 body parser</li>\n<li>支持 request body 校验</li>\n<li>支持参数类型自动转换</li>\n<li>支持自动生成 OpenAPI</li>\n</ul>\n<h2>简单例子：</h2>\n<p><strong>index.js</strong></p>\n<pre class=\"prettyprint\"><code>import Koa from &#x27;koa&#x27;;\nimport Mapper from &#x27;koa-mapper&#x27;;\nimport * as service from &#x27;.&#x2F;service&#x27;;\n\nconst Mapper = new Mapper();\n\nmapper.get(&#x27;&#x2F;users&#x2F;:id&#x2F;projects&#x27;, {\n  params: {\n    id: { type: &#x27;number&#x27; },\n    status: { type: &#x27;array&lt;string&gt;&#x27;, in: &#x27;query&#x27; },\n    token: { type: &#x27;string&#x27;, in: &#x27;header&#x27; }\n  }\n}, service.getProjects);\n\nmapper.post(&#x27;&#x2F;users&#x2F;:id&#x2F;projects&#x27;, {\n  params: {\n    id: { type: &#x27;number&#x27; }\n  },\n  body: &#x27;Project&#x27;\n}, service.addProject);\n\nmapper.schema(&#x27;Project&#x27;, {\n  id: { type: &#x27;number&#x27;, required: true },\n  name: { type: &#x27;string&#x27;, required: true },\n  status: { type: &#x27;array&lt;Status&gt;&#x27;, required: true }\n});\n\nmapper.schema(&#x27;Status&#x27;, {\n  id: { type: &#x27;integer&#x27; },\n  name: { type: &#x27;string&#x27; }\n}, {\n  required: [&#x27;id&#x27;, &#x27;name&#x27;]\n});\n\napp.use(mapper.routes());\napp.use(mapper.allowedMethods());\n\napp.listen(3000);\n\n&#x2F;&#x2F; open http:&#x2F;&#x2F;localhost:3000&#x2F;openapi.json\n</code></pre><p><strong>service.js</strong></p>\n<pre class=\"prettyprint\"><code>export async function getProjects(ctx) {\n  const { id, status, token } = ctx.params;\n\n  await checkToken(id, token);\n\n  ctx.body = await Project.findAll({\n    where: {\n      userId: id,\n      status: { $in: status }\n    }\n  });\n}\n\nexport async function addProject(ctx) {\n  const { body } = ctx.request;\n\n  ctx.body = await Project.create({\n    ...body,\n    userId: id\n  });\n}\n</code></pre><h2>路由定义：</h2>\n<pre class=\"prettyprint\"><code>mapper.get(path, [options], ...middlewares);\nmapper.post(path, [options], ...middlewares);\nmapper.put(path, [options], ...middlewares);\nmapper.del(path, [options], ...middlewares);\n...\n</code></pre><p>options 为可选参数，包含:</p>\n<ul>\n<li>name: 路由名称</li>\n<li>params: 请求参数定义</li>\n<li>body: 请求 Body 定义</li>\n<li>其他 OpenAPI 中 Operation Object 的参数</li>\n</ul>\n<p>options.params 为请求参数定义，如：</p>\n<pre class=\"prettyprint\"><code>params = {\n  id: { type: &#x27;number&#x27; },\n  name: { type: &#x27;string&#x27;, in: &#x27;query&#x27; },\n  user: { type: &#x27;User&#x27;, in: &#x27;query&#x27; }\n}\n</code></pre><ul>\n<li>type: 参数类型，包含基本类型（<code>number</code>、<code>string</code>、<code>integer</code>、<code>date</code>、<code>time</code>、<code>datetime</code>），数组类型（<code>array&lt;string&gt;</code>），自定义类型（如 User），自定义数组类型（<code>array&lt;User&gt;</code>），多个类型（<code>number|string</code>）</li>\n<li>in: 参数来源，包含 path，header，query，cookie</li>\n<li>其他 OpenAPI 中 Parameter Object 的参数</li>\n</ul>\n<h2>自定义类型</h2>\n<pre class=\"prettyprint\"><code>mapper.define(schemaName, properties, options);\n&#x2F;&#x2F; or\nmapper.schema(schemaName, properties, options);\n</code></pre><p>支持类型组合，如：</p>\n<pre class=\"prettyprint\"><code>mapper.schema(&#x27;Status&#x27;, {\n  id: { type: &#x27;integer&#x27; },\n  name: { type: &#x27;string&#x27; }\n}, {\n  required: [&#x27;id&#x27;]\n});\nmapper.schema(&#x27;Project&#x27;, {\n  id: { type: &#x27;number&#x27;, required: true },\n  name: { type: &#x27;string&#x27;, required: true },\n  status: { type: &#x27;array&lt;Status&gt;&#x27;, required: true }\n});\n</code></pre><p>支持继承，如：</p>\n<pre class=\"prettyprint\"><code>mapper.schema(&#x27;Model&#x27;, {\n  id: { type: &#x27;number&#x27; },\n  createdAt: { type: &#x27;datetime&#x27; },\n  updatedAt: { type: &#x27;datetime&#x27; }\n});\nmapper.schema(&#x27;User: Model&#x27;, {\n  name: { type: &#x27;string&#x27; }\n});\n</code></pre><h2>Body Parser</h2>\n<pre class=\"prettyprint\"><code>mapper.post(&#x27;&#x2F;users&#x27;, {\n  body: &#x27;User&#x27;\n}, (ctx) =&gt; {\n  const { id, name } = ctx.request.body;\n});\n</code></pre><p>支持文件上传，如：</p>\n<pre class=\"prettyprint\"><code>mapper.post(&#x27;&#x2F;uploadImage&#x27;, {\n  bodyparser: { multipart: true },\n  body: {\n    user: { type: &#x27;number&#x27; },\n    image: { type: &#x27;file&#x27; }\n  }\n}, (ctx) =&gt; {\n  const { user, image } = ctx.request.body;\n});\n</code></pre><h2>结尾</h2>\n<p>目前 koa-mapper 刚发布，测试覆盖率达到 100%，有哪些有兴趣的小伙伴欢迎一起维护。</p>\n</div>","title":"让我们来重新设计一下 koa-router","last_reply_at":"2019-04-19T02:28:28.033Z","good":false,"top":false,"reply_count":1,"visit_count":1285,"create_at":"2019-03-06T04:12:31.838Z","author":{"loginname":"helloyou2012","avatar_url":"https://avatars0.githubusercontent.com/u/1798364?v=4&s=120"}},{"id":"5cb82abda86ae80ce64b0b02","author_id":"5b2a60225cd02be6409015ed","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FtJPkmcz9zIgGxVHGH2x9qiOzrum\" alt=\"0094223E-9F7A-4BD3-92CC-90E9404577B6.png\"></p>\n</div>","title":"vscode安装egg插件后并没有egg代码提示？","last_reply_at":"2019-04-19T00:31:59.996Z","good":false,"top":false,"reply_count":1,"visit_count":624,"create_at":"2019-04-18T07:43:57.618Z","author":{"loginname":"vitozyf","avatar_url":"https://avatars0.githubusercontent.com/u/26626159?v=4&s=120"}},{"id":"5cb59ad7a86ae80ce64afb39","author_id":"5b03c9a7000332b81cf821a5","tab":"ask","content":"<div class=\"markdown-text\"><p>操作系统自己开个线程不断轮询各个文件描述符的 IO 缓存区，发现有数据，就产生一个事件？</p>\n</div>","title":"操作系统是怎么实现epoll的？","last_reply_at":"2019-04-18T15:19:35.649Z","good":false,"top":false,"reply_count":3,"visit_count":1042,"create_at":"2019-04-16T09:05:27.872Z","author":{"loginname":"linxiaoziruo","avatar_url":"https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"}},{"id":"5befe1b1be1b120abac5a592","author_id":"5b5a7729b71aedfe4c12652b","tab":"share","content":"<div class=\"markdown-text\"><p>6套经典node.js+vue项目实战视频教程，大家看看下面具体教程，有需要的可以学习一下哦</p>\n<p><img src=\"//static.cnodejs.org/FisDxxcRtOtl7qWtIwYMfYzDTr2G\" alt=\"11111.jpg\"></p>\n<p><strong>教程如下：</strong>\n[node]7天搞定NodeJS微信公众号开发\n[vue]vue2.0+node.js+MongoDB全栈打造商城（新录制）\nVue+Node+MongoDB小程序公众号全栈项目开发实战\nnode.js从入门到实战教育项目\nVue+Node+MongoDB小程序公众号全栈项目开发实战\n【实战】Node.js + Web Socket 打造即时通讯聊天程序</p>\n<p>下载地址：<a href=\"http://www.sucaihuo.com/video/378.html\">http://www.sucaihuo.com/video/378.html</a></p>\n</div>","title":"6套经典node.js+vue项目实战视频教程","last_reply_at":"2019-04-18T14:00:20.093Z","good":false,"top":false,"reply_count":21,"visit_count":4559,"create_at":"2018-11-17T09:38:57.164Z","author":{"loginname":"codeofking","avatar_url":"https://avatars2.githubusercontent.com/u/41748064?v=4&s=120"}},{"id":"5a9cf82f77dc4e0d2136ae0b","author_id":"595d976b10d696af07768a24","tab":"share","content":"<div class=\"markdown-text\"><h1>express搭建的淘宝客网站</h1>\n<blockquote>\n<p>测试地址: <a href=\"http://www.5aiss.com\">www.5aiss.com</a></p>\n</blockquote>\n<blockquote>\n<p>项目地址：<a href=\"https://gitee.com/null_639_7345/taobaoke\">https://gitee.com/null_639_7345/taobaoke</a></p>\n</blockquote>\n<h2>效果</h2>\n<p><img src=\"//static.cnodejs.org/FhODBX0aEYv9S_vHNMupGOJMyLiK\" alt=\"1.png\">\n<img src=\"//static.cnodejs.org/FnOFioCtmxAAwd-Hp6NavqrRpaV2\" alt=\"2.png\">\n<img src=\"//static.cnodejs.org/FpsOnYTFTJo1tdbBuahPTb1MUjFm\" alt=\"3.png\">\n<img src=\"//static.cnodejs.org/FgvpMq9M5kIyt7Qg0gAlvSxIXcnt\" alt=\"4.png\"></p>\n<h2>1.运行</h2>\n<ul>\n<li>安装mongodb数据库</li>\n<li>修改配置文件config/default.js</li>\n<li>配置淘宝api信息\n\\taobaoke\\server\\tbk\\TbkAPI.js</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>var client = new TopClient({\n  appkey: &quot;***&quot;,&#x2F;&#x2F;你的appkey\n  appsecret: &quot;***&quot;,&#x2F;&#x2F;appsecret\n  REST_URL: &quot;http:&#x2F;&#x2F;gw.api.taobao.com&#x2F;router&#x2F;rest&quot;\n});\n\nlet api = (module.exports = {\n  adzone_id: &quot;***&quot;,&#x2F;&#x2F;你的adzone_id\n  fields:&#x27;num_iid,title,pict_url,small_images,reserve_price,zk_final_price,user_type,provcity,item_url&#x27;\n});\n\n</code></pre><blockquote>\n<p>不清楚的请参考-book/淘宝客API使用方法.doc</p>\n</blockquote>\n<ul>\n<li>安装依赖库</li>\n</ul>\n<pre class=\"prettyprint language-sh\"><code>npm i gulp -g\nnpm i\n</code></pre><ul>\n<li>前端打包</li>\n</ul>\n<pre class=\"prettyprint language-sh\"><code>gulp\n</code></pre><ul>\n<li>启动web服务</li>\n</ul>\n<pre class=\"prettyprint language-sh\"><code>node .&#x2F;bin&#x2F;www\n</code></pre></div>","title":"express搭建的淘宝客网站","last_reply_at":"2019-04-18T10:57:28.168Z","good":false,"top":false,"reply_count":3,"visit_count":2260,"create_at":"2018-03-05T07:56:31.091Z","author":{"loginname":"18820227745","avatar_url":"https://avatars0.githubusercontent.com/u/25097125?v=4&s=120"}},{"id":"5cb85784a86ae80ce64b0cbd","author_id":"595d976b10d696af07768a24","tab":"share","content":"<div class=\"markdown-text\"><h1>使用koa-mysql-session时报错</h1>\n<ul>\n<li>\n<p>描述\n在本地测试代码没问题，但是部署到服务器上时就报错。</p>\n</li>\n<li>\n<p>错误</p>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>&gt; cross-env WEBPACK_TARGET=node NODE_ENV=production node .&#x2F;server&#x2F;app.js\n\ntrue\nthe server is start at port 3333\n&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;nav&#x2F;server&#x2F;node_modules&#x2F;koa-mysql-session&#x2F;node_modules&#x2F;co&#x2F;index.js:292\n    throw err;\n    ^\n\nError: ER_INDEX_COLUMN_TOO_LONG: Index column size too large. The maximum column size is 767 bytes.\n</code></pre><ul>\n<li>原因：因为mysql的版本差异导致的，本地5.7，服务器上5.6。koa-mysql-session是4年前的包不建议使用。</li>\n</ul>\n<blockquote>\n<p>单列索引的长度的限制:5.6里面默认不能超过767bytes，5.7不超过3072bytes</p>\n</blockquote>\n<ul>\n<li>解决：\n手动创建mysql_session_store</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>CREATE TABLE &#96;_mysql_session_store&#96; (\n  &#96;id&#96; varchar(255) NOT NULL,\n  &#96;expires&#96; bigint(20) DEFAULT NULL,\n  &#96;data&#96; text,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;\n</code></pre><ul>\n<li>\n<p>参考： <a href=\"https://blog.51cto.com/lee90/2087122\">MySQL中索引的长度的限制</a></p>\n</li>\n<li>\n<p>推荐：</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25686563?refer=cnodejs\">如何挑选高质量的 Node.js 模块？</a></li>\n<li><a href=\"https://awehunt.com/?tnid=5af1c0b67b4fac67bf3af2b4\">优秀的npm包</a></li>\n</ul>\n</li>\n</ul>\n</div>","title":"使用koa-mysql-session时报错","last_reply_at":"2019-04-18T10:55:00.842Z","good":false,"top":false,"reply_count":0,"visit_count":431,"create_at":"2019-04-18T10:55:00.842Z","author":{"loginname":"18820227745","avatar_url":"https://avatars0.githubusercontent.com/u/25097125?v=4&s=120"}},{"id":"5cb49686207b2365936ed5af","author_id":"57df88ff7d8293463a01e70b","tab":"share","content":"<div class=\"markdown-text\"><p>技术栈不多，只有express、mongodb和redis\n还有完全没必要用的docker，似乎只有一台服务器\n进程管理居然还是用的forever\n缺少错误收集机制，更不用说故障报警\n有日志模块，但是却多个服务写在同一个文件，毫无疑问如果开多进程日志有很大的风险被覆盖\n前后端没有完全分离，有少量代码使用了ejs模板，完全可以砍掉做到前后端完全分离（前后端代码放一起难以分清哪些是前端哪些是后端，混乱）\n因为有两个web服务入口点，其中一个是管理后台，完全不需要nginx却也套了一层，可以砍掉\n产品文档、数据库表文档、运维文档之类还算有，不过有点多余，因为那些都是基础的东西，关键部分的文档却没有\n没有接触到线上环境，从代码上看没有任何async/await到处是var和.then().then()，明显node版本应该在4.x左右\n又遇见了global，完全失去了IDE对代码的追踪功能\n往别人对象上添加方法和属性的行为，在node后端绝对是大忌\n发现有个似乎自己写的Promise模块，在删掉前搜索了一下整个项目，结果还真使用到了，多次使用了.when()方法，寡人也是第一次见啊，必需砍掉这个不标准的东西\npost方法本身支持json，而用的时候却到处都是json数据里的一个json字符串，奇葩\n没有任何单元测试\n没有开发环境的数据库初始数据，导致部分功能完全没法在本地跑起来，所以一个项目应该要做到能在完全新环境下跑起来</p>\n<p>今天的感悟：\n1.项目还是要选择越简单的技术栈越好，这样新人可以在最短的时间接手，不要为了用某技术而用某技术，像这个项目中的docker和nginx完全是多余的\n2.项目初始提交是18年却还在使用17年就已经淘汰的异步处理方法\n3.一个项目最容易跑起来的一定要是开发环境，任何生产环境的配置都不能出现在版本库中</p>\n<p>下一步要干掉全局变量，升级node版本以支持async/await，彻底拆分前后端</p>\n</div>","title":"今天新接手了一个项目，用的技术栈不多，发贴记录下接手的过程，为以后做其它项目时改进和规范开发流程","last_reply_at":"2019-04-18T09:22:53.205Z","good":false,"top":false,"reply_count":15,"visit_count":2018,"create_at":"2019-04-15T14:34:46.397Z","author":{"loginname":"zengming00","avatar_url":"https://avatars2.githubusercontent.com/u/5255081?v=4&s=120"}},{"id":"5cb41305207b2365936ed0e6","author_id":"570b551012def0933c43ac1b","tab":"share","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>魔都某公司；前段时间去面试了，然后收到2个offer；最后去了其中某一家，上了大概一天不到的班；\n他们人事下午大概4点左右的时候跟我说 因为招人的时候总经理出差了，但是现在总经理回来了，说从项目人员架构上来讲不需要人了。\n我....，  你们总经理出差去了，但我也是通过了层层面试才收到offer的啊。\n后来我说有没有赔偿，刚开始说没有，后来又叫我把银行卡写下来。   我就呵呵了，我是写下了银行卡，可它一直没有动静。\n当然我也不是因为那么点钱说这事，只是这基本的信用都没有吗。\n\n</code></pre></div>","title":"有的时候你真的想艹蛋","last_reply_at":"2019-04-18T08:50:18.288Z","good":false,"top":false,"reply_count":17,"visit_count":1642,"create_at":"2019-04-15T05:13:41.020Z","author":{"loginname":"linkenliu","avatar_url":"https://avatars0.githubusercontent.com/u/17923055?v=4&s=120"}},{"id":"5c98d7d400bcfd7eb2be60f5","author_id":"5af262b80a36e5312d6ece81","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fi0HqRPZ1HsMp9gbqS_uAyZPEVsz\" alt></p>\n<p>HTML5前端学习路线视频教程，带4个实战项目带课件资料和笔记总结，\n课程包括css3、html5、nodejs、vue、4个框架（bootstrap+Zepto+AngularJS+less）等\n教程下载：<a href=\"https://www.sucaihuo.com/video/460.html\">https://www.sucaihuo.com/video/460.html</a></p>\n</div>","title":"HTML5前端学习路线视频教程","last_reply_at":"2019-04-18T03:12:57.072Z","good":false,"top":false,"reply_count":1,"visit_count":628,"create_at":"2019-03-25T13:29:56.401Z","author":{"loginname":"alber1986","avatar_url":"https://avatars2.githubusercontent.com/u/38983466?v=4&s=120"}},{"id":"5cb69f13a86ae80ce64b0112","author_id":"59dc3f8c61932717683d21cf","tab":"ask","content":"<div class=\"markdown-text\"><p>如何解决兼容问题？上一个项目是用mongo数据库，最新的项目是mysql，但是部分业务需要用到mongo，所以想两者共存，请问有比较好的解决方案吗？</p>\n</div>","title":"egg框架可以同时支持mongo和mysql两种不同的数据库使用吗？（已解决）","last_reply_at":"2019-04-18T03:11:44.439Z","good":false,"top":false,"reply_count":10,"visit_count":1102,"create_at":"2019-04-17T03:35:47.882Z","author":{"loginname":"shanzemin","avatar_url":"https://avatars3.githubusercontent.com/u/32158058?v=4&s=120"}},{"id":"5cb5f31ba86ae80ce64afd1c","author_id":"58898ca65d4612c33919ea01","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>Linux有很多个发行版本，不同的发行版本有不同的包管理工具。为了安装指定的Node.js版本，有时候需要花一些精力找攻略或者安装额外的包管理工具等，有些包管理工具并没有最新的Node.js版本。所以，如果是Linux系统，索性直接使用编译好的二进制文件进行安装是最省心省力的。</p>\n<h2>安装</h2>\n<ul>\n<li>下载指定版本的二进制文件</li>\n</ul>\n<p>在Node.js官方的发布网站<a href=\"https://nodejs.org/dist/\">https://nodejs.org/dist/</a>下载合适的二进制包，比如我要安装<code>v11.14.0</code>版本，我需要下载二进制包为<a href=\"https://nodejs.org/dist/v11.14.0/node-v11.14.0-linux-x64.tar.gz\">node-v11.14.0-linux-x64.tar.gz</a>。</p>\n<ul>\n<li>解压文件</li>\n</ul>\n<pre class=\"prettyprint language-shell\"><code>tar -xvf node-v11.14.0-linux-x64.tar.gz\n</code></pre><ul>\n<li>拷贝文件到指定目录</li>\n</ul>\n<pre class=\"prettyprint language-shell\"><code>sudo cp -r node-v11.14.0-linux-x64&#x2F;* &#x2F;usr&#x2F;local&#x2F;\n</code></pre><ul>\n<li>测试是否安装成功</li>\n</ul>\n<pre class=\"prettyprint language-shell\"><code>root@blackmatch:~# node -v\nv11.14.0\nroot@blackmatch:~# npm -v\n6.7.0\nroot@blackmatch:~# npx -v\n6.7.0\n</code></pre><h2>总结</h2>\n<ul>\n<li>二进制包一定要下载合适的（比如x64、x86）等。</li>\n<li>安装完成后如果相关命令不生效，请重新打开一个终端即可生效。</li>\n</ul>\n</div>","title":"在Linux系统上通过二进制包安装Node.js","last_reply_at":"2019-04-18T01:35:12.182Z","good":false,"top":false,"reply_count":5,"visit_count":983,"create_at":"2019-04-16T15:22:03.832Z","author":{"loginname":"blackmatch","avatar_url":"https://avatars3.githubusercontent.com/u/12443954?v=4&s=120"}},{"id":"5ad6a0693edb2aff6be85bbd","author_id":"547c35030ae47dec03aa2939","tab":"share","content":"<div class=\"markdown-text\"><ol>\n<li>\n<p>问：你认为区块链技术中的区块意味着什么？\n区块链由所有金融交易的信息组成。一个块只不过是一个记录列表。当这些列表相互结合时，它们被称为区块链。例如，一个组织有100个分类账簿，其中的组合被称为区块链，单个分类账将被视为一个区块。</p>\n</li>\n<li>\n<p>问：为什么区块链是一种值得信赖的方法\n有很多原因，区块链可以被信任。第一个原因是它与其他商业应用程序有良好的兼容性，因为它是开源的。其次是它的安全性，因为它是为了在线交易而开发的，所以开发人员在保证安全性的同时也特别关注它的数据同步。由于其拥有的业务类型无关，所以在选择的时候区别链很容易地被考虑。</p>\n</li>\n<li>\n<p>问：区块链中是否有可能从网络中删除一个或多个区块？\n当然可以，如果只考虑该在线分类帐的特定部分的时候。借助默认选项和过滤器，可以轻松完成此任务，而不需要付出太多。</p>\n</li>\n<li>\n<p>问：你对区块链了解多少？\n这是一种实际上为比特币设计的技术，后来因为监控和记录网络上所有金融交易而带来的多种好处而获得了大量的推广。这是一种值得信赖的方法，目前情况下有很多组织正在使用它。由于一切都是十分安全的，并且它是一种开源方式，所以从长远来看，它可以轻松获得大家的信任。</p>\n</li>\n<li>\n<p>问：区块链方法如何识别区块？\n在线分类帐中的每个块基本上都包含一个哈希指针，该指针指向它之前的块并形成链接，块中包含交易数据和时间戳。</p>\n</li>\n<li>\n<p>问：你认为一个区块的安全性究竟是什么？\n网络上的所有用户都不能修改块。因此它提供了极好的安全级别。除此之外，每个区块都使用加密技术进行保护，这是另一项措施。因此，不需要担心块中存在的数据的安全性和安全性。</p>\n</li>\n<li>\n<p>问：在组织中使用区块链技术是否有网络特定的条件？\n使用它没有特定的条件。但是，网络必须是有关协议下的对等网络。它实际上很简单地验证了新块，并帮助组织在不投资第三方应用程序的情况下保持同步。</p>\n</li>\n<li>\n<p>问：什么是加密？它在区块链中的作用是什么？\n数据安全始终很重要。加密基本上是一种帮助组织保持数据安全的方法。在这种技术中，数据在被发送者发送到网络之前被编码或者在一定程度上被改变。唯一的接收器可以理解如何对其进行解码。在区块链中，这种方法很有用，因为它增加了区块的整体安全性和真实性，并有助于保护区块的安全。</p>\n</li>\n<li>\n<p>问：一旦写入数据块后，是否可以修改数据？\n不，这是不可能的。如果需要进行任何修改，组织只需删除所有其他块的信息。这是因为没有其他方法，数据在使用这种方法时必须非常谨慎。</p>\n</li>\n<li>\n<p>问：区块链中可以保存哪些类型的记录？有什么限制吗？\n区块链方法中没有任何类型记录的限制。目前，世界各地的许多组织正在使用这种方法，事实是医疗交易记录，与组织相关的事件，管理活动，交易处理，身份管理以及文件记录都是常见的可以使用区块链的记录类型。而且记录保存并不仅限于这些应用程序。</p>\n</li>\n<li>\n<p>问：什么是双重支出？</p>\n</li>\n</ol>\n<p>这是与数字货币有关的主要问题之一。 事实上，这是一个数字通证被多次使用的条件，因为通证通常由易于克隆的数字文件组成。它只会导致通货膨胀，组织不得不承受巨大的损失。 区块链技术的主要目标之一是尽可能地消除这种方法。</p>\n<ol>\n<li>问：解释盲签名的重要性以及它如何有用？</li>\n</ol>\n<p>它实际上是一种数字签名形式，密码学的一个重要组成部分，其中所有信息在实际考虑或签署之前都是盲目的。 这是经过验证的方法，通常在作者和签署方都不同的隐私相关协议中考虑。 数字货币设计是最常见的例子之一。</p>\n<ol>\n<li>问：什么是密钥分享？区块链技术有什么好处吗？</li>\n</ol>\n<p>众所周知的事实是，数字交易中的安全问题非常重要。密钥分享是一种类似的方法。在区块链技术中，这是一种将密钥密或个人信息划分为不同单元并将其发送给网络上的用户的方法。原始信息只能在分配了密钥的参与者同意将他们与其他人结合在一起时才能结合使用。它可以在区块链技术中提供多种与安全相关的好处。</p>\n<ol>\n<li>\n<p>问：超级账本是什么？区块链支持吗？\n超级账本只不过是一种特殊的账本，为给人们提供服务的企业而设计。没有严格的服务上限，企业可以通过超级账本进行管理。区块链拥有专门用于处理超级账本的算法。事实上，它减少了许多与此相关的问题。</p>\n</li>\n<li>\n<p>问：命名区块链项目实施中涉及的步骤？\n这个过程共涉及六个步骤，它们是：\n1.需求识别\n2.筛选并确认需求\n3.区块链项目开发\n4.安全性的可行性研究\n5.实施\n6.控制和监测项目</p>\n</li>\n<li>\n<p>问：你所知道区块链的好处是什么？\n它鼓励安全的在线交易，这是它最大的好处之一。基本上，作为一个密切关注所有交易记录的分布式分散账本，它不会让记录被任何人改变，这增强了安全性。除此之外，参与者和企业主可以始终确保最终的成本审计。区块链始终可以保证的一件事是每个区块或单元只能传输一次，这样可以消除双重支出问题。</p>\n</li>\n<li>\n<p>问：将区块链数据库中存在的两种记录命名为？\n这些记录是块记录和交易记录。这两个记录都可以轻松访问，最好的方式是可以将它们彼此集成，而无需遵循复杂的算法。</p>\n</li>\n<li>\n<p>问：你了解的信息威胁有哪些？\n目前情况下信息面临很多威胁。由于互联网在线交易的增加，许多黑客已经变得活跃，正在采用新方法来破解包含财务信息的数据和服务器。主要的威胁是软件攻击，身份盗窃，信息勒索以及破坏。除此之外，特洛伊木马，蠕虫和病毒也是麻烦的创造者。</p>\n</li>\n<li>\n<p>问：信息泄漏对组织可能造成什么挑战？\n信息泄露可以极大地降低组织的声誉。除此之外，这可能是组织承受巨大损失的原因。许多未能实施安全协议来保证其数据安全的组织已经失去了客户的信任，并且正在努力争取再次获得相同的声誉。如果不关注在线交易安全，任何组织的总体利润可降低80％。</p>\n</li>\n<li>\n<p>问：有那些可以使用区块链技术的组织？\n可以考虑这种方法的商业类别没有严格的上限。事实上，几乎所有的企业都在进行在线或财务交易，而这些交易需要他们顺利的执行完整的流程。大型公司，金融机构，私营企业，政府部门乃至国防组织都可以非常轻松地信任这项技术。</p>\n</li>\n<li>\n<p>问：什么是信息处理？与此相关的关键挑战是什么？\n这些信息通常在网络上共享。在通过网络实际发送之前，需要将其改变为适合频道标准的格式（频道是发送者和接收者之间的链接）。在发送端和接收端进行信息转换所做的工作通常被认为是信息处理。信息处理所面临的最大挑战就是在这段时间保护它。另一个挑战是处理批量信息会对性能造成限制。</p>\n</li>\n<li>\n<p>问：BIP代表什么？\n这意味着比特币改善建议。</p>\n</li>\n<li>\n<p>问：区块链中的哪些关键原则有助于消除需要遵循的安全威胁？\n是的，在时间方面需要遵循一些原则。他们是：\n1.审计\n2.保护应用程序\n3.确保测试和类似的方法\n4.数据库安全\n5.连续性计划\n6.数字劳动力培训</p>\n</li>\n</ol>\n<p>所有这些原则都是基本的，并且易于实施。它们有助于使交易记录有用。</p>\n<ol>\n<li>\n<p>问：区块链技术的基础是什么？\n它使信息能够在用户之间分发而不被复制。</p>\n</li>\n<li>\n<p>问：区块链是不可破坏的分类账吗？\n根据开发商的说法，区块链分类帐不能损坏。</p>\n</li>\n<li>\n<p>问：什么是安全策略？\n安全策略定义了系统上确切需要确保的内容。它根据一些核心协议绑定网络用户，他们都必须同意并遵循以提高整体安全性。当涉及到组织的信息或财务记录时，多个安全策略的实施不止一个。</p>\n</li>\n<li>\n<p>问：在确保交易记录时，您将如何处理风险管理？\n它基本上是一个查找组织的财务记录的威胁和所有漏洞的过程。对付这种做法最好的办法是立即采取正确的对策。另一种方法是注意备份计划。根据信息的价值，可以简单地考虑购买新风险管理软件等更多方法。信息的主要风险来自黑帽黑客。</p>\n</li>\n<li>\n<p>问：请列出区块链中用户可以考虑的普通类型的分类帐？\n这些是：\n1.集中式分类账\n2.分散式分类帐\n3.分布式分类帐</p>\n</li>\n<li>\n<p>问：区块链分类账与普通分类账的区别？\n第一个，其实最主要的区别是区块链是一个可以非常容易分散的数字分类帐。这种方法出错的几率远远低于普通分类账中的错误率。普通账本就是用手或人工努力准备的，而区块链自动执行所有任务。你只需要以适当的方式配置它，并遵循所有的指导原则。</p>\n</li>\n<li>\n<p>问：分布式数字分类帐用于在BlockChain中记录交易。系统依赖于什么？</p>\n</li>\n</ol>\n<p>它依赖于网络节点。</p>\n<p>以上问题出自：<a href=\"https://mindmajix.com/blockchain-interview-questions\">https://mindmajix.com/blockchain-interview-questions</a></p>\n<ol>\n<li>问：陷门函数的功能是什么，为什么它是区块链所需要的？</li>\n</ol>\n<p>一个陷门函数是在一个方向上容易计算但难以在相反方向的计算，除非你有特殊的信息。陷门函数是必不可少的公共密钥加密，所以他们常用在blockchain发展代表思想的地址和私有密钥。</p>\n<ol>\n<li>问：比特币实现中的交易和块是如何加密的？</li>\n</ol>\n<p>比特币块不以任何方式加密：每个块都是公开的。阻止修改和保证数据完整性的是一个称为块哈希的值。块的内容是使用在比特币的一种特殊Hash函数来处理，它的实现和得到的值包含在区块链中。</p>\n<ol>\n<li>问 ：解释为什么区块链需要通证。</li>\n</ol>\n<p>代币/通证用于实现状态之间的变化。当有人做交易时，这是一种状态的改变，代币从一个地址移到另一个地址。除此之外，交易可以包含额外的数据和状态的变化来改变数据，来做这一个不变的定义区块链的唯一途径。从技术上讲，区块链不需要代币为其主要业务，但没有他们，其他方式需要引进管理链状态和验证交易。</p>\n<ol>\n<li>问：对等网络（P2P）网络中对等体是如何工作的？</li>\n</ol>\n<p>当一个新的节点启动时，它对网络一无所知，因为没有中央服务器。通常开发人员提供可信节点的列表，这些节点直接写入可用于初始对等点发现的代码中。</p>\n<ol>\n<li>问：如何验证检查一个块是有效的？</li>\n</ol>\n<p>网络上的每个完整节点都进行块验证。当一个新的块被宣布时，接收它的每个节点都会执行一个检查列表。两个最重要的检查是工作证明（如果一个块提供足够的工作要包含在链中）和所有事务的有效性（每个事务必须是有效的）。</p>\n<ol>\n<li>问：一个ScriptPubKey是什么？解释如何使用P2SH地址就可以了。</li>\n</ol>\n<p>一个是所谓的锁定ScriptPubKey脚本。它出现目的是阻止交易的输出，在输出过程中必须满足。</p>\n<p>P2SH是一种特殊类型的地址，代替复杂的锁定脚本的hash值。当一个试图花费输出的交易稍后显示时，除了解锁脚本之外，它还必须包含与哈希匹配的脚本。</p>\n<ol>\n<li>问：使用脚本，编写一个redeem script脚本，允许用户仅在用户知道魔术数字1234567时才使用输出。</li>\n</ol>\n<pre class=\"prettyprint\"><code>OP_EQUALVERIFY\nscriptPubKey: 1234567 OP_EQUALVERIFY\nscriptSig: 1234567\n</code></pre><ol>\n<li>问：使用脚本，编写一个redeem script脚本，允许任何人在一次老化后最少花费30天的时间。</li>\n</ol>\n<pre class=\"prettyprint\"><code>scriptPubKey: &quot;30d&quot; OP_CHECKSEQUENCEVERIFY OP_VERIFY\nscriptSig: empty\n</code></pre><ol>\n<li>问：什么是挖矿？</li>\n</ol>\n<p>挖矿是在区块链网络达成共识的过程。挖矿有两个目的。首先，它在生成的块中创建新的代币。其次，它通过向网络提供工作证明，包括分布式计费中的交易；也就是说，证明所生成的块是有效的。</p>\n<ol>\n<li>问：什么是软分叉？</li>\n</ol>\n<p>在分类帐中的块包括以建立最长链的方式，即具有最大累积难度的链。分叉是有两个候选块竞争形成最长的区块链，两个矿工发现工作问题的证明方法在很短的时间内没有同步对方的情况。造成网络分割，因为某些节点得到块从矿工#1和而另外一些得到矿工#2。\n分叉通常在一个块中得到解决，因为这种情况再次发生的概率变得非常低，因为下一个块出现，所以很快有一个新的最长链，将被认为是主要的。</p>\n<p>（注：这种叉不同于硬叉，这是一些开发商决定创建一个不向后兼容的改变到区块链协议，导致两个永远不同区块链。）</p>\n<p>以上问题出自：<a href=\"https://www.toptal.com/blockchain/interview-questions\">https://www.toptal.com/blockchain/interview-questions</a></p>\n<p>顺便推荐两个区块链、以太坊开发DApp的实战教程：</p>\n<ol>\n<li>\n<p>适合区块链新手的以太坊DApp开发：\n<a href=\"http://xc.hubwiz.com/course/5a952991adb3847553d205d1?affid=20180418cnodew\">http://xc.hubwiz.com/course/5a952991adb3847553d205d1</a></p>\n</li>\n<li>\n<p>用区块链、星际文件系统（IPFS）、Node.js和MongoDB来构建电商平台:\n<a href=\"http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6/?affid=20180418cnodew\">http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6</a></p>\n</li>\n</ol>\n</div>","title":"区块链面试招聘中可能会被问到的40个问题。","last_reply_at":"2019-04-17T17:38:27.467Z","good":false,"top":false,"reply_count":2,"visit_count":2548,"create_at":"2018-04-18T01:33:29.450Z","author":{"loginname":"2596887568","avatar_url":"https://avatars3.githubusercontent.com/u/9349200?v=4&s=120"}},{"id":"5ae886c51b02288048bd0b75","author_id":"5ae885ad1b02288048bd0b74","tab":"ask","content":"<div class=\"markdown-text\"><p>小白一个 学了点小基础 希望能够提升一下\n希望各位表哥  分享一下开源项目和学习教程</p>\n</div>","title":"求node和微信小程序的教程或者 开源项目","last_reply_at":"2019-04-17T15:51:25.158Z","good":false,"top":false,"reply_count":43,"visit_count":7619,"create_at":"2018-05-01T15:24:53.470Z","author":{"loginname":"longletian","avatar_url":"https://avatars0.githubusercontent.com/u/28197668?v=4&s=120"}},{"id":"5cb53882207b2365936ed958","author_id":"5a1067384f0d21491dd96078","tab":"ask","content":"<div class=\"markdown-text\"><p>其他常用的包也可以推荐</p>\n</div>","title":"在本地起一个指定目录的静态服务器，有没有合适的包推荐","last_reply_at":"2019-04-17T15:27:48.886Z","good":false,"top":false,"reply_count":10,"visit_count":1276,"create_at":"2019-04-16T02:05:54.636Z","author":{"loginname":"lucky-leaf","avatar_url":"https://avatars1.githubusercontent.com/u/31915733?v=4&s=120"}},{"id":"5cb7125d37faec0ce1d02fa0","author_id":"5ac77987e34737560fccaa7b","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/14/16a1a43866ee4958?w=1380&amp;h=806&amp;f=jpeg&amp;s=110148\" alt=\"image\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/14/16a1a43668effc5b?w=2786&amp;h=1644&amp;f=png&amp;s=525606\" alt=\"image\"></p>\n<h2>感谢</h2>\n<p><a href=\"https://github.com/funfish/blog/issues/8\">funfish</a>, <a href=\"https://juejin.im/post/5af108dc518825672565cf31#heading-5\">玩弄心里的鬼</a>, <a href=\"https://ustbhuangyi.github.io/vue-analysis/vue-router/transition-to.html#%E7%BB%84%E4%BB%B6\">Vue.js 技术揭秘</a>的文章，对我的帮助</p>\n<h2>前言</h2>\n<p>vue-router的源码不算很多, 但是内容也不算少。本文谈不上逐行分析, 但是会尽量详尽的说明主流程和原理。对一些工具函数和边缘条件的处理会略过，因为我也没有逐行去了解它们，请见谅。</p>\n<h2>前置基础知识</h2>\n<p>我们在学习VueRouter源码前，先来复习下hash以及histroy相关的知识。更多细节请参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/History_API\">mdn文档</a>，本节内容节选自mdn文档。</p>\n<h3>hash</h3>\n<h4>onhashchange</h4>\n<p>当URL的片段标识符更改时，将触发hashchange事件 (跟在＃符号后面的URL部分，包括＃符号)。注意 histroy.pushState() 绝对不会触发 hashchange 事件，即使新的URL与旧的URL仅哈希不同也是如此。</p>\n<h3>histroy</h3>\n<h4>pushState</h4>\n<p>pushState()需要三个参数: 一个状态对象, 一个标题(目前被忽略), 和一个URL。</p>\n<ul>\n<li>state, 状态对象state是一个JavaScript对象，popstate事件触发时，该对象会传入回调函数</li>\n<li>title, 目前所有浏览器忽略</li>\n<li>url, 新的url记录</li>\n</ul>\n<h4>replaceState</h4>\n<p>history.replaceState()的使用与history.pushState()非常相似，区别在于replaceState()是修改了当前的历史记录项而不是新建一个。</p>\n<h4>onpopstate</h4>\n<p>调用history.pushState()或者history.replaceState()不会触发popstate事件. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法)。</p>\n<p>如果当前处于激活状态的历史记录条目是由history.pushState()方法创建, 或者由history.replaceState()方法修改过的, 则popstate事件对象的state属性包含了这个历史记录条目的state对象的一个拷贝。</p>\n<h2>应用初始化</h2>\n<p>通常构建一个Vue应用的时候, 我们会使用Vue.use以插件的形式安装VueRouter。同时会在Vue的实例上挂载router的实例。</p>\n<pre class=\"prettyprint language-js\"><code>import Vue from &#x27;vue&#x27;\nimport App from &#x27;.&#x2F;App.vue&#x27;\nimport router from &#x27;.&#x2F;router&#x27;\n\nVue.config.productionTip = false\n\nlet a = new Vue({\n  router,\n  render: h =&gt; h(App)\n}).$mount(&#x27;#app&#x27;)\n</code></pre><pre class=\"prettyprint language-js\"><code>\nimport Vue from &#x27;vue&#x27;\nimport Router from &#x27;vue-router&#x27;\nimport Home from &#x27;.&#x2F;views&#x2F;Home.vue&#x27;\n\nVue.use(Router)\n\nexport default new Router({\n  mode: &#x27;history&#x27;,\n  base: process.env.BASE_URL,\n  routes: [\n    {\n      path: &#x27;&#x2F;&#x27;,\n      name: &#x27;home&#x27;,\n      component: Home\n    },\n    {\n      path: &#x27;&#x2F;about&#x27;,\n      name: &#x27;about&#x27;,\n      component: () =&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#x27;.&#x2F;views&#x2F;About.vue&#x27;)\n    }\n  ]\n})\n</code></pre><h2>插件的安装</h2>\n<p>在Vue的文档中指出<strong>Vue.js 的插件应该有一个公开方法 install。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象</strong>, 我们首先查看源码中install.js的文件。</p>\n<p>在install文件中, 我们在Vue的实例上初始化了一些私有属性</p>\n<ul>\n<li>_routerRoot, 指向了Vue的实例</li>\n<li>_router, 指向了VueRouter的实例</li>\n</ul>\n<p>在Vue的prototype上初始化了一些getter</p>\n<ul>\n<li>$router, 当前Router的实例</li>\n<li>$route, 当前Router的信息</li>\n</ul>\n<p>并且在全局混入了mixin, 已经全局注册了RouterView, RouterLink组件.</p>\n<pre class=\"prettyprint language-js\"><code>\nimport View from &#x27;.&#x2F;components&#x2F;view&#x27;\nimport Link from &#x27;.&#x2F;components&#x2F;link&#x27;\n\nexport let _Vue\n\nexport function install (Vue) {\n  if (install.installed &amp;&amp; _Vue === Vue) return\n  install.installed = true\n\n  _Vue = Vue\n\n  const isDef = v =&gt; v !== undefined\n\n  const registerInstance = (vm, callVal) =&gt; {\n    let i = vm.$options._parentVnode\n    if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal)\n    }\n  }\n\n  Vue.mixin({\n    beforeCreate () {\n      &#x2F;&#x2F; 判断是否实例是否挂载了router\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this\n        this._router = this.$options.router\n        this._router.init(this)\n        &#x2F;&#x2F; _router, 劫持的是当前的路由\n        Vue.util.defineReactive(this, &#x27;_route&#x27;, this._router.history.current)\n      } else {\n        this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this\n      }\n      registerInstance(this, this)\n    },\n    destroyed () {\n      registerInstance(this)\n    }\n  })\n\n  Object.defineProperty(Vue.prototype, &#x27;$router&#x27;, {\n    get () { return this._routerRoot._router }\n  })\n\n  Object.defineProperty(Vue.prototype, &#x27;$route&#x27;, {\n    get () { return this._routerRoot._route }\n  })\n\n  Vue.component(&#x27;RouterView&#x27;, View)\n  Vue.component(&#x27;RouterLink&#x27;, Link)\n\n  const strats = Vue.config.optionMergeStrategies\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created\n}\n</code></pre><p>Vue.util.defineReactive, 这是Vue里面观察者劫持数据的方法，劫持_route，当_route触发setter方法的时候，则会通知到依赖的组件。<strong>而RouterView, 需要访问parent.$route所以形成了依赖</strong>(我们在后面会看到)</p>\n<p>👀我们到Vue中看一下defineReactive的源码, 在defineReactive, 会对_route使用Object.defineProperty劫持setter方法。set时会通知观察者。</p>\n<pre class=\"prettyprint language-js\"><code>\n\nObject.defineProperty(obj, key, {\n  enumerable: true,\n  configurable: true,\n  get: function reactiveGetter () {\n    &#x2F;&#x2F; ...\n  },\n  set: function reactiveSetter (newVal) {\n    &#x2F;&#x2F; ...\n    childOb = !shallow &amp;&amp; observe(newVal)\n    dep.notify()\n  }\n})\n</code></pre><h2>VueRouter实例</h2>\n<pre class=\"prettyprint language-js\"><code>\nexport default class VueRouter {\n  constructor (options: RouterOptions = {}) {\n    this.app = null\n    this.apps = []\n    this.options = options\n    this.beforeHooks = []\n    this.resolveHooks = []\n    this.afterHooks = []\n    this.matcher = createMatcher(options.routes || [], this)\n\n    let mode = options.mode || &#x27;hash&#x27;\n    &#x2F;&#x2F; fallback会在不支持history环境的情况下, 回退到hash模式\n    this.fallback = mode === &#x27;history&#x27; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false\n    if (this.fallback) {\n      mode = &#x27;hash&#x27;\n    }\n    if (!inBrowser) {\n      mode = &#x27;abstract&#x27;\n    }\n    this.mode = mode\n\n    switch (mode) {\n      case &#x27;history&#x27;:\n        this.history = new HTML5History(this, options.base)\n        break\n      case &#x27;hash&#x27;:\n        this.history = new HashHistory(this, options.base, this.fallback)\n        break\n      case &#x27;abstract&#x27;:\n        this.history = new AbstractHistory(this, options.base)\n        break\n      default:\n        if (process.env.NODE_ENV !== &#x27;production&#x27;) {\n          assert(false, &#96;invalid mode: ${mode}&#96;)\n        }\n    }\n  }\n}\n</code></pre><h2>matcher</h2>\n<p>matcher对象中包含了两个属性, addRoutes, match。</p>\n<h3>pathList, pathMap, nameMap</h3>\n<p>pathList, pathMap, nameMap分别是路径的列表, 路径和路由对象的映射, 路由名称和路由对象的映射。vue-router目标支持动态路由, pathList, pathMap, nameMap可以在初始化后动态的被修改。它们由createRouteMap方法创建, 我们来看看createRouteMap的源码。</p>\n<pre class=\"prettyprint language-js\"><code>\nexport function createRouteMap (\n  routes,\n  oldPathList,\n  oldPathMap,\n  oldNameMap\n) {\n  &#x2F;&#x2F; pathList，pathMap，nameMap支持后续的动态添加\n  const pathList: Array&lt;string&gt; = oldPathList || []\n  const pathMap: Dictionary&lt;RouteRecord&gt; = oldPathMap || Object.create(null)\n  const nameMap: Dictionary&lt;RouteRecord&gt; = oldNameMap || Object.create(null)\n\n  &#x2F;&#x2F; 遍历路由列表\n  routes.forEach(route =&gt; {\n    addRouteRecord(pathList, pathMap, nameMap, route)\n  })\n\n  &#x2F;&#x2F; 将通配符的路径, push到pathList的末尾\n  for (let i = 0, l = pathList.length; i &lt; l; i++) {\n    if (pathList[i] === &#x27;*&#x27;) {\n      pathList.push(pathList.splice(i, 1)[0])\n      l--\n      i--\n    }\n  }\n\n  return {\n    pathList,\n    pathMap,\n    nameMap\n  }\n}\n</code></pre><p>routes为一组路由, 所以我们循环routes, 但是route可能存在children所以我们通过递归的形式创建route。返回一个route的树🌲</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction addRouteRecord (\n  pathList,\n  pathMap,\n  nameMap,\n  route,\n  parent,\n  matchAs\n) {\n  const { path, name } = route\n \n  const pathToRegexpOptions: PathToRegexpOptions = route.pathToRegexpOptions || {}\n\n  &#x2F;&#x2F; normalizePath, 会对path进行格式化\n  &#x2F;&#x2F; 会删除末尾的&#x2F;，如果route是子级，会连接父级和子级的path，形成一个完整的path\n  const normalizedPath = normalizePath(\n    path,\n    parent,\n    pathToRegexpOptions.strict\n  )\n\n  if (typeof route.caseSensitive === &#x27;boolean&#x27;) {\n    pathToRegexpOptions.sensitive = route.caseSensitive\n  }\n\n  &#x2F;&#x2F; 创建一个完整的路由对象\n  const record: RouteRecord = {\n    path: normalizedPath,\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n    components: route.components || { default: route.component },\n    instances: {},\n    name,\n    parent,\n    matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null\n      ? {}\n      : route.components\n        ? route.props\n        : { default: route.props }\n  }\n\n  &#x2F;&#x2F; 如果route存在children, 我们会递归的创建路由对象\n  &#x2F;&#x2F; 递归的创建route对象\n  if (route.children) {\n    route.children.forEach(child =&gt; {\n      const childMatchAs = matchAs\n        ? cleanPath(&#96;${matchAs}&#x2F;${child.path}&#96;)\n        : undefined\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs)\n    })\n  }\n\n  &#x2F;&#x2F; 这里是对路由别名的处理\n  if (route.alias !== undefined) {\n    const aliases = Array.isArray(route.alias)\n      ? route.alias\n      : [route.alias]\n\n    aliases.forEach(alias =&gt; {\n      const aliasRoute = {\n        path: alias,\n        children: route.children\n      }\n      addRouteRecord(\n        pathList,\n        pathMap,\n        nameMap,\n        aliasRoute,\n        parent,\n        record.path || &#x27;&#x2F;&#x27; &#x2F;&#x2F; matchAs\n      )\n    })\n  }\n\n  &#x2F;&#x2F; 填充pathMap，nameMap，pathList\n  if (!pathMap[record.path]) {\n    pathList.push(record.path)\n    pathMap[record.path] = record\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record\n    }\n  }\n}\n</code></pre><h3>addRoutes</h3>\n<p>动态添加更多的路由规则, 并动态的修改pathList，pathMap，nameMap</p>\n<pre class=\"prettyprint language-js\"><code>function addRoutes (routes) {\n  createRouteMap(routes, pathList, pathMap, nameMap)\n}\n</code></pre><h3>match</h3>\n<p>match方法根据参数raw(可以是字符串也可以Location对象), 以及currentRoute（当前的路由对象返回Route对象)，在nameMap中查找对应的Route，并返回。</p>\n<p>如果location包含name, 我通过nameMap找到了对应的Route, 但是此时path中可能包含params, 所以我们会通过fillParams函数将params填充到patch，返回一个真实的路径path。</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction match (\n  raw,\n  currentRoute,\n  redirectedFrom\n) {\n  &#x2F;&#x2F; 会对raw，currentRoute处理，返回格式化后path, hash, 以及params\n  const location = normalizeLocation(raw, currentRoute, false, router)\n\n  const { name } = location\n\n  if (name) {\n    const record = nameMap[name]\n    if (!record) return _createRoute(null, location)\n    \n    &#x2F;&#x2F; 获取所有必须的params。如果optional为true说明params不是必须的\n    const paramNames = record.regex.keys\n      .filter(key =&gt; !key.optional)\n      .map(key =&gt; key.name)\n\n    if (typeof location.params !== &#x27;object&#x27;) {\n      location.params = {}\n    }\n\n    if (currentRoute &amp;&amp; typeof currentRoute.params === &#x27;object&#x27;) {\n      for (const key in currentRoute.params) {\n        if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) {\n          location.params[key] = currentRoute.params[key]\n        }\n      }\n    }\n\n    if (record) {\n      &#x2F;&#x2F; 使用params对path进行填充返回一个真实的路径\n      location.path = fillParams(record.path, location.params, &#96;named route &quot;${name}&quot;&#96;)\n      &#x2F;&#x2F; 创建Route对象\n      return _createRoute(record, location, redirectedFrom)\n    }\n  } else if (location.path) {\n    location.params = {}\n    for (let i = 0; i &lt; pathList.length; i++) {\n      const path = pathList[i]\n      const record = pathMap[path]\n      &#x2F;&#x2F; 使用pathList中的每一个regex，对path进行匹配\n      if (matchRoute(record.regex, location.path, location.params)) {\n        return _createRoute(record, location, redirectedFrom)\n      }\n    }\n  }\n  return _createRoute(null, location)\n}\n</code></pre><p>我们接下来继续看看_createRoute中做了什么。</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction _createRoute (\n  record: ?RouteRecord,\n  location: Location,\n  redirectedFrom?: Location\n): Route {\n  if (record &amp;&amp; record.redirect) {\n    return redirect(record, redirectedFrom || location)\n  }\n  if (record &amp;&amp; record.matchAs) {\n    return alias(record, location, record.matchAs)\n  }\n  return createRoute(record, location, redirectedFrom, router)\n}\n</code></pre><p>其中redirect，alias最终都会调用createRoute方法。我们再将视角转向createRoute函数。createRoute函数会返回一个冻结的Router对象。</p>\n<p>其中matched属性为一个数组，包含当前路由的所有嵌套路径片段的路由记录。数组的顺序为从外向里(树的外层到内层)。</p>\n<pre class=\"prettyprint language-js\"><code>\nexport function createRoute (\n  record: ?RouteRecord,\n  location: Location,\n  redirectedFrom?: ?Location,\n  router?: VueRouter\n): Route {\n  const stringifyQuery = router &amp;&amp; router.options.stringifyQuery\n\n  let query: any = location.query || {}\n  try {\n    query = clone(query)\n  } catch (e) {}\n\n  const route: Route = {\n    name: location.name || (record &amp;&amp; record.name),\n    meta: (record &amp;&amp; record.meta) || {},\n    path: location.path || &#x27;&#x2F;&#x27;,\n    hash: location.hash || &#x27;&#x27;,\n    query,\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery),\n    matched: record ? formatMatch(record) : []\n  }\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery)\n  }\n  return Object.freeze(route)\n}\n</code></pre><h2>init</h2>\n<p>init中。会挂载cb的回调，这关乎到RouteView的渲染。我们根据当前的url，在Vue根实例的beforeCreate生命周期钩子中完成路由的初始化，完成第一次的路由导航。</p>\n<pre class=\"prettyprint language-js\"><code>\ninit (app) {\n\n  &#x2F;&#x2F; app为Vue的实例\n  this.apps.push(app)\n\n  if (this.app) {\n    return\n  }\n\n  &#x2F;&#x2F; 在VueRouter上挂载app属性\n  this.app = app\n\n  const history = this.history\n\n  &#x2F;&#x2F; 初始化当前的路由，完成第一次导航，在hash模式下会在transitionTo的回调中调用setupListeners\n  &#x2F;&#x2F; setupListeners里会对hashchange事件进行监听\n  &#x2F;&#x2F; transitionTo是进行路由导航的函数，我们将会在下面介绍\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation())\n  } else if (history instanceof HashHistory) {\n    const setupHashListener = () =&gt; {\n      history.setupListeners()\n    }\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    )\n  }\n\n  &#x2F;&#x2F; 挂载了回调的cb， 每次更新路由更好更新_route\n  history.listen(route =&gt; {\n    this.apps.forEach((app) =&gt; {\n      app._route = route\n    })\n  })\n}\n</code></pre><h2>history</h2>\n<p>history一共有三个模式hash, histroy, abstract, 这三个类都继承至base类</p>\n<h3>base</h3>\n<p>我们首先看下base的构造函数, 其中router是VueRouter的实例, base是路由的基础路径。current是当前的路由默认为&quot;/&quot;, ready是路由的状态, readyCbs是ready的回调的集合, readyErrorCbs是raday失败的回调。errorCbs导航出错的回调的集合。</p>\n<pre class=\"prettyprint language-js\"><code>\nexport class History {\n  constructor (router: Router, base: ?string) {\n    this.router = router\n    &#x2F;&#x2F; normalizeBase会对base路径做出格式化的处理，会为base开头自动添加‘&#x2F;’，删除结尾的‘&#x2F;’，默认返回’&#x2F;‘\n    this.base = normalizeBase(base)\n    &#x2F;&#x2F; 初始化的当前路由对象\n    this.current = START\n    this.pending = null\n    this.ready = false\n    this.readyCbs = []\n    this.readyErrorCbs = []\n    this.errorCbs = []\n  }\n}\n</code></pre><pre class=\"prettyprint language-js\"><code>\nexport const START = createRoute(null, {\n  path: &#x27;&#x2F;&#x27;\n})\n</code></pre><pre class=\"prettyprint language-js\"><code>\nfunction normalizeBase (base: ?string): string {\n  if (!base) {\n    &#x2F;&#x2F; inBrowser判断是否为浏览器环境\n    if (inBrowser) {\n      const baseEl = document.querySelector(&#x27;base&#x27;)\n      base = (baseEl &amp;&amp; baseEl.getAttribute(&#x27;href&#x27;)) || &#x27;&#x2F;&#x27;\n      base = base.replace(&#x2F;^https?:\\&#x2F;\\&#x2F;[^\\&#x2F;]+&#x2F;, &#x27;&#x27;)\n    } else {\n      base = &#x27;&#x2F;&#x27;\n    }\n  }\n  if (base.charAt(0) !== &#x27;&#x2F;&#x27;) {\n    base = &#x27;&#x2F;&#x27; + base\n  }\n  return base.replace(&#x2F;\\&#x2F;$&#x2F;, &#x27;&#x27;)\n}\n</code></pre><p><strong>base中的listen的方法，会在VueRouter的init方法中使用到，listen会给每一次的路由的更新，添加回调</strong></p>\n<pre class=\"prettyprint language-js\"><code>\nlisten (cb: Function) {\n  this.cb = cb\n}   \n</code></pre><p>base类中还有一些其他方法比如，transitionTo，confirmTransition，updateRoute它们在base子类中被使用。我们马上在hashrouter中再看看它们的具体实现。</p>\n<h3>HashRouter</h3>\n<h4>构造函数</h4>\n<p>在HashHistory的构造函数中。我们会判断当前的fallback是否为true。如果为true，使用checkFallback，添加’#‘，并使用window.location.replace替换文档。</p>\n<p>如果fallback为false，我们会调用ensureSlash，ensureSlash会为没有“#”的url，添加“#”，并且使用histroy的API或者replace替换文档。</p>\n<p>所以我们在访问127.0.0.1的时候，会自动替换为127.0.0.1/#/</p>\n<pre class=\"prettyprint language-js\"><code>\nexport class HashHistory extends History {\n  constructor (router: Router, base: ?string, fallback: boolean) {\n    super(router, base)\n    &#x2F;&#x2F; 如果是回退hash的情况，并且判断当前路径是否有&#x2F;#&#x2F;。如果没有将会添加&#x27;&#x2F;#&#x2F;&#x27;\n    if (fallback &amp;&amp; checkFallback(this.base)) {\n      return\n    }\n    ensureSlash()\n  }\n}\n</code></pre><p>checkFallback</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; 检查url是否包含‘&#x2F;#&#x2F;’\nfunction checkFallback (base) {\n  &#x2F;&#x2F; 获取hash值\n  const location = getLocation(base)\n  &#x2F;&#x2F; 如果location不是以&#x2F;#，开头。添加&#x2F;#，使用window.location.replace替换文档\n  if (!&#x2F;^\\&#x2F;#&#x2F;.test(location)) {\n    window.location.replace(\n      cleanPath(base + &#x27;&#x2F;#&#x27; + location)\n    )\n    return true\n  }\n}\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 返回hash\nexport function getLocation (base) {\n  let path = decodeURI(window.location.pathname)\n  if (base &amp;&amp; path.indexOf(base) === 0) {\n    path = path.slice(base.length)\n  }\n  return (path || &#x27;&#x2F;&#x27;) + window.location.search + window.location.hash\n}\n</code></pre><pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; 删除 &#x2F;&#x2F;, 替换为 &#x2F;\nexport function cleanPath (path) {\n  return path.replace(&#x2F;\\&#x2F;\\&#x2F;&#x2F;g, &#x27;&#x2F;&#x27;)\n}\n</code></pre><p>ensureSlash</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction ensureSlash (): boolean {\n  &#x2F;&#x2F; 判断是否包含#，并获取hash值。如果url没有#，则返回‘’\n  const path = getHash()\n  &#x2F;&#x2F; 判断path是否以&#x2F;开头\n  if (path.charAt(0) === &#x27;&#x2F;&#x27;) {\n    return true\n  }\n  &#x2F;&#x2F; 如果开头不是‘&#x2F;’, 则添加&#x2F;\n  replaceHash(&#x27;&#x2F;&#x27; + path)\n  return false\n}\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 获取“#”后面的hash\nexport function getHash (): string {\n  const href = window.location.href\n  const index = href.indexOf(&#x27;#&#x27;)\n  return index === -1 ? &#x27;&#x27; : decodeURI(href.slice(index + 1))\n}\n</code></pre><pre class=\"prettyprint language-js\"><code>function replaceHash (path) {\n  &#x2F;&#x2F; supportsPushState判断是否存在history的API\n  &#x2F;&#x2F; 使用replaceState或者window.location.replace替换文档\n  &#x2F;&#x2F; getUrl获取完整的url\n  if (supportsPushState) {\n    replaceState(getUrl(path))\n  } else {\n    window.location.replace(getUrl(path))\n  }\n}\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; getUrl返回了完整了路径，并且会添加#, 确保存在&#x2F;#&#x2F;\nfunction getUrl (path) {\n  const href = window.location.href\n  const i = href.indexOf(&#x27;#&#x27;)\n  const base = i &gt;= 0 ? href.slice(0, i) : href\n  return &#96;${base}#${path}&#96;\n}\n</code></pre><p>在replaceHash中，我们调用了replaceState方法，在replaceState方法中，又调用了pushState方法。在pushState中我们会调用saveScrollPosition方法，它会记录当前的滚动的位置信息。然后使用histroyAPI，或者window.location.replace完成文档的更新。</p>\n<pre class=\"prettyprint language-js\"><code>\nexport function replaceState (url?: string) {\n  pushState(url, true)\n}\n\nexport function pushState (url?: string, replace?: boolean) {\n  &#x2F;&#x2F; 记录当前的x轴和y轴，以发生导航的时间为key，位置信息记录在positionStore中\n  saveScrollPosition()\n  const history = window.history\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, &#x27;&#x27;, url)\n    } else {\n      _key = genKey()\n      history.pushState({ key: _key }, &#x27;&#x27;, url)\n    }\n  } catch (e) {\n    window.location[replace ? &#x27;replace&#x27; : &#x27;assign&#x27;](url)\n  }\n}\n</code></pre><h4>push, replace,</h4>\n<p>我们把push，replace放在一起说，因为它们实现的源码都是类似的。在push和replace中，调用transitionTo方法，transitionTo方法在基类base中，我们现在转过头来看看transitionTo的源码(👇往下两节，<em>代码不是很难，但是callback嵌套callback, 如蜜传如蜜，看起来还是比较恶心的</em>)</p>\n<pre class=\"prettyprint language-js\"><code>\npush (location, onComplete, onAbort) {\n  const { current: fromRoute } = this\n  this.transitionTo(\n    location,\n    route =&gt; {\n      pushHash(route.fullPath)\n      handleScroll(this.router, route, fromRoute, false)\n      onComplete &amp;&amp; onComplete(route)\n    },\n    onAbort\n  )\n}\n\nreplace (location, onComplete, onAbort) {\n  const { current: fromRoute } = this\n  this.transitionTo(\n    location,\n    route =&gt; {\n      replaceHash(route.fullPath)\n      handleScroll(this.router, route, fromRoute, false)\n      onComplete &amp;&amp; onComplete(route)\n    },\n    onAbort\n  )\n}\n</code></pre><h4>transitionTo, confirmTransition, updateRoute</h4>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/14/16a1a436687810ab?w=1446&amp;h=886&amp;f=png&amp;s=107156\" alt=\"image\"></p>\n<p>transitionTo的location参数是我们的目标路径, 可以是string或者RawLocation对象。我们通过router.match方法(我们在在matcher介绍过)，router.match会返回我们的目标路由对象。紧接着我们会调用confirmTransition函数。</p>\n<pre class=\"prettyprint language-js\"><code>\ntransitionTo (location, onComplete, onAbort) {\n  const route = this.router.match(location, this.current)\n  this.confirmTransition(\n    route,\n    () =&gt; {\n      &#x2F;&#x2F; ...\n    },\n    err =&gt; {\n      &#x2F;&#x2F; ...\n    }\n  )\n}\n</code></pre><p>confirmTransition函数中会使用，isSameRoute会检测是否导航到相同的路由，如果导航到相同的路由会停止🤚导航，并执行终止导航的回调。</p>\n<pre class=\"prettyprint language-js\"><code>\nif (\n  isSameRoute(route, current) &amp;&amp;\n  route.matched.length === current.matched.length\n) {\n  this.ensureURL()\n  return abort()\n}\n</code></pre><p>接着我们调用resolveQueue方法，resolveQueue接受当前的路由和目标的路由的matched属性作为参数，resolveQueue的工作方式可以如下图所示。我们会逐一比较两个数组的路由，寻找出需要销毁的，需要更新的，需要激活的路由，并返回它们（因为我们需要执行它们不同的路由守卫）</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/14/16a1a4366883a3ce?w=1598&amp;h=662&amp;f=png&amp;s=89462\" alt=\"image\"></p>\n<pre class=\"prettyprint language-js\"><code>function resolveQueue (\n  current\n  next\n) {\n  let i\n  &#x2F;&#x2F; 依次比对当前的路由和目标的路由的matched属性中的每一个路由\n  const max = Math.max(current.length, next.length)\n  for (i = 0; i &lt; max; i++) {\n    if (current[i] !== next[i]) {\n      break\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  }\n}\n</code></pre><p>下一步，我们会逐一提取出，所有要执行的路由守卫，将它们concat到队列queue。queue里存放里所有需要在这次路由更新中执行的路由守卫。</p>\n<p>第一步，我们使用extractLeaveGuards函数，提取出deactivated中所有需要销毁的组件内的“beforeRouteLeave”的守卫。extractLeaveGuards函数中会调用extractGuards函数，extractGuards函数，会调用flatMapComponents函数，flatMapComponents函数会遍历records(<strong>resolveQueue返回deactivated</strong>), 在遍历过程中我们将组件，组件的实例，route对象，传入了fn(<strong>extractGuards中传入flatMapComponents的回调</strong>), 在fn中我们会获取组件中beforeRouteLeave守卫。</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; 返回每一个组件中导航的集合\nfunction extractLeaveGuards (deactivated) {\n  return extractGuards(deactivated, &#x27;beforeRouteLeave&#x27;, bindGuard, true)\n}\n\nfunction extractGuards (\n  records,\n  name,\n  bind,\n  reverse?\n) {\n  const guards = flatMapComponents(\n    records,\n    &#x2F;&#x2F; def为组件\n    &#x2F;&#x2F; instance为组件的实例\n    (def, instance, match, key) =&gt; {\n      &#x2F;&#x2F; 返回每一个组件中定义的路由守卫\n      const guard = extractGuard(def, name)\n      if (guard) {\n        &#x2F;&#x2F; bindGuard函数确保了guard（路由守卫）的this指向的是Component中的实例\n        return Array.isArray(guard)\n          ? guard.map(guard =&gt; bind(guard, instance, match, key))\n          : bind(guard, instance, match, key)\n      }\n    }\n  )\n  &#x2F;&#x2F; 返回导航的集合\n  return flatten(reverse ? guards.reverse() : guards)\n}\n\nexport function flatMapComponents (\n  matched,\n  fn\n) {\n  &#x2F;&#x2F; 遍历matched，并返回matched中每一个route中的每一个Component\n  return flatten(matched.map(m =&gt; {\n    &#x2F;&#x2F; 如果没有设置components则默认是components{ default: YouComponent }，可以从addRouteRecord函数中看到\n    &#x2F;&#x2F; 将每一个matched中所有的component传入fn中\n    &#x2F;&#x2F; m.components[key]为components中的key键对应的组件\n    &#x2F;&#x2F; m.instances[key]为组件的实例，这个属性是在routerview组件中beforecreated中被赋值的\n    return Object.keys(m.components).map(key =&gt; fn(\n      m.components[key],\n      m.instances[key],\n      m,\n      key\n    ))\n  }))\n}\n\n&#x2F;&#x2F; 返回一个新数组\nexport function flatten (arr) {\n  return Array.prototype.concat.apply([], arr)\n}\n\n&#x2F;&#x2F; 获取组件中的属性\nfunction extractGuard (def, key) {\n  if (typeof def !== &#x27;function&#x27;) {\n    def = _Vue.extend(def)\n  }\n  return def.options[key]\n}\n\n&#x2F;&#x2F; 修正函数的this指向\nfunction bindGuard (guard, instance) {\n  if (instance) {\n    return function boundRouteGuard () {\n      return guard.apply(instance, arguments)\n    }\n  }\n}\n</code></pre><p>第二步，获取全局VueRouter对象beforeEach的守卫</p>\n<p>第三步, 使用extractUpdateHooks函数，提取出update组件中所有的beforeRouteUpdate的守卫。过程同第一步类似。</p>\n<p>第四步, 获取activated的options配置中beforeEach守卫</p>\n<p>第五部, 获取所有的异步组件</p>\n<hr>\n<p>在获取所有的路由守卫后我们定义了一个迭代器iterator。接着我们使用runQueue遍历queue队列。将queue队列中每一个元素传入fn(<strong>迭代器iterator</strong>)中，在迭代器中会执行路由守卫，并且路由守卫中必须明确的调用next方法才会进入下一个管道，进入下一次迭代。迭代完成后，会执行runQueue的callback。</p>\n<p>在runQueue的callback中，我们获取激活组件内的beforeRouteEnter的守卫，并且将beforeRouteEnter守卫中next的回调存入postEnterCbs中，在导航被确认后遍历postEnterCbs执行next的回调。</p>\n<p>在queue队列执行完成后，confirmTransition函数会执行transitionTo传入的onComplete的回调。往下看👇</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; queue为路由守卫的队列\n&#x2F;&#x2F; fn为定义的迭代器\nexport function runQueue (queue, fn, cb) {\n  const step = index =&gt; {\n    if (index &gt;= queue.length) {\n      cb()\n    } else {\n      if (queue[index]) {\n        &#x2F;&#x2F; 使用迭代器处理每一个钩子\n        &#x2F;&#x2F; fn是迭代器\n        fn(queue[index], () =&gt; {\n          step(index + 1)\n        })\n      } else {\n        step(index + 1)\n      }\n    }\n  }\n  step(0)\n}\n\n&#x2F;&#x2F; 迭代器\nconst iterator = (hook, next) =&gt; {\n  if (this.pending !== route) {\n    return abort()\n  }\n  try {\n    &#x2F;&#x2F; 传入路由守卫三个参数，分别分别对应to，from，next\n    hook(route, current, (to: any) =&gt; {\n      if (to === false || isError(to)) {\n        &#x2F;&#x2F; 如果next的参数为false\n        this.ensureURL(true)\n        abort(to)\n      } else if (\n        &#x2F;&#x2F; 如果next需要重定向到其他路由\n        typeof to === &#x27;string&#x27; ||\n        (typeof to === &#x27;object&#x27; &amp;&amp; (\n          typeof to.path === &#x27;string&#x27; ||\n          typeof to.name === &#x27;string&#x27;\n        ))\n      ) {\n        abort()\n        if (typeof to === &#x27;object&#x27; &amp;&amp; to.replace) {\n          this.replace(to)\n        } else {\n          this.push(to)\n        }\n      } else {\n        &#x2F;&#x2F; 进入下个管道\n        next(to)\n      }\n    })\n  } catch (e) {\n    abort(e)\n  }\n}\n\nrunQueue(\n  queue,\n  iterator,\n  () =&gt; {\n    const postEnterCbs = []\n    const isValid = () =&gt; this.current === route\n    &#x2F;&#x2F; 获取所有激活组件内部的路由守卫beforeRouteEnter，组件内的beforeRouteEnter守卫，是无法获取this实例的\n    &#x2F;&#x2F; 因为这时激活的组件还没有创建，但是我们可以通过传一个回调给next来访问组件实例。\n    &#x2F;&#x2F; beforeRouteEnter (to, from, next) {\n    &#x2F;&#x2F;   next(vm =&gt; {\n    &#x2F;&#x2F;     &#x2F;&#x2F; 通过 &#96;vm&#96; 访问组件实例\n    &#x2F;&#x2F;   })\n    &#x2F;&#x2F; }\n    const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)\n    &#x2F;&#x2F; 获取全局的beforeResolve的路由守卫\n    const queue = enterGuards.concat(this.router.resolveHooks)\n    &#x2F;&#x2F; 再一次遍历queue\n    runQueue(queue, iterator, () =&gt; {\n      &#x2F;&#x2F; 完成过渡\n      if (this.pending !== route) {\n        return abort()\n      }\n      &#x2F;&#x2F; 正在过渡的路由设置为null\n      this.pending = null\n      &#x2F;&#x2F; \n      onComplete(route)\n      &#x2F;&#x2F; 导航被确认后，我们执行beforeRouteEnter守卫中，next的回调\n      if (this.router.app) {\n        this.router.app.$nextTick(() =&gt; {\n          postEnterCbs.forEach(cb =&gt; { cb() })\n        })\n      }\n    }\n  )\n})\n\n&#x2F;&#x2F; 获取组件中的beforeRouteEnter守卫\nfunction extractEnterGuards (\n  activated,\n  cbs,\n  isValid\n) {\n  return extractGuards(activated, &#x27;beforeRouteEnter&#x27;, (guard, _, match, key) =&gt; {\n    &#x2F;&#x2F; 这里没有修改guard（守卫）中this的指向\n    return bindEnterGuard(guard, match, key, cbs, isValid)\n  })\n}\n\n&#x2F;&#x2F; 将beforeRouteEnter守卫中next的回调push到postEnterCbs中\nfunction bindEnterGuard (\n  guard,\n  match,\n  key,\n  cbs,\n  isValid\n) {\n  &#x2F;&#x2F; 这里的next参数是迭代器中传入的参数\n  return function routeEnterGuard (to, from, next) {\n    return guard(to, from, cb =&gt; {\n      &#x2F;&#x2F; 执行迭代器中传入的next，进入下一个管道\n      next(cb)\n      if (typeof cb === &#x27;function&#x27;) {\n        &#x2F;&#x2F; 我们将next的回调包装后保存到cbs中，next的回调会在导航被确认的时候执行回调\n        cbs.push(() =&gt; {\n          poll(cb, match.instances, key, isValid)\n        })\n      }\n    })\n  }\n}\n</code></pre><p>在confirmTransition的onComplete回调中，我们调用updateRoute方法, 参数是导航的路由。在updateRoute中我们会更新当前的路由(<strong>history.current</strong>), 并执行cb(<strong>更新Vue实例上的_route属性，🌟这会触发RouterView的重新渲染</strong>）</p>\n<pre class=\"prettyprint language-js\"><code>\nupdateRoute (route: Route) {\n  const prev = this.current\n  this.current = route\n  this.cb &amp;&amp; this.cb(route)\n  &#x2F;&#x2F; 执行after的钩子\n  this.router.afterHooks.forEach(hook =&gt; {\n    hook &amp;&amp; hook(route, prev)\n  })\n}\n</code></pre><p>接着我们执行transitionTo的回调函数onComplete。在回调中会调用replaceHash或者pushHash方法。它们会更新location的hash值。如果兼容historyAPI，会使用history.replaceState或者history.pushState。如果不兼容historyAPI会使用window.location.replace或者window.location.hash。而handleScroll方法则是会更新我们的滚动条的位置我们这里就不在细说了。</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; replaceHash方法\n(route) =&gt; {\n  replaceHash(route.fullPath)\n  handleScroll(this.router, route, fromRoute, false)\n  onComplete &amp;&amp; onComplete(route)\n}\n\n&#x2F;&#x2F; push方法\nroute =&gt; {\n  pushHash(route.fullPath)\n  handleScroll(this.router, route, fromRoute, false)\n  onComplete &amp;&amp; onComplete(route)\n}\n</code></pre><p>好了，现在我们就把，replace或者push方法的流程说完了。</p>\n<p>🎉🎉🎉🎉🎉🎉 以下是transitionTo，confirmTransition中完整的代码。 🎉🎉🎉🎉🎉🎉</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; onComplete 导航成功的回调\n&#x2F;&#x2F; onAbort 导航终止的回调\ntransitionTo (location, onComplete, onAbort) {\n  const route = this.router.match(location, this.current)\n  this.confirmTransition(route,\n    () =&gt; {\n      this.updateRoute(route)\n      onComplete &amp;&amp; onComplete(route)\n      this.ensureURL()\n      if (!this.ready) {\n        this.ready = true\n        this.readyCbs.forEach(cb =&gt; { cb(route) })\n      }\n    },\n    err =&gt; {\n      if (onAbort) {\n        onAbort(err)\n      }\n      if (err &amp;&amp; !this.ready) {\n        this.ready = true\n        this.readyErrorCbs.forEach(cb =&gt; { cb(err) })\n      }\n    }\n  )\n}\n\n&#x2F;&#x2F; onComplete 导航成功的回调\n&#x2F;&#x2F; onAbort 导航终止的回调\nconfirmTransition (route: Route, onComplete: Function, onAbort?: Function) {\n\n  &#x2F;&#x2F; 当前的路由\n  const current = this.current\n\n  const abort = err =&gt; {\n    if (isError(err)) {\n      if (this.errorCbs.length) {\n        this.errorCbs.forEach(cb =&gt; { cb(err) })\n      }\n    }\n    onAbort &amp;&amp; onAbort(err)\n  }\n  \n  &#x2F;&#x2F; 判断是否导航到相同的路由，如果是我们终止导航\n  if (\n    isSameRoute(route, current) &amp;&amp;\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL()\n    return abort()\n  }\n\n  &#x2F;&#x2F; 获取所有需要激活，更新，销毁的路由\n  const {\n    updated,\n    deactivated,\n    activated\n  } = resolveQueue(this.current.matched, route.matched)\n\n  &#x2F;&#x2F; 获取所有需要执行的路由守卫\n  const queue = [].concat(\n    extractLeaveGuards(deactivated),\n    this.router.beforeHooks,\n    extractUpdateHooks(updated), \n    activated.map(m =&gt; m.beforeEnter),\n    resolveAsyncComponents(activated)\n  )\n\n  this.pending = route\n\n  &#x2F;&#x2F; 定义迭代器\n  const iterator = (hook: NavigationGuard, next) =&gt; {\n    if (this.pending !== route) {\n      return abort()\n    }\n    try {\n      hook(route, current, (to: any) =&gt; {\n        if (to === false || isError(to)) {\n          this.ensureURL(true)\n          abort(to)\n        } else if (\n          typeof to === &#x27;string&#x27; ||\n          (typeof to === &#x27;object&#x27; &amp;&amp; (\n            typeof to.path === &#x27;string&#x27; ||\n            typeof to.name === &#x27;string&#x27;\n          ))\n        ) {\n          abort()\n          if (typeof to === &#x27;object&#x27; &amp;&amp; to.replace) {\n            this.replace(to)\n          } else {\n            this.push(to)\n          }\n        } else {\n          next(to)\n        }\n      })\n    } catch (e) {\n      abort(e)\n    }\n  }\n\n  &#x2F;&#x2F; 迭代所有的路由守卫\n  runQueue(\n    queue,\n    iterator, \n    () =&gt; {\n      const postEnterCbs = []\n      const isValid = () =&gt; this.current === route\n      const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)\n      const queue = enterGuards.concat(this.router.resolveHooks)\n      runQueue(queue, iterator, () =&gt; {\n        if (this.pending !== route) {\n          return abort()\n        }\n        this.pending = null\n        onComplete(route)\n        if (this.router.app) {\n          this.router.app.$nextTick(() =&gt; {\n            postEnterCbs.forEach(cb =&gt; { cb() })\n          })\n        }\n      }\n    )\n  })\n}\n</code></pre><h4>go, forward, back</h4>\n<p>在VueRouter上定义的go，forward，back方法都是调用history的属性的go方法</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; index.js\n\ngo (n) {\n  this.history.go(n)\n}\n\nback () {\n  this.go(-1)\n}\n\nforward () {\n  this.go(1)\n}\n</code></pre><p>而hash上go方法调用的是history.go，它是如何更新RouteView的呢？答案是hash对象在setupListeners方法中添加了对popstate或者hashchange事件的监听。在事件的回调中会触发RoterView的更新</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; go方法调用history.go\ngo (n) {\n  window.history.go(n)\n}\n</code></pre><h4>setupListeners</h4>\n<p>我们在通过点击后退, 前进按钮或者调用back, forward, go方法的时候。我们没有主动更新_app.route和current。我们该如何触发RouterView的更新呢？通过在window上监听popstate，或者hashchange事件。在事件的回调中，调用transitionTo方法完成对_route和current的更新。</p>\n<p>或者可以这样说，在使用push，replace方法的时候，hash的更新在_route更新的后面。而使用go, back时，hash的更新在_route更新的前面。</p>\n<pre class=\"prettyprint language-js\"><code>\nsetupListeners () {\n  const router = this.router\n\n  const expectScroll = router.options.scrollBehavior\n  const supportsScroll = supportsPushState &amp;&amp; expectScroll\n\n  if (supportsScroll) {\n    setupScroll()\n  }\n\n  window.addEventListener(supportsPushState ? &#x27;popstate&#x27; : &#x27;hashchange&#x27;, () =&gt; {\n    const current = this.current\n    if (!ensureSlash()) {\n      return\n    }\n    this.transitionTo(getHash(), route =&gt; {\n      if (supportsScroll) {\n        handleScroll(this.router, route, current, true)\n      }\n      if (!supportsPushState) {\n        replaceHash(route.fullPath)\n      }\n    })\n  })\n}\n</code></pre><h3>HistoryRouter</h3>\n<p>HistoryRouter的实现基本于HashRouter一致。差异在于\bHistoryRouter不会做一些容错处理，不会判断当前环境是否支持historyAPI。默认监听popstate事件，默认使用histroyAPI。感兴趣的同学可以看/history/html5.js中关于HistoryRouter的定义。</p>\n<h2>组件</h2>\n<h3>RouterView</h3>\n<p>RouterView是可以互相嵌套的，RouterView依赖了parent.$route属性，parent.$route即this._routerRoot._route。我们使用Vue.util.defineReactive将_router设置为响应式的。在transitionTo的回调中会更新_route, 这会触发RouteView的渲染。(渲染机制目前不是很了解，目前还没有看过Vue的源码，猛男落泪)。</p>\n<pre class=\"prettyprint language-js\"><code>export default {\n  name: &#x27;RouterView&#x27;,\n  functional: true,\n  &#x2F;&#x2F; RouterView的name, 默认是default\n  props: {\n    name: {\n      type: String,\n      default: &#x27;default&#x27;\n    }\n  },\n  render (_, { props, children, parent, data }) {\n    data.routerView = true\n\n    &#x2F;&#x2F; h为渲染函数\n    const h = parent.$createElement\n    const name = props.name\n    const route = parent.$route\n    const cache = parent._routerViewCache || (parent._routerViewCache = {})\n\n    let depth = 0\n    let inactive = false\n    &#x2F;&#x2F; 使用while循环找到Vue的根节点, _routerRoot是Vue的根实例\n    &#x2F;&#x2F; depth为当前的RouteView的深度，因为RouteView可以互相嵌套，depth可以帮组我们找到每一级RouteView需要渲染的组件\n    while (parent &amp;&amp; parent._routerRoot !== parent) {\n      if (parent.$vnode &amp;&amp; parent.$vnode.data.routerView) {\n        depth++\n      }\n      if (parent._inactive) {\n        inactive = true\n      }\n      parent = parent.$parent\n    }\n    data.routerViewDepth = depth\n\n    if (inactive) {\n      return h(cache[name], data, children)\n    }\n\n    const matched = route.matched[depth]\n    if (!matched) {\n      cache[name] = null\n      return h()\n    }\n\n    &#x2F;&#x2F; 获取到渲染的组件\n    const component = cache[name] = matched.components[name]\n\n    &#x2F;&#x2F; registerRouteInstance会在beforeCreated中调用，又全局的Vue.mixin实现\n    &#x2F;&#x2F; 在matched.instances上注册组件的实例, 这会帮助我们修正confirmTransition中执行路由守卫中内部的this的指向\n    data.registerRouteInstance = (vm, val) =&gt; {\n      const current = matched.instances[name]\n      if (\n        (val &amp;&amp; current !== vm) ||\n        (!val &amp;&amp; current === vm)\n      ) {\n        matched.instances[name] = val\n      }\n    }\n\n    ;(data.hook || (data.hook = {})).prepatch = (_, vnode) =&gt; {\n      matched.instances[name] = vnode.componentInstance\n    }\n\n    let propsToPass = data.props = resolveProps(route, matched.props &amp;&amp; matched.props[name])\n    if (propsToPass) {\n      propsToPass = data.props = extend({}, propsToPass)\n      const attrs = data.attrs = data.attrs || {}\n      for (const key in propsToPass) {\n        if (!component.props || !(key in component.props)) {\n          attrs[key] = propsToPass[key]\n          delete propsToPass[key]\n        }\n      }\n    }\n    &#x2F;&#x2F; 渲染组件\n    return h(component, data, children)\n  }\n}\n</code></pre><h2>结语</h2>\n<p>我们把VueRouter源码看完了。总体来说不是很复杂。<strong>总的来说就是使用Vue.util.defineReactive将实例的_route属性设置为响应式。而push, replace方法会主动更新属性_route。而go，back，或者点击前进后退的按钮则会在onhashchange或者onpopstate的回调中更新_route，而_route的更新会触发RoterView的重新渲染</strong></p>\n<p>但是也略过了比如keep-live，滚动行为的处理。我打算接下来，结合VueRouter核心原理实现了一个简易版的<a href=\"https://github.com/BengBu-YueZhang/very-simple-router\">VueRouter</a>,当然现在还没有开始。</p>\n<h2>其他</h2>\n<p>从3月中下旬左右一直在学一些库的源码，本身学习源码对工作帮助并不是很大。因为像VueRouter，Preact都有着完善的文档。看源码单纯是个人的兴趣，不过学习了这些库的源码，自己实现一个简易版本，还是挺有成就感的一件事情。</p>\n<p><a href=\"https://juejin.im/post/5ca97d60f265da24d5070613\">Preact源码分析</a></p>\n<p><a href=\"https://github.com/BengBu-YueZhang/very-simple-react\">简易的React的实现</a></p>\n</div>","title":"VueRouter源码分析","last_reply_at":"2019-04-17T11:47:41.389Z","good":false,"top":false,"reply_count":0,"visit_count":393,"create_at":"2019-04-17T11:47:41.389Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{"id":"5cb6e230a86ae80ce64b03e6","author_id":"5905f959782dbc4b183ecf41","tab":"ask","content":"<div class=\"markdown-text\"><p>今天发现，不同用户之间或多个请求之间阻塞了，这样就不能并发了。如下面的代码，延迟5秒模拟数据库</p>\n<pre class=\"prettyprint\"><code>const Koa = require(&#x27;koa&#x27;);\nconst app = new Koa();\n\napp.use(async ctx =&gt; {\n  return new Promise(resolve =&gt; {\n    setTimeout(() =&gt; {\n      ctx.body = &#x27;Hello Koa&#x27;;\n      resolve()\n    }, 5000)\n  })\n});\napp.listen(3002);\n</code></pre><p>浏览器同时开启两个标签页，一个用时5.01秒，另一个9.72秒。很明显后面的被前面的阻塞了。所以我想问怎么写才能两个都5秒？\n还有一点，为什么第二个不是大于10秒？\n不是很清楚，希望大家解答</p>\n</div>","title":"node服务器，代码怎么写请求不会互相阻塞？","last_reply_at":"2019-04-17T09:29:27.625Z","good":false,"top":false,"reply_count":7,"visit_count":565,"create_at":"2019-04-17T08:22:08.566Z","author":{"loginname":"ooooevan","avatar_url":"https://avatars2.githubusercontent.com/u/25603236?v=4&s=120"}},{"id":"5c73d9c2ab86b86ddf6b2b4a","author_id":"51f0f267f4963ade0e08f503","tab":"share","content":"<div class=\"markdown-text\"><p>更灵活的机动、更快的效率、更高的产能\nServerless - 解放的不仅仅是生产力，更是一种全新的思维方式。</p>\n<p>百姓网 Hax、上线了郭达峰、ThoughtWorks 陈欢、阿里云杜万、淘宝冰森等优秀分享者，\n期待与你一起进入嗨翻 server 的新场景。</p>\n<p><img src=\"//static.cnodejs.org/FlbUfz7IHVgS4DwmjSrXKiL9fMRl\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FlDAitTvYWpWsudI8VGjfjGGXYRr\" alt=\"image.png\"></p>\n<p>时间：03 月 16 日周六\n地点：上海证大五道口广场</p>\n<p>报名链接：<a href=\"https://survey.alibaba.com/apps/zhiliao/tZc2WjLe2\">https://survey.alibaba.com/apps/zhiliao/tZc2WjLe2</a>\n活动主页：<a href=\"https://taobaofed.github.io/nodejs-club/\">https://taobaofed.github.io/nodejs-club/</a></p>\n</div>","title":"Node 地下铁第八期「上海站」线下沙龙邀约 - Let's Go Serverless!","last_reply_at":"2019-04-17T09:15:15.569Z","good":false,"top":false,"reply_count":45,"visit_count":8796,"create_at":"2019-02-25T12:04:18.826Z","author":{"loginname":"lellansin","avatar_url":"https://avatars2.githubusercontent.com/u/2081487?v=4&s=120"}},{"id":"5c81c18f5b8cb21491ca70b4","author_id":"53e1802fbd3cc3e50ba9e311","tab":"share","content":"<div class=\"markdown-text\"><p>这几天为 Deno 开发了一个 VS Code 插件：<a href=\"https://marketplace.visualstudio.com/items?itemName=justjavac.vscode-deno\">Deno support for VSCode</a>，GitHub 地址：<a href=\"https://github.com/justjavac/vscode-deno\">https://github.com/justjavac/vscode-deno</a>。</p>\n<p>自 Deno 发布以来就备受关注，也有很多媒体和开发者称 Deno 为“下一代 Node.js”。然而 Deno 的目标则是不兼容 Node.js，没有 npm，没有 package.json。</p>\n<p>Deno 的目标旨在提供一个兼容浏览器的平台，因此 Deno 可以像浏览器的 ES Modules 那样，通过 URL 加载模块:</p>\n<pre class=\"prettyprint language-js\"><code>import * as log from &quot;https:&#x2F;&#x2F;deno.land&#x2F;x&#x2F;std&#x2F;log&#x2F;mod.ts&quot;;\n</code></pre><p>而且在加载模块时<strong>不能省略扩展名</strong>。</p>\n<p>但是，目前的所有开发工具都是为 Node.js 而构建的。在 TypeScript 中，我们不需要添加 <code>.ts</code> 扩展名。如果我们添加了，VS Code 会给我们一个错误提示：</p>\n<blockquote>\n<p>ts(2691): An import path cannot end with a ‘.ts’ extension. Consider importing ‘./hello’ instead.</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/FmViYchU4wYG_7g9TSyHllRUtDzQ\" alt=\"ts-error-2691\"></p>\n<p>而另一个问题则是，Deno 可以加载远程模块，但是 TypeScript 却不行。比如上面的代码，也是会报错的：</p>\n<blockquote>\n<p>ts(2307): Cannot find module ‘<a href=\"https://deno.land/x/std/log/mod\">https://deno.land/x/std/log/mod</a>’.</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/FsbcG1h3loRuD1WHlZuudPuiG4-I\" alt=\"ts-error-2307\"></p>\n<p>而这个插件正是为了解决这 2 个问题。</p>\n<p>但是这两个错误不是 VS Code 提供了，而是 TypeScript 的编译器 tsc 提供的，因此需要修改 tsc 的功能。好消息是，TypeScript 从 2.3 开始便支持了 <a href=\"https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin\">Language Service Plugin</a>，这个功能仅能增强编辑体验，无法改变 TypeScript 核心行为（比如改变类型检查行为）或增加新特性（比如提供一种新语法或者）。通过查看 Language Service Plugin 的说明文件，这个功能正是我需要的。</p>\n<p>所以在写这个 VS Code 插件之前，我又为 TypeScript 写了一个插件：<a href=\"https://github.com/justjavac/typescript-deno-plugin\">typescript-deno-plugin</a>。这个插件不仅可以用在 VS Code，还可以用在任何支持 TypeScript 的编辑器，比如 Atom、Visual Studio、WebStorm 等。</p>\n<p>VS Code 插件提供了开箱即用的 Deno 支持，开发者不需要任何配置，但是有一个前提是：开发者需要使用 VS Code 内置的 TypeScript。如果你在项目中自行安装了 TypeScript，并且修改了 VS Code 的配置，使用了自己安装的版本，则需要自行安装配置 <a href=\"https://github.com/justjavac/typescript-deno-plugin\">typescript-deno-plugin</a> 插件。通过修改 <code>tsconfig.json</code> 的 <code>plugins</code>：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;compilerOptions&quot;: {\n    &quot;plugins&quot;: [\n      {\n        &quot;name&quot;: &quot;typescript-deno-plugin&quot;\n      }\n    ]\n  }\n}\n</code></pre><p>如果你正在打算学习 Deno 的开发，可以通过这个链接 <a href=\"https://marketplace.visualstudio.com/items?itemName=justjavac.vscode-deno\">Deno support for VSCode</a> 安装插件。</p>\n<p>祝，开发愉快。</p>\n</div>","title":"我为 Deno 开发了一个 VS Code 插件","last_reply_at":"2019-04-17T06:43:57.402Z","good":true,"top":false,"reply_count":7,"visit_count":2207,"create_at":"2019-03-08T01:12:47.402Z","author":{"loginname":"justjavac","avatar_url":"https://avatars1.githubusercontent.com/u/359395?v=4&s=120"}},{"id":"5c769cd4ab86b86ddf6b387a","author_id":"5a0dbddde2f4b8ea224964b6","tab":"share","content":"<div class=\"markdown-text\"><p>最近平时有空了也学习学习Node.js，在codejs平台也有一些不错的教程，同时也发现平台有提供开放的 <a href=\"https://cnodejs.org/api\">API</a> 给开发者们。平时工作主要做小程序，于是乎就想运用cnode平台提供的API来做一个下程序客户端。</p>\n<p>之前也有尝试过写过，不过感觉体验很不好，这次重新弄了一个新的，界面干净了很多，资讯嘛还是以内容为主。希望能够帮助到大家，共同学习共同进步。写的比较仓促，样式参考、数据请求处理，差不多用了1天的时间。目前只用到了<strong>get /topics 主题首页</strong> 和 <strong>get /topic/:id 主题详情</strong>。也就是列表和详情页，后续也会陆续更新，不断完善。</p>\n<p><strong>Node随心阅</strong>微信小程序码：</p>\n<p><img src=\"//static.cnodejs.org/Fjd6d5yI8pZ4SPqliGmhUzjRIuW2\" alt=\"gh_26ff2b7c5db7_258.jpg\"></p>\n<p>该微信小程序的开发没有使用第三方框架，直接使用的是微信小程序原生的方式来开发的。参考文档为微信小程序官方开发文档，第一版(v1.0.01)主要的功能点：</p>\n<ul>\n<li>\n<p>首页</p>\n<ol>\n<li>列表展示</li>\n<li>类别切换（点击分类可选择全部分类、精华、问答、招聘）</li>\n<li>点击右上角将当前类别列表分享给好友</li>\n<li>下拉刷新、上拉加载</li>\n</ol>\n</li>\n<li>\n<p>详情页</p>\n<ol>\n<li>内容展示</li>\n<li>用户回复列表</li>\n<li>分享好友。 详情页的分享路径用户打开有个重定向的过程，这样可以保证被分享者打开后可以返回到首页列表。</li>\n</ol>\n</li>\n</ul>\n<p>后续也会慢慢优化和改善相关的体验，同时也慢慢添加一些新的功能点，不多学习和完善。</p>\n<p>免责申明： 此小程序为业余以学习为目的开发，不属于官方小程序客户端。如有相关问题请告知开发者，联系方式：</p>\n<p>微信:  <a href=\"#\">aoxiaoqiang001</a></p>\n<p>Email:  <a href=\"mailto:aoxiaoqiang@163.com\">aoxiaoqiang@163.com</a></p>\n<hr>\n<p>PS： 最近也基于此小程序开发、维护了一个“足球教练社区”的小程序，欢迎大家体验。发现Bug可及时在下方留言反馈，感谢。</p>\n<p><strong>足球教练社区</strong>微信小程序码：\n<img src=\"//static.cnodejs.org/FjspD4pvMKjNz3z-xfLuSDan7X9l\" alt=\"image.png\"></p>\n</div>","title":"CNode 社区微信小程序客户端","last_reply_at":"2019-04-17T06:14:10.763Z","good":false,"top":false,"reply_count":13,"visit_count":1866,"create_at":"2019-02-27T14:21:08.196Z","author":{"loginname":"aoxiaoqiang","avatar_url":"https://avatars1.githubusercontent.com/u/17998436?v=4&s=120"}},{"id":"5b5e78f5673571454c633cea","author_id":"5b56866ae740336c7bedb345","tab":"share","content":"<div class=\"markdown-text\"><p><strong>koa2实战项目介绍（真全栈）：</strong></p>\n<p><strong>Nodejs+koa2实战视频教程</strong>从零开始一步一步让你学会Koa基础以及用用<strong>Koa开发项目</strong>，本教程涉及 用户权限判断 、<strong>验证码</strong> 、分页、多级分类、<strong>ueditor可视化富文本编辑器</strong>、图片上传、<strong>底层DB库封装</strong>、<strong>扩展art-template的核心方法、<strong>ajax改变状态、ajax排序、以及赠送的</strong>Socket.io机器人</strong> 、Socket.io多人聊天室、<strong>Socket.io群聊</strong>、前后端分离 <strong>RESTful API Api</strong>接口、购买域名 服务器、域名备案、<strong>nginx负载均衡</strong>、<strong>域名解析部署nodejs程序</strong>、Nodejs进程管理器pm2模块、Koa操作<strong>mysql数据库</strong></p>\n<p><strong>地址：</strong> <a href=\"https://www.itying.com/goods-800.html\">Koa2实战视频教程下载地址点我</a></p>\n<p><strong>2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址（41讲免费基础下载地址）：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w</a></p>\n</div>","title":"Nodejs+koa2实战视频教程【87讲】--Koa2+Nodejs+MongoDb打造企业级CMS前后端全栈项目实战视频教程","last_reply_at":"2019-04-17T01:48:48.609Z","good":false,"top":false,"reply_count":80,"visit_count":16571,"create_at":"2018-07-30T02:33:25.113Z","author":{"loginname":"songsunli","avatar_url":"https://avatars1.githubusercontent.com/u/41601667?v=4&s=120"}},{"id":"5c91da248a587f26b426cd1b","author_id":"55a8ba4c0b9ddb895675df3a","tab":"ask","content":"<div class=\"markdown-text\"><p>把所有东西都放在ctx上面，这样真的合理吗？</p>\n</div>","title":"Egg这样的设计真的合理吗，把所有东西都放在ctx上面","last_reply_at":"2019-04-17T01:45:11.065Z","good":false,"top":false,"reply_count":20,"visit_count":1812,"create_at":"2019-03-20T06:13:56.281Z","author":{"loginname":"luluzero","avatar_url":"https://avatars1.githubusercontent.com/u/10164939?v=4&s=120"}},{"id":"5bc000d015e4fd1923f48e3f","author_id":"5b2a0c5029e6e510415b2c0f","tab":"share","content":"<div class=\"markdown-text\"><p>Node.js初中高级全栈高清视频教程、全栈工程师项目实战开发基础视频教程，带你从入门到精通！</p>\n<p>01【基础】Node：nodejs快速进阶（版本4.1.0）\n<img src=\"//static.cnodejs.org/FmZ2l1AiKERlqpJJxo_GnjRtmpvK\" alt=\"2.jpg\"></p>\n<p>02【实战】node.js从入门到实战教育项目(版本v6.9.1)\n<img src=\"//static.cnodejs.org/FhH4Dh-K7d4a31xfLSm_jWS1iD4r\" alt=\"3.jpg\"></p>\n<p>03【实战】Nodejs+ES6+Webpack+Vuejs构建大型商城（版本6.10.3）\n<img src=\"//static.cnodejs.org/FvoBxx8AMU3KobeIgENDY2vi9OPj\" alt=\"4.jpg\">\n下载地址：<a href=\"http://www.sucaihuo.com/video/387.html\">http://www.sucaihuo.com/video/387.html</a></p>\n</div>","title":"Node.js初中高级全栈高清视频教程","last_reply_at":"2019-04-17T01:18:15.845Z","good":false,"top":false,"reply_count":15,"visit_count":4585,"create_at":"2018-10-12T02:02:56.504Z","author":{"loginname":"whoknowme","avatar_url":"https://avatars0.githubusercontent.com/u/40422811?v=4&s=120"}},{"id":"5bce82227a248c7f50334c6c","author_id":"5338d96c88ed3fc55b0088cc","tab":"share","content":"<div class=\"markdown-text\"><h1>VSCode 注释翻译</h1>\n<h2>简介</h2>\n<p><a href=\"https://github.com/intellism/vscode-comment-translate\">【源码】</a> <a href=\"https://marketplace.visualstudio.com/items?itemName=intellsmi.comment-translate\">【安装】</a></p>\n<p>许多优秀的项目，都有丰富的注释，使用者可以快速理解代码意图。但是如果使用者并不熟习注释的语言，会带来理解困难。本插件使用 Google Translate API 翻译 VSCode 的编程语言的注释。</p>\n<h2>功能</h2>\n<ol>\n<li>\n<p>识别代码中注释部分，不干扰阅读。支持不同语言，单行、多行注释\n<img src=\"https://github.com/intellism/vscode-comment-translate/blob/master/doc/image/cn/Introduction.gif?raw=true\" alt=\"Introduction\"></p>\n</li>\n<li>\n<p>支持用户字符串与变量翻译,支持驼峰拆分\n<img src=\"https://github.com/intellism/vscode-comment-translate/blob/master/doc/image/cn/variable.gif?raw=true\" alt=\"Introduction\"></p>\n</li>\n<li>\n<p>选中最后一次翻译区域命令\n<img src=\"https://github.com/intellism/vscode-comment-translate/blob/master/doc/image/cn/select.gif?raw=true\" alt=\"Introduction\"></p>\n</li>\n<li>\n<p>选择区域翻译\n<img src=\"https://github.com/intellism/vscode-comment-translate/blob/master/doc/image/cn/selection.gif?raw=true\" alt=\"Introduction\"></p>\n</li>\n</ol>\n<h2>配置项</h2>\n<h4>多国语言支持</h4>\n<p>状态栏快速配置目标语言\n<img src=\"https://github.com/intellism/vscode-comment-translate/blob/master/doc/image/cn/status-bar.gif?raw=true\" alt=\"Multi-language\"></p>\n<table>\n<thead>\n<tr>\n<th>Display Language</th>\n<th>Locale</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>English (US)</td>\n<td><code>en</code></td>\n</tr>\n<tr>\n<td>Simplified Chinese</td>\n<td><code>zh-CN</code></td>\n</tr>\n<tr>\n<td>Traditional Chinese</td>\n<td><code>zh-TW</code></td>\n</tr>\n<tr>\n<td>French</td>\n<td><code>fr</code></td>\n</tr>\n<tr>\n<td>German</td>\n<td><code>de</code></td>\n</tr>\n<tr>\n<td>Italian</td>\n<td><code>it</code></td>\n</tr>\n<tr>\n<td>Spanish</td>\n<td><code>es</code></td>\n</tr>\n<tr>\n<td>Japanese</td>\n<td><code>ja</code></td>\n</tr>\n<tr>\n<td>Korean</td>\n<td><code>ko</code></td>\n</tr>\n<tr>\n<td>Russian</td>\n<td><code>ru</code></td>\n</tr>\n<tr>\n<td>Bulgarian</td>\n<td><code>bg</code></td>\n</tr>\n<tr>\n<td>Hungarian</td>\n<td><code>hu</code></td>\n</tr>\n<tr>\n<td>Portuguese (Brazil)</td>\n<td><code>pt-br</code></td>\n</tr>\n<tr>\n<td>Turkish</td>\n<td><code>tr</code></td>\n</tr>\n</tbody>\n</table>\n<h4>合并多行注释 （源语言只支持英语）</h4>\n<p><img src=\"https://github.com/intellism/vscode-comment-translate/blob/master/doc/image/multi-line-merge.gif?raw=true\" alt=\"Multi-line-merge\"></p>\n</div>","title":"推荐VSCode注释翻译插件，方便快速阅读源码","last_reply_at":"2019-04-17T01:09:05.687Z","good":false,"top":false,"reply_count":23,"visit_count":3076,"create_at":"2018-10-23T02:06:26.993Z","author":{"loginname":"intellism","avatar_url":"https://avatars3.githubusercontent.com/u/442894?v=4&s=120"}},{"id":"5cb57119ffa1ea7975a223af","author_id":"5cb56ce1ffa1ea7975a22362","tab":"ask","content":"<div class=\"markdown-text\"><h2>1.在客户端是怎么接收服务器的推送？</h2>\n<p><img src=\"//static.cnodejs.org/FiOXYxZFlf7TvEy1uPvwaG_lexJN\" alt=\"image.png\">\nnode的官方文档有实例，但是这段代码是不能运行在浏览器的，这个客户端指的不是浏览器吗？\nnode文档链接： <a href=\"http://nodejs.cn/api/http2.html\">http://nodejs.cn/api/http2.html</a>\ndart版本的相关实现模块：<a href=\"https://github.com/dart-lang/http2\">https://github.com/dart-lang/http2</a>\nnode的所有http/2的模块：<a href=\"https://github.com/http2/http2-spec/wiki/Implementations\">https://github.com/http2/http2-spec/wiki/Implementations</a>\n<img src=\"//static.cnodejs.org/Fr8zEUXHzskMmMxe12rrigp3ZAJh\" alt=\"image.png\">\n（三个模块都需要依赖与node原生http等依赖）</p>\n<p><strong>2.由这个问题引发的node的所有模块只要引入到浏览器端代码就就报错</strong>\n<img src=\"//static.cnodejs.org/Fj6FbokJtb9Y7aLZ-ABF81-0Zoti\" alt=\"image.png\">\n（图片上用的是typescript项目）\n<img src=\"//static.cnodejs.org/FqIg2AxctbaASNFq5shbkJGUvZGk\" alt=\"image.png\">\n观点：按照我的理解只要是js代码都可以在浏览器上运行（不包括ES6，浏览器不能解析的）\n结论：前端（浏览器是不能运行node的相关模块）\n猜测：node的原生模块不是js（C/C++）</p>\n</div>","title":"http/2服务端推送","last_reply_at":"2019-04-17T01:08:22.895Z","good":false,"top":false,"reply_count":4,"visit_count":819,"create_at":"2019-04-16T06:07:21.467Z","author":{"loginname":"heshuai326","avatar_url":"https://avatars3.githubusercontent.com/u/18663991?v=4&s=120"}},{"id":"5b8e207937b3005a0b0e6b50","author_id":"5b8e1ee0bf116a8c0e4257b4","tab":"ask","content":"<div class=\"markdown-text\"><p>怎么才能真正学好node.js,东西太多了，老忘记怎么办？</p>\n</div>","title":"如何才能学好node.js","last_reply_at":"2019-04-16T14:54:15.605Z","good":false,"top":false,"reply_count":37,"visit_count":6078,"create_at":"2018-09-04T06:04:41.390Z","author":{"loginname":"kouxiang2008","avatar_url":"https://avatars1.githubusercontent.com/u/42954282?v=4&s=120"}},{"id":"5ca4681f6c1de62dce4676dd","author_id":"5c91ace496558e26e1b677bd","tab":"ask","content":"<div class=\"markdown-text\"><p>在nodejs中IO操作是使用线程池进程异步操作的，那么假如我向nodejs请求读取一个大文件，是不是会持续占用线程导致降低服务器处理其他请求的能力。\n在Eggjs中有什么机制来避免大文件访问造成服务器性能下降的办法吗</p>\n</div>","title":"关于Nodejs的IO异步操作以及eggjs处理耗时任务的疑问","last_reply_at":"2019-04-16T14:52:26.379Z","good":false,"top":false,"reply_count":4,"visit_count":949,"create_at":"2019-04-03T08:00:31.009Z","author":{"loginname":"HyperClockUp","avatar_url":"https://avatars2.githubusercontent.com/u/36909196?v=4&s=120"}},{"id":"5cb20aa7dad66d658e408a65","author_id":"50b5bc5d637ffa4155091236","tab":"ask","content":"<div class=\"markdown-text\"><p>与传统cb相比的话</p>\n</div>","title":"promise与aysnc/await是否降低了开发效率？","last_reply_at":"2019-04-16T07:54:57.682Z","good":false,"top":false,"reply_count":13,"visit_count":1244,"create_at":"2019-04-13T16:13:27.109Z","author":{"loginname":"yakczh","avatar_url":"https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"}},{"id":"5b18a28557137f22415c49e9","author_id":"55d120f3b25bd72150842d85","tab":"share","content":"<div class=\"markdown-text\"><h1>前端进阶之困</h1>\n<p>最近看了不少文章和帖子， 如文：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5b124fdd5188257d6c0465da?utm_source=gold_browser_extension\">前端的焦虑，你想过30岁以后的前端路怎么走吗？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5af047150a36e5312d6ecdf0\">前端怎么一步步走向全栈呢？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5b164efa29e6e510415b2803\">移动端入门Node.js怎么学习?</a></li>\n<li><a href=\"https://cnodejs.org/topic/5a4cc04cebc575dc49b270d5\">前端的未来走向在哪里？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5ab1ebb5e7b166bb7b9eccaa\">工作2年多的前端，现在迷茫了，如何更进一步的提升自己</a></li>\n</ul>\n<p>身边和朋友圈也不少做前端开发的同事朋友问如何发展和提升\n这里我向大家给一些建议</p>\n<h2>扎实基础</h2>\n<p>首先思考下手上的工作是否做得足够好了，近几年前端技术发展迅猛各种框架层出不穷，刚学会jquery还没用熟， angular 、vue 、react 已经满大街了。\ngulp 还没明白怎么回事、webpack 已开始遍地开花了。眼花缭乱的技术不知道从哪里开始好。\n如果你还被这些困扰的话，那请静下来思考一下，技术的发展总是有规律的，学习也是有规律可循的，我的建议是，把共性和必要的技能先稳固下来，既不浪费时间，又能提高效率，如果这块还么稳固好、框架什么少看几种吧，先有一样可用的就好。\n对于加强基础一个可行的方案是，从自己上手的工作开始、除了专注现学现用工作需要的框架技术外加强基础的学习，如：</p>\n<ul>\n<li>基本的逻辑（与、或、非）</li>\n<li>运算操作（加减乘除 Math 下的各种函数）</li>\n<li>字符串处理 （什么大小写、编码、裁剪什么的）</li>\n<li>时间处理 （日期的加减、对比、格式转换等）</li>\n<li>数组、集合对象处理\n可以了解学习一些基础库 如: <a href=\"https://github.com/lodash/lodash\">lodash</a>、<a href=\"https://github.com/moment/moment\">moment</a> 等、若时间有限可以看看示例有个印象回头可以查找，当然最好的方式是实践练习。</li>\n</ul>\n<h2>发展全栈的正确姿势</h2>\n<p>Javascript 生态链对于全栈有一些优势，但全栈不是贴金的标签，如果技能不够硬，必然落得个 <strong>前端不强，后端不行</strong> 的尴尬局面。</p>\n<h3>那对于前端是不是不该发展后端呢？</h3>\n<p>回答当然是否定的，前端<em>有目的、有计划的发展后端技能</em>，对于系统全局观、工作协作能力提升是非常有帮助的，<strong>另外切实让老板愿意为你加工资是非常可能的</strong>。</p>\n<h3>那要如何才能是有目的、有计划的发展后端技能呢？</h3>\n<p>首先认清后端技能出发点和关键点。</p>\n<ul>\n<li>出发点: 是主动权和话语权（可能某个后端老是鄙视你，你要的东西，说这个没办法，那个不应该，造成了你工作很被动，效率不高，出错了可能还先找你）。</li>\n<li>关键点: 前后端接口 （如果你能清晰、标准、明确你要的接口，那么一些都会明朗起来）。\n所以我认为前端切入后端应该从接口开始。</li>\n</ul>\n<h3>从标准接口开始，什么样的接口才是标准的呢？</h3>\n<p><a href=\"https://swagger.io/resources/open-api/\">OpenAPI  Specification</a>\n这里我为大家推荐 Swagger 标准接口 (目前有两个标准 OAS 2.0 和 OAS 3.0)\nSwagger 致力于接口的标准化，并为此提供了一系列的工具，方便大家对进口进行标准化。</p>\n<h3>有什么好处呢</h3>\n<ul>\n<li>简化工作流程 (Streamline Your Workflow)。</li>\n<li>自由构建 (Restraint-Free Build)</li>\n<li>开放/全球化的支持 (Open &amp; Globally Supported)\n我的理解是增强系统的健壮性、降低沟通成本、提高写作效率，另外接口是系统的一种抽象可以更好的从宏观把握系统。</li>\n</ul>\n<h3>标准化的接口要如何实践</h3>\n<p>这里我安利下我的开源项目 <a href=\"https://github.com/vellengs/typerx\">typerx</a>, typerx 是一个轻量注解式的全栈系统、你可以使用他快速的实践接口标准的全栈开发。</p>\n<ul>\n<li>创建接口前、我们仍旧还是要考虑接口模块的、模块化的设计能降低我们一次思考的复杂度。\n在 typerx 中我们分了 core 模块和 cms 模块。</li>\n<li>接口的创建从原型开始考虑、确定接口所需的模型 model, 这个模型我们称之为 DTO(data transform object) 也就是接口的输入输出数据对象。\n<a href=\"https://github.com/vellengs/typerx/blob/master/packages/server/src/modules/core/dto\">dto 的编写示例</a></li>\n<li>有了模型之后我们就可以确定需要哪些接口方法了，编写接口的时候先不着急考虑接口的实现，我们只要先提供模型（可以建立一个按模型提供的数据mock)确保必要的接口规格描述就好，\n<a href=\"https://github.com/vellengs/typerx/blob/master/packages/server/src/modules/core/account.controller.ts\">account 的接口定义</a>\n这里我们通过直接编写代码的方式来实现文档，这样方便我们高效、可维护的接口文档（当然先完成文档再来生成代码也是可以的，不过代码能表述的永远比文档能描述的多，所以应该是有一套能够自动生成api 文档的代码来维护比较合适，过去也曾从文档开始，但文档的错漏不方便验证、而且文档维护数据模型是很累的一个事情无法动态关联重构）。</li>\n<li>按要求完成了接口定义之后，你只要轻松运行</li>\n</ul>\n<pre class=\"prettyprint\"><code>npm run build \n</code></pre><p>你就拥有标准的接口文档描述文件 swagger.json / swagger.yaml 了, 你可以使用 typerx 直接启动服务端预览接口 <a href=\"http://localhost:4700/docs\">localhost:4700</a> 或者放到在线编辑器上预览 <a href=\"http://editor.swagger.io/\">editor.swagger.io</a>;</p>\n<ul>\n<li>好了标准话的接口有了你可以保持这个接和后端的接口一致，这样就可以和后端愉快的协作了，当然如果你喜欢，直接使用 typerx 实现自己真实的后端。</li>\n</ul>\n<p>最后欢迎大家关注 <a href=\"https://github.com/vellengs/typerx\">typerx</a> 一起讨论努力进阶。</p>\n</div>","title":"前端如何进阶全栈开发","last_reply_at":"2019-04-16T06:45:09.281Z","good":false,"top":false,"reply_count":43,"visit_count":9949,"create_at":"2018-06-07T03:12:05.854Z","author":{"loginname":"vellengs","avatar_url":"https://avatars1.githubusercontent.com/u/5743338?v=4&s=120"}},{"id":"5cb521c2207b2365936ed653","author_id":"5cae89e2207b2365936ebb4f","tab":"ask","content":"<div class=\"markdown-text\"><p><strong>描述</strong>：在项目中，需要对接第三方系统（现在项目对接是医院的业务系统，如电子病历系统等）。要基于第三方系统的基础数据来做（授权或者查询病历功能），第三方系统的数据形态很可能不同。我也不确定是啥原因，总是在不断的适配第三方的系统，根据现场的问题在不断修改。</p>\n<p><strong>问题</strong>：需要怎样去采取合理的方式？还是研发怎样去做功能设计？？</p>\n</div>","title":"【请教】：项目中对接第三方系统，怎样的更好方式才能把系统稳定下来","last_reply_at":"2019-04-16T01:02:39.663Z","good":false,"top":false,"reply_count":3,"visit_count":653,"create_at":"2019-04-16T00:28:50.562Z","author":{"loginname":"qiutian00","avatar_url":"https://avatars0.githubusercontent.com/u/24382500?v=4&s=120"}},{"id":"5ca5741631010b2dfbb431d4","author_id":"595dc9f2d1d54a0a0890b4ec","tab":"ask","content":"<div class=\"markdown-text\"><p>react小白，在尝试todolist，遇到一个问题，请大家帮解个惑：\nredux里面reducer修改状态之后，react里面容器的props更新了，但是容器里面的无状态子组件却未更新，这是为什么？\n贴下代码：\n<img src=\"//static.cnodejs.org/FkR3hq8EQJZ3U527bXcuVmegcYMc\" alt=\"react_helloworld_my-hello_src_cont_1.png\">\n<img src=\"//static.cnodejs.org/FuyPLTU0RU8V_ruS__7dHXxCJTaA\" alt=\"react_helloworld_my-hello_src_cont_2.png\">\n调试现场：\n<img src=\"//static.cnodejs.org/FjjRKmDxthgE9Z4nuicXD4IrHO6g\" alt=\"2019-04-04 11_04_13-React App.png\"></p>\n</div>","title":"请教：redux修改状态后，react容器内无状态子组件数据未刷新","last_reply_at":"2019-04-16T00:46:33.363Z","good":false,"top":false,"reply_count":3,"visit_count":838,"create_at":"2019-04-04T03:03:50.168Z","author":{"loginname":"xwwscu","avatar_url":"https://avatars1.githubusercontent.com/u/8022267?v=4&s=120"}},{"id":"5cb4bb41207b2365936ed613","author_id":"5cb4b9b5dad66d658e409645","tab":"ask","content":"<div class=\"markdown-text\"><p>在node中怎么使用mongoose根据前端表单提交的数据进行更新数据库并同步重新渲染到页面中，我之前试过了可以更新数据但是不能同步渲染页面重新登录才可以，有没有大神指导一下啊，挺急的，拜托了</p>\n</div>","title":"更新数据并重新渲染","last_reply_at":"2019-04-15T17:11:29.294Z","good":false,"top":false,"reply_count":0,"visit_count":651,"create_at":"2019-04-15T17:11:29.294Z","author":{"loginname":"forever520cy","avatar_url":"https://avatars1.githubusercontent.com/u/49617584?v=4&s=120"}},{"id":"5ac478e10ab0448f0fe3f86d","author_id":"5ac3a5a437f5d1510f57c88d","tab":"ask","content":"<div class=\"markdown-text\"><p>react.js 入门真心难，太多步骤太多东西要记了</p>\n</div>","title":"React入门真难","last_reply_at":"2019-04-15T15:07:19.380Z","good":false,"top":false,"reply_count":110,"visit_count":15519,"create_at":"2018-04-04T07:04:01.663Z","author":{"loginname":"15766273878","avatar_url":"https://avatars0.githubusercontent.com/u/37205147?v=4&s=120"}},{"id":"5cb20504dad66d658e408a46","author_id":"5b1d495729e6e510415b29b0","tab":"ask","content":"<div class=\"markdown-text\"><p>let func = function(){\n\treuturn new Promise( async (resolve, reject) =&gt; {\n\t\tawait p1();\n\t})\n}\n像这种写法，把async写在这里是否合适？</p>\n</div>","title":"请教关于promise与aysnc/await混用问题","last_reply_at":"2019-04-15T14:25:03.413Z","good":false,"top":false,"reply_count":8,"visit_count":776,"create_at":"2019-04-13T15:49:24.728Z","author":{"loginname":"helloHT","avatar_url":"https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"}},{"id":"5cab070c7edd13064e053550","author_id":"5c862e877ce0df3732426edf","tab":"ask","content":"<div class=\"markdown-text\"><p>给前端一个URL地址(图片，视频，音频地址)，他们就能下载了吧，为什么还要我后端处理？</p>\n</div>","title":"上传下载问题","last_reply_at":"2019-04-15T14:00:51.589Z","good":false,"top":false,"reply_count":8,"visit_count":880,"create_at":"2019-04-08T08:32:12.490Z","author":{"loginname":"cheerApril","avatar_url":"https://avatars0.githubusercontent.com/u/38412944?v=4&s=120"}},{"id":"5cb46814207b2365936ed4c5","author_id":"5c98426500bcfd7eb2be5add","tab":"ask","content":"<div class=\"markdown-text\"><p>比如： id = [1,2,3,…] 请求一千条数据信息， 怎么做缓存。用redis</p>\n</div>","title":"mysql 批量数据请求，怎么做缓存","last_reply_at":"2019-04-15T11:16:36.133Z","good":false,"top":false,"reply_count":0,"visit_count":626,"create_at":"2019-04-15T11:16:36.133Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5cad56a67edd13064e0541ad","author_id":"548d350057fd3ae46b233487","tab":"ask","content":"<div class=\"markdown-text\"><p>本人想将NodeJS代码部署在别人的服务器上，但是担心源码泄露的问题，于是想是否有办法进行代码保护？还请各位大神指点一二。</p>\n</div>","title":"NodeJS如何进行代码保护？","last_reply_at":"2019-04-15T09:58:00.778Z","good":false,"top":false,"reply_count":15,"visit_count":1673,"create_at":"2019-04-10T02:36:22.674Z","author":{"loginname":"jiangbophd","avatar_url":"https://avatars3.githubusercontent.com/u/4505253?v=4&s=120"}},{"id":"5cb4558e207b2365936ed439","author_id":"503dfba9f767cc9a5131ac6c","tab":"ask","content":"<div class=\"markdown-text\"><p>使用 ember-intl 多语言。\n链接：<a href=\"https://github.com/ember-intl/ember-intl\">https://github.com/ember-intl/ember-intl</a></p>\n<p>使用 ember-seo-meta-tags 做 seo。\n链接：<a href=\"https://www.npmjs.com/package/ember-seo-meta-tags\">https://www.npmjs.com/package/ember-seo-meta-tags</a></p>\n<p>如何在 ember-seo-meta-tags 中使用多语言？</p>\n</div>","title":"ember seo 如何使用多语言？","last_reply_at":"2019-04-15T09:57:34.410Z","good":false,"top":false,"reply_count":0,"visit_count":321,"create_at":"2019-04-15T09:57:34.410Z","author":{"loginname":"liuxufei","avatar_url":"https://avatars3.githubusercontent.com/u/1210771?v=4&s=120"}},{"id":"5caf7754dad66d658e4081ca","author_id":"5c4b0027595cbd1e95088843","tab":"share","content":"<div class=\"markdown-text\"><p>#nestjs+typeORM后端开发web系统\n###要求熟练使用git，nestjs，typeorm，参与项目的共同开发。\n###要求一定要有nestjs+typeorm项目经验，新手勿扰。\n###要求有足够的时间来对接和开发项目\n##优先考虑个人自由职业开发人员\n##有angular material前端开发更佳。\n##项目是会员管理系统\nvx:     fengvipp</p>\n</div>","title":"外包-远程合作-nestjs+typeORM后端开发web系统","last_reply_at":"2019-04-15T09:55:51.195Z","good":false,"top":false,"reply_count":3,"visit_count":828,"create_at":"2019-04-11T17:20:20.548Z","author":{"loginname":"haishangfeng","avatar_url":"https://avatars3.githubusercontent.com/u/47029980?v=4&s=120"}},{"id":"5cb356d7dad66d658e408d2b","author_id":"5b1d495729e6e510415b29b0","tab":"ask","content":"<div class=\"markdown-text\"><p>funtion(param1,param2,async function(err, result){\n\tlet a = await p1(result);\n\t…\n\t…\n\t…\n});\n这种写法可以吗？</p>\n</div>","title":"想在回调函数里调用await，是否要将回调修饰成async","last_reply_at":"2019-04-15T09:04:34.461Z","good":false,"top":false,"reply_count":4,"visit_count":480,"create_at":"2019-04-14T15:50:47.557Z","author":{"loginname":"helloHT","avatar_url":"https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"}},{"id":"5cb34d4bdad66d658e408d00","author_id":"5b1d495729e6e510415b29b0","tab":"ask","content":"<div class=\"markdown-text\"><p>let func1 = async function(){\ntry {\n\t  let a = await p1(0);\n\t  let b = await p2(a);\nreturn Promise.resolve(b);\n} catch (error) {\nreturn Promise.reject(error);\n}\n}</p>\n<p>let func2 = async function(){\ntry {\nlet result =  await func1();\n} catch (error) {\nconsole.log(error);\n}\n}\n像这样的写法可以吗？我自己node出来的结果显示是正确的。请问还有更好的写法吗？</p>\n</div>","title":"async函数return出去的结果如何被调用的async函数的await获取？","last_reply_at":"2019-04-15T06:16:34.732Z","good":false,"top":false,"reply_count":4,"visit_count":423,"create_at":"2019-04-14T15:10:03.760Z","author":{"loginname":"helloHT","avatar_url":"https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"}},{"id":"5cb3f6eadad66d658e408ee8","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> 从内存角度理解 let 和 const 的意义。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000018854431\">JavaScript 是如何工作的：JavaScript 的内存模型</a></li>\n<li>作者：<a href=\"https://segmentfault.com/u/minnanitkong\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p>这是专门探索 JavaScript 及其所构建的组件的系列文章的第 21 篇。</p>\n<p>如果你错过了前面的章节，可以在这里找到它们：</p>\n<ol>\n<li><a href=\"https://segmentfault.com/a/1190000017352941\">JavaScript 是如何工作的：引擎，运行时和调用堆栈的概述！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017369465\">JavaScript 是如何工作的：深入 V8 引擎&amp;编写优化代码的 5 个技巧！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017392370\">JavaScript 是如何工作的：内存管理+如何处理 4 个常见的内存泄漏！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017419328\">JavaScript 是如何工作的：事件循环和异步编程的崛起+ 5 种使用 async/await 更好地编码方式！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017448270\">JavaScript 是如何工作的：深入探索 websocket 和 HTTP/2 与 SSE +如何选择正确的路径！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017485968\">JavaScript 是如何工作的：与 WebAssembly 比较 及其使用场景！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017578650\">JavaScript 是如何工作的：Web Workers 的构建块+ 5 个使用他们的场景!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017749922\">JavaScript 是如何工作的：Service Worker 的生命周期及使用场景!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017794020?_ea=6014340#articleHeader0\">JavaScript 是如何工作的：Web 推送通知的机制!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017832686\">JavaScript 是如何工作的：使用 MutationObserver 跟踪 DOM 的变化!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017872125#articleHeader0\">JavaScript 是如何工作的：渲染引擎和优化其性能的技巧!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017903157\">JavaScript 是如何工作的：深入网络层 + 如何优化性能和安全!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017927665\">JavaScript 是如何工作的：CSS 和 JS 动画底层原理及如何优化它们的性能！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017961297\">JavaScript 是如何工作的：解析、抽象语法树（AST）+ 提升编译速度 5 个技巧!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017992671\">JavaScript 是如何工作的：深入类和继承内部原理+Babel 和 TypeScript 之间转换!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018020391\">JavaScript 是如何工作的：存储引擎+如何选择合适的存储 API!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018033709\">JavaScript 是如何工作的：Shadow DOM 的内部结构+如何编写独立的组件！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018046292\">JavaScript 是如何工作的：WebRTC 和对等网络的机制！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018059329\">JavaScript 是如何工作的：编写自己的 Web 开发框架 + React 及其虚拟 DOM 原理!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018140746#articleHeader0\">JavaScript 是如何工作的：模块的构建以及对应的打包工具</a></li>\n</ol>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 声明一些变量并初始化它们\nvar a = 5;\nlet b = &quot;xy&quot;;\nconst c = true;\n\n&#x2F;&#x2F; 分配新值\na = 6;\nb = b + &quot;z&quot;;\nc = false; &#x2F;&#x2F;  类型错误:不可对常量赋值\n</code></pre><p>作为程序员，声明变量、初始化变量(或不初始化变量)以及稍后为它们分配新值是我们每天都要做的事情。</p>\n<p>但是当这样做的时候会发生什么呢? JavaScript 如何在内部处理这些基本功能? 更重要的是，作为程序员，理解 JavaScript 的底层细节对我们有什么好处。</p>\n<p>下面，我打算介绍以下内容:</p>\n<ul>\n<li>JS 原始数据类型的变量声明和赋值</li>\n<li>JavaScript 内存模型：调用堆栈和堆</li>\n<li>JS 引用类型的变量声明和赋值</li>\n<li><code>let</code> vs <code>const</code></li>\n</ul>\n<h3>JS 原始数据类型的变量声明和赋值</h3>\n<p>让我们从一个简单的例子开始。下面，我们声明一个名为<code>myNumber</code>的变量，并用值<code>23</code>初始化它。</p>\n<pre class=\"prettyprint language-javascript\"><code>let myNumber = 23;\n</code></pre><p>当执行此代码时，JS 将执行:</p>\n<ol>\n<li>为变量(<code>myNumber</code>)创建唯一标识符(<strong>identifier</strong>)。</li>\n<li>在内存中分配一个地址(在运行时分配)。</li>\n<li>将值 <code>23</code> 存储在分配的地址。</li>\n</ol>\n<p><img src=\"https://image.fundebug.com/2019-0415-01.png\" alt></p>\n<p>虽然我们通俗地说，<code>“myNumber 等于 23”</code>，更专业地说，<code>myNumber</code> 等于保存值 23 的内存地址，这是一个值得理解的重要区别。</p>\n<p>如果我们要创建一个名为 <code>newVar</code> 的新变量并把 <code>myNumber</code> 赋值给它。</p>\n<pre class=\"prettyprint language-javascript\"><code>let newVar = myNumber;\n</code></pre><p>因为 <code>myNumber</code> 在技术上实际是等于 “<code>0012CCGWH80</code>”，所以 <code>newVar</code> 也等于 “<code>0012CCGWH80</code>”，这是保存值为<code>23</code>的内存地址。通俗地说就是 <code>newVar</code> 现在的值为 <code>23</code>。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-02.png\" alt></p>\n<p>因为 <code>myNumber</code> 等于内存地址 <code>0012CCGWH80</code>，所以将它赋值给 <code>newVar</code> 就等于将<code>0012CCGWH80</code> 赋值给 <code>newVar</code>。</p>\n<p>现在，如果我这样做会发生什么:</p>\n<pre class=\"prettyprint language-javascript\"><code>myNumber = myNumber + 1;\n</code></pre><p><code>myNumber</code>的值肯定是 24。但是<code>newVar</code>的值是否也为 24 呢？，因为它们指向相同的内存地址？</p>\n<p>答案是否定的。由于 JS 中的原始数据类型是不可变的，当 <code>myNumber + 1</code> 解析为<code>24</code>时，JS 将在内存中分配一个新地址，将<code>24</code>作为其值存储，<code>myNumber</code>将指向新地址。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-03.png\" alt></p>\n<p>这是另一个例子:</p>\n<pre class=\"prettyprint language-javascript\"><code>let myString = &quot;abc&quot;;\nmyString = myString + &quot;d&quot;;\n</code></pre><p>虽然一个初级 JS 程序员可能会说，字母<code>d</code>只是简单在原来存放<code>adbc</code>内存地址上的值，从技术上讲，这是错的。当 <code>abc</code> 与 <code>d</code> 拼接时，因为字符串也是 JS 中的基本数据类型，不可变的，所以需要分配一个新的内存地址，<code>abcd</code> 存储在这个新的内存地址中，<code>myString</code> 指向这个新的内存地址。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-04.png\" alt></p>\n<p>下一步是了解原始数据类型的内存分配位置。</p>\n<h3>JavaScript 内存模型：调用堆栈和堆</h3>\n<p>JS 内存模型可以理解为有两个不同的区域:<strong>调用堆栈(call stack)<strong>和</strong>堆(heap)</strong>。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-05.png\" alt></p>\n<p>调用堆栈是存放原始数据类型的地方(除了函数调用之外)。上一节中声明变量后调用堆栈的粗略表示如下。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-06.png\" alt></p>\n<p>在上图中，我抽象出了内存地址以显示每个变量的值。 但是，不要忘记实际上变量指向内存地址，然后保存一个值。 这将是理解 <code>let vs. const</code> 一节的关键。</p>\n<p><strong>堆</strong>是存储引用类型的地方。跟调用堆栈主要的区别在于，堆可以存储无序的数据，这些数据可以动态地增长，非常适合数组和对象。</p>\n<h3>JS 引用类型的变量声明和赋值</h3>\n<p>让我们从一个简单的例子开始。下面，我们声明一个名为<code>myArray</code>的变量，并用一个空数组初始化它。</p>\n<pre class=\"prettyprint language-javascript\"><code>let myArray = [];\n</code></pre><p>当你声明变量“<code>myArray</code>”并为其指定非原始数据类型（如“[]”）时，以下是在内存中发生的情况：</p>\n<ol>\n<li>为变量创建唯一标识符（“<code>myArray</code>”）</li>\n<li>在内存中分配一个地址（将在运行时分配）</li>\n<li>存储在堆上分配的内存地址的值（将在运行时分配）</li>\n<li>堆上的内存地址存储分配的值（空数组[]）</li>\n</ol>\n<p><img src=\"https://image.fundebug.com/2019-0415-07.png\" alt></p>\n<p><img src=\"https://image.fundebug.com/2019-0415-08.png\" alt></p>\n<p>从这里，我们可以 <code>push</code>, <code>pop</code>，或对数组做任何我们想做的。</p>\n<pre class=\"prettyprint language-javascript\"><code>myArray.push(&quot;first&quot;);\nmyArray.push(&quot;second&quot;);\nmyArray.push(&quot;third&quot;);\nmyArray.push(&quot;fourth&quot;);\nmyArray.pop();\n</code></pre><p><img src=\"https://image.fundebug.com/2019-0415-09.png\" alt></p>\n<p><strong>代码部署后可能存在的 BUG 没法实时知道，事后为了解决这些 BUG，花了大量的时间进行 log 调试，这边顺便给大家推荐一个好用的 BUG 监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<h3>let <code>vs</code> const</h3>\n<p>一般来说，我们应该尽可能多地使用<code>const</code>，只有当我们知道某个变量将发生改变时才使用<code>let</code>。</p>\n<p>让我们明确一下我们所说的**“改变”**是什么意思。</p>\n<pre class=\"prettyprint language-javascript\"><code>let sum = 0;\nsum = 1 + 2 + 3 + 4 + 5;\nlet numbers = [];\nnumbers.push(1);\nnumbers.push(2);\nnumbers.push(3);\nnumbers.push(4);\nnumbers.push(5);\n</code></pre><p>这个程序员使用<code>let</code>正确地声明了<code>sum</code>，因为他们知道值会改变。但是，这个程序员使用<code>let</code>错误地声明了数组 <code>numbers</code> ，因为他将把东西推入数组理解为<strong>改变数组的值</strong>。</p>\n<p>解释**“改变”**的正确方法是更改<code>内存地址</code>。<code>let</code> 允许你更改内存地址。<code>const</code> 不允许你更改内存地址。</p>\n<pre class=\"prettyprint language-javascript\"><code>const importantID = 489;\nimportantID = 100; &#x2F;&#x2F; 类型错误:赋值给常量变量\n</code></pre><p>让我们想象一下这里发生了什么。</p>\n<p>当声明<code>importantID</code>时，分配了一个内存地址，并存储<code>489</code>的值。记住，将变量<code>importantID</code>看作等于内存地址。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-10.png\" alt></p>\n<p>当将<code>100</code>分配给<code>importantID</code>时，因为<code>100</code>是一个原始数据类型，所以会分配一个新的内存地址，并将<code>100</code>的值存储这里。</p>\n<p>然后 JS 尝试将新的内存地址分配给 <code>importantID</code>，这就是抛出错误的地方，这也是我们想要的行为，因为我们不想改变这个 <code>importantID</code>的值。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-11.png\" alt></p>\n<p>当你将<code>100</code>分配给<code>importantID</code>时，实际上是在尝试分配存储<code>100</code>的新内存地址，这是不允许的，因为<code>importantID</code>是用<code>const</code>声明的。</p>\n<p>如上所述，假设的初级 JS 程序员使用<code>let</code>错误地声明了他们的数组。相反，他们应该用<code>const</code>声明它。这在一开始看起来可能令人困惑，我承认这一点也不直观。</p>\n<p>初学者会认为数组只有在我们可以改变的情况下才有用，<code>const</code> 使数组不可变，那么为什么要使用它呢？ <strong>请记住</strong>:<strong>“改变”<strong>是指改变内存地址。让我们深入探讨一下为什么使用</strong>const</strong>声明数组是完全可以的。</p>\n<pre class=\"prettyprint language-javascript\"><code>const myArray = [];\n</code></pre><p>在声明 <code>myArray</code> 时，将在调用堆栈上分配内存地址，该值是在堆上分配的内存地址。堆上存储的值是实际的空数组。想象一下，它是这样的:</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-12.png\" alt></p>\n<p><img src=\"https://image.fundebug.com/2019-0415-13.png\" alt></p>\n<p>如果我们这么做:</p>\n<pre class=\"prettyprint language-javascript\"><code>myArray.push(1);\nmyArray.push(2);\nmyArray.push(3);\nmyArray.push(4);\nmyArray.push(5);\n</code></pre><p><img src=\"https://image.fundebug.com/2019-0415-14.png\" alt></p>\n<p>执行 <code>push</code> 操作实际是将数字放入堆中存在的数组。而 <code>myArray</code> 的内存地址没有改变。这就是为什么虽然使用<code>const</code>声明了 myArray，但没有抛出任何错误。</p>\n<p><code>myArray</code> 仍然等于 <code>0458AFCZX91</code>，它的值是另一个内存地址<code>22VVCX011</code>，它在堆上有一个数组的值。</p>\n<p>如果我们这样做，就会抛出一个错误：</p>\n<pre class=\"prettyprint language-javascript\"><code>myArray = 3;\n</code></pre><p>由于 <code>3</code> 是一个原始数据类型，因此生成一个新的调用堆栈上的内存地址，其值为 <code>3</code>，然后我们将尝试将新的内存地址分配给 <code>myArray</code>，由于 myArray 是用 const 声明的，所以这是不允许的。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-15.png\" alt></p>\n<p>另一个会抛出错误的例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>myArray = [&quot;a&quot;];\n</code></pre><p>由于<code>[a]</code>是一个新的引用类型的数组，因此将分配调用堆栈上的一个新内存地址，并存储<strong>堆</strong>上的一个内存地址的值，其它值为 <code>[a]</code>。然后，我们尝试将调用堆栈内存地址分配给 <code>myArray</code>，这会抛出一个错误。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-16.png\" alt></p>\n<p>对于使用<code>const</code>声明的对象（如数组），由于对象是引用类型，因此可以添加键，更新值等等。</p>\n<pre class=\"prettyprint language-javascript\"><code>const myObj = {};\nmyObj[&quot;newKey&quot;] = &quot;someValue&quot;; &#x2F;&#x2F; 这不会抛出错误\n</code></pre><h3>为什么这些知识对我们有用呢</h3>\n<p>JavaScript 是世界上排名第一的编程语言（<a href=\"https://insights.stackoverflow.com/survey/2018/\">根据 GitHub 和 Stack Overflow 的年度开发人员调查</a>）。 掌握并成为“JS 忍者”是我们所有人都渴望成为的人。</p>\n<p>任何质量好的的 JS 课程或书籍都提倡使用<code>let, const</code> 来代替 <code>var</code>，但他们并不一定说出原因。 对于初学者来说，为什么某些 <strong>const</strong> 变量在“改变”其值时会抛出错误而其他 <strong>const</strong>变量却没有。 对我来说这是有道理的，为什么这些程序员默认使用<strong>let</strong>到处避免麻烦。</p>\n<p>但是，不建议这样做。谷歌拥有世界上最好的一些程序员，在他们的 JavaScript 风格指南中说，使用 <strong>const</strong> 或 <strong>let</strong> 声明所有本地变量。默认情况下使用 <strong>const</strong>，除非需要重新分配变量，不使用 <strong>var</strong> 关键字(<a href=\"https://google.github.io/styleguide/jsguide.html#features-use-const-and-let\">原文</a>)。</p>\n<p>虽然他们没有明确说明原因，但据我所知，有几个原因</p>\n<ul>\n<li>先发制人地限制未来的 bug。</li>\n<li>使用 <code>const</code> 声明的变量必须在声明时初始化，这迫使程序员经常在范围方面更仔细地放置它们。这最终会导致更好的内存管理和性能。</li>\n<li>要通过代码与任何可能遇到它的人交流，哪些变量是不可变的(就 JS 而言)，哪些变量可以重新分配。</li>\n</ul>\n<p>希望上面的解释能帮助你开始明白为什么或者什么时候应该在代码中使用 <strong>let</strong> 和 <strong>const</strong> 。</p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2019/04/15/javascritpt-memory-mechanism/\">https://blog.fundebug.com/2019/04/15/javascritpt-memory-mechanism/</a></p>\n</div>","title":"JavaScript 是如何工作的：JavaScript 的内存模型","last_reply_at":"2019-04-15T03:13:46.938Z","good":false,"top":false,"reply_count":0,"visit_count":625,"create_at":"2019-04-15T03:13:46.938Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5cb1e5c5207b2365936ecae3","author_id":"57d216e13d3520a5387c2b53","tab":"ask","content":"<div class=\"markdown-text\"><p>我知道有个cms叫nodercms,有个论坛系统叫nodebb，有没有博客系统。或者还有什么比较好的开源项目可以看一看。</p>\n</div>","title":"大家好，请问Node有没有开源的博客项目","last_reply_at":"2019-04-15T01:16:50.747Z","good":false,"top":false,"reply_count":4,"visit_count":915,"create_at":"2019-04-13T13:36:05.647Z","author":{"loginname":"a69694510","avatar_url":"https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"}},{"id":"5cb343f6dad66d658e408cdc","author_id":"5b31b09b57137f22415c4f4a","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p><strong>该文章阅读需要5分钟,更多文章请点击本人博客<a href=\"https://www.halu886.cn\">halu886</a></strong></p>\n</blockquote>\n<ul>\n<li><a href=\"#%E5%AE%9A%E6%97%B6%E5%99%A8\">定时器</a></li>\n<li><a href=\"#precessnexttick\">precess.nextTick()</a></li>\n<li><a href=\"#setimmediate\">setImmediate()</a></li>\n<li><a href=\"#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E4%B8%8E%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8\">事件驱动与高性能服务器</a></li>\n</ul>\n<p>Node除去异步I/O，还有一些与I/O无关的异步API需要特别关注：setTimeout()，setInterval()，setImmediate()，process.nextTick()。</p>\n<h1>定时器</h1>\n<p><code>setTimeOut()</code>和<code>setInterval()</code>和浏览器的API的功能一致的，分别为单次或多次执行任务。实现原理和异步I/O相似。但是不需要I/O线程池参与，定时器创建后会插入定时器红黑树中。在每一次的Tick中，定时器观察者会从红黑树迭代取出一个定时器，判断是否超时，如果超时会执行这个定时器的回调。</p>\n<p>如图所示，两者的行为是一致的，不过<code>setInterval()</code>是重复的。</p>\n<p>定时器的问题在于不精确。例如，一个定时器任务是10ms后执行，但是当9毫秒时，有个任务占用了CPU时间片5毫秒，那么当14毫秒时才能执行定时器任务，此时已经逾期了4ms。</p>\n<p><img src=\"http://resource.halu886.cn/images/async-io-4/1.png?x-oss-process=style/halu-blog-watermark\" alt=\"1\"></p>\n<h1>precess.nextTick()</h1>\n<p>当未了解<code>process.nextTick()</code>时,为了立即执行一个异步任务，会这样实现</p>\n<pre class=\"prettyprint language-js\"><code>setTimeout(function(){\n    &#x2F;&#x2F;TODO\n},0);\n</code></pre><p>由于定时器的特点，不够精确。并且，创建和迭代一个定时器，需要动用红黑树，这样时比较浪费性能的。但是<code>process.nextTice()</code>是比较轻量级的。</p>\n<pre class=\"prettyprint language-js\"><code>process.nextTick = function(callback){\n    if(process._exiting) return;\n\n    if(tickDepth &gt;= process.maxTickDepth)\n        maxTickWarn();\n    \n    var tock = { callback: callback};\n    if(process.domain) tock.domain = process.domain;\n    nextTickQueue.push(tock);\n    if(nextTickQueue.length){\n        process._needTickCallback();\n    }\n}\n</code></pre><p>调用<code>process.nextTick()</code>，只会将回调函数放入队列中，下一轮Tick取出。定时器中的红黑树的时间复杂度为O(lg(n)),<code>nextTick()</code>的时间复杂度为O(1)。所以<code>process.nextTick()</code>更加高效。</p>\n<h1>setImmediate()</h1>\n<p><code>setImmediate()</code>与<code>process.nextTick()</code>功能相似，都是将回调延期执行。但是在Nodev0.9.0之前，<code>setImmediate()</code>还未实现，所以相关功能主要是通过<code>process.nextTick()</code>。<br>\n例如:</p>\n<pre class=\"prettyprint language-js\"><code>process.nextTick(function(){\n    console.log(&#x27;延期执行&#x27;);\n})\nconsole.log(&#x27;正常执行&#x27;);\n&#x2F;&#x2F;正常执行\n&#x2F;&#x2F;延期执行  \n</code></pre><p>而用<code>setImmedieate()</code>实现时，相关代码如下：</p>\n<pre class=\"prettyprint language-js\"><code>setImmediate(function(){\n    console.log(&#x27;延期执行&#x27;);\n})\nconsole.log(&#x27;正常执行&#x27;);\n&#x2F;&#x2F;正常执行\n&#x2F;&#x2F;延期执行\n</code></pre><p>其实它们还是有细微差别的，如果将它们放在一起会怎么样呢？</p>\n<pre class=\"prettyprint language-js\"><code>process.nextTick(function(){\n    console.log(&#x27;nextTick延迟执行&#x27;);\n})\nsetImmediate(function(){\n    console.log(&#x27;setImmediate延迟执行&#x27;);\n})\nconsole.log(&#x27;正常执行&#x27;);\n&#x2F;&#x2F; 正常执行\n&#x2F;&#x2F; nextTick延迟执行\n&#x2F;&#x2F; setImmediate延迟执行\n</code></pre><p>从结果上来看，nextTick的优先级高于setImmediate，这是因为事件循环对观察者是有先后顺序的，<code>process.nextTick()</code>是idle观察者，<code>setImmediate()</code>是check观察者。idle观察者优先级高于I/O观察者，I/O观察者优先级高于check观察者。</p>\n<p>具体实现上，<code>process.nextTick()</code>会将回调函数放入一个数组中，而<code>setImmediate()</code>则会将回调放入一个链表中。在每轮循环中，nextTick会将数组中的所有循环全都执行完，而setImmediate则会执行链表中一个回调函数。</p>\n<pre class=\"prettyprint language-js\"><code>process.nextTick(function(){\n    console.log(&#x27;nextTick延迟执行1&#x27;);\n});\n\nprocess.nextTick(function(){\n    console.log(&#x27;nextTick延迟执行2&#x27;);\n})\n\nsetImmediate(function(){\n    console.log(&#x27;setImmediate延迟执行1&#x27;);\n    process.nextTick(function(){\n        console.log(&#x27;强势插入&#x27;);\n    });\n})\n\nsetImmediate(function(){\n    console.log(&#x27;setImmediate延迟执行2&#x27;);\n})\nconsole.log(&#x27;正常执行&#x27;);\n&#x2F;&#x2F;正常执行\n&#x2F;&#x2F;nextTick延迟执行1\n&#x2F;&#x2F;nextTick延迟执行2\n&#x2F;&#x2F;setImmediate延迟执行1\n&#x2F;&#x2F;强势插入\n&#x2F;&#x2F;setImmediate延迟执行2\n</code></pre><p>从执行结果上看，当执行完第一个setImmediate后不是立即执行第二个setImmediate，而是开始下一个循环，按优先级执行process.nextTick()的回调再执行setImmediate()的回调。之所以这样设计是为了每轮循环尽快的结束任务，防止阻塞后续的I/O调用</p>\n<h1>事件驱动与高性能服务器</h1>\n<p>尽管我们前面使用<code>fs.open()</code>作为异步I/O的例子，但是在Node中网络套接字的读取也应用到了异步I/O，网络套接字的监听到请求都会形成事件交给I/O观察者。事件循环不停的处理网络I/O事件，如果Javascript有传入回调函数，这些事件最后会最终传递业务逻辑层进行处理。<br>\n<img src=\"http://resource.halu886.cn/images/async-io-4/2.png?x-oss-process=style/halu-blog-watermark\" alt=\"2\"></p>\n<p>以下是比较经典的服务器模型，下面对比一下他们优缺点:</p>\n<ol>\n<li>同步式，一次只能处理一个请求，其余时候都处于等待状态。</li>\n<li>每进程/每请求，为每个请求启动一个进程，虽然可以处理多个请求，但是不易拓展，比较系统资源有限。</li>\n<li>每线程/每请求，每个请求启动一个线程，虽然线程比进程轻量，但是当高并发请求访问时，也很容易把内存吃光导致服务器缓慢，每线程/每请求比每线程/每请求拓展性更好，但对于大型站点而言依然不够。</li>\n</ol>\n<p>每线程/每请求的方式依旧被Apache采用。Node通过事件循环处理请求，省略了创建线程和销毁线程的开销，通过操作系统在调度任务时线程比较少，上下文切换代价比较低。这使服务器能够有条不紊的处理请求，即使在大量连接的情况下，也不受线程上下文切换的影响，这是Node高性能的一个原因。</p>\n<p>事件驱动的高效已经逐渐被业内重视。例如Nginx，摒弃了多线程的方式，采用了和Node相同的事件驱动。并且如今Nginx大有取代Apache的趋势。Node具有和Nginx相同的特性，不过Nginx采用纯C开发的，新能极高，但是它仅适用于作为Web服务器，用于反向代理或均衡负载等服务，在处理业务方面上较为欠缺。Node则是一个高性能的平台，可以利用它构建与Nginx相同的功能，也可以处理其他业务，两者相比，Node没有Nignx在Web服务器上那么专业，但场景更大，自身性能也不错。</p>\n<blockquote>\n<p>以上知识点均来自&lt;&lt;深入浅出Node.js&gt;&gt;，更多细节建议阅读书籍:-)</p>\n</blockquote>\n</div>","title":"浅谈NodeJs异步I/O-4","last_reply_at":"2019-04-14T14:30:14.406Z","good":false,"top":false,"reply_count":0,"visit_count":362,"create_at":"2019-04-14T14:30:14.406Z","author":{"loginname":"halu886","avatar_url":"https://avatars1.githubusercontent.com/u/22374024?v=4&s=120"}},{"id":"5c8b0a4a7ce0df3732428254","author_id":"5adecaa3a86ec1f308ec2480","tab":"ask","content":"<div class=\"markdown-text\"><p>从学习 Nodejs 以来，听各路大神说 nodejs 的一大优势就是处理高并发。我是非科班出身，对于高并发的理解就是能够同时处理大量请求，第一印象就是每个请求单独起个线程处理，请求与请求之间互不干扰，然鹅…</p>\n<p>用 http 原生代码起一个服务器，接收两个请求：</p>\n<ul>\n<li><code>/a</code>：该接口内部写了个斐波拉契递归函数，执行时间大约 10s 左右</li>\n<li><code>/b</code></li>\n</ul>\n<p>实际起服务后，先请求 <code>/a</code> 接口，再请求 <code>/b</code> 接口。由于 <code>/a</code> 接口被斐波拉契函数阻塞了 10s 左右，惊讶的发现 <code>/b</code> 接口竟然一直要等到 <code>/a</code> 接口跑完才能响应。这说明 http 处理接口是一个处理完再处理下一个的，那么问题来了，10个用户同时请求同一个查询接口，假设每次查询时间为 1s，那岂不是运气差的人拿到响应肯定是在 10 秒之后。</p>\n<p>所谓高并发又到底怎么理解呢？</p>\n<pre class=\"prettyprint\"><code>var http = require(&#x27;http&#x27;)\n\nvar app = http.createServer(function (req, res) {\n    if (req.url === &#x27;&#x2F;a&#x27;) {\n        &#x2F;&#x2F; 斐波拉契函数\n        function fib(n) {\n            if (n === 0) return 0;\n            else if (n === 1) return 1;\n            else return fib(n - 1) + fib(n - 2)\n        }\n        fib(44) &#x2F;&#x2F; 执行时间要 10s 左右\n        res.end(&#x27;a is &#x27; + new Date())\n    } else if (req.url === &#x27;&#x2F;b&#x27;) {\n        res.end(&#x27;b is &#x27; + new Date())\n    }\n})\n\napp.listen(3600, function () {\n    console.log(&#x27;服务已启动&#x27;)\n})\n</code></pre></div>","title":"关于 Nodejs 服务器高并发的疑问","last_reply_at":"2019-04-14T06:29:15.453Z","good":false,"top":false,"reply_count":62,"visit_count":3233,"create_at":"2019-03-15T02:13:30.302Z","author":{"loginname":"dkvirus","avatar_url":"https://avatars1.githubusercontent.com/u/29170168?v=4&s=120"}},{"id":"5cb037cbdad66d658e40851b","author_id":"55500f555809a4b66f37f625","tab":"share","content":"<div class=\"markdown-text\"><h2>引言</h2>\n<p>在编程测试用例的过程中，一款好的测试报告器能帮忙我们一览用例全貌，并且快速定位问题。目前市面上的报告器大多功能较为单一，随着对报告器的要求不断提升，现有测试报告器已经无法满足飞速发展的业务。本文从如何获取 Mocha 数据到渲染 HTML 报告器，分享如何开发一款测试报告器，最后介绍一款蚂蚁国际出品的测试报告器 <a href=\"https://macacajs.github.io/macaca-reporter/zh/\">Macaca Reporter</a>。</p>\n<h2>获取 Mocha 数据</h2>\n<h3>处理数据</h3>\n<p>通过监听 Mocha 用例处理事件，对 Mocha 的数据进行二次加工，可以获取我们需要的数据结构。具体代码见 <a href=\"https://github.com/macacajs/macaca-reporter/blob/master/lib/macaca-reporter.js#L51\">GitHub</a>。</p>\n<pre class=\"prettyprint language-javascript\"><code>function MacacaReporter(runner, options) {\n\n  &#x2F;&#x2F; 用例结束的钩子函数，对数据 output 进行处理\n  this.done = (failures, exit) =&gt; done(this.output, options, this.config, failures, exit);\n\n  this.config = {\n    reportFilename: &#x27;report&#x27;,\n    saveJson: true\n  };\n  Base.call(this, runner);\n\n  new Spec(runner);\n\n  &#x2F;&#x2F; 测试用例开始执行的时候，获取 Mocha 数据的引用\n  runner.on(&#x27;start&#x27;, () =&gt; {\n    this._originSuiteData = runner.suite;\n  });\n\n  &#x2F;&#x2F; 每次用例结束后，对 Mocha 数据进行处理\n  runner.on(&#x27;test end&#x27;, test =&gt; {\n    test.uuid = _.uuid();\n    handleTestEnd();\n  });\n\n  &#x2F;&#x2F; 所有用例结束后，打印数据，输出报告器\n  runner.on(&#x27;end&#x27;, test =&gt; {\n    handleTestEnd(true);\n  });\n}\n</code></pre><p>数据处理过程中需要注意对 circle json 的处理，Mocha 数据中每个 test 会引用 suit，导致普通 JSON.stringify 处理会抛异常，这里采用 <a href=\"https://github.com/debitoor/safe-json-stringify\">safe-json-stringify</a> 对其进行处理。</p>\n<p>在数据处理数据后，得到 Mocha 测试数据</p>\n<ul>\n<li>JSON 文件保存到本地一份，以供其他测试框架集成使用。</li>\n<li>同时通过转码后内嵌到 html 报告器中，作为 html 报告器的原始数据：见 <a href=\"https://github.com/macacajs/macaca-reporter/blob/master/lib/render.js\">GitHub</a></li>\n</ul>\n<h3>用例截图</h3>\n<p>用例截图使用 macaca 框架提供的能力，基于 electron 的截图功能，能够在用例结束前自动产生截图</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;macacajs&#x2F;macaca-wd&#x2F;blob&#x2F;master&#x2F;lib&#x2F;helper.js#L183 \nwd.addPromiseChainMethod(&#x27;saveScreenshots&#x27;, function(context) {\n  const reportspath = path.join(cwd, &#x27;reports&#x27;);\n  const filepath = path.join(reportspath, &#x27;screenshots&#x27;, &#96;${uuid()}.png&#96;);\n  mkdir(path.dirname(filepath));\n\n  return this.saveScreenshot(filepath).then(() =&gt; {\n    appendToContext(context, &#96;${path.relative(reportspath, filepath)}&#96;);\n  });\n});\n</code></pre><p>生成截图后，可以将图片上传到 CDN 中，将路径保存到每个 test 数据中。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;macacajs&#x2F;macaca-reporter&#x2F;blob&#x2F;master&#x2F;lib&#x2F;macaca-reporter.js#L130\nMacacaReporter.appendToContext = function (mocha, content) {\n  try {\n    const test = mocha.currentTest || mocha.test;\n\n    if (!test.context) {\n      test.context = content;\n    } else if (Array.isArray(test.context)) {\n      test.context.push(content);\n    } else {\n      test.context = [test.context];\n      test.context.push(content);\n    }\n  } catch (e) {\n    console.log(&#x27;error&#x27;, e);\n  }\n};\n</code></pre><h2>开发 HTML 报告器</h2>\n<p>有了测试原始数据后，我们开始着手开发 HTML 报告器，报告器应该有以下两个要素：</p>\n<ul>\n<li>直观显示用例总数、成功和失败用例数量、耗时</li>\n<li>显示每个用例的具体名称、状态、耗时</li>\n</ul>\n<p>在此基础上，为了方便开发者直观的看到每个用例的情况以及用例的整体情况，我们添加了链路树模式、脑图模式和全图模式。</p>\n<h3>链路树模式</h3>\n<p>Mocha 测试用例编写是 suit 中嵌套 suit，叶子节点是 test（describle -&gt; describle -&gt; it），非常适合用链路图的形式开表达用例的关系。我们基于 <a href=\"https://d3js.org/\">D3</a> 开发了 <a href=\"https://github.com/zhuyali/d3-tree\">d3-tree</a>，用来展示链路树结构。链路树模式是最常用的也是默认的展示模式，将用例的组织结构按照树来展示，链路树模式方便还原业务产品的测试执行路径。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;macacajs&#x2F;macaca-reporter&#x2F;blob&#x2F;master&#x2F;assets&#x2F;components&#x2F;Suite.js#L107\nconst d3tree = new D3Tree({\n  selector: selector,\n  data: d3Data,\n  width: document.querySelector(&#x27;ul.head&#x27;).clientWidth,\n  height: this.maxD3Height * 300,\n  duration: 500,\n  imageHeight: 200,\n  imageWidth: 200,\n  imageMargin: 10,\n  itemConfigHandle: () =&gt; {\n    return {\n      isVertical: false\n    };\n  }\n});\nd3tree.init();\n</code></pre><p>传入对应数据结构就能绘制出下图：&lt;br /&gt;<img src=\"https://cdn.nlark.com/yuque/0/2019/png/95383/1555052751748-44a6c5df-8d70-49d8-96f9-115b5914711c.png#align=left&amp;display=inline&amp;height=847&amp;originHeight=1692&amp;originWidth=1491&amp;size=0&amp;status=done&amp;width=746\" alt></p>\n<h3>脑图模式</h3>\n<p>通过使用 [<a href=\"/user/antv\">@antv</a>/g6-editor](<a href=\"https://github.com/antvis/g6-editor\">https://github.com/antvis/g6-editor</a>) 提供的 Mind 可以非常方便的绘制脑图。脑图模式可以认为是全部用例的概览，这个视图更方便用户整理和组织用例，在改进、补充新用例前可作为分析依据。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;macacajs&#x2F;macaca-reporter&#x2F;blob&#x2F;master&#x2F;assets&#x2F;components&#x2F;Mind.js#L77\nnew Editor.Mind({\n  defaultData: mindSuite,\n  labelEditable: false,\n  mode: &#x27;readOnly&#x27;,\n  graph: {\n    container: &#x27;mind-node&#x27;,\n    height: window.innerHeight - 100,\n    width: window.innerWidth,\n  },\n});\n</code></pre><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/95383/1555052751763-a97602e7-df8e-44df-b187-074586c6a8b5.png#align=left&amp;display=inline&amp;height=296&amp;originHeight=624&amp;originWidth=1570&amp;size=0&amp;status=done&amp;width=746\" alt></p>\n<h3>全图模式</h3>\n<p>全图模式提取了测试过程中的全部截图，更适用于偏渲染展示型的功能测试。在交付下一阶段前可以用做质量依据从而降低成本。但不建议每次通过人工看报告的形式来避免问题，推荐使用 <a href=\"https://macacajs.github.io/zh/guide/computer-vision.html#%E5%85%B6%E5%AE%83%E6%96%B9%E6%A1%88\">像素判断</a> 和异常捕获等自动化手段辅助断言当前渲染是否正常。&lt;br /&gt;<img src=\"https://cdn.nlark.com/yuque/0/2019/png/95383/1555052751810-a1405baa-21f1-4185-9594-f095747e3b16.png#align=left&amp;display=inline&amp;height=296&amp;originHeight=525&amp;originWidth=1322&amp;size=0&amp;status=done&amp;width=746\" alt></p>\n<h2>Macaca Reporter</h2>\n<p>蚂蚁国际的前端同学在业务实践过程中，基于 <a href=\"https://mochajs.org/\">Mocha</a> 沉淀了 <a href=\"https://macacajs.github.io/macaca-reporter/zh/guide/\">macaca-reporter</a>，经过近两年的不断打磨，已经在阿里多个 BU 中广泛使用。我们先看看 Macaca Reporter 具有哪些能力，能够做哪些事情：</p>\n<ul>\n<li>配合自动截图功能能够刻画完整的链路</li>\n<li>能够支持成功、失败、跳过等类型的用例展示</li>\n<li>支持计算通过率</li>\n<li>支持脑图模型展示用例链路</li>\n<li>支持图片模式直观展示用例截图</li>\n<li>支持二次定制开发，添加功能</li>\n</ul>\n<h3>深度刻画链路</h3>\n<p>效果图（页面太长，只截取了一小部分）：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/95383/1555052751778-2226a04e-7a66-42a1-83ef-e679d5003c06.png#align=left&amp;display=inline&amp;height=1238&amp;originHeight=2672&amp;originWidth=1610&amp;size=0&amp;status=done&amp;width=746\" alt></p>\n<h3>脑图模式</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/95383/1555052751775-8248002e-e9e7-48e9-b373-7970e0a4c4cd.png#align=left&amp;display=inline&amp;height=399&amp;originHeight=849&amp;originWidth=1588&amp;size=0&amp;status=done&amp;width=746\" alt></p>\n<h3>图片模式</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/95383/1555052751789-95b11d04-acf1-49bd-bb85-1ee40729e6c0.png#align=left&amp;display=inline&amp;height=532&amp;originHeight=1148&amp;originWidth=1610&amp;size=0&amp;status=done&amp;width=746\" alt></p>\n<h3>表格模式</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/95383/1555052751819-ac782c60-8627-4530-bcdc-75a7230972fe.png#align=left&amp;display=inline&amp;height=655&amp;originHeight=1482&amp;originWidth=1689&amp;size=0&amp;status=done&amp;width=746\" alt></p>\n<h2>体验 Macaca Reporter</h2>\n<p>通过 DataHub 项目体验下 Macaca Repoter：</p>\n<pre class=\"prettyprint language-bash\"><code>$ git clone git@github.com:macacajs&#x2F;macaca-datahub.git\n$ cd macaca-datahub\n$ npm i\n$ npm run dev:test\n$ npm run test\n</code></pre><p>等测试用例跑完之后，控制台会输出：</p>\n<pre class=\"prettyprint\"><code>&gt;&gt; &gt;&gt; html reporter generated: &#x2F;github&#x2F;macacajs&#x2F;datahub-view&#x2F;reports&#x2F;index.html\n&gt;&gt; &gt;&gt; json reporter generated: &#x2F;github&#x2F;macacajs&#x2F;datahub-view&#x2F;reports&#x2F;json-final.json\n&gt;&gt; &gt;&gt; reporter config generated:&#x2F;github&#x2F;macacajs&#x2F;datahub-view&#x2F;reports&#x2F;config.json\n&gt;&gt; &gt;&gt; coverage reporter generated: &#x2F;github&#x2F;macacajs&#x2F;datahub-view&#x2F;coverage&#x2F;index.html\n</code></pre><p>打开 HTML 报告器即可。</p>\n<h2>结语</h2>\n<p>Macaca Reporter 作为一款功能强大的报告器，欢迎大家来使用，来共建。</p>\n<p>项目主页：<a href=\"https://macacajs.github.io/macaca-reporter/zh/\">https://macacajs.github.io/macaca-reporter/zh/</a>&lt;br /&gt;GitHub：<a href=\"https://github.com/macacajs/macaca-reporter\">https://github.com/macacajs/macaca-reporter</a>&lt;br /&gt;问题反馈：<a href=\"https://github.com/macacajs/macaca-reporter/issues\">https://github.com/macacajs/macaca-reporter/issues</a></p>\n<p>BTW，欢迎成为 <a href=\"https://macacajs.com/\">Macaca</a> 项目的<a href=\"https://macacajs.github.io/zh/guide/contributing.html#%E5%89%8D%E8%A8%80\">贡献者</a>，Macaca 是一套面向用户端软件的测试解决方案，提供了自动化驱动，环境配套，周边工具，集成方案等，拥有自研的自主产权的产品矩阵，旨在解决终端上的测试、自动化、性能等方面的问题。</p>\n</div>","title":"如何打造东半球 No1 的测试报告器","last_reply_at":"2019-04-13T11:00:41.428Z","good":false,"top":false,"reply_count":7,"visit_count":544,"create_at":"2019-04-12T07:01:31.872Z","author":{"loginname":"yllziv","avatar_url":"https://avatars1.githubusercontent.com/u/11460601?v=4&s=120"}},{"id":"57a944e59c26ea7c7226096f","author_id":"559f6bb9419f1e8a23a64163","tab":"ask","content":"<div class=\"markdown-text\"><p>希望大家发我一份，谢谢</p>\n</div>","title":"redis desk manager  收费了，还有免费的工具吗？","last_reply_at":"2019-04-13T09:39:23.522Z","good":false,"top":false,"reply_count":10,"visit_count":5391,"create_at":"2016-08-09T02:50:13.408Z","author":{"loginname":"qimuyunduan","avatar_url":"https://avatars0.githubusercontent.com/u/3916574?v=3&s=120"}},{"id":"5ca73b1431010b2dfbb43766","author_id":"590a8584bbaf2f3f569be508","tab":"ask","content":"<div class=\"markdown-text\"><p>最近公司要做一个智能化产品，用到的富文本编辑器有些特殊要求，需要比较智能，大概样子要像下面这样\n<img src=\"//static.cnodejs.org/FqSMkSFYQ8cdIDTV9W7Pdu7aSHbk\" alt=\"image.png\"></p>\n<ol>\n<li>要支持一些敏感词的标注</li>\n<li>我们可能会对敏感词做一些替换</li>\n<li>要支持拖拽上传图片和视频，点击图片的时候要在图片周围显示出像上图那个的提示，支持裁剪之类的操作。。。</li>\n</ol>\n<p>大家有没有好的开源框架推荐，最好在原基础上改动比较小的 。</p>\n</div>","title":"大家有没有好的富文本编辑器推荐?","last_reply_at":"2019-04-13T09:17:31.690Z","good":false,"top":false,"reply_count":6,"visit_count":1034,"create_at":"2019-04-05T11:25:08.395Z","author":{"loginname":"GeekHi","avatar_url":"https://avatars2.githubusercontent.com/u/22934185?v=4&s=120"}},{"id":"5c3092dc5bf06c5e7e3f1ab4","author_id":"5c2ec7f75bf06c5e7e3f10e8","tab":"share","content":"<div class=\"markdown-text\"><p>《web前端开发》从零基础到高级项目实战14个视频教程，2018整理较新web前端开发教程，还有移动端视频教程，整套教程包含笔记+开发工具+源码</p>\n<p><img src=\"//static.cnodejs.org/Fr7UbcXv9dgB-tK3c4LNqhteSp9B\" alt=\"11111.jpg\"></p>\n<p><strong>web前端开发教程大纲</strong>\n<img src=\"//static.cnodejs.org/FukwYmgiH_AjeDVsmVjds7kboIOB\" alt=\"22222.jpg\"></p>\n<p><strong>14个前端项目实战教程</strong>\n<img src=\"//static.cnodejs.org/FiLUGF9w51avsIlCqxQcZi-IRPZE\" alt=\"33333.jpg\"></p>\n<p>教程下载：<a href=\"https://www.sucaihuo.com/video/448.html\">https://www.sucaihuo.com/video/448.html</a></p>\n</div>","title":"《web前端开发》从零基础到高级项目实战14个视频教程","last_reply_at":"2019-04-13T08:59:53.618Z","good":false,"top":false,"reply_count":5,"visit_count":1847,"create_at":"2019-01-05T11:19:56.250Z","author":{"loginname":"missheying","avatar_url":"https://avatars3.githubusercontent.com/u/46346806?v=4&s=120"}},{"id":"5ca42ada31010b2dfbb42a0b","author_id":"5c0e2cc3f3d48d2397c0fad9","tab":"share","content":"<div class=\"markdown-text\"><h1>Clipic.js</h1>\n<blockquote>\n<p>Clipic.js插件可以为移动端提供头像上传并裁剪成指定尺寸，用原生js开发的，轻量级，包含html跟css，不到8kb。先上一张效果图，或者点此链接体验：<a href=\"https://teojs.github.io/clipic/\" title=\"Clipic.js\">https://teojs.github.io/clipic/</a></p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/6/16951ba160c5fc6d?w=300&amp;h=519&amp;f=gif&amp;s=1635316\" alt=\"eg\"></p>\n<h2>Github地址</h2>\n<p><a href=\"https://github.com/teojs/clipic\">https://github.com/teojs/clipic</a></p>\n<h2>使用方法</h2>\n<h3>支持 npm 方式</h3>\n<pre class=\"prettyprint language-bath\"><code>$ npm install clipic\n</code></pre><h3>支持 cdn 引入</h3>\n<pre class=\"prettyprint language-html\"><code>&lt;script src=&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;clipic&#x2F;dist&#x2F;clipic.min.js&quot;&gt;&lt;&#x2F;script&gt;\n</code></pre><h3>在 vue 项目中使用</h3>\n<pre class=\"prettyprint language-html\"><code>&#x2F;&#x2F; xxx.vue\n&lt;template&gt;\n  &lt;img :src=&quot;base64&quot; &#x2F;&gt;\n  &lt;input type=&quot;file&quot; name=&quot;file&quot; accept=&quot;image&#x2F;*&quot; @change=&quot;uploadImg&quot; &#x2F;&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\n  import Clipic from &#x27;clipic&#x27;\n  const clipic = new Clipic()\n  export default {\n    data () {\n      return {\n        base64: &#x27;&#x27;\n      }\n    }\n    methods: {\n      uploadImg(event) {\n        const files = event.files\n        const reader = new FileReader()\n        reader.readAsDataURL(files[0])\n        reader.onload = img =&gt; {\n          clipic.getImage({\n            width: 500,\n            height: 400,\n            src: img.target.result,\n            onDone: base64 =&gt; {\n              this.base64 = base64\n            }\n          })\n        }\n        event.value = &#x27;&#x27;\n      }\n    }\n  }\n&lt;&#x2F;script&gt;\n</code></pre><p>普通项目的使用可以看作者的<a href=\"https://github.com/teojs/clipic/blob/master/index.html\">demo</a></p>\n<h2>参数说明</h2>\n<ul>\n<li><code>width:Number</code> (默认：500) – 裁剪宽度</li>\n<li><code>height:Number</code> (默认：500) – 裁剪高度</li>\n<li><code>ratio:Number</code> (可选) – 裁剪的比例，当传入<code>ratio</code>时<code>width/height</code>将无效</li>\n<li><code>src:String</code> (必传) – 需要裁剪的图片，可以是图片链接，或者 base64</li>\n<li><code>type:String</code> (默认：jpeg) – 裁剪后图片的类型，仅支持 jpeg/png 两种</li>\n<li><code>quality:Number</code> (默认：0.9) – 压缩质量</li>\n<li><code>buttonText:Array</code> (默认：[‘取消’, ‘重置’, ‘完成’]) – 底部三个按钮文本</li>\n</ul>\n</div>","title":"移动端上传头像并裁剪 - Clipic.js","last_reply_at":"2019-04-13T05:46:49.974Z","good":false,"top":false,"reply_count":4,"visit_count":819,"create_at":"2019-04-03T03:39:06.951Z","author":{"loginname":"Cheesenx","avatar_url":"https://avatars2.githubusercontent.com/u/25993112?v=4&s=120"}},{"id":"570c6a09d3220b7e4e3045f2","author_id":"53f8a710bbdaa79d51633ca0","tab":"share","content":"<div class=\"markdown-text\"><p><strong>1、前端那些事儿</strong>\n<img src=\"http://dn-cnode.qbox.me/FvIdtHgmmjHFjXrKJ9p8el-h_25f\" alt=\"前端那些事儿258.jpg\"></p>\n<p><strong>2、前端JavaScript</strong>\n<img src=\"http://dn-cnode.qbox.me/FjGYVHXFiSC60kQooF51fkdspRfk\" alt=\"前端javascript.png\"></p>\n<p><strong>3、前端乱炖</strong>\n<img src=\"//static.cnodejs.org/Frn63TgZ2YBHrB52ZPxAQyaQP522\" alt=\"前端乱炖.png\"></p>\n<p><strong>4、前端外刊评论</strong>\n<img src=\"http://dn-cnode.qbox.me/FuwHuBI0oBqhPQ1-EIsypaGICo1P\" alt=\"前端外刊评论.png\"></p>\n<p><strong>5、前端大全</strong>\n<img src=\"http://dn-cnode.qbox.me/FmDFNI8z9v3MM4iS9g6oHM2se_2C\" alt=\"前端大全.png\"></p>\n<p><strong>6、Node全栈</strong>\n<img src=\"http://dn-cnode.qbox.me/FtZX7S1kNBfGGlXWBmHs1Bie88KV\" alt=\"Node全栈.png\"></p>\n<p><strong>7、 W3cplus</strong>\n<img src=\"http://dn-cnode.qbox.me/FgDOdj_xq0rjWCUeq1DoWBu2sASY\" alt=\"W3cplus.png\"></p>\n<p><strong>8、前端早读课</strong>\n<img src=\"http://dn-cnode.qbox.me/FvaTw6AHPmZQfaV7FeCsqe9Ft75a\" alt=\"前端早读课.png\"></p>\n<p><strong>9、HTML5</strong>\n<img src=\"http://dn-cnode.qbox.me/FhnDEmZ7QiFcthZLBVyftyqQ-41m\" alt=\"HTML5.png\"></p>\n<p><strong>10、web前端开发</strong>\n<img src=\"http://dn-cnode.qbox.me/FrtGaDe20fGLikIoj6vOr-8KaafI\" alt=\"web前端开发.png\"></p>\n<p><strong>11、奇舞周刊</strong>\n<img src=\"//static.cnodejs.org/FvW-gDSvqqtgG-5k2BdKrxsRRdcK\" alt=\"奇舞周刊.png\"></p>\n<p><strong>12、滴滴出行</strong>\n<img src=\"//static.cnodejs.org/FvxDk-imDhANm2qUyBnWQEogw-2U\" alt=\"滴滴出行.png\"></p>\n<p><strong>欢迎补充</strong>：\n…</p>\n</div>","title":"前端微信公众号推荐","last_reply_at":"2019-04-13T05:00:04.908Z","good":false,"top":false,"reply_count":17,"visit_count":6428,"create_at":"2016-04-12T03:22:49.253Z","author":{"loginname":"JerroldLee","avatar_url":"https://avatars.githubusercontent.com/u/5645510?v=3&s=120"}},{"id":"5cac05e9d68ff5064921b50c","author_id":"5c1af54c3898674067a76341","tab":"ask","content":"<div class=\"markdown-text\"><p>技术大咖们来评估一下难度系数怎么样啊\n<a href=\"https://activity.lagou.com/topic/0408AfterShiptopic.html\">https://activity.lagou.com/topic/0408AfterShiptopic.html</a></p>\n<p>这个公司还有一个代码版本的公司介绍，用开源做的，一起发出来看看\n<a href=\"https://activity.lagou.com/gracie/pc/AfterShip0213.html\">https://activity.lagou.com/gracie/pc/AfterShip0213.html</a></p>\n</div>","title":"大家有用 hackerrank 刷过题吗，这家公司出了一个题来让大家测测自己有多牛","last_reply_at":"2019-04-13T02:52:01.967Z","good":false,"top":false,"reply_count":3,"visit_count":808,"create_at":"2019-04-09T02:39:37.465Z","author":{"loginname":"littleflowersansan","avatar_url":"https://avatars3.githubusercontent.com/u/42596541?v=4&s=120"}},{"id":"5cb149d8dad66d658e408806","author_id":"5adf4d96d25ba6000932f5e2","tab":"ask","content":"<div class=\"markdown-text\"><p>在UDP中setMulticastTTL和seTTL有什么区别？作用是什么？看文档中的说明都是一样的，有点懵，有没有牛人举例说明一下呀。</p>\n</div>","title":"UDP中setMulticastTTL和seTTL的区别作用？","last_reply_at":"2019-04-13T02:30:48.691Z","good":false,"top":false,"reply_count":0,"visit_count":290,"create_at":"2019-04-13T02:30:48.691Z","author":{"loginname":"wangliguo6666","avatar_url":"https://avatars0.githubusercontent.com/u/18714910?v=4&s=120"}},{"id":"5caebc13207b2365936ebda4","author_id":"5909444b782dbc4b183ecfe2","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://i04picsos.sogoucdn.com/ff46168e7f4e45b2\" alt></p>\n</div>","title":"有没有 vscode 扩展的群，一起撸扩展？","last_reply_at":"2019-04-12T08:11:31.826Z","good":false,"top":false,"reply_count":11,"visit_count":985,"create_at":"2019-04-11T04:01:23.241Z","author":{"loginname":"axetroy","avatar_url":"https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"}},{"id":"5cb00e31dad66d658e40842b","author_id":"5cb00b86dad66d658e40840d","tab":"ask","content":"<div class=\"markdown-text\"><p>先贴出让我困惑的结果：\n<img src=\"//static.cnodejs.org/FmtssEdijYIEgtbShFzFgohcC3sF\" alt=\"图片\"></p>\n<p>代码：</p>\n<pre class=\"prettyprint language-js\"><code>var fs = require(&#x27;fs&#x27;)\nfs.readdir(&#x27;node_modules&#x27;,function(err,files){\n\tif(err){\n\t\tconsole.log(err)\n\t}else{\n\t\t&#x2F;&#x2F;console.log(files)\n\t\tlet filesArr=[];\n\t\tfor(var i=0;i&lt;files.length;i++){\n\t\t\t(function(i){\n\t\t\t\tfs.stat(&#x27;node_modules&#x2F;&#x27;+files[i],(e,stats)=&gt;{\n\t\t\t\t&#x2F;&#x2F;\tconsole.log(&#x27;files[&#x27;+i+&#x27;] : &#x27;+files[i])\n\t\t\t\t\tif(stats.isDirectory()){\n\t\t\t\t\t\tfilesArr.push(files[i])\n\t\t\t\t\t\tif(i === files.length-1){\n\t\t\t\t\t\t\tconsole.log(&#x27;目录：-----&#x27;+filesArr)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.log(&#x27;files[&#x27;+i+&#x27;] : &#x27;+files[i])   \n\t\t\t\t})\n\t\t\t})(i)\n\t\t}\n\t\t\n\t}\n})\n</code></pre><p>上述示例中有时得到的<code>filesArr</code>仅有<code>nav</code>目录，有时候得到的结果是<code>nav</code>和<code>bar</code>目录都有，为什么呢？我以为异步函数是按照顺序依次加入到队列中的，然后依次执行，不是这样的吗？</p>\n</div>","title":"新手求教，使用fs.stat判断fs.readdir读出的数组中是否含有目录时得到的结果与期望有异","last_reply_at":"2019-04-12T05:46:35.636Z","good":false,"top":false,"reply_count":3,"visit_count":440,"create_at":"2019-04-12T04:04:01.903Z","author":{"loginname":"innerWang","avatar_url":"https://avatars1.githubusercontent.com/u/44764435?v=4&s=120"}},{"id":"5cada94fdad66d658e40782c","author_id":"5c98426500bcfd7eb2be5add","tab":"share","content":"<div class=\"markdown-text\"><h1>Node.js docker 镜像体积优化实践</h1>\n<p>你讨厌部署你的应用程序花费很长时间吗? 对于单个容器来说，超过gb并不是最佳实践。每次部署新版本时都要处理数十亿字节，这对我们来说并不太合适。</p>\n<p>本文将通过Nodejs程序展示如何优化Docker镜像的几个简单步骤，使它们更小、更快、更适合生产环境。</p>\n<h2>简单的一段Node.js项目</h2>\n<p>首先写一段基于express的简单web服务器程序</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; package.json\n{\n  &quot;name&quot;: &quot;docker-test&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;app.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;node app&quot;\n  },\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;dependencies&quot;: {\n    &quot;express&quot;: &quot;^4.16.4&quot;\n  },\n  &quot;devDependencies&quot;: {\n    &quot;eslint&quot;: &quot;^5.16.0&quot;\n  }\n}\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; app.js\nconst express = require(&#x27;express&#x27;)\nconst app = express()\n\napp.get(&#x27;&#x2F;&#x27;, function(req, res){\n  res.send(&#x27;hello world&#x27;)\n})\n\napp.listen(3000)\n</code></pre><p>在根目录下新建Dockerfile并写入以下代码</p>\n<pre class=\"prettyprint language-dockerfile\"><code># Dockerfile\nFROM node\n\nCOPY . &#x2F;home&#x2F;app\n\nRUN cd &#x2F;home&#x2F;app &amp;&amp; npm install\n\nWORKDIR &#x2F;home&#x2F;app\n\nCMD [&#x27;npm&#x27;, &#x27;start&#x27;]\n</code></pre><p>执行</p>\n<ul>\n<li>docker build -t myapp .</li>\n<li>docker images</li>\n</ul>\n<p><img src=\"https://i.loli.net/2019/04/10/5cad83236b780.jpeg\" alt=\"结果\"></p>\n<p>可以看到这段最简单的nodejs程序有920MB,请不要这样做。接下来我们将逐步的减少这个镜像的体积。</p>\n<h2>优化docker生产环境镜像</h2>\n<ul>\n<li>\n<h3>使用Node.js Alpine 镜像</h3>\n<p>大幅减小镜像体积的最简单和最快的方法是选择一个小得多的基本镜像。Alpine是一个很小的Linux发行版，可以完成这项工作。只要选择Node.js的Alpine版本，就会有很大的改进。</p>\n<pre class=\"prettyprint language-dockerfile\"><code>FROM node:alpine\n\nCOPY . &#x2F;home&#x2F;app\n\nRUN cd &#x2F;home&#x2F;app &amp;&amp; npm install\n\nWORKDIR &#x2F;home&#x2F;app\n\nCMD [&#x27;npm&#x27;, &#x27;start&#x27;]\n</code></pre><p>build之后\n<img src=\"https://i.loli.net/2019/04/10/5cad83877388e.jpeg\" alt=\"结果\"></p>\n<p>可以看到整整减少了<strong>800MB</strong>，这是一个非常大的优化。</p>\n</li>\n<li>\n<h3>生成环境下不打包开发的依赖包</h3>\n<p>但我们还能继续优化。我们正在安装所有依赖项，即使我们最终只需要生成环境下的依赖包。如果只打包生产环境的以来不会怎么样，继续改进一下。</p>\n<pre class=\"prettyprint language-dockerfile\"><code>  FROM node:alpine\n\n  COPY . &#x2F;home&#x2F;app\n\n  RUN cd &#x2F;home&#x2F;app &amp;&amp; npm install --production\n\n  WORKDIR &#x2F;home&#x2F;app\n\n  CMD [&#x27;npm&#x27;, &#x27;start&#x27;]\n</code></pre><p>build之后\n<img src=\"https://i.loli.net/2019/04/10/5cad8e5f54128.jpeg\" alt=\"结果\"></p>\n<p>我们又减少了6MB，因为我们目前只有一个开发依赖，可以想象在一个正常的项目中这也将是非常大的优化。</p>\n</li>\n<li>\n<h3>使用基础版本的 Alpine 镜像组合Nodejs</h3>\n<p>如果我们使用基础版本的 Alpine 镜像，然后自己安装Nodejs结果会怎么样呢?</p>\n<pre class=\"prettyprint language-dockerfile\"><code>  FROM alpine:latest\n\n  RUN apk add --no-cache --update nodejs nodejs-npm\n\n  COPY . &#x2F;home&#x2F;app\n\n  RUN cd &#x2F;home&#x2F;app &amp;&amp; npm install --production\n\n  WORKDIR &#x2F;home&#x2F;app\n\n  CMD [&#x27;npm&#x27;, &#x27;start&#x27;]\n</code></pre><p>build之后\n<img src=\"https://i.loli.net/2019/04/10/5cad93eceb10b.jpeg\" alt=\"结果\"></p>\n<p>现在只剩下了65MB，相比刚开始已经减少了10倍多。</p>\n</li>\n<li>\n<h3>多阶段构建</h3>\n<ul>\n<li>\n<p>Docker镜像是分层的，Dockerfile中的每个指令都会创建一个新的镜像层，镜像层可以被复用和缓存。当Dockerfile的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效，某一层的镜像缓存失效之后，它之后的镜像层缓存都会失效。</p>\n</li>\n<li>\n<p>因此我们还可以将RUN指令合并，但是需要记住的是，我们只能将变化频率一致的指令合并。</p>\n</li>\n<li>\n<p>我们应该把变化最少的部分放在Dockerfile的前面，这样可以充分利用镜像缓存。</p>\n</li>\n<li>\n<p>通过最小化镜像层的数量，我们可以得到更小的镜像。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>上述示例中，源代码会经常变化，则每次构建镜像时都需要重新安装NPM模块，这显然不是我们希望看到的。因此我们可以先拷贝package.json，然后安装NPM模块，最后才拷贝其余的源代码。这样的话，即使源代码变化，也不需要重新安装NPM模块。</p>\n<pre class=\"prettyprint language-dockerfile\"><code>  FROM alpine AS builder\n  WORKDIR &#x2F;home&#x2F;app\n  RUN apk add --no-cache --update nodejs nodejs-npm\n  COPY package.json package-lock.json .&#x2F;\n  RUN npm install --production\n\n  FROM alpine\n  WORKDIR &#x2F;home&#x2F;app\n  RUN apk add --no-cache --update nodejs nodejs-npm\n  COPY --from=builder &#x2F;usr&#x2F;src&#x2F;app&#x2F;node_modules .&#x2F;node_modules\n  COPY . .\n  CMD [ &#x27;npm&#x27;, &#x27;start&#x27; ]\n</code></pre><p><img src=\"https://i.loli.net/2019/04/10/5cada07ba5f96.jpeg\" alt=\"结果\"></p>\n<p>最终的镜像只有51MB，比最开始大概减少了17倍！并且后续的 build 速度也大大提升。</p>\n<p>每一条 FROM 指令都是一个构建阶段，多条 FROM 就是多阶段构建，虽然最后生成的镜像只能是最后一个阶段的结果，但是，能够将前置阶段中的文件拷贝到后边的阶段中，这就是多阶段构建的最大意义。</p>\n<p>在上面的Dockerfile文件中，我们先 copy 了package.json，然后 npm install，在第二阶段构建时，我们直接 copy 了第一阶段已经下载好的node_moduls,在下一次 build 时，如果没有新增依赖，docker将使用缓存中的node_modules，这样就减少了部署的时间。</p>\n<p>使用 docker inspect imageId命令 我们可以看到，虽然我们有多个指令，但是最终的镜像也只有5层，这就是层的共享机制。</p>\n<p>使用多阶段构建可以充分利用Docker镜像的缓存，大大减少最终部署到生产环境的时间。</p>\n<h2>结论</h2>\n<p>在实际生产环境中，没有任何理由使用gb大小的镜像，如果你确实需要提高部署速度，并且被缓慢的CI/CD所困扰，那么多阶段构建将会是一个非常有帮助的方法</p>\n<p>希望这篇简短的文章对考虑使用Docker进行基于Node.js的应用程序开发或部署的人有些许帮助。</p>\n</div>","title":"Nodejs Docker 镜像体积优化实践","last_reply_at":"2019-04-12T05:27:40.704Z","good":false,"top":false,"reply_count":4,"visit_count":666,"create_at":"2019-04-10T08:29:03.659Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5c22034c3898674067a783fc","author_id":"5b52cbf1fb9e84ec69cc1ca2","tab":"share","content":"<div class=\"markdown-text\"><p>Vscode编辑器用中Angular7提示工具下载量马上达到750万，这意味这说什么？</p>\n<p>说实话Angular7.x相比React vue有更快的编译速度、更快的运行速度。难道王者归来。</p>\n<p><strong>Angular7入门视频教程网盘免费下</strong>：   <a href=\"https://pan.baidu.com/s/1dTItz3tEnP0GxPcExfH68g\">https://pan.baidu.com/s/1dTItz3tEnP0GxPcExfH68g</a></p>\n<p><img src=\"//static.cnodejs.org/Fp_oe68CGoTo4J8Vbpcqc_dVAFhQ\" alt=\"1.png\"></p>\n</div>","title":"Vscode编辑器中Angular7提示工具下载量达到750万 -这意味着什么？ 王者归来来吗？","last_reply_at":"2019-04-12T03:12:55.308Z","good":false,"top":false,"reply_count":26,"visit_count":3062,"create_at":"2018-12-25T10:15:40.046Z","author":{"loginname":"nodeper","avatar_url":"https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"}},{"id":"5c4142063898674067a80677","author_id":"5c0678d9d3b8ab334e8dab20","tab":"share","content":"<div class=\"markdown-text\"><p>在Egg.js框架里面可以非常容易的引入 Koa 中间件生态，下面我们看看Egg.js中如何使用koa的中间件。</p>\n<p>koa-compress 是koa的中间件，下面我们看看Egg.js中如何使用koa-compress</p>\n<h3>1、使用koa-compress 开启服务器Gzip压缩功能，以 koa-compress 为例，在 Koa 中使用的方法：</h3>\n<pre class=\"prettyprint\"><code>const koa = require(&#x27;koa&#x27;);\nconst compress = require(&#x27;koa-compress&#x27;);\n\nconst app = koa();\n\nconst options = { threshold: 2048 };\napp.use(compress(options));\n</code></pre><h3>2、使用koa-compress 在Egg中使用的方法：</h3>\n<p><strong>1、新建app/middleware/compress.js 文件，然后在compress.js文件中写入下面代码</strong></p>\n<pre class=\"prettyprint\"><code>module.exports = require(&#x27;koa-compress&#x27;);\n</code></pre><p><strong>2、在config/config.default.js 中配置中间件</strong></p>\n<pre class=\"prettyprint\"><code>config.middleware = [&#x27;compress&#x27;];\nconfig.compress = { \nthreshold: 1024 &#x2F;&#x2F;它支持指定只有当 body 大于配置的 threshold 时才进行 gzip 压缩\n};\n</code></pre><p>这样我们就在egg中可以使用koa的中间件了 非常简单</p>\n</div>","title":"Egg.js中如何使用koa的中间件","last_reply_at":"2019-04-12T03:10:32.497Z","good":false,"top":false,"reply_count":2,"visit_count":815,"create_at":"2019-01-18T03:03:34.259Z","author":{"loginname":"sinazl","avatar_url":"https://avatars2.githubusercontent.com/u/44309893?v=4&s=120"}},{"id":"5cad657bdad66d658e407615","author_id":"5b39abe057137f22415c51eb","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FqUujCWTBs4lgrDXKMWcAWfLcY7n\" alt=\"image.png\">\n有大佬能解释一番么</p>\n</div>","title":"使用cnpm 安装sharp失败","last_reply_at":"2019-04-12T01:28:32.154Z","good":false,"top":false,"reply_count":3,"visit_count":631,"create_at":"2019-04-10T03:39:39.698Z","author":{"loginname":"nlbydcg","avatar_url":"https://avatars2.githubusercontent.com/u/40027034?v=4&s=120"}},{"id":"5cadb726207b2365936eb9d3","author_id":"5cadb69e207b2365936eb9ca","tab":"share","content":"<div class=\"markdown-text\"><p>一个简单的阅读webapp,技术栈vue+vue-router+webpack+vuex 线上地址：<a href=\"https://websevan.club/#/pages\">https://websevan.club/#/pages</a> 如有帮助 给个星星!\ngithub:<a href=\"https://github.com/shengxingwang/yuebook\">https://github.com/shengxingwang/yuebook</a></p>\n</div>","title":"一个vue开发简单的阅读webapp源码分享","last_reply_at":"2019-04-12T01:10:46.187Z","good":false,"top":false,"reply_count":1,"visit_count":483,"create_at":"2019-04-10T09:28:06.584Z","author":{"loginname":"shengxingwang","avatar_url":"https://avatars3.githubusercontent.com/u/22761197?v=4&s=120"}},{"id":"5caf476adad66d658e40816f","author_id":"5b31b09b57137f22415c4f4a","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p><strong>该文章阅读需要5分钟,更多文章请点击本人博客<a href=\"https://www.halu886.cn\">halu886</a></strong></p>\n</blockquote>\n<ul>\n<li><a href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\">事件循环</a></li>\n<li><a href=\"#%E8%A7%82%E5%AF%9F%E8%80%85\">观察者</a></li>\n<li><a href=\"#%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1\">请求对象</a></li>\n<li><a href=\"#%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83\">执行回调</a></li>\n</ul>\n<h1>事件循环</h1>\n<p>正是事件循环，所以在Node中回调函数如此普遍。</p>\n<p>当进程启动时，Node会创建一个<code>while(true)</code>的循环，每执行一次循环称为一个Tick。Tick的过程首先判断是否有事件，如果有事件则取出事件，且判断判断是否有关联回调，执行关联回调。如果没有事件则退出进程。<br>\n<img src=\"http://resource.halu886.cn/images/async-io-3/1.png?x-oss-process=style/halu-blog-watermark\" alt=\"1\"></p>\n<h1>观察者</h1>\n<p>每个Tick如何判断是否有事件需要被处理呢？这里就需要引入观察者的概念了。\n每个事件循环都有一个或多个监听者，判断当前Tick是否事件需要处理就是询问这些监听者。</p>\n<p>浏览器的也存在监听者，例如一次点击或者加载一个文件。Node的事件则是网络请求，文件I/O。并且每种不同的事件都有对应的观察者。观察者将事件进行了分类。</p>\n<p>事件循环是一个生产者/消费者模型。异步I/O，网络请求负责生产事件，事件传递到监听者中，事件循环则从观察者中取出事件并拓展。</p>\n<p>在Windows中，这个循环基于IOCP创建，在*nix中，则是基于多线程创建。</p>\n<h1>请求对象</h1>\n<p>接下来我们将要举个例子来说明 在Windows中（基于IOCP）异步I/O从Javascript层到内核发生了什么。</p>\n<p>对于一般的非异步I/O回调函数，有我们自行调用。</p>\n<pre class=\"prettyprint language-js\"><code>var forEach = function(list,callback){\n     for(var i = 0; i &lt; list.length;i++){\n          callback(list[i],i,list);\n     }\n}\n</code></pre><p>对于Node的异步I/O，却不由开发者调用。从发起调用后，到调用被执行，中间到底发生了什么?其实从Javascript发起调用到内核执行完异步I/O，产生了一种中间产物，请求对象。</p>\n<p>接下来我们来一起学习一下<code>fs.open()</code>中的回调函数是是如何执行和调用的。</p>\n<pre class=\"prettyprint language-js\"><code>fs.open = function(path,flags,mode,callback){\n     &#x2F;&#x2F;...\n     binding.open(pathModule.makeLong(path),\n                    stringToFlags(flags),\n                    mode,\n                    callback);\n}\n</code></pre><p><code>fs.open()</code>的功能是指定文件路径和参数打开一个文件，获取一个文件描述符，这也是后续所有异步I/O的初始操作。其实Javascript层面是调用C++核心模块，获取文件描述符。</p>\n<p><img src=\"http://resource.halu886.cn/images/async-io-3/2.png?x-oss-process=style/halu-blog-watermark\" alt=\"2\"></p>\n<p>从Javascript调用Node核心模块，核心模块调用C++内建模块，内建模块通过libuv系统调用，这是典型的Node的调用堆栈。libuv作为封装层，实际上调用uv_fs_open()方法。调用过程中，创建了一个FSReqWrap请求对象，所有参数和当前方法都封装在这个对象中，回调函数则被设置在这个对象中的oncomplete_sym属性中。</p>\n<pre class=\"prettyprint language-js\"><code>req_wrap-&gt;object-&gt;Set(oncomplete_sym,callback);\n</code></pre><p>对象包装完毕，在Windows中调用<code>QueueUserWorkItem()</code>把这个对象推入线程池中等待执行</p>\n<pre class=\"prettyprint language-js\"><code>QueueUserWorkItem(&amp;uv_fs_thread_proc,\n                         req,\n                         WT_EXECUTEDEFAULT)\n</code></pre><p><code>QueueUserWorkItem()</code>会接受三个参数，第一个参数是要被执行的方法的引用，第二个则是引用的方法的参数，第三个参数则是执行的标志。当线程池中有可用的参数时，<code>uv_fs_thread_proc()</code>则会通过参数的类型调用相应的底层函数，例如<code>uv_fs_open()</code>,其实调用的是<code>fs_open()</code>。</p>\n<p>至此，Javascript层面的异步I/O至此结束，然后Javascript线程接着执行当前任务的后续操作。当线程池中有空闲的线程时则执行I/O且不会阻塞Javascript线程的后续执行。</p>\n<p>请求对象是异步I/O的重要中间产物，所有状态都保存在这个请求对象中，包括送入线程池以及I/O操纵结束的回调函数执行。</p>\n<h1>执行回调</h1>\n<p>组装好请求对象，将对象送入I/O线程池等待执行，这才是第一步。第二步才是执行回调。</p>\n<p>线程I/O完成操作后，会将结果存储在req-&gt;result上。然后调用<code>PostQueueCompletionStatus()</code>通知IOCP，告知当前对象操作已经完成：</p>\n<pre class=\"prettyprint language-js\"><code>PostQueuedCompletionStatus((loop)-&gt;iocp,o,o,&amp;((req)-&gt;overlapped))\n</code></pre><p><code>PostQueuedCompletionStatus()</code>方法的作用就是向IOCP提交执行状态，并将线程返还给线程池。</p>\n<p>且在每次Tick的执行中，会调用IOCP的<code>GetQueuedCompletetionStatus()</code>检查线程池是否有执行完的请求。如果存在则将请求对象加入到I/O观察者的队列中，然后当作事件处理。</p>\n<p><img src=\"http://resource.halu886.cn/images/async-io-3/3.png?x-oss-process=style/halu-blog-watermark\" alt=\"3\"></p>\n<blockquote>\n<p>以上知识点均来自&lt;&lt;深入浅出Node.js&gt;&gt;，更多细节建议阅读书籍:-)</p>\n</blockquote>\n</div>","title":"浅谈NodeJs异步I/O-3","last_reply_at":"2019-04-11T13:55:54.235Z","good":false,"top":false,"reply_count":0,"visit_count":373,"create_at":"2019-04-11T13:55:54.235Z","author":{"loginname":"halu886","avatar_url":"https://avatars1.githubusercontent.com/u/22374024?v=4&s=120"}},{"id":"5caf0e40207b2365936ec159","author_id":"5b1d495729e6e510415b29b0","tab":"ask","content":"<div class=\"markdown-text\"><p>function fun(callback){\nPromise.then()\n.then(() =&gt; {})\n.then(() =&gt; {})\n.then(() =&gt; {callback()})\n.then(() =&gt; {})\n.then(() =&gt; {})\n}\n一个回调函数包含着一个promise,我想执行到callback就结束，而不执行后面的then,请问有什么优雅的写法么？</p>\n</div>","title":"promise多个then，如何不使用catch跳出中间的then","last_reply_at":"2019-04-11T11:36:08.482Z","good":false,"top":false,"reply_count":3,"visit_count":480,"create_at":"2019-04-11T09:52:00.524Z","author":{"loginname":"helloHT","avatar_url":"https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"}},{"id":"56cd8a91842c03521a7351ec","author_id":"55f0f4159ae0f45035ae49b5","tab":"ask","content":"<div class=\"markdown-text\"><p>项目里面有个生成code128条形码的需求。</p>\n<p>开始在准备用https://github.com/birchroad/node-barc这个的，在win中安装node-convas时受阻，在centos的测试机上安装时又遇到了Package cairo这个问题，所以又找了另外一个，<a href=\"https://github.com/samt/barcode%E3%80%82\">https://github.com/samt/barcode。</a></p>\n<p>这个按照他提供的方法，运行的时候会报spawn gm enoent 这个错，参考帖子https://cnodejs.org/topic/51fc8bd944e76d216ab64939上说的，先后安装了gm、im 然后 npm install …，始终过不去上面那个错误。以上这一步在linux的测试机环境中也没通过。希望大家帮我找找原因。</p>\n</div>","title":"node 使用barcode生成条形码报错 spawn gm enoent","last_reply_at":"2019-04-11T11:21:33.305Z","good":false,"top":false,"reply_count":6,"visit_count":3029,"create_at":"2016-02-24T10:48:49.426Z","author":{"loginname":"loveitdoit","avatar_url":"https://avatars3.githubusercontent.com/u/12961611?v=4&s=120"}},{"id":"5ca5f4936c1de62dce467fed","author_id":"5ca1a9666c1de62dce4667d7","tab":"ask","content":"<div class=\"markdown-text\"><p>先上测试代码吧。</p>\n<blockquote>\n<p>var fs = require(‘fs’);\nvar i = 0;\nfs.writeFile(’./json’+i+’.json’, 1,function(err){\nif(err) console.log(‘写文件操作失败’);\nelse console.log(‘写文件操作成功 -1’);\n});\n//i++;\nfs.writeFile(’./json’+i+’.json’, 111,function(err){\nif(err) console.log(‘写文件操作失败’);\nelse console.log(‘写文件操作成功-2’);\n});\n//i++;</p>\n<p>fs.writeFile(’./json’+i+’.json’, 11111,function(err){\nif(err) console.log(‘写文件操作失败’);\nelse console.log(‘写文件操作成功-3’);\n});\n//i++;</p>\n<p>fs.writeFile(’./json’+i+’.json’, 1111111,function(err){\nif(err) console.log(‘写文件操作失败’);\nelse console.log(‘写文件操作成功-4’);\n});\n//i++;</p>\n<p>fs.writeFile(’./json’+i+’.json’, 111111111,function(err){\nif(err) console.log(‘写文件操作失败’);\nelse console.log(‘写文件操作成功-5’);\n});\n//i++;</p>\n<p>fs.writeFile(’./json’+i+’.json’, 222222222222,function(err){\nif(err) console.log(‘写文件操作失败-6’);\nelse console.log(‘写文件操作成功-6’);\n});</p>\n</blockquote>\n<p>同时发起六个写文件的操作，文件名称相同，也就是往同一个文件里面写数据。\n如果是单线程的话，那么是一个一个顺序执行，\n先执行第一个，把“1”写进去，\n然后执行第二个，把“111”写进去，同时覆盖上一次的操作“1”\n然后执行第三个，以此类推，最后文件里面剩下的只有“222222222222”。</p>\n<p>但是多次运行之后，结果很诡异。有时候文件里是“222222222222”，有的时候是“1”，这个可以理解为“入栈”的先后顺序不一致。</p>\n<p>但是有一次，文件内容是“111111122222”，还有一次内容是“111111111222”。</p>\n<p>这是什么鬼？这是哪来的？如果是单线程，一次只执行一个写入操作，内容绝对不会乱，会覆盖在意料之中。</p>\n<p>难道是传说中的“线程不安全”，但是node不是单线程的吗？</p>\n<p>难道六个写入操作，是同时进行的吗？而且还互相影响？！</p>\n</div>","title":"node写文件的并发问题，是同时写入，还是一个完成后再执行下一个？","last_reply_at":"2019-04-11T06:08:05.504Z","good":false,"top":false,"reply_count":7,"visit_count":973,"create_at":"2019-04-04T12:12:03.725Z","author":{"loginname":"jyk0011","avatar_url":"https://avatars0.githubusercontent.com/u/6062713?v=4&s=120"}},{"id":"5c876535acb681372d4175ce","author_id":"5c876456acb681372d4175c3","tab":"ask","content":"<div class=\"markdown-text\"><p>我是做h5游戏的 目前需要用到websocket\n我知道 node.js 自带的 socket可以传socket的句柄给其他进程\n但是ws的 怎么搞呢 我发现相关资料特别少\n求大佬们 指点迷津</p>\n</div>","title":"请问ws(websocket)模块如何做多进程呢？","last_reply_at":"2019-04-11T04:09:51.222Z","good":false,"top":false,"reply_count":2,"visit_count":624,"create_at":"2019-03-12T07:52:21.663Z","author":{"loginname":"shanxiaoda","avatar_url":"https://avatars3.githubusercontent.com/u/34155285?v=4&s=120"}},{"id":"5cae8157207b2365936ebb46","author_id":"5cae2d7f207b2365936ebb2f","tab":"share","content":"<div class=\"markdown-text\"><p>通过 Robotgo 绑定 JavaScript 和 python 等编程语言，实现 Golang 跨平台、跨语言桌面自动化, 控制鼠标、键盘、位图、屏幕、窗口句柄以及全局事件监听。</p>\n<p>项目地址: <a href=\"https://github.com/vcaesar/robotn\">https://github.com/vcaesar/robotn</a></p>\n<p>示例:</p>\n<pre class=\"prettyprint language-js\"><code>var robot = require(&#x27;robotn&#x27;);\n\nrobot.scroll(10, 10);\nrobot.mouseClick(&quot;left&quot;, true);\nrobot.moveSmooth(100, 200, 1.0, 100.0);\n\nvar fpid = robot.findIds(&quot;Google&quot;)\nconsole.log(&quot;pids... &quot;, fpid)\nif (fpid.length &gt; 0) {\n  robot.activePID(fpid[0])\n  robot.kill(fpid[0])\n}\n\nconsole.log(&quot;--- Please press ctrl + shift + q ---&quot;)\nvar ok = robotgo.AddEvents(&quot;q&quot;, &quot;ctrl&quot;, &quot;shift&quot;)\nif ok {\n    console.log((&quot;add events...&quot;)\n}\n</code></pre><p>python</p>\n<pre class=\"prettyprint language-py\"><code>import robot\n\nrobot.scroll(10, 10)\nrobot.mouseClick(&quot;left&quot;, true)\nrobot.moveSmooth(100, 200, 1.0, 100.0)\n</code></pre></div>","title":"Robotn,  使用 robotgo 绑定 JavaScript 和 Python 的跨平台桌面自动化系统","last_reply_at":"2019-04-11T02:54:39.407Z","good":false,"top":false,"reply_count":3,"visit_count":414,"create_at":"2019-04-10T23:50:47.917Z","author":{"loginname":"vcaesar","avatar_url":"https://avatars0.githubusercontent.com/u/16043470?v=4&s=120"}},{"id":"5caea4f7dad66d658e407bc7","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>译者按：</strong> 通过监听<strong>unhandledrejection</strong>事件，可以捕获未处理的Promise错误。</p>\n<ul>\n<li>原文: <a href=\"http://2ality.com/2016/04/unhandled-rejections.html\">Tracking unhandled rejected Promises</a></li>\n<li>译者: <a href=\"https://www.fundebug.com/\">Fundebug</a></li>\n</ul>\n<p><strong>为了保证可读性，本文采用意译而非直译，并且对源代码进行了大量修改。另外，本文版权归原作者所有，翻译仅用于学习。</strong></p>\n<p>使用<strong>Promise</strong>编写异步代码时，使用<strong>reject</strong>来处理错误。有时，开发者通常会忽略这一点，导致一些错误没有得到处理。例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>function main() {\n    asyncFunc()\n    .then(···)\n    .then(() =&gt; console.log(&#x27;Done!&#x27;));\n}\n</code></pre><p>由于没有使用<strong>catch</strong>方法捕获错误，当<strong>asyncFunc()<strong>函数</strong>reject</strong>时，抛出的错误则没有被处理。</p>\n<p>这篇博客将分别介绍在浏览器与Node.js中，如何捕获那些未处理的Promise错误。</p>\n<h3>浏览器中未处理的Promise错误</h3>\n<p>一些浏览器(例如Chrome)能够捕获未处理的Promise错误。</p>\n<h4>unhandledrejection</h4>\n<p>监听<strong>unhandledrejection</strong>事件，即可捕获到未处理的Promise错误：</p>\n<pre class=\"prettyprint language-javascript\"><code>window.addEventListener(&#x27;unhandledrejection&#x27;, event =&gt; ···);\n</code></pre><p>这个事件是<strong>PromiseRejectionEvent</strong>实例，它有2个最重要的属性：</p>\n<ul>\n<li><code>promise</code>: reject的Promise</li>\n<li><code>reason</code>: Promise的reject值</li>\n</ul>\n<p>示例代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>window.addEventListener(&#x27;unhandledrejection&#x27;, event =&gt;\n{\n    console.log(event.reason); &#x2F;&#x2F; 打印&quot;Hello, Fundebug!&quot;\n});\n\nfunction foo()\n{\n    Promise.reject(&#x27;Hello, Fundebug!&#x27;);\n}\n\nfoo();\n</code></pre><p><a href=\"https://www.fundebug.com/\">Fundebug</a>的<a href=\"https://docs.fundebug.com/notifier/javascript/\">JavaScript</a>错误监控插件监听了<strong>unhandledrejection</strong>事件，因此可以自动捕获未处理Promise错误。</p>\n<h4>rejectionhandled</h4>\n<p>当一个Promise错误最初未被处理，但是稍后又得到了处理，则会触发<strong>rejectionhandled</strong>事件：</p>\n<pre class=\"prettyprint language-javascript\"><code>window.addEventListener(&#x27;rejectionhandled&#x27;, event =&gt; ···);\n</code></pre><p>这个事件是<strong>PromiseRejectionEvent</strong>实例。</p>\n<p>示例代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>window.addEventListener(&#x27;unhandledrejection&#x27;, event =&gt;\n{\n    console.log(event.reason); &#x2F;&#x2F; 打印&quot;Hello, Fundebug!&quot;\n});\n\nwindow.addEventListener(&#x27;rejectionhandled&#x27;, event =&gt;\n{\n    console.log(&#x27;rejection handled&#x27;); &#x2F;&#x2F; 1秒后打印&quot;rejection handled&quot;\n});\n\n\nfunction foo()\n{\n    return Promise.reject(&#x27;Hello, Fundebug!&#x27;);\n}\n\nvar r = foo();\n\nsetTimeout(() =&gt;\n{\n    r.catch(e =&gt;{});\n}, 1000);\n</code></pre><h3>Node.js中未处理的Promise错误</h3>\n<p>监听<strong>unhandledRejection</strong>事件，即可捕获到未处理的Promise错误：</p>\n<pre class=\"prettyprint language-javascript\"><code>process.on(&#x27;unhandledRejection&#x27;, (reason, promise) =&gt; ···);\n</code></pre><p>示例代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>process.on(&#x27;unhandledRejection&#x27;, reason =&gt;\n{\n    console.log(reason); &#x2F;&#x2F; 打印&quot;Hello, Fundebug!&quot;\n});\n\nfunction foo()\n{\n    Promise.reject(&#x27;Hello, Fundebug!&#x27;);\n}\n\nfoo();\n</code></pre><p><strong>注:</strong> Node.js v6.6.0+ 默认会报告未处理的Promise错误，因此不去监听<strong>unhandledrejection</strong>事件也没问题。</p>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>的<a href=\"https://docs.fundebug.com/notifier/nodejs/\">Node.js</a>错误监控插件监听了<strong>unhandledRejection</strong>事件，因此可以自动捕获未处理Promise错误。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://googlechrome.github.io/samples/promise-rejection-events/\">Promise Rejection Events Sample</a></li>\n<li><a href=\"https://nodejs.org/api/process.html#process_event_unhandledrejection\">Event: ‘unhandledRejection’</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2017/10/09/unhandled-pomise-rejection/\">https://blog.fundebug.com/2017/10/09/unhandled-pomise-rejection/</a></p>\n</div>","title":"捕获未处理的Promise错误","last_reply_at":"2019-04-11T02:22:47.438Z","good":false,"top":false,"reply_count":0,"visit_count":367,"create_at":"2019-04-11T02:22:47.438Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5ca56d836c1de62dce467bc1","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要</strong> ：JavaScript 是一个神奇的语言，字符串转数字有 5 种方法，各有各的坑法!</p>\n<ul>\n<li>原文: <a href=\"https://coderwall.com/p/5tlhmw/converting-strings-to-number-in-javascript-pitfalls\">Converting Strings to Number in Javascript: Pitfalls</a></li>\n<li>译者: <a href=\"https://www.fundebug.com/\">Fundebug</a></li>\n</ul>\n<p><strong>本文采用意译，版权归原作者所有</strong></p>\n<p>String 转换为 Number 有很多种方式，我可以想到的有 5 种！</p>\n<pre class=\"prettyprint language-javascript\"><code>parseInt(num); &#x2F;&#x2F; 默认方式 (没有基数)\nparseInt(num, 10); &#x2F;&#x2F; 传入基数 (十位数)\nparseFloat(num); &#x2F;&#x2F; 浮点数\nNumber(num); &#x2F;&#x2F; Number 构造器\n~~num; &#x2F;&#x2F;按位非\nnum &#x2F; 1; &#x2F;&#x2F; 除一个数\nnum * 1; &#x2F;&#x2F; 乘一个数\nnum -\n0 + &#x2F;&#x2F; 减去0\n    num; &#x2F;&#x2F; 一元运算符 &quot;+&quot;\n</code></pre><p>选择哪一种呢？什么时候选择它？为什么选择这种它？我们逐一进行分析，并解析每种方式的常见陷阱。</p>\n<h3>parseInt</h3>\n<p>根据 <a href=\"http://JsPerf.com\">JsPerf.com</a> 的基准测试，大多数浏览器对 parseInt 的响应最佳。虽然它是最快的方式，但使用 preseInt 会碰到一些常见陷阱：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseInt(&quot;08&quot;); &#x2F;&#x2F; returns 0 部分老浏览器.\nparseInt(&quot;44.jpg&quot;); &#x2F;&#x2F; returns 44\n</code></pre><p><code>parseInt</code>: 没有传入基数时，默认是传入的基数为 10 <code>parseInt(num, 10)</code>，如果你不知道 num 属性的类型，不要使用 parseInt 进行字符串转数字。</p>\n<h3>parseFloat</h3>\n<p>如果你不解析 16 进制数，这是一个非常好的选择。例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseInt(-0xff); &#x2F;&#x2F; returns -255\nparseInt(&quot;-0xFF&quot;); &#x2F;&#x2F; returns -255\nparseFloat(-0xff); &#x2F;&#x2F; returns -255\nparseFloat(&quot;-0xFF&quot;); &#x2F;&#x2F; returns 0\n</code></pre><p>注意：字符串中的负十六进制数字是一个特殊情况，如果你用 parseFloat 解析，结果是不正确的。为了避免程序出现 NaN 的情况，应该检查转化后的值。</p>\n<pre class=\"prettyprint language-javascript\"><code>parseFloat(&quot;44.jpg&quot;); &#x2F;&#x2F; return 44\n</code></pre><p><code>parseFloat</code>: 转换十六进制数时要小心，如果你不知道要转换对象的类型，不要使用 parseFloat。</p>\n<h3>按位非</h3>\n<p>可以把字符串转换成整数，但他不是浮点数。如果是一个字符串转换，它将返回 0；</p>\n<pre class=\"prettyprint language-javascript\"><code>~~1.23; &#x2F;&#x2F; returns 1\n~~&quot;1.23&quot;; &#x2F;&#x2F; returns 1\n~~&quot;23&quot;; &#x2F;&#x2F; returns 23\n~~&quot;Hello world&quot;; &#x2F;&#x2F; returns 0\n</code></pre><p>这是什么原理？通过<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#.7E_(Bitwise_NOT)\">翻转</a>每个位，也称为数字的 A1 补码。你可以使用它，但注意只能用来存储整数。所以通常情况不要用它，除非你能确定这个数是在 32 位整数之间的值（因为调用的 ToInt32 的规范）。</p>\n<p><code>按位非</code>：用它确保输入中没有字符，仅用于整数。</p>\n<h3>Number</h3>\n<p>Number 与以上提及的转换方式一样存在这样的问题，解析时试图找出你给他的数字：</p>\n<pre class=\"prettyprint language-javascript\"><code>Number(&quot;023&quot;); &#x2F;&#x2F; returns 23\nNumber(023); &#x2F;&#x2F; returns 19\n</code></pre><p>注意：023 实际上是一个八进制数，无论你怎么做，都是返回 19；对于没有单引号或双引号的十六进制数一样。</p>\n<p>Number 也是 JsPerf 中最慢的之一。</p>\n<p><code>Number</code>：几乎不用它。</p>\n<h3>一元运算符</h3>\n<pre class=\"prettyprint language-javascript\"><code>&quot;1.23&quot; * 1; &#x2F;&#x2F; returns 1.23\n&quot;0xFF&quot; - 0; &#x2F;&#x2F; returns 255\n&quot;0xFF.jpg&quot; &#x2F; 1 + &#x2F;&#x2F; returns NaN\n    &quot;023&quot;; &#x2F;&#x2F; returns 23\n</code></pre><p>一元运算符与其它的解析方式不同，如果是一个 NaN 值，那么返回的也是 NaN 。这是我最喜欢的数值转换方式，因为我认为任何带有字符的对象都不应该被视为 0 或者根据他有多少位来“猜”。我基本使用 <code>+</code> 操作符，因为这个方式不容易混淆。虽然 <code>-0</code> 的用法也很好，但它并没有很好的表达转换为数字的本意。</p>\n<h3>字符串转换为数字的方式总结</h3>\n<p>负十六进制数字符串转换为数字时。应首先将任何其转换为 String（例如通过 <code>+ &quot;&quot;</code> ），然后使用一元运算符或带基数的 parseInt 解析为数字。但是结果不是 NaN 的数值时，使用 parseFloat 更为合适。</p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：</p>\n<p><a href=\"https://blog.fundebug.com/2018/07/07/string-to-number/\">https://blog.fundebug.com/2018/07/07/string-to-number/</a></p>\n</div>","title":"JavaScript字符串转数字的5种方法及其陷阱","last_reply_at":"2019-04-11T02:21:44.297Z","good":false,"top":false,"reply_count":2,"visit_count":502,"create_at":"2019-04-04T02:35:47.403Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5cae9ffbdad66d658e407b4d","author_id":"5c90939f96558e26e1b66e84","tab":"ask","content":"<div class=\"markdown-text\"><p>在组件内写的路由钩子能不能获取数据之类的，或者是路由参数什么的</p>\n</div>","title":"关于vue-router","last_reply_at":"2019-04-11T02:16:47.419Z","good":false,"top":false,"reply_count":4,"visit_count":392,"create_at":"2019-04-11T02:01:31.776Z","author":{"loginname":"xuejiancnode","avatar_url":"https://avatars0.githubusercontent.com/u/48708465?v=4&s=120"}},{"id":"516e0ab46d382773067a5473","author_id":"50cbf5fb637ffa41556d22f2","content":"<div class=\"markdown-text\"><p>我要将用户查询的结果信息保存到csv或者execl（由于没有找到合适的execl库，所以采用csv库保存）中， 结果用execl打开csv文件发现乱码，通过google找到iconv-lite，可结果还是不行 。代码如下：\nfs.open(config.UP_PATH+’/csv/’+troopId+year+month+’.csv’,‘a’);\nvar csvData = ‘“序号”,“检查人”,“检查日期”,“省”,“城市”,“系统”,“售点”,“地址”,“门店类型”,’+shopnames;\nvar b = Iconv.encode(csvData,‘GBK’);\ncsv().from.string(b).to(config.UP_PATH+&quot;/csv/&quot;+troopId+year+month+’.csv’);</p>\n<p>shopnames：是一个中文字符串变量</p>\n</div>","title":"怎么解决数据保存到csv文件乱码问题","last_reply_at":"2019-04-10T14:28:16.858Z","good":false,"top":false,"reply_count":26,"visit_count":48518,"create_at":"2013-04-17T02:36:36.681Z","author":{"loginname":"zjshop","avatar_url":"//gravatar.com/avatar/9515c08503d6ee8bf1612e9bd8273f22?size=48"}},{"id":"5ca59ab231010b2dfbb4333e","author_id":"5ca1a9666c1de62dce4667d7","tab":"ask","content":"<div class=\"markdown-text\"><p>刚学习数据库的操作，向mysql发出申请后，会接着执行后面的代码，同时等待数据库的回调。\n那么如果发出多个请求，多个回调的执行顺序是啥样的呢？</p>\n<p>比如这样的代码</p>\n<blockquote>\n<p>var mysql  = require(‘mysql’);\nvar cnString = require(’…/sqlConnection.json’);\nvar connection = mysql.createConnection(cnString);\nconnection.connect();\nvar  userAddSql = ‘INSERT INTO node_user(id,name,age) VALUES(0,?,?)’;\nvar  userAddSql_Params = [&quot;张洒 ’ – &quot; , 55];\n//增 add\nconnection.query(userAddSql,userAddSql_Params,function (err, result) {\n//回调1\n});\nconnection.end();</p>\n</blockquote>\n<blockquote>\n<p>connection = mysql.createConnection(cnString);\nconnection.connect();\nvar  userAddSql = ‘INSERT INTO node_user(id,name,age) VALUES(0,?,?)’;\nvar  userAddSql_Params = [&quot;张洒 ’ – &quot; , 55];\n//增 add\nconnection.query(userAddSql,userAddSql_Params,function (err, result) {\n//回调2\n});\nconnection.end();</p>\n</blockquote>\n<blockquote>\n<p>connection = mysql.createConnection(cnString);\nconnection.connect();\nvar  userAddSql = ‘INSERT INTO node_user(id,name,age) VALUES(0,?,?)’;\nvar  userAddSql_Params = [&quot;张洒 ’ – &quot; , 55];\n//增 add\nconnection.query(userAddSql,userAddSql_Params,function (err, result) {\n//回调3\n});\nconnection.end();</p>\n</blockquote>\n<blockquote>\n<p>connection = mysql.createConnection(cnString);\nconnection.connect();\nvar  userAddSql = ‘INSERT INTO node_user(id,name,age) VALUES(0,?,?)’;\nvar  userAddSql_Params = [&quot;张洒 ’ – &quot; , 55];\n//增 add\nconnection.query(userAddSql,userAddSql_Params,function (err, result) {\n//回调4\n});\nconnection.end();</p>\n</blockquote>\n<p>预想的是，会按照回调1、2、3、4的顺序被执行，因为node是单线程的，回调函数应该按照申请的顺序被回调。\n但是实际运行几次后发现，每次四个回调的先后执行顺序完全不一样。\n哪个回调先回来都有可能，这是啥原因呢？</p>\n<p>怀疑问题出在mysql方面，但是不能确定。</p>\n<p>所以想问问大家。</p>\n</div>","title":"node + mysql 的回调的先后顺序问题？","last_reply_at":"2019-04-10T13:54:53.674Z","good":false,"top":false,"reply_count":8,"visit_count":640,"create_at":"2019-04-04T05:48:34.567Z","author":{"loginname":"jyk0011","avatar_url":"https://avatars0.githubusercontent.com/u/6062713?v=4&s=120"}},{"id":"5ca0d30b99e62a362ff41ad5","author_id":"57df88ff7d8293463a01e70b","tab":"share","content":"<div class=\"markdown-text\"><h4>上一贴被素质低下的人谩骂，建议cnodejs增加黑名单功能</h4>\n<h1>仓库地址 <a href=\"https://github.com/996icu/996.ICU\">https://github.com/996icu/996.ICU</a></h1>\n<p>996ICU最近的热门事件，因为比较敏感，都担心被企业拉入黑名单，在cnodejs居然只有我一个人敢发贴，我不入地狱谁入地狱，为了广大互联网从业人员，豁出去了，反正我也不打算能写程序到35岁\n工作 996，生病 ICU，说不定ICU的机会都没有，赚那么多钱有用吗？要敢于反抗，不畏强权，即使被生活所迫也不要放弃说“不”的权利，我们热爱工作，我们更热爱生活，我们要陪家人、我们要有时间去谈恋爱、去感受生命的美好\n<strong>程序猿的责任心不容质疑，我可以自愿007，但绝不愿强制996</strong></p>\n<h2>到2019/03/31 21:48，已经达到github star排行榜第四名，已经超过了linux、node、react等项目</h2>\n<p><img src=\"//static.cnodejs.org/Fre1-VOz_Q6R-QZbtifrX-M8Yjp8\" alt=\"QQ图片20190331214609.png\"></p>\n<h2>这些关注996工作制的程序员中，有程序员大牛吗？当然有！我们把粉丝数排名前10的程序员筛了出来。</h2>\n<p><img src=\"//static.cnodejs.org/FtUSgXzvDKwiS2zd78ME8j7bpAsH\" alt=\"0LcMty70Gl.jpeg\">\n排名第一的是一个熟悉的面孔，轮子哥！另外有来自腾讯的Coco，来自滴滴的singwhatiwanna，技术博主颜海镜等，这些人都在关注996。在39987个Star了该repos的程序员中，粉丝数大于1000的有47人，大于500的有110，大于100的有598人。说明还是有很多有影响力的程序员在关注996工作制。\n来源： <a href=\"https://www.yidianzixun.com/article/0LcMtyRT?title_sn=0\">https://www.yidianzixun.com/article/0LcMtyRT?title_sn=0</a></p>\n<p>各行各业都有被压榨，都有在反抗，比如富士康接二连三的跳楼，这些人用命换来了大量工厂的遵纪守法，在这个风口，十几万程序猿正在进行一项伟大的事业，为中国的程序猿们争取合法正当权益，让我们加油！</p>\n<p><strong>法律从来没说给钱多就允许违法，正义可能迟到但从不缺席</strong></p>\n<h2>请文明发表意见</h2>\n</div>","title":"重新开贴，讨论最近热门996ICU，工作 996，生病 ICU，说不定ICU的机会都没有，赚那么多钱有用吗？","last_reply_at":"2019-04-10T13:48:10.804Z","good":false,"top":false,"reply_count":15,"visit_count":1900,"create_at":"2019-03-31T14:47:39.933Z","author":{"loginname":"zengming00","avatar_url":"https://avatars2.githubusercontent.com/u/5255081?v=4&s=120"}},{"id":"5ca6cadf6c1de62dce4680c2","author_id":"5ca1a9666c1de62dce4667d7","tab":"ask","content":"<div class=\"markdown-text\"><p>要求：web服务，记录每次访问记录，保存到文本文件。\n测试目的：异步读写文件是否安全，多人访问下是否可以完整记录。</p>\n<p>代码，先写个最简单的代码进行测试。把每次访问的url记录下来。</p>\n<p>测试方法，在一个网页里使用多个iframe，模拟多人同时访问。</p>\n<blockquote>\n<p>var fs = require(‘fs’);\nvar http = require(“http”);\nhttp.createServer(function (request, response) {\nresponse.writeHeader(200, { “Content-Type”: “text/html” });\nresponse.write(“Hello World编码!&lt;br&gt;\\n”);\nresponse.write(&quot;&lt;br&gt; url:&quot;+request.url);</p>\n<pre class=\"prettyprint\"><code>if (request.url != &#x27;&#x2F;favicon.ico&#x27;){\n    fs.readFile(&#x27;.&#x2F;json.txt&#x27;, &#x27;utf8&#x27;, function(err, data){\n        console.log(data);\n        fs.writeFile(&#x27;.&#x2F;json.txt&#x27;,data +&#x27;\\r\\n&#x27;+ request.url ,function(err){\n            if(err) console.log(&#x27;写文件操作失败&#x27;);\n            else console.log(&#x27;写文件操作成功 &#x27; + request.url);\n        });\n    });\n}\n response.end();\n</code></pre><p>}).listen(8080);</p>\n</blockquote>\n<p>网页访问</p>\n<blockquote>\n<p>&lt;html lang=“en”&gt;\n&lt;head&gt;\n&lt;meta charset=“UTF-8”&gt;\n&lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/1\">http://127.0.0.1:8080/1</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/22\">http://127.0.0.1:8080/22</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/333\">http://127.0.0.1:8080/333</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/4444\">http://127.0.0.1:8080/4444</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/55555\">http://127.0.0.1:8080/55555</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/666666\">http://127.0.0.1:8080/666666</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/7777777\">http://127.0.0.1:8080/7777777</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/88888888\">http://127.0.0.1:8080/88888888</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/999999999\">http://127.0.0.1:8080/999999999</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/aaaaaaaaaa\">http://127.0.0.1:8080/aaaaaaaaaa</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/bbbbbbbbbbb\">http://127.0.0.1:8080/bbbbbbbbbbb</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/cccccccccccc\">http://127.0.0.1:8080/cccccccccccc</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/ddddddddddddd\">http://127.0.0.1:8080/ddddddddddddd</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/eeeeeeeeeeeeee\">http://127.0.0.1:8080/eeeeeeeeeeeeee</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/fffffffffffffff\">http://127.0.0.1:8080/fffffffffffffff</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/gggggggggggggggg\">http://127.0.0.1:8080/gggggggggggggggg</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/hhhhhhhhhhhhhhhhhh\">http://127.0.0.1:8080/hhhhhhhhhhhhhhhhhh</a>”&gt;&lt;/iframe&gt;</p>\n<p>&lt;/body&gt;\n&lt;/html&gt;</p>\n</blockquote>\n<p>首先问问这种写法有没有什么致命问题，如果有的话，怎么改代码。</p>\n<p>这个代码有个小问题，没有事先判断文件是否存在，但是这个不是大事。</p>\n<p>测试方法，打开那个有很多iframe的网页，模拟多次访问，然后看看日志文件，然后刷新页面，再次看内容，重复多次。</p>\n<p>理想情况下，每次访问都会先读取文件内容，然后把url加在最后，在重新保存文件，这样每次访问都会被记录下来，不会有漏掉的。</p>\n<p>但是实际测试的时候却发现，不仅有漏掉的访问记录，而且还会把上一轮的内容覆盖掉。\n但是并不是每次都会把以前的记录覆盖掉。\n完全没发现任何规律。</p>\n<p>刷新两次网页后，日志文件是这个样子的</p>\n<blockquote>\n<p>/cccccccccccc\n/ddddddddddddd\n/eeeeeeeeeeeeee\n/fffffffffffffff\n/gggggggggggggggg\n/hhhhhhhhhhhhhhhhhh\n/1\n/333\n/55555\n/7777777\n/88888888\n/999999999\n/aaaaaaaaaa\n/bbbbbbbbbbb\n/cccccccccccc\n/ddddddddddddd\n/eeeeeeeeeeeeee\n/fffffffffffffff\n/gggggggggggggggg\n/hhhhhhhhhhhhhhhhhh</p>\n</blockquote>\n<p>再刷新网页，又变成这个样子</p>\n<blockquote>\n<p>/666666\n/aaaaaaaaaa\n/bbbbbbbbbbb\n/ddddddddddddd\n/eeeeeeeeeeeeee\n/fffffffffffffffg\n/hhhhhhhhhhhhhhhhhh\n/1\n/333\n/4444\n/55555\n/666666\n/7777777\n/88888888\n/aaaaaaaaaa\n/bbbbbbbbbbb\n/cccccccccccc\n/ddddddddddddd\n/fffffffffffffff\n/hhhhhhhhhhhhhhhhhh</p>\n</blockquote>\n<p>再刷新，简单了，就剩下六行了。</p>\n<blockquote>\n<p>/cccccccccccc\n/ddddddddddddd\n/eeeeeeeeeeeeee\n/fffffffffffffff\n/gggggggggggggggg\n/hhhhhhhhhhhhhhhhhh</p>\n</blockquote>\n<p>每次刷新网页后，日志文件的内容都不完整，而且没发现啥规律。</p>\n</div>","title":"异步读写文件的问题，是我写的代码有问题，还是出大事了？彻底蒙了。","last_reply_at":"2019-04-10T10:02:14.499Z","good":false,"top":false,"reply_count":12,"visit_count":680,"create_at":"2019-04-05T03:26:23.710Z","author":{"loginname":"jyk0011","avatar_url":"https://avatars0.githubusercontent.com/u/6062713?v=4&s=120"}},{"id":"582d121f6efc292b79ff09e2","author_id":"58219f2bd5e70f9005343462","tab":"ask","content":"<div class=\"markdown-text\"><p>一篇帖子阅读数如何获取？如何存储？\n求赐教</p>\n</div>","title":"一篇帖子的阅读数是怎么获得的？","last_reply_at":"2019-04-10T10:00:55.522Z","good":false,"top":false,"reply_count":16,"visit_count":2738,"create_at":"2016-11-17T02:12:47.267Z","author":{"loginname":"mengLLLL","avatar_url":"https://avatars1.githubusercontent.com/u/13366294?v=4&s=120"}},{"id":"5c9b430cfd41137eb7662787","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>对每个接口的传入参数进行校验，是一个Web后端项目的必备功能，有一个npm包叫<a href=\"https://github.com/hapijs/joi\">Joi</a>可以很优雅的完成这个工作，比如这样子：</p>\n<pre class=\"prettyprint\"><code>const schema = {\n    userId: Joi.string()\n};\nconst {error, value} = Joi.validate({ userId: &#x27;a string&#x27; }, schema);\n</code></pre><p>我们使用Typescript是希望得到明确的类型定义，减少出错的可能性。在一个后端项目中，给每个接口定义它的传入参数结构以及返回结果的结构，是一件很值得做的事情，因为这样给后续的维护带来极大的便利。比如这样子：</p>\n<pre class=\"prettyprint\"><code>export type IFooParam = {\n  userId: string\n}\n\nexport type IFooResponse = {\n  name: string\n}\n\nasync foo (param: IFooParam): Promise&lt;IFooResponse&gt; {\n  &#x2F;&#x2F; Your business code\n  return {name: &#x27;bar&#x27;}\n}\n</code></pre><p>现在问题就来了，如果传入参数希望加多一个字段，我们必须得修改2个地方，一个是Joi的校验，一个是IFooParam类型的定义。有没有好的办法解决这个问题呢？</p>\n<h2>Class-validaotr</h2>\n<p>有一个npm包叫<a href=\"https://github.com/typestack/class-validator\">class-validator</a>, 是采用注解的方式进行校验，底层使用的是老牌的校验包<a href=\"https://github.com/chriso/validator.js\">validator.js</a>。<br>\n这次试用，发现通过一些小包装，居然做到像Joi一样优雅的写法，而且更好用！</p>\n<h3>定义传入/返回结构</h3>\n<pre class=\"prettyprint\"><code>import {Length, Min, Max} from &#x27;class-validator&#x27;\n\nexport class IRegister {\n  @Length(11)\n  phone: string\n\n  @Length(2, 10)\n  name: string\n\n  @Min(18)\n  @Max(50)\n  age: number\n}\n\nclass Button {\n  text: string\n}\n\nexport class ORegister {\n  &#x2F;**\n   * user&#x27;s id\n   *&#x2F;\n  userId: string\n\n  buttons: Button[]\n}\n</code></pre><p>这里定义了2个类，IRegister为传入参数，通过class-validator规定的注解方式做校验，ORegister为返回结果。</p>\n<p>class-validator官方提供的方式还不能直接对一个请求的body进行校验，它要求必须要是IRegister类的一个对象，所以需要做一些处理。</p>\n<h3>使用class-transformer做转化</h3>\n<p>跟class-validator的作者也开源了另外一个包，叫<a href=\"https://github.com/typestack/class-transformer\">class-transformer</a>, 可以将一个json转成指定的类的对象，官方的例子是这样的：</p>\n<pre class=\"prettyprint\"><code>import {plainToClass} from &quot;class-transformer&quot;;\n\nlet users = plainToClass(User, userJson); &#x2F;&#x2F; to convert user plain object a single user. also supports arrays\n</code></pre><p>利用这一点，我们写一个小工具：</p>\n<pre class=\"prettyprint\"><code>import * as classTransformer from &#x27;class-transformer&#x27;\nimport {validate} from &#x27;class-validator&#x27;\nimport * as lodash from &#x27;lodash&#x27;\n\nexport class ValidateUtil {\n  private static instance: ValidateUtil\n\n  private constructor () {\n  }\n\n  static getInstance () {\n    return this.instance || (this.instance = new ValidateUtil())\n  }\n\n  async validate (Clazz, data): Promise&lt;any&gt; {\n    const obj = classTransformer.plainToClass(Clazz, data)\n    const errors = await validate(obj)\n    if (errors.length &gt; 0) {\n      console.info(errors)\n      throw new Error(lodash.values(errors[0].constraints)[0])\n    }\n    return obj\n  }\n}\n</code></pre><p>这个小工具提供了一个validate方法，第一个参数是一个类定义，第二个是一个json，它先利用class-transformer将json转成指定类的对象，然后使用class-validator做校验，如果校验错误将抛出错误，否则返回转化后的对象。</p>\n<h3>在Controller中使用</h3>\n<p>有了上面的工具，就可以方便地在代码中对传入参数做校验了，比如这样：</p>\n<pre class=\"prettyprint\"><code>  static async register(ctx) {\n    const iRegister = await ValidateUtil.getInstance().validate(IRegister, ctx.request.body)\n    const oRegister = await UserService.register(iRegister)\n    ctx.body = oRegister\n  }\n</code></pre><h2>新问题</h2>\n<p>到了这里，完美地使用class-validator替换掉了Joi。</p>\n<p>但是还有一个问题没解决，也是之前一直遗留的问题。</p>\n<p>我们使用<a href=\"http://apidocjs.com/\">apidoc</a>编写接口文档，当新增或修改一个接口时，是通过编写一段注释，让apidoc自动生成html文档，将文档地址发给前端，可以减少双方的频繁沟通，而且对前端的体验也是非常好的。比如写这样一段注释：</p>\n<pre class=\"prettyprint\"><code>  &#x2F;**\n   * @api {post} &#x2F;user&#x2F;registerOld registerOld\n   * @apiGroup user\n   * @apiName registerOld\n   * @apiParam {String} name user&#x27;s name\n   * @apiParam {Number} age user&#x27;s age\n   * @apiSuccess {String} userId user&#x27;s id \n   *&#x2F;\n  router.post(&#x27;&#x2F;user&#x2F;registerOld&#x27;, UserController.register)\n</code></pre><p>apidoc会帮我们生成这样的文档： <a href=\"https://user-gold-cdn.xitu.io/2019/3/21/1699f85c7d18d3e3?w=1060&amp;h=916&amp;f=png&amp;s=88262\"><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699f85c7d18d3e3?w=1060&amp;h=916&amp;f=png&amp;s=88262\" alt=\"oldApidocDemo\"></a></p>\n<p>问题比较明显，当我们要新增一个参数时，需要修改一次类的定义，同时还要修改一次apidoc的注释，很烦，由于很烦，文档会慢慢变得没人维护，新同事就会吐槽没有文档或者文档太旧了。</p>\n<p>理想的情况是代码即文档，只需要修改类的定义，apidoc文档自动更新。</p>\n<h2>探索apidoc根据class-validator的定义生成</h2>\n<p>从同事的分享中得知一个废弃的npm包，叫<a href=\"https://www.npmjs.com/package/apidoc-plugin-ts\">apidoc-plugin-ts</a>, 可以实现根据ts的interface定义来生成apidoc的。官方的例子：</p>\n<pre class=\"prettyprint\"><code>filename: .&#x2F;employers.ts\n \nexport interface Employer {\n  &#x2F;**\n   * Employer job title\n   *&#x2F;\n  jobTitle: string;\n  &#x2F;**\n   * Employer personal details\n   *&#x2F;\n  personalDetails: {\n    name: string;\n    age: number;\n  }\n}\n @apiInterface (.&#x2F;employers.ts) {Person}\n</code></pre><p>会转化成：</p>\n<pre class=\"prettyprint\"><code> @apiSuccess {String} jobTitle Job title\n @apiSuccess {Object} personalDetails Empoyer personal details\n @apiSuccess {String} personalDetails.name\n @apiSuccess {Number} personalDetails.age\n</code></pre><p>虽然不知道为什么作者要废弃它，但是它的思想很好，源码也很有帮助。</p>\n<p>给我的启发是，参考这个npm包，写一个针对class定义来生成apidoc的插件就行了。</p>\n<h2>造轮子: apidoc-plugin-class-validator</h2>\n<p>轮子的制造细节不适合在这里陈述，基本上参考apidoc-plugin-ts，目前已经发布在npm上了，<a href=\"https://www.npmjs.com/package/apidoc-plugin-class-validator\">apidoc-plugin-class-validator</a></p>\n<h2>使用apidoc-plugin-class-validator</h2>\n<p>以上面的注册接口为例，使用方法：</p>\n<pre class=\"prettyprint\"><code>  &#x2F;**\n   * @api {post} &#x2F;user&#x2F;register register\n   * @apiGroup user\n   * @apiName register\n   * @apiParamClass (src&#x2F;user&#x2F;io&#x2F;Register.ts) {IRegister}\n   * @apiSuccessClass (src&#x2F;user&#x2F;io&#x2F;Register.ts) {ORegister}\n   *&#x2F;\n  router.post(&#x27;&#x2F;user&#x2F;register&#x27;, UserController.register)\n</code></pre><p>就会生成文档： <a href=\"https://user-gold-cdn.xitu.io/2019/3/21/1699f85c40449b5a?w=1288&amp;h=1224&amp;f=png&amp;s=120386\"><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699f85c40449b5a?w=1288&amp;h=1224&amp;f=png&amp;s=120386\" alt=\"demo\"></a></p>\n<p>后续新增字段，只需修改IRegister类的定义就行，真正做到了修改一处，处处生效，代码即文档的效果。</p>\n<p>本文的demo代码在<a href=\"https://github.com/zhengyhn/apidoc-plugin-class-validator-demo\">这里</a>，这是一个简单的web后端项目，看代码更容易理解。</p>\n<hr>\n<p>著作权归本文作者所有，未经授权，请勿转载，谢谢。</p>\n</div>","title":"使用class-validator替换Joi包的方法","last_reply_at":"2019-04-10T09:18:59.310Z","good":false,"top":false,"reply_count":2,"visit_count":523,"create_at":"2019-03-27T09:31:56.079Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5caaf50ed68ff5064921af62","author_id":"57df88ff7d8293463a01e70b","tab":"share","content":"<div class=\"markdown-text\"><h1>事情是这样的：去年9月公司解散，个人原因瘫痪在床半年多，最近复习了下准备找工作，上了下猎聘网看看，我甚至都没登陆网站！！！没登陆网站！！！没登陆网站！！！</h1>\n<h1>下午以前公司的老板发消息给我，就是下面这位</h1>\n<p><img src=\"//static.cnodejs.org/FgvtDF0MwN99t6B8OOJOqD1B8QS6\" alt=\"QQ图片20190408150857.png\"></p>\n<h1>已举报</h1>\n<p><img src=\"//static.cnodejs.org/Fnkyp7h6C7c7QQ13qy1xCcVVgpI_\" alt=\"微信截图_20190408151015.png\"></p>\n<h1>鬼知道有没有用，只能说违法成本太低，维权成本太高</h1>\n</div>","title":"太可怕了，只要你浏览过招聘网站，公司HR就已经知道了","last_reply_at":"2019-04-10T04:01:15.678Z","good":false,"top":false,"reply_count":11,"visit_count":1791,"create_at":"2019-04-08T07:15:26.556Z","author":{"loginname":"zengming00","avatar_url":"https://avatars2.githubusercontent.com/u/5255081?v=4&s=120"}},{"id":"5c8b0c317ce0df3732428286","author_id":"5c10c50f7ec239239ff561c2","tab":"share","content":"<div class=\"markdown-text\"><p>这个 app “Mathway&quot; 挺强大的，\n你可以通过它特别优化过的键盘很方便地输入数学公式，或者直接拍照截取一个方程，\n尽管这个方程再复杂，这个 app 都可以马上告诉你 x 的解是多少，而且还有详细的解答步骤。</p>\n<p>感觉现在学习机器学习，这个 app 还挺能帮上忙的。\n这里有更详细的介绍：<a href=\"https://mergeek.com?project_id=MK5lYgAM7Zm1wx2k&amp;ref=cnode\">Mergeek: Mathway</a></p>\n<p><img src=\"//static.cnodejs.org/Fnqv5DnAcGdHFUu7Q70sQ4Ocn5ZG\" alt=\"392x696bb.jpg\"></p>\n</div>","title":"分享一个帮你解决数学问题的神器","last_reply_at":"2019-04-10T02:47:01.166Z","good":false,"top":false,"reply_count":2,"visit_count":871,"create_at":"2019-03-15T02:21:37.121Z","author":{"loginname":"Kilen","avatar_url":"https://avatars1.githubusercontent.com/u/2741628?v=4&s=120"}},{"id":"5cad5569d68ff5064921bc10","author_id":"5b39abe057137f22415c51eb","tab":"ask","content":"<div class=\"markdown-text\"><p>node要把腾讯云上服务器迁移到本地 之前一直用的gm的插件进行图片处理 现在迁移内网公司不给装各种预装环境没办法只能改用sharp\n据说sharp的性能也会很快，现在的问题是npm install 就各种报错  运行起来就是刚刚下面图片的错误 求大佬帮吗给看下问题?\n<img src=\"//static.cnodejs.org/Fr3cNMFE7QcqqsCAYkOktiNdaH8O\" alt=\"image.png\"></p>\n</div>","title":"node sharp 迁移服务器问题","last_reply_at":"2019-04-10T02:31:05.781Z","good":false,"top":false,"reply_count":0,"visit_count":517,"create_at":"2019-04-10T02:31:05.780Z","author":{"loginname":"nlbydcg","avatar_url":"https://avatars2.githubusercontent.com/u/40027034?v=4&s=120"}},{"id":"5cab1bdfd68ff5064921b0f3","author_id":"5cab188c7edd13064e05363f","tab":"share","content":"<div class=\"markdown-text\"><p>github设置好邮箱后\n<img src=\"//static.cnodejs.org/Fkv2NaFgTXwhAoJ9O93Nys4g0-R6\" alt=\"image.png\">\n点击通过github登陆，\n点击注册新账号，\n完毕，\n————————————————————————\n如果你这么操作还是登陆不上，欢迎去我的github留言，，我知道你想在这里留言也留言不到。。。。。。</p>\n<p>我登陆了（一年）才登陆上。。。。</p>\n<p>这个登陆操作很迷。。。。。</p>\n<p>我感觉应该加精。。。。。。。。</p>\n</div>","title":"终于成功登陆cnode，下面分享教程","last_reply_at":"2019-04-10T01:04:55.836Z","good":false,"top":false,"reply_count":5,"visit_count":773,"create_at":"2019-04-08T10:01:03.124Z","author":{"loginname":"ganshiqingyuan","avatar_url":"https://avatars0.githubusercontent.com/u/33950951?v=4&s=120"}},{"id":"5cac7ffbd68ff5064921b99a","author_id":"5c85d4b2acb681372d416dd6","tab":"share","content":"<div class=\"markdown-text\"><p>极客学院&amp;腾讯 TAPD —极客开放日活动，本次主题「敏捷开发畅想与实战」。</p>\n<p>多位行业大佬亲临：嘉宾包括中国 IT 界著名意见领袖、敏捷开发布道师熊节先生，源自硅谷、扎根香港的行业独角兽 Aftership CEO Teddy 「陈龙生」先生，腾讯 TAPD 敏捷事业群副总经理杨晓俊先生，极客学院&amp;Toppro 创始人姚尚朗先生。</p>\n<p>这回我们不吹虚的，我们着力探讨：1，哪些企业正在践行敏捷开发以及敏捷如何在真实场景中实现落地； 2，敏捷能否为企业、工程师带来双赢局面； 3，敏捷开发再实施过程中遇到的那些“坑”； 4，如何发挥工程师在“不确定”场景下的最大价值。</p>\n<p>4 月 13 日本周六下午 13：30，腾讯大厦（深南大道） 2 楼 2F 多功能厅，期待你的到来！</p>\n<p>通过链接来报名吧： <a href=\"https://www.huodongxing.com/event/2487232947800\">https://www.huodongxing.com/event/2487232947800</a></p>\n</div>","title":"极客学院&腾讯TAPD·极客开放日【敏捷开发畅想与实战】","last_reply_at":"2019-04-09T11:20:27.646Z","good":false,"top":false,"reply_count":0,"visit_count":586,"create_at":"2019-04-09T11:20:27.646Z","author":{"loginname":"wangxihua916","avatar_url":"https://avatars0.githubusercontent.com/u/37897167?v=4&s=120"}},{"id":"5c97586efd41137eb7660f7b","author_id":"58f837a3bbaf2f3f569be082","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p><strong>这是一个可以“伪造”微博、知乎、豆瓣、简书等网站界面截图的网站。但本网站是为了告诉（不懂编程的）普通人：不要轻易相信网上看到的“截图”！</strong></p>\n<p>项目地址：<a href=\"https://github.com/thegreatjavascript/FakeScreenshot\">https://github.com/thegreatjavascript/FakeScreenshot</a></p>\n<p>在线预览：<a href=\"https://fakes.netlify.com\">https://fakes.netlify.com</a></p>\n</blockquote>\n<p><img src=\"https://ww1.sinaimg.cn/large/007i4MEmgy1g1e1a8k7qdj30k00crglu.jpg\" alt=\"截图预览\"></p>\n<p><strong>当你在互联网上看到一张截图时，你第一反应是什么？</strong></p>\n<p>我曾在技术交流群里发了下面这么一张图，想看看人们的第一反应是什么。</p>\n<p><img src=\"https://ww1.sinaimg.cn/large/007i4MEmgy1g1bqlow4vhj30h20450t7.jpg\" alt=\"vue3.0\"></p>\n<p>“卧槽，这么快？”</p>\n<p>“正好这段时间没事做，学一下”</p>\n<p>“和2.0有什么区别啊？”</p>\n<p>“求你们别更了，我学不动了.jpg”</p>\n<p>“支持TS吗？”</p>\n<p>…</p>\n<p><strong>你看，没有人怀疑这个截图的真实性（当然，也可能有人怀疑但没发声）</strong></p>\n<p>我们都曾看到过各种截屏：包括不限于<code>知乎</code>、<code>微博</code>、<code>豆瓣</code>、<code>NGA</code>、<code>V2EX</code>、<code>QQ</code>、<code>微信</code> 、<code>各种新闻站</code>…</p>\n<p>如果那些截屏内容只涉及到段子还好，但多数情况不是。它们往往和某事/某人有关，这（假截图）就<strong>极有可能</strong>导致人们对该事/人产生错误的看法（之所以说错误，是因为我认为<strong>大多数</strong>虚假截图的制作者都怀有不良动机。）</p>\n<p>再加上<strong>多数人并不会去主动验证该截图描述事情的真伪</strong>，这是“虚假截图”泛滥的重要原因之一。</p>\n<blockquote>\n<p>为什么人们普遍不会去验证截图内容的真伪？</p>\n<p>答案很简单：难。（人们每天接受的信息量太多，但验证某条信息的真伪很难。）</p>\n</blockquote>\n<p>所以我就想，作为一个程序员，我能为此做些什么？</p>\n<p>然后联想到了之前的<strong>一些事儿：</strong></p>\n<p><strong>1</strong></p>\n<p>之前还常玩知乎的时候，凑过不少“热闹”。</p>\n<p>我发现了一个现象：<strong>如果某答主在发表对某事的看法时，附带了截图的话，那么往往就能吸引不少“赞同”。</strong> 因为人们下意识地认为“既然都有截图，那么情况十有八九就是这样吧”。</p>\n<p>好（wu）玩（yu）的是，有两次我还专门撰写了答案，用我伪造的一些荒唐的截图（让人一看就觉得是假的）来提醒其他用户：不要轻易相信高赞答主提供的“所谓截图证据”。</p>\n<p>但是…</p>\n<p>我的回答迅速淹没在洪流中，沉了…</p>\n<p>当时，<strong>我的心情是复杂的…</strong></p>\n<p><strong>2</strong></p>\n<p>我基本每天都会上网，也有在不同渠道看新闻的习惯。当我看到一些明显真实性存疑的东西被广泛传播时，我就很烦，想骂人，想质问他们转发前为什么不先自己去证实下真伪？</p>\n<p>但理智地讲，我也非常清楚：<strong>“现实就是这样。因为现在人们每天接受的信息太多，且求证的难度也太高，所以就极少会有人去求证”。</strong> 这个事实很让人沮丧。</p>\n<p>我最先想到的其实并不是<a href=\"https://github.com/thegreatjavascript/FakeScreenshot\">「虚假截图制作工具/FakeScreenshot」</a>项目。</p>\n<p>而是运营一个专门替别人“求证”某事真实性的微博账户。当然，也不是所有的事情我都可以“搞定”，毕竟我只是一个没有什么社会能量的普通程序员，但仍旧有一些事情我可以求证出来。不过因为近期时间已经被其他事情占用了，因此这个想法一直没有去实施。</p>\n<p>后面我才想到了这个“灵感”（貌似是和别人斗图的时候？:p ）：何不做一个“伪造截图”的网站，<strong>这样任何知道此网站存在的人，心里都会明白这么一件事：“哦，原来各大网站截图都是可以轻易伪造的啊”。这样当他再次看到其他截图的时候，会想起来此网站的存在，然后就会下意识地怀疑截图的真实性了。</strong></p>\n<blockquote>\n<p>有朋友说这是：用“造假”来对抗造假。</p>\n<p>是的，它是！</p>\n</blockquote>\n</div>","title":"对抗假消息：虚假截图制作工具","last_reply_at":"2019-04-09T09:31:50.190Z","good":false,"top":false,"reply_count":8,"visit_count":1277,"create_at":"2019-03-24T10:14:06.578Z","author":{"loginname":"shuiRong","avatar_url":"https://avatars1.githubusercontent.com/u/16076993?v=4&s=120"}},{"id":"5cabff7c7edd13064e053a00","author_id":"59e4bc6b61932717683d23d7","tab":"ask","content":"<div class=\"markdown-text\"><p>egg-core里的egg_loader.js的\ngetServerEnv方法报错</p>\n<p>上一次遇到这个问题，我是通过把依赖删掉重下 来解决的  这次无效</p>\n<p>我不知道该如何解决了，有人知道这是怎么回事嘛，或者指个方向？\n谢谢了\n<img src=\"//static.cnodejs.org/Flwm8_n3gkbKq8gs4J5lKtPj2V-Z\" alt=\"屏幕快照 2019-04-09 上午9.49.40.png\">\n<img src=\"//static.cnodejs.org/Fv3CgTlPYTPWblukfPl6ZIZEJgN5\" alt=\"屏幕快照 2019-04-09 上午10.02.05.png\"></p>\n</div>","title":"请求帮助 使用vscode调试egg.js 报错 ’config/env‘ file not exist","last_reply_at":"2019-04-09T09:03:23.070Z","good":false,"top":false,"reply_count":2,"visit_count":285,"create_at":"2019-04-09T02:12:12.268Z","author":{"loginname":"Benny233","avatar_url":"https://avatars0.githubusercontent.com/u/12774730?v=4&s=120"}},{"id":"5ca4384e31010b2dfbb42a6b","author_id":"5ca1a9666c1de62dce4667d7","tab":"ask","content":"<div class=\"markdown-text\"><p>初学node，听说他是单线程的，只能使用一个核心，如果CPU是多核心的，那么只能用一个核心，其他核心无法使用。对吧？</p>\n<p>发现了一个问题。本来是想看看精确计时的问题，但是在死循环的时候，看了一下CPU的使用情况，发现四个核心都利用起来了。\n反复试验了几次都是这样，没有其他软件运行。不知道是怎么回事。</p>\n<blockquote>\n<p>var i=0;\nvar j=0;</p>\n</blockquote>\n<p>var star = (new Date()).getTime();  //普通计时\nvar star2 = time();  //精确计时\nvar star3 = time();  //精确计时</p>\n<p>while (true){\ni++;j++;</p>\n<pre class=\"prettyprint\"><code>var t = time() - star2;\nvar msg = i + &#x27;_&#x27; + (new Date()).getTime() + &#x27;_&#x27; + time() + &#x27;_&#x27; +t;\n&#x2F;&#x2F;计算每循环100次需要的时间，运行结果可得，时间并不一致\nif (j==100){\n    var t2 = (new Date()).getTime() - star;\n    var t3 = time() - star3;\n    console.log(msg + &#x27;_&#x27; + t2+ &#x27;_&#x27; + t3); &#x2F;&#x2F;每百次用时\n    star = (new Date()).getTime();\n    star3 = time();\n    j=0;\n}\nelse {\n    console.log(msg);\n}\n\nstar2 = time();\n</code></pre><p>}\nfunction time(){\nvar diff = process.hrtime();\nreturn diff[0] * 1000 + diff[1] / 1e6; // nano second -&gt; ms</p>\n<p>}</p>\n<p><img src=\"//static.cnodejs.org/FgQ2pWQIjYgzNYTGpxGjbV4YePfS\" alt=\"time10.png\"></p>\n<p>开始运行，四个核的使用率都上来了，关闭运行，四个核的使用率都下来了。</p>\n<p>是不是我理解错了？</p>\n</div>","title":"不是说node不能利用多核心CPU吗？","last_reply_at":"2019-04-09T07:53:00.135Z","good":false,"top":false,"reply_count":27,"visit_count":1554,"create_at":"2019-04-03T04:36:30.928Z","author":{"loginname":"jyk0011","avatar_url":"https://avatars0.githubusercontent.com/u/6062713?v=4&s=120"}},{"id":"5c9aefaafd41137eb7662373","author_id":"57cb8e015f7f910c27696d6f","tab":"share","content":"<div class=\"markdown-text\"><p>这是由 Electron &amp; Vue.js 编写的，为程序员服务的编程工具</p>\n<p>目前提供了四个版块：</p>\n<ul>\n<li>正则表达式</li>\n<li>时间戳转化</li>\n<li>颜色盒子</li>\n<li>Json 转化</li>\n</ul>\n<p>在这几个模块中，可以发现使用组件化的好处，处理多个组件之间各种数据变化非常方便。\n当然这里面很多转化都是自己造轮子。。。\n<img src=\"https://github.com/TsaiKoga/it-tools/raw/master/src/renderer/assets/IT-Tools-preview.gif\" alt=\"IT Tools\"></p>\n<h2>项目地址：</h2>\n<p>Github 地址：<a href=\"https://github.com/TsaiKoga/it-tools\">https://github.com/TsaiKoga/it-tools</a></p>\n<h2>求 Star</h2>\n<p>感兴趣的朋友可以 star 或 fork，或是给我你的宝贵意见，互相学习一下</p>\n<p>下面介绍一下我写 正则表达式内容，写的不好，望见谅…</p>\n<h3>下载 electron-vue</h3>\n<p>克隆项目，从 electron-vue 克隆项目，然后开始编写代码；</p>\n<pre class=\"prettyprint\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;SimulatedGREG&#x2F;electron-vue.git\n</code></pre><p>通过&quot;正则表达式&quot;这个模块，来了解 Vue 组件通信；</p>\n<p>electron-vue 一开始已经为你生成一些文件页面，我们可以按照他的方法创建我们自己的页面；</p>\n<h3>创建路由：</h3>\n<p>src/renderer/router/index.js 文件中添加路由：</p>\n<pre class=\"prettyprint language-js\"><code>export default new Router({\n  routes: [\n    {\n      path: &#x27;&#x2F;&#x27;,\n      name: &#x27;landing-page&#x27;,\n      component: require(&#x27;@&#x2F;components&#x2F;LandingPage&#x27;).default\n    },\n    {\n      path: &#x27;&#x2F;regex-page&#x27;,\n      name: &#x27;regex-page&#x27;,\n      component: require(&#x27;@&#x2F;components&#x2F;RegexPage&#x27;).default\n    }\n]\n});\n</code></pre><p>这里我们的 url 为 /regex-page，并且 require 了 RegexPage 组件，这个组件要放置在 components 目录下，所以我创建了文件：src/renderer/components/RegexPage.vue</p>\n<h4>编写组件：</h4>\n<p>可以通过复制 LandingPage.vue 组件，将它改成新组件即可：</p>\n<p>要实现这个页面，头部两个输入框，输入后都能与下面的 textarea 内容进行比较处理，得出结论；</p>\n<p>这个用 组件化 vue 比纯粹用 js jquery 的 dom 操作要方便太多了；</p>\n<p>通过 template 包裹写成 vue 组件：</p>\n<pre class=\"prettyprint\"><code>&lt;template&gt;\n  &lt;div id=&quot;regex-page&quot;&gt;\n　　　　&lt;div class=&quot;regex-inner&quot; v-show=&quot;currentTab === &#x27;Home&#x27;&quot;&gt;\n        　　　　&lt;div class=&quot;regex-top&quot;&gt;\n          　　　　　　&lt;div class=&quot;regex-top-label&quot;&gt;\n            　　　　　　　　&lt;label&gt;Your regular expression:&lt;&#x2F;label&gt;\n          　　　　　　&lt;&#x2F;div&gt;\n          　　　　　　&lt;div class=&quot;regex-top-fields&quot;&gt;\n            　　　　　　　　&lt;div class=&quot;regex-diagonal&quot;&gt;&#x2F;&lt;&#x2F;div&gt;\n            　　　　　　　　&lt;div class=&quot;regex-diagnoal-input&quot;&gt;\n              　　　　　　　　　　&lt;input type=&quot;text&quot; name=&quot;regex-exp&quot; @input=&#x27;execRegex&#x27; :value=&#x27;regexExp&#x27; &#x2F;&gt;\n            　　　　　　　　&lt;&#x2F;div&gt;\n\n 　　　　　　　　&lt;div class=&quot;regex-diagonal&quot;&gt;&#x2F;&lt;&#x2F;div&gt;\n            　　　　　　　　&lt;div&gt;\n              　　　　　　　　　　&lt;input type=&quot;text&quot; name=&quot;regex-opt&quot; @input=&quot;execRegex&quot; :value=&quot;regexOpt&quot; &#x2F;&gt;\n            　　　　　　　　&lt;&#x2F;div&gt;\n          　　　　　　&lt;&#x2F;div&gt;\n        　　　　　&lt;&#x2F;div&gt;\n\n 　　　　　&lt;div class=&quot;regex-bottom&quot;&gt;\n          　　　　　　&lt;div class=&quot;regex-content&quot;&gt;\n            　　　　　　　　&lt;label&gt;Your test string: &lt;&#x2F;label&gt;\n            　　　　　　　　&lt;textarea class=&quot;regex-textarea&quot; name=&quot;regex-content&quot; @input=&quot;execRegex&quot; :value=&#x27;regexCont&#x27;&gt;&lt;&#x2F;textarea&gt;\n          　　　　　　&lt;&#x2F;div&gt;\n\n 　　　　　　&lt;div class=&quot;result-content result-init&quot; v-if=&quot;regexResult[&#x27;status&#x27;] == 0&quot;&gt;\n            　　　　　　　　{{ regexResult[&#x27;content&#x27;] }}\n          　　　　　　&lt;&#x2F;div&gt;\n\n\n          　　　　　　&lt;div class=&quot;result-content result-match&quot; v-if=&quot;regexResult[&#x27;status&#x27;] == 1&quot;&gt;\n            　　　　　　　　&lt;div&gt;\n              　　　　　　　　　　&lt;div class=&quot;regex-match-btn&quot;&gt;\n                　　　　　　　　　　　　&lt;label&gt;Match Result:&lt;&#x2F;label&gt;\n                　　　　　　　　　　　　&lt;a href=&quot;javascript:void(0)&quot; class=&quot;clean-fields&quot; @click=&quot;cleanAllFields&quot;&gt;Clean Fields&lt;&#x2F;a&gt;\n              　　　　　　　　　　&lt;&#x2F;div&gt;\n              　　　　　　　　　　&lt;div class=&quot;result-item&quot;&gt;\n　　　　　　　　　　　　&lt;span v-for=&quot;(cont, indx) in regexResult[&#x27;matchedContext&#x27;]&quot; :class=&quot;indx%2 !== 0 ? &#x27;match&#x27; : null&quot;&gt;{{ cont }}&lt;&#x2F;span&gt;\n              　　　　　　　　　　&lt;&#x2F;div&gt;\n            　　　　　　　　&lt;&#x2F;div&gt;\n            　　　　　　　　&lt;ul v-if=&quot;regexResult[&#x27;content&#x27;].length &gt; 0&quot;&gt;\n              　　　　　　　　　　&lt;label&gt;Match Groups:&lt;&#x2F;label&gt;\n              　　　　　　　　　　&lt;div class=&quot;match-groups&quot;&gt;\n                　　　　　　　　　　　　&lt;li v-for=&quot;(itemGroup, index) in regexResult[&#x27;content&#x27;]&quot;&gt;\n                  　　　　　　　　　　　　　　&lt;div class=&quot;group-item&quot;&gt;\n                    　　　　　　　　　　　　　　&lt;label&gt;Match Group {{ index + 1 }}:&lt;&#x2F;label&gt;\n                    　　　　　　　　　　　　　　&lt;ul&gt;\n                      　　　　　　　　　　　　　　　　&lt;li v-if=&quot;i !== 0&quot; v-for=&quot;(item, i) in itemGroup&quot;&gt;{{ i }}: {{ item }}&lt;&#x2F;li&gt;\n                    　　　　　　　　　　　　　　&lt;&#x2F;ul&gt;\n                  　　　　　　　　　　　　　　&lt;&#x2F;div&gt;\n                　　　　　　　　　　　　&lt;&#x2F;li&gt;\n              　　　　　　　　　　&lt;&#x2F;div&gt;\n            　　　　　　　　&lt;&#x2F;ul&gt;\n          　　　　　　　　&lt;&#x2F;div&gt;\n\n 　　　　　　　　&lt;div class=&quot;result-content result-not-match&quot; v-if=&quot;regexResult[&#x27;status&#x27;] == -1&quot;&gt;\n            　　　　　　　　　　{{ regexResult[&#x27;content&#x27;] }}\n          　　　　　　　　&lt;&#x2F;div&gt;\n        　　　　　　&lt;&#x2F;div&gt;\n      　　　　&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport { mapState, mapActions } from &#x27;vuex&#x27;\n\nexport default {\n  name: &#x27;regex-page&#x27;,\n  computed: {\n    ...mapState(&#x27;Regex&#x27;, {\n      regexExp: state =&gt; state.regexExp,\n      regexOpt: state =&gt; state.regexOpt,\n      regexCont: state =&gt; state.regexCont,\n      regexResult: state =&gt; state.regexResult})\n  },\n\n    methods: {\n    ...mapActions(&#x27;Regex&#x27;, [\n      &#x27;setNav&#x27;,\n      &#x27;cleanFields&#x27;,\n      &#x27;regexMatch&#x27;\n    ]),\n    cleanAllFields () {\n      this.cleanFields()\n    },\n    execRegex (event) {\n      this.regexMatch(event)\n    },\n    updateNav (title, index) {\n      this.setNav({ title: title, index: index })\n    }\n\n  }\n\n}\n&lt;&#x2F;script&gt;\n&lt;style lang=&quot;scss&quot; scoped&gt;\n * {\n\n  }\n&lt;&#x2F;style&gt;\n</code></pre><p>至于，输入框之间的交互，我使用 vuex 来实现他们之间数据的传递；</p>\n<h3>使用 Vuex 管理状态：</h3>\n<p><strong>一、创建 store 目录，并创建 modules 目录用来管理不同的命名空间的 State, Actions, Mutations 创建 src/renderer/store/modules/Regex.js 文件</strong>：</p>\n<pre class=\"prettyprint\"><code>const state = {\n  regexExp: &#x27;&#x27;,\n  regexOpt: &#x27;&#x27;,\n  regexCont: &#x27;&#x27;,\n  regexResult: { status: 0, content: &quot;Here&#x27;s result.&quot; }\n}\n\nconst mutations = {\n  REGEX_MATCH (state, target) {\n    if (target.name === &#x27;regex-exp&#x27;) {\n      state.regexExp = target.value\n    }\n    if (target.name === &#x27;regex-opt&#x27;) {\n      state.regexOpt = target.value\n    }\n    if (target.name === &#x27;regex-content&#x27;) {\n      state.regexCont = target.value\n    }\n    ...\n}\n\n\nconst actions = {\n  cleanFields ({ commit }) {\n    commit(&#x27;CLEAN_FIELDS&#x27;)\n  },\n  regexMatch ({ commit }, payload) {\n    commit(&#x27;REGEX_MATCH&#x27;, payload.target)\n  }\n}\n\n\nexport default {\n  state,\n  mutations,\n  actions\n}\n</code></pre><p>state 给默认状态；</p>\n<p>mutations 更改对应 state ；</p>\n<p>actions 用于写异步来改变状态或提交 mutations 的更改；</p>\n<p>state 的方法被我写在 computed，这样组件中可以使用；</p>\n<p>在 methods 方法中使用 mapActions，并定义其他方法来调用这些 action ；</p>\n<p><strong>二、main.js 加入 store 容器</strong></p>\n<pre class=\"prettyprint language- js\"><code>import App from &#x27;.&#x2F;App&#x27;\nimport router from &#x27;.&#x2F;router&#x27;\nimport store from &#x27;.&#x2F;store&#x27;\n\nif (!process.env.IS_WEB) Vue.use(require(&#x27;vue-electron&#x27;))\nVue.http = Vue.prototype.$http = axios\nVue.config.productionTip = false\n\nnew Vue({\n  components: { App },\n  router,\n  store,\n  template: &#x27;&lt;App&#x2F;&gt;&#x27;\n}).$mount(&#x27;#app&#x27;)\n</code></pre><p><strong>三、组件中通过 computed 或 data 使用 State，通过 methods 触发 Actions 方法</strong></p>\n<pre class=\"prettyprint language- js\"><code>import { mapState, mapActions } from &#x27;vuex&#x27;\n\nexport default {\n  name: &#x27;regex-page&#x27;,\n  computed: {\n    ...mapState(&#x27;Regex&#x27;, {\n      regexExp: state =&gt; state.regexExp,\n      regexOpt: state =&gt; state.regexOpt,\n      regexCont: state =&gt; state.regexCont,\n      regexResult: state =&gt; state.regexResult})\n    },\n\n    methods: {\n    ...mapActions(&#x27;Regex&#x27;, [\n      &#x27;setNav&#x27;,\n      &#x27;cleanFields&#x27;,\n      &#x27;regexMatch&#x27;\n    ]),\n    cleanAllFields () {\n      this.cleanFields()\n    },\n    execRegex (event) {\n      this.regexMatch(event)\n    },\n    updateNav (title, index) {\n      this.setNav({ title: title, index: index })\n    }\n\n  }\n}\n</code></pre><p>在组件文件中引用了</p>\n<p>mapState, mapActions 方法，他可以获取这个 store 里的 state 和 action 方法，</p>\n<p>不过要注意命名空间的使用，此处使用了 Regex 作为命名空间，所以要在 mapState 和 mapActions 中加 命名空间；</p>\n<p>命名空间定义文件在：src/renderer/store/modules/index.js 文件；</p>\n<pre class=\"prettyprint language- js\"><code>const files = require.context(&#x27;.&#x27;, false, &#x2F;\\.js$&#x2F;)\nconst modules = {}\n\nfiles.keys().forEach(key =&gt; {\n  if (key === &#x27;.&#x2F;index.js&#x27;) return\n  modules[key.replace(&#x2F;(\\.\\&#x2F;|\\.js)&#x2F;g, &#x27;&#x27;)] = files(key).default\n  modules[key.replace(&#x2F;(\\.\\&#x2F;|\\.js)&#x2F;g, &#x27;&#x27;)][&#x27;namespaced&#x27;] = true\n})\n\nexport default modules\n</code></pre><p>但是直接 (‘ Regex ’, [regexExp: state =&gt; state.regexExp]) 是无法使用的，必须在 module 中声明 namespaced: true 才可以；</p>\n<p>… mapActions() 是将里面的对象 扁平化 到 外面的对象中；</p>\n<p>直接 mapActions 只是打开了方法，还未执行：</p>\n<p>删除 createSharedMutations() 的方法后，action 生效；</p>\n<p><strong>绑定到组件上</strong></p>\n<pre class=\"prettyprint\"><code>&lt;input type=&quot;text&quot; name=&quot;regex-exp&quot; @input=&#x27;execRegex&#x27; value=&#x27;regexExp&#x27; &#x2F;&gt;\n</code></pre><h3>生成桌面应用</h3>\n<p>运行命令：</p>\n<pre class=\"prettyprint language- sh\"><code>npm run build:mas # 生成 mac 应用\nnpm run build:linux # 生成 linux 应用\nnpm run build:win32 # 生成 windows 应用\n</code></pre><p>可以在 /build 目录中看到生成的应用目录</p>\n</div>","title":"使用 Electron-Vue 开发的协助程序员的开发工具 IT-Tools","last_reply_at":"2019-04-09T06:10:30.846Z","good":false,"top":false,"reply_count":2,"visit_count":702,"create_at":"2019-03-27T03:36:10.182Z","author":{"loginname":"TsaiKoga","avatar_url":"https://avatars1.githubusercontent.com/u/5005072?v=4&s=120"}},{"id":"5cab4e217edd13064e053791","author_id":"5cab4dba7edd13064e05378e","tab":"ask","content":"<div class=\"markdown-text\"><p>在egg中加入egg-sequelize后，npm run dev报错，尝试过很多次，也换过数据库，都报错\n请问这是什么问题</p>\n<blockquote>\n<p>2019-04-08 21:22:18,797 ERROR 12252 nodejs.AgentWorkerDiedError: [master] agent_worker#1:10556 died (code: 1, signal: null)\nat Master.onAgentExit (F:\\MX\\MX_0.2\\node_modules\\egg-cluster\\lib\\master.js:341:17)\nat Master.emit (events.js:182:13)\nat Messenger.sendToMaster (F:\\MX\\MX_0.2\\node_modules\\egg-cluster\\lib\\utils\\messenger.js:137:17)\nat Messenger.send (F:\\MX\\MX_0.2\\node_modules\\egg-cluster\\lib\\utils\\messenger.js:102:12)\nat ChildProcess.agentWorker.once (F:\\MX\\MX_0.2\\node_modules\\egg-cluster\\lib\\master.js:232:22)\nat Object.onceWrapper (events.js:273:13)\nat ChildProcess.emit (events.js:182:13)\nat Process.ChildProcess._handle.onexit (internal/child_process.js:240:12)\nname: &quot;AgentWorkerDiedError&quot;\npid: 12252\nhostname:</p>\n</blockquote>\n</div>","title":"在egg框架中加入egg-sequelize后报错","last_reply_at":"2019-04-09T04:21:00.681Z","good":false,"top":false,"reply_count":3,"visit_count":331,"create_at":"2019-04-08T13:35:29.666Z","author":{"loginname":"praeteritis","avatar_url":"https://avatars3.githubusercontent.com/u/12553751?v=4&s=120"}},{"id":"5cabfe75d68ff5064921b4a0","author_id":"52cce7827a15a38466a94b4b","tab":"share","content":"<div class=\"markdown-text\"><p>程序员是一个整体偏理性的群体，凡事都喜欢问个 Why\\How\\What？但是因为种种原因，我发现身边很多同事朋友对【保险】这件事的认识比少，或者存在一些思想误区。我个人从两年前开始关注保险行业，经过持续的学习和认识，发现保险对于绝大多数个人和家庭来说都是非常重要的一项资产配置，我自己也在过去的一年中逐步完成了个人保险配置。本期 Chat 就将为大家分享关于个人和家庭保险配置的相关知识。</p>\n<p>本场 Chat 的主要内容有：</p>\n<p>Why：保险对于个人及家庭的意义\nHow：各个险种的保障作用、适用场景、配置思路\nWhat： 个人买保险的途径、购买过程需要关注点、购买过程不需要关注的点\n理论上本次 Chat 适合所有人，无论有没有兴趣，多了解一些总归是好的。</p>\n<p><img src=\"https://refined-x.com/asset/a/insurance-configuration.jpg\" alt></p>\n</div>","title":"奋斗路上的安全边际，程序员保险配置指南","last_reply_at":"2019-04-09T03:39:53.821Z","good":false,"top":false,"reply_count":3,"visit_count":569,"create_at":"2019-04-09T02:07:49.819Z","author":{"loginname":"tower1229","avatar_url":"https://avatars1.githubusercontent.com/u/4016839?v=4&s=120"}},{"id":"5c949d11fd41137eb76608ab","author_id":"580f6fcab37ee8fb339787ea","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FgUfHkjYr6VWmRR044Mwp9SvZaz6\" alt=\"image.png\"></p>\n</div>","title":"cnpm最近两天是炸了么？？？","last_reply_at":"2019-04-09T02:08:07.579Z","good":false,"top":false,"reply_count":11,"visit_count":1252,"create_at":"2019-03-22T08:30:09.721Z","author":{"loginname":"lzq920","avatar_url":"https://avatars0.githubusercontent.com/u/37999725?v=4&s=120"}},{"id":"5c9c671f484eeb3634157e41","author_id":"5aef3aa30a36e5312d6ecd82","tab":"ask","content":"<div class=\"markdown-text\"><h3>需求</h3>\n<p>有一个 HTTP 接口 A，后端会执行一段异步任务\n发一个 HTTP 请求到 B 站点，B 站点异步执行后 callback A 站点的 HTTP 接口。</p>\n<p>我想客户端请求的时候阻塞一下 A &lt;—&gt; B 这个过程，让客户端使用 A 的时候基本无感，有没有什么比较好的处理方案？</p>\n<h3>现有方案</h3>\n<p>标记每一个请求，A 接口上轮询等待 B 接口的返回结果。有其他更好的事件流或者闭包处理方案吗？\n伪代码</p>\n<pre class=\"prettyprint language-js\"><code>const POOL = {}\nfunction sleep(timer = 100) {\n  return new Promise(resolve =&gt; {\n    setTimeout(resolve, timer)\n  })\n}\n\n&#x2F;&#x2F; 客户端请求的接口\nasync function handle(ctx) {\n  const tid = Math.random().toString()\n  await axios.post(&#x27;xxx&#x27;, { tid })\n  POOL[tid] = null\n  for (let i = 0; i &lt;= 100; i++) {\n    &#x2F;&#x2F; 轮询 POOL 有没有返回值\n    if (POOL[tid]) {\n\t   break\n\t}\n    await sleep()\n  }\n  const res = POOL[tid]\n  if (!res) {\n    ctx.throw(500)\n  }\n  ctx.body = res\n}\n\nasync function callback() {\n  const { tid, payload } = ctx.request.body\n  if (POOL[tid] !== undefined) {\n    POOL[tid] = payload\n  }\n  ctx.body = &#x27;ok&#x27;\n}\n\n</code></pre></div>","title":"HTTP 请求异步资源，后端阻塞等待怎么高效实现？","last_reply_at":"2019-04-09T02:01:47.620Z","good":false,"top":false,"reply_count":8,"visit_count":566,"create_at":"2019-03-28T06:18:07.155Z","author":{"loginname":"wiviwiv","avatar_url":"https://avatars0.githubusercontent.com/u/25006774?v=4&s=120"}},{"id":"5cabf7cb7edd13064e053944","author_id":"5c2e23963898674067a7ae2b","tab":"ask","content":"<div class=\"markdown-text\"><p>相关 issue <a href=\"https://github.com/Microsoft/TypeScript/issues/2873\">https://github.com/Microsoft/TypeScript/issues/2873</a></p>\n<p>我目前的解决方法是手动给返回结果标注类型。</p>\n<pre class=\"prettyprint\"><code>interface TypedCommonStorageInterface {\n  &#x2F;** --------图床--------- *&#x2F;\n\n  addImageHosting(imageHosting: ImageHosting): Promise&lt;ImageHosting[]&gt;;\n\n  getImageHosting(): Promise&lt;ImageHosting[]&gt;;\n}\n\n\ntype PromiseType&lt;T extends Promise&lt;any&gt;&gt; = T extends Promise&lt;infer U&gt;\n  ? U\n  : never;\n\n   const imageHostingList: PromiseType&lt;\n      ReturnType&lt;typeof storage.addImageHosting&gt;\n    &gt; = yield call(storage.addImageHosting, imageHosting);\n</code></pre></div>","title":"redux-saga 在用 typescript 开发时 call 的返回值类型怎么确定？","last_reply_at":"2019-04-09T01:39:23.857Z","good":false,"top":false,"reply_count":0,"visit_count":274,"create_at":"2019-04-09T01:39:23.857Z","author":{"loginname":"DiamondYuan","avatar_url":"https://avatars1.githubusercontent.com/u/9692408?v=4&s=120"}},{"id":"5cab18b97edd13064e053649","author_id":"590a90375bb7efe417431fd4","tab":"ask","content":"<div class=\"markdown-text\"><p><a href=\"http://socket.io\">socket.io</a> 先合界面连接成功了，然后登录网站，把用户信息放进 session，但是 socket.request.session 中还是原来的值，并没有后面添加的用户信息。这个如何解决。\nnodejs 代码如下</p>\n<pre class=\"prettyprint\"><code>const io = require(&#x27;socket.io&#x27;).listen(&#x27;8082&#x27;, { origins: &#x27;*&#x27; })\nconst schedule = require(&#x27;node-schedule&#x27;)\n\nio.set(&#x27;transports&#x27;, [\n  &#x27;websocket&#x27;,\n  &#x27;flashsocket&#x27;,\n  &#x27;htmlfile&#x27;,\n  &#x27;xhr-polling&#x27;,\n  &#x27;jsonp-polling&#x27;,\n  &#x27;polling&#x27;\n])\nio.set(&#x27;origins&#x27;, &#x27;*:*&#x27;)\n\nconst app = new express()\n\nconst sessionStore = new session.MemoryStore({ reapInterval: 3600 * 1000 })\nconst sessionMiddleware = session({\n    secret: &#x27;Stefanie Sun&#x27;,\n    store: sessionStore,\n    resave: false, &#x2F;&#x2F; 强制更新 session\n    saveUninitialized: true,  &#x2F;&#x2F; \n    cookie: { \n        maxAge: 8 * 3600 * 1000,  &#x2F;&#x2F; 过期时 8 小时\n        secure: false &#x2F;&#x2F; http 访问时 secure 为 false\n  }, \n    rolling: true\n})\nio.use((socket, next) =&gt; {\n  sessionMiddleware(socket.request, socket.request.res, next);\n})\napp.use(sessionMiddleware)\nroutes(app)\n\nio.on(&#x27;connection&#x27;, (socket) =&gt; {\n  const comment_schedule = schedule.scheduleJob(&#x27;*&#x2F;10 * * * * *&#x27;, async () =&gt; {         &#x2F;** 10s查询一次是否有新的内容 **&#x2F;\n    const COOKIE_STR = socket.request.session\n    console.log(COOKIE_STR)\n  })\n})\n</code></pre><p>是否必须要登录之后再连接才能获取呢。</p>\n</div>","title":"socket.io 中的 socket.request.session 无法获取连接成功之后设置的 session","last_reply_at":"2019-04-08T09:47:37.981Z","good":false,"top":false,"reply_count":0,"visit_count":248,"create_at":"2019-04-08T09:47:37.981Z","author":{"loginname":"hellomrbigshot","avatar_url":"https://avatars1.githubusercontent.com/u/16463481?v=4&s=120"}},{"id":"5cab0f9dd68ff5064921b046","author_id":"5cab0e857edd13064e0535a4","tab":"ask","content":"<div class=\"markdown-text\"><p>import { PopupSelect } from ‘<a href=\"/user/atlaskit\">@atlaskit</a>/select’;\n**提示的信息：**module &quot;e:/mygit/atlassian-organizer-4-8/atlassian-organizer/node_modules/<a href=\"/user/atlaskit\">@atlaskit</a>/select/dist/cjs/index&quot;\n无法找到模块“<a href=\"/user/atlaskit\">@atlaskit</a>/select”的声明文件。“e:/mygit/atlassian-organizer-4-8/atlassian-organizer/node_modules/<a href=\"/user/atlaskit\">@atlaskit</a>/select/dist/cjs/index.js”隐式拥有 “any” 类型。\nTry <code>npm install @types/atlaskit__select</code> if it exists or add a new declaration (.d.ts) file containing <code>declare module '[@atlaskit](/user/atlaskit)/select';</code>ts(7016)\n无法找到模块“<a href=\"/user/atlaskit\">@atlaskit</a>/select”的声明文件。“e:/mygit/atlassian-organizer-4-8/atlassian-organizer/node_modules/<a href=\"/user/atlaskit\">@atlaskit</a>/select/dist/cjs/index.js”隐式拥有 “any” 类型。\nTry <code>npm install @types/atlaskit__select</code> if it exists or add a new declaration (.d.ts) file containing <code>declare module '[@atlaskit](/user/atlaskit)/select';</code>ts(7016)\n无法找到模块“<a href=\"/user/atlaskit\">@atlaskit</a>/select”的声明文件。“e:/mygit/atlassian-organizer-4-8/atlassian-organizer/node_modules/<a href=\"/user/atlaskit\">@atlaskit</a>/select/dist/cjs/index.js”隐式拥有 “any” 类型。\n按照官方的文档引用的 链接：<a href=\"https://atlaskit.atlassian.com/packages/core/select/example/popup-select\">https://atlaskit.atlassian.com/packages/core/select/example/popup-select</a></p>\n</div>","title":"无法找到模块@atlaskit/select","last_reply_at":"2019-04-08T09:43:17.291Z","good":false,"top":false,"reply_count":1,"visit_count":238,"create_at":"2019-04-08T09:08:45.383Z","author":{"loginname":"TheBigP","avatar_url":"https://avatars2.githubusercontent.com/u/33213320?v=4&s=120"}},{"id":"5caaf1737edd13064e05346c","author_id":"5a0d348fe2f4b8ea22496498","tab":"share","content":"<div class=\"markdown-text\"><h3>契约测试</h3>\n<p>为前后端对接的过程中会出现信息不对称，以及工作进度不一致的情况，因此希望通过事先约定好API返回数据的文档，根据文档来开发后端代码，以及生产可以被前端调用的虚拟的API，帮助前后端能够同时开展工作并且保持前后端代码的正确性，加快后期的系统集成测试甚至是取消系统集成测试。</p>\n<p>我们将以上的做法称之为契约测试。契约测试最开始的概念由 Martin Fowler 提出，它又被称之为：消费者驱动的契约测试（Consumer Driven Contracts），简称CDC。这里的契约是指软件系统中各个服务间交互的数据标准格式，更多的指消费端（client）和提供端（server）之间交互的API的格式。</p>\n<p>契约测试带来的变化主要是：</p>\n<ol>\n<li>将前后端测试解耦，前后端可以分别在对方还没有完成工作的时候就开展测试；</li>\n<li>将测试过程前移，加速或者取代集成测试；</li>\n<li>保证数据的一致性，让后端服务返回的数据就是前端想要得到的。</li>\n</ol>\n<p>我做了一张图方便大家理解CDC的概念：\n<img src=\"//static.cnodejs.org/Fo0W59jC5vVOD4YOcJ32B6Y1jeKs\" alt=\"1.png\"></p>\n<p>上图经历了三个步骤：</p>\n<ol>\n<li>消费者（广义的前端）根据业务需要编写好契约文件，契约文件里面编写了需要返回的数据；</li>\n<li>消费者（广义的前端）向契约文件（实际上是一个API服务）发起请求，得到预期的结果，验证前端业务逻辑是否正确；</li>\n<li>契约文件（实际上是一个API服务）向提供者（广义的后端）发起请求，得到后端真实的返回结果并且与契约文件中的数据规则进行校验，判断后端返回的数据是否满足契约的要求。如果无法通过校验，说明提供者的服务发生了改变，或者是没有按照契约所规定的来进行开发。</li>\n</ol>\n<p>如果通过了上面的三步，我们可以认为前后端对于契约的理解和实现是一致的，等到真正集成之后也不会出现问题。</p>\n<h3>Pact 契约测试框架</h3>\n<p>之前业内较为常见的做法是通过Pact（一个契约测试框架）进行契约测试：通过前端开发人员编写代码进行测试并生成Pact契约文件，后端通过Pact Brocker等服务管理契约以及调用等。</p>\n<p>但是Pact也存在一些缺点：</p>\n<ol>\n<li>需要引入Pact的相关文件以及正确搭建服务，用起来需要一定的时间成本</li>\n<li>生成的返回数据不够灵活，无法编写代码生成复杂的随机数据；</li>\n<li>无法判断请求参数来返回不同的结果；</li>\n<li>需要开发人员额外编写代码，增加了工作量；</li>\n<li>存在代码入侵的情况，并且目前支持的语言较少；</li>\n<li>模糊了开发与测试人员之间的界限，管理不当容易导致重复劳动；</li>\n</ol>\n<p>由于有以上的不足之处，Pact 在实际应用的效果往往并不理解。因此我们提出了通过 Mock API 以及测试用例实现更快速、更有效地契约测试。</p>\n<h3>通过 EOLINKER API Studio 实现契约测试</h3>\n<p>EOLINKER API Studio（<a href=\"https://s.growingio.com/gke2DD\">https://www.eolinker.com</a>） 提供了UI实现的 Mock API，配合API Studio 的测试用例与自动化测试，可以帮助研发团队更快速、更有效地实现契约测试。</p>\n<h4>什么是Mock API？</h4>\n<p>通过 Mock API，您可以事先编写好 API 的数据生成规则，由 API Studio 动态生成 API 的返回数据。开发人员通过访问 Mock API 的 URL 来获得所需要的数据，完成对接工作。</p>\n<p>在 API Studio中，同一个项目中的 Mock API 的地址前缀是相同的（<a href=\"http://xn--mock-f96g.eolinker.com/uasyd1/%E2%80%A6%EF%BC%89%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%B0%86\">如mock.eolinker.com/uasyd1/…），因此可以在代码中将</a> Mock API 的地址前缀作为全局变量，项目上线时仅需替换变量的值即可改变整个项目的 API 请求地址前缀。</p>\n<p><img src=\"//static.cnodejs.org/FnK9GhoacAQ7f9UJE8-auwPmDplX\" alt=\"2.jpg\"></p>\n<h4>创建Mock API，实现前端的契约测试</h4>\n<p>在EOLINKER API Studio中，创建 Mock API 之前需要先创建API文档（或者导入Postman、Swagger等数据），API文档可以作为前后端对接的依据。这里我创建了一个简单的用户登录API文档：</p>\n<p><img src=\"//static.cnodejs.org/FqVi51Y2CvnNuce9LjIrkyV0atwR\" alt=\"3.jpg\"></p>\n<p>创建好API文档之后，点击 Mock API 标签进入Mock API的管理页面，在这里可以快速创建多个Mock API，并且根据不同的请求参数返回相应的数据：</p>\n<p><img src=\"//static.cnodejs.org/FtUpJN_bQ_uXNgSdaIGrLPvOQm2d\" alt=\"4.jpg\"></p>\n<p>创建一个 Mock API 期望，我们希望当传递user_name=123和user_psw=112233时，Mock Server返回登录成功的数据，这里返回的数据类型选择Json，填写好Json的格式以及内容即可：</p>\n<p><img src=\"//static.cnodejs.org/FpbtjZ63cXcfaYyGYQK8d3zTibju\" alt=\"5.jpg\"></p>\n<p>点击预览按钮可以看到是我们希望得到的返回数据，然后确定保存即可：</p>\n<p><img src=\"//static.cnodejs.org/FrRhBGeQXyIXXbNWsBqkVDfF939Y\" alt=\"6.jpg\"></p>\n<p>通过这种方式可以创建多个Mock API，并且通过请求红框处的 Mock API URL 得到返回结果：</p>\n<p><img src=\"//static.cnodejs.org/FkMLOYDcsRQif2QXi-Mlx6V3Jrx3\" alt=\"7.jpg\"></p>\n<p>API Studio 中也提供了强大的 API 测试的功能，我们直接在平台上对刚才的登录成功的 Mock API 发起请求，可以看到当我们传递正确的参数时，可以得到预期的返回结果，至此契约测试的前端契约就已经完成了：</p>\n<p><img src=\"//static.cnodejs.org/FnQyihoA1yqGiGw-JWW58QKI5Yjj\" alt=\"8.jpg\"></p>\n<h4>创建测试用例，实现后端的契约测试：</h4>\n<p>传统的契约测试其实并不能够保证测试的覆盖率，因为前端开发人员提供的契约文件很可能无法覆盖所有的请求情况，导致出现漏测的情况。</p>\n<p>因此 API Studio 建议将后端的契约测试交给测试人员负责，这样可以提供更完善的测试用例，并且可以结合各类CI工具实现自动化测试。</p>\n<p>由于 API Studio 基于 API 文档来实现契约测试、API用例测试、API自动化测试等功能，因此可以将前端、后端、测试人员解耦，工作的流程可以进一步改进为下图所示，前后端、测试人员可以同时开展工作，并且测试用例可以导入到自动化测试中成为长期的定时测试任务。</p>\n<p><img src=\"//static.cnodejs.org/FoxjwNMfI9IIEs7LFKKzCcA3AQAA\" alt=\"9.png\"></p>\n<p>由于测试用例与自动化测试所包含的内容较多，如有需要可以前往 EOLINKER API Studio 官方网站（<a href=\"http://www.eolinker.com/#/?ref=cnodejs\">https://www.eolinker.com</a>）或者是查阅 API Studio 帮助文档，在此不再赘述。</p>\n</div>","title":"为什么要抛弃Pact？如何快速实现契约测试（CDC）","last_reply_at":"2019-04-08T07:00:03.486Z","good":false,"top":false,"reply_count":0,"visit_count":484,"create_at":"2019-04-08T07:00:03.486Z","author":{"loginname":"wardennn","avatar_url":"https://avatars0.githubusercontent.com/u/33686934?v=4&s=120"}},{"id":"5caae462d68ff5064921ae7e","author_id":"541bf946ad60405c1f14b770","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文来自<a href=\"https://item.jd.com/12573168.html\">《深入浅出Vue.js》</a>模板编译原理篇的第九章，主要讲述了如何将模板解析成AST，这一章的内容是全书最复杂且烧脑的章节。本文未经排版，真实纸质书的排版会更加精致。</p>\n</blockquote>\n<p>通过第8章的学习，我们知道解析器在整个模板编译中的位置。我们只有将模板解析成AST后，才能基于AST做优化或者生成代码字符串，那么解析器是如何将模板解析成AST的呢？</p>\n<p>本章中，我们将详细介绍解析器内部的运行原理。</p>\n<h2>9.1 解析器的作用</h2>\n<p>解析器要实现的功能是将模板解析成AST。</p>\n<p>例如：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div&gt;\n  &lt;p&gt;{{name}}&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n</code></pre><p>上面的代码是一个比较简单的模板，它转换成AST后的样子如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>{\n  tag: &quot;div&quot;\n  type: 1,\n  staticRoot: false,\n  static: false,\n  plain: true,\n  parent: undefined,\n  attrsList: [],\n  attrsMap: {},\n  children: [\n    {\n      tag: &quot;p&quot;\n      type: 1,\n      staticRoot: false,\n      static: false,\n      plain: true,\n      parent: {tag: &quot;div&quot;, ...},\n      attrsList: [],\n      attrsMap: {},\n      children: [{\n        type: 2,\n        text: &quot;{{name}}&quot;,\n        static: false,\n        expression: &quot;_s(name)&quot;\n      }]\n    }\n  ]\n}\n</code></pre><p>其实AST并不是什么很神奇的东西，不要被它的名字吓倒。它只是用JS中的对象来描述一个节点，一个对象代表一个节点，对象中的属性用来保存节点所需的各种数据。比如，<code>parent</code>属性保存了父节点的描述对象，<code>children</code>属性是一个数组，里面保存了一些子节点的描述对象。再比如，<code>type</code>属性代表一个节点的类型等。当很多个独立的节点通过<code>parent</code>属性和<code>children</code>属性连在一起时，就变成了一个树，而这样一个用对象描述的节点树其实就是AST。</p>\n<h2>9.2 解析器内部运行原理</h2>\n<p>事实上，解析器内部也分了好几个子解析器，比如HTML解析器、文本解析器以及过滤器解析器，其中最主要的是HTML解析器。顾名思义，HTML解析器的作用是解析HTML，它在解析HTML的过程中会不断触发各种钩子函数。这些钩子函数包括开始标签钩子函数、结束标签钩子函数、文本钩子函数以及注释钩子函数。</p>\n<p>伪代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseHTML(template, {\n    start (tag, attrs, unary) {\n        &#x2F;&#x2F; 每当解析到标签的开始位置时，触发该函数\n    },\n    end () {\n        &#x2F;&#x2F; 每当解析到标签的结束位置时，触发该函数\n    },\n    chars (text) {\n        &#x2F;&#x2F; 每当解析到文本时，触发该函数\n    },\n    comment (text) {\n        &#x2F;&#x2F; 每当解析到注释时，触发该函数\n    }\n})\n</code></pre><p>你可能不能很清晰地理解，下面我们举个简单的例子：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div&gt;&lt;p&gt;我是Berwin&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;\n</code></pre><p>当上面这个模板被HTML解析器解析时，所触发的钩子函数依次是：<code>start</code>、<code>start</code>、<code>chars</code>、<code>end</code>、<code>end</code>。</p>\n<p>也就是说，解析器其实是从前向后解析的。解析到<code>&lt;div&gt;</code>时，会触发一个标签开始的钩子函数<code>start</code>；然后解析到<code>&lt;p&gt;</code>时，又触发一次钩子函数<code>start</code>；接着解析到<code>我是Berwin</code>这行文本，此时触发了文本钩子函数<code>chars</code>；然后解析到<code>&lt;/p&gt;</code>，触发了标签结束的钩子函数<code>end</code>；接着继续解析到<code>&lt;/div&gt;</code>，此时又触发一次标签结束的钩子函数<code>end</code>，解析结束。</p>\n<p>因此，我们可以在钩子函数中构建AST节点。在<code>start</code>钩子函数中构建元素类型的节点，在<code>chars</code>钩子函数中构建文本类型的节点，在<code>comment</code>钩子函数中构建注释类型的节点。</p>\n<p>当HTML解析器不再触发钩子函数时，就代表所有模板都解析完毕，所有类型的节点都在钩子函数中构建完成，即AST构建完成。</p>\n<p>我们发现，钩子函数<code>start</code>有三个参数，分别是<code>tag</code>、<code>attrs</code>和<code>unary</code>，它们分别代表标签名、标签的属性以及是否是自闭合标签。</p>\n<p>而文本节点的钩子函数<code>chars</code>和注释节点的钩子函数<code>comment</code>都只有一个参数，只有<code>text</code>。这是因为构建元素节点时需要知道标签名、属性和自闭合标识，而构建注释节点和文本节点时只需要知道文本即可。</p>\n<p>什么是自闭合标签？举个简单的例子，<code>input</code>标签就属于自闭合标签：<code>&lt;input type=&quot;text&quot; /&gt;</code>，而<code>div</code>标签就不属于自闭合标签：<code>&lt;div&gt;&lt;/div&gt;</code>。</p>\n<p>在<code>start</code>钩子函数中，我们可以使用这三个参数来构建一个元素类型的AST节点，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>function createASTElement (tag, attrs, parent) {\n    return {\n        type: 1,\n        tag,\n        attrsList: attrs,\n        parent,\n        children: []\n    }\n}\n\nparseHTML(template, {\n    start (tag, attrs, unary) {\n        let element = createASTElement(tag, attrs, currentParent)\n    }\n})\n</code></pre><p>在上面的代码中，我们在钩子函数<code>start</code>中构建了一个元素类型的AST节点。</p>\n<p>如果是触发了文本的钩子函数，就使用参数中的文本构建一个文本类型的AST节点，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseHTML(template, {\n    chars (text) {\n        let element = {type: 3, text}\n    }\n})\n</code></pre><p>如果是注释，就构建一个注释类型的AST节点，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseHTML(template, {\n    comment (text) {\n        let element = {type: 3, text, isComment: true}\n    }\n})\n</code></pre><p>你会发现，9.1节中看到的AST是有层级关系的，一个AST节点具有父节点和子节点，但是9.2节中介绍的创建节点的方式，节点是被拉平的，没有层级关系。因此，我们需要一套逻辑来实现层级关系，让每一个AST节点都能找到它的父级。下面我们介绍一下如何构建AST层级关系。</p>\n<p>构建AST层级关系其实非常简单，我们只需要维护一个栈（stack）即可，用栈来记录层级关系，这个层级关系也可以理解为DOM的深度。</p>\n<p>HTML解析器在解析HTML时，是从前向后解析。每当遇到<code>开始标签</code>，就触发钩子函数<code>start</code>。每当遇到<code>结束标签</code>，就会触发钩子函数<code>end</code>。</p>\n<p>基于HTML解析器的逻辑，我们可以在每次触发钩子函数<code>start</code>时，把当前构建的节点推入栈中；每当触发钩子函数<code>end</code>时，就从栈中弹出一个节点。</p>\n<p>这样就可以保证每当触发钩子函数<code>start</code>时，栈的最后一个节点就是当前正在构建的节点的父节点，如图9-1所示。</p>\n<p><img src=\"http://p7.qhimg.com/t016fc0c45c684b380c.jpg\" alt=\"栈\">\n图9-1 使用栈记录DOM层级关系（<strong>英文为代码体</strong>）</p>\n<p>下面我们用一个具体的例子来描述如何从0到1构建一个带层级关系的AST。</p>\n<p>假设有这样一个模板：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div&gt;\n    &lt;h1&gt;我是Berwin&lt;&#x2F;h1&gt;\n    &lt;p&gt;我今年23岁&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n</code></pre><p>上面这个模板被解析成AST的过程如图9-2所示。</p>\n<p><img src=\"http://p3.qhimg.com/t01e3f773553bc714b8.jpg\" alt=\"构建AST的过程\"></p>\n<p>图9-2给出了构建AST的过程，图中的黑底白数字代表解析的步骤，具体如下。</p>\n<p>(1) 模板的开始位置是<code>div</code>的开始标签，于是会触发钩子函数<code>start</code>。<code>start</code>触发后，会先构建一个<code>div</code>节点。此时发现栈是空的，这说明<code>div</code>节点是根节点，因为它没有父节点。最后，将<code>div</code>节点推入栈中，并将模板字符串中的<code>div</code>开始标签从模板中截取掉。</p>\n<p>(2) 这时模板的开始位置是一些空格，这些空格会触发文本节点的钩子函数，在钩子函数里会忽略这些空格。同时会在模板中将这些空格截取掉。</p>\n<p>(3) 这时模板的开始位置是<code>h1</code>的开始标签，于是会触发钩子函数<code>start</code>。与前面流程一样，<code>start</code>触发后，会先构建一个<code>h1</code>节点。此时发现栈的最后一个节点是<code>div</code>节点，这说明<code>h1</code>节点的父节点是<code>div</code>，于是将<code>h1</code>添加到<code>div</code>的子节点中，并且将<code>h1</code>节点推入栈中，同时从模板中将<code>h1</code>的开始标签截取掉。</p>\n<p>(4) 这时模板的开始位置是一段文本，于是会触发钩子函数<code>chars</code>。<code>chars</code>触发后，会先构建一个文本节点，此时发现栈中的最后一个节点是<code>h1</code>，这说明文本节点的父节点是<code>h1</code>，于是将文本节点添加到<code>h1</code>节点的子节点中。由于文本节点没有子节点，所以文本节点不会被推入栈中。最后，将文本从模板中截取掉。</p>\n<p>(5) 这时模板的开始位置是<code>h1</code>结束标签，于是会触发钩子函数<code>end</code>。<code>end</code>触发后，会把栈中最后一个节点弹出来。</p>\n<p>(6) 与第(2)步一样，这时模板的开始位置是一些空格，这些空格会触发文本节点的钩子函数，在钩子函数里会忽略这些空格。同时会在模板中将这些空格截取掉。</p>\n<p>(7) 这时模板的开始位置是<code>p</code>开始标签，于是会触发钩子函数<code>start</code>。<code>start</code>触发后，会先构建一个<code>p</code>节点。由于第(5)步已经从栈中弹出了一个节点，所以此时栈中的最后一个节点是<code>div</code>，这说明<code>p</code>节点的父节点是<code>div</code>。于是将<code>p</code>推入<code>div</code>的子节点中，最后将<code>p</code>推入到栈中，并将<code>p</code>的开始标签从模板中截取掉。</p>\n<p>(8) 这时模板的开始位置又是一段文本，于是会触发钩子函数<code>chars</code>。当<code>chars</code>触发后，会先构建一个文本节点，此时发现栈中的最后一个节点是<code>p</code>节点，这说明文本节点的父节点是<code>p</code>节点。于是将文本节点推入<code>p</code>节点的子节点中，并将文本从模板中截取掉。</p>\n<p>(9) 这时模板的开始位置是<code>p</code>的结束标签，于是会触发钩子函数<code>end</code>。当<code>end</code>触发后，会从栈中弹出一个节点出来，也就是把<code>p</code>标签从栈中弹出来，并将<code>p</code>的结束标签从模板中截取掉。</p>\n<p>(10) 与第(2)步和第(6)步一样，这时模板的开始位置是一些空格，这些空格会触发文本节点的钩子函数并且在钩子函数里会忽略这些空格。同时会在模板中将这些空格截取掉。</p>\n<p>(11) 这时模板的开始位置是<code>div</code>的结束标签，于是会触发钩子函数<code>end</code>。其逻辑与之前一样，把栈中的最后一个节点弹出来，也就是把<code>div</code>弹了出来，并将<code>div</code>的结束标签从模板中截取掉。</p>\n<p>(12)这时模板已经被截取空了，也就代表着HTML解析器已经运行完毕。这时我们会发现栈已经空了，但是我们得到了一个完整的带层级关系的AST语法树。这个AST中清晰写明了每个节点的父节点、子节点及其节点类型。</p>\n<h2>9.3 HTML解析器</h2>\n<p>通过前面的介绍，我们发现构建AST非常依赖HTML解析器所执行的钩子函数以及钩子函数中所提供的参数，你一定会非常好奇HTML解析器是如何解析模板的，接下来我们会详细介绍HTML解析器的运行原理。</p>\n<h3>9.3.1 运行原理</h3>\n<p>事实上，解析HTML模板的过程就是循环的过程，简单来说就是用HTML模板字符串来循环，每轮循环都从HTML模板中截取一小段字符串，然后重复以上过程，直到HTML模板被截成一个空字符串时结束循环，解析完毕，如图9-2所示。</p>\n<p>在截取一小段字符串时，有可能截取到开始标签，也有可能截取到结束标签，又或者是文本或者注释，我们可以根据截取的字符串的类型来触发不同的钩子函数。</p>\n<p>循环HTML模板的伪代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>function parseHTML(html, options) {\n  while (html) {\n    &#x2F;&#x2F; 截取模板字符串并触发钩子函数\n  }\n}\n</code></pre><p>为了方便理解，我们手动模拟HTML解析器的解析过程。例如，下面这样一个简单的HTML模板：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div&gt;\n  &lt;p&gt;{{name}}&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n</code></pre><p>它在被HTML解析器解析的过程如下。</p>\n<p>最初的HTML模板：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;&lt;div&gt;\n  &lt;p&gt;{{name}}&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;&#96;\n</code></pre><p>第一轮循环时，截取出一段字符串<code>&lt;div&gt;</code>，并且触发钩子函数<code>start</code>，截取后的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;\n  &lt;p&gt;{{name}}&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;&#96;\n</code></pre><p>第二轮循环时，截取出一段字符串：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;\n  &#96;\n</code></pre><p>并且触发钩子函数<code>chars</code>，截取后的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;&lt;p&gt;{{name}}&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;&#96;\n</code></pre><p>第三轮循环时，截取出一段字符串<code>&lt;p&gt;</code>，并且触发钩子函数<code>start</code>，截取后的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;{{name}}&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;&#96;\n</code></pre><p>第四轮循环时，截取出一段字符串<code>{{name}}</code>，并且触发钩子函数<code>chars</code>，截取后的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;&#96;\n</code></pre><p>第五轮循环时，截取出一段字符串<code>&lt;/p&gt;</code>，并且触发钩子函数<code>end</code>，截取后的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;\n&lt;&#x2F;div&gt;&#96;\n</code></pre><p>第六轮循环时，截取出一段字符串：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;\n&#96;\n</code></pre><p>并且触发钩子函数<code>chars</code>，截取后的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;&lt;&#x2F;div&gt;&#96;\n</code></pre><p>第七轮循环时，截取出一段字符串<code>&lt;/div&gt;</code>，并且触发钩子函数<code>end</code>，截取后的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;&#96;\n</code></pre><p>解析完毕。</p>\n<p>HTML解析器的全部逻辑都是在循环中执行，循环结束就代表解析结束。接下来，我们要讨论的重点是HTML解析器在循环中都干了些什么事。</p>\n<p>你会发现HTML解析器可以很聪明地知道它在每一轮循环中应该截取哪些字符串，那么它是如何做到这一点的呢？</p>\n<p>通过前面的例子，我们发现一个很有趣的事，那就是每一轮截取字符串时，都是在整个模板的开始位置截取。我们根据模板开始位置的片段类型，进行不同的截取操作。</p>\n<blockquote>\n<p>例如，上面例子中的第一轮循环：如果是以开始标签开头的模板，就把开始标签截取掉。</p>\n<p>再例如，上面例子中的第四轮循环：如果是以文本开始的模板，就把文本截取掉。</p>\n</blockquote>\n<p>这些被截取的片段分很多种类型，示例如下。</p>\n<ul>\n<li>开始标签，例如<code>&lt;div&gt;</code>。</li>\n<li>结束标签，例如<code>&lt;/div&gt;</code>。</li>\n<li>HTML注释，例如<code>&lt;!-- 我是注释 --&gt;</code>。</li>\n<li>DOCTYPE，例如<code>&lt;!DOCTYPE html&gt;</code>。</li>\n<li>条件注释，例如<code>&lt;!--[if !IE]&gt;--&gt;我是注释&lt;!--&lt;![endif]--&gt;</code>。</li>\n<li>文本，例如<code>我是Berwin</code>。</li>\n</ul>\n<p>通常，最常见的是开始标签、结束标签、文本以及注释。</p>\n<h3>9.3.2 截取开始标签</h3>\n<p>上一节中我们说过，每一轮循环都是从模板的最前面截取，所以只有模板以开始标签开头，才需要进行开始标签的截取操作。</p>\n<p>那么，如何确定模板是不是以开始标签开头？</p>\n<p>在HTML解析器中，想分辨出模板是否以开始标签开头并不难，我们需要先判断HTML模板是不是以<code>&lt;</code>开头。</p>\n<p>如果HTML模板的第一个字符不是<code>&lt;</code>，那么它一定不是以开始标签开头的模板，所以不需要进行开始标签的截取操作。</p>\n<p>如果HTML模板以<code>&lt;</code>开头，那么说明它至少是一个以标签开头的模板，但这个标签到底是什么类型的标签，还需要进一步确认。</p>\n<p>如果模板以<code>&lt;</code>开头，那么它有可能是以开始标签开头的模板，同时它也有可能是以结束标签开头的模板，还有可能是注释等其他标签，因为这些类型的片段都以<code>&lt;</code>开头。那么，要进一步确定模板是不是以开始标签开头，还需要借助正则表达式来分辨模板的开始位置是否符合开始标签的特征。</p>\n<p>那么，如何使用正则表达式来匹配模板以开始标签开头？我们看下面的代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>const ncname = &#x27;[a-zA-Z_][\\\\w\\\\-\\\\.]*&#x27;\nconst qnameCapture = &#96;((?:${ncname}\\\\:)?${ncname})&#96;\nconst startTagOpen = new RegExp(&#96;^&lt;${qnameCapture}&#96;)\n\n&#x2F;&#x2F; 以开始标签开始的模板\n&#x27;&lt;div&gt;&lt;&#x2F;div&gt;&#x27;.match(startTagOpen) &#x2F;&#x2F; [&quot;&lt;div&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;div&gt;&lt;&#x2F;div&gt;&quot;]\n\n&#x2F;&#x2F; 以结束标签开始的模板\n&#x27;&lt;&#x2F;div&gt;&lt;div&gt;我是Berwin&lt;&#x2F;div&gt;&#x27;.match(startTagOpen) &#x2F;&#x2F; null\n\n&#x2F;&#x2F; 以文本开始的模板\n&#x27;我是Berwin&lt;&#x2F;p&gt;&#x27;.match(startTagOpen) &#x2F;&#x2F; null\n</code></pre><p>通过上面的例子可以看到，只有<code>'&lt;div&gt;&lt;/div&gt;'</code>可以成功匹配，而以<code>&lt;/div&gt;</code>开头的或者以文本开头的模板都无法成功匹配。</p>\n<p>在9.2节中，我们介绍了当HTML解析器解析到标签开始时，会触发钩子函数<code>start</code>，同时会给出三个参数，分别是标签名（<code>tagName</code>）、属性（<code>attrs</code>）以及自闭合标识（<code>unary</code>）。</p>\n<p>因此，在分辨出模板以开始标签开始之后，需要将标签名、属性以及自闭合标识解析出来。</p>\n<p>在分辨模板是否以开始标签开始时，就可以得到标签名，而属性和自闭合标识则需要进一步解析。</p>\n<p>当完成上面的解析后，我们可以得到这样一个数据结构：</p>\n<pre class=\"prettyprint language-javascript\"><code>const start = &#x27;&lt;div&gt;&lt;&#x2F;div&gt;&#x27;.match(startTagOpen)\nif (start) {\n    const match = {\n        tagName: start[1],\n        attrs: []\n    }\n}\n</code></pre><p>这里有一个细节很重要：在前面的例子中，我们匹配到的开始标签并不全。例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>const ncname = &#x27;[a-zA-Z_][\\\\w\\\\-\\\\.]*&#x27;\nconst qnameCapture = &#96;((?:${ncname}\\\\:)?${ncname})&#96;\nconst startTagOpen = new RegExp(&#96;^&lt;${qnameCapture}&#96;)\n\n&#x27;&lt;div&gt;&lt;&#x2F;div&gt;&#x27;.match(startTagOpen)\n&#x2F;&#x2F; [&quot;&lt;div&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;div&gt;&lt;&#x2F;div&gt;&quot;]\n\n&#x27;&lt;p&gt;&lt;&#x2F;p&gt;&#x27;.match(startTagOpen)\n&#x2F;&#x2F; [&quot;&lt;p&quot;, &quot;p&quot;, index: 0, input: &quot;&lt;p&gt;&lt;&#x2F;p&gt;&quot;]\n\n&#x27;&lt;div class=&quot;box&quot;&gt;&lt;&#x2F;div&gt;&#x27;.match(startTagOpen)\n&#x2F;&#x2F; [&quot;&lt;div&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;div class=&quot;box&quot;&gt;&lt;&#x2F;div&gt;&quot;]\n</code></pre><p>可以看出，上面这个正则表达式虽然可以分辨出模板是否以开始标签开头，但是它的匹配规则并不是匹配整个开始标签，而是开始标签的一小部分。</p>\n<p>事实上，开始标签被拆分成三个小部分，分别是标签名、属性和结尾，如图9-3所示。</p>\n<p><img src=\"https://p0.ssl.qhimg.com/t01d15917c94d5a34bf.jpg\" alt=\"开始标签的三个小部分\">\n图9-3 开始标签被拆分成三个小部分（<strong>代码用代码体</strong>）</p>\n<p>通过“标签名”这一段字符，就可以分辨出模板是否以开始标签开头，此后要想得到属性和自闭合标识，则需要进一步解析。</p>\n<h4>1. 解析标签属性</h4>\n<p>在分辨模板是否以开始标签开头时，会将开始标签中的标签名这一小部分截取掉，因此在解析标签属性时，我们得到的模板是下面伪代码中的样子：</p>\n<pre class=\"prettyprint language-html\"><code>&#x27; class=&quot;box&quot;&gt;&lt;&#x2F;div&gt;&#x27;\n</code></pre><p>通常，标签属性是可选的，一个标签的属性有可能存在，也有可能不存在，所以需要判断标签是否存在属性，如果存在，对它进行截取。</p>\n<p>下面的伪代码展示了如何解析开始标签中的属性，但是它只能解析一个属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>const attribute = &#x2F;^\\s*([^\\s&quot;&#x27;&lt;&gt;\\&#x2F;=]+)(?:\\s*(=)\\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\\s&quot;&#x27;=&lt;&gt;&#96;]+)))?&#x2F;\nlet html = &#x27; class=&quot;box&quot;&gt;&lt;&#x2F;div&gt;&#x27;\nlet attr = html.match(attribute)\nhtml = html.substring(attr[0].length)\nconsole.log(attr)\n&#x2F;&#x2F; [&#x27; class=&quot;box&quot;&#x27;, &#x27;class&#x27;, &#x27;=&#x27;, &#x27;box&#x27;, undefined, undefined, index: 0, input: &#x27; class=&quot;box&quot;&gt;&lt;&#x2F;div&gt;&#x27;]\n</code></pre><p>如果标签上有很多属性，那么上面的处理方式就不足以支撑解析任务的正常运行。例如下面的代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>const attribute = &#x2F;^\\s*([^\\s&quot;&#x27;&lt;&gt;\\&#x2F;=]+)(?:\\s*(=)\\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\\s&quot;&#x27;=&lt;&gt;&#96;]+)))?&#x2F;\nlet html = &#x27; class=&quot;box&quot; id=&quot;el&quot;&gt;&lt;&#x2F;div&gt;&#x27;\nlet attr = html.match(attribute)\nhtml = html.substring(attr[0].length)\nconsole.log(attr)\n&#x2F;&#x2F; [&#x27; class=&quot;box&quot;&#x27;, &#x27;class&#x27;, &#x27;=&#x27;, &#x27;box&#x27;, undefined, undefined, index: 0, input: &#x27; class=&quot;box&quot; id=&quot;el&quot;&gt;&lt;&#x2F;div&gt;&#x27;]\n</code></pre><p>可以看到，这里只解析出了<code>class</code>属性，而<code>id</code>属性没有解析出来。</p>\n<p>此时剩余的HTML模板是这样的：</p>\n<pre class=\"prettyprint language-html\"><code>&#x27; id=&quot;el&quot;&gt;&lt;&#x2F;div&gt;&#x27;\n</code></pre><p>所以属性也可以分成多个小部分，一小部分一小部分去解析与截取。</p>\n<p>解决这个问题时，我们只需要每解析一个属性就截取一个属性。如果截取完后，剩下的HTML模板依然符合标签属性的正则表达式，那么说明还有剩余的属性需要处理，此时就重复执行前面的流程，直到剩余的模板不存在属性，也就是剩余的模板不存在符合正则表达式所预设的规则。</p>\n<p>例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>const startTagClose = &#x2F;^\\s*(\\&#x2F;?)&gt;&#x2F;\nconst attribute = &#x2F;^\\s*([^\\s&quot;&#x27;&lt;&gt;\\&#x2F;=]+)(?:\\s*(=)\\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\\s&quot;&#x27;=&lt;&gt;&#96;]+)))?&#x2F;\nlet html = &#x27; class=&quot;box&quot; id=&quot;el&quot;&gt;&lt;&#x2F;div&gt;&#x27;\nlet end, attr\nconst match = {tagName: &#x27;div&#x27;, attrs: []}\n\nwhile (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) {\n    html = html.substring(attr[0].length)\n    match.attrs.push(attr)\n}\n</code></pre><p>上面这段代码的意思是，如果剩余HTML模板不符合开始标签结尾部分的特征，并且符合标签属性的特征，那么进入到循环中进行解析与截取操作。</p>\n<p>通过<code>match</code>方法解析出的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>{\n    tagName: &#x27;div&#x27;,\n    attrs: [\n        [&#x27; class=&quot;box&quot;&#x27;, &#x27;class&#x27;, &#x27;=&#x27;, &#x27;box&#x27;, null, null],\n        [&#x27; id=&quot;el&quot;&#x27;, &#x27;id&#x27;,&#x27;=&#x27;, &#x27;el&#x27;, null, null]\n    ]\n}\n</code></pre><p>可以看到，标签中的两个属性都已经解析好并且保存在了<code>attrs</code>中。</p>\n<p>此时剩余模板是下面的样子：</p>\n<pre class=\"prettyprint language-javascript\"><code>&quot;&gt;&lt;&#x2F;div&gt;&quot;\n</code></pre><p>我们将属性解析后的模板与解析之前的模板进行对比：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 解析前的模板\n&#x27; class=&quot;box&quot; id=&quot;el&quot;&gt;&lt;&#x2F;div&gt;&#x27;\n\n&#x2F;&#x2F; 解析后的模板\n&#x27;&gt;&lt;&#x2F;div&gt;&#x27;\n\n&#x2F;&#x2F; 解析前的数据\n{\n    tagName: &#x27;div&#x27;,\n    attrs: []\n}\n\n&#x2F;&#x2F; 解析后的数据\n{\n    tagName: &#x27;div&#x27;,\n    attrs: [\n        [&#x27; class=&quot;box&quot;&#x27;, &#x27;class&#x27;, &#x27;=&#x27;, &#x27;box&#x27;, null, null],\n        [&#x27; id=&quot;el&quot;&#x27;, &#x27;id&#x27;,&#x27;=&#x27;, &#x27;el&#x27;, null, null]\n    ]\n}\n</code></pre><p>可以看到，标签上的所有属性都已经被成功解析出来，并保存在<code>attrs</code>属性中。</p>\n<h4>2. 解析自闭合标识</h4>\n<p>如果我们接着上面的例子继续解析的话，目前剩余的模板是下面这样的：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;&gt;&lt;&#x2F;div&gt;&#x27;\n</code></pre><p>开始标签中结尾部分解析的主要目的是解析出当前这个标签是否是自闭合标签。</p>\n<p>举个例子：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div&gt;&lt;&#x2F;div&gt;\n</code></pre><p>这样的<code>div</code>标签就不是自闭合标签，而下面这样的<code>input</code>标签就属于自闭合标签：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;input type=&quot;text&quot; &#x2F;&gt;\n</code></pre><p>自闭合标签是没有子节点的，所以前文中我们提到构建AST层级时，需要维护一个栈，而一个节点是否需要推入到栈中，可以使用这个自闭合标识来判断。</p>\n<p>那么，如何解析开始标签中的结尾部分呢？看下面这段代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>function parseStartTagEnd (html) {\n  const startTagClose = &#x2F;^\\s*(\\&#x2F;?)&gt;&#x2F;\n  const end = html.match(startTagClose)\n  const match = {}\n\n  if (end) {\n      match.unarySlash = end[1]\n      html = html.substring(end[0].length)\n      return match\n  }\n}\n\nconsole.log(parseStartTagEnd(&#x27;&gt;&lt;&#x2F;div&gt;&#x27;)) &#x2F;&#x2F; {unarySlash: &quot;&quot;}\nconsole.log(parseStartTagEnd(&#x27;&#x2F;&gt;&lt;div&gt;&lt;&#x2F;div&gt;&#x27;)) &#x2F;&#x2F; {unarySlash: &quot;&#x2F;&quot;}\n</code></pre><p>这段代码可以正确解析出开始标签是否是自闭合标签。</p>\n<p>从代码中打印出来的结果可以看到，自闭合标签解析后的<code>unarySlash</code>属性为<code>/</code>，而非自闭合标签为空字符串。</p>\n<h4>3. 实现源码</h4>\n<p>前面解析开始标签时，我们将其拆解成了三个部分，分别是标签名、属性和结尾。我相信你已经对开始标签的解析有了一个清晰的认识，接下来看一下Vue.js中真实的代码是什么样的：</p>\n<pre class=\"prettyprint language-javascript\"><code>const ncname = &#x27;[a-zA-Z_][\\\\w\\\\-\\\\.]*&#x27;\nconst qnameCapture = &#96;((?:${ncname}\\\\:)?${ncname})&#96;\nconst startTagOpen = new RegExp(&#96;^&lt;${qnameCapture}&#96;)\nconst startTagClose = &#x2F;^\\s*(\\&#x2F;?)&gt;&#x2F;\n\nfunction advance (n) {\n    html = html.substring(n)\n}\n\nfunction parseStartTag () {\n    &#x2F;&#x2F; 解析标签名，判断模板是否符合开始标签的特征\n    const start = html.match(startTagOpen)\n    if (start) {\n        const match = {\n            tagName: start[1],\n            attrs: []\n        }\n        advance(start[0].length)\n        \n        &#x2F;&#x2F; 解析标签属性\n        let end, attr\n        while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) {\n            advance(attr[0].length)\n            match.attrs.push(attr)\n        }\n        \n        &#x2F;&#x2F; 判断是否是自闭合标签\n        if (end) {\n            match.unarySlash = end[1]\n            advance(end[0].length)\n            return match\n        }\n    }\n}\n</code></pre><p>上面的代码是Vue.js中解析开始标签的源码，这段代码中的<code>html</code>变量是HTML模板。</p>\n<p>调用<code>parseStartTag</code>就可以将剩余模板开始部分的开始标签解析出来。如果剩余HTML模板的开始部分不符合开始标签的正则表达式规则，那么调用<code>parseStartTag</code>就会返回<code>undefined</code>。因此，判断剩余模板是否符合开始标签的规则，只需要调用<code>parseStartTag</code>即可。如果调用它后得到了解析结果，那么说明剩余模板的开始部分符合开始标签的规则，此时将解析出来的结果取出来并调用钩子函数<code>start</code>即可：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 开始标签\nconst startTagMatch = parseStartTag()\nif (startTagMatch) {\n    handleStartTag(startTagMatch)\n    continue\n}\n</code></pre><p>前面我们说过，所有解析操作都运行在循环中，所以<code>continue</code>的意思是这一轮的解析工作已经完成，可以进行下一轮解析工作。</p>\n<p>从代码中可以看出，如果调用<code>parseStartTag</code>之后有返回值，那么会进行开始标签的处理，其处理逻辑主要在<code>handleStartTag</code>中。这个函数的主要目的就是将<code>tagName</code>、<code>attrs</code>和<code>unary</code>等数据取出来，然后调用钩子函数将这些数据放到参数中。</p>\n<h3>9.3.3 截取结束标签</h3>\n<p>结束标签的截取要比开始标签简单得多，因为它不需要解析什么，只需要分辨出当前是否已经截取到结束标签，如果是，那么触发钩子函数就可以了。</p>\n<p>那么，如何分辨模板已经截取到结束标签了呢？其道理其实和开始标签的截取相同。</p>\n<p>如果HTML模板的第一个字符不是<code>&lt;</code>，那么一定不是结束标签。只有HTML模板的第一个字符是<code>&lt;</code>时，我们才需要进一步确认它到底是不是结束标签。</p>\n<p>进一步确认时，我们只需要判断剩余HTML模板的开始位置是否符合正则表达式中定义的规则即可：</p>\n<pre class=\"prettyprint language-javascript\"><code>const ncname = &#x27;[a-zA-Z_][\\\\w\\\\-\\\\.]*&#x27;\nconst qnameCapture = &#96;((?:${ncname}\\\\:)?${ncname})&#96;\nconst endTag = new RegExp(&#96;^&lt;\\\\&#x2F;${qnameCapture}[^&gt;]*&gt;&#96;)\n\nconst endTagMatch = &#x27;&lt;&#x2F;div&gt;&#x27;.match(endTag)\nconst endTagMatch2 = &#x27;&lt;div&gt;&#x27;.match(endTag)\n\nconsole.log(endTagMatch) &#x2F;&#x2F; [&quot;&lt;&#x2F;div&gt;&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;&#x2F;div&gt;&quot;]\nconsole.log(endTagMatch2) &#x2F;&#x2F; null\n</code></pre><p>上面代码可以分辨出剩余模板是否是结束标签。当分辨出结束标签后，需要做两件事，一件事是截取模板，另一件事是触发钩子函数。而Vue.js中相关源码被精简后如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>const endTagMatch = html.match(endTag)\nif (endTagMatch) {\n    html = html.substring(endTagMatch[0].length)\n    options.end(endTagMatch[1])\n    continue\n}\n</code></pre><p>可以看出，先对模板进行截取，然后触发钩子函数。</p>\n<h3>9.3.4 截取注释</h3>\n<p>分辨模板是否已经截取到注释的原理与开始标签和结束标签相同，先判断剩余HTML模板的第一个字符是不是<code>&lt;</code>，如果是，再用正则表达式来进一步匹配：</p>\n<pre class=\"prettyprint language-javascript\"><code>const comment = &#x2F;^&lt;!--&#x2F;\n\nif (comment.test(html)) {\n    const commentEnd = html.indexOf(&#x27;--&gt;&#x27;)\n\n    if (commentEnd &gt;= 0) {\n        if (options.shouldKeepComment) {\n            options.comment(html.substring(4, commentEnd))\n        }\n        html = html.substring(commentEnd + 3)\n        continue\n    }\n}\n</code></pre><p>在上面的代码中，我们使用正则表达式来判断剩余的模板是否符合注释的规则，如果符合，就将这段注释文本截取出来。</p>\n<p>这里有一个有意思的地方，那就是注释的钩子函数可以通过选项来配置，只有<code>options.shouldKeepComment</code>为真时，才会触发钩子函数，否则只截取模板，不触发钩子函数。</p>\n<h3>9.3.5 截取条件注释</h3>\n<p>条件注释不需要触发钩子函数，我们只需要把它截取掉就行了。</p>\n<p>截取条件注释的原理与截取注释非常相似，如果模板的第一个字符是<code>&lt;</code>，并且符合我们事先用正则表达式定义好的规则，就说明需要进行条件注释的截取操作。</p>\n<p>在下面的代码中，我们通过<code>indexOf</code>找到条件注释结束位置的下标，然后将结束位置前的字符都截取掉：</p>\n<pre class=\"prettyprint language-javascript\"><code>const conditionalComment = &#x2F;^&lt;!\\[&#x2F;\nif (conditionalComment.test(html)) {\n    const conditionalEnd = html.indexOf(&#x27;]&gt;&#x27;)\n\n    if (conditionalEnd &gt;= 0) {\n        html = html.substring(conditionalEnd + 2)\n        continue\n    }\n}\n</code></pre><p>我们来举个例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>const conditionalComment = &#x2F;^&lt;!\\[&#x2F;\nlet html = &#x27;&lt;![if !IE]&gt;&lt;link href=&quot;non-ie.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;![endif]&gt;&#x27;\nif (conditionalComment.test(html)) {\n    const conditionalEnd = html.indexOf(&#x27;]&gt;&#x27;)\n    if (conditionalEnd &gt;= 0) {\n        html = html.substring(conditionalEnd + 2)\n    }\n}\n\nconsole.log(html) &#x2F;&#x2F; &#x27;&lt;link href=&quot;non-ie.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;![endif]&gt;&#x27;\n</code></pre><p>从打印结果中可以看到，HTML中的条件注释部分截取掉了。</p>\n<p>通过这个逻辑可以发现，在Vue.js中条件注释其实没有用，写了也会被截取掉，通俗一点说就是写了也白写。</p>\n<h3>9.3.6 截取<code>DOCTYPE</code></h3>\n<p><code>DOCTYPE</code>与条件注释相同，都是不需要触发钩子函数的，只需要将匹配到的这一段字符截取掉即可。下面的代码将<code>DOCTYPE</code>这段字符匹配出来后，根据它的<code>length</code>属性来决定要截取多长的字符串：</p>\n<pre class=\"prettyprint language-javascript\"><code>const doctype = &#x2F;^&lt;!DOCTYPE [^&gt;]+&gt;&#x2F;i\nconst doctypeMatch = html.match(doctype)\nif (doctypeMatch) {\n    html = html.substring(doctypeMatch[0].length)\n    continue\n}\n</code></pre><p>示例如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>const doctype = &#x2F;^&lt;!DOCTYPE [^&gt;]+&gt;&#x2F;i\nlet html = &#x27;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#x27;\nconst doctypeMatch = html.match(doctype)\nif (doctypeMatch) {\n    html = html.substring(doctypeMatch[0].length)\n}\n\nconsole.log(html) &#x2F;&#x2F; &#x27;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#x27;\n</code></pre><p>从打印结果可以看到，HTML中的<code>DOCTYPE</code>被成功截取掉了。</p>\n<h3>9.3.7 截取文本</h3>\n<p>若想分辨在本轮循环中HTML模板是否已经截取到文本，其实很简单，我们甚至不需要使用正则表达式。</p>\n<p>在前面的其他标签类型中，我们都会判断剩余HTML模板的第一个字符是否是<code>&lt;</code>，如果是，再进一步确认到底是哪种类型。这是因为以<code>&lt;</code>开头的标签类型太多了，如开始标签、结束标签和注释等。然而文本只有一种，如果HTML模板的第一个字符不是<code>&lt;</code>，那么它一定是文本了。</p>\n<p>例如：</p>\n<pre class=\"prettyprint language-html\"><code>我是文本&lt;&#x2F;div&gt;\n</code></pre><p>上面这段HTML模板并不是以<code>&lt;</code>开头的，所以可以断定它是以文本开头的。</p>\n<p>那么，如何从模板中将文本解析出来呢？我们只需要找到下一个<code>&lt;</code>在什么位置，这之前的所有字符都属于文本，如图9-4所示。</p>\n<p><img src=\"http://p4.qhimg.com/t01fb2546eafa16179e.jpg\" alt=\"尖括号前面的字符都属于文本\">\n图9-4 尖括号前面的字符都属于文本</p>\n<p>在代码中可以这样实现：</p>\n<pre class=\"prettyprint language-javascript\"><code>while (html) {\n    let text\n    let textEnd = html.indexOf(&#x27;&lt;&#x27;)\n    \n    &#x2F;&#x2F; 截取文本\n    if (textEnd &gt;= 0) {\n        text = html.substring(0, textEnd)\n        html = html.substring(textEnd)\n    }\n\n    &#x2F;&#x2F; 如果模板中找不到&lt;，就说明整个模板都是文本\n    if (textEnd &lt; 0) {\n        text = html\n        html = &#x27;&#x27;\n    }\n\n    &#x2F;&#x2F; 触发钩子函数\n    if (options.chars &amp;&amp; text) {\n        options.chars(text)\n    }\n}\n</code></pre><p>上面的代码共有三部分逻辑。</p>\n<p>第一部分是截取文本，这在前面介绍过了。<code>&lt;</code>之前的所有字符都是文本，直接使用<code>html.substring</code>从模板的最开始位置截取到<code>&lt;</code>之前的位置，就可以将文本截取出来。</p>\n<p>第二部分是一个条件：如果在整个模板中都找不到<code>&lt;</code>，那么说明整个模板全是文本。</p>\n<p>第三部分是触发钩子函数并将截取出来的文本放到参数中。</p>\n<p>关于文本，还有一个特殊情况需要处理：如果<code>&lt;</code>是文本的一部分，该如何处理？</p>\n<p>举个例子：</p>\n<pre class=\"prettyprint language-html\"><code>1&lt;2&lt;&#x2F;div&gt;\n</code></pre><p>在上面这样的模板中，如果只截取第一个<code>&lt;</code>前面的字符，最后被截取出来的将只有1，而不能把所有文本都截取出来。</p>\n<p>那么，该如何解决这个问题呢？</p>\n<p>有一个思路是，如果将<code>&lt;</code>前面的字符截取完之后，剩余的模板不符合任何需要被解析的片段的类型，就说明这个<code>&lt;</code>是文本的一部分。</p>\n<p>什么是需要被解析的片段的类型？在9.3.1节中，我们说过HTML解析器是一段一段截取模板的，而被截取的每一段都符合某种类型，这些类型包括开始标签、结束标签和注释等。</p>\n<p>说的再具体一点，那就是上面这段代码中的1被截取完之后，剩余模板是下面的样子：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;2&lt;&#x2F;div&gt;\n</code></pre><p><code>&lt;2</code>符合开始标签的特征么？不符合。</p>\n<p><code>&lt;2</code>符合结束标签的特征么？不符合。</p>\n<p><code>&lt;2</code>符合注释的特征么？不符合。</p>\n<p>当剩余的模板什么都不符合时，就说明<code>&lt;</code>属于文本的一部分。</p>\n<p>当判断出<code>&lt;</code>是属于文本的一部分后，我们需要做的事情是找到下一个<code>&lt;</code>并将其前面的文本截取出来加到前面截取了一半的文本后面。</p>\n<p>这里还用上面的例子，第二个<code>&lt;</code>之前的字符是<code>&lt;2</code>，那么把<code>&lt;2</code>截取出来后，追加到上一次截取出来的<code>1</code>的后面，此时的结果是：</p>\n<pre class=\"prettyprint language-html\"><code>1&lt;2\n</code></pre><p>截取后剩余的模板是：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;&#x2F;div&gt;\n</code></pre><p>如果剩余的模板依然不符合任何被解析的类型，那么重复此过程。直到所有文本都解析完。</p>\n<p>说完了思路，我们看一下具体的实现，伪代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>while (html) {\n    let text, rest, next\n    let textEnd = html.indexOf(&#x27;&lt;&#x27;)\n    \n    &#x2F;&#x2F; 截取文本\n    if (textEnd &gt;= 0) {\n        rest = html.slice(textEnd)\n        while (\n            !endTag.test(rest) &amp;&amp;\n            !startTagOpen.test(rest) &amp;&amp;\n            !comment.test(rest) &amp;&amp;\n            !conditionalComment.test(rest)\n        ) {\n            &#x2F;&#x2F; 如果&#x27;&lt;&#x27;在纯文本中，将它视为纯文本对待\n            next = rest.indexOf(&#x27;&lt;&#x27;, 1)\n            if (next &lt; 0) break\n            textEnd += next\n            rest = html.slice(textEnd)\n        }\n        text = html.substring(0, textEnd)\n        html = html.substring(textEnd)\n    }\n    \n    &#x2F;&#x2F; 如果模板中找不到&lt;，那么说明整个模板都是文本\n    if (textEnd &lt; 0) {\n        text = html\n        html = &#x27;&#x27;\n    }\n    \n    &#x2F;&#x2F; 触发钩子函数\n    if (options.chars &amp;&amp; text) {\n        options.chars(text)\n    }\n}\n</code></pre><p>在代码中，我们通过<code>while</code>来解决这个问题（注意是里面的<code>while</code>）。如果剩余的模板不符合任何被解析的类型，那么重复解析文本，直到剩余模板符合被解析的类型为止。</p>\n<p>在上面的代码中，<code>endTag</code>、<code>startTagOpen</code>、<code>comment</code>和<code>conditionalComment</code>都是正则表达式，分别匹配结束标签、开始标签、注释和条件注释。</p>\n<p>在Vue.js源码中，截取文本的逻辑和其他的实现思路一致。</p>\n<h3>9.3.8 纯文本内容元素的处理</h3>\n<p>什么是纯文本内容元素呢？<code>script</code>、<code>style</code>和<code>textarea</code>这三种元素叫作纯文本内容元素。解析它们的时候，会把这三种标签内包含的所有内容都当作文本处理。那么，具体该如何处理呢？</p>\n<p>前面介绍开始标签、结束标签、文本、注释的截取时，其实都是默认当前需要截取的元素的父级元素不是<strong>纯文本内容元素</strong>。事实上，如果要截取元素的父级元素是纯文本内容元素的话，处理逻辑将完全不一样。</p>\n<p>事实上，在<code>while</code>循环中，最外层的判断条件就是父级元素是不是纯文本内容元素。例如下面的伪代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>while (html) {\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n        &#x2F;&#x2F; 父元素为正常元素的处理逻辑\n    } else {\n        &#x2F;&#x2F; 父元素为script、style、textarea的处理逻辑\n    }\n}\n</code></pre><p>在上面的代码中，<code>lastTag</code>代表父元素。可以看到，在<code>while</code>中，首先进行判断，如果父元素不存在或者不是纯文本内容元素，那么进行正常的处理逻辑，也就是前面介绍的逻辑。</p>\n<p>而当父元素是<code>script</code>这种纯文本内容元素时，会进入到<code>else</code>这个语句里面。由于纯文本内容元素都被视作文本处理，所以我们的处理逻辑就变得很简单，只需要把这些文本截取出来并触发钩子函数<code>chars</code>，然后再将结束标签截取出来并触发钩子函数<code>end</code>。</p>\n<p>也就是说，如果父标签是纯文本内容元素，那么本轮循环会一次性将这个父标签给处理完毕。</p>\n<p>伪代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>while (html) {\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n        &#x2F;&#x2F; 父元素为正常元素的处理逻辑\n    } else {\n        &#x2F;&#x2F; 父元素为script、style、textarea的处理逻辑\n        const stackedTag = lastTag.toLowerCase()\n        const reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp(&#x27;([\\\\s\\\\S]*?)(&lt;&#x2F;&#x27; + stackedTag + &#x27;[^&gt;]*&gt;)&#x27;, &#x27;i&#x27;))\n        const rest = html.replace(reStackedTag, function (all, text) {\n            if (options.chars) {\n                options.chars(text)\n            }\n            return &#x27;&#x27;\n        })\n        html = rest\n        options.end(stackedTag)\n    }\n}\n</code></pre><p>上面代码中的正则表达式可以匹配结束标签前包括结束标签自身在内的所有文本。</p>\n<p>我们可以给<code>replace</code>方法的第二个参数传递一个函数。在这个函数中，我们得到了参数<code>text</code>（代表结束标签前的所有内容），触发了钩子函数<code>chars</code>并把<code>text</code>放到钩子函数的参数中传出去。最后，返回了一个空字符串，代表将匹配到的内容都截掉了。注意，这里的截掉会将内容和结束标签一起截取掉。</p>\n<p>最后，调用钩子函数<code>end</code>并将标签名放到参数中传出去，代表本轮循环中的所有逻辑都已处理完毕。</p>\n<p>假如我们现在有这样一个模板：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div id=&quot;el&quot;&gt;\n    &lt;script&gt;console.log(1)&lt;&#x2F;script&gt;\n&lt;&#x2F;div&gt;\n</code></pre><p>当解析到<code>script</code>中的内容时，模板是下面的样子：</p>\n<pre class=\"prettyprint language-html\"><code>console.log(1)&lt;&#x2F;script&gt;\n&lt;&#x2F;div&gt;\n</code></pre><p>此时父元素为<code>script</code>，所以会进入到<code>else</code>中的逻辑进行处理。在其处理过程中，会触发钩子函数<code>chars</code>和<code>end</code>。</p>\n<p>钩子函数<code>chars</code>的参数为<code>script</code>中的所有内容，本例中大概是下面的样子：</p>\n<pre class=\"prettyprint language-javascript\"><code>chars(&#x27;console.log(1)&#x27;)\n</code></pre><p>钩子函数<code>end</code>的参数为标签名，本例中是<code>script</code>。</p>\n<p>处理后的剩余模板如下：</p>\n<pre class=\"prettyprint language-html\"><code>\n&lt;&#x2F;div&gt;\n</code></pre><h3>9.3.9 使用栈维护DOM层级</h3>\n<p>通过前面几节的介绍，特别是9.3.8节中的介绍，你一定会感到很奇怪，如何知道父元素是谁？</p>\n<p>在前面几节中，我们并没有介绍HTML解析器内部其实也有一个栈来维护DOM层级关系，其逻辑与9.2.1节相同：就是每解析到开始标签，就向栈中推进去一个；每解析到标签结束，就弹出来一个。因此，想取到父元素并不难，只需要拿到栈中的最后一项即可。</p>\n<p>同时，HTML解析器中的栈还有另一个作用，它可以检测出HTML标签是否正确闭合。例如：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div&gt;&lt;p&gt;&lt;&#x2F;div&gt;\n</code></pre><p>在上面的代码中，<code>p</code>标签忘记写结束标签，那么当HTML解析器解析到<code>div</code>的结束标签时，栈顶的元素却是<code>p</code>标签。这个时候从栈顶向栈底循环找到<code>div</code>标签，在找到<code>div</code>标签之前遇到的所有其他标签都是忘记了闭合的标签，而Vue.js会在非生产环境下在控制台打印警告提示。</p>\n<p>关于使用栈来维护DOM层级关系的具体实现思路，9.2.1节已经详细介绍过，这里不再重复介绍。</p>\n<h3>9.3.10 整体逻辑</h3>\n<p>前面我们把开始标签、结束标签、注释、文本、纯文本内容元素等的截取方式拆分开，单独进行了详细介绍。本节中，我们就来介绍如何将这些解析方式组装起来完成HTML解析器的功能。</p>\n<p>首先，HTML解析器是一个函数。就像9.2节介绍的那样，HTML解析器最终的目的是实现这样的功能：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseHTML(template, {\n    start (tag, attrs, unary) {\n        &#x2F;&#x2F; 每当解析到标签的开始位置时，触发该函数\n    },\n    end () {\n        &#x2F;&#x2F; 每当解析到标签的结束位置时，触发该函数\n    },\n    chars (text) {\n        &#x2F;&#x2F; 每当解析到文本时，触发该函数\n    },\n    comment (text) {\n        &#x2F;&#x2F; 每当解析到注释时，触发该函数\n    }\n})\n</code></pre><p>所以HTML解析器在实现上肯定是一个函数，它有两个参数——模板和选项：</p>\n<pre class=\"prettyprint language-javascript\"><code>export function parseHTML (html, options) {\n    &#x2F;&#x2F; 做点什么\n}\n</code></pre><p>我们的模板是一小段一小段去截取与解析的，所以需要一个循环来不断截取，直到全部截取完毕：</p>\n<pre class=\"prettyprint language-javascript\"><code>export function parseHTML (html, options) {\n    while (html) {\n        &#x2F;&#x2F; 做点什么\n    }\n}\n</code></pre><p>在循环中，首先要判断父元素是不是纯文本内容元素，因为不同类型父节点的解析方式将完全不同：</p>\n<pre class=\"prettyprint language-javascript\"><code>export function parseHTML (html, options) {\n    while (html) {\n        if (!lastTag || !isPlainTextElement(lastTag)) {\n            &#x2F;&#x2F; 父元素为正常元素的处理逻辑\n        } else {\n            &#x2F;&#x2F; 父元素为script、style、textarea的处理逻辑\n        }\n    }\n}\n</code></pre><p>在上面的代码中，我们发现这里已经把整体逻辑分成了两部分，一部分是父标签是正常标签的逻辑，另一部分是父标签是<code>script</code>、<code>style</code>、<code>textarea</code>这种纯文本内容元素的逻辑。</p>\n<p>如果父标签为正常的元素，那么有几种情况需要分别处理，比如需要分辨出当前要解析的一小段模板到底是什么类型。是开始标签？还是结束标签？又或者是文本？</p>\n<p>我们把所有需要处理的情况都列出来，有下面几种情况：</p>\n<ul>\n<li>文本</li>\n<li>注释</li>\n<li>条件注释</li>\n<li><code>DOCTYPE</code></li>\n<li>结束标签</li>\n<li>开始标签</li>\n</ul>\n<p>我们会发现，在这些需要处理的类型中，除了文本之外，其他都是以标签形式存在的，而标签是以<code>&lt;</code>开头的。</p>\n<p>所以逻辑就很清晰了，我们先根据<code>&lt;</code>来判断需要解析的字符是文本还是其他的：</p>\n<pre class=\"prettyprint language-javascript\"><code>export function parseHTML (html, options) {\n    while (html) {\n        if (!lastTag || !isPlainTextElement(lastTag)) {\n            let textEnd = html.indexOf(&#x27;&lt;&#x27;)\n            if (textEnd === 0) {\n                &#x2F;&#x2F; 做点什么\n            }\n            \n            let text, rest, next\n            if (textEnd &gt;= 0) {\n                &#x2F;&#x2F; 解析文本\n            }\n            \n            if (textEnd &lt; 0) {\n                text = html\n                html = &#x27;&#x27;\n            }\n            \n            if (options.chars &amp;&amp; text) {\n                options.chars(text)\n            }\n        } else {\n            &#x2F;&#x2F; 父元素为script、style、textarea的处理逻辑\n        }\n    }\n}\n</code></pre><p>在上面的代码中，我们可以通过<code>&lt;</code>来分辨是否需要进行文本解析。关于文本解析的内容，详见9.3.7节。</p>\n<p>如果通过<code>&lt;</code>分辨出即将解析的这一小部分字符不是文本而是标签类，那么标签类有那么多类型，我们需要进一步分辨具体是哪种类型：</p>\n<pre class=\"prettyprint language-javascript\"><code>export function parseHTML (html, options) {\n    while (html) {\n        if (!lastTag || !isPlainTextElement(lastTag)) {\n            let textEnd = html.indexOf(&#x27;&lt;&#x27;)\n            if (textEnd === 0) {\n                &#x2F;&#x2F; 注释\n                if (comment.test(html)) {\n                    &#x2F;&#x2F; 注释的处理逻辑\n                    continue\n                }\n                \n                &#x2F;&#x2F; 条件注释\n                if (conditionalComment.test(html)) {\n                    &#x2F;&#x2F; 条件注释的处理逻辑\n                    continue\n                }\n                \n                &#x2F;&#x2F; DOCTYPE\n                const doctypeMatch = html.match(doctype)\n                if (doctypeMatch) {\n                    &#x2F;&#x2F; DOCTYPE的处理逻辑\n                    continue\n                }\n                \n                &#x2F;&#x2F; 结束标签\n                const endTagMatch = html.match(endTag)\n                if (endTagMatch) {\n                    &#x2F;&#x2F; 结束标签的处理逻辑\n                    continue\n                }\n                \n                &#x2F;&#x2F; 开始标签\n                const startTagMatch = parseStartTag()\n                if (startTagMatch) {\n                    &#x2F;&#x2F; 开始标签的处理逻辑\n                    continue\n                }\n            }\n            \n            let text, rest, next\n            if (textEnd &gt;= 0) {\n                &#x2F;&#x2F; 解析文本\n            }\n            \n            if (textEnd &lt; 0) {\n                text = html\n                html = &#x27;&#x27;\n            }\n            \n            if (options.chars &amp;&amp; text) {\n                options.chars(text)\n            }\n        } else {\n            &#x2F;&#x2F; 父元素为script、style、textarea的处理逻辑\n        }\n    }\n}\n</code></pre><p>关于不同类型的具体处理方式，前面已经详细介绍过，这里不再重复。</p>\n<h2>9.4 文本解析器</h2>\n<p>文本解析器的作用是解析文本。你可能会觉得很奇怪，文本不是在HTML解析器中被解析出来了么？准确地说，文本解析器是对HTML解析器解析出来的文本进行二次加工。为什么要进行二次加工？</p>\n<p>文本其实分两种类型，一种是纯文本，另一种是带变量的文本。例如下面这样的文本是纯文本：</p>\n<pre class=\"prettyprint language-html\"><code>Hello Berwin\n</code></pre><p>而下面这样的是带变量的文本：</p>\n<pre class=\"prettyprint language-html\"><code>Hello {{name}}\n</code></pre><p>在Vue.js模板中，我们可以使用变量来填充模板。而HTML解析器在解析文本时，并不会区分文本是否是带变量的文本。如果是纯文本，不需要进行任何处理；但如果是带变量的文本，那么需要使用文本解析器进一步解析。因为带变量的文本在使用虚拟DOM进行渲染时，需要将变量替换成变量中的值。</p>\n<p>我们在9.2节中介绍过，每当HTML解析器解析到文本时，都会触发<code>chars</code>函数，并且从参数中得到解析出的文本。在<code>chars</code>函数中，我们需要构建文本类型的AST，并将它添加到父节点的<code>children</code>属性中。</p>\n<p>而在构建文本类型的AST时，纯文本和带变量的文本是不同的处理方式。如果是带变量的文本，我们需要借助文本解析器对它进行二次加工，其代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseHTML(template, {\n    start (tag, attrs, unary) {\n        &#x2F;&#x2F; 每当解析到标签的开始位置时，触发该函数\n    },\n    end () {\n        &#x2F;&#x2F; 每当解析到标签的结束位置时，触发该函数\n    },\n    chars (text) {\n        text = text.trim()\n        if (text) {\n            const children = currentParent.children\n            let expression\n            if (expression = parseText(text)) {\n                children.push({\n                    type: 2,\n                    expression,\n                    text\n                })\n            } else {\n                children.push({\n                    type: 3,\n                    text\n                })\n            }\n        }\n    },\n    comment (text) {\n        &#x2F;&#x2F; 每当解析到注释时，触发该函数\n    }\n})\n</code></pre><p>在<code>chars</code>函数中，如果执行<code>parseText</code>后有返回结果，则说明文本是带变量的文本，并且已经通过文本解析器（<code>parseText</code>）二次加工，此时构建一个带变量的文本类型的AST并将其添加到父节点的<code>children</code>属性中。否则，就直接构建一个普通的文本节点并将其添加到父节点的<code>children</code>属性中。而代码中的<code>currentParent</code>是当前节点的父节点，也就是前面介绍的栈中的最后一个节点。</p>\n<p>假设<code>chars</code>函数被触发后，我们得到的<code>text</code>是一个带变量的文本：</p>\n<pre class=\"prettyprint language-javascript\"><code>&quot;Hello {{name}}&quot;\n</code></pre><p>这个带变量的文本被文本解析器解析之后，得到的<code>expression</code>变量是这样的：</p>\n<pre class=\"prettyprint language-javascript\"><code>&quot;Hello &quot;+_s(name)\n</code></pre><p>上面代码中的<code>_s</code>其实是下面这个<code>toString</code>函数的别名：</p>\n<pre class=\"prettyprint language-javascript\"><code>function toString (val) {\n    return val == null\n        ? &#x27;&#x27;\n        : typeof val === &#x27;object&#x27;\n            ? JSON.stringify(val, null, 2)\n            : String(val)\n}\n</code></pre><p>假设当前上下文中有一个变量<code>name</code>，其值为<code>Berwin</code>，那么<code>expression</code>中的内容被执行时，它的内容是不是就是<code>Hello Berwin</code>了？</p>\n<p>我们举个例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>var obj = {name: &#x27;Berwin&#x27;}\nwith(obj) {\n    function toString (val) {\n        return val == null\n            ? &#x27;&#x27;\n            : typeof val === &#x27;object&#x27;\n                ? JSON.stringify(val, null, 2)\n                : String(val)\n    }\n    console.log(&quot;Hello &quot;+toString(name)) &#x2F;&#x2F; &quot;Hello Berwin&quot;\n}\n</code></pre><p>在上面的代码中，我们打印出来的结果是<code>&quot;Hello Berwin&quot;</code>。</p>\n<p>事实上，最终AST会转换成代码字符串放在<code>with</code>中执行，这部分内容会在第11章中详细介绍。</p>\n<p>接着，我们详细介绍如何加工文本，也就是文本解析器的内部实现原理。</p>\n<p>在文本解析器中，第一步要做的事情就是使用正则表达式来判断文本是否是带变量的文本，也就是检查文本中是否包含<code>{{xxx}}</code>这样的语法。如果是纯文本，则直接返回<code>undefined</code>；如果是带变量的文本，再进行二次加工。所以我们的代码是这样的：</p>\n<pre class=\"prettyprint language-javascript\"><code>function parseText (text) {\n    const tagRE = &#x2F;\\{\\{((?:.|\\n)+?)\\}\\}&#x2F;g\n    if (!tagRE(text)) {\n        return\n    }\n}\n</code></pre><p>在上面的代码中，如果是纯文本，则直接返回。如果是带变量的文本，该如何处理呢？</p>\n<p>一个解决思路是使用正则表达式匹配出文本中的变量，先把变量左边的文本添加到数组中，然后把变量改成<code>_s(x)</code>这样的形式也添加到数组中。如果变量后面还有变量，则重复以上动作，直到所有变量都添加到数组中。如果最后一个变量的后面有文本，就将它添加到数组中。</p>\n<p>这时我们其实已经有一个数组，数组元素的顺序和文本的顺序是一致的，此时将这些数组元素用<code>+</code>连起来变成字符串，就可以得到最终想要的效果，如图9-5所示。</p>\n<p><img src=\"https://p5.ssl.qhimg.com/t01ba783e66e40ab7df.jpg\" alt=\"文本解析过程\">\n图9-5 文本解析过程</p>\n<p>在图9-5中，最上面的字符串代表即将解析的文本，中间两个方块代表数组中的两个元素。最后，使用数组方法<code>join</code>将这两个元素合并成一个字符串。</p>\n<p>具体实现代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>function parseText (text) {\n    const tagRE = &#x2F;\\{\\{((?:.|\\n)+?)\\}\\}&#x2F;g\n    if (!tagRE.test(text)) {\n        return\n    }\n\n    const tokens = []\n    let lastIndex = tagRE.lastIndex = 0\n    let match, index\n    while ((match = tagRE.exec(text))) {\n        index = match.index\n        &#x2F;&#x2F; 先把 {{ 前边的文本添加到tokens中\n        if (index &gt; lastIndex) {\n            tokens.push(JSON.stringify(text.slice(lastIndex, index)))\n        }\n        &#x2F;&#x2F; 把变量改成&#96;_s(x)&#96;这样的形式也添加到数组中\n        tokens.push(&#96;_s(${match[1].trim()})&#96;)\n        \n        &#x2F;&#x2F; 设置lastIndex来保证下一轮循环时，正则表达式不再重复匹配已经解析过的文本\n        lastIndex = index + match[0].length\n    }\n    \n    &#x2F;&#x2F; 当所有变量都处理完毕后，如果最后一个变量右边还有文本，就将文本添加到数组中\n    if (lastIndex &lt; text.length) {\n        tokens.push(JSON.stringify(text.slice(lastIndex)))\n    }\n    return tokens.join(&#x27;+&#x27;)\n}\n</code></pre><p>这是文本解析器的全部代码，代码并不多，逻辑也不是很复杂。</p>\n<p>这段代码有一个很关键的地方在<code>lastIndex</code>：每处理完一个变量后，会重新设置<code>lastIndex</code>的位置，这样可以保证如果后面还有其他变量，那么在下一轮循环时可以从<code>lastIndex</code>的位置开始向后匹配，而<code>lastIndex</code>之前的文本将不再被匹配。</p>\n<p>下面用文本解析器解析不同的文本看看：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseText(&#x27;你好{{name}}&#x27;)\n&#x2F;&#x2F; &#x27;&quot;你好 &quot;+_s(name)&#x27;\n\nparseText(&#x27;你好Berwin&#x27;)\n&#x2F;&#x2F; undefined\n\nparseText(&#x27;你好{{name}}, 你今年已经{{age}}岁啦&#x27;)\n&#x2F;&#x2F; &#x27;&quot;你好&quot;+_s(name)+&quot;, 你今年已经&quot;+_s(age)+&quot;岁啦&quot;&#x27;\n</code></pre><p>从上面代码的打印结果可以看到，文本已经被正确解析了。</p>\n<h2>9.5 总结</h2>\n<p>解析器的作用是通过模板得到AST（抽象语法树）。</p>\n<p>生成AST的过程需要借助HTML解析器，当HTML解析器触发不同的钩子函数时，我们可以构建出不同的节点。</p>\n<p>随后，我们可以通过栈来得到当前正在构建的节点的父节点，然后将构建出的节点添加到父节点的下面。</p>\n<p>最终，当HTML解析器运行完毕后，我们就可以得到一个完整的带DOM层级关系的AST。</p>\n<p>HTML解析器的内部原理是一小段一小段地截取模板字符串，每截取一小段字符串，就会根据截取出来的字符串类型触发不同的钩子函数，直到模板字符串截空停止运行。</p>\n<p>文本分两种类型，不带变量的纯文本和带变量的文本，后者需要使用文本解析器进行二次加工。</p>\n<blockquote>\n<p>更多精彩内容可以观看<a href=\"https://item.jd.com/12573168.html\">《深入浅出Vue.js》</a></p>\n</blockquote>\n<h3>关于《深入浅出Vue.js》</h3>\n<p>本书使用最最容易理解的文笔来描述Vue.js的内部原理，对于想学习Vue.js原理的小伙伴是非常值得入手的一本书。</p>\n<p><a href=\"https://item.jd.com/12573168.html\"><img src=\"https://p2.ssl.qhimg.com/t01b6b34a1be5d53090.jpg\" alt=\"封面\"></a></p>\n<p>京东：\n<a href=\"https://item.jd.com/12573168.html\">https://item.jd.com/12573168.html</a></p>\n<p>亚马逊：\n<a href=\"https://www.amazon.cn/gp/product/B07NKVMN1V\">https://www.amazon.cn/gp/product/B07NKVMN1V</a></p>\n<p>当当：\n<a href=\"http://product.dangdang.com/26922892.html\">http://product.dangdang.com/26922892.html</a></p>\n<p><img src=\"https://p4.ssl.qhimg.com/t01bd5a63e9f8d83e9f.jpg\" alt=\"京东购买链接\">\n扫码京东购买</p>\n</div>","title":"Vue.js 模板解析器原理 - 来自《深入浅出Vue.js》第九章","last_reply_at":"2019-04-08T06:04:18.606Z","good":false,"top":false,"reply_count":0,"visit_count":363,"create_at":"2019-04-08T06:04:18.606Z","author":{"loginname":"berwin","avatar_url":"https://avatars0.githubusercontent.com/u/3739368?v=4&s=120"}},{"id":"5caad1c87edd13064e053315","author_id":"5c85d4b2acb681372d416dd6","tab":"share","content":"<div class=\"markdown-text\"><p>深圳 aftership 将在 4 月 27 日举行 Cloudflare 最新边缘 API，打造无服务器(Serverless)架构的技术分享活动，报名页面： <a href=\"https://www.huodongxing.com/event/4486802536500\">https://www.huodongxing.com/event/4486802536500</a></p>\n<p>优惠码：aftershipjoinus</p>\n<p>欢迎大家报名参加。</p>\n</div>","title":"[aftership 技术分享活动] Cloudflare 最新边缘 API，打造无服务器(Serverless)架构","last_reply_at":"2019-04-08T04:44:56.278Z","good":false,"top":false,"reply_count":0,"visit_count":300,"create_at":"2019-04-08T04:44:56.278Z","author":{"loginname":"wangxihua916","avatar_url":"https://avatars0.githubusercontent.com/u/37897167?v=4&s=120"}},{"id":"5caab9b27edd13064e0531ef","author_id":"5caab92ad68ff5064921ad07","tab":"share","content":"<div class=\"markdown-text\"><p>拼团地址： <a href=\"https://cloud.tencent.com/act/group/amdv2/detail?from=10521&amp;group=64666\">https://cloud.tencent.com/act/group/amdv2/detail?from=10521&amp;group=64666</a></p>\n</div>","title":"腾讯云1g1核2m带宽服务器15元/月，有兴趣的了解一下","last_reply_at":"2019-04-08T03:02:10.679Z","good":false,"top":false,"reply_count":0,"visit_count":598,"create_at":"2019-04-08T03:02:10.679Z","author":{"loginname":"CHKabin","avatar_url":"https://avatars2.githubusercontent.com/u/18096641?v=4&s=120"}},{"id":"5ca2f5126c1de62dce466d9f","author_id":"581ae153e90cfbec054d762a","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/103147/1554174860996-48dafaa4-e8f1-483f-9d05-8ccc91028aa5.png#align=left&amp;display=inline&amp;height=443&amp;name=image.png&amp;originHeight=886&amp;originWidth=1790&amp;size=2086701&amp;status=done&amp;width=895\" alt=\"image.png\"></p>\n<p>【Alibaba-TXD 前端小报】- 热门前端技术快报，聚焦业界新视界；不知不觉 2019 年已经过去了 1/4，日新月异的前端技术正在蓬勃发展，<a href=\"https://segmentfault.com/a/1190000018311280\">ES10</a> 都已到来。</p>\n<blockquote>\n<p>欢迎 <a href=\"https://zhuanlan.zhihu.com/txd-team\">订阅</a> &amp; <a href=\"https://github.com/txd-team/monthly/issues\">投稿</a>\n本期小编：<a href=\"https://github.com/happyliuliu\">玙璠</a></p>\n</blockquote>\n<h3>学习专栏</h3>\n<h4>2019 年前端技术会议</h4>\n<p>裕波列出了一份前端技术会议的<a href=\"https://www.yuque.com/itchina110/giku37/xdzuak\">清单</a>，涵盖国内和海外的重大前端相关的技术会议</p>\n<h4>微软前端训练营</h4>\n<p>微软推出另一个前端的学习路径规划，官方提供的<a href=\"https://github.com/Microsoft/frontend-bootcamp\">代码仓库</a>将一步一步带你走进前端技术领域，囊括基础的 HTML/CSS/JS 学习、TypeScript 强类型、React/Redux 学习和实践等。</p>\n<h3>新闻快报</h3>\n<h4>阿里开源 Flutter 应用框架 Fish Redux</h4>\n<p><a href=\"https://github.com/alibaba/fish-redux\">Fish Redux</a> 框架是基于 Redux 数据管理的组装式 Flutter 应用框架，适合用于构建中大型的复杂应用，解决了集中状态管理和UI组件化等问题，将集中，分治，复用，隔离做的更进一步。</p>\n<h4>Handtrack.js 搞定手部动作跟踪</h4>\n<p>这是一个经过训练的产生的开源模型，而不需要用户自己训练。它隐藏了模型的加载步骤，允许用户在没有任何 ML 经验的情况下检测图像中的手，可以直接在 Web 应用使用该库，<a href=\"https://github.com/eduardolundgren/tracking.js\">传送门</a>。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/137059/1554173440898-750a723a-7f77-4a2b-8be6-4657f6a1e5d5.gif#align=left&amp;display=inline&amp;height=194&amp;name=%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.gif&amp;originHeight=240&amp;originWidth=320&amp;size=3646259&amp;status=done&amp;width=259\" alt=\"人工智能.gif\"></p>\n<h4>小程序多端框架</h4>\n<p>如今小程序的发展如日中天，很多公司的业务也都慢慢转向小程序，同时很多应用需要同时兼顾多个小程序平台，所以就有了上层开发框架或者脚手架来优化 DSL 来提高开发效率。其中凹凸实验室从开发体验、兼容性、接入成本、工具链等多个方面对小程序的的多端框架进行了全面的<a href=\"https://juejin.im/post/5c90eb366fb9a070d4199cc9\">测评</a>，如果准备入坑，可以事先了解一下。</p>\n<h4>TWA 让你的 PWA 进入应用商店</h4>\n<p>TWA（Trusted Web Activity）的发布，是将 Native 的技术扩展到 Web App，将 PWA 站点打包为 Native App 放入应用商店，用户可以在应用商店中搜索安装 PWA 应用，相比国外，PWA 在国内并非很流行，但这并不代表这个技术就不关键。未来可以考虑如何将该技术融入实践中来，<a href=\"https://developers.google.com/web/updates/2019/02/using-twa\">传送门</a>，这篇<a href=\"https://www.infoq.cn/article/XTE9WzSL11iHmW*WBozi\">文章</a>也有全面的解析。</p>\n<h4>Storybook 5.0 正式发布</h4>\n<p>Storybook 是一个比较受欢迎的 UI 组件库，为各种视图层（如 React、Vue、Angular、React Native、Ember）提供了结构化的 UI 开发、测试和文档。Storybook 5.0 是目前为止发布的最大的一个版本，新版本的内容包括：全新的开发体验；带有主题的组件库；改进的前端插件架构；全新的<a href=\"https://storybook.js.org/\">官网</a>。</p>\n<h4>Node.js 和 JS 基金会合并为 OpenJS 基金会</h4>\n<p>Node.js 基金会和 JS 基金会宣布合并为 OpenJS 基金会，将提供一个中立的组织来托管项目并协助资助有益于生态系统的活动，简化基金会日常运营的同时满足个基础架构、技术和营销需求，为 Node.js 和 JavaScript 提供更光明的未来，这也是 JavaScript 发展中的一大步。</p>\n<h4>5G 来了</h4>\n<p>从 2G 的发展，到 3G 的的成熟，再到 4G 落地，继而迎接 5G 时代的全面到来。5G 具有极快的传输速度、更高的网络容量、信息可及时触达等特点，也就是高速率、多连体、低时延。这些优势可带动广泛的行业发展，如物联网、视频、全息技术以及无人驾驶等，让我们，拭目以待。</p>\n<h4>996.ICU</h4>\n<p>相当火爆的 github 项目 <a href=\"https://github.com/996icu/996.ICU\">996.ICU</a>，由 IT 工作者对工作制度的反抗，以谋求自己的合法权益的一种特别的方式。不得不感叹的是，随着时代及技术的发展，无产阶级的联合方式也在发生着变化。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/137059/1554173440891-46104a73-a778-4813-b116-2d2840e6795f.gif#align=left&amp;display=inline&amp;height=168&amp;name=%E5%8A%A0%E7%8F%AD.gif&amp;originHeight=104&amp;originWidth=129&amp;size=19061&amp;status=done&amp;width=208\" alt=\"加班.gif\"></p>\n<h4>TSLint -&gt; ESLint</h4>\n<p>继和 Babel 合作，使 Babel 支持编译 TS 语法后，TypeScript 团队又发布了新的 Roadmap，将使用 ESLint 来进行 TS 语法的静态类型检查，统一开发体验。TSLint 和 ESLint 团队也纷纷发文，公布未来的计划，TSLint 在被完全集成之前，会保持维护状态，ESLint 中推荐使用 typescript-eslint 来支持 TS 语法的静态类型检查，具体见 <a href=\"https://github.com/palantir/tslint/issues/4534\">TSLint Roadmap</a>、<a href=\"https://eslint.org/blog/2019/01/future-typescript-eslint\">The future of TypeScript on ESLint</a></p>\n<h3>工具推荐</h3>\n<h4><a href=\"https://github.com/alexfoxy/laxxx\">Animations when you scroll</a></h4>\n<ul>\n<li>将滚动与动画相结合，使页面更有灵性</li>\n<li>支持在 DOM、React、VUE 中使用</li>\n<li>支持多种动画参数配置</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/137059/1554173440895-2c7ea1b1-3e3c-428b-9c40-fa08b863168c.gif#align=left&amp;display=inline&amp;height=259&amp;name=lax.gif&amp;originHeight=259&amp;originWidth=320&amp;size=634366&amp;status=done&amp;width=320\" alt=\"lax.gif\"></p>\n<h4>You Dont Need 系列</h4>\n<p>You Dont Need 系列教程目的在于让读者回归基础，在不依赖一些主流的 util 库的情况下，自己动手去实现库里面提供的核心功能；很多情况下，一些 util 库占用了大量的体积，而且业务中实际使用的部分很少，如果能够手工去实现其中使用到的一些方法，就可以轻松通过移除三方库来提高加载速度了。（然而上规模的项目中，依然建议使用统一的 util 库）</p>\n<ul>\n<li><a href=\"https://github.com/you-dont-need/You-Dont-Need-JavaScript\">You-Dont-Need-JavaScript</a> 介绍了一些常用的组件、动效、甚至功能，在不通过编写 JavaScript 代码的前提下去实现它！</li>\n<li><a href=\"https://github.com/you-dont-need/You-Dont-Need-GUI\">You-Dont-Need-GUI</a> 许多场景下，我们使用命令交互的方式去操作机器（如文件、进程等处理），能大幅提高工作效率。</li>\n<li><a href=\"https://github.com/you-dont-need/You-Dont-Need-Momentjs\">You-Dont-Need-Momentjs</a> 介绍了 moment.js 对时间处理的核心功能实现。（通常情况下，我们还是需要一个时间处理库，推荐使用体积更小的 date-fns / dayjs）。</li>\n<li><a href=\"https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore\">You-Dont-Need-Lodash-Underscore</a> 常用的一些 util 方法的 JavaScript 实现。</li>\n<li><a href=\"https://github.com/nefe/You-Dont-Need-jQuery\">You-Dont-Need-jQuery</a> 去除 jQuery 的一些 Native JavaScript 的方案，一步一步替换 jQuery 的 API。</li>\n</ul>\n<h4>TypeScript To WebAssembly</h4>\n<p>通常我们都需要将 TypeScript 编译成 ES5 的代码，才能在浏览器中正常运行，<a href=\"https://github.com/AssemblyScript/assemblyscript\">assemblyscript</a> 是一款 TypeScript To WebAssembly 的编译器，通过 Webassembly 运行编译后的二进制代码。</p>\n<h3>热门文章</h3>\n<h4><a href=\"https://zhuanlan.zhihu.com/yujiangshui\">我在淘宝做前端的这三年</a></h4>\n<p>红了樱桃，绿了芭蕉。文章将在淘宝的三年时光折射为入职、职业规划、招聘、晋升、离职等与我们息息相关的经验分享，值得品读。</p>\n<h4><a href=\"https://mp.weixin.qq.com/s?__biz=MzI5MTA4ODA3NQ==&amp;mid=2247483710&amp;idx=1&amp;sn=cce855fd797f68ef77da424a7809500b&amp;chksm=ec14b29adb633b8ccd4cab9a84adfd89014c96792c799b8501bdaf99bfc3c916dd298ffd62e3&amp;mpshare=1&amp;scene=2&amp;srcid=&amp;from=timeline&amp;ascene=2&amp;devicetype=androi\">前端专业方向的尽头</a></h4>\n<p>驽马十驾,功在不舍。或是走一条纯专业的探索之路，或是趋向技术管理，这些都是技术人的选择与坚持，也会拥有独一无二的风景。</p>\n<h4><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651014404&amp;idx=2&amp;sn=7ed7c965c10af5463b0ffadd9661ab61&amp;chksm=bdbebd578ac93441467b1d81bc81141f2cecbee0b35dd625c62156d8f6abd33d1bea8661bea6&amp;xtrack=1&amp;scene=0&amp;subscene=131&amp;clicktime=1552918479&amp;ascene=7&amp;devic\">2019年大前端技术趋势深度解读</a></h4>\n<p>念过去，望未来。前端的发展日新月异，坚持学习的同时也要保持思辨和平和。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/137059/1554173440911-9bd825a2-0664-4e96-b300-12a855a34e4a.png#align=left&amp;display=inline&amp;height=378&amp;name=image.png&amp;originHeight=1044&amp;originWidth=1080&amp;size=1149092&amp;status=done&amp;width=391\" alt=\"image.png\"></p>\n</div>","title":"前端小报 - 201903月刊","last_reply_at":"2019-04-08T02:04:05.080Z","good":false,"top":false,"reply_count":3,"visit_count":863,"create_at":"2019-04-02T05:37:22.144Z","author":{"loginname":"x-cold","avatar_url":"https://avatars1.githubusercontent.com/u/6903313?v=4&s=120"}},{"id":"5ca464fd6c1de62dce467688","author_id":"5ca4639c31010b2dfbb42c0a","tab":"ask","content":"<div class=\"markdown-text\"><p>刚开始的时候，node main.js是正常的，接口也可以正常返回，但是放着一段时间，大概5~10分钟，就会报错 read ECONNRESET，然后重新运行node main.js又可以了，间隔一段时间又是同样的问题。node小白，求大神指点一下<img src=\"//static.cnodejs.org/FoR7GugN2D91pb0aKqn6TxNEl_Fu\" alt=\"error.png\"></p>\n</div>","title":"node运行接口，刚开始是正常的，间隔一段时间后变成 read ECONNRESET","last_reply_at":"2019-04-08T01:58:33.508Z","good":false,"top":false,"reply_count":6,"visit_count":585,"create_at":"2019-04-03T07:47:09.354Z","author":{"loginname":"yjl000","avatar_url":"https://avatars0.githubusercontent.com/u/25833497?v=4&s=120"}},{"id":"5ca9c17bd68ff5064921a9ed","author_id":"54d85b676a95c42f404f7e26","tab":"share","content":"<div class=\"markdown-text\"><p>目前我付出的健康上网费用是86.5CNY/month，如果和另外两个人共享，年付，只要222CNY/year.\n省钱是王道。\n我Wechat：gazeldx\n感谢CnodeJS平台。</p>\n</div>","title":"健康上网帐号付费共享，寻需要的朋友","last_reply_at":"2019-04-08T01:27:27.121Z","good":false,"top":false,"reply_count":1,"visit_count":430,"create_at":"2019-04-07T09:23:07.567Z","author":{"loginname":"gazeldx","avatar_url":"https://avatars.githubusercontent.com/u/1132770?v=3&s=120"}},{"id":"5ca84e8b6c1de62dce468344","author_id":"579daf3285dba6b12ac5856e","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://moodz.minghe.me\">微信最轻的日记本</a></p>\n<p>之前有发过一个<a href=\"https://ruby-china.org/topics/37656\">版本</a>，这两天趁着假期，重新设计了一下UI. 有兴趣的同学可以尝试一下.</p>\n<p><img src=\"//static.cnodejs.org/FqwgzB5przXcPX7eD7zzbep20Ie7\" alt=\"compose.jpg\"></p>\n<p>微信扫码:</p>\n<p><img src=\"//static.cnodejs.org/FsfOS_-x-AJZu1IxHpWZ-gfIMv6w\" alt=\"moodz.png\"></p>\n</div>","title":"“轻巧日记\"小程序 记录多彩生活","last_reply_at":"2019-04-08T01:05:51.820Z","good":false,"top":false,"reply_count":1,"visit_count":615,"create_at":"2019-04-06T07:00:27.773Z","author":{"loginname":"metrue","avatar_url":"https://avatars2.githubusercontent.com/u/1001246?v=4&s=120"}},{"id":"5ca3359e31010b2dfbb426c4","author_id":"556150874eb040084cfe5dcb","tab":"ask","content":"<div class=\"markdown-text\"><p>在 <code>koa-compose</code> 中 <a href=\"https://github.com/koajs/compose/blob/4.1.0/index.js#L42\">return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));</a>为什么需要 <code>Promise.resolve()</code></p>\n<p>a:  在 <a href><code>koa/application.js</code></a> 中</p>\n<p><code>fnMiddleware(ctx).then(handleResponse)</code>, 可知需要一个 <code>Promise</code></p>\n<p>但是 改成如下也是可以工作的</p>\n<pre class=\"prettyprint\"><code>return function (context, next) {\n    &#x2F;&#x2F; last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i &lt;= index) return Promise.reject(new Error(&#x27;next() called multiple times&#x27;))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      \n\n      &#x2F;&#x2F; 添加 对 i === 0 判断是否是 fnMiddleware(ctx).then\n      if( i === 0) {\n       fn = (...args) =&gt; {\n\t\t\tlet res = null;\n\t\t\t&#x2F;&#x2F; 1楼提出的改善\n\t\t\ttry{\n\t\t  \t\tres = Promise.resolve(middleware[0](...args))\n\t\t\t} catch(e) {\n\t\t\t\tres = Promise.reject(e);\n\t\t\t}\n\t\t\treturn res;\n\t   }\n      }\n      if (!fn) return Promise.resolve()\n      try {\n        return fn(context, dispatch.bind(null, i + 1));\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n</code></pre><p>b: 如果是 middleware 中 需要 <code>await next</code> 的话, 一定是一个 <code>async</code> 函数, 所以也不需要<code>Promise.resolve()</code></p>\n<p>c: 如果 middleware 是一个同步函数, 也不需要 <code>Promise.resolve()</code></p>\n<p>还有哪些情况我没有考虑到的?</p>\n</div>","title":"koa-compose 为什么需要  Promise.resolve(fn(context, dispatch.bind(null, i + 1)));","last_reply_at":"2019-04-07T07:30:14.115Z","good":false,"top":false,"reply_count":6,"visit_count":528,"create_at":"2019-04-02T10:12:46.903Z","author":{"loginname":"xinshangshangxin","avatar_url":"https://avatars1.githubusercontent.com/u/8779091?v=4&s=120"}},{"id":"5ca987dcd68ff5064921a98a","author_id":"5c98426500bcfd7eb2be5add","tab":"share","content":"<div class=\"markdown-text\"><h1>JavaScript中的执行上下文和堆栈是什么</h1>\n<p>在这篇文章中，将深入研究JavaScript最基本的部分之一，即执行上下文。在这篇文章的最后，你应该更清楚地理解解释器要做什么，为什么在声明一些函数/变量之前可以使用它们，以及它们的值是如何确定的。</p>\n<h2>什么是执行上下文</h2>\n<p>当JavaScript代码运行时，执行代码的环境是相当重要的。一般有以下三种情况：</p>\n<ul>\n<li>全局代码 – 代码首次开始执行的默认环境</li>\n<li>函数代码 – 每当进入一个函数内部</li>\n<li>Eval代码 – eval内部代码执行时</li>\n</ul>\n<p>把执行上下文看作是当前代码正在执行的环境/作用域</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; global context\nvar sayHello = &#x27;sayHello&#x27;\n\nfunction person() {\n  var first = &#x27;webb&#x27;\n  var last = &#x27;wang&#x27;\n\n  function firstName() {\n    return first\n  }\n\n  function lastName() {\n    return last\n  }\n\n  console.log(sayHello + firstName() + &#x27;&#x27; + lastName())\n}\n</code></pre><p>以上代码没什么特别的地方，它包括1个全局上下文和3个不同的函数上下文,全局上下文可以被程序中的其它任何上下文访问。</p>\n<p>你可以有任意数量的函数上下文，每个函数被调用的时候都会创建一个新的上下文。每个下文都有一个不能被外部函数直接访问到的内部变量的私有作用域。在上面代码的例子中，一个函数可以访问当前上下文外部声明的变量，但是一个外部上下文不可以访问函数内部声明的变量。</p>\n<h2>执行上下文堆栈</h2>\n<p>浏览器中的JavaScript解释器是作为一个单线程实现的，这实际上意味着，在浏览器中，一次只能发生一件事，其他操作或事件将排队在所谓的执行堆栈中。</p>\n<p>当浏览器开始执行脚本时，首先会默认进入全局执行上下文，如果在全局代码中调用了函数，程序会按照顺序进入被调用函数，创建一个新的执行上下文，并推入到执行栈的栈顶。</p>\n<p>如果你在当前执行的函数中，调用了另外的函数，代码的执行流将会进入函数内部，并创建一个新的执行上下文推入到执行栈顶。浏览器总是会先执行栈顶的代码，并且一旦函数完成执行当前执行上下文，他就会从栈顶弹出，将控制权返回到当前堆栈中的上下文。</p>\n<p>关于执行堆栈有以下关键点</p>\n<ul>\n<li>单线程</li>\n<li>同步执行</li>\n<li>1个全局上下文</li>\n<li>每个函数调用都会创建一个新的执行上下文，即使调用它自身。</li>\n</ul>\n<h2>深入理解执行上下文</h2>\n<p>现在我们知道每当有函数被调用时，都会创建一个新的执行上下文。在js内部，每个执行上文创建都要经历下面2个阶段</p>\n<p>1.创建阶段（函数被调用，但还没有执行内部代码）</p>\n<ul>\n<li>创建作用域链</li>\n<li>创建变量和参数</li>\n<li>决定this指向</li>\n</ul>\n<p>2.代码执行阶段</p>\n<ul>\n<li>变量赋值，执行代码</li>\n</ul>\n<p>可以将每个执行上下文概念上表示为一个具有3个属性的对象:</p>\n<pre class=\"prettyprint language-js\"><code>executionContextObj = {\n  &#x27;scopeChain&#x27;: { &#x2F;* variableObject + all parent execution context&#x27;s variableObject *&#x2F; },\n  &#x27;variableObject&#x27;: { &#x2F;* function arguments &#x2F; parameters, inner variable and function declarations *&#x2F; },\n  &#x27;this&#x27;: {}\n}\n</code></pre><h2>活动对象/变量对象（AO/VO）</h2>\n<p>当函数被调用时，在创建阶段解释器会创建包含有函数内部变量，参数的一个变量对象</p>\n<h3>下面是解释器如何评估代码的概述</h3>\n<ol>\n<li>扫描被调用函数中的代码</li>\n<li>在代码执行前，创建执行上文</li>\n<li>进入创建阶段\n<ul>\n<li>初始化作用域链</li>\n<li>创建变量对象</li>\n<li>创建arguments对象，检查参数上下文，初始化名称和值，并创建引用副本</li>\n<li>扫描上下文中函数的声明\n<ul>\n<li>对于找到的每个函数，在变量对象中创建一个属性，该属性是确切的函数名，该函数在内存中有一个指向该函数的引用指针</li>\n<li>如果函数名已经存在，指针将会被覆盖</li>\n</ul>\n</li>\n<li>扫描变量的声明\n<ul>\n<li>对于找到的每个变量，在变量对象中创建一个属性，该属性是确切的变量名，该变量的值是undefined</li>\n<li>如果变量名已经存在，将不会做任何处理继续\b执行</li>\n</ul>\n</li>\n<li>决定this的值</li>\n</ul>\n</li>\n<li>代码执行阶段\n<ul>\n<li>变量赋值，按顺序执行代码</li>\n</ul>\n</li>\n</ol>\n<h2>声明提升</h2>\n<p>你可以在网上找到许多用JavaScript定义术语提升的资源，解释变量和函数声明被提升到函数作用域的顶部。但是，没有人详细解释为什么会发生这种情况，而且有了解释器如何创建激活对象的新知识，就很容易理解为什么会发生这种情况。以下面的代码为例:</p>\n<pre class=\"prettyprint language-js\"><code>(function() {\n  console.log(typeof foo); &#x2F;&#x2F; function pointer\n  console.log(typeof bar); &#x2F;&#x2F; undefined\n\n  var foo = &#x27;hello&#x27;,\n      bar = function() {\n          return &#x27;world&#x27;;\n      };\n\n  function foo() {\n      return &#x27;hello&#x27;;\n  }\n\n}());​\n</code></pre><h3>为什么在什么之前可以访问到foo</h3>\n<p>如果我们遵循创建阶段，我们就知道在代码执行阶段之前已经创建了变量。因此，当函数流开始执行时，foo已经在活动对象中定义。</p>\n<h3>Foo声明了两次，为什么Foo是函数而不是未定义或字符串？</h3>\n<p>尽管foo声明了两次，但从创建阶段我们就知道函数是在变量之前在变量对象上创建的，如果变量对象上的属性名已经存在，那么我们只需绕过。\n因此，首先在变量对象上创建对函数foo()的引用，当解释器到达var foo时，我们已经看到了属性名foo的存在，所以代码什么也不做，继续执行</p>\n<h3>为什么bar是undefined</h3>\n<p>bar实际上是一个具有函数赋值的变量，我们知道这些变量是在创建阶段创建的，但是它们是用undefined值初始化的。</p>\n<h2>总结</h2>\n<p>希望现在你已经很好地理解了JavaScript解释器是如何执行代码的。理解执行上下文和堆栈可以让你了解代码没有按照预期执行的原因</p>\n</div>","title":"JavaScript中的执行上下文和堆栈是什么","last_reply_at":"2019-04-07T05:17:16.576Z","good":false,"top":false,"reply_count":0,"visit_count":549,"create_at":"2019-04-07T05:17:16.576Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5ca986937edd13064e052e96","author_id":"5c98426500bcfd7eb2be5add","tab":"share","content":"<div class=\"markdown-text\"><h1>两种敏捷开发方式的工作流</h1>\n<p>敏捷开发时当今很流行的一种开发软件方式，接下来主要介绍一下两种主要的敏捷开发方式的工作流</p>\n<h2>Scrum flow</h2>\n<p>项目计划从定义backlog开始，即交付完成的产品时应该完成的用户需求列表。</p>\n<ul>\n<li>产品 backlog - 列出团队主要的 “To Do” list。 产品的代办事项列表应该包括全部的特性和 bug 修复。以便在项目结束时确认已经完成。产品的代办列表需要在工作中按照新的需求或者发现的错误持续的更新。产品的负责人负责待办事项，使其与客户的反馈和建议以及团队的工作进度同步。一些Item的优先级应该被提升或下降，一些item应该根据需求的变化增加或者减少。</li>\n<li>Sprint backlog - 包含在特定sprint中要完成的任务。sprint backlog的项目被选择为在sprint结束时交付一个完成的特性或组件。虽然sprint backlog也允许一定的灵活性和修改，但是sprint的目标应该保持不变，并且变更应该保持在最小。</li>\n<li>Sprint goal or increment - 作为sprint结果交付的可用产品。通常，sprint以展示完成的特性或组件的演示结束。在这方面，一个重要的概念是“done”的定义，它指的是要将每个用户工作视为完整的。“done”的定义可能会根据用户的情况而有所不同:它可能包含多个任务，例如开发、测试、设计、文档和表示，还可能涉及不同的团队成员。</li>\n</ul>\n<p>每个sprint都从一个计划阶段开始，在下一个sprint中选择任务。对于计划阶段，整个团队通常都会到场，包括产品负责人和Scrum Master。团队决定在sprint结束时可以交付什么，并从产品backlog中选择相应的用户工作。通过这种方式，他们将sprint backlog放在一起。</p>\n<p>在sprint期间，团队每天开会进行“每日scrum”，讨论他们的进展以及可能遇到的任何障碍。每日scrum的目的是尽早发现问题，并快速找到解决方案，以免中断sprint流程。</p>\n<p>在sprint之后，涉众将审查完成的特性。在sprint评审期间，团队有机会收到关于他们工作的反馈，以及变更建议(如果有的话)。</p>\n<p>与此同时，团队开会进行sprint回顾，分析他们刚刚完成的sprint，并找到可以改进的地方。回顾之后，流程被重置，新的sprint从计划阶段开始。</p>\n<p><img src=\"https://da-14.com/sites/default/files/pictures/kanban-vs-scrum-workflow-sprint-development.jpg\" alt=\"''\"></p>\n<h2>Kanban flow</h2>\n<p>在 Kanban中，没有要求需要在一个确定的时间点完成一定数量的工作。相反，Kanban专注于平衡团队的当前正在进行的工作的能力。</p>\n<p>一个 Kanban 项目流程从一般的backlog开始,包含所有的应该完成的任务。每个团队成员从backlog中为自己挑选一个任务，并集中精力完成它。当任务完成时，成员选择下一个任务，以此类推，直到所有任务完成为止。待办事项列表的优先级是将最紧急的任务放在顶部，由团队首先处理。</p>\n<p>在Kanban中，重要的是在项目期间的任何时候，正在进行的工作量都不能超过团队的能力。为此目的，有可能根据现有的能力为任何类型的工作定一个限度。</p>\n<p>产品负责人可以尽可能频繁地设置和更改backlog中的优先级，因为backlog管理对团队的性能没有影响。团队只关心正在进行的工作，只有在当前任务完成后才返回到backlog。</p>\n<p>每个任务都沿着“To Do”—“Work in Progress”—“Done”路线进行。当然，Kanban也支持“完成”定义的概念，这是每个任务接受的标准。</p>\n<p>总而言之，我们可以说Scrum的主要区别在于它试图在指定的时间内完成预定的工作，而Kanban确保正在进行的工作永远不会超过设定的限制。</p>\n<h2>如何选择</h2>\n<p>如果你一直在等待这个问题的最终答案，我们可能会让你失望。到目前为止，我们希望已经成功地证明了这两种方法都有它们的优点，并且都可以帮助建立敏捷开发过程。然而，我们提供了一些指导方针，可以帮助您选择最适合您的团队的方法。</p>\n<h3>使用 Scrim</h3>\n<ul>\n<li>你可以相对容易地将工作划分为逻辑块，这些逻辑块可以在两周内完成。</li>\n<li>你需要对整个项目有高度的可预测性。Scrum专注于将sprint中的变更保持在最小。</li>\n<li>你的团队里有很多新成员。使用Scrum，如果需要的话，他们会更容易理解团队纪律并做出改进。</li>\n</ul>\n<h3>使用 Kanban</h3>\n<ul>\n<li>你期望项目中有很多频繁的变更。</li>\n<li>很难隔离能够在两周内交付的产品组件。</li>\n<li>你的团队纪律严明，可以信任他们会在没有严格截止日期的情况下安排他们的活动。</li>\n</ul>\n</div>","title":"两种敏捷开发方式的工作流介绍","last_reply_at":"2019-04-07T05:11:47.588Z","good":false,"top":false,"reply_count":0,"visit_count":528,"create_at":"2019-04-07T05:11:47.588Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5ca95340d68ff5064921a8e6","author_id":"5941d0829079357b642b2771","tab":"ask","content":"<div class=\"markdown-text\"><p>请问：如何才算将nodejs精通了？</p>\n</div>","title":"请问：如何才算将nodejs精通了？","last_reply_at":"2019-04-07T02:13:17.941Z","good":false,"top":false,"reply_count":2,"visit_count":726,"create_at":"2019-04-07T01:32:48.976Z","author":{"loginname":"lililbwl","avatar_url":"https://avatars1.githubusercontent.com/u/13088143?v=4&s=120"}},{"id":"5ca6bba46c1de62dce46809f","author_id":"50b5bc5d637ffa4155091236","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>var dgram     = require(&#x27;dgram&#x27;)\nvar udp       = dgram.createSocket(&#x27;udp4&#x27;)\n\nudp.on(&#x27;message&#x27;, function(data, ipdr) {\n  console.log(&#x27;message&#x27;)\n  console.log(data.toString())\n  console.log(ipdr)\n})\n\nudp.on(&#x27;error&#x27;, function(err) {\n  console.log(&#x27;error&#x27;)\n  console.log(arguments)\n})\n\nudp.on(&#x27;listening&#x27;, function(err) {\n  console.log(&#x27;listening&#x27;)\n  console.log(arguments)\n})\n\nudp.bind(8090)\nconsole.log(&#x27;udp listening on port 8090&#x27;)\n\n\nvar send = function(message, port, host) {\n  console.log(&#x27;send&#x27;)\n  console.log(arguments)\n  udp.send(Buffer.from(message), port || 8090, host || &#x27;localhost&#x27;)\n}\n\n \nif (require.main === module) {\n  var port = parseInt(process.argv[2])\n  var host = process.argv[3]\n  if (port) {\n    send(&#x27;echo&#x27;, port, host)\n  } else {\n    send(&#x27;echo&#x27;)\n  }\n}\n\n\n\n\n</code></pre><p>在本地服务器可以连接，布署在阿里云服务器上用客户端连就没反应</p>\n</div>","title":"阿里云给的是内网ip ,是不是就没法实现udp连接了？","last_reply_at":"2019-04-06T03:24:02.766Z","good":false,"top":false,"reply_count":2,"visit_count":370,"create_at":"2019-04-05T02:21:24.944Z","author":{"loginname":"yakczh","avatar_url":"https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"}},{"id":"5c95dc1dfd41137eb7660bd2","author_id":"5c95d7eefd41137eb7660bbf","tab":"ask","content":"<div class=\"markdown-text\"><p>由于node本身异步的机制，打印日志也是异步的，而不是一个请求对应一个完整的日志过程，在请求并发的时候日志都是混乱的，请问大佬们平时都是怎么做的，希望大家可以互相讨论学习下</p>\n</div>","title":"node如何做到日志“同步”","last_reply_at":"2019-04-05T07:46:02.561Z","good":false,"top":false,"reply_count":10,"visit_count":1067,"create_at":"2019-03-23T07:11:25.195Z","author":{"loginname":"newJack12","avatar_url":"https://avatars1.githubusercontent.com/u/38709773?v=4&s=120"}},{"id":"5ca63a1031010b2dfbb43674","author_id":"5c3a86a23898674067a7e824","tab":"share","content":"<div class=\"markdown-text\"><h2>缘起</h2>\n<p>考完 Final 又是一个 Spring Break，10 天很无聊啊，人一无聊就想写代码，但是前面写守望 UI  CSS 的时候写伤了，而且 Spring Break 就 10 天，实在不想写一个大项目。</p>\n<p>有一天听到了古巨基的《爱与诚》里面唱的：<strong>“做只🐱做只🐶不做情人”</strong>。不如就做一个阿猫阿狗的 APP 吧，当然单做一个简单的 APP 又是写写页面，不好玩，所以这个 APP 用了三大框架都写了一次。UI 框架也用了之前没怎么用过的 Material UI，NG-ZORRO。</p>\n<h2>Demo</h2>\n<p>每个框架产出的 APP 都放在不只的 URL 里，所以就写了个简陋的首面将它们集中一起啦</p>\n<ul>\n<li>\n<p><a href=\"https://haixiang6123.github.io/awesome-a-cat-a-dog/\">Home page is here!</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/Haixiang6123/awesome-a-cat-a-dog\">Github: awesome-a-cat-a-dog</a></p>\n</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/5/169e951a8581ac52?w=3360&amp;h=1864&amp;f=png&amp;s=177708\" alt></p>\n<p>App 的布局就参照 XX 软件写的，咳咳，这个 XX 你们可以猜猜，下面是 Vue 版的阿猫阿狗。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/5/169e951cb8cab1e2?w=3360&amp;h=1850&amp;f=png&amp;s=1189817\" alt=\"Vue\"></p>\n<h2>后记</h2>\n<p>写了一遍对这三大框架的差异也有一个更大的了解，反正就是写 Vue 的时候觉得 React 简洁，没有太多约束想干嘛就干嘛，写 React 的时候又觉得 Vue 有约束爽，直接套 Vue 里的东西就搞定了，简单。写 Angular 又觉得啥都是官方的，用起来更放心，文档很全，就是太麻烦了文件名字也太长了点 8。</p>\n<p>看了那么多知乎上的什么“三大框架对比”其实不如自己用一次来得舒服，理解更深刻。所以 <strong>纸上得来终觉浅，绝知此事要躬行</strong> 呀</p>\n<hr>\n<h2>技术栈/库（补）</h2>\n<p>这可能不是一个特别创新的项目，只是熟悉一下三大框架的同时，也用一下以前没用过的库。下面是这个项目的技术栈。</p>\n<h3>API</h3>\n<ul>\n<li>猫猫的 API：<a href=\"https://thecatapi.com/\">thecatapi.com</a></li>\n<li>狗狗的 API：<a href=\"https://thedogapi.com/\">thedogapi.com</a></li>\n</ul>\n<h3>React</h3>\n<ul>\n<li>React，React Router，Redux</li>\n<li>TypeScript</li>\n<li>Scss</li>\n<li>Axios</li>\n<li>Material UI x React</li>\n</ul>\n<h3>Vue</h3>\n<ul>\n<li>Vue，Vue Router，Vuex</li>\n<li><s>Material x Vue</s> (太坑了，写到一半实在写不下去了，还是用回 Element UI)</li>\n<li>Axios</li>\n<li>Scss</li>\n</ul>\n<h2>Angular</h2>\n<ul>\n<li>Angular (TypeScript 路由什么的都包了)</li>\n<li>Axios (有个地方查了 Google 半天， 用 Angular 的 HttpClient 实在解决不了，只能用一下 Axios)</li>\n</ul>\n</div>","title":"你们这些阿猫🐱阿狗🐶，做只猫🐱做只狗🐶不要做情人啊","last_reply_at":"2019-04-04T17:08:32.352Z","good":false,"top":false,"reply_count":0,"visit_count":649,"create_at":"2019-04-04T17:08:32.352Z","author":{"loginname":"Haixiang6123","avatar_url":"https://avatars1.githubusercontent.com/u/17061654?v=4&s=120"}},{"id":"5ca5fea631010b2dfbb43604","author_id":"55c56e8a39273b9219336288","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>原文： <a href=\"https://github.com/t9tio/tomato-pie/blob/master/blog/stay_focus_when_doing_tomato.md\">https://github.com/t9tio/tomato-pie/blob/master/blog/stay_focus_when_doing_tomato.md</a></p>\n</blockquote>\n<h3>关于 tomato-pie 的前序介绍</h3>\n<ul>\n<li><a href=\"https://www.v2ex.com/t/538331#reply24\">https://www.v2ex.com/t/538331#reply24</a></li>\n<li><a href=\"https://www.v2ex.com/t/547816#reply8\">https://www.v2ex.com/t/547816#reply8</a></li>\n</ul>\n<h3>缘起</h3>\n<p>最近在阅读 <a href=\"https://en.wikipedia.org/wiki/Getting_Things_Done\">Getting Things Done\n</a> by <a href=\"https://en.wikipedia.org/wiki/David_Allen_(author)\">David Allen</a>。里面提到的一个点很触动到我 – 关注 “next action” 而不是同时思考着很多事情。整理好自己的 todo list 们，排好优先级之后，只关注接下来你要做的事情并且专注于此。这样的工作方式下自己会更专注，感受到的压力更小，从而更有效率。</p>\n<h3>Tomato pie 的 “next action”</h3>\n<p>于是顺手给 tomato-pie 加了一个功能: 当你在为某个 todo 做番茄时，将其他 todo 模糊掉：</p>\n<p><img src=\"https://raw.githubusercontent.com/timqian/images/master/focusing_mode.gif\" alt></p>\n<h3>欢迎安装试用</h3>\n<ul>\n<li><a href=\"https://chrome.google.com/webstore/detail/gffgechdocgfajkbpinmjjjlkjfjampi\">从 chrome web store 安装试用</a></li>\n<li><a href=\"https://github.com/t9tio/tomato-pie\">Github 上的源代码</a></li>\n<li><a href=\"https://spectrum.chat/t9tio\">加入 t9t.io spectrum 群</a></li>\n<li><a href=\"https://user-images.githubusercontent.com/5512552/40399903-53d1ebde-5e72-11e8-98d8-615fc40c09f1.jpeg\">加入 t9t.io 微信群</a></li>\n</ul>\n</div>","title":"读 GTD 时间管理法有感以及 tomato-pie 的一个新 feature","last_reply_at":"2019-04-04T12:55:02.160Z","good":false,"top":false,"reply_count":0,"visit_count":263,"create_at":"2019-04-04T12:55:02.160Z","author":{"loginname":"timqian","avatar_url":"https://avatars3.githubusercontent.com/u/5512552?v=4&s=120"}},{"id":"5ca5ac5a31010b2dfbb433f8","author_id":"5ca5abdf31010b2dfbb433ec","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Frs9ZKsJnbrDMBacBzDz66QF__PV\" alt=\"node.png\"></p>\n<p>请问这是怎么回事？</p>\n</div>","title":"关于node gm模块图片处理的问题","last_reply_at":"2019-04-04T11:04:23.512Z","good":false,"top":false,"reply_count":3,"visit_count":516,"create_at":"2019-04-04T07:03:54.020Z","author":{"loginname":"blackyhb","avatar_url":"https://avatars1.githubusercontent.com/u/29148005?v=4&s=120"}},{"id":"5c9600c800bcfd7eb2be5484","author_id":"4efc278625fa69ac69000229","tab":"ask","content":"<div class=\"markdown-text\"><p>我在深圳，做了差不多10年程序员，以前是做游戏前端的，后来也做Web前端，然后是Web全栈，后端用Node，后来做游戏又用Node，差不多有三四年Node经验了，但是相对于Java、PHP等后端，Node的应用不是很广而且比较偏，现在找工作挺难的。</p>\n<p>之前公司招人也挺难的，因为Java、PHP转Node的人很少，大部分是前端转过去的，对后端的积累不深，不大满足要求。</p>\n<p>我现在就是处于这样尴尬的地位，虽然最近花了不少时间去积累后端深层技能，但是仍然不够自信。</p>\n<p>我最近在考虑要不要重新回到前端方向去。毕竟前端现在也越来越复杂。前后端全栈，一边调试CSS，一边研究Linux内核，感觉精力实在不足啊。</p>\n<p>不过考虑未来30年的职业发展，我肯定还是会全面发展的。只是近期比较尴尬，又到了养家糊口的年纪。</p>\n</div>","title":"前端转Node后端会很尴尬吗？","last_reply_at":"2019-04-04T08:39:57.050Z","good":false,"top":false,"reply_count":45,"visit_count":2723,"create_at":"2019-03-23T09:47:52.134Z","author":{"loginname":"lushisang","avatar_url":"https://avatars0.githubusercontent.com/u/197572?v=4&s=120"}},{"id":"5ca46b936c1de62dce467702","author_id":"5ca4678731010b2dfbb42c4b","tab":"ask","content":"<div class=\"markdown-text\"><p>抓取 cnode 社区首页的 40 条文章链接\n然后再对 40 条链接发起请求\n然后发现同时请求太多，会返回 503\n我就直接折腾，封装了一个控制 同时请求 的数量的函数，应该是叫 并发控制 吧。\n不过，有点问题，当我设置为 7 个并发时，就少了 7 条返回，设置为 2 条并发时，就少了 2 条返回。\n我想自己封装，不使用其他包\n以下为代码：</p>\n<pre class=\"prettyprint language-js\"><code>const axios = require(&#x27;axios&#x27;);\nconst cheerio = require(&#x27;cheerio&#x27;);\nconst url = require(&#x27;url&#x27;);\n\nconst href = &#x27;https:&#x2F;&#x2F;cnodejs.org&#x27;;\n\n&#x2F;&#x2F; 抓取url\naxios.get(href)\n      .then(res =&gt; {\n        let $ = cheerio.load(res.data);\n        let node = $(&#x27;#topic_list a.topic_title&#x27;);\n        let list = [];\n        node.each((index, value) =&gt; list.push(url.resolve(href, value.attribs.href)));\n        return list;\n      })\n      .then(list =&gt; {\n\t  &#x2F;&#x2F; 7 个并发\n        many(list, 7).then(data =&gt; console.log(data)).catch(err =&gt; console.log(err));\n\n      })\n      .catch(err =&gt; err);\n\n\n&#x2F;&#x2F; 多线程异步,并发\nfunction many (arr, n) {\n  return new Promise((resolve, reject) =&gt; {\n    &#x2F;&#x2F; 多线程统一数据存放\n    let list = [];\n    &#x2F;&#x2F; 正在运行的线程数\n    let thread = 0;\n    &#x2F;&#x2F; 队列\n    let length = 0;\n\n    &#x2F;&#x2F; 单线程异步\n    function queues (arr) {\n      return new Promise((resolve, reject) =&gt; {\n        &#x2F;&#x2F; 队列数据统一存放\n        let datas = [];\n        function queue (arr) {\n          length ++;\n          return new Promise((resolve, reject) =&gt; {\n          axios.get(arr[length-1])\n                .then(res =&gt; {\n                  if (length &lt; arr.length) {\n                    console.log(&#x27;...&#x27; + length);\n                    datas.push(res.data);\n                    return queue(arr).then(() =&gt; resolve());\n                  }\n                  else {\n                    resolve();\n                  }\n      \n      \n                })\n                .catch(err =&gt; reject(err));\n          });\n      \n        }\n      \n        queue(arr).then(() =&gt; resolve(datas))\n      });\n    }\n\n    &#x2F;&#x2F; 多线程创建\n    for (let i = 0; i &lt; n; i ++) {\n      thread++;\n      queues(arr)\n                .then(data =&gt; {\n                  list.push(data);\n                  thread--;\n                  if (thread === 0) {\n\t\t\t\t  &#x2F;&#x2F; 最后一个线程返回数据\n                    resolve(list);\n                  }\n                })\n                .catch(err =&gt; reject(err));\n    }\n\n  });\n}\n</code></pre><p>返回：\n<img src=\"//static.cnodejs.org/FtODHULPfaIfCJFu-FeXF-wUfxbi\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FoBs1-kL9wuIwcqqb714k_tRP8Nf\" alt=\"image.png\"></p>\n</div>","title":"并发控制问题","last_reply_at":"2019-04-04T07:22:26.860Z","good":false,"top":false,"reply_count":3,"visit_count":543,"create_at":"2019-04-03T08:15:15.982Z","author":{"loginname":"tingzhong666","avatar_url":"https://avatars0.githubusercontent.com/u/47524168?v=4&s=120"}},{"id":"5ca5a4e86c1de62dce467d75","author_id":"56fdcb26c5f5b4a959e91751","tab":"share","content":"<div class=\"markdown-text\"><p>极客教程-致力于推广各种编程语言技术，也为了未来数字化世界，让人更容易找到操作数字化的方式，为了未来而生的编程学习平台。</p>\n<p>优化了写作方式（类简书式，更友好）。如下图：</p>\n<p><img src=\"//static.cnodejs.org/Fh4GgpAT-sBntotCsCexsP_FYz1n\" alt=\"QQ20190404-142843@2x.png\">\n<img src=\"//static.cnodejs.org/FnLeguxk7154pelL9d5hTdEuokrx\" alt=\"QQ20190404-142938@2x.png\"></p>\n<p>欢迎体验, 地址: <a href=\"https://www.geekjc.com\">https://www.geekjc.com</a></p>\n</div>","title":"程序猿界的简书写作学习平台","last_reply_at":"2019-04-04T06:32:08.963Z","good":false,"top":false,"reply_count":0,"visit_count":611,"create_at":"2019-04-04T06:32:08.963Z","author":{"loginname":"cllgeek","avatar_url":"https://avatars0.githubusercontent.com/u/15187909?v=4&s=120"}},{"id":"5ca1e9dc31010b2dfbb41f35","author_id":"516cc5936d382773065b8e2f","tab":"share","content":"<div class=\"markdown-text\"><p>最近项目需要缓存一批二维码的点阵信息,\n最开始用二维数组存,发现太占资源,\n后来改用 Uint8Array 好了点,<br>\n想找个直接以bit为单元存储的类,结果没有;\n然后就有这个 <a href=\"https://github.com/cnwhy/BitMatrix\">BitMatrix</a>;</p>\n<p>用 ArrayBuffer来存储数据, 并把每个byte再拆成bit来用.   最终效果还是可以的, 有兴趣的可以关注一下, API还在完善中</p>\n<pre class=\"prettyprint\"><code>用 1 填充 2000 个 100*100 矩阵 内存占用情况:\n┌─────────┬──────────────────────┬────────────┬────────────┬────────────┐\n│ (index) │      className       │  heapUsed  │  external  │    sum     │\n├─────────┼──────────────────────┼────────────┼────────────┼────────────┤\n│    0    │     &#x27;BitMatrix&#x27;      │  &#x27;0.77MB&#x27;  │  &#x27;2.38MB&#x27;  │  &#x27;3.16MB&#x27;  │\n│    1    │     &#x27;Int8Matrix&#x27;     │  &#x27;0.87MB&#x27;  │ &#x27;19.07MB&#x27;  │ &#x27;19.94MB&#x27;  │\n│    2    │    &#x27;Uint8Matrix&#x27;     │  &#x27;0.81MB&#x27;  │ &#x27;19.07MB&#x27;  │ &#x27;19.89MB&#x27;  │\n│    3    │ &#x27;Uint8ClampedMatrix&#x27; │  &#x27;0.76MB&#x27;  │ &#x27;19.07MB&#x27;  │ &#x27;19.83MB&#x27;  │\n│    4    │    &#x27;Int16Matrix&#x27;     │  &#x27;0.68MB&#x27;  │ &#x27;38.15MB&#x27;  │ &#x27;38.83MB&#x27;  │\n│    5    │    &#x27;Uint16Matrix&#x27;    │  &#x27;0.68MB&#x27;  │ &#x27;38.15MB&#x27;  │ &#x27;38.83MB&#x27;  │\n│    6    │    &#x27;Int32Matrix&#x27;     │  &#x27;0.51MB&#x27;  │ &#x27;76.29MB&#x27;  │ &#x27;76.80MB&#x27;  │\n│    7    │    &#x27;Uint32Matrix&#x27;    │  &#x27;0.53MB&#x27;  │ &#x27;76.29MB&#x27;  │ &#x27;76.82MB&#x27;  │\n│    8    │   &#x27;Float32Matrix&#x27;    │  &#x27;0.53MB&#x27;  │ &#x27;76.29MB&#x27;  │ &#x27;76.82MB&#x27;  │\n│    9    │   &#x27;Float64Matrix&#x27;    │  &#x27;0.52MB&#x27;  │ &#x27;152.59MB&#x27; │ &#x27;153.11MB&#x27; │\n│   10    │     &#x27;AnyMatrix&#x27;      │ &#x27;153.23MB&#x27; │  &#x27;0.00MB&#x27;  │ &#x27;153.23MB&#x27; │\n│   11    │ &#x27;AnyMatrixUseObject&#x27; │ &#x27;159.15MB&#x27; │  &#x27;0.00MB&#x27;  │ &#x27;159.15MB&#x27; │\n└─────────┴──────────────────────┴────────────┴────────────┴────────────┘\n</code></pre></div>","title":"分享一个 Bit矩阵","last_reply_at":"2019-04-04T05:36:53.527Z","good":false,"top":false,"reply_count":5,"visit_count":472,"create_at":"2019-04-01T10:37:16.736Z","author":{"loginname":"cnwhy","avatar_url":"https://avatars1.githubusercontent.com/u/4178465?v=4&s=120"}},{"id":"5ca5696b6c1de62dce467b5e","author_id":"5ca5676631010b2dfbb430f2","tab":"ask","content":"<div class=\"markdown-text\"><p>想要通过日志或者console.log来记录运行过程中每个模块的引入（require或者import），有什么官方API或者可以通过自己改造的方法来实现吗？</p>\n</div>","title":"请问nodejs如何监控每个模块的引入","last_reply_at":"2019-04-04T05:29:43.607Z","good":false,"top":false,"reply_count":4,"visit_count":524,"create_at":"2019-04-04T02:18:19.640Z","author":{"loginname":"Zrylhh","avatar_url":"https://avatars1.githubusercontent.com/u/22956655?v=4&s=120"}},{"id":"5c92e30b96558e26e1b67efb","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><ul>\n<li>GitHub 仓库：<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection\">Fundebug/loop-mongodb-big-collection</a></li>\n</ul>\n<p><img src=\"https://image.fundebug.com/2019-03-21-mongodb.jpg\" alt></p>\n<p>本文使用的编程语言是 Node.js，连接 MongoDB 的模块用的是<a href=\"https://mongoosejs.com/\">mongoose</a>。但是，本文介绍的方法适用于其他编程语言及其对应的 MongoDB 模块。</p>\n<h3>错误方法：find()</h3>\n<p>也许，在遍历 MongoDB 集合时，我们会这样写：</p>\n<pre class=\"prettyprint language-javascript\"><code>const Promise = require(&quot;bluebird&quot;);\n\nfunction findAllMembers() {\n    return Member.find();\n}\n\nasync function test() {\n    const members = await findAllMembers();\n    let N = 0;\n    await Promise.mapSeries(members, member =&gt; {\n        N++;\n        console.log(&#96;name of the ${N}th member: ${member.name}&#96;);\n    });\n    console.log(&#96;loop all ${N} members success&#96;);\n}\n\ntest();\n</code></pre><p>注意，我们使用的是 Bluebird 的<a href=\"http://bluebirdjs.com/docs/api/promise.mapseries.html\">mapSeries</a>而非<a href=\"http://bluebirdjs.com/docs/api/promise.map.html\">map</a>，members 数组中的元素是一个一个处理的。这样就够了吗？</p>\n<p>当 Member 集合中的 document 不多时，比如只有 1000 个时，那确实没有问题。但是当 Member 集合中有 1000 万个 document 时，会发生什么呢？如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&lt;--- Last few GCs ---&gt;\nrt of marking 1770 ms) (average mu = 0.168, current mu = 0.025) finalize [5887:0x43127d0]    33672 ms: Mark-sweep 1398.3 (1425.2) -&gt; 1398.0 (1425.7) MB, 1772.0 &#x2F; 0.0 ms  (+ 0.1 ms in 12 steps since start of marking, biggest step 0.0 ms, walltime since start of marking 1775 ms) (average mu = 0.088, current mu = 0.002) finalize [5887:0x43127d0]    35172 ms: Mark-sweep 1398.5 (1425.7) -&gt; 1398.4 (1428.7) MB, 1496.7 &#x2F; 0.0 ms  (average mu = 0.049, current mu = 0.002) allocation failure scavenge might not succeed\n\n\n&lt;--- JS stacktrace ---&gt;\n\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\n 1: 0x8c02c0 node::Abort() [node]\n 2: 0x8c030c  [node]\n 3: 0xad15de v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [node]\n 4: 0xad1814 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [node]\n 5: 0xebe752  [node]\n 6: 0xebe858 v8::internal::Heap::CheckIneffectiveMarkCompact(unsigned long, double) [node]\n 7: 0xeca982 v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [node]\n 8: 0xecb2b4 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [node]\n 9: 0xecba8a v8::internal::Heap::FinalizeIncrementalMarkingIfComplete(v8::internal::GarbageCollectionReason) [node]\n10: 0xecf1b7 v8::internal::IncrementalMarkingJob::Task::RunInternal() [node]\n11: 0xbc1796 v8::internal::CancelableTask::Run() [node]\n12: 0x935018 node::PerIsolatePlatformData::FlushForegroundTasksInternal() [node]\n13: 0x9fccff  [node]\n14: 0xa0dbd8  [node]\n15: 0x9fd63b uv_run [node]\n16: 0x8ca6c5 node::Start(v8::Isolate*, node::IsolateData*, int, char const* const*, int, char const* const*) [node]\n17: 0x8c945f node::Start(int, char**) [node]\n18: 0x7f84b6263f45 __libc_start_main [&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6]\n19: 0x885c55  [node]\nAborted (core dumped)\n</code></pre><p>可知，内存不足了。</p>\n<p>打印<a href=\"https://mongoosejs.com/docs/api.html#model_Model.find\">find()</a>返回的 members 数组可知，集合中所有元素都返回了，<strong>哪个数组放得下 1000 万个 Object?</strong></p>\n<h3>正确方法：find().cursor()与 eachAsync()</h3>\n<p>将整个集合 find()全部返回，这种操作应该避免，正确的方法应该是这样的：</p>\n<pre class=\"prettyprint language-javascript\"><code>function findAllMembersCursor() {\n    return Member.find().cursor();\n}\n\nasync function test() {\n    const membersCursor = await findAllMembersCursor();\n    let N = 0;\n    await membersCursor.eachAsync(member =&gt; {\n        N++;\n        console.log(&#96;name of the ${N}th member: ${member.name}&#96;);\n    });\n    console.log(&#96;loop all ${N} members success&#96;);\n}\n\ntest();\n</code></pre><p>使用<a href=\"https://mongoosejs.com/docs/api.html#query_Query-cursor\">cursor()</a>方法返回 QueryCursor，然后再使用<a href=\"https://mongoosejs.com/docs/api.html#querycursor_QueryCursor-eachAsync\">eachAsync()</a>就可以遍历整个集合了，而且不用担心内存不够。</p>\n<p><a href=\"https://mongoosejs.com/docs/api.html#QueryCursor\">QueryCursor</a>是什么呢？不妨看一下 mongoose 文档：</p>\n<blockquote>\n<p>A QueryCursor is a concurrency primitive for processing query results one document at a time. A QueryCursor fulfills the Node.js streams3 API, in addition to several other mechanisms for loading documents from MongoDB one at a time.</p>\n</blockquote>\n<p>总之，QueryCursor 可以每次从 MongoDB 中取一个 document，这样显然极大地减少了内存使用。</p>\n<h3>如何测试？</h3>\n<p>这篇博客介绍的内容很简单，但是也很容易被忽视。如果大家测试一下，印象会更加深刻一些。</p>\n<p>测试代码很简单，大家可以查看<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection\">Fundebug/loop-mongodb-big-collection</a>。</p>\n<p>我的测试环境是这样的：</p>\n<ul>\n<li>ubuntu 14.04</li>\n<li>mongodb 3.2</li>\n<li>nodejs 10.9.0</li>\n</ul>\n<p><strong>1. 使用 Docker 运行 MongoDB</strong></p>\n<pre class=\"prettyprint language-bash\"><code>sudo docker run --net=host -d --name mongodb daocloud.io&#x2F;library&#x2F;mongo:3.2\n</code></pre><p><strong>2. 使用<a href=\"https://github.com/feliixx/mgodatagen\">mgodatagen</a>生成测试数据</strong></p>\n<p>使用 mgodatagen，1000 万个 document 可以在 1 分多钟生成！</p>\n<p>下载 mgodatagen：<a href=\"https://github.com/feliixx/mgodatagen/releases/download/0.7.3/mgodatagen_linux_x86_64.tar.gz\">https://github.com/feliixx/mgodatagen/releases/download/0.7.3/mgodatagen_linux_x86_64.tar.gz</a></p>\n<p>解压之后，复制到/usr/local/bin 目录即可：</p>\n<pre class=\"prettyprint language-bash\"><code>sudo mv mgodatagen &#x2F;usr&#x2F;local&#x2F;bin\n</code></pre><p>mgodatagen 的配置文件<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection/blob/master/mgodatagen-config.json\">mgodatagen-config.json</a>如下：</p>\n<pre class=\"prettyprint language-json\"><code>[\n    {\n        &quot;database&quot;: &quot;test&quot;,\n        &quot;collection&quot;: &quot;members&quot;,\n        &quot;count&quot;: 10000000,\n        &quot;content&quot;: {\n            &quot;name&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            },\n            &quot;city&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            },\n            &quot;country&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            },\n            &quot;company&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            },\n            &quot;email&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            }\n        }\n    }\n]\n</code></pre><p>执行<code>mgodatagen -f mgodatagen-config.json</code>命令，即可生成 10000 万测试数据。</p>\n<pre class=\"prettyprint language-bash\"><code>mgodatagen -f mgodatagen-config.json\nConnecting to mongodb:&#x2F;&#x2F;127.0.0.1:27017\nMongoDB server version 3.2.13\n\ncollection members: done            [====================================================================] 100%\n\n+------------+----------+-----------------+----------------+\n| COLLECTION |  COUNT   | AVG OBJECT SIZE |    INDEXES     |\n+------------+----------+-----------------+----------------+\n| members    | 10000000 |             108 | _id_  95368 kB |\n+------------+----------+-----------------+----------------+\n\nrun finished in 1m12.82s\n</code></pre><p>查看 MongoDB，可知新生成的数据有 0.69GB，其实很小，但是使用 find()方法遍历会报错。</p>\n<pre class=\"prettyprint language-bash\"><code>show dbs\nlocal  0.000GB\ntest   0.690GB\n</code></pre><p><strong>3. 执行测试代码</strong></p>\n<p>两种不同遍历方法的代码分别位于<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection/blob/master/test1.js\">test1.js</a>和<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection/blob/master/test2.js\">test2.js</a>。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://cnodejs.org/topic/51508570604b3d512113f1b3\">如何使用 mongoose 对一个 100 万+的 mongodb 的表进行遍历操作</a></li>\n<li><a href=\"https://thecodebarbarian.com/cursors-in-mongoose-45\">Cursors in Mongoose 4.5</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2019/03/21/how-to-visit-all-documents-in-a-big-collection-of-mongodb/\">https://blog.fundebug.com/2019/03/21/how-to-visit-all-documents-in-a-big-collection-of-mongodb/</a></p>\n</div>","title":"如何高效地遍历 MongoDB 超大集合？","last_reply_at":"2019-04-04T03:59:02.130Z","good":false,"top":false,"reply_count":7,"visit_count":863,"create_at":"2019-03-21T01:04:11.264Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c88cb9cacb681372d417bf9","author_id":"5a7a5d505321b5396004ec1e","tab":"share","content":"<div class=\"markdown-text\"><p>欢迎使用 Nest Cloud\nNest Cloud 是一套以 consul 作为服务注册与发现中心，基于 nest.js 的微服务解决方案。</p>\n<p>由以下几个组件组成：</p>\n<p>​boot - 服务启动的时候读取本地配置文件和环境变量</p>\n<p>​consul - 对 consul api 的一层封装</p>\n<p>​consul-config - 提供以 consul kv 作为配置中心的 client</p>\n<p>​consul-service - 提供服务注册以及服务查找功能</p>\n<p>​consul-loadbalance - 提供本地负载均衡功能</p>\n<p>​feign - 提供基于 decorator 的 http client，并且支持负载均衡，使用更加简单方便</p>\n<p>​schedule - 提供基于 decorator 实现的定时任务库，支持分布式</p>\n<p>围观地址： <a href=\"https://nestcloud.org/solutions/\">https://nestcloud.org/solutions/</a></p>\n</div>","title":"基于 nest.js 的微服务解决方案—— Nest cloud","last_reply_at":"2019-04-04T03:11:27.759Z","good":false,"top":false,"reply_count":13,"visit_count":1503,"create_at":"2019-03-13T09:21:32.430Z","author":{"loginname":"zuohuadong","avatar_url":"https://avatars0.githubusercontent.com/u/11203929?v=4&s=120"}},{"id":"5ca494c76c1de62dce467889","author_id":"5c4589cc3b948a2b4ab701c9","tab":"ask","content":"<div class=\"markdown-text\"><p>我用model查询返回的model太大了，我现在只知道用JSON.stringfy()和JSON.parse()来回转换，请问还有什么方法可以转换吗</p>\n</div>","title":"请问mongoose的model怎么转成json对象","last_reply_at":"2019-04-04T02:41:41.409Z","good":false,"top":false,"reply_count":2,"visit_count":332,"create_at":"2019-04-03T11:11:03.119Z","author":{"loginname":"TJJ123456","avatar_url":"https://avatars1.githubusercontent.com/u/25629797?v=4&s=120"}},{"id":"5ca321436c1de62dce46703c","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h2>1. Dubbo 是啥？</h2>\n<p>Dubbo 是一个由阿里开源的 RPC 框架。</p>\n<p>简单说下RPC框架的背景。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6ly1g1his3o33yj20p40p011i.jpg\" alt=\"From dubbo.apache.org\"></p>\n<p>Dubbo 是一种 RPC 框架，应用在分布式服务。</p>\n<p><img src=\"http://dubbo.apache.org/img/architecture.png\" alt></p>\n<h2>2. 使用 Dubbo 实现 Java 互调</h2>\n<p>​\t首先我们可以先尝试下同语言下的 Dubbo 调用，从容易开始。</p>\n<p>​\t可以参考下 dubbo 官方文档 <a href=\"http://dubbo.apache.org/zh-cn/docs/user/quick-start.html\">http://dubbo.apache.org/zh-cn/docs/user/quick-start.html</a></p>\n<p>​\t这边简单尝试下，主要有两步：</p>\n<ol>\n<li>\n<p>首先建立一个服务提供方， 也就是上图 Provider 的角色；</p>\n</li>\n<li>\n<p>接下来建立一个服务消费者， 也如同上图的 Consumer 的角色；</p>\n</li>\n</ol>\n<h3>服务提供方建立 Provider</h3>\n<p><strong>1.0 使用Spring Boot 建立一个Spring 微服务</strong> (可以参考)<a href=\"http://https://yuchenzhen.github.io/2018/08/24/SpringBoot-IDE-initial/\">https://yuchenzhen.github.io/2018/08/24/SpringBoot-IDE-initial/</a></p>\n<p>**1.1.  建立一个 Interface **</p>\n<pre class=\"prettyprint language-   java\"><code>&#x2F;&#x2F; TestProviderService.java\n\npackage com.dubbo.learn.dubbo;\n\npublic interface TestProviderService {\n    String Hello (String who);\n}\n</code></pre><p><strong>1.2 实现这个TestProviderServiceImpl</strong></p>\n<pre class=\"prettyprint language- java\"><code>&#x2F;&#x2F; TestProviderServiceImpl\npackage com.dubbo.learn.dubbo.impl;\n\nimport com.dubbo.learn.dubbo.TestProviderService;\nimport com.alibaba.dubbo.config.annotation.Service;\n\n@Service(version=&quot;1.0.0&quot;)\npublic class TestProviderServiceImpl implements TestProviderService  {\n    public String Hello(String who) {\n        return &quot;Hello world ! Dear Programer &quot; + who ;\n    }\n}\n\n</code></pre><p><strong>1.3 启动程序主入口添加<code>@EnableDubbo</code>注解</strong></p>\n<pre class=\"prettyprint language- java\"><code>&#x2F;&#x2F; ProviderApplication.java\npackage com.dubbo.learn;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;\n\n@SpringBootApplication\n@EnableDubbo\npublic class ProviderApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ProviderApplication.class, args);\n    }\n\n}\t\n</code></pre><p>​\t为了引入这个<code>@EnableDubbo</code>注解，需要我们引入<code>com.alibaba</code>的包</p>\n<pre class=\"prettyprint language-xml\"><code>&lt;!--pom.xml--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt; \n  &lt;version&gt;0.2.1.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;dubbo&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.6.5&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.11.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n</code></pre><p>​\t<code>curator-framework</code>是dubbo所使用的消息中心<code>Zookeeper</code>所需要的包<br>\n​\t<code>dubbo-spring-boot-starter</code>是 dubbo spring 的配置包</p>\n<p><strong>1.4 最后我们把dubbo 的启动配置写到<code>application.properties</code>里面</strong></p>\n<pre class=\"prettyprint language-properties\"><code># application.properties\nserver.port = 8829\n#\ndubbo.application.name=provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=zookeeper:&#x2F;&#x2F;127.0.0.1:2181\ndubbo.scan.base-packages=com.dubboo.learn\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20880\ndubbo.consumer.check=false\n</code></pre><p>整个项目结构如图：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1ffq5j1mrj20a70jhab5.jpg\" alt></p>\n<p>然后，启动就好。</p>\n<p>启动之后，通过 dubbo Admin 网页客户端可以看见Provider的接口在 Regitry 里面注册成功。<br>\n<img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1ffrs83ubj227m0n8djl.jpg\" alt></p>\n<h3>服务消费者Consumer</h3>\n<p><strong>1.0 使用Spring Boot 建立一个Spring 消费者的微服务</strong></p>\n<p><strong>1.1 定义接口，这里的接口路径位置和包名最好一致 （不然要自己调整）</strong></p>\n<pre class=\"prettyprint language-java\"><code>&#x2F;&#x2F; TestProviderService.java\npackage com.dubbo.learn.dubbo;\npublic interface TestProviderService {\n    String Hello (String who);\n}\n</code></pre><p><strong>1.2 定义一个 Service调用该dubbo 接口</strong></p>\n<pre class=\"prettyprint language-java\"><code>&#x2F;&#x2F; TestConsumerService.java\npackage com.dubbo.learn;\n\nimport com.alibaba.dubbo.config.annotation.Reference;\nimport com.dubbo.learn.dubbo.TestProviderService;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class TestConsumerService {\n    @Reference(version = &quot;1.0.0&quot;)\n    TestProviderService testProviderService;\n\n    public void consumer (String who) {\n        String res = testProviderService.Hello(who);\n        System.out.println(&quot;consumer : provider says &quot; + res);\n    }\n}\n</code></pre><p>在主程序函数调用该Service 的函数</p>\n<pre class=\"prettyprint language-java\"><code>&#x2F;&#x2F; DubboConsumerApplication.java\npackage com.dubbo.learn;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport com.dubbo.learn.TestConsumerService;\n\n@SpringBootApplication\npublic class DubboConsumerApplication {\n\n    public static void main(String[] args) {\n        ConfigurableApplicationContext run = SpringApplication.run(DubboConsumerApplication.class, args);\n        TestConsumerService testConsumer = run.getBean(TestConsumerService.class);\n        testConsumer.consumer(&quot;White&quot;);\n    }\n\n}\n</code></pre><p><code>@Reference</code>这个注解就是用来调用 dubbo 对应的接口的。所以也是要引入跟服务端的那几个包</p>\n<pre class=\"prettyprint language-xml\"><code>&lt;!--pom.xml--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt; \n  &lt;version&gt;0.2.1.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;dubbo&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.6.5&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.11.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;  \n</code></pre><p><strong>1.3 最后我们把dubbo 的启动配置写到application.properties里面</strong></p>\n<pre class=\"prettyprint language- properties\"><code>#application.properties\nserver.port=8830\ndubbo.application.name=consumer\n#注册中心地址\ndubbo.registry.address=zookeeper:&#x2F;&#x2F;127.0.0.1:2181\n\ndubbo.scan.base-packages=com.dubboo.learn.dubbo\ndubbo.protocol.port=20880\n</code></pre><p>项目目录结构如下：\n<img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1fgt0ik3aj20aa0irdgx.jpg\" alt></p>\n<p>启动后效果如下：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1fgfyr094j211l0e60yc.jpg\" alt></p>\n<h2>3. Node.js 如何通过 Dubbo 调用 Java</h2>\n<p>Node 这边通过 dubbo调用 Java 的 provider 的接口，我们尝试调用了几个包：sofa-rpc-node，node-zookeeper-dubbo，和dubbo2.js 。<br>\n其中 sofa-rpc-node 的对使用 egg.js框架的比较友好，node-zookeeper-dubbo 使用起来跟 sofa-rpc-node 差不多；但是有点麻烦的就是这两个包都需要写 proto3的接口定义。<br>\n而 dubbo2.js则比较方便，以下是使用 dubbo2.js 的示列</p>\n<pre class=\"prettyprint language-javascript\"><code>const { Dubbo, java, setting } = require(&#x27;dubbo2.js&#x27;)\nconst interfaceName = &#x27;com.dubbo.learn.dubbo.TestProviderService&#x27;\nconst interfaceVersion = &#x27;1.0.0&#x27;\nconst dubboSetting = setting.match(\n  interfaceName, { version: interfaceVersion }\n)\nconst dubboService = dubbo =&gt; dubbo.proxyService({\n  dubboInterface: interfaceName,\n  version: &#x27;1.0.0&#x27;,\n  methods: {\n    Hello (who) {\n      return [\n        java.String(who)\n      ]\n    }\n  }\n})\nconst service = {dubboService}\n&#x2F;&#x2F; 实例化Dubbo， 入参主要是名称和 dubbo 接口的设置\nconst dubbo = new Dubbo({\n  application: {name: &#x27;dubbo-node-test&#x27;},\n  register: &#x27;127.0.0.1:2181&#x27;,\n  dubboSetting,\n  service\n})\n\nmodule.exports = dubbo\n\n</code></pre><p>代码就是这么简单， 把 Java 服务里面通过 dubbo 提供出来的接口(包括接口名，接口版本信息，接口方法) 注册一下。<br>\n得到Dubbo 实例之后，调用对应的 service就可以使用。<br>\n如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>await dubbo.service.dubboService.Hello(who)\n</code></pre><p>我们简单写了一个接口：</p>\n<pre class=\"prettyprint language-javascript\"><code>const KoaRouter = require(&#x27;koa-router&#x27;)\nconst dubbo = require(&#x27;.&#x2F;dubbo&#x27;)\nconst router = new KoaRouter({prefix: &#x27;&#x2F;api&#x2F;v1&#x27;})\n\nrouter.use(&#x27;&#x2F;&#x27;)\n\nrouter.get(&#x27;&#x2F;testNodeDubbo&#x27;, async (ctx, next) =&gt; {\n  console.info(&#96;[testNodeDubbo]:==:&gt; start&#96;)\n  let {who} = ctx.request.query\n  const res = await dubbo.service.dubboService.Hello(who)\n  ctx.body = res\n})\n\nmodule.exports = router\n\n</code></pre><p>调用结果：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1gidpequnj20zc0fyq45.jpg\" alt><br>\n这样就完成了 node 作为消费者通过 dubbo 去调用 java 的接口了。</p>\n<h2>4. Node.js 通过接口调用 Java 与 通过 Dubbo 调用 Java 的对比</h2>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1hbp8z51mj21fg0kaq7i.jpg\" alt><br>\n这边尝试使用了调用了同样逻辑的 dubbo 和 http 接口， 对比了一下两个实现的返回时间。<br>\n其中红色的是 dubbo 接口， 蓝色的是 http 接口。</p>\n<h4>其他：</h4>\n<p>项目地址：\n<a href=\"https://github.com/yuchenzhen/Java-dubbo-provider\">https://github.com/yuchenzhen/Java-dubbo-provider</a>\n<a href=\"https://github.com/yuchenzhen/Java-dubbo-client\">https://github.com/yuchenzhen/Java-dubbo-client</a>\n<a href=\"https://github.com/yuchenzhen/node-dubbo2-consumer/tree/master\">https://github.com/yuchenzhen/node-dubbo2-consumer/tree/master</a></p>\n</div>","title":"Node.js通过Dubbo2.js调用Java","last_reply_at":"2019-04-03T12:02:23.250Z","good":false,"top":false,"reply_count":1,"visit_count":526,"create_at":"2019-04-02T08:45:55.530Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5c9c87e799e62a362ff40cce","author_id":"5c88bffdacb681372d417bb4","tab":"share","content":"<div class=\"markdown-text\"><p>多多客（doodooke）是一款支持微信、百度、支付宝小程序的第三方SaaS平台。</p>\n<p><strong>重要更新</strong>\n1、开源diy可视化拖拉拽；\n2、开源taro三端合一小程序；</p>\n<p><strong>3.0新特性</strong>\n1、支持migrations，可以快速的创建和修改表；\n2、支持rewrite，可以将请求转发到修改过的接口；\n3、支持view逻辑钩子，可以扩展vue逻辑；\n4、支持view视图钩子，可以扩展vue视图；\n5、支持cluster，可以启动多个项目；\n6、支持本地调试，可以将生产环境的请求转发或复制到本地；\n7、支持bin命令，可以快速的处理migration等；</p>\n<p>开源版下载：<a href=\"https://gitee.com/doodooke/doodoo\">https://gitee.com/doodooke/doodoo</a></p>\n</div>","title":"【全开源】可视化DIY微信/百度/支付宝小程序saas平台源码","last_reply_at":"2019-04-03T10:38:22.539Z","good":false,"top":false,"reply_count":1,"visit_count":597,"create_at":"2019-03-28T08:37:59.067Z","author":{"loginname":"doodooke1688","avatar_url":"https://avatars0.githubusercontent.com/u/48510722?v=4&s=120"}},{"id":"5c9490cb00bcfd7eb2be500a","author_id":"5c88bffdacb681372d417bb4","tab":"share","content":"<div class=\"markdown-text\"><p>多多客（doodooke）是一款支持微信、百度、支付宝小程序的第三方SaaS平台。</p>\n<p><strong>重要更新</strong>\n1、开源diy可视化拖拉拽；\n2、开源taro三端合一小程序；</p>\n<p><strong>3.0 新特性</strong>\n1、支持migrations，可以快速的创建和修改表\n通过命令./bin/migrate.js make [name] --scope [module]创建migration，然后使用./bin/migrate.js latest执行migration，使用./bin/migrate.js rollback回滚migration，具体migration的用法可以参考knex文档 <a href=\"https://knexjs.org\">https://knexjs.org</a></p>\n<p>2、支持rewrite，可以将请求转发到修改过的接口\n二次开发最大的问题就是如何在保证系统一致性和更新的情况下，二次修改代码。比如我们需要修改app模块，然后我们复制app模块，起名apps，然后修改rewrite.js，添加如下数据，即完成了配置。此时我们请求app模块会全部转发到apps模块。提示：一个模块下前端路由不带/api，后端路由以/api开头</p>\n<pre class=\"prettyprint language-js\"><code>module.exports = {\n    &quot;&#x2F;app&quot;: &quot;&#x2F;apps&quot;,\n    &quot;&#x2F;api&#x2F;app&quot;: &quot;&#x2F;api&#x2F;apps&quot;\n}\n</code></pre><p>3、支持view逻辑钩子，可以扩展vue逻辑\n3.0重要的特性之一，可以很方便到扩展vue前端逻辑。通过调用this.$hook.run(“xxx”, 1, 2)自动加载view_hook目录下hook.js名称为xxx的函数，修改data里面的数据等。</p>\n<p>4、支持view视图钩子，可以扩展vue视图\n3.0重要的特性之二，可以很方便的扩展vue前端视图，通过调用&lt;doodoo-hook name=“xxx” abc=“2”&gt;&lt;/doodoo-hook&gt;实现，当系统发现view_hook目录下，名称是xxx.vue会自动加载到调用的位置</p>\n<p>5、支持cluster，可以启动多个项目\n目前仅支持同一个序列号，同一台服务器启动多个实例，如需多台服务器启动，请联系客服</p>\n<p>6、支持本地调试，可以将生产环境的请求转发或复制到本地\n解决生产环境的bug，是一个很头痛的问题，我们除了有错误监控外，新增加了本地调试功能。本地调试功能可以将线上生产环境的请求转发或者复制到本地系统，这样可以快速的发现和修复bug。线上的已全部集成到所有的系统，线下的命令行工具会随后发布。</p>\n<p>7、支持bin命令，可以快速的处理migration等\n目前支持doodoo.sh和migrate.js命令</p>\n<p><a href=\"https://gitee.com/doodooke/doodoo\">3.0开源版</a><a href=\"https://gitee.com/doodooke/doodoo\">https://gitee.com/doodooke/doodoo</a></p>\n</div>","title":"多多客发布 3.0.0-alpha.3开源版，支持微信、百度、支付宝小程序","last_reply_at":"2019-04-03T10:37:34.030Z","good":false,"top":false,"reply_count":1,"visit_count":452,"create_at":"2019-03-22T07:37:47.641Z","author":{"loginname":"doodooke1688","avatar_url":"https://avatars0.githubusercontent.com/u/48510722?v=4&s=120"}},{"id":"5ca1b8206c1de62dce46688d","author_id":"5a3b17649807389a1809f5a5","tab":"ask","content":"<div class=\"markdown-text\"><p>mongo 同步数据到 es上，尽可能的不改现有代码？各位怎么做的？</p>\n</div>","title":"mongo 同步数据到 es上，尽可能的不改现有代码？各位怎么做的？","last_reply_at":"2019-04-03T06:19:42.632Z","good":false,"top":false,"reply_count":1,"visit_count":595,"create_at":"2019-04-01T07:05:04.123Z","author":{"loginname":"Sxy97","avatar_url":"https://avatars3.githubusercontent.com/u/24429847?v=4&s=120"}},{"id":"5c9843bffd41137eb76612fc","author_id":"5b1d495729e6e510415b29b0","tab":"ask","content":"<div class=\"markdown-text\"><p>后台有一个接口，做一分钟内只能被调用一次，多余的请求被忽略。请问有什么模块或者什么方法可以来实现吗</p>\n</div>","title":"express接口做1分钟只能请求一次的限制","last_reply_at":"2019-04-03T05:09:48.888Z","good":false,"top":false,"reply_count":7,"visit_count":1039,"create_at":"2019-03-25T02:58:07.038Z","author":{"loginname":"helloHT","avatar_url":"https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"}},{"id":"5ca42f696c1de62dce46744a","author_id":"5ca42bf931010b2dfbb42a1c","tab":"share","content":"<div class=\"markdown-text\"><p>HTTP Catcher 是一个 iOS 平台上的 http 调试工具，一般我们查看移动设备上的 http 请求需要连接电脑上的代理应用，通过代理应用才能查看请求日志。使用 HTTP Catcher 可以在 iOS 设备上直接查看请求内容，同时支持 https 数据解密。</p>\n<h1>功能</h1>\n<ul>\n<li>实时记录 HTTP 和 WebSocket 请求</li>\n<li>支持解密 HTTPS</li>\n<li>请求过滤</li>\n<li>支持远程代理</li>\n<li>图片预览</li>\n<li>HTML, JavaScript, CSS 格式化预览</li>\n<li>二进制数据查看</li>\n<li>自定义 Hosts</li>\n<li>重放请求</li>\n<li>黑名单</li>\n</ul>\n<p>分享一个比较常用的场景：\n在配合服务端接口调试的时候，会被要求重发请求，有时候需要页面多次跳转才能发送相应的请求，使用重放功能会简化这个工作。</p>\n<p>目前应用还在持续开发中，期待大家使用！</p>\n<p><a href=\"https://itunes.apple.com/us/app/http-catcher/id1445874902?l=zh&amp;ls=1&amp;mt=8\">Link to App Store</a></p>\n<p><a href=\"https://testflight.apple.com/join/4Qt2lIm5\">Link to TestFight</a></p>\n</div>","title":"分享 iOS 平台下的 http 抓包应用 - HTTP Catcher","last_reply_at":"2019-04-03T03:58:33.820Z","good":false,"top":false,"reply_count":0,"visit_count":563,"create_at":"2019-04-03T03:58:33.820Z","author":{"loginname":"imxiaozhi","avatar_url":"https://avatars1.githubusercontent.com/u/7193241?v=4&s=120"}},{"id":"5c9c477d484eeb3634157d7b","author_id":"5c9c474299e62a362ff40b3c","tab":"ask","content":"<div class=\"markdown-text\"><p>nodejs怎么执行远程服务器的bat脚本，求大佬</p>\n</div>","title":"nodejs怎么执行远程服务器的bat脚本","last_reply_at":"2019-04-03T03:11:36.979Z","good":false,"top":false,"reply_count":5,"visit_count":561,"create_at":"2019-03-28T04:03:09.310Z","author":{"loginname":"IAmYuanZhao","avatar_url":"https://avatars2.githubusercontent.com/u/38496544?v=4&s=120"}},{"id":"5ca3724631010b2dfbb427d5","author_id":"56d01c25dec0748461ebb8e6","tab":"share","content":"<div class=\"markdown-text\"><p>WebStorm 有很方便的 Debug 功能，如果是普通 node.js 项目的话，参考 <a href=\"https://www.jetbrains.com/help/webstorm/running-and-debugging-node-js.html\">WebStorm 官方的 Debug 说明</a> 配置即可。</p>\n<p>由于 node.js 7+ 后都使用 <a href=\"https://nodejs.org/en/docs/guides/debugging-getting-started/\">Inspector</a> 来实现 Debug， 因此需要注意最低保证 node.js 版本 &gt;= 7 及 JetBrains WebStorm 版本 &gt;= 2017.1+。</p>\n<p>鉴于 js 项目的多样性，实际项目中，经常会使用 Babel 或者 TypeScript 编译，特别记录下 <a href=\"https://avnpc.com/pages/webstorm-debug-typescript-babel-project\">WebStorm 在使用 TypeScript 或 Babel 时的 Debug 配置</a>以备忘。 下文以 node.js v10 及 WebStorm 2019.1 为例。</p>\n<h2>WebStorm Debug 基于 Babel 的项目</h2>\n<p>虽然 babel 有 <a href=\"https://babeljs.io/docs/en/babel-node\">babel-node</a> 可以直接运行未编译代码，但并不推荐在 Debug 中使用 babel-node 直接替换 node。这是由于 babel-node <a href=\"https://github.com/babel/babel/blob/master/packages/babel-node/src/babel-node.js\">只是一个 node cli 的简单封装</a>，在 babel-node 的一些早期版本中， 并未加入 <code>--inspect-brk</code> 等 Debug 所需参数的支持，可能会引发无法打断点或 Debug 进程无法退出等问题。</p>\n<p>首先确认好 babel 的安装情况</p>\n<p>对于 Babel 7</p>\n<pre class=\"prettyprint language-bash\"><code>npm install --save-dev @babel&#x2F;core @babel&#x2F;cli @babel&#x2F;register\n</code></pre><p>对于 Babel 6</p>\n<pre class=\"prettyprint language-bash\"><code>npm install --save-dev babel-core babel-cli babel-register\n</code></pre><p>推荐的 Debug 配置如下：</p>\n<ol>\n<li>打开 <code>Run/Debug Configuration</code> 窗口</li>\n<li>新建一个配置，类型选择 <code>Node.js</code></li>\n<li><code>Node Interpreter</code> 选择本地安装的 node 路径</li>\n<li><code>Node Parameters</code> 中通过 <code>-r</code> 参数，在 node 启动时额外加载 babel 的运行时， 即\n<ul>\n<li>如果是 Babel 7, 填入 <code>-r @babel/register</code></li>\n<li>如果是 Babel 6， 填入 <code>-r babel-register</code></li>\n</ul>\n</li>\n<li><code>Working Directory</code> 中填入当前项目的根目录</li>\n<li><code>JavaScript file</code> 中填入要 Debug 的 js 文件的相对路径 （相对项目根目录）。如果是类似 Express 之类的 Web 服务，填入服务启动入口文件相对路径</li>\n</ol>\n<p>如下图</p>\n<p><img src=\"https://static.avnpc.com/blog/2019/webstorm_debug_babel.png\" alt=\"WebStorm debug Babel\"></p>\n<h2>WebStorm Debug 基于 TypeScript 的项目</h2>\n<p>和 Babel 类似， TypeScript 的项目也可以用同样的思路进行 Debug</p>\n<pre class=\"prettyprint language-bash\"><code>npm install --save-dev typescript ts-node\n</code></pre><p>配置如下</p>\n<ol>\n<li>打开 <code>Run/Debug Configuration</code> 窗口</li>\n<li>新建一个配置，类型选择 <code>Node.js</code></li>\n<li><code>Node Interpreter</code> 选择本地安装的 node 路径</li>\n<li><code>Node Parameters</code> 填入 <code>-r ts-node/register</code></li>\n<li><code>Working Directory</code> 中填入当前项目的根目录</li>\n<li><code>JavaScript file</code> 中填入要 Debug 的 ts 文件的相对路径</li>\n</ol>\n<p>如图</p>\n<p><img src=\"https://static.avnpc.com/blog/2019/webstorm_debug_typescript.png\" alt=\"WebStorm debug TypeScript\"></p>\n</div>","title":"使用 WebStorm Debug 基于 TypeScript 或 Babel 的 node.js 项目","last_reply_at":"2019-04-02T14:31:34.390Z","good":false,"top":false,"reply_count":0,"visit_count":360,"create_at":"2019-04-02T14:31:34.390Z","author":{"loginname":"AlloVince","avatar_url":"https://avatars3.githubusercontent.com/u/176019?v=4&s=120"}},{"id":"5ca2baa76c1de62dce466bc6","author_id":"5ca2a0806c1de62dce466b43","tab":"share","content":"<div class=\"markdown-text\"><p>看《社交网络》时，扎克伯格用博客直播黑掉隔壁宿舍的照片网站，顿时觉得太酷！当即决定开发一个玩玩。但随着使用的深入，功能逐渐扩展至大部分文字使用场景，比如我用它记录要看的书籍，美剧，电影，记录技术要点，记录网址，写购物清单，写工作列表，写博客等。我甚至用它与几个笔友聊天。\n优点是：对文档进行分类管理；打开就可以开始记录，无需登录\n缺点是：不适合贴代码；界面还不够美观</p>\n<p><a href=\"http://talkooo.com\">网站: talkooo.com</a></p>\n<p>我一个人玩太无聊了，希望能多几个人来玩玩！随手记可能对部分人有用，因为我每天都要使用到它。下面是我的使用截图:</p>\n<p><img src=\"//static.cnodejs.org/FsOhB8-btlOAgNa3XnO2sJXNLHE2\" alt=\"IMG_1009.PNG\"></p>\n<p><img src=\"//static.cnodejs.org/FhBipZmao8I2o-yglUXspesk-d5u\" alt=\"IMG_1012.PNG\"></p>\n<p><img src=\"//static.cnodejs.org/FoAEPLBf4-tmFY1rr7R4n9qzUWxu\" alt=\"IMG_1011.PNG\"></p>\n</div>","title":"用Node.js写了一个随手记的web应用","last_reply_at":"2019-04-02T10:23:50.860Z","good":false,"top":false,"reply_count":2,"visit_count":609,"create_at":"2019-04-02T01:28:07.024Z","author":{"loginname":"talkooo","avatar_url":"https://avatars2.githubusercontent.com/u/47216906?v=4&s=120"}},{"id":"5b63b25e792f59ae501bf71c","author_id":"59c12213e7d9a031127ead16","tab":"share","content":"<div class=\"markdown-text\"><h4>RPC是什么</h4>\n<p>在很久之前的单机时代，一台电脑中跑着多个进程，进程之间没有交流各干各的，就这样过了很多年。突然有一天有了新需求，A进程需要实现一个画图的功能，恰好邻居B进程已经有了这个功能，偷懒的程序员C想出了一个办法：A进程调B进程的画图功能。于是出现了<code>IPC</code>（Inter-process communication，进程间通信）。就这样程序员C愉快的去吃早餐去了！</p>\n<p>又过了几年，到了互联网时代，每个电脑都实现了互联互通。这时候雇主又有了新需求，当时还没挂的A进程需要实现使用<code>tensorflow</code>识别出笑脸 &gt;_&lt; 。说巧不巧，远在几千里的一台快速运行的电脑上已经实现了这个功能，睡眼惺忪的程序媛D接手了这个A进程后借鉴之前<code>IPC</code>的实现，把<code>IPC</code>扩展到了互联网上，这就是<code>RPC</code>(Remote Procedure Call，远程过程调用)。<code>RPC</code>其实就是一台电脑上的进程调用另外一台电脑上的进程的工具。成熟的<code>RPC</code>方案大多数会具备服务注册、服务发现、熔断降级和限流等机制。目前市面上的RPC已经有很多成熟的了，比如<code>Facebook</code>家的<code>Thrift</code>、<code>Google</code>家的<code>gRPC</code>、阿里家的<code>Dubbo</code>和蚂蚁家的<code>SOFA</code>。</p>\n<h4>接口定义语言</h4>\n<p>接口定义语言，简称<code>IDL,</code>是实现端对端之间可靠通讯的一套编码方案。这里有涉及到传输数据的序列化和反序列化，我们常用的http的请求一般用json当做序列化工具，定制<code>rpc</code>协议的时候因为要求响应迅速等特点，所以大多数会定义一套序列化协议。比如：</p>\n<p><code>Protobuf</code>：</p>\n<pre class=\"prettyprint language- protobuf\"><code>&#x2F;&#x2F; protobuf 版本\nsyntax = &quot;proto3&quot;;\n \npackage testPackage;\n \nservice testService {\n  &#x2F;&#x2F; 定义一个ping方法，请求参数集合pingRequest, 响应参数集合pingReply \n  rpc ping (pingRequest) returns (pingReply) {}\n}\n \nmessage pingRequest {\n  &#x2F;&#x2F; string 是类型，param是参数名，1是指参数在方法的第1个位置\n  string param = 1;\n}\n \nmessage pingReply {\n  string message = 1;\n  string content = 2;\n}\n</code></pre><p>讲到<code>Protobuf</code>就得讲到该库作者的另一个作品<code>Cap'n proto</code>了，号称性能是直接秒杀<code>Google Protobuf</code>，直接上官方对比：</p>\n<p><img src=\"https://capnproto.org/images/infinity-times-faster.png\" alt=\"Cap'n proto\"></p>\n<p>虽然知道很多比<code>Protobuf</code>更快的编码方案，但是快到这种地步也是厉害了，为啥这么快，Cap’n Proto的文档里面就立刻说明了，因为<code>Cap'n Proto</code>没有任何序列号和反序列化步骤，<code>Cap'n Proto</code>编码的数据格式跟在内存里面的布局是一致的，所以可以直接将编码好的structure直接字节存放到硬盘上面。贴个栗子：</p>\n<pre class=\"prettyprint language- shell\"><code>@0xdbb9ad1f14bf0b36;  # unique file ID, generated by &#96;capnp id&#96;\n\nstruct Person {\n  name @0 :Text;\n  birthdate @3 :Date;\n\n  email @1 :Text;\n  phones @2 :List(PhoneNumber);\n\n  struct PhoneNumber {\n    number @0 :Text;\n    type @1 :Type;\n\n    enum Type {\n      mobile @0;\n      home @1;\n      work @2;\n    }\n  }\n}\n\nstruct Date {\n  year @0 :Int16;\n  month @1 :UInt8;\n  day @2 :UInt8;\n}\n</code></pre><p>我们这里要定制的编码方案就是基于<code>protobuf</code>和<code>Cap'n Proto</code>结合的类似的语法。因为本人比较喜欢刀剑神域里的男主角，所以就给这个库起了个名字    —— <code>Kiritobuf</code>。</p>\n<p>首先我们定义<code>kirito</code>的语法：</p>\n<pre class=\"prettyprint language-bash\"><code># test\n\nservice testService {\n  method ping (reqMsg, resMsg)\n}\n\nstruct reqMsg {\n  @0 age = Int16;\n  @1 name = Text;\n}\n\nstruct resMsg {\n  @0 age = Int16;\n  @1 name = Text;\n}\n</code></pre><ul>\n<li><code>#</code> 开头的是注释</li>\n<li>保留关键字, <code>service</code>、<code>method</code>、<code>struct</code>,</li>\n<li><code>{}</code>里是一个块结构</li>\n<li><code>()</code>里有两个参数，第一个是请求的参数结构，第二个是返回值的结构</li>\n<li><code>@</code>是定义参数位置的描述符，<code>0</code>表示在首位</li>\n<li><code>=</code>号左边是参数名，右边是参数类型</li>\n</ul>\n<p>参数类型：</p>\n<ul>\n<li><strong>Boolean:</strong> <code>Bool</code></li>\n<li><strong>Integers:</strong> <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code></li>\n<li><strong>Unsigned integers:</strong> <code>UInt8</code>, <code>UInt16</code>, <code>UInt32</code>, <code>UInt64</code></li>\n<li><strong>Floating-point:</strong> <code>Float32</code>, <code>Float64</code></li>\n<li><strong>Blobs:</strong> <code>Text</code>, <code>Data</code></li>\n<li><strong>Lists:</strong> <code>List(T)</code></li>\n</ul>\n<p>定义好了语法和参数类型，我们先过一下生成有抽象关系代码的流程：</p>\n<p><img src=\"https://raw.githubusercontent.com/rickyes/rickyes.github.io/master/image/kirito.jpg\" alt=\"ast\"></p>\n<p>取到<code>.kirito</code>后缀的文件，读取全部字符，通过词法分析器生成<code>token</code>，得到的<code>token</code>传入语法分析器生成<code>AST (抽象语法树)</code>。</p>\n<p>首先我们新建一个<code>kirito.js</code>文件:</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;use strict&#x27;;\n\nconst fs = require(&#x27;fs&#x27;);\nconst tokenizer = Symbol.for(&#x27;kirito#tokenizer&#x27;);\nconst parser = Symbol.for(&#x27;kirito#parser&#x27;);\nconst transformer = Symbol.for(&#x27;kirito#transformer&#x27;);\n&#x2F;&#x2F; 定义词法分析Token类型 \nconst TYPE = {\n  &#x2F;&#x2F; 保留字，service、struct、method...\n  KEYWORD: &#x27;keyword&#x27;,\n  &#x2F;&#x2F; 变量\n  VARIABLE: &#x27;variable&#x27;,\n  &#x2F;&#x2F; 符号，{ } ( ) ; # @ ,\n  SYMBOL: &#x27;symbol&#x27;,\n  &#x2F;&#x2F; 参数位置，数值表示0、1、2、3...\n  INDEX: &#x27;index&#x27;\n};\n&#x2F;&#x2F; 定义语法分析字段类型\nconst EXP = {\n  &#x2F;&#x2F; 变量\n  VARIABLE: &#x27;Identifier&#x27;,\n  &#x2F;&#x2F; 结构申明，service、struct、method\n  STRUCT_DECLARATIONL: &#x27;StructDeclaration&#x27;,\n  &#x2F;&#x2F; 变量申明，@\n  VAR_DECLARATION: &#x27;VariableDeclaration&#x27;,\n  &#x2F;&#x2F; 数据类型, Int16、UInt16、Bool、Text...\n  TYPE: &#x27;DataType&#x27;,\n};\n</code></pre><p>定义好了一些必要的字面量，接下来首先是词法分析阶段。</p>\n<h5>词法解析</h5>\n<p>我们设计词法分析得到的<code>Token</code>是这样子的：</p>\n<pre class=\"prettyprint language-shell\"><code>[ { type: &#x27;keyword&#x27;, value: &#x27;service&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;testService&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;{&#x27; },\n  { type: &#x27;keyword&#x27;, value: &#x27;method&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;ping&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;(&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;reqMsg&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;resMsg&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;)&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;}&#x27; },\n  { type: &#x27;keyword&#x27;, value: &#x27;struct&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;reqMsg&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;{&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;1&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;age&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Int16&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;2&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;name&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Text&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;}&#x27; },\n  { type: &#x27;keyword&#x27;, value: &#x27;struct&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;resMsg&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;{&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;1&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;age&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Int16&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;2&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;name&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Text&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;}&#x27; } ]\n</code></pre><p>词法分析步骤：</p>\n<ul>\n<li>把获取到的<code>kirito</code>代码串按照<code>\\n</code>分割组合成数组A，数组的每个元素就是一行代码</li>\n<li>遍历数组A，将每行代码逐个字符去读取</li>\n<li>在读取的过程中定义匹配规则，比如注释、保留字、变量、符号、数组等</li>\n<li>将每个匹配的字符或字符串按照对应类型添加到tokens数组中</li>\n</ul>\n<p>代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>[tokenizer] (input) {\n    &#x2F;&#x2F; 保留关键字\n    const KEYWORD = [&#x27;service&#x27;, &#x27;struct&#x27;, &#x27;method&#x27;];\n    &#x2F;&#x2F; 符号\n    const SYMBOL = [&#x27;{&#x27;, &#x27;}&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;=&#x27;, &#x27;@&#x27;, &#x27;;&#x27;];\n    &#x2F;&#x2F; 匹配所有空字符\n    const WHITESPACE = &#x2F;\\s&#x2F;;\n    &#x2F;&#x2F; 匹配所有a-z的字符、不限大小写\n    const LETTERS = &#x2F;^[a-z]$&#x2F;i;\n    &#x2F;&#x2F; 匹配数值\n    const NUMBER = &#x2F;\\d&#x2F;;\n    \n    &#x2F;&#x2F; 以换行符分割成数组\n    const source = input.split(&#x27;\\n&#x27;);\n    &#x2F;&#x2F; 最终生成的token数组\n    const tokens = [];\n    source.some(line =&gt; {\n      &#x2F;&#x2F; 声明一个 &#96;current&#96; 变量作为指针\n      let current = 0;\n      &#x2F;&#x2F; 是否继续当前循环、移动到下一行，用于忽略注释\n      let isContinue = false;\n      while (current &lt; line.length) {\n        let char = line[current];\n\n        &#x2F;&#x2F; 匹配任何空字符\n        if (WHITESPACE.test(char)) {\n          current++;\n          continue;\n        }\n\n        &#x2F;&#x2F; 忽略注释\n        if (char === &#x27;#&#x27;) {\n          isContinue = true;\n          break;\n        }\n\n        &#x2F;&#x2F; 匹配a-z|A-Z的字符\n        if (LETTERS.test(char)) {\n          &#x2F;&#x2F; 定义一个字符串变量，用来存储连续匹配成功的字符\n          let value = &#x27;&#x27;;\n          &#x2F;&#x2F; 匹配字符(变量&#x2F;保留字)、字符加数字(参数类型)\n          while (LETTERS.test(char) || NUMBER.test(char)) {\n            &#x2F;&#x2F; 追加字符\n            value += char;\n            &#x2F;&#x2F; 移动指针\n            char = line[++current];\n          }\n          if (KEYWORD.indexOf(value) !== -1) {\n            &#x2F;&#x2F; 匹配保留关键字\n            tokens.push({\n              type: TYPE.KEYWORD,\n              value: value\n            });\n          } else {\n            &#x2F;&#x2F; 匹配变量名、类型\n            tokens.push({\n              type: TYPE.VARIABLE,\n              value: value\n            });\n          }\n          continue;\n        }\n\n        &#x2F;&#x2F; 匹配符号 { } ( ) = @\n        if (SYMBOL.indexOf(char) !== -1) {\n          tokens.push({\n            type: TYPE.SYMBOL,\n            value: char\n          });\n          &#x2F;&#x2F; 匹配@ 参数位置符号\n          if (char === &#x27;@&#x27;) {\n            char = line[++current];\n            &#x2F;&#x2F; 匹配参数位置0-9\n            if (NUMBER.test(char)) {\n              &#x2F;&#x2F; 定义参数位置字符串，用来存储连续匹配成功的参数位置\n              let index = &#x27;&#x27;;\n              &#x2F;&#x2F; 匹配参数位置0-9\n              while (NUMBER.test(char)) {\n                &#x2F;&#x2F; 追加参数位置 &#96;1&#96;+&#96;2&#96;=&#96;12&#96;\n                index += char;\n                char = line[++current];\n              }\n              tokens.push({\n                type: TYPE.INDEX,\n                value: index\n              });\n            }\n            continue;\n          }\n          current++;\n          continue;\n        }\n        current++;\n      }\n        \n      &#x2F;&#x2F; 跳过注释\n      if (isContinue) return false;\n    });\n    return tokens;\n  }\n</code></pre><h5>语法分析</h5>\n<p>得到上面的词法分析的token后，我们就可以对该token做语法分析，我们需要最终生成的AST的格式如下：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;type&quot;: &quot;Program&quot;,\n  &quot;body&quot;: [\n    {\n      &quot;type&quot;: &quot;StructDeclaration&quot;,\n      &quot;name&quot;: &quot;service&quot;,\n      &quot;value&quot;: &quot;testService&quot;,\n      &quot;params&quot;: [\n        {\n          &quot;type&quot;: &quot;StructDeclaration&quot;,\n          &quot;name&quot;: &quot;method&quot;,\n          &quot;value&quot;: &quot;ping&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;reqMsg&quot;\n            },\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;resMsg&quot;\n            }\n          ]\n        }\n      ]\n    },\n    {\n      &quot;type&quot;: &quot;StructDeclaration&quot;,\n      &quot;name&quot;: &quot;struct&quot;,\n      &quot;value&quot;: &quot;reqMsg&quot;,\n      &quot;params&quot;: [\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;1&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;age&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Int16&quot;\n            }\n          ]\n        },\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;2&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;name&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Text&quot;\n            }\n          ]\n        }\n      ]\n    },\n    {\n      &quot;type&quot;: &quot;StructDeclaration&quot;,\n      &quot;name&quot;: &quot;struct&quot;,\n      &quot;value&quot;: &quot;resMsg&quot;,\n      &quot;params&quot;: [\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;1&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;age&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Int16&quot;\n            }\n          ]\n        },\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;2&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;name&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Text&quot;\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n</code></pre><p>看上图我们能友好的得到结构、参数、数据类型、函数之间的依赖和关系，步骤：</p>\n<ul>\n<li>遍历词法分析得到的token数组，通过调用分析函数提取token之间的依赖节点</li>\n<li>分析函数内部定义token提取规则，比如：\n<ol>\n<li>服务保留字  服务名  { 函数保留字 函数名 ( 入参，返回参数 ) }</li>\n<li>参数结构保留字 结构名 { 参数位置 参数名 参数数据类型 }</li>\n</ol>\n</li>\n<li>递归调用分析函数提取对应节点依赖关系，将节点添加到AST中</li>\n</ul>\n<p>代码如下：</p>\n<pre class=\"prettyprint language-js\"><code>[parser] (tokens) {\n    &#x2F;&#x2F; 声明ast对象，作为分析过程中的节点存储器\n    const ast = {\n      type: &#x27;Program&#x27;,\n      body: []\n    };\n    &#x2F;&#x2F; 定义token数组指针变量\n    let current = 0;\n    \n    &#x2F;&#x2F; 定义函数、用例递归分析节点之间的依赖和存储\n    function walk() {\n      &#x2F;&#x2F; 当前指针位置的token节点\n      let token = tokens[current];\n\n      &#x2F;&#x2F; 检查变量、数据类型\n      if (token.type === TYPE.VARIABLE) {\n        current++;\n        return {\n          type: EXP.VARIABLE,\n          struct: tokens[current].value === &#x27;=&#x27; ? false : true,\n          value: token.value\n        };\n      }\n\n      &#x2F;&#x2F; 检查符号\n      if (token.type === TYPE.SYMBOL) {\n        &#x2F;&#x2F; 检查@，添加参数位置绑定\n        if (token.value === &#x27;@&#x27;) {\n          &#x2F;&#x2F; 移动到下一个token, 通常是个数值，也就是参数位置\n          token = tokens[++current];\n          &#x2F;&#x2F; 定义参数节点，用来存储位置、变量名、数据类型\n          let node = {\n            type: EXP.VAR_DECLARATION,\n            name: &#x27;@&#x27;,\n            value: token.value,\n            params: []\n          };\n            \n          &#x2F;&#x2F; 移动到下一个token, 准备开始读取参数变量名和数据类型\n          token = tokens[++current];\n          &#x2F;&#x2F; 每个参数节点以;符号结束\n          &#x2F;&#x2F; 这个循环中会匹配参数变量名和参数数据类型并把他们添加到当前的参数节点上\n          while (token.value !== &#x27;;&#x27;) {\n            &#x2F;&#x2F; 递归匹配参数变量名、数据类型\n            node.params.push(walk());\n            &#x2F;&#x2F; 指定当前指针的token\n            token = tokens[current];\n          }\n          &#x2F;&#x2F; 移动token数组指针\n          current++;\n          &#x2F;&#x2F; 返回参数节点\n          return node;\n        }\n\n        &#x2F;&#x2F; 检查=，匹配该符号右边的参数数据类型\n        if (token.value === &#x27;=&#x27;) {\n          &#x2F;&#x2F; 移动到下一个token\n          token = tokens[++current];\n          current++;\n          return {\n            type: EXP.TYPE,\n            value: token.value\n          };\n        }\n\n        current++;\n      }\n\n      &#x2F;&#x2F; 检查保留字\n      if (token.type === TYPE.KEYWORD) {\n        &#x2F;&#x2F; 检查service、struct\n        if ([&#x27;struct&#x27;, &#x27;service&#x27;].indexOf(token.value) !== -1) {\n          &#x2F;&#x2F; 缓存保留字\n          let keywordName = token.value;\n          &#x2F;&#x2F; 移动到下一个token，通常是结构名\n          token = tokens[++current];\n          &#x2F;&#x2F; 定义结构节点，用来储存结构保留字、结构名、结构参数数组\n          let node = {\n            type: EXP.STRUCT_DECLARATIONL,\n            &#x2F;&#x2F; 保留字\n            name: keywordName,\n            &#x2F;&#x2F; 结构名\n            value: token.value,\n            &#x2F;&#x2F; 参数数组\n            params: []\n          };\n\n          &#x2F;&#x2F; 移动到下一个token\n          token = tokens[++current];\n          &#x2F;&#x2F; 匹配符号且是{,准备解析{里的参数\n          if (token.type === TYPE.SYMBOL &amp;&amp; token.value === &#x27;{&#x27;) {\n            &#x2F;&#x2F; 移动到下一个token\n            token = tokens[++current];\n            &#x2F;&#x2F; 等于}是退出参数匹配，完成参数储存\n            while (token.value !== &#x27;}&#x27;) {\n              &#x2F;&#x2F; 递归调用分析函数，获取参数数组\n              node.params.push(walk());\n              &#x2F;&#x2F; 移动token到当前指针\n              token = tokens[current];\n            }\n            current++;\n          }\n          &#x2F;&#x2F; 返回结构节点\n          return node;\n        }\n\n        if (token.value === &#x27;method&#x27;) {\n          &#x2F;&#x2F; 检查method，匹配请求函数名\n          token = tokens[++current];\n          &#x2F;&#x2F; 定义请求函数节点，用来储存函数入参和返回参数\n          let node = {\n            type: EXP.STRUCT_DECLARATIONL,\n            name: &#x27;method&#x27;,\n            value: token.value,\n            params: []\n          };\n            \n          &#x2F;&#x2F; 移动到下一个token\n          token = tokens[++current];\n          &#x2F;&#x2F; 匹配(符号,准备储存入参和返回参数\n          if (token.type === TYPE.SYMBOL &amp;&amp; token.value === &#x27;(&#x27;) {\n            &#x2F;&#x2F; 移动到入参token\n            token = tokens[++current];\n            &#x2F;&#x2F; 等于)时退出匹配，完成函数匹配\n            while (token.value !== &#x27;)&#x27;) {\n              &#x2F;&#x2F; 递归调用分析函数\n              node.params.push(walk());\n              token = tokens[current];\n            }\n            current++;\n          }\n          &#x2F;&#x2F; 返回函数节点\n          return node;\n\n        }\n      }\n      \n      &#x2F;&#x2F; 抛出未匹配到的错误\n      throw new TypeError(token.type);\n    }\n\n    &#x2F;&#x2F; 遍历token数组\n    while (current &lt; tokens.length) {\n      ast.body.push(walk());\n    }\n    \n    &#x2F;&#x2F; 返回ast\n    return ast;\n  }\n</code></pre><h5>转换器</h5>\n<p>得到了语法分析的<code>AST</code>后我们需要进一步对<code>AST</code>转换为更易操作的<code>js对象</code>。格式如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>{ \n    testService: { \n        ping: {\n            [Function]\n            param: { \n                reqMsg: { \n                    age: &#x27;Int16&#x27;, \n                    name: &#x27;Text&#x27; \n                },\n                resMsg: { \n                    age: &#x27;Int16&#x27;, \n                    name: &#x27;Text&#x27; \n                } \n            }\n        } \n    } \n}\n</code></pre><p>通过上面这个格式，我们可以更容易的知道有几个<code>service</code>、<code>service</code>里有多少个函数以及函数的参数。</p>\n<p>代码如下：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 转换器\n  [transformer] (ast) {\n    &#x2F;&#x2F; 定义汇总的service\n    const services = {};\n    &#x2F;&#x2F; 定义汇总的struct，用来储存参数结构，以便最后和service合并\n    const structs = {};\n\n    &#x2F;&#x2F; 转换数组\n    function traverseArray(array, parent) {\n      &#x2F;&#x2F; 遍历数组\n      array.some((child) =&gt; {\n        &#x2F;&#x2F; 分治转换单个节点\n        traverseNode(child, parent);\n      });\n    }\n\n    function traverseNode (node, parent) {\n\n      switch (node.type) {\n      case &#x27;Program&#x27;:\n        &#x2F;&#x2F; 根节点\n        traverseArray(node.body, parent);\n        break;\n      case &#x27;StructDeclaration&#x27;:\n        &#x2F;&#x2F; 匹配service、struct、method类型节点\n        if (node.name === &#x27;service&#x27;) {\n          &#x2F;&#x2F; 定义service的父节点为对象，为了更好的添加属性\n          parent[node.value] = {};\n          &#x2F;&#x2F; 调用数组转换函数解析，并把父节点传入以便添加子节点\n          traverseArray(node.params, parent[node.value]);\n        } else if (node.name === &#x27;method&#x27;) {\n          &#x2F;&#x2F; 定义一个空函数给method节点\n          parent[node.value] = function () {};\n          &#x2F;&#x2F; 在该函数下挂载一个param属性作为函数的参数列表\n          parent[node.value].param = {};\n          traverseArray(node.params, parent[node.value].param);\n        } else if (node.name === &#x27;struct&#x27;) {\n          &#x2F;&#x2F; 定义struct的父节点为一个对象\n          structs[node.value] = {};\n          &#x2F;&#x2F; 解析struct\n          traverseArray(node.params, structs[node.value]);\n        }\n        break;\n      case &#x27;Identifier&#x27;:\n        &#x2F;&#x2F; 定义参数变量\n        parent[node.value] = {};\n        break;\n      case &#x27;VariableDeclaration&#x27;:\n        &#x2F;&#x2F; 解析参数数组\n        traverseArray(node.params, parent);\n        break;\n      case &#x27;DataType&#x27;:\n        &#x2F;&#x2F; 参数数据类型\n        parent[Object.keys(parent).pop()] = node.value;\n        break;\n      default:\n        &#x2F;&#x2F; 抛出未匹配到的错误\n        throw new TypeError(node.type);\n      }\n    }\n\n    traverseNode(ast, services);\n      \n    &#x2F;&#x2F; 合并service和struct\n    const serviceKeys = Object.getOwnPropertyNames(services);\n    serviceKeys.some(service =&gt; {\n      const methodKeys = Object.getOwnPropertyNames(services[service]);\n      methodKeys.some(method =&gt; {\n        Object.keys(services[service][method].param).some(p =&gt; {\n          if (structs[p] !== null) {\n            services[service][method].param[p] = structs[p];\n            delete structs[p];\n          }\n        });\n      });\n    });\n\n    return services;\n  }\n</code></pre><h4>传输协议</h4>\n<p><code>RPC</code>协议有多种，可以是<code>json、xml、http2</code>，相对于http1.x这种文本协议，http2.0这种二进制协议更适合作为<code>RPC</code>的应用层通信协议。很多成熟的<code>RPC</code>框架一般都会定制自己的协议已满足各种变化莫测的需求。</p>\n<p>比如<code>Thrift</code>的<code>TBinaryProtocol</code>、<code>TCompactProtocol</code>等，用户可以自主选择适合自己的传输协议。</p>\n<p>大多数计算机都是以字节编址的（除了按字节编址还有按字编址和按位编址），我们这里只讨论字节编址。每个机器因为不同的系统或者不同的CPU对内存地址的编码有不一样的规则，一般分为两种字节序：大端序和小端序。</p>\n<blockquote>\n<p>大端序: 数据的高字节保存在低地址</p>\n</blockquote>\n<blockquote>\n<p>小端序: 数据的低字节保存在高地址</p>\n</blockquote>\n<p>举个栗子：</p>\n<p>比如一个整数：<code>258</code>，用16进制表示为<code>0x0102</code>，我们把它分为两个字节<code>0x01</code>和<code>ox02</code>，对应的二进制为<code>0000 0001</code>和<code>0000 0010</code>。在大端序的电脑上存放形式如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/rickyes/rickyes.github.io/master/image/big.jpg\" alt=\"big\"></p>\n<p>小端序则相反。为了保证在不同机器之间传输的数据是一样的，开发一个通讯协议时会首先约定好使用一种作为通讯方案。<code>java虚拟机</code>采用的是大端序。在机器上我们称为<code>主机字节序</code>，网络传输时我们称为<code>网络字节序</code>。网络字节序是<code>TCP/IP</code>中规定好的一种数据表示格式，它与具体的<code>CPU</code>类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节序采用大端排序方式。</p>\n<p>我们这里就不造新应用层协议的轮子了，我们直接使用<code>MQTT</code>协议作为我们的默认应用层协议。<code>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议）</code>，是一种基于<code>发布/订阅</code>（<code>publish/subscribe</code>）模式的“轻量级”通讯协议，采用大端序的网络字节序传输，该协议构建于<code>TCP/IP</code>协议上。</p>\n<h4>实现通讯</h4>\n<p>先贴下实现完的代码调用流程，首先是server端：</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst pRPC = require(&#x27;..&#x27;);\nconst path = require(&#x27;path&#x27;);\nconst kiritoProto = &#x27;.&#x2F;protocol&#x2F;test.kirito&#x27;;\nconst server = new pRPC.Server();\n&#x2F;&#x2F; 解析kirito文件生成js对象\nconst proto = pRPC.load(path.join(__dirname, kiritoProto));\n\n&#x2F;&#x2F; 定义client端可以调用的函数\nfunction test(call, cb) {\n  cb(null, {age: call.age, name: call.name});\n}\n\n&#x2F;&#x2F; 加载kirito解析出来的对象和函数绑定，这里声明了ping的执行函数test\nserver.addKiritoService(proto.testService, {ping: test});\n\nserver.listen(10003);\n</code></pre><p>client端：</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst pRPC = require(&#x27;..&#x27;);\nconst path = require(&#x27;path&#x27;);\nconst kiritoProto = &#x27;.&#x2F;protocol&#x2F;test.kirito&#x27;;\n&#x2F;&#x2F; 解析kirito文件生成js对象\nconst proto = pRPC.load(path.join(__dirname, kiritoProto));\n&#x2F;&#x2F; 分配一个client实例绑定kirito解析的对象并连接server\nconst client =  new pRPC.Client({host: &#x27;localhost&#x27;, port: 10003}, proto.testService);\n\n&#x2F;&#x2F; 调用server端的函数\nclient.ping({age: 23, name: &#x27;ricky 泽阳&#x27;}, function (err, result) {\n  if (err) {\n    throw new Error(err.message);\n  }\n  console.log(result);\n});\n</code></pre><p>无论是server端定义函数或者client端调用函数都是比较简洁的步骤。接下来我们慢慢剖析具体的逻辑实现。</p>\n<p>贴下具体的调用流程架构图：</p>\n<p><img src=\"https://raw.githubusercontent.com/rickyes/rickyes.github.io/master/image/mqt_rpc.jpg\" alt=\"rpc\"></p>\n<p>调用流程总结：</p>\n<ul>\n<li>client端解析kirito文件，绑定kirito的service到client对象</li>\n<li>server端解析kirito文件，将kiritod的service与调用函数绑定添加到server对象</li>\n<li>client端调用kirito service 里定义的函数，注册回调事件，发起MQTT请求</li>\n<li>server端接收MQTT请求，解析请求body，调用对应的函数执行完后向client端发起MQTT请求</li>\n<li>client端接收到MQTT请求后，解析body和error，并从回调事件队列里取出对应的回调函数并赋值执行</li>\n</ul>\n<p>说完了调用流程，现在开始讲解具体的实现。</p>\n<blockquote>\n<p><strong>server</strong>：</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol&#x2F;mqtt.js\n\n&#x27;use strict&#x27;;\n\nconst net = require(&#x27;net&#x27;);\nconst debug = require(&#x27;debug&#x27;)(&#x27;polix-rpc:mqtt&#x27;);\nconst EventEmitter = require(&#x27;events&#x27;).EventEmitter;\nconst mqttCon = require(&#x27;mqtt-connection&#x27;);\n\n&#x2F;&#x2F; 定义server类，继承EventEmitter是为了更好的将模块解耦\nclass MQTT extends EventEmitter {\n\n  constructor () {\n    super();\n    &#x2F;&#x2F; 是否已经开启服务\n    this.inited = false;\n    &#x2F;&#x2F; 函数集合\n    this.events = {};\n  }\n\n  &#x2F;&#x2F; 监听端口并开启服务\n  listen (port, cb) {\n    &#x2F;&#x2F; 已经初始化了就不用再次init\n    if (this.inited) {\n      cb &amp;&amp; cb(new Error(&#x27;already inited.&#x27;, null));\n      return;\n    }\n    &#x2F;&#x2F; 赋值当前作用域上下文的指针给self对象，用来在非当前作用的函数执行当前作用域的代码\n    const self = this;\n    &#x2F;&#x2F; 设置初始化\n    this.inited = true;\n    &#x2F;&#x2F; 实例化一个net服务\n    this.server = new net.Server();\n    this.port = port || 10003;\n    &#x2F;&#x2F; 监听端口\n    this.server.listen(this.port);\n    debug(&#x27;MQTT Server is started for port: %d&#x27;, this.port);\n      \n    &#x2F;&#x2F; 监听error事件\n    this.server.on(&#x27;error&#x27;, (err) =&gt; {\n      debug(&#x27;rpc server is error: %j&#x27;, err.stack);\n      self.emit(&#x27;error&#x27;, err);\n    });\n      \n    &#x2F;&#x2F; 监听连接事件\n    this.server.on(&#x27;connection&#x27;, (stream) =&gt; {\n      &#x2F;&#x2F; 实例化mqtt对象\n      const socket = mqttCon(stream);\n      debug(&#x27;=========== new connection ===========&#x27;);\n      \n      &#x2F;&#x2F; 监听mqtt服务connect事件\n      socket.on(&#x27;connect&#x27;, () =&gt; {\n        debug(&#x27;connected&#x27;);\n        socket.connack({ returnCode: 0 });\n      });\n\n      socket.on(&#x27;error&#x27;, (err) =&gt; {\n        debug(&#x27;error : %j&#x27;, err);\n        socket.destroy();\n      });\n\n      socket.on(&#x27;close&#x27;, () =&gt; {\n        debug(&#x27;===========     close     ============&#x27;);\n        socket.destroy();\n      });\n\n\n      socket.on(&#x27;disconnect&#x27;, () =&gt; {\n        debug(&#x27;===========   disconnect   ============&#x27;);\n        socket.destroy();\n      });\n        \n      &#x2F;&#x2F; 监听mqtt服务publish事件，接收client端请求\n      socket.on(&#x27;publish&#x27;, (pkg) =&gt; {\n        &#x2F;&#x2F; 消费client端的请求\n        self.consumers(pkg, socket);\n      });\n    });\n  }\n    \n  &#x2F;&#x2F; 消费client端的请求\n  consumers (pkg, socket) {\n    &#x2F;&#x2F; 赋值当前作用的指针给self对象\n    const self = this;\n    &#x2F;&#x2F; 将client的数据包转成json字符，字节序不同的处理已经在mqtt的底层转换好了\n    let content = pkg.payload.toString();\n    debug(content);\n    content = JSON.parse(content);\n    &#x2F;&#x2F; 定义响应数据包\n    const respMsg = {\n      msgId: content.msgId\n    };\n    &#x2F;&#x2F; 如果请求调用的函数不存在则加上错误消息响应回去client端\n    if (this.events[content.method] === null) {\n      &#x2F;&#x2F; 定义调用错误消息\n      respMsg.error = {\n        message: &#96;not found ${content.method} method&#96;\n      };\n      &#x2F;&#x2F; 推送到client端\n      self.response(socket, {messageId: pkg.messageId, body: respMsg});\n    } else {\n      &#x2F;&#x2F; 如果存在有效的函数则准备调用\n      const fn = this.events[content.method].method;\n      &#x2F;&#x2F; 设置调用函数的回调事件，用来处理调用函数完成后的参数返回\n      const callback = function (err, result) {\n        &#x2F;&#x2F; 获取调用完后的参数结果\n        respMsg.body = result;\n        &#x2F;&#x2F; 推送到client端\n        self.response(socket, {messageId: pkg.messageId, body: respMsg});\n      };\n      &#x2F;&#x2F; 执行调用参数\n      fn.call(fn, content.body, callback);\n    }\n  }\n    \n  &#x2F;&#x2F; 推送调用结果数据包给client端\n  response (socket, result) {\n    socket.publish({\n      topic: &#x27;rpc&#x27;,\n      qos: 1,\n      messageId: result.messageId,\n      payload: JSON.stringify(result.body)\n    });\n  }\n\n\n  &#x2F;&#x2F; 绑定kirito定义的函数集合\n  addEvent (events) {\n    const eventKeys = Object.getOwnPropertyNames(events);\n    eventKeys.some(event =&gt; {\n      this.events[event] = {\n        method: events[event].method,\n        param: events[event].param\n      };\n    });\n  }\n\n}\n\nmodule.exports.create = function () {\n  return new MQTT();\n};\n</code></pre><p>定义protocol接口，加上这一层是为了以后的多协议，mqtt只是默认使用的协议：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol.js\n\n&#x27;use strict&#x27;;\n\nconst mqtt = require(&#x27;.&#x2F;protocol&#x2F;mqtt&#x27;);\n\nmodule.exports.create = function (opts = {}) {\n  return mqtt.create(opts);\n};\n</code></pre><p>接下来是server端的暴露出去的接口：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; index.js\n\n&#x27;use strict&#x27;;\n\nconst protocol = require(&#x27;.&#x2F;protocol.js&#x27;);\n\nclass Server {\n\n  constructor () {\n    &#x2F;&#x2F; 实例化协议对象\n    this.server = protocol.create();\n  }\n    \n  &#x2F;&#x2F; 将kirito定义的接口和函数集合绑定\n  addKiritoService (service, methods) {\n    const serviceKeys = Object.getOwnPropertyNames(service);\n    const methodKeys = Object.getOwnPropertyNames(methods);\n    const events = {};\n    serviceKeys.some(method =&gt; {\n      let idx = -1;\n      if ((idx = methodKeys.indexOf(method)) !== -1) {\n        events[method] = {\n          method: methods[method],\n          param: service[method].param\n        };\n        methodKeys.splice(idx, 1);\n      }\n    });\n    if (Object.keys(events).length &gt; 0) {\n      this.server.addEvent(events);\n    }\n  }\n\n  listen (port) {\n    this.server.listen(port);\n  }\n\n}\n\nmodule.exports = Server;\n</code></pre><blockquote>\n<p><strong>client</strong>：</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol&#x2F;mqtt.js\n\n&#x27;use strict&#x27;;\n\nconst net = require(&#x27;net&#x27;);\nconst debug = require(&#x27;debug&#x27;)(&#x27;polix-rpc:mqtt&#x27;);\nconst EventEmitter = require(&#x27;events&#x27;).EventEmitter;\nconst mqttCon = require(&#x27;mqtt-connection&#x27;);\n\nclass MQTT extends EventEmitter {\n\n  constructor (server) {\n    super();\n    &#x2F;&#x2F; 获取server端连接信息\n    this.host = server.host || &#x27;localhost&#x27;;\n    this.port = server.port || 10003;\n    &#x2F;&#x2F; 是否服务已连接\n    this.connected = false;\n    &#x2F;&#x2F; 是否服务已关闭\n    this.closed = false;\n  }\n    \n  &#x2F;&#x2F; 连接server服务\n  connect (cb) {\n    &#x2F;&#x2F; 连接了就不用再次执行连接\n    if (this.connected) {\n      cb &amp;&amp; cb (new Error(&#x27;mqtt rpc has already connected&#x27;), null);\n      return;\n    }\n\n    &#x2F;&#x2F; 复制当前作用域上下文的指针给self变量\n    const self = this;\n    &#x2F;&#x2F; 获取net服务连接流\n    const stream = net.createConnection(this.port, this.host);\n    &#x2F;&#x2F; 初始化mqtt服务\n    this.socket = mqttCon(stream);\n    &#x2F;&#x2F; 监听conack事件\n    this.socket.on(&#x27;connack&#x27;, (pkg) =&gt; {\n      debug(&#x27;conack: %j&#x27;, pkg);\n    });\n\n    &#x2F;&#x2F; 监听error事件\n    this.socket.on(&#x27;error&#x27;, function (err) {\n      debug(&#x27;error: %j&#x27;, err);\n    });\n\n\n    &#x2F;&#x2F; 监听publish事件，接收server端调用函数结果的返回数据\n    this.socket.on(&#x27;publish&#x27;, (pkg) =&gt; {\n      &#x2F;&#x2F; 将数据包转成json字符\n      const content = pkg.payload.toString();\n      debug(content);\n      &#x2F;&#x2F; 将数据转发到MQTT的对象事件上\n      this.emit(&#x27;data&#x27;, JSON.parse(content));\n    });\n\n    &#x2F;&#x2F; 监听puback事件\n    this.socket.on(&#x27;puback&#x27;, (pkg) =&gt; {\n      debug(&#x27;puback: %j&#x27;, pkg);\n    });\n\n    &#x2F;&#x2F; 发起连接\n    this.socket.connect({\n      clientId: &#x27;MQTT_RPC_&#x27; + Math.round(new Date().getTime() &#x2F; 1000)\n    }, () =&gt; {\n      if (self.connected) {\n        return;\n      }\n        \n      &#x2F;&#x2F; 设置已连接\n      self.connected = true;\n\n      cb &amp;&amp; cb(null, {connected: self.connected});\n    });\n  }\n    \n  &#x2F;&#x2F; 发起调用函数请求\n  send (param) {\n    this.socket.publish({\n      topic: &#x27;rpc&#x27;,\n      qos: 1,\n      messageId: 1,\n      payload: JSON.stringify(param || {})\n    });\n  }\n\n  &#x2F;&#x2F; 关闭连接\n  close () {\n    if (this.closed) {\n      return;\n    }\n    this.closed = true;\n    this.connected = false;\n    this.socket.destroy();\n  }\n\n}\n\nmodule.exports.create = function (server) {\n  return new MQTT(server || {});\n};\n</code></pre><p>定义protocol接口：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol.js\n\n&#x27;use strict&#x27;;\n\nconst mqtt = require(&#x27;.&#x2F;protocol&#x2F;mqtt&#x27;);\n\nmodule.exports.create = function (opts = {}) {\n  return mqtt.create(opts);\n};\n</code></pre><p>最后是client端暴露的接口：</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst protocol = require(&#x27;.&#x2F;protocol.js&#x27;);\nconst connect = Symbol.for(&#x27;connect&#x27;);\nconst uuid = require(&#x27;uuid&#x2F;v1&#x27;);\n\nclass Client {\n\n  constructor(opts, service) {\n    &#x2F;&#x2F; 声明client实例\n    this.client = void(0);\n    &#x2F;&#x2F; 调用协议连接接口\n    this[connect](opts, service);\n    &#x2F;&#x2F; 定义回调参数集合\n    this.callQueues = {};\n  }\n\n  &#x2F;&#x2F; 连接server\n  [connect] (opts, service) {\n    &#x2F;&#x2F; 初始化协议服务\n    this.client = protocol.create(opts);\n    &#x2F;&#x2F; 发起连接\n    this.client.connect((err) =&gt; {\n      if (err) {\n        throw new Error(err);\n      }\n    });\n      \n    &#x2F;&#x2F; 复制当前作用域的上下文指针给self对象\n    const self = this;\n\n    &#x2F;&#x2F; 监听协议data时间，接收协议转发server端响应的数据\n    this.client.on(&#x27;data&#x27;, function (result) {\n      &#x2F;&#x2F; 听过msgId取出回调函数\n      const fn = self.callQueues[result.msgId];\n      &#x2F;&#x2F; 如果有调用错误信息，则直接回调错误\n      if (result.error) {\n        return fn.call(fn, result.error, null);\n      }\n      &#x2F;&#x2F; 执行回调\n      fn.call(fn, null, result.body);\n    });\n    &#x2F;&#x2F; 绑定kirito定义的接口参数到协议对象中\n    const serviceKeys = Object.getOwnPropertyNames(service);\n    serviceKeys.some(method =&gt; {\n      &#x2F;&#x2F; 增加client端的函数，对应server端的调用函数\n      self[method] = function () {\n        &#x2F;&#x2F; 取出发送的数据\n        const reqMsg = arguments[0];\n        &#x2F;&#x2F; 取出回调函数\n        const fn = arguments[1];\n        const paramKey = Object.getOwnPropertyNames(service[method].param);\n        paramKey.some((param) =&gt; {\n          if (reqMsg[param] === null) {\n            throw new Error(&#96;Parameters &#x27;${param}&#x27; are missing&#96;);\n          }\n          &#x2F;&#x2F; todo 类型判断及转换\n        });\n        &#x2F;&#x2F; 为每个请求标记\n        const msgId = uuid();\n        &#x2F;&#x2F; 注册该请求的回调函数到回调队列中\n        self.callQueues[msgId] = fn;\n        &#x2F;&#x2F; 发起调用函数请求\n        self.client.send({method, msgId, body: reqMsg});\n      };\n    });\n  }\n\n}\n\nmodule.exports = Client;\n</code></pre><p>就这样，一个简单的IDL+RPC框架就这样搭建完成了。这里只是描述RPC的原理和常用的调用方式，要想用在企业级的开发上，还得加上服务发现、注册，服务熔断，服务降级等，读者如果有兴趣可以在Github上fork下来或者提PR来改进这个框架，有什么问题也可以提Issue, 当然PR是最好的 : ) 。</p>\n<p>仓库地址：</p>\n<p>RPC: <a href=\"https://github.com/polixjs/polix-rpc\">https://github.com/polixjs/polix-rpc</a></p>\n<p>IDL: <a href=\"https://github.com/rickyes/kiritobuf\">https://github.com/rickyes/kiritobuf</a></p>\n</div>","title":"从零开始实现一个IDL+RPC框架","last_reply_at":"2019-04-02T10:07:51.760Z","good":true,"top":false,"reply_count":33,"visit_count":5851,"create_at":"2018-08-03T01:39:42.660Z","author":{"loginname":"zhoumingque","avatar_url":"https://avatars3.githubusercontent.com/u/20432815?v=4&s=120"}},{"id":"5ca2caf86c1de62dce466c76","author_id":"5c98426500bcfd7eb2be5add","tab":"share","content":"<div class=\"markdown-text\"><h2>Introduction</h2>\n<p>面试过程通常从最初的电话面试开始，然后是现场面试，检查编程技能和文化契合度。几乎毫无例外，最终的决定因素是还是编码能力。通常上，不仅仅要求能得到正确的答案，更重要的是要有清晰的思维过程。写代码中就像在生活中一样，正确的答案并不总是清晰的，但是好的推理通常就足够了。有效推理的能力预示着学习、适应和进化的潜力。好的工程师一直是在成长的，好的公司总是在创新的。</p>\n<p>算法挑战是有用的，因为解决它们的方法不止一种。这为决策的制定和决策的计算提供了可能性。在解决算法问题时，我们应该挑战自己从多个角度来看待问题的定义，然后权衡各种方法的优缺点。通过足够的尝试后，我们甚至可能看到一个普遍的真理:不存在“完美”的解决方案。</p>\n<p>要真正掌握算法，就必须了解它们与数据结构的关系。数据结构和算法就像阴阳、水杯和水一样密不可分。没有杯子，水就不能被容纳。没有数据结构，我们就没有对象来应用逻辑。没有水，杯子是空的，没有营养。没有算法，对象就不能被转换或“消费”。</p>\n<p>要了解和分析JavaScript中的数据结构，请看<a href=\"https://github.com/lvwxx/blog/issues/1\">JavaScript中的数据结构</a></p>\n<h2>Primer</h2>\n<p>在<strong>JavaScript</strong>中，算法只是一个函数，它将某个确定的数据结构输入转换为某个确定的数据结构输出。函数内部的逻辑决定了怎么转换。首先，输入和输出应该清楚地提前定义。这需要我们充分理解手上的问题，因为对问题的全面分析可以很自然地提出解决方案，而不需要编写任何代码。</p>\n<p>一旦完全理解了问题，就可以开始对解决方案进行思考，需要那些变量？ 有几种循环？ 有那些JavaScript内置方法可以提供帮助？需要考虑那些边缘情况？复杂或者重复的逻辑会导致代码十分的难以阅读和理解，可以考虑能否提出抽象成多个函数？一个算法通常上需要可扩展的。随着输入<strong>size</strong>的增加，函数将如何执行? 是否应该有某种缓存机制吗? 通常上，需要牺牲内存优化(空间)来换取性能提升(时间)。</p>\n<h3>为了使问题更加具体，画图表！</h3>\n<p>当解决方案的具体结构开始出现时，伪代码就可以开始了。为了给面试官留下深刻印象，请提前寻找重构和重用代码的机会。有时，行为相似的函数可以组合成一个更通用的函数，该函数接受一个额外的参数。其他时候，函数柯里的效果更好。保证函数功能的纯粹方便测试和维护也是非常重要的。换句话说，在做出解决问题的决策时需要考虑到架构和设计模式。</p>\n<h3>Big O（复杂度）</h3>\n<p>为了计算出算法运行时的复杂性，我们需要将算法的输入大小外推到无穷大，从而近似得出算法的复杂度。最优算法有一个恒定的时间复杂度和空间复杂度。这意味着它不关心输入的数量增长多少，其次是对数时间复杂度或空间复杂度，然后是线性、二次和指数。最糟糕的是阶乘时间复杂度或空间复杂度。算法复杂度可用以下符号表示:</p>\n<ol>\n<li>Constabt: O(1)</li>\n<li>Logarithmic: O(log n)</li>\n<li>Linear: O(n)</li>\n<li>Linearithmic: O(n log n)</li>\n<li>Quadratic: O(n^2)</li>\n<li>Expontential: O(2^n)</li>\n<li>Factorial: O(n!)</li>\n</ol>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*-j3Q4EiyBgc1tDTR5uKTnQ.png\" alt=\"''\"></p>\n<p>在设计算法的结构和逻辑时，时间复杂度和空间复杂度的优化和权衡是一个重要的步骤。</p>\n<h3>Arrays</h3>\n<p>一个最优的算法通常上会利用语言里固有的标准对象实现。可以说，在计算机科学中最重要的是数组。在JavaScript中，没有其他对象比数组拥有更多的实用方法。值得记住的数组方法有:sort、reverse、slice和splice。数组元素从第0个索引开始插入，所以最后一个元素的索引是 array.length-1。数组在push元素有很好的性能，但是在数组中间插入，删除和查找元素上性能却不是很优，JavaScript中的数组的大小是可以动态增长的。</p>\n<h4>数组的各种操作复杂度</h4>\n<ul>\n<li>Push: O(1)</li>\n<li>Insert: O(n)</li>\n<li>Delet: O(n)</li>\n<li>Searching: O(n)</li>\n<li>Optimized Searching: O(log n)</li>\n</ul>\n<p><strong>Map</strong> 和 <strong>Set</strong>是和数组相似的数据结构。set中的元素都是不重复的，在map中，每个Item由键和值组成。当然，对象也可以用来存储键值对，但是键必须是字符串。</p>\n<h3>Iterations</h3>\n<p>与数组密切相关的是使用循环遍历它们。在JavaScript中,有5种最常用的遍历方法，使用最多的是<strong>for</strong>循环，for循环可以用任何顺序遍历数组的索引。如果无法确定迭代的次数，我们可以使用<strong>while</strong>和<strong>do while</strong>循环，直到满足某个条件。对于任何<strong>Object</strong>, 我们可以使用 <strong>for in</strong> 和 <strong>for of</strong>循环遍历它的keys 和values。为了同时获取key和value我们可以使用 <strong>entries()</strong>。我们也可以在任何时候使用<strong>break</strong>语句终止循环，或者使用<strong>continue</strong>语句跳出本次循环进入下一次循环。</p>\n<p>原生数组提供了如下迭代方法：<strong>indexOf,lastIndexOf,includes,fill,join</strong>。 另外我们可以提供一个回调函数在如下方法中：<strong>findIndex,find,filter,forEach,map,some,every,reduce</strong>。</p>\n<h3>Recursions</h3>\n<p>在一篇开创性的论文中，Church-Turing论文证明了任何迭代函数都可以用递归函数来复制，反之亦然。有时候，递归方法更简洁、更清晰、更优雅。以这个迭代阶乘函数为例:</p>\n<pre class=\"prettyprint language-js\"><code>const factorial = number =&gt; {\n  let product = 1\n  for (let i = 2; i &lt;= number; i++) {\n    product *= i\n  }\n  return product\n}\n</code></pre><p>如果使用递归，仅仅需要一行代码</p>\n<pre class=\"prettyprint language-js\"><code>const _factorial = number =&gt; {\n  return number &lt; 2 ? 1 : number * _factorial(number - 1)\n}\n</code></pre><p>所有的递归函数都有相同的模式。它们由创建一个调用自身的递归部分和一个不调用自身的基本部分组成。任何时候一个函数调用它自身都会创建一个新的执行上下文并推入执行栈顶直。这种情况会一直持续到直到满足了基本情况为止。然后执行栈会一个接一个的将栈顶元素推出。因此，对递归的滥用可能导致堆栈溢出的错误。</p>\n<h3>最后，我们一起来思考一些常见算法题！</h3>\n<h4>1. 字符串反转</h4>\n<p>一个函数接受一个字符串作为参数，返回反转后的字符串</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;String Reversal&quot;, () =&gt; {\n it(&quot;Should reverse string&quot;, () =&gt; {\n  assert.equal(reverse(&quot;Hello World!&quot;), &quot;!dlroW olleH&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>这道题的关键点是我们可以使用数组自带的<strong>reverse</strong>方法。首先我们使用 <strong>split</strong>方法将字符串转为数组，然后使用reverse反转字符串，最后使用<strong>join</strong>方法转为字符串。另外也可以使用数组的<strong>reduce</strong>方法</p>\n<p>给定一个字符串，每个字符需要访问一次。虽然这种情况发生了很多次，但是时间复杂度会正常化为线性。由于没有单独的内部数据结构，空间复杂度是恒定的。</p>\n<pre class=\"prettyprint language-js\"><code>const reverse = string =&gt; string.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)\n\nconst _reverse = string =&gt; string.split(&#x27;&#x27;).reduce((res,char) =&gt; char + res)\n</code></pre><h4>2. 回文</h4>\n<p>回文是一个单词或短语，它的读法是前后一致的。写一个函数来检查。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Palindrome&quot;, () =&gt; {\n it(&quot;Should return true&quot;, () =&gt; {\n  assert.equal(isPalindrome(&quot;Cigar? Toss it in a can. It is so tragic&quot;), true);\n })\n it(&quot;Should return false&quot;, () =&gt; {\n  assert.equal(isPalindrome(&quot;sit ad est love&quot;), false);\n })\n})\n</code></pre><h5>思考</h5>\n<p>函数只需要简单地判断输入的单词或短语反转之后是否和原输入相同，完全可以参考第一题的解决方案。我们可以使用数组的 <strong>every</strong> 方法检查第i个字符和第array.length-i个字符是否匹配。但是这个方法会使每个字符检查2次，这是没必要的。那么，我们可以使用reduce方法。和第1题一样，时间复杂度和空间复杂度是相同的。</p>\n<pre class=\"prettyprint language-js\"><code>const isPalindrome = string =&gt; {\n  const validCharacters = &quot;abcdefghijklmnopqrstuvwxyz&quot;.split(&quot;&quot;)\n  const stringCharacters = string &#x2F;&#x2F; 过滤掉特殊符号\n      .toLowerCase()\n      .split(&quot;&quot;)\n      .reduce(\n        (characters, character) =&gt;\n          validCharacters.indexOf(character) &gt; -1\n            ? characters.concat(character)\n            : characters,\n        []\n      );\n  return stringCharacters.join(&quot;&quot;) === stringCharacters.reverse().join(&quot;&quot;)\n</code></pre><h4>3. 整数反转</h4>\n<p>给定一个整数，反转数字的顺序。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Integer Reversal&quot;, () =&gt; {\n it(&quot;Should reverse integer&quot;, () =&gt; {\n  assert.equal(reverse(1234), 4321);\n  assert.equal(reverse(-1200), -21);\n })\n})\n</code></pre><h5>思考</h5>\n<p>把number类型使用<strong>toString</strong>方法换成字符串，然后就可以按照字符串反转的步骤来做。反转完成之后，使用<strong>parseInt</strong>方法转回number类型，然后使用<strong>Math.sign</strong>加入符号，只需一行代码便可完成。</p>\n<p>由于我们重用了字符串反转的逻辑，因此该算法在空间和时间上也具有相同的复杂度。</p>\n<pre class=\"prettyprint language-js\"><code>const revserInteger = integer =&gt; parseInt(number\n      .toString()\n      .split(&#x27;&#x27;)\n      .reverse()\n      .join(&#x27;&#x27;)) * Math.sign(integer)\n</code></pre><h4>4. 出现次数最多的字符</h4>\n<p>给定一个字符串，返回出现次数最多的字符</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Max Character&quot;, () =&gt; {\n it(&quot;Should return max character&quot;, () =&gt; {\n  assert.equal(max(&quot;Hello World!&quot;), &quot;l&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>可以创建一个对象，然后遍历字符串，字符串的每个字符作为对象的key，value是对应该字符出现的次数。然后我们可以遍历这个对象，找出value最大的key。</p>\n<p>虽然我们使用两个单独的循环来迭代两个不同的输入(字符串和字符映射)，但是时间复杂度仍然是线性的。它可能来自字符串，但最终，字符映射的大小将达到一个极限，因为在任何语言中只有有限数量的字符。空间复杂度是恒定的。</p>\n<pre class=\"prettyprint language-js\"><code>const maxCharacter = (str) =&gt; {\n    const obj = {}\n    let max = 0\n    let character = &#x27;&#x27;\n    for (let index in str) {\n      obj[str[index]] = obj[str[index]] + 1 || 1\n    }\n    for (let i in obj) {\n      if (obj[i] &gt; max) {\n        max = obj[i]\n        character = i\n      }\n    }\n    return character\n  }\n</code></pre><h4>5.找出string中元音字母出现的个数</h4>\n<p>给定一个单词或者短语，统计出元音字母出现的次数</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Vowels&quot;, () =&gt; {\n it(&quot;Should count vowels&quot;, () =&gt; {\n  assert.equal(vowels(&quot;hello world&quot;), 3);\n })\n})\n</code></pre><h5>思考</h5>\n<p>最简单的解决办法是利用正则表达式提取所有的元音，然后统计。如果不允许使用正则表达式，我们可以简单的迭代每个字符并检查是否属于元音字母，首先应该把输入的参数转为小写。</p>\n<p>这两种方法都具有线性的时间复杂度和恒定的空间复杂度，因为每个字符都需要检查，临时基元可以忽略不计。</p>\n<pre class=\"prettyprint language-js\"><code>  const vowels = str =&gt; {\n    const choices = [&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;]\n    let count = 0\n    for (let character in str) {\n      if (choices.includes(str[character])) {\n        count ++\n      }\n    }\n    return count\n  }\n\n  const vowelsRegs = str =&gt; {\n    const match = str.match(&#x2F;[aeiou]&#x2F;gi)\n    return match ? match.length : 0\n  }\n</code></pre><h4>6.数组分隔</h4>\n<p>给定数组和大小，将数组项拆分为具有给定大小的数组列表。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Array Chunking&quot;, () =&gt; {\n it(&quot;Should implement array chunking&quot;, () =&gt; {\n  assert.deepEqual(chunk([1, 2, 3, 4], 2), [[1, 2], [3, 4]]);\n  assert.deepEqual(chunk([1, 2, 3, 4], 3), [[1, 2, 3], [4]]);\n  assert.deepEqual(chunk([1, 2, 3, 4], 5), [[1, 2, 3, 4]]);\n })\n})\n</code></pre><p>一个好的解决方案是使用内置的slice方法。这样就能生成更干净的代码。可通过while循环或for循环来实现，它们按给定大小的步骤递增。</p>\n<p>这些算法都具有线性时间复杂度，因为每个数组项都需要访问一次。它们还具有线性空间复杂度，因为保留了一个内部的“块”数组，它与输入数组成比例地增长。</p>\n<pre class=\"prettyprint language-js\"><code>const chunk = (array, size) =&gt; {\n  const chunks = []\n  let index = 0\n   while(index &lt; array.length) {\n     chunks.push(array.slice(index, index + size))\n     index += size\n   }\n   return chunks\n}\n</code></pre><h4>7.words反转</h4>\n<p>给定一个短语，按照顺序反转每一个单词</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Reverse Words&quot;, () =&gt; {\n it(&quot;Should reverse words&quot;, () =&gt; {\n  assert.equal(reverseWords(&quot;I love JavaScript!&quot;), &quot;I evol !tpircSavaJ&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>可以使用split方法创建单个单词数组。然后对于每一个单词，可以复用之前反转string的逻辑。</p>\n<p>因为每一个字符都需要被访问，而且所需的临时变量与输入的短语成比例增长，所以时间复杂度和空间复杂度是线性的。</p>\n<pre class=\"prettyprint language-js\"><code>const reverseWords = string =&gt; string\n                                  .split(&#x27; &#x27;)\n                                  .map(word =&gt; word\n                                                .split(&#x27;&#x27;)\n                                                .reverse()\n                                                .join(&#x27;&#x27;)\n                                      ).join(&#x27; &#x27;)\n\n</code></pre><h4>8.首字母大写</h4>\n<p>给定一个短语，每个首字母变为大写。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Capitalization&quot;, () =&gt; {\n it(&quot;Should capitalize phrase&quot;, () =&gt; {\n  assert.equal(capitalize(&quot;hello world&quot;), &quot;Hello World&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>一种简洁的方法是将输入字符串拆分为单词数组。然后，我们可以循环遍历这个数组并将第一个字符大写，然后再将这些单词重新连接在一起。出于不变的相同原因，我们需要在内存中保存一个包含适当大写字母的临时数组。</p>\n<p>因为每一个字符都需要被访问，而且所需的临时变量与输入的短语成比例增长，所以时间复杂度和空间复杂度是线性的。</p>\n<pre class=\"prettyprint language-js\"><code>const capitalize = str =&gt; {\n  return str.split(&#x27; &#x27;).map(word =&gt; word[0].toUpperCase() + word.slice(1)).join(&#x27; &#x27;)\n}\n</code></pre><h4>9.凯撒密码</h4>\n<p>给定一个短语，通过在字母表中上下移动一个给定的整数来替换每个字符。如果有必要，这种转换应该回到字母表的开头或结尾。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Caesar Cipher&quot;, () =&gt; {\n it(&quot;Should shift to the right&quot;, () =&gt; {\n  assert.equal(caesarCipher(&quot;I love JavaScript!&quot;, 100), &quot;E hkra FwrwOynelp!&quot;)\n })\nit(&quot;Should shift to the left&quot;, () =&gt; {\n  assert.equal(caesarCipher(&quot;I love JavaScript!&quot;, -100), &quot;M pszi NezeWgvmtx!&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>首先我们需要一个包含所有字母的数组，这意味着我们需要把给定的字符串转为小写，然后遍历整个字符串，给每个字符增加或减少给定的整数位置，最后判断大小写即可。</p>\n<p>由于需要访问输入字符串中的每个字符，并且需要从中创建一个新的字符串，因此该算法具有线性的时间和空间复杂度。</p>\n<pre class=\"prettyprint language-js\"><code>const caesarCipher = (str, number) =&gt; {\n  const alphabet = &quot;abcdefghijklmnopqrstuvwxyz&quot;.split(&quot;&quot;)\n    const string = str.toLowerCase()\n    const remainder = number % 26\n    let outPut = &#x27;&#x27;\n    for (let i = 0; i &lt; string.length; i++) {\n      const letter = string[i]\n      if (!alphabet.includes(letter)) {\n        outPut += letter\n      } else {\n        let index = alphabet.indexOf(letter) + remainder\n        if (index &gt; 25) {\n          index -= 26\n        }\n        if (index &lt; 0) {\n          index += 26\n        }\n        outPut += str[i] === str[i].toUpperCase() ? alphabet[index].toUpperCase() : alphabet[index]\n      }\n    }\n  return outPut\n}\n</code></pre><h4>10.找出从0开始到给定整数的所有质数</h4>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Sieve of Eratosthenes&quot;, () =&gt; {\n it(&quot;Should return all prime numbers&quot;, () =&gt; {\n  assert.deepEqual(primes(10), [2, 3, 5, 7])\n })\n})\n</code></pre><h5>思考</h5>\n<p>最简单的方法是我们循环从0开始到给定整数的每个整数，并创建一个方法检查它是否是质数。</p>\n<pre class=\"prettyprint language-js\"><code>const isPrime = n =&gt; {\n  if (n &gt; 1 &amp;&amp; n &lt;= 3) {\n      return true\n    } else {\n      for(let i = 2;i &lt;= Math.sqrt(n);i++){\n        if (n % i == 0) {\n          return false\n        }\n      }\n      return true\n  }\n}\n\nconst prime = number =&gt; {\n  const primes = []\n  for (let i = 2; i &lt; number; i++) {\n    if (isPrime(i)) {\n      primes.push(i)\n    }\n  }\n  return primes\n}\n</code></pre><h4>自己实现一个高效的斐波那契队列，欢迎在评论区提交代码</h4>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Fibonacci&quot;, () =&gt; {\n it(&quot;Should implement fibonacci&quot;, () =&gt; {\n  assert.equal(fibonacci(1), 1);\n  assert.equal(fibonacci(2), 1);\n  assert.equal(fibonacci(3), 2);\n  assert.equal(fibonacci(6), 8);\n  assert.equal(fibonacci(10), 55);\n })\n})\n</code></pre></div>","title":"JavaScript中的算法（附10道面试常见算法题解决方法和思路）","last_reply_at":"2019-04-02T10:00:32.523Z","good":false,"top":false,"reply_count":8,"visit_count":732,"create_at":"2019-04-02T02:37:44.112Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5ca171d499e62a362ff41bd3","author_id":"5c862e877ce0df3732426edf","tab":"ask","content":"<div class=\"markdown-text\"><p>除了PM2之外,还有什么方法或者模块让node实现多进程。。。</p>\n</div>","title":"node多进程实现","last_reply_at":"2019-04-02T06:01:25.674Z","good":false,"top":false,"reply_count":10,"visit_count":645,"create_at":"2019-04-01T02:05:08.248Z","author":{"loginname":"cheerApril","avatar_url":"https://avatars0.githubusercontent.com/u/38412944?v=4&s=120"}},{"id":"5ca227df31010b2dfbb42023","author_id":"5933cd9e7e057cea7ceb98ab","tab":"ask","content":"<div class=\"markdown-text\"><p>下面是简单的示例：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; article\nconst ArticleSchema = new Schema({\n\ttitle: {\n        type: String,\n        required: true,\n    },\n    content: {\n        type: String,\n        required: true,\n    },\n    tags: [{\n        type: Schema.Types.ObjectId,\n        ref: &#x27;Tag&#x27;,\n    }],\n})\n\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; tag\nconst TagSchema = new Schema({\n    name: {\n        type: String,\n        default: &#x27;&#x27;,\n        required: true,\n    },\n    sort: {\n        type: Number,\n        default: 0,\n    },\n    articles: [{\n        type: Schema.Types.ObjectId,\n        ref: &#x27;Article&#x27;,\n    }],\n})\n</code></pre><p>我现在的做法是，添加文章时，更新tag下的articles字段，push 进去 article id。但我感觉这样是错的，因为如果修改了文章的标签，需要先删除原标签下的文章id，再添加到新标签下。求问有没有比较好的解决方式</p>\n</div>","title":"设计标签功能时，如何统计标签下文章数量？","last_reply_at":"2019-04-02T04:07:35.579Z","good":false,"top":false,"reply_count":5,"visit_count":375,"create_at":"2019-04-01T15:01:51.391Z","author":{"loginname":"wmui","avatar_url":"https://avatars0.githubusercontent.com/u/24876474?v=4&s=120"}},{"id":"5ca2088c31010b2dfbb41fc6","author_id":"5ac77987e34737560fccaa7b","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/1/169d8d8bcbd33a48?w=3968&amp;h=2976&amp;f=jpeg&amp;s=4483019\" alt=\"image\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/1/169d8d8be0cca453?w=2976&amp;h=3968&amp;f=jpeg&amp;s=5742233\" alt=\"image\"></p>\n<p>3月31日去颐和园转了一圈, 拍的比较满意的几张照片</p>\n<h2>前言</h2>\n<p>本文主要参考了<a href=\"https://github.com/developit/preact\">preact的源码</a></p>\n<h2>准备工作</h2>\n<p>我们首先搭建开发的环境, 我们选择webpack4。值得注意的是, 因为我们需要解析JSX的语法, 我们需要使用**<a href=\"/user/babel\">@babel</a>/plugin-transform-react-jsx**插件。</p>\n<p><a href=\"/user/babel\">@babel</a>/plugin-transform-react-jsx插件会将JSX语法做出以下格式的转换。<a href=\"/user/babel\">@babel</a>/plugin-transform-react-jsx默认使用React.createElement, 我们可以通过设置插件的pragma配置项, 修改默认的函数名</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; before\nvar profile = &lt;div&gt;\n  &lt;img src=&quot;avatar.png&quot; className=&quot;profile&quot; &#x2F;&gt;\n  &lt;h3&gt;{[user.firstName, user.lastName].join(&#x27; &#x27;)}&lt;&#x2F;h3&gt;\n&lt;&#x2F;div&gt;;\n\n&#x2F;&#x2F; after\nvar profile = React.createElement(&quot;div&quot;, null,\n  React.createElement(&quot;img&quot;, { src: &quot;avatar.png&quot;, className: &quot;profile&quot; }),\n  React.createElement(&quot;h3&quot;, null, [user.firstName, user.lastName].join(&quot; &quot;))\n);\n</code></pre><pre class=\"prettyprint language-js\"><code>\nconst webpack = require(&#x27;webpack&#x27;)\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)\nconst path = require(&#x27;path&#x27;)\nconst HappyPack = require(&#x27;happypack&#x27;)\n\nmodule.exports = {\n  devtool: &#x27;#cheap-module-eval-source-map&#x27;,\n\n  mode: &#x27;development&#x27;,\n\n  target: &#x27;web&#x27;,\n\n  entry: {\n    main: path.resolve(__dirname, &#x27;.&#x2F;example&#x2F;index.js&#x27;)\n  },\n\n  devServer: {\n    host: &#x27;0.0.0.0&#x27;,\n    port: 8080,\n    hot: true\n  },\n\n  resolve: {\n    extensions: [&#x27;.js&#x27;]\n  },\n\n  module: {\n    rules: [\n      {\n        test: &#x2F;\\.js$&#x2F;,\n        exclude: &#x2F;node_modules&#x2F;,\n        use: &#x27;happypack&#x2F;loader?id=js&#x27;\n      },\n      {\n        test: &#x2F;\\.css$&#x2F;,\n        use: [\n          {\n            loader: &#x27;style-loader&#x27;\n          },\n          {\n            loader: &#x27;css-loader&#x27;\n          }\n        ]\n      }\n    ]\n  },\n\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(),\n    new HappyPack({\n      id: &#x27;js&#x27;,\n      threads: 4,\n      use: [\n        {\n          loader: &#x27;babel-loader&#x27;,\n          options: {\n            presets: [&#x27;[@babel](&#x2F;user&#x2F;babel)&#x2F;preset-env&#x27;],\n            plugins: [\n              &#x27;[@babel](&#x2F;user&#x2F;babel)&#x2F;plugin-syntax-dynamic-import&#x27;,\n              [\n                &quot;[@babel](&#x2F;user&#x2F;babel)&#x2F;plugin-transform-react-jsx&quot;,\n                {\n                  pragma: &#x27;h&#x27;\n                }\n              ]\n            ]\n          }\n        }\n      ]\n    }),\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, &#x27;.&#x2F;public&#x2F;index.html&#x27;)\n    })\n  ]\n}\n</code></pre><p>上面是完整的打包配置(如果严格来说, 类库应该单独打包的)。同时我们将<a href=\"/user/babel\">@babel</a>/plugin-transform-react-jsx插件, pragma参数设置为&quot;h&quot;。我们在使用的时候, 只需要在文件中引入h函数即可。</p>\n<h2>创建VNode</h2>\n<p>我们在这里将会实现h方法, h方法的作用是创建一个VNode。根据编译结果可知, h函数的参数如下。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;**\n * type为VNode的类型\n * props为VNode的属性\n * childrens为VNode的子节点, 可能用多组子节点, 我们使用es6的rest参数\n *&#x2F;\nh(type, props, ...childrens)\n</code></pre><p>VNode本质就是Javascript中对象, 因此h函数只需要返回对应的对象即可。</p>\n<pre class=\"prettyprint language-js\"><code>\nexport function createElement (type, props, ...children) {\n  if (!props) props = {}\n  \n  props.children = [...children]\n\n  let key = props.key\n\n\tif (key) {\n    delete props.key\n  }\n\n  return createVNode(type, props, null, key)\n}\n\nexport function createVNode (type, props, text, key) {\n  const VNode = {\n    type,\n    props,\n    text,\n    key,\n    _dom: null,\n    _children: null,\n    _component: null\n  }\n\n  return VNode\n}\n</code></pre><p>我们来使用一下，看一下h函数返回的结果, h函数返回的结果即是虚拟DOM</p>\n<pre class=\"prettyprint language-js\"><code>import { h } from &#x27;yy-react&#x27;\n\nconsole.log(\n  &lt;div&gt;\n    &lt;h1&gt;Hello&lt;&#x2F;h1&gt;\n    &lt;h1&gt;World&lt;&#x2F;h1&gt;\n  &lt;&#x2F;div&gt;\n)\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/1/169d8d92d8d3ea36?w=1008&amp;h=618&amp;f=png&amp;s=103473\" alt=\"image\"></p>\n<h2>实现render</h2>\n<p>我们可以参考React的render函数的实现, render函数接受两个参数, React元素(VNode)以及container(挂载的DOM)。我们将要把VNode渲染成了真实的DOM节点。</p>\n<p>下面是render函数的实现, 我们在本期还没有来得及实现Diff方法, 读者可以不用关注于这些。</p>\n<p>整体代码的实现，参考(抄)了preact的源码的实现😏。(我还给preact的项目提交了pr😊，不过还没有merge😢)</p>\n<p>👇 <strong>文章的最后是具体实现, 但是一大坨对阅读不是很友好，不想看的可以略过，直接看解说。</strong></p>\n<p>我们首先将视角转向render, render函数里调用里diff函数, 将返回的dom挂载到document中。_prevVNode等属性我们会在以后用到，目前可以忽略。</p>\n<pre class=\"prettyprint language-js\"><code>\nexport function render (vnode, root) {\n  let oldVNode = root._prevVNode\n  let newVNode = root._prevVNode = vnode\n  let dom = oldVNode ? oldVNode._dom : null\n  let mounts = []\n  let newDom = diff(dom, root, newVNode, oldVNode, mounts)\n  if (newDom) {\n    root.appendChild(newDom)\n  }\n}\n</code></pre><p>在diff中，我们将对节点类型做出判断, VNode类型可以是普通的节点也可以是组件类型的节点, 我们这里先对普通类型的节点做出处理。</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction diff (\n  dom,\n  root,\n  newVNode,\n  oldVNode,\n  mounts,\n  force\n) {\n\n  let newType = newVNode.type\n\n  if (typeof newType === &#x27;function&#x27;) {\n    &#x2F;&#x2F; render component\n  } else {\n    dom = diffElementNodes(\n      dom,\n      newVNode,\n      oldVNode,\n      mounts\n    )\n  }\n\n  newVNode._dom = dom\n\n  return dom\n}\n</code></pre><p>我们接着将目光转向diffElementNodes函数, 在diffElementNodes函数中我们会根据具体节点类型创建对应的真实的DOM节点。\n例如文本类型的节点我们使用createTextNode, 而普通类型的我们使用createElement</p>\n<p>因为整个VNode呈现的一种树状结构, 面对树状结构免不了使用递归去遍历每一颗节点。我们这里将创建后dom，作为父节点传入diffChildren函数中(<strong>新创建的节点会append到这个父节点中</strong>)。递归的转换的每一个子节点以及子节点的子节点。</p>\n<p>由此我们也可知道，整个VNode树的渲染的顺序是由外向里的。但是设置VNode的props的顺序则是由里向外的。</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction diffElementNodes (dom, newVNode, oldVNode, mounts) {\n\n  if (!dom) {\n    dom = newVNode.type === null ? document.createTextNode(newVNode.text) : document.createElement(newVNode.type)\n  }\n\n  newVNode._dom = dom\n\n  if (newVNode.type) {\n    if (newVNode !== oldVNode) {\n      let newProps = newVNode.props\n      let oldProps = oldVNode.props\n      if (!oldProps) {\n        oldProps = {}\n      }\n      diffChildren(dom, newVNode, oldVNode, mounts)\n      diffProps(dom, newProps, oldProps)\n    }\n  }\n\n  return dom\n}\n</code></pre><p>在diffChildren中, 我们将VNode的子VNode挂载到_children属性上, 遍历每一个子节点, 将子节点带入到diff中, 完成创建的过程</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction diffChildren (\n  root,\n  newParentVNode,\n  oldParentVNode,\n  mounts\n) {\n  let oldVNode, newVNode, newDom, i, j, index, p, oldChildrenLength\n\n  let newChildren = newParentVNode._children || \n                    toChildVNodeArray(newParentVNode.props.children, newParentVNode._children = [])\n\n  for (i = 0; i &lt; newChildren.length; i++) {\n    newVNode = newChildren[i]\n    oldVNode = index = null\n\n    newDom = diff(\n      oldVNode ? oldVNode._dom : null,\n      root,\n      newVNode,\n      oldVNode,\n      mounts,\n      null\n    )\n\n    if (newVNode &amp;&amp; newDom) {\n      root.appendChild(newDom)\n    }\n  }\n}\n</code></pre><p>我们在遍历递归完子节点后, 就可以使用diffProps来设置我们的root节点了。我们遍历newProps中的每一个key, 并使用setProperty将props设置到dom上, setProperty中对一些dom属性做了特殊的处理。比如处理了驼峰的css的key, 和数字的value自动添加px等。</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction diffProps (dom, newProps, oldProps) {\n  for (let key in newProps) {\n    if (\n      key !==&#x27;children&#x27; &amp;&amp;\n      key!==&#x27;key&#x27; &amp;&amp;\n      (\n        !oldProps ||\n        ((key === &#x27;value&#x27; || key === &#x27;checked&#x27;) ? dom : oldProps)[key] !== newProps[key]\n      )\n    ) {\n\t\t\tsetProperty(dom, key, newProps[key], oldProps[key])\n\t\t}\n  }\n}\n\nfunction setProperty (dom, name, value, oldValue) {\n  if (name === &#x27;style&#x27;) {\n    let s = dom.style\n    if (typeof value === &#x27;string&#x27;) {\n\t\t\ts.cssText = value\n\t\t} else {\n\t\t\tif (typeof oldValue === &#x27;string&#x27;) {\n        s.cssText = &#x27;&#x27;\n      } else {\n\t\t\t\tfor (let i in oldValue) {\n\t\t\t\t\tif (value==null || !(i in value)) {\n            s.setProperty(i.replace(CAMEL_REG, &#x27;-&#x27;), &#x27;&#x27;)\n          }\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i in value) {\n\t\t\t\tv = value[i];\n\t\t\t\tif (oldValue==null || v!==oldValue[i]) {\n\t\t\t\t\ts.setProperty(i.replace(CAMEL_REG, &#x27;-&#x27;), typeof v===&#x27;number&#x27; &amp;&amp; IS_NON_DIMENSIONAL.test(i)===false ? (v + &#x27;px&#x27;) : v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n  } else if (value == null) {\n    dom.removeAttribute(name)\n  } else if (typeof value !== &#x27;function&#x27;) {\n    dom.setAttribute(name, value)\n  }\n}\n</code></pre><p>最后我们再次回到render函数，render函数最后的会将创建好的dom, append到挂载的dom中完成渲染。</p>\n<pre class=\"prettyprint language-js\"><code>\nroot.appendChild(newDom)\n</code></pre><h2>完整示例</h2>\n<blockquote>\n<p>github的仓库地址将在完成后放出</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; create-element.js\nexport function render (vnode, root) {\n  let oldVNode = root._prevVNode\n  let newVNode = root._prevVNode = vnode\n  let dom = oldVNode ? oldVNode._dom : null\n  let mounts = []\n  let newDom = diff(dom, root, newVNode, oldVNode, mounts)\n  if (newDom) {\n    root.appendChild(newDom)\n  }\n  runDidMount(mounts, vnode)\n}\n\n&#x2F;&#x2F; diff.js\nfunction diff (\n  dom,\n  root,\n  newVNode,\n  oldVNode,\n  mounts,\n  force\n) {\n  if (oldVNode == null || newVNode == null || newVNode.type !== oldVNode.type) {\n    if (!newVNode) return null\n    dom = null\n    oldVNode = {}\n  }\n\n  let newType = newVNode.type\n\n  if (typeof newType === &#x27;function&#x27;) {\n    &#x2F;&#x2F; render component\n  } else {\n    dom = diffElementNodes(\n      dom,\n      newVNode,\n      oldVNode,\n      mounts\n    )\n  }\n\n  newVNode._dom = dom\n\n  return dom\n}\n\nfunction diffElementNodes (dom, newVNode, oldVNode, mounts) {\n\n  if (!dom) {\n    dom = newVNode.type === null ? document.createTextNode(newVNode.text) : document.createElement(newVNode.type)\n  }\n\n  newVNode._dom = dom\n\n  if (newVNode.type) {\n    if (newVNode !== oldVNode) {\n      let newProps = newVNode.props\n      let oldProps = oldVNode.props\n      if (!oldProps) {\n        oldProps = {}\n      }\n      diffChildren(dom, newVNode, oldVNode, mounts)\n      diffProps(dom, newProps, oldProps)\n    }\n  }\n\n  return dom\n}\n\n&#x2F;&#x2F; diff-children.js\nfunction diffChildren (\n  root,\n  newParentVNode,\n  oldParentVNode,\n  mounts\n) {\n  let oldVNode, newVNode, newDom, i, j, index, p, oldChildrenLength\n\n  let newChildren = newParentVNode._children || \n                    toChildVNodeArray(newParentVNode.props.children, newParentVNode._children = [])\n\n  for (i = 0; i &lt; newChildren.length; i++) {\n    newVNode = newChildren[i]\n    oldVNode = index = null\n\n    newDom = diff(\n      oldVNode ? oldVNode._dom : null,\n      root,\n      newVNode,\n      oldVNode,\n      mounts,\n      null\n    )\n\n    if (newVNode &amp;&amp; newDom) {\n      root.appendChild(newDom)\n    }\n  }\n}\n\n&#x2F;&#x2F; diffProps.js\nfunction diffProps (dom, newProps, oldProps) {\n  for (let key in newProps) {\n    if (\n      key !==&#x27;children&#x27; &amp;&amp;\n      key!==&#x27;key&#x27; &amp;&amp;\n      (\n        !oldProps ||\n        ((key === &#x27;value&#x27; || key === &#x27;checked&#x27;) ? dom : oldProps)[key] !== newProps[key]\n      )\n    ) {\n\t\t\tsetProperty(dom, key, newProps[key], oldProps[key])\n\t\t}\n  }\n  for (let key in oldProps) {\n  }\n}\n\n&#x2F;&#x2F; diff-props\nfunction diffProps (dom, newProps, oldProps) {\n  for (let key in newProps) {\n    if (\n      key !==&#x27;children&#x27; &amp;&amp;\n      key!==&#x27;key&#x27; &amp;&amp;\n      (\n        !oldProps ||\n        ((key === &#x27;value&#x27; || key === &#x27;checked&#x27;) ? dom : oldProps)[key] !== newProps[key]\n      )\n    ) {\n\t\t\tsetProperty(dom, key, newProps[key], oldProps[key])\n\t\t}\n  }\n  for (let key in oldProps) {\n  }\n}\n\nfunction setProperty (dom, name, value, oldValue) {\n  if (name === &#x27;style&#x27;) {\n    let s = dom.style\n    if (typeof value === &#x27;string&#x27;) {\n\t\t\ts.cssText = value\n\t\t} else {\n\t\t\tif (typeof oldValue === &#x27;string&#x27;) {\n        s.cssText = &#x27;&#x27;\n      } else {\n\t\t\t\tfor (let i in oldValue) {\n\t\t\t\t\tif (value==null || !(i in value)) {\n            s.setProperty(i.replace(CAMEL_REG, &#x27;-&#x27;), &#x27;&#x27;)\n          }\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i in value) {\n\t\t\t\tv = value[i];\n\t\t\t\tif (oldValue==null || v!==oldValue[i]) {\n\t\t\t\t\ts.setProperty(i.replace(CAMEL_REG, &#x27;-&#x27;), typeof v===&#x27;number&#x27; &amp;&amp; IS_NON_DIMENSIONAL.test(i)===false ? (v + &#x27;px&#x27;) : v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n  } else if (value == null) {\n    dom.removeAttribute(name)\n  } else if (typeof value !== &#x27;function&#x27;) {\n    dom.setAttribute(name, value)\n  }\n}\n</code></pre><h3>其他</h3>\n<p><a href=\"https://juejin.im/post/5c97599fe51d450f357634fc\">preact源码分析(一)</a></p>\n<p><a href=\"https://juejin.im/post/5c9759cef265da611256430c\">preact源码分析(二)</a></p>\n<p><a href=\"https://juejin.im/post/5c975a1e6fb9a07107193af1\">preact源码分析(三)</a></p>\n<p><a href=\"https://juejin.im/post/5c9a36316fb9a070f03d083e\">preact源码分析(四)</a></p>\n<p><a href=\"https://juejin.im/post/5c9f7e126fb9a05e58493f9f\">preact源码分析(五)</a></p>\n</div>","title":"实现一个属于自己的React框架～～～～更新中～～～～～","last_reply_at":"2019-04-01T12:52:53.250Z","good":false,"top":false,"reply_count":1,"visit_count":386,"create_at":"2019-04-01T12:48:12.209Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{"id":"5c9de1aa484eeb3634158513","author_id":"5a0a5c9da57c17282e120654","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/29/169c8b7d66969005?w=640&amp;h=480&amp;f=jpeg&amp;s=104395\" alt=\"administration-articles-bank-261949.jpg\"></p>\n<p>2019年3月29日目前，Node 对 ES6 Module 的支持又有新进展。一个新的 PR 更新了当前 <code>--experimental-modules</code> 的实现方案。</p>\n<p><strong>type 动态判断模块加载模式</strong></p>\n<p>更新后的方案将根据 <code>package.json</code> 文件中指定的 type 值来判断 js 文件是使用 ESM 还是 commonjs</p>\n<ul>\n<li>如果 type 的值为 module 那么 js 文件将被作为 ESM 加载</li>\n<li>如果 type 的值为 commonjs 那么 js 文件将被作为 commonjs 来加载</li>\n</ul>\n<p>好处就是不需要使用 <code>.mjs</code> 这种与传统 js 扩展名不同的写法</p>\n<p><strong>使用 flag 指定入口文件模块加载模式</strong></p>\n<p>更新后的方案允许开发者使用 <code>--entry-type=type</code> 的方式来指定入口文件的解析方式，判断行为与 <code>package.json</code> 的 type 一致</p>\n<p><strong>支持新的扩展名 .cjs</strong></p>\n<p>新的扩展名 <code>.cjs</code> 表示在 module 模式的加载环境下去使用 commonjs 来加载扩展名为 <code>.cjs</code> 的模块</p>\n<p><strong>模块加载方式有所改变</strong></p>\n<p>新的 flag：<code>--es-module-specifier-resolution=[type]</code> 的默认值是 <code>explicit</code>，和可选值 <code>node</code>，在默认值的情况下引入模块时必须书写扩展名。</p>\n<blockquote>\n<p>This implies that ./x will only ever import exactly the sibling file “x” without appending paths or extensions. “x” is never resolved to x.mjs or x/index.mjs (or the .js equivalents).</p>\n<p>比方说这里加载 <code>./x</code> 模块，那么默认情况下只会加载名为 <code>x</code> 的模块，而不是去尝试加载 <code>x.mjs</code> 或 <code>x/index.mjs</code></p>\n<p>提案在此：<a href=\"https://github.com/GeoffreyBooth/node-import-file-specifier-resolution-proposal#proposal\">https://github.com/GeoffreyBooth/node-import-file-specifier-resolution-proposal#proposal</a></p>\n</blockquote>\n<p><strong>在 ESM 模式下加载 json 文件</strong></p>\n<p><code>--experimental-json-loader</code> flag 能够在 ESM 模式下加载 JSON 文件。</p>\n<p>导入的 json 文件将提供的 json 文件中的内容转化为一个对象或数组。就好像直接通过 JSON 模块 parse 了一样。</p>\n<p><strong>main 根据 type 的值确认入口文件加载模式</strong></p>\n<p>在 <code>package.json</code> 文件中的 main 字段指定入口文件，根据 type 字段来指定是 commonjs 还是 ESM 模式来加载。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/nodejs/node/pull/26745/commits/b1094dbe19f31f7a69ad16d193748f610b159073\">https://github.com/nodejs/node/pull/26745/commits/b1094dbe19f31f7a69ad16d193748f610b159073</a></li>\n<li><a href=\"https://github.com/GeoffreyBooth/node-import-file-specifier-resolution-proposal#proposal\">https://github.com/GeoffreyBooth/node-import-file-specifier-resolution-proposal#proposal</a></li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/29/169c8b7d668e008f?w=960&amp;h=260&amp;f=jpeg&amp;s=58713\" alt=\"JS 菌公众账号\"></p>\n<p>请关注我的订阅号，不定期推送有关 JS 的技术文章，只谈技术不谈八卦 😊</p>\n</div>","title":"Node 引入 ESM 新方案","last_reply_at":"2019-04-01T10:23:22.960Z","good":false,"top":false,"reply_count":2,"visit_count":803,"create_at":"2019-03-29T09:13:14.005Z","author":{"loginname":"oliyg","avatar_url":"https://avatars1.githubusercontent.com/u/19631785?v=4&s=120"}},{"id":"5a311f729807389a1809f37a","author_id":"57b99bc2dcaeb5d932db220a","tab":"share","content":"<div class=\"markdown-text\"><h1>Web性能</h1>\n<p>从底层计算机网络协议到应用层各个方面去理解Web性能。目前项目处于刚开始阶段，欢迎对性能优化感兴趣的同学共同参与总结！</p>\n<p>Github: <a href=\"https://github.com/laoqiren/web-performance\">https://github.com/laoqiren/web-performance</a></p>\n<h2>目录</h2>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/README.md\">网页渲染原理</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">渲染过程</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.md\">资源加载顺序</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">浏览器优化策略</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/repaint%E4%B8%8Ereflow.md\">repaint与reflow</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/tree/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F\">带宽与延迟</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%BC%80%E5%A7%8B.md\">从输入URL开始</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F.md\">带宽与延迟</a></li>\n<li>TCP协议细节</li>\n<li>HTTP 1.x性能</li>\n<li>针对性优化</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/README.md\">缓存机制</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.md\">首部字段</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA.md\">浏览器行为</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E4%BC%98%E5%8C%96.md\">优化</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/tree/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90\">静态资源</a>\n<ul>\n<li>减少请求</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9.md\">资源压缩</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96.md\">图片资源优化</a></li>\n<li>Webpack</li>\n<li>CDN</li>\n</ul>\n</li>\n<li>Virtual DOM\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E8%99%9A%E6%8B%9FDOM/React%E5%9F%BA%E7%A1%80.md\">React基础</a></li>\n<li>实现</li>\n<li>diff算法</li>\n<li>性能考虑</li>\n</ul>\n</li>\n<li>SPA与SSR\n<ul>\n<li>SPA问题</li>\n<li>服务端渲染</li>\n<li>同构应用</li>\n<li>性能问题</li>\n</ul>\n</li>\n<li>HTTP2\n<ul>\n<li>新特性概览</li>\n<li>性能提升</li>\n<li>工程实践</li>\n</ul>\n</li>\n<li>HTTPS性能影响\n<ul>\n<li>TLS原理</li>\n<li>性能影响</li>\n</ul>\n</li>\n<li>高性能JavaScript\n<ul>\n<li>V8与JIT</li>\n<li>内存泄露</li>\n<li>GC机制</li>\n<li>算法与流程</li>\n<li>Web worker</li>\n</ul>\n</li>\n<li>WebAssembly</li>\n<li>PWA与离线应用</li>\n<li>即时运用与P2P</li>\n<li>Node.js性能优化</li>\n<li>集群与负载均衡</li>\n<li>数据库相关</li>\n<li>性能测试\n<ul>\n<li>Chrome开发者工具</li>\n<li>benchmark</li>\n<li>压力测试</li>\n</ul>\n</li>\n</ul>\n<h2>引用说明</h2>\n<p>此项目会引用许多其他文章书籍的图片或部分内容，我会尽量都加以注明，如果有部分遗漏以致于侵犯到您的版权，烦请联系我修改！此项目旨在整理零碎的知识和实践方案，方便交流学习，请勿用于商业用途。</p>\n<h2>参与贡献</h2>\n<ul>\n<li>提想法和建议</li>\n<li>纠错完善</li>\n<li>增加新章节或内容</li>\n</ul>\n</div>","title":"性能优化知识与实践整理","last_reply_at":"2019-04-01T09:47:23.208Z","good":false,"top":false,"reply_count":16,"visit_count":6792,"create_at":"2017-12-13T12:39:14.755Z","author":{"loginname":"laoqiren","avatar_url":"https://avatars2.githubusercontent.com/u/16136702?v=4&s=120"}},{"id":"5ca1cdc231010b2dfbb41ded","author_id":"571053a36a2d2bda52de95ce","tab":"ask","content":"<div class=\"markdown-text\"><p>请求各位大佬，有个react问题，我在组件中写个了定时器同步系统时间，然后用鼠标滑动选择antd库下拉框时，每隔一秒，滑动条就会重新回到顶部，这如何解决？\n已经查明原因是 定时器每秒执行一次render导致的；但还不知道如何解决，菜鸟求助啊</p>\n</div>","title":"react 定时器 select下拉框出现问题","last_reply_at":"2019-04-01T08:37:22.812Z","good":false,"top":false,"reply_count":0,"visit_count":343,"create_at":"2019-04-01T08:37:22.812Z","author":{"loginname":"RocketV2","avatar_url":"https://avatars2.githubusercontent.com/u/12555991?v=4&s=120"}}]}